{"id": "7d3XD8", "name": "progressive random gradients ", "author": "FabriceNeyret2", "description": "Progressive variant of https://shadertoy.com/view/fscSWH where you (almost) don't see the white pixels appearing.\nClick to see the difference.", "tags": ["gradient", "hash", "dithering", "bluenoise", "whitenoise"], "likes": 8, "viewed": 322, "published": 3, "date": "1633020918", "time_retrieved": "2024-07-30T18:58:31.662451", "image_code": "// Progressive variant of https://shadertoy.com/view/fscSWH\n// Eulerian variant of https://www.shadertoy.com/view/fdcXWH\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(c)     texelFetch(c, ivec2(u) % textureSize(c,0).xy, 0).x \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R;\n    u.x += float(iFrame);\n    U = u / R;\n\n    float h =    P.y > .66 ? hash(U)\n               : P.y > .33 ? T(iChannel0) \n               :             T(iChannel1);\n    O = vec4 ( iMouse.z > 0. ? step(P.x,h)               // raw thresholding\n                             : R.x/64.* ( h - P.x) +.5   // progressive appear\n             );             // 10.\n    if ( int(u.y)*3 % int(R.y) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 302, 302, 782]], "test": "untested"}
{"id": "3lfBW8", "name": "rep3109847", "author": "lennyjpg", "description": "sdfdssdfsdf", "tags": ["ddfsdfdf"], "likes": 1, "viewed": 225, "published": 3, "date": "1633019003", "time_retrieved": "2024-07-30T18:58:32.442366", "image_code": "\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n\nfloat layer(vec2 uv, vec2 offset, float s, float t){\n   uv += offset * t * 100.4;\n   uv = rotate2D(uv, t);\n   float p = mod(uv.x/  s, 1.0);\n  // return smoothstep(p, p * 1.01, 0.5);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 f = fragCoord.xy;\n\n    float t = iTime * 0.01;\n    vec2 u = uv;\n    \n    float a = layer(f, vec2(0.0, 3.0), 500.0, t * -4.4);\n    float b = layer(f, vec2(3.3, 0.5), 100.0, t * 2.432);\n    float c = layer(f, vec2(2.2, -3.3), 50.0, t * -1.32);\n\n    float k = a - b + c;\n    \n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 181], [184, 184, 236, 236, 381], [383, 383, 440, 440, 789]], "test": "untested"}
{"id": "fstSWn", "name": "Isozig (RAA)", "author": "paniq", "description": "dipole based field rendered with revised affine arithmetic. ", "tags": ["raymarching", "dipole", "raa", "winding"], "likes": 8, "viewed": 442, "published": 3, "date": "1633013312", "time_retrieved": "2024-07-30T18:58:33.541428", "image_code": "// uncomment for simple interactive six point demo\n//#define TEST_SIXAXIS\n\n\n#define MAX_LEVEL 16u\n#define MAX_STEPS 100\n\n// revised affine form of rank 1\nstruct raf1 {\n    float x0;\n    float x1;\n    float e;\n};\n\nstruct raf1x3 {\n    raf1 x;\n    raf1 y;\n    raf1 z;\n};\n\nraf1 ra_const(float x) {\n    return raf1(x, 0.0, 0.0);\n}\nfloat ra_radius(raf1 a) {\n    return abs(a.x1) + a.e;\n}\nvec2 ra_interval(raf1 a) {\n    float r = ra_radius(a);\n    return vec2(a.x0 - r, a.x0 + r);\n}\n\nraf1 ra_add(raf1 a, raf1 b) {\n\treturn raf1(a.x0 + b.x0, a.x1 + b.x1, a.e + b.e);\n}\nraf1 ra_add(raf1 a, float b) {\n\treturn raf1(a.x0 + b, a.x1, a.e);\n}\nraf1 ra_add(float a, raf1 b) {\n\treturn raf1(a + b.x0, b.x1, b.e);\n}\nraf1x3 ra_add(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_add(a.x,b.x),ra_add(a.y,b.y),ra_add(a.z,b.z));\n}\n\nraf1 ra_sub(raf1 a, raf1 b) {\n\treturn raf1(a.x0 - b.x0, a.x1 - b.x1, a.e + b.e);\n}\nraf1 ra_sub(raf1 a, float b) {\n\treturn raf1(a.x0 - b, a.x1, a.e);\n}\nraf1 ra_sub(float a, raf1 b) {\n\treturn raf1(a - b.x0, -b.x1, b.e);\n}\nraf1x3 ra_sub(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_sub(a.x,b.x),ra_sub(a.y,b.y),ra_sub(a.z,b.z));\n}\n\nraf1 ra_neg(raf1 a) {\n\treturn raf1(-a.x0, -a.x1, a.e);\n}\n\nraf1 ra_mul(raf1 a, raf1 b) {\n    float s = abs(a.x1);\n    float t = abs(b.x1);\n    float w = dot(a.x1, b.x1);\n    float u = s;\n    float v = t;\n    return raf1(\n        a.x0 * b.x0 + 0.5 * w,\n        a.x0 * b.x1 + a.x1 * b.x0,\n        a.e * b.e\n        + b.e * (abs(a.x0) + u)\n        + a.e * (abs(b.x0) + v)\n        + u * v\n        - 0.5 * dot(s, t));\n}\nraf1 ra_mul(raf1 a, float b) {\n    return raf1(\n        a.x0 * b,\n        a.x1 * b,\n        a.e * abs(b));\n}\nraf1 ra_mul(float a, raf1 b) {\n    return ra_mul(b, a);\n}\nraf1x3 ra_mul(raf1 a, vec3 b) {\n\treturn raf1x3(ra_mul(a,b.x),ra_mul(a,b.y),ra_mul(a,b.z));\n}\n\nraf1 ra_rcp(raf1 a) {\n    vec2 i = ra_interval(a);\n    float i0i1 = i[0]*i[1];\n    if (i0i1 < 0.0) {\n        return raf1(1.0/a.x0, 0.0, 1.0/0.0);\n    } else {\n        vec2 ab = 1.0 / i;\n        float h = sign(i[0]) / sqrt(i0i1);\n        float c = (ab[0]+ab[1]) * 0.5;\n        float nalpha = ab[0] * ab[1];\n        float alpha = -nalpha;\n        float zeta = c + h;\n        float delta = abs(c-h);\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            nalpha * a.e + delta);\n    }\n}\n\nraf1 ra_div(raf1 a, raf1 b) {\n    return ra_mul(a, ra_rcp(b));\n}\n\nraf1 ra_pow2(raf1 a) {\n    float w = 0.5 * a.x1 * a.x1;\n    return raf1(\n        a.x0 * a.x0 + w,\n        2.0 * a.x0 * a.x1,\n        a.e * (1.0 + 2.0 * (abs(a.x0) + abs(a.x1))) + w);\n}\n\nraf1 ra_dot(raf1x3 a, raf1x3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a, vec3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a) {\n    return ra_add(ra_add(ra_pow2(a.x),ra_pow2(a.y)),ra_pow2(a.z));\n}\n\nraf1 ra_sqrt(raf1 x) {\n    vec2 i = ra_interval(x);\n    if (i[1] < 0.0) return ra_const(0.0);\n    i[0] = max(i[0], 0.0);\n    vec2 sq = sqrt(i);\n    float c = sq[1] + sq[0];\n    float h = sq[1] - sq[0];\n    float alpha = 1.0 / c;\n    float dzeta = c / 8.0 + 0.5 * sq[0] * sq[1] / c;\n    float delta = h * h / (8.0 * c);\n    return raf1(\n        alpha * x.x0 + dzeta,\n        alpha * x.x1,\n        alpha * x.e + delta);\n}\n\nraf1 ra_length(raf1x3 a) {\n    return ra_sqrt(ra_dot(a));\n}\n\nraf1 ra_abs (raf1 a) {\n    vec2 i = ra_interval(a);\n    if (i[0]*i[1] >= 0.0) {\n        return raf1(abs(a.x0), a.x1 * sign(a.x0), a.e);\n    } else {\n    #if 0\n        // keep ambiguous case in a box\n        vec2 j = abs(i);\n        i = (i[0]>=0.0)?j:(i[1]<0.0)?j.yx:vec2(0.0,max(j[0],j[1]));\n        return raf1((i[0]+i[1])*0.5, 0.0, (i[1]-i[0])*0.5);\n    #else\n        vec2 ab = abs(i);\n        float alpha = (ab[1] - ab[0]) / (i[1] - i[0]);\n        float zeta = (ab[0] - i[0] * alpha) * 0.5;\n        float delta = zeta;\n\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            abs(alpha) * a.e + delta);\n\t#endif\n    }\n}\n\n// crude approximation for min/max\n// there are more opportunities for truncation here, as only\n// the overlapping parallelogram and either one or both top parts (max)\n// or bottom parts (min) of each argument need to be bounded.\n// e.g. if all minimum values of a are above the minimum values of b,\n// regardless of any overlapping, only a needs to be considered for max(a,b).\n\nraf1 ra_max(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[0] >= ib[1])\n        return a;\n    else if (ib[0] >= ia[1])\n        return b;\n    else {\n\t    return ra_mul(ra_add(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_min(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[1] <= ib[0])\n        return a;\n    else if (ib[1] <= ia[0])\n        return b;\n    else {\n\t    return ra_mul(ra_sub(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_zero(raf1 x, raf1 y) {\n    float dxdy = x.x1 / y.x1;\n    return raf1(x.x0 - dxdy * y.x0, dxdy * y.e, 0.0);\n}\n\nvec2 get_range(uint c, uint level) {\n#if 1\n    float r = exp2( -float(level) );\n    const float k = exp2( -float(MAX_LEVEL) );\n    float center = (float(c)*k) * 2.0 - 1.0 + r;\n#else\n    float r = 1.0 / float(1u << level);\n    float center = (float(c) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;\n#endif\n    center += 1.0;\n    return vec2(center, r);\n}\n\nuint find_lsb(uint value) {\n#if 1\n    // findLSB() hack\n    return uint(log2(float(value & -value)));\n#else\n    // with GL4, this loop can be replaced with\n    // a single use of findLSB()\n    uint count = 0u;\n    for (uint i = 0u; i < MAX_LEVEL; ++i) {\n        if ((value & 1u) != 0u)\n            break;\n        count += 1u;\n        value >>= 1u;\n    }\n    return count;\n#endif\n}\n\nuint lowest_level(uint p) {\n    uint used_levels = min(MAX_LEVEL, find_lsb(p));\n    return MAX_LEVEL - used_levels;\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nconst float PI = 3.14159265359;\n\nraf1 ra_dipole(raf1x3 p, vec3 n, float a) {\n    raf1 u = ra_dot(p, -n*a);\n    raf1 v = ra_dot(p);\n    v = ra_mul(v, ra_sqrt(v));\n    return ra_div(u, v);\n}\n\nraf1 ra_map( raf1x3 p ) {\n#if 0\n    p.y = ra_add(p.y, 0.3);\n    raf1 d = ra_const(0.0);\n    const int N = 80;\n    float u = sin(iTime)*0.5+0.5;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i);\n        float a = x * 2.39996322972865332;\n        vec2 n = vec2(cos(a), sin(a));\n        float r = (x + 1.0) / float(N);\n        float h = mix(x / float(N), 1.0 - x / float(N),u);\n        float A = r*0.2;//pow(r,2.5)*0.3;//4.0 * PI 1 r * r / 8.0;\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(n.x*r, h, n.y*r)), normalize(vec3(n.x, u*2.0-1.0, n.y)), A));\n    }\n    \n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#elif defined(TEST_SIXAXIS)\n    float r = 0.5;\n    float a = 4.0 * PI * r * r / 6.0 * (iMouse.y / iResolution.y) * 4.0;\n    raf1 d = ra_dipole(ra_sub(p, vec3(r, 0.0, 0.0)), normalize(vec3(cos(iTime), sin(iTime), 0.0)), a);\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(-r, 0.0, 0.0)), normalize(vec3(-1.0, 0.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, r, 0.0)), normalize(vec3(0.0, 1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, -r, 0.0)), normalize(vec3(0.0, -1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, r)), normalize(vec3(0.0, 0.0, 1.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -r)), normalize(vec3(0.0, 0.0, -1.0)), a));\n\n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#else\n    const int N = 8;\n    float A = 4.0 * PI * 0.25 / float(N) * 0.25;\n\n    raf1 d = ra_const(0.0);\n    for (int i = 0; i < N; ++i) {\n        float q = float(i)/float(N);\n        float a = q * 2.0 * PI;\n        float w0 = sin(a*3.0 + 0.1*iTime*2.0*PI);\n        float ae = a + w0*2.0*PI;\n        float s = sin(a);\n        float c = cos(a);\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(c, s, 0.0)*0.5), normalize(vec3(cos(ae), sin(ae), 0.0)), A*(w0*0.5+0.5)*8.0));\n    }    \n    //d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -0.5)), normalize(vec3(0.0, 0.0, 1.0)), A*32.0));\n    \n    d = ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n    return d;\n#endif\n}\n\nraf1x3 ra_grad(vec3 pos, vec3 eps) {\n    return raf1x3(raf1(pos.x, eps.x, 0.0), raf1(pos.y, eps.y, 0.0), raf1(pos.z, eps.z, 0.0));\n}\n\nvec3 gradient( in vec3 pos ) {\n    const float eps = 0.001;\n\n    return -normalize(vec3(ra_map(ra_grad(pos, vec3(eps,0,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,eps,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,0,eps))).x1));\n}\n\nfloat calcIntersectionRA( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n    float threshold = get_range(0u, MAX_LEVEL).y;        \n    uint p = 0u;\n    uint level = 0u;\n    float maxd = 10.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        steps = i;\n        const uint topstep = 1u << MAX_LEVEL;\n        if (p >= topstep)\n            break;\n        vec2 rc = get_range(p, level);\n        raf1 t = raf1(rc.x, rc.y, 0.0);\n        raf1 d = ra_map(ra_add(ra_mul(t, rd * maxd), ro));\n        uint stepsz = topstep >> level;\n        // visualize interval\n        vec2 iv = ra_interval(d);\n        // interval crosses zero?\n        bool hit = (iv.x*iv.y < 0.0);\n        if (hit) {\n            // if we have prematurely reached our\n            // desired precision, exit early                \n            if ((d.e <= threshold) || (level == MAX_LEVEL)) {\n                vec2 pr = ra_interval(ra_zero(raf1(rc.x,rc.y,0.0), d));\n                return maxd * (pr[0]+pr[1])/2.0;\n            }\n            // reached maximum precision\n            if (level == MAX_LEVEL)\n                break;\n        }\n        if (hit && (level < MAX_LEVEL)) {\n            level += 1u;\n        } else {\n            p += stepsz;\n            level = lowest_level(p);\n        }\n    }\n    return -1.0;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, out vec3 normal, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n    vec2 m = (-resolution.xy + 2.0*iMouse.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,6.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    float w = (iMouse.z > 0.5)?m.x:0.0;\n\n\t// raymarch\n    float t = calcIntersectionRA( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        normal = -gradient(position);\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;\n\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    vec3 normal;\n    int steps;\n    bool hit = dorender(dist, steps, pos, normal, fragCoord, resolution, 1.0);\n\n    fragColor = vec4(vec3(0.0),1.0);\n#if 0\n    if (hit) {\n        vec3 nor = calcNormal(pos);\n        fragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n    }\n#else\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    ivec3 p = ivec3(pos*10.0);\n    c2 = mix(c2, vec3(float((p.x ^ p.y ^ p.z) % 3)/2.0), 0.1);    \n\n    fragColor = vec4(normal*0.5+0.5,1.0);\n#endif\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 293, 293, 325], [326, 326, 351, 351, 381], [382, 382, 408, 408, 475], [477, 477, 506, 506, 559], [560, 560, 590, 590, 627], [628, 628, 658, 658, 695], [696, 696, 729, 729, 796], [798, 798, 827, 827, 880], [881, 881, 911, 911, 948], [949, 949, 979, 979, 1017], [1018, 1018, 1051, 1051, 1118], [1120, 1120, 1141, 1141, 1176], [1178, 1178, 1207, 1207, 1533], [1534, 1534, 1564, 1564, 1642], [1643, 1643, 1673, 1673, 1700], [1701, 1701, 1732, 1732, 1793], [1795, 1795, 1816, 1816, 2314], [2316, 2316, 2345, 2345, 2380], [2382, 2382, 2404, 2404, 2566], [2568, 2568, 2601, 2601, 2682], [2684, 2684, 2715, 2715, 2796], [2798, 2798, 2821, 2821, 2890], [2892, 2892, 2914, 2914, 3311], [3313, 3313, 3339, 3339, 3372], [3374, 3374, 3396, 3396, 4031], [4412, 4412, 4441, 4441, 4675], [4677, 4677, 4706, 4706, 4940], [4942, 4942, 4972, 4972, 5058], [5411, 5411, 5438, 5438, 5791], [5793, 5793, 5820, 5820, 5910], [5913, 5913, 5996, 5996, 6119], [6121, 6121, 6148, 6148, 6183], [6218, 6218, 6261, 6261, 6373], [6375, 6375, 6400, 6400, 8443], [8445, 8445, 8481, 8481, 8577], [8579, 8579, 8609, 8609, 8832], [8834, 8834, 8925, 8925, 10128], [10131, 10131, 10195, 10195, 10373], [10375, 10375, 10512, 10512, 11504], [11506, 11506, 11532, 11532, 11617], [11619, 11667, 11692, 11692, 11750], [11753, 11753, 11809, 11809, 12393]], "test": "untested"}
{"id": "NscSDH", "name": "paint conserving average color", "author": "FabriceNeyret2", "description": "reverse LOD, or TopDown painting:\nuser first sketched the colors at low res ( here, the dark olive color )\nthen zoom to add details while preserving the local average color ( painter above ).\nMore natural way to design natural as well as anatomical scenes", "tags": ["mipmap", "paint", "topdown", "lop"], "likes": 3, "viewed": 341, "published": 3, "date": "1633012153", "time_retrieved": "2024-07-30T18:58:34.672404", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = U.x/R.x>.1 ? T(U)                              // show paint\n                   : texelFetch(iChannel1,ivec2(U),0); // show palette\n    \n    float d = length(U-.95*R);                         // show target color\n    O = mix( O, vec4(0), S(d-R.y/14.) );\n    O = mix( O, target,  S(d-R.y/15.) );\n    \n // O = pow( O, vec4(1./2.2) ); // should be converted to sRGB, but then I need better hue\n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// =========== paint manager =====================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n     vec4 paint = texelFetch(iChannel1,ivec2(0),0); // vec4(0,1,0,1) + 1e-5;\n\n   if ( iFrame < 1 ) { O = target ; return; } \n    O = T(U);\n    \n    vec4 T = texture(iChannel0, U/R, 99.);\n    // goal: replace target  with ~ texture(iChannel0, U/R, 7.)\n    O *= target / mix(T, paint, 3.14*20.*20./R.x/R.y );\n    O = mix( O, paint, S(length(U-iMouse.xy)-20. ) );\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define target   vec4(.3,.6, .1, 1) // target average color\n\n// --- utils https://www.shadertoy.com/view/llySRh\n#define T(U)     texelFetch(iChannel0, ivec2(U), 0 )\n#define R        iResolution.xy\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define S(v)     smoothstep(1.5,0.,v)", "buffer_b_code": "// =========== palette manager ===========================\n\nvec4 col( vec2 U ) {\n    float x = U.x/.05 - 1.;\n    return x < 0. ? hue(U.y)*(1.+x) : mix(hue(U.y),vec4(1), x);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R, M = iMouse.xy/R;\n    if ( U.x > .1 ) return;\n   \n    O = u == vec2(.5)\n         ? iMouse.z>0. && M.x < .1 ? col(M) : T(u)\n         : col(U);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 439]], "test": "untested"}
{"id": "fdcXWH", "name": "random point gradients:  h/t/b", "author": "FabriceNeyret2", "description": "point distribution gradient, rather than pixel noise gradient as in https://shadertoy.com/view/fscSWH\nclick to see tiles.\ntop: pos = white noise  procedural ( float hash )\nmid: pos = white noise  texture\nbottom: pos = blue noise ( no effect here :-) ).", "tags": ["gradient", "poisson", "hash", "dithering", "bluenoise", "whitenoise", "pointdistribution"], "likes": 4, "viewed": 402, "published": 3, "date": "1633006205", "time_retrieved": "2024-07-30T18:58:35.548062", "image_code": "// Lagrangian variant of https://shadertoy.com/view/fscSWH\n\n#define hash(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(c)     texelFetch(c, ivec2(U) % textureSize(c,0).xy, 0).xy \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R, T,D,H;\n    u.x += float(iFrame);\n    T = u / 16.;\n    O-=O;\n    float d = 99.;\n    for ( float i=0.; i < 256.*(1.-P.x); i++ ) {\n        U = floor(T) + i*13.7;\n        H =   P.y > .66 ? hash(U)\n            : P.y > .33 ? T(iChannel0) \n            :             T(iChannel1);\n        D = fract(T) - H;\n        d = min(d, dot(D,D));\n     // O = max(O, 1.3 - 16.*sqrt(d) );\n     // O += (1.-O) * clamp( 1.3 - 16.*sqrt(d) , 0.,1.);\n    }\n        \n    O = vec4( 1.3 - 16.*sqrt(d) );   // draw closest point\n    if ( int(u.y) % (int(R.y)/3) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n    u = fract((u-.5)/16.);\n    if ( iMouse.z>0. && u.x*u.y==0.) O = vec4(0,0,1,1);    // if click, draw grid\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fscSWH", "name": "random gradients: hash / tex / b", "author": "FabriceNeyret2", "description": "noise gradient.\ntop: white noise  procedural ( float hash )\nmid: white noise  texture\nbottom: blue noise", "tags": ["gradient", "hash", "dithering", "bluenoise", "whitenoise"], "likes": 12, "viewed": 402, "published": 3, "date": "1633004942", "time_retrieved": "2024-07-30T18:58:36.370862", "image_code": "// Eulerian variant of https://www.shadertoy.com/view/fdcXWH\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(c)     texelFetch(c, ivec2(u) % textureSize(c,0).xy, 0).x \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R;\n    u.x += float(iFrame);\n    U = u / R;\n\n    O = vec4( (   P.y > .66 ? hash(U)\n                : P.y > .33 ? T(iChannel0) \n                :             T(iChannel1)\n              ) > P.x );\n    if ( int(u.y)*3 % int(R.y) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 242, 242, 558]], "test": "untested"}
{"id": "fscSD8", "name": "Phawq of Lovely Bubbles", "author": "xenn", "description": "It appears that I am unable tio have the bubbles leave behind colourful trails like michael does in this video https://www.youtube.com/watch?v=nqxVMLVe62U&ab_channel=TheJacksonsVEVO\n\nso I did some other rubbish. as yet unfinished", "tags": ["bubbles"], "likes": 7, "viewed": 360, "published": 3, "date": "1632996169", "time_retrieved": "2024-07-30T18:58:37.474911", "image_code": "// Fork of \"Lovely Bubbles Fawq\" by xenn. https://shadertoy.com/view/fddSz7\n// 2021-09-30 10:00:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ob, nb, a;\n    ob = texture(iChannel0, uv).rgb;\n    nb = texture(iChannel1, uv).rgb;\n    vec3 xb = texture(iChannel2, uv).rgb;\n    xb += (xb * xb) - xb;\n    \n    //a = col * len\n    a = vec3(0.5 * (abs(sin(iTime / 3.0))), 0.25, 0.5 * (1.1 * (abs(cos(iTime / 3.0))))) * .5;\n\n    fragColor = min(vec4(mix(ob, nb, (a / 0.50)), 1.),(xb,1.));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if USE_THIN_FILM_LOOKUP\n    {\n        int segmentCount = 32;\n        int segment = iFrame % segmentCount;\n        int currSegment = int(floor((fragCoord.y * float(segmentCount) / iResolution.y)));\n        \n        if ( segment != currSegment )\n        {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            return;\n        }\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec3 result = GetThinFilmColour(uv.x, uv.y);  \n\n    fragColor = vec4(result,1.0);\n#else\n    discard;\n#endif\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.058\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}", "buffer_b_code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.5;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n    vec3 envMap = texture(iChannel1, dir).rgb;\n    envMap = envMap * envMap;\n    float kEnvmapExposure = 0.99999;\n    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.0f - (1.0f - fresnelA) * (1.0f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.5, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 200.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = 1.0;\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n //   colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 2.5;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .65;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .042;\nconst float iBlob2Radius              = .7;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       =  0.05;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * (iBlob1ColorPulseSpeed / -1.5), 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * (iBlob2ColorPulseSpeed / -1.5) + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n //   prevColor = mix(prevColor, prevColor2, 0.0995);\n    prevColor = min(prevColor, prevColor2);\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This buffer is the feedback loop\n\n// iq noise\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n// hue by netgrind(?)\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat fractalNoise(vec2 pos) {\n\tfloat n = 0.;\n\tfloat scale = 1. / 1.5;\n\tfor (int i = 0; i < 5; i += 1) {\n\t\tn += noise(pos) * scale;\n\t\tscale *= 0.5;\n\t\tpos *= 2.;\n\t}\n\treturn n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.5 - fractalNoise(vec2(sin(angle*4. + iTime*2.) + length(uv)*10., length(uv)*20. + sin(angle*4.)))*0.005 ;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1, offs.xy).rgb;\n    \n    // Since the colors of the iChannel0 are monochrome, set a color channel to zero to do a hue shift\n //   base.b = 0.0;\n    \n    // Apply a hue shift to the overlaid image so it cascades in the feedback loop\n    overlay = hue(overlay, .5);\n      overlay += (base + base) * (overlay / .50);\n    \n    // Additively blend the colors together\n    vec4 col = vec4(clamp(vec3(0.),vec3(1.),base + overlay*0.99), 1.0);\n    \n   // col *= (col + col) * (overlay,1.0);\n    //(overlay,1.0);\n    \n    fragColor = col ;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 157, 157, 553]], "test": "untested"}
{"id": "fscXW8", "name": "britney spirals", "author": "abje", "description": "teacher was gone so i made this with my bros ", "tags": ["spiral"], "likes": 2, "viewed": 245, "published": 3, "date": "1632994120", "time_retrieved": "2024-07-30T18:58:38.243855", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec2 ab = vec2(0);\n    ab.x = atan(uv.x, uv.y)/6.28*4.0;\n    ab.y = length(uv);\n    \n    ab.y = 1.0/ab.y;\n    ab.y += iTime;\n    ab.x -= iTime*0.5;\n    ab.x += ab.y*0.3;\n    \n    vec4 col = texture(iChannel1, ab);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 444]], "test": "untested"}
{"id": "sscSWn", "name": "Vaporwave Outrun", "author": "noobdawn", "description": "Vaporwave Style Outrun", "tags": ["outrun", "vaporwave", "synthwave"], "likes": 12, "viewed": 931, "published": 3, "date": "1632983119", "time_retrieved": "2024-07-30T18:58:39.084607", "image_code": "#define PI 3.14159265358979\n#define SPEED 0.25\n#define GRID_COUNT 32.\n#define STEP 0.005\n#define COUNT 256.\n#define HEIGHT 0.25\n#define SUN_SPEED 0.3\n\nvec3 GetBackgroundColor(in vec3 ray)\n{\n    vec3 c0 = vec3(115. / 255., 25. / 255., 171. / 255.);\n    vec3 c1 = vec3(235. / 255., 51. / 255., 201. / 255.);\n    vec3 c2 = vec3(40. / 255., 7. / 255., 80. / 255.);\n    float a = fract(iTime * 0.5) * 2.0;\n    a = a > 1.0 ? 2.0 - a : a;\n    vec3 c = c0 * a + c2 * (1.0 - a);\n    a = pow(1.0 - abs(ray.y), 0.25);\n    float b = abs(atan(ray.x / ray.z)) / PI;\n    float m = texture(iChannel1, vec2(b * 0.05, fract(iTime * 0.00005))).x;\n    a = 0.85 * a - 0.05 * m;\n        \n    c = c1 * a + c * (1.0 - a);\n    return c;\n}\n\nbool GetHitWithPlane(in vec3 o, in vec3 ray, out vec3 hitPoint)\n{\n    bool hit = false;\n    hitPoint = vec3(0.0, 0.0, 0.0);\n    float realHeight = 0.;\n    float preRealHeight = 0.;\n    float _step = STEP;// min(STEP / abs(ray.y), 2. * STEP);\n    for (float i = 1.; i <= COUNT; i++)\n    {\n        vec3 current = o + ray * _step * i;\n        realHeight = texture(iChannel0, current.xz / 16.).x * HEIGHT;\n        float s = abs(current.x - o.x) / 0.5;\n        s = clamp(s * s, 0., 1.);\n        realHeight *= s;\n        if (current.y < realHeight)\n        {\n            vec3 last = current - ray * _step;\n            float preDiff = last.y - preRealHeight;\n            float curDiff = realHeight - current.y;\n            float t = preDiff / (preDiff + curDiff);\n            current = last + ray * _step * t;      \n            hitPoint = current;\n            return true;\n        }\n        preRealHeight = realHeight;\n    }\n    return hit;\n}\n\nvec3 GetHitPointColor(in vec3 cameraPos, in vec3 hitPoint, in vec3 background)\n{\n    float fx = abs(fract(hitPoint.x * GRID_COUNT + 0.5) - 0.5);\n    float fz = abs(fract(hitPoint.z * GRID_COUNT + 0.5) - 0.5);\n\n    vec3 b = vec3(0.2, 0.6, 0.9);\n    vec3 r = background;\n    r.x = pow(r.x, 3.3);\n    r.y = pow(r.y, 0.7);\n    r.z = pow(r.z, 0.5);\n    float d = length(hitPoint.xz - cameraPos.xz) * 0.15;\n    d = clamp(d, 0., 1.);\n    vec3 col = r * d + b * (1. - d);\n    float li = texture(iChannel0, hitPoint.xz / 64. + vec2(0, -iTime * 0.005)).x * 0.5 + 0.5;\n    float lo = abs(hitPoint.z - cameraPos.z) + 0.3;\n    col /= min(li, lo);\n    \n    \n    d = min(fx, fz);\n    d = smoothstep(d, 0., 0.02);\n    \n    return r * d + col * (1. - d);\n}\n\nvec4 GetSun(in vec3 cameraPos, in vec3 ray)\n{\n    if (dot(ray, normalize(vec3(0.0, 0.035, 1.0))) > 0.96)\n    {\n        vec4 r = vec4(1., 0., 0., 1.);\n        vec4 y = vec4(2., 2., 0., 1.);\n        float a = abs(ray.y);\n        vec4 col = y * a + r * (1. - a);\n        \n        float ft = fract(iTime * SUN_SPEED) * 0.25;\n        vec2 l0 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.25) * 0.25;\n        vec2 l1 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.5) * 0.25;\n        vec2 l2 = vec2(-ft + 0.05, ft * 0.2);\n        ft = fract(iTime * SUN_SPEED + 0.75) * 0.25;\n        vec2 l3 = vec2(-ft + 0.05, ft * 0.2);\n        return col * (1. - \n                      step(l0.x - l0.y, ray.y) * step(ray.y, l0.x + l0.y) -\n                      step(l1.x - l1.y, ray.y) * step(ray.y, l1.x + l1.y) -\n                      step(l2.x - l2.y, ray.y) * step(ray.y, l2.x + l2.y) -\n                      step(l3.x - l3.y, ray.y) * step(ray.y, l3.x + l3.y)\n                      );\n        \n        return col * \n                (step(ray.y, -0.03) + \n                 step(0., ray.y) * step(ray.y, 0.04) +\n                 step(0.06, ray.y) * step(ray.y, 0.11) +\n                 step(0.13, ray.y) * step(ray.y, 0.18) +\n                 step(0.195, ray.y)\n                 );\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec4 GetScreenColor(in vec3 ray, in vec3 cameraPos)\n{\n    vec3 background = GetBackgroundColor(ray);\n    bool hit;\n    vec3 hitPoint;\n    hit = GetHitWithPlane(cameraPos, ray, hitPoint);\n    vec3 plane = GetHitPointColor(cameraPos, hitPoint, background);\n    if (hit)\n        return vec4(plane, 1);\n    vec4 sun = GetSun(cameraPos, ray);\n    \n    return vec4(background * (1.0 - sun.w) + sun.xyz * sun.w, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv * 2.0 - 1.0;\n    cuv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(cuv.x, cuv.y, 1.2));\n    \n    float ix = PI * 0.5 + (iMouse.x / iResolution.x) * PI;\n    float iy = iMouse.y / iResolution.y * PI * 0.25;\n    \n    vec3 f = vec3(\n        cos(ix) * cos(iy),\n        sin(iy),\n        sin(ix) * cos(iy)\n    );\n    f = normalize(f);\n    vec3 u = vec3(0.0, 1.0, 0.0);\n    vec3 r = normalize(cross(f, u));\n    u = normalize(cross(r, f));\n    \n    \n    fragColor = GetScreenColor(normalize(f * ray.z + u * ray.y + r * ray.x), vec3(0.0, 0.1, iTime * SPEED));\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 189, 189, 713], [715, 715, 780, 780, 1650], [1652, 1652, 1732, 1732, 2391], [2393, 2393, 2438, 2438, 3750], [3752, 3752, 3805, 3805, 4163], [4165, 4165, 4222, 4222, 4852]], "test": "untested"}
{"id": "7dtSDn", "name": "ZCAM chroma/hue sweep (sRGB)", "author": "kdrag0n", "description": "sRGB gamut visualization in ZCAM (Oklab: mouse down), with maximum chroma per color.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "cam", "srgb", "colorscience", "oklab", "zcam"], "likes": 2, "viewed": 400, "published": 3, "date": "1632970616", "time_retrieved": "2024-07-30T18:58:40.266447", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nconst float LR_K1 = 0.206;\nconst float LR_K2 = 0.03;\nconst float LR_K3 = (1.0 + LR_K1) / (1.0 + LR_K2);\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    return vec3(L, a, b);\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * OkLrab\n */\n\nvec3 xyzToOklrab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    float Lr = (LR_K3*L - LR_K1 + sqrt(square(LR_K3*L - LR_K1) + 4.0*LR_K2*LR_K3*L)) / 2.0;\n\n    return vec3(Lr, a, b);\n}\n\nvec3 oklrabToXyz(vec3 c) {\n    float Lr = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float L = (Lr * (Lr + LR_K1)) / (LR_K3 * (Lr + LR_K2));\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklrab(vec3 c) {\n    return xyzToOklrab(linearSrgbToXyz(c));\n}\n\nvec3 oklrabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklrabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    //float Sz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n    //float Qz = (Jz / 100.0) * Qz_w;\n    //float Cz = (Qz * square(Sz)) / (100.0 * Qz_w * pow(cond.F_l, 1.2));\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipCielchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = xyzToLinearSrgb(cielabToXyz(lchToLab(lch)));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid, hue))));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid2, hue))));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipOklchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = oklabToLinearSrgb(lchToLab(lch));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = oklabToLinearSrgb(lchToLab(vec3(lightness, mid, hue)));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = oklabToLinearSrgb(lchToLab(vec3(lightness, mid2, hue)));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessOklrab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklrab = lchToLab(lch);\n    return oklrabToLinearSrgb(oklrab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendOklch(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = labToLch(linearSrgbToOklab(srgbTransferInv(lhsRgb)));\n    vec3 rhs = labToLch(linearSrgbToOklab(srgbTransferInv(rhsRgb)));\n    rhs.z = lhs.z;\n    return clipOklchToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklab(srgbTransferInv(rhsRgb));\n    return oklabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklrab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklrab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklrab(srgbTransferInv(rhsRgb));\n    return oklrabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Chroma/hue sweep\n */\n\nvec3 chromaHueSweepZcam(vec2 uv) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipZcamJchToLinearSrgb(vec3(lightness, chroma, hue), cond);\n}\n\nvec3 chromaHueSweepOklab(vec2 uv) {\n    float lightness = uv.y;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipOklchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\nvec3 chromaHueSweepCielab(vec2 uv) {\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipCielchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Blue demo - ZCAM\n    /*ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    //blue.hueAngle = hue;\n    //blue.hueAngle = 33.44; // red\n    //blue.hueAngle = 89.29; // yellow\n    //blue.hueAngle = 146.30; // green\n    //blue.hueAngle = 238.36; // blue\n    if (uv.y >= 0.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(uv.x * 100.0, blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, uv.x * blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.hueAngle) < 0.5) ? blue.chroma : 10.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, 500.0, hue), cond);\n    }*/\n\n    // Blue demo - CIELAB\n    /*vec3 blue = labToLch(xyzToCielab(linearSrgbToXyz(vec3(0.0, 0.0, 1.0))));\n    if (uv.y >= 0.0) {\n        camOut = clipCielchToLinearSrgb(vec3(uv.x * 100.0, blue.y, blue.z));\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 21.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, chroma, hue));\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, 500.0, hue));\n    }*/\n\n    // Blue demo - Oklab\n    /*if (iMouse.z > 0.0) {\n        vec3 blue = labToLch(linearSrgbToOklab(vec3(0.0, 0.0, 1.0)));\n        //blue.z = hue;\n        if (uv.y >= 0.0) {\n            camOut = clipOklchToLinearSrgb(vec3(uv.x, blue.y, blue.z));\n        }\n        if (uv.y >= 1.0/3.0) {\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n        }\n        if (uv.y >= 2.0/3.0) {\n            float hue = uv.x * 360.0;\n            float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 0.07;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, chroma, hue));\n            //camOut = oklabToLinearSrgb(lchToLab(vec3(blue.x, chroma, hue)));\n        }\n        if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n            float hue = uv.x * 360.0;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, 500.0, hue));\n        }\n    }*/\n\n    // Hue ring - ZCAM\n    /*vec2 center = 0.5 * iResolution.xy;\n    vec2 cDistance = fragCoord - center;\n    hue = radiansToDegrees(atan2(cDistance.y, cDistance.x));\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    blue.hueAngle = hue;\n    blue.lightness = 73.0;\n    //blue.lightness = (cos(iTime / 2.0) + 1.0) * 50.0;\n    float chroma = 12.0;\n    float rDistance = distance(center, fragCoord);\n    if (rDistance <= 400.0 && rDistance >= 250.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    } else {\n        camOut = vec3(1.0);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, 0.0, 0.0), cond);\n    }*/\n\n    // Chroma/hue sweep\n    if (iMouse.z > 0.0) {\n        camOut = chromaHueSweepOklab(uv);\n    } else {\n        camOut = chromaHueSweepZcam(uv);\n    }\n\n    // Blending red with blue\n    /*if (uv.y >= 0.5) {\n        camOut = blendOklab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    } else {\n        camOut = blendOklrab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    if (digit2 > 0.001) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7352, 7352, 7377, 7377, 7918], [7920, 7920, 7945, 7945, 8471], [8473, 8473, 8505, 8505, 8550], [8552, 8552, 8584, 8584, 8629], [8650, 8650, 8676, 8676, 9311], [9313, 9313, 9339, 9339, 9927], [9929, 9929, 9962, 9962, 10008], [10010, 10010, 10043, 10043, 10089], [11298, 11462, 11510, 11668, 13694], [13696, 13787, 13821, 13884, 14261], [14263, 14401, 14480, 14523, 17554], [17556, 17556, 17602, 17602, 18172], [18174, 18174, 18216, 18216, 18771], [18773, 18773, 18818, 18818, 19579], [19581, 19581, 19637, 19637, 20312], [20314, 20314, 20373, 20373, 21324], [21937, 21937, 21956, 21956, 22094], [22096, 22096, 22118, 22118, 22250], [22252, 22252, 22278, 22278, 22724], [22726, 22726, 22750, 22750, 22807], [22809, 22809, 22861, 22861, 23009], [23011, 23011, 23132, 23132, 23408], [23697, 23697, 23749, 23793, 25029], [25031, 25031, 25083, 25083, 26728], [26730, 26730, 26794, 26794, 26920], [26994, 26994, 27062, 27062, 28101], [28102, 28102, 28141, 28141, 29219], [29220, 29220, 29258, 29258, 30303], [31927, 31927, 32052, 32052, 32440], [32442, 32442, 32543, 32543, 32878], [32880, 32880, 32917, 32917, 33581], [33583, 33583, 33683, 33683, 34809], [34811, 34811, 34851, 34851, 35318], [35355, 35355, 35423, 35423, 35545], [35547, 35547, 35616, 35616, 35767], [35769, 35769, 35836, 35836, 36093], [36096, 36096, 36168, 36168, 36281], [36283, 36283, 36356, 36356, 36472], [36474, 36474, 36547, 36547, 36681], [36683, 36683, 36754, 36754, 36982], [37005, 37005, 37056, 37056, 37499], [37501, 37501, 37553, 37553, 37767], [37769, 37769, 37821, 37821, 37992], [37994, 37994, 38047, 38047, 38221], [38223, 38223, 38280, 38280, 38409], [38411, 38411, 38462, 38462, 38502], [38533, 38533, 38567, 38567, 38784], [38786, 38786, 38821, 38821, 38973], [38975, 38975, 39011, 39011, 39172], [39192, 39192, 39247, 39247, 45990]], "test": "untested"}
{"id": "sdtSDn", "name": "ZCAM hue ring", "author": "kdrag0n", "description": "Hue ring in the ZCAM color appearance model, with fixed in-gamut lightness and chroma.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "hue", "cam", "colorscience", "zcam"], "likes": 0, "viewed": 257, "published": 3, "date": "1632970394", "time_retrieved": "2024-07-30T18:58:41.564975", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nconst float LR_K1 = 0.206;\nconst float LR_K2 = 0.03;\nconst float LR_K3 = (1.0 + LR_K1) / (1.0 + LR_K2);\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    return vec3(L, a, b);\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * OkLrab\n */\n\nvec3 xyzToOklrab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    float Lr = (LR_K3*L - LR_K1 + sqrt(square(LR_K3*L - LR_K1) + 4.0*LR_K2*LR_K3*L)) / 2.0;\n\n    return vec3(Lr, a, b);\n}\n\nvec3 oklrabToXyz(vec3 c) {\n    float Lr = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float L = (Lr * (Lr + LR_K1)) / (LR_K3 * (Lr + LR_K2));\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklrab(vec3 c) {\n    return xyzToOklrab(linearSrgbToXyz(c));\n}\n\nvec3 oklrabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklrabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    //float Sz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n    //float Qz = (Jz / 100.0) * Qz_w;\n    //float Cz = (Qz * square(Sz)) / (100.0 * Qz_w * pow(cond.F_l, 1.2));\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipCielchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = xyzToLinearSrgb(cielabToXyz(lchToLab(lch)));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid, hue))));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid2, hue))));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipOklchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = oklabToLinearSrgb(lchToLab(lch));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = oklabToLinearSrgb(lchToLab(vec3(lightness, mid, hue)));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = oklabToLinearSrgb(lchToLab(vec3(lightness, mid2, hue)));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessOklrab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklrab = lchToLab(lch);\n    return oklrabToLinearSrgb(oklrab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendOklch(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = labToLch(linearSrgbToOklab(srgbTransferInv(lhsRgb)));\n    vec3 rhs = labToLch(linearSrgbToOklab(srgbTransferInv(rhsRgb)));\n    rhs.z = lhs.z;\n    return clipOklchToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklab(srgbTransferInv(rhsRgb));\n    return oklabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklrab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklrab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklrab(srgbTransferInv(rhsRgb));\n    return oklrabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Chroma/hue sweep\n */\n\nvec3 chromaHueSweepZcam(vec2 uv) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipZcamJchToLinearSrgb(vec3(lightness, chroma, hue), cond);\n}\n\nvec3 chromaHueSweepOklab(vec2 uv) {\n    float lightness = uv.y;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipOklchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\nvec3 chromaHueSweepCielab(vec2 uv) {\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipCielchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Blue demo - ZCAM\n    /*ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    //blue.hueAngle = hue;\n    //blue.hueAngle = 33.44; // red\n    //blue.hueAngle = 89.29; // yellow\n    //blue.hueAngle = 146.30; // green\n    //blue.hueAngle = 238.36; // blue\n    if (uv.y >= 0.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(uv.x * 100.0, blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, uv.x * blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.hueAngle) < 0.5) ? blue.chroma : 10.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, 500.0, hue), cond);\n    }*/\n\n    // Blue demo - CIELAB\n    /*vec3 blue = labToLch(xyzToCielab(linearSrgbToXyz(vec3(0.0, 0.0, 1.0))));\n    if (uv.y >= 0.0) {\n        camOut = clipCielchToLinearSrgb(vec3(uv.x * 100.0, blue.y, blue.z));\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 21.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, chroma, hue));\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, 500.0, hue));\n    }*/\n\n    // Blue demo - Oklab\n    /*if (iMouse.z > 0.0) {\n        vec3 blue = labToLch(linearSrgbToOklab(vec3(0.0, 0.0, 1.0)));\n        //blue.z = hue;\n        if (uv.y >= 0.0) {\n            camOut = clipOklchToLinearSrgb(vec3(uv.x, blue.y, blue.z));\n        }\n        if (uv.y >= 1.0/3.0) {\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n        }\n        if (uv.y >= 2.0/3.0) {\n            float hue = uv.x * 360.0;\n            float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 0.07;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, chroma, hue));\n            //camOut = oklabToLinearSrgb(lchToLab(vec3(blue.x, chroma, hue)));\n        }\n        if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n            float hue = uv.x * 360.0;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, 500.0, hue));\n        }\n    }*/\n\n    // Hue ring - ZCAM\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 cDistance = fragCoord - center;\n    hue = radiansToDegrees(atan2(cDistance.y, cDistance.x));\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    blue.hueAngle = hue;\n    blue.lightness = 73.0;\n    //blue.lightness = (cos(iTime / 2.0) + 1.0) * 50.0;\n    float chroma = 12.0;\n    float rDistance = distance(center, fragCoord);\n    if (rDistance <= 400.0 && rDistance >= 250.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    } else {\n        camOut = vec3(1.0);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, 0.0, 0.0), cond);\n    }\n\n    // Chroma/hue sweep\n    /*if (iMouse.z > 0.0) {\n        camOut = chromaHueSweepOklab(uv);\n    } else {\n        camOut = chromaHueSweepZcam(uv);\n    }*/\n\n    // Blending red with blue\n    /*if (uv.y >= 0.5) {\n        camOut = blendOklab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    } else {\n        camOut = blendOklrab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    if (digit2 > 0.001) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7352, 7352, 7377, 7377, 7918], [7920, 7920, 7945, 7945, 8471], [8473, 8473, 8505, 8505, 8550], [8552, 8552, 8584, 8584, 8629], [8650, 8650, 8676, 8676, 9311], [9313, 9313, 9339, 9339, 9927], [9929, 9929, 9962, 9962, 10008], [10010, 10010, 10043, 10043, 10089], [11298, 11462, 11510, 11668, 13694], [13696, 13787, 13821, 13884, 14261], [14263, 14401, 14480, 14523, 17554], [17556, 17556, 17602, 17602, 18172], [18174, 18174, 18216, 18216, 18771], [18773, 18773, 18818, 18818, 19579], [19581, 19581, 19637, 19637, 20312], [20314, 20314, 20373, 20373, 21324], [21937, 21937, 21956, 21956, 22094], [22096, 22096, 22118, 22118, 22250], [22252, 22252, 22278, 22278, 22724], [22726, 22726, 22750, 22750, 22807], [22809, 22809, 22861, 22861, 23009], [23011, 23011, 23132, 23132, 23408], [23697, 23697, 23749, 23793, 25029], [25031, 25031, 25083, 25083, 26728], [26730, 26730, 26794, 26794, 26920], [26994, 26994, 27062, 27062, 28101], [28102, 28102, 28141, 28141, 29219], [29220, 29220, 29258, 29258, 30303], [31927, 31927, 32052, 32052, 32440], [32442, 32442, 32543, 32543, 32878], [32880, 32880, 32917, 32917, 33581], [33583, 33583, 33683, 33683, 34809], [34811, 34811, 34851, 34851, 35318], [35355, 35355, 35423, 35423, 35545], [35547, 35547, 35616, 35616, 35767], [35769, 35769, 35836, 35836, 36093], [36096, 36096, 36168, 36168, 36281], [36283, 36283, 36356, 36356, 36472], [36474, 36474, 36547, 36547, 36681], [36683, 36683, 36754, 36754, 36982], [37005, 37005, 37056, 37056, 37499], [37501, 37501, 37553, 37553, 37767], [37769, 37769, 37821, 37821, 37992], [37994, 37994, 38047, 38047, 38221], [38223, 38223, 38280, 38280, 38409], [38411, 38411, 38462, 38462, 38502], [38533, 38533, 38567, 38567, 38784], [38786, 38786, 38821, 38821, 38973], [38975, 38975, 39011, 39011, 39172], [39192, 39192, 39247, 39247, 45990]], "test": "untested"}
{"id": "sddXWn", "name": "sRGB blue analysis in ZCAM", "author": "kdrag0n", "description": "Analyzing sRGB blue in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "blue", "cam", "srgb", "colorscience", "oklab", "zcam"], "likes": 2, "viewed": 301, "published": 3, "date": "1632967861", "time_retrieved": "2024-07-30T18:58:42.696948", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nconst float LR_K1 = 0.206;\nconst float LR_K2 = 0.03;\nconst float LR_K3 = (1.0 + LR_K1) / (1.0 + LR_K2);\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    return vec3(L, a, b);\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * OkLrab\n */\n\nvec3 xyzToOklrab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    float L = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    float a = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    float b = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n\n    float Lr = (LR_K3*L - LR_K1 + sqrt(square(LR_K3*L - LR_K1) + 4.0*LR_K2*LR_K3*L)) / 2.0;\n\n    return vec3(Lr, a, b);\n}\n\nvec3 oklrabToXyz(vec3 c) {\n    float Lr = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float L = (Lr * (Lr + LR_K1)) / (LR_K3 * (Lr + LR_K2));\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklrab(vec3 c) {\n    return xyzToOklrab(linearSrgbToXyz(c));\n}\n\nvec3 oklrabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklrabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Björn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    //float Sz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n    //float Qz = (Jz / 100.0) * Qz_w;\n    //float Cz = (Qz * square(Sz)) / (100.0 * Qz_w * pow(cond.F_l, 1.2));\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipCielchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = xyzToLinearSrgb(cielabToXyz(lchToLab(lch)));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid, hue))));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = xyzToLinearSrgb(cielabToXyz(lchToLab(vec3(lightness, mid2, hue))));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\nvec3 clipOklchToLinearSrgb(vec3 lch) {\n    vec3 initialResult = oklabToLinearSrgb(lchToLab(lch));\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = lch.r;\n    float chroma = lch.g;\n    float hue = lch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = oklabToLinearSrgb(lchToLab(vec3(lightness, mid, hue)));\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = oklabToLinearSrgb(lchToLab(vec3(lightness, mid2, hue)));\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessOklrab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklrab = lchToLab(lch);\n    return oklrabToLinearSrgb(oklrab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendOklch(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = labToLch(linearSrgbToOklab(srgbTransferInv(lhsRgb)));\n    vec3 rhs = labToLch(linearSrgbToOklab(srgbTransferInv(rhsRgb)));\n    rhs.z = lhs.z;\n    return clipOklchToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklab(srgbTransferInv(rhsRgb));\n    return oklabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendOklrab(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = linearSrgbToOklrab(srgbTransferInv(lhsRgb));\n    vec3 rhs = linearSrgbToOklrab(srgbTransferInv(rhsRgb));\n    return oklrabToLinearSrgb(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Chroma/hue sweep\n */\n\nvec3 chromaHueSweepZcam(vec2 uv) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipZcamJchToLinearSrgb(vec3(lightness, chroma, hue), cond);\n}\n\nvec3 chromaHueSweepOklab(vec2 uv) {\n    float lightness = uv.y;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipOklchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\nvec3 chromaHueSweepCielab(vec2 uv) {\n    float lightness = uv.y * 100.0;\n    float chroma = 1000.0;\n    float hue = uv.x * 360.0;\n\n    return clipCielchToLinearSrgb(vec3(lightness, chroma, hue));\n}\n\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Blue demo - ZCAM\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    //blue.hueAngle = hue;\n    //blue.hueAngle = 33.44; // red\n    //blue.hueAngle = 89.29; // yellow\n    //blue.hueAngle = 146.30; // green\n    //blue.hueAngle = 238.36; // blue\n    if (uv.y >= 0.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(uv.x * 100.0, blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, uv.x * blue.chroma, blue.hueAngle), cond);\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.hueAngle) < 0.5) ? blue.chroma : 10.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, 500.0, hue), cond);\n    }\n\n    // Blue demo - CIELAB\n    /*vec3 blue = labToLch(xyzToCielab(linearSrgbToXyz(vec3(0.0, 0.0, 1.0))));\n    if (uv.y >= 0.0) {\n        camOut = clipCielchToLinearSrgb(vec3(uv.x * 100.0, blue.y, blue.z));\n    }\n    if (uv.y >= 1.0/3.0) {\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n    }\n    if (uv.y >= 2.0/3.0) {\n        float hue = uv.x * 360.0;\n        float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 21.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, chroma, hue));\n    }\n    if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n        float hue = uv.x * 360.0;\n        camOut = clipCielchToLinearSrgb(vec3(blue.x, 500.0, hue));\n    }*/\n\n    // Blue demo - Oklab\n    if (iMouse.z > 0.0) {\n        vec3 blue = labToLch(linearSrgbToOklab(vec3(0.0, 0.0, 1.0)));\n        //blue.z = hue;\n        if (uv.y >= 0.0) {\n            camOut = clipOklchToLinearSrgb(vec3(uv.x, blue.y, blue.z));\n        }\n        if (uv.y >= 1.0/3.0) {\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, uv.x * blue.y, blue.z));\n        }\n        if (uv.y >= 2.0/3.0) {\n            float hue = uv.x * 360.0;\n            float chroma = (abs(hue - blue.z) < 0.5) ? blue.y : 0.07;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, chroma, hue));\n            //camOut = oklabToLinearSrgb(lchToLab(vec3(blue.x, chroma, hue)));\n        }\n        if (uv.y >= 4.0/6.0 && uv.y <= 5.0/6.0) {\n            float hue = uv.x * 360.0;\n            camOut = clipOklchToLinearSrgb(vec3(blue.x, 500.0, hue));\n        }\n    }\n\n    // Hue ring - ZCAM\n    /*vec2 center = 0.5 * iResolution.xy;\n    vec2 cDistance = fragCoord - center;\n    hue = radiansToDegrees(atan2(cDistance.y, cDistance.x));\n    ZcamViewingConditions cond = getZcamCond();\n    vec3 xyzAbs = linearSrgbToXyz(vec3(0.0, 0.0, 1.0)) * cond.whiteLuminance;\n    Zcam blue = xyzToZcam(xyzAbs, cond);\n    blue.hueAngle = hue;\n    blue.lightness = 73.0;\n    //blue.lightness = (cos(iTime / 2.0) + 1.0) * 50.0;\n    float chroma = 12.0;\n    float rDistance = distance(center, fragCoord);\n    if (rDistance <= 400.0 && rDistance >= 250.0) {\n        camOut = clipZcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, chroma, hue), cond);\n    } else {\n        camOut = vec3(1.0);\n        //camOut = zcamJchToLinearSrgb(vec3(blue.lightness, 0.0, 0.0), cond);\n    }*/\n\n    // Chroma/hue sweep\n    /*if (iMouse.z > 0.0) {\n        camOut = chromaHueSweepOklab(uv);\n    } else {\n        camOut = chromaHueSweepZcam(uv);\n    }*/\n\n    // Blending red with blue\n    /*if (uv.y >= 0.5) {\n        camOut = blendOklab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    } else {\n        camOut = blendOklrab(uv, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    if (digit2 > 0.001) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7352, 7352, 7377, 7377, 7918], [7920, 7920, 7945, 7945, 8471], [8473, 8473, 8505, 8505, 8550], [8552, 8552, 8584, 8584, 8629], [8650, 8650, 8676, 8676, 9311], [9313, 9313, 9339, 9339, 9927], [9929, 9929, 9962, 9962, 10008], [10010, 10010, 10043, 10043, 10089], [11298, 11462, 11510, 11668, 13694], [13696, 13787, 13821, 13884, 14261], [14263, 14401, 14480, 14523, 17554], [17556, 17556, 17602, 17602, 18172], [18174, 18174, 18216, 18216, 18771], [18773, 18773, 18818, 18818, 19579], [19581, 19581, 19637, 19637, 20312], [20314, 20314, 20373, 20373, 21324], [21937, 21937, 21956, 21956, 22094], [22096, 22096, 22118, 22118, 22250], [22252, 22252, 22278, 22278, 22724], [22726, 22726, 22750, 22750, 22807], [22809, 22809, 22861, 22861, 23009], [23011, 23011, 23132, 23132, 23408], [23697, 23697, 23749, 23793, 25029], [25031, 25031, 25083, 25083, 26728], [26730, 26730, 26794, 26794, 26920], [26994, 26994, 27062, 27062, 28101], [28102, 28102, 28141, 28141, 29219], [29220, 29220, 29258, 29258, 30303], [31927, 31927, 32052, 32052, 32440], [32442, 32442, 32543, 32543, 32878], [32880, 32880, 32917, 32917, 33581], [33583, 33583, 33683, 33683, 34809], [34811, 34811, 34851, 34851, 35318], [35355, 35355, 35423, 35423, 35545], [35547, 35547, 35616, 35616, 35767], [35769, 35769, 35836, 35836, 36093], [36096, 36096, 36168, 36168, 36281], [36283, 36283, 36356, 36356, 36472], [36474, 36474, 36547, 36547, 36681], [36683, 36683, 36754, 36754, 36982], [37005, 37005, 37056, 37056, 37499], [37501, 37501, 37553, 37553, 37767], [37769, 37769, 37821, 37821, 37992], [37994, 37994, 38047, 38047, 38221], [38223, 38223, 38280, 38280, 38409], [38411, 38411, 38462, 38462, 38502], [38533, 38533, 38567, 38567, 38784], [38786, 38786, 38821, 38821, 38973], [38975, 38975, 39011, 39011, 39172], [39192, 39192, 39247, 39247, 45986]], "test": "untested"}
{"id": "NstSDn", "name": "Adaptive tile sizes", "author": "mrange", "description": "License CC0: Adaptive tile sizes\nBeen working too much lately to do shader stuff.\nBut today I experimented a bit with tiling so thought I share\n", "tags": ["2d"], "likes": 36, "viewed": 570, "published": 3, "date": "1632944654", "time_retrieved": "2024-07-30T18:58:43.580586", "image_code": "// License CC0: Adaptive tile sizes\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n\nconst int max_iter = 6;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                    DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shape(vec2 p) {\n  const float z = 1.6;\n  p /= z;\n  p *= ROT(TIME*0.25);\n  p.y += 0.58;\n  float d = heart(p)*z;\n  return d;\n}\n\nfloat df(vec2 p, out int ii, out bool inside) {\n  float aa = 3.0/RESOLUTION.y;\n\n  float sz = 0.9;\n  float ds = shape(p);\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  return box(pp, vec2(r-aa));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float d = df(p, i, inside)*z;\n  float ds = shape(p)*z;\n  float ii = float(i)/float(max_iter);\n\n  if (!inside) d = abs(d)-aa;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3((inside ? 0.1 : 0.6) +1.1*ii, 0.7, sqrt(max(1.0-ii, 0.0)));\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[541, 541, 563, 563, 709], [1005, 1091, 1127, 1127, 1221], [1223, 1317, 1338, 1338, 1558], [1560, 1654, 1681, 1681, 1761], [1763, 1763, 1784, 1784, 1893], [1895, 1895, 1942, 1942, 2368], [2370, 2453, 2489, 2533, 2804], [2806, 2806, 2861, 2861, 3467]], "test": "untested"}
{"id": "7dcSDr", "name": "Oscillator a la hydra", "author": "alvarobyrne", "description": "Oscillator like hydra does: [url]https://github.com/ojack/hydra-synth[/url]", "tags": ["hydra"], "likes": 1, "viewed": 248, "published": 3, "date": "1632933564", "time_retrieved": "2024-07-30T18:58:44.342548", "image_code": "vec4 osc(vec2 _st, float frequency, float sync, float offset) {\n     vec2 st = _st;\n     float r = sin((st.x-offset/frequency+iTime*sync)*frequency)*0.5  + 0.5;\n     float g = sin((st.x+iTime*sync)*frequency)*0.5 + 0.5;\n     float b = sin((st.x+offset/frequency+iTime*sync)*frequency)*0.5  + 0.5;\n     return vec4(r, g, b, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = osc(uv,60.,0.1,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 330], [333, 333, 390, 440, 543]], "test": "untested"}
{"id": "sscXWn", "name": "Torus flip", "author": "fizzgig", "description": "how you turn a torus inside out by cheating", "tags": ["torus", "stereographic", "flip"], "likes": 4, "viewed": 272, "published": 3, "date": "1632921619", "time_retrieved": "2024-07-30T18:58:45.373791", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nvec4 stereographicProj(vec3 point) {\n    vec4 p4 = vec4(point, 2.0);\n    float norm = length(p4);\n    return 4.0*p4/(norm*norm) - vec4(vec3(0.0),1.0);\n}\n\nfloat torus4SDF(vec4 point, vec4 pl1, vec4 pl2, float radius) {\n    float dp1 = dot(point,pl1);\n    float dp2 = dot(point,pl2);\n    vec4 pp = pl1*dp1 + pl2*dp2;\n    vec4 ppp = point - pp;\n    vec4 cp = pp/length(pp);\n    vec4 ppmcp = pp-cp;\n    return sqrt(dot(ppmcp,ppmcp) + dot(ppp,ppp)) - radius;\n}\n\nfloat sceneSDF(vec3 point) {\n    float theta = iTime;//PI/2.0*sin(iTime)*sin(iTime);\n    return torus4SDF(stereographicProj(point), \n                    vec4(0.0,1.0,0.0,0.0),\n                    vec4(cos(theta),0.0,0.0,sin(theta)),\n                    0.8);\n    /*return min(\n        min(\n            min(\n                sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n                sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n            ),\n            sphereSDF(vec3(0.0), 1.0, point)\n        ),\n        planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n      );*/\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(1.0, 0.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(0.0, 1.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(0.0, 0.0, 1.0));\n    \n    float disttoscreen = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(5.0, 2.0*cos(iTime*2.0+PI) + 6.0, -7.0 + 3.0*cos(iTime*2.0+PI));\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(0.7 + 0.4*cos(iTime*2.0+PI), 0.5, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    bool invert = scenedist < 0.0;\n    if (invert) scenedist = -scenedist;\n    float raydist = 0.0;\n    \n    float epsilon = 0.01;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = invert ? -sceneSDF(point) : sceneSDF(point);\n        \n        raydist += scenedist;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.3));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1338, 1338, 1454], [1456, 1456, 1519, 1519, 1757], [1759, 1759, 1787, 1787, 2325], [2327, 2327, 2377, 2377, 2733], [2735, 2735, 2768, 2768, 2823], [2825, 2825, 2861, 2861, 2909], [2911, 2911, 2940, 2940, 2998], [3000, 3000, 3109, 3109, 3549], [3551, 3551, 3608, 3608, 5525]], "test": "untested"}
{"id": "fscXDr", "name": " benching Gaussian generators", "author": "FabriceNeyret2", "description": "benching  Box–Muller vs Marsaglia polar Gaussian RNG methods.\nno surprise: the rejection variant, even if sometime faster on CPU ( no sin/cos ), is desastrous on SIMD parallelism : 4 to 8 times slower.\nSwitch 1st and last comments to see distribution.", "tags": ["gaussian", "rng"], "likes": 2, "viewed": 263, "published": 3, "date": "1632914470", "time_retrieved": "2024-07-30T18:58:46.438944", "image_code": "// generation Gaussian samples: benching  Box–Muller vs Marsaglia polar methods\n// https://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\n\n// #define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n   #define H(p) fract((p)/1.237) // fake hash to avoid counting this time\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R =  iResolution.xy,\n         U =  u/R - .5, H;\n    for(float i=0.,s,j; i < 10000.; i++) { // to get measurable durations\n    \n#if 1                      // --- Box–Muller method : 270 ms  Fake hash : 194 ms\n      H = H(U+i); \n  //  O.xy += H; continue; //     raw Uniform eval  : 202 ms  Fake hash : 108 ms\n      H = sqrt(-2.*log(H.x)) * vec2( sin(H.y*=6.283),cos(H.y)); \n#else                      // --- Marsaglia polar method : 715 ms\n      for( s = 2.,j=i; s > 1.; j+=.12347) { \n          H = 2.* H(U+j) - 1.; \n          s = dot(H,H); \n      }\n      H = sqrt(-2.*log(s)/s) * H;\n#endif\n      O.xy += H;           // to fight the optimizer \n   // O += vec4( max(0., 2.-R.y * length( 5.*U - H ) ) ); // display distrib instead\n  }\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 370, 370, 1125]], "test": "untested"}
{"id": "7sdXz7", "name": "Simple circles", "author": "mrange", "description": "License CC0: Simple circle tiling\nBeen working too much lately to do shader stuff.\nBut today I experimented a bit with tiling so thought I share", "tags": ["2d"], "likes": 5, "viewed": 263, "published": 3, "date": "1632903320", "time_retrieved": "2024-07-30T18:58:47.274709", "image_code": "// License CC0: Simple circle tiling\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df(vec2 p, out float n, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d = circle(pp, 1.25*sz);\n  \n  n = fract(r);\n  sc = sz;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  p += r*vec2(cos(a), sin(a));\n  p *= ROT(-a+0.25);\n  float n = 0.0;\n  float sc = 0.0;\n  float d = df(p, n, sc)*z;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3(n-0.25*d/sc, 0.5+0.5*d/sc, 1.0);\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXz7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[486, 486, 508, 508, 654], [950, 950, 981, 981, 1007], [1009, 1095, 1131, 1131, 1225], [1227, 1293, 1314, 1314, 1382], [1384, 1384, 1429, 1429, 1722], [1724, 1807, 1843, 1887, 2158], [2160, 2160, 2215, 2215, 2758]], "test": "untested"}
{"id": "7scSR7", "name": "blob field", "author": "drschizzo", "description": "use RIGHT,UP,LEFT arrows to toggle lights\nuse mouse to move the main light and the camera", "tags": ["raymarching", "wip"], "likes": 5, "viewed": 277, "published": 3, "date": "1632902499", "time_retrieved": "2024-07-30T18:58:48.036672", "image_code": "#define lin2sRGB(x) ( x <= .0031308 ? (x)*12.92 : 1.055*pow(x,1./2.4) - .055 )\n\n\nconst float ANIM_SPEED=2.;\n\n\nconst float SEED=3.42;\n\nconst int MAX_STEP=80;\nconst float MIN_DIST=.005;\nconst float MAX_DIST=80.;\n\n\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\n\nstruct Light{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nstruct Hit{\n    float dist;\n    vec4 objId;\n    vec3 pos;\n    vec3 normal;    \n};\n\n//  from DAVE HOSKINS\nvec3 N13(float p) {\n    p=p*SEED;\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat map01(float min,float max, float val){\n    return val=clamp((val-min)/(max-min),0.,1.);\n}\n\n \n\nvec4 getSphere(float n){\n    float nb=n;\n    float t=iTime/ANIM_SPEED;\n    vec3 p=N13(nb);\n    nb=nb*p.x;\n    float b=4.;\n    float z=-6.+3.*(sin(t*2.+b*float(nb))*0.5+.5);\n    float w=min(b/1.5,1.2)*pow((1.-(-z-3.)/3.),2.);\n    return vec4(p.x*1.5+cos(z*3.+n)*.4,p.y*1.5+sin(z*3.+n)*.4,z,w*1.2);\n    \n}\n\n//from https://iquilezles.org/articles/smin\nvec2 sminN( float a, float b, float k, float n )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nfloat computeId(vec3 p,vec3 rep){\n   \n    return dot(floor((rep*.5+p)/rep),vec3(1.,10.,100.));\n    \n}\n\n\nHit getDist(vec3 p){\n    float fact=.8;\n\n    vec3 orip=p;\n    \n    vec3 rep=vec3(3.*fact,3.*fact,15.);\n    float idOffset;\n\n    \n    p=mod(p+rep/2.,rep)-rep/2.;\n    \n    \n   \n    float dist=MAX_DIST;\n    int objId=-1;\n    int sphereId=0;\n     \n    \n   vec3 col=vec3(0.);\n    \n    \n    for(float i=-1.;i<=1.;i++){\n        for(float j=-1.;j<=1.;j++){\n            \n            vec3 p1=vec3(orip.x+i*rep.x,orip.y+j*rep.y,orip.z);\n            \n            idOffset=computeId(p1,rep);\n            vec4 sphere=getSphere(idOffset);\n            sphere.x=sphere.x+i*rep.x;\n            sphere.y=sphere.y+j*rep.y;\n           \n            float d1=length(p-sphere.xyz)-sphere.w;\n            //float d1=sdBox(p-sphere.xyz,vec3(sphere.w*fact));\n            col+=N13(idOffset)*pow(max(min(1.-d1,1.),0.),3.);\n\n            dist=sminN(dist,d1,2.*fact,4.).x;\n        }\n    }\n\n    \n    objId=int(idOffset);\n\n    dist*=.5;\n    return Hit(dist,vec4(objId,col),vec3(0),vec3(0));\n}\n\n\n\nvec3 getNormal(vec3 pos){\n    vec2 e=vec2(.05,0);\n    float dist=getDist(pos).dist;\n    vec3 n=vec3(\n        dist-getDist(pos-e.xyy).dist,\n        dist-getDist(pos-e.yxy).dist,\n        dist-getDist(pos-e.yyx).dist);\n    return normalize(n);\n}\n\nHit rayMarch(vec3 o,vec3 ray){\n    float totalDist=0.;\n    Hit hit;\n    for(int i=0;i<MAX_STEP;i++){\n        vec3 p=o+totalDist*ray;\n        hit=getDist(p);\n        totalDist+=hit.dist*2.*(.5+map01(0.,60.,totalDist));\n        if(hit.dist<MIN_DIST||totalDist>MAX_DIST) break ;\n    }\n    if(totalDist<MAX_DIST){\n        vec3 pos=o+ray*totalDist;\n        return Hit(totalDist,hit.objId,pos,getNormal(pos));\n    }\n    else{\n        return Hit(totalDist,vec4(-1),vec3(0),vec3(MAX_DIST));\n    }\n    \n}\n\nvec3 shadePixel(vec3 pos, vec3 n, Light light,vec3 viewDir){\n\n    float intensity=1./pow(length(pos-light.pos),2.)*light.intensity;\n    float diffuse=dot(normalize(light.pos-pos),n);\n    float shadow=1.;//softshadow( pos, light.pos, 0.01, 10., 5.);\n    diffuse=clamp(diffuse,0.,1.)*shadow;\n\n\n    vec3 r=normalize(light.pos-viewDir-pos);\n    float spec=pow(max(dot(n, r),0.), 90.)*shadow;\n    \n    float ret=diffuse;\n    ret +=  spec;\n\n    return ret*intensity*light.color;\n}\n\nfloat getzoffset(){\n   return iTime/ANIM_SPEED*10.;\n}\n\nvec2 getmousePos(){\n    return ((iMouse.xy-.5*iResolution.xy)/iResolution.y);\n\n}\n\n\nvec3 computeLighting(vec3 hitPos,vec3 n,vec3 ray){\n\n  bool disableLight1=texelFetch( iChannel1, ivec2(KEY_LEFT,2),0 ).x>0.;\n    bool disableLight2=texelFetch( iChannel1, ivec2(KEY_RIGHT,2),0 ).x>0.;\n    bool disableLight3=texelFetch( iChannel1, ivec2(KEY_UP,2),0 ).x>0.;\nfloat zoffset=getzoffset();\n\nLight lights[]=Light[](Light(vec3(getmousePos()*20.,30.-zoffset),disableLight3?0.:100.,vec3(1.,1.,1.)),\n                           Light(vec3(-8,3.,8.-zoffset),disableLight1?0.:100.,vec3(1.,.8,0.)),\n                           Light(vec3(8,-3.,8.-zoffset),disableLight2?0.:150.,vec3(0.,0.,1.)));\n\n\n    vec3 col=vec3(0.);\n    for(int i=0;i<3;i++){\n        vec3 shadingColor=shadePixel(hitPos,n,lights[i],ray);\n        \n        col+=shadingColor;\n   }\n   return col;\n}\n\n\n\nvec4 render(inout vec3 ro, inout vec3 ray,inout float fresnel, out bool doreflect){\n\n \n    \n    Hit hit=rayMarch(ro,ray);\n    \n    ro=hit.pos+hit.normal*0.003;\n    ray=reflect(ray,hit.normal);\n    fresnel=1.-dot(hit.normal,ray);\n    \n    vec4 colSphere;\n    \n    //only compute reflexion on close objects\n    if(hit.dist<15.)\n        doreflect=true;\n   \n    if(hit.objId.y!=-1.){\n        vec3 col=computeLighting(hit.pos,hit.normal,ray);\n        vec3 colsp=hit.objId.yzw;\n        colSphere = vec4(col.xyz*colsp,1.0);\n        \n    }\n    \n    return colSphere;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime/ANIM_SPEED;\n    \n    vec2 mousePos=getmousePos();\n    \n    float zoffset=t*10.;\n    \n    //camera model from https://www.youtube.com/watch?v=PBxuVlp7nuM\n    vec3 camera=vec3(mousePos*8.,30.-zoffset);//-20.*(1.+sin(t)));\n    vec3 lookAt=vec3(mousePos*4.,-zoffset);\n    float zoom=1.;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    \n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    bool doreflect=false;\n\n    float fresnel=0.;\n    fragColor=render(camera,ray,fresnel,doreflect);\n    if(doreflect){\n    float savefresnel=fresnel;\n    fragColor+=render(camera,ray,fresnel,doreflect)*pow(map01(.3,.7,savefresnel),3.);\n    }\n   //gamma correction\n    fragColor.r=lin2sRGB(fragColor.r);\n    fragColor.g=lin2sRGB(fragColor.g);\n    fragColor.b=lin2sRGB(fragColor.b);\n    \n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 467, 486, 486, 633], [635, 635, 658, 658, 710], [713, 713, 757, 757, 808], [813, 813, 837, 837, 1116], [1118, 1162, 1212, 1212, 1355], [1357, 1357, 1390, 1390, 1458], [1461, 1461, 1481, 1481, 2417], [2421, 2421, 2446, 2446, 2663], [2665, 2665, 2695, 2695, 3160], [3162, 3162, 3222, 3222, 3636], [3638, 3638, 3657, 3657, 3691], [3693, 3693, 3712, 3712, 3773], [4545, 4545, 4628, 4628, 5105], [5110, 5110, 5167, 5167, 6127]], "test": "untested"}
{"id": "sstXR7", "name": "Indonesia flag", "author": "andraantariksa", "description": "Based on The_ArtOfCode and https://www.shadertoy.com/view/slsSWn", "tags": ["flag", "indonesia"], "likes": 1, "viewed": 219, "published": 3, "date": "1632898711", "time_retrieved": "2024-07-30T18:58:48.803621", "image_code": "precision highp float;\n\nvec3 WHITE = vec3(1);\nvec3 RED = vec3(206, 17, 39)/255.;\n\nfloat PI = 3.1415;\n\nvec2 RotateUV(vec2 uv, float angle) {\n    return vec2(\n        cos(angle) * uv.x + sin(angle) * uv.y,\n        cos(angle) * uv.y - sin(angle) * uv.x\n    );\n}\n\nvec3 Flag(vec2 uv) {\n    vec2 st = RotateUV(uv, PI/4.);\n\n    vec3 col = mix(RED, WHITE, step(0.0, -uv.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05 * (uv.x + 0.5);    \n    \n    vec3 col = Flag(uv);\n    col *= mix(1., .7+cos(t)*.3, (uv.x + 0.5));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 139, 139, 258], [260, 260, 280, 280, 384], [386, 386, 443, 443, 690]], "test": "untested"}
{"id": "sstSR7", "name": "Wave Equation 1D", "author": "oneshade", "description": "https://en.wikipedia.org/wiki/Wave_equation", "tags": ["waves", "1d", "smoothnoise", "waveequation"], "likes": 20, "viewed": 271, "published": 3, "date": "1632892918", "time_retrieved": "2024-07-30T18:58:49.574560", "image_code": "#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nvec2 noise(in vec2 x) {\n    return fFract(fMul(vec2(367.436, 0.0), fCos(439.573 * x + vec2(153.584, 0.0))));\n}\n\nvec2 f(in vec2 x) {\n    x *= 0.5;\n    return 3.0 * fMix(noise(fFloor(x)), noise(fCeil(x)), fSmoothstep(vec2(0.0), vec2(1.0, 0.0), fFract(x)));\n}\n\nvec2 u(in vec2 x, in float t) {\n    t *= 8.0; // c\n    return (f(x - vec2(t, 0.0)) + f(x + vec2(t, 0.0))) / 2.0; // + int(x - ct < s < x + ct, g(s)ds) / 2c\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Draw wave function\n    vec2 y = u(vec2(uv.x, 1.0), iTime);\n    color = mix(color, vec3(0.0, 0.0, 0.8 * exp(0.25 * (uv.y - y.x))), smoothstep(unit, 0.0, (uv.y - y.x) / sqrt(1.0 + y.y * y.y)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "vec2 const2dual(in float x) { return vec2(x, 0.0); }\nvec2 var2dual(in float x) { return vec2(x, 1.0); }\nvec2 fAdd(in vec2 a, in vec2 b) { return a + b; }\nvec2 fSub(in vec2 a, in vec2 b) { return a - b; }\nvec2 fMul(in vec2 a, in vec2 b) { return vec2(a.x * b.x, a.x * b.y + a.y * b.x); }\nvec2 fDiv(in vec2 a, in vec2 b) { return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x)); }\nvec2 fInv(in vec2 z) { float q = 1.0 / z.x; return vec2(q, -z.y * q / z.x); }\nvec2 fPow(in vec2 a, in vec2 b) { float q = pow(a.x, b.x); return vec2(q, q * (b.x * a.y / a.x + b.y * log(a.x))); }\nvec2 fConstPow(in vec2 z, in float power) { float q = pow(z.x, power); return vec2(q, power * z.y * q / z.x); }\nvec2 fIntPow(in vec2 z, in int power) { float res = 1.0; for (int n=0; n < abs(power); n++) { res *= z.x; } if (power < 0) res = 1.0 / res; return vec2(res, float(power) * res / z.x * z.y); }\nvec2 fSquare(in vec2 z) { return vec2(z.x * z.x, 2.0 * z.x * z.y); }\nvec2 fSqrt(in vec2 z) { float q = sqrt(z.x); return vec2(q, 0.5 * z.y / q); }\nvec2 fExp(in vec2 z, in float base) { float q = pow(base, z.x); return vec2(q, q * z.y); }\nvec2 fLn(in vec2 z) { return vec2(log(z.x), z.y / z.x); }\nvec2 fSin(in vec2 z) { return vec2(sin(z.x), cos(z.x) * z.y); }\nvec2 fCos(in vec2 z) { return vec2(cos(z.x), -sin(z.x) * z.y); }\nvec2 fTan(in vec2 z) { float q = cos(z.x); return vec2(tan(z.x), z.y / (q * q)); }\nvec2 fAsin(in vec2 z) { return vec2(asin(z.x), z.y / sqrt(1.0 - z.x * z.x)); }\nvec2 fAcos(in vec2 z) { return vec2(acos(z.x), -z.y / sqrt(1.0 - z.x * z.x)); }\nvec2 fAtan(in vec2 z) { return vec2(atan(z.x), z.y / (1.0 + z.x * z.x)); }\nvec2 fSinh(in vec2 z) { return vec2(sinh(z.x), cosh(z.x) * z.y); }\nvec2 fCosh(in vec2 z) { return vec2(cosh(z.x), sinh(z.x) * z.y); }\nvec2 fTanh(in vec2 z) { float q = cosh(z.x); return vec2(tanh(z.x), z.y / (q * q)); }\nvec2 fAsinh(in vec2 z) { return vec2(asinh(z.x), z.y / sqrt(z.x * z.x + 1.0)); }\nvec2 fAcosh(in vec2 z) { return vec2(acosh(z.x), z.y / sqrt(z.x * z.x - 1.0)); }\nvec2 fAtanh(in vec2 z) { return vec2(atanh(z.x), z.y / (1.0 - z.x * z.x)); }\nvec2 fMin(in vec2 a, in vec2 b) { return a.x < b.x ? a : b; }\nvec2 fMax(in vec2 a, in vec2 b) { return a.x > b.x ? a : b; }\nvec2 fFloor(in vec2 z) { return vec2(floor(z.x), 0.0); }\nvec2 fCeil(in vec2 z) { return vec2(ceil(z.x), 0.0); }\nvec2 fAbs(in vec2 z) { return vec2(abs(z.x), z.y * sign(z.x)); }\nvec2 fSign(in vec2 z) { return vec2(sign(z.x), 0.0); }\nvec2 fMod(in vec2 a, in vec2 b) { return vec2(mod(a.x, b.x), a.y); }\nvec2 fFract(in vec2 z) { return vec2(fract(z.x), z.y); }\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) { return fMax(edge0, fMin(edge1, z)); }\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) { z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0)); vec2 sq = fSquare(z); return 3.0 * sq - 2.0 * fMul(sq, z);}\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) { return a + fMul(b - a, t); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 104, 104, 191], [193, 193, 212, 212, 337], [339, 339, 370, 370, 496], [498, 498, 553, 553, 929]], "test": "untested"}
{"id": "fsdXz7", "name": "Deep Suzanne", "author": "kosmaks", "description": "I wrote a simple MLP regression to estimate SDF for suzanne from blender. Just calculated distances for all triangles and converted them into a single function. It didn't catch some details like eyes or nose, but I'm happy with the result :) 60 fps on m1.", "tags": ["experiment", "nn"], "likes": 4, "viewed": 344, "published": 3, "date": "1632870349", "time_retrieved": "2024-07-30T18:58:51.082528", "image_code": "const vec3 Up = vec3(0., 1., 0.);\nconst int MaxSteps = 200;\nconst float MinDist = 0.001;\nconst float MaxDist = 10.;\n\n\nfloat sdScene(vec3 p) {\n    return sdNN(p) - 0.1;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd) {\n    float total = 0.;\n    for (int i = 0; i < MaxSteps; ++i) {\n        float d = sdScene(ro + total * rd);\n        total += d;\n        if (abs(d) < MinDist) return total;\n        if (total > MaxDist) break;\n    }\n    return MaxDist + 0.1;\n}\n\nvec3 getNormal(vec3 p) {\n    int id;\n    float dist = sdScene(p);\n    vec2 e = vec2(MinDist, 0.);\n    vec3 n = dist - vec3(\n        sdScene(p - e.xyy),\n        sdScene(p - e.yxy),\n        sdScene(p - e.yyx));\n    return normalize(n);\n}\n\nvec3 fresnel(in vec3 f0, in float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float vpWindow = 2. / iResolution.y;\n    vec2 vpShift = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 vp = fragCoord * vpWindow - vpShift;\n    \n    float time = 0.5 * iTime + .7;\n    vec3 ld = normalize(vec3(1., 1., -1.));\n    vec3 co = vec3(3.5, 0.5, -3.5) * vec3(sin(time), 1., cos(time));\n    vec3 ct = vec3(0., 0., 0.);\n    vec3 cf = normalize(ct - co);\n    vec3 cr = normalize(cross(Up, cf));\n    vec3 cu = cross(cf, cr);\n\n    vec3 ro = co;\n    vec3 rd = normalize(cf * 2. + vp.x * cr + vp.y * cu);\n    \n    vec3 radiance = vec3(0.);\n    \n    float d = intersect(ro, rd);\n    \n    if (d < MaxDist) {\n        vec3 p = ro + d * rd;\n        vec3 n = getNormal(p);\n        vec3 ld = normalize(vec3(1., 1., 0.));\n        float s = intersect(p + n * MinDist * 2., ld) < MaxDist ? 0.7 : 1.;\n        vec3 color = vec3(1., 0.2, 0.3);\n        vec3 f = fresnel(vec3(0.04), max(0., dot(-rd, n)));\n        vec3 diffuse = color * textureLod(iChannel1, n, 9.).rgb * 1.;\n        vec3 refl = texture(iChannel0, reflect(rd, n)).rgb * 3.;\n        radiance += s * (f * refl + (1. - f) * diffuse);\n    } else {\n        radiance += texture(iChannel0, rd).rgb * 0.5;\n    }\n    \n    vec3 color = radiance;\n    color = color / (color + vec3(2.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdNNLocal(vec3 inp) {\n    float l0_0 = inp.x;\n    float l0_1 = inp.y;\n    float l0_2 = inp.z;\n    float l1_0 = tanh(-1.05968614 + 0.10086252 * l0_0 + -0.00363408 * l0_1 + -1.46499568 * l0_2);\n    float l1_1 = tanh(-0.19910900 + 1.09375853 * l0_0 + -1.04089161 * l0_1 + 1.04958421 * l0_2);\n    float l1_2 = tanh(0.59265323 + 0.33114441 * l0_0 + -0.20480392 * l0_1 + 0.29771640 * l0_2);\n    float l1_3 = tanh(0.25942873 + -2.79827385 * l0_0 + 0.17930557 * l0_1 + -0.50899781 * l0_2);\n    float l1_4 = tanh(0.04888931 + 1.45414972 * l0_0 + -0.53668653 * l0_1 + -1.15699645 * l0_2);\n    float l1_5 = tanh(0.25540761 + 0.09917475 * l0_0 + 1.71854845 * l0_1 + 1.87242381 * l0_2);\n    float l1_6 = tanh(-0.57603477 + -0.63626333 * l0_0 + -1.53200790 * l0_1 + 0.47518993 * l0_2);\n    float l1_7 = tanh(-0.67267692 + -0.16971515 * l0_0 + 1.20986021 * l0_1 + 0.67363124 * l0_2);\n    float l1_8 = tanh(1.50482769 + -1.78249681 * l0_0 + 0.71629440 * l0_1 + 4.89436948 * l0_2);\n    float l1_9 = tanh(0.59250436 + -2.00723484 * l0_0 + 0.68503942 * l0_1 + 0.17260082 * l0_2);\n    float l1_10 = tanh(0.64515362 + -1.27056397 * l0_0 + -0.47569248 * l0_1 + 0.30472384 * l0_2);\n    float l1_11 = tanh(1.58468193 + 1.38778136 * l0_0 + -3.61809939 * l0_1 + 0.73566802 * l0_2);\n    float l1_12 = tanh(0.39026344 + -0.08600417 * l0_0 + 4.49238873 * l0_1 + -0.03671114 * l0_2);\n    float l1_13 = tanh(-1.40808806 + 0.84253802 * l0_0 + -0.63565532 * l0_1 + 3.45004986 * l0_2);\n    float l1_14 = tanh(-0.47354127 + -2.62811253 * l0_0 + 0.93422023 * l0_1 + -0.19195709 * l0_2);\n    float l1_15 = tanh(0.61334098 + 0.95888106 * l0_0 + 0.78649512 * l0_1 + 0.30386589 * l0_2);\n    float l1_16 = tanh(-0.91396224 + 0.78537385 * l0_0 + -0.23577916 * l0_1 + 1.02103661 * l0_2);\n    float l1_17 = tanh(-1.10234184 + -1.26506055 * l0_0 + 0.05283757 * l0_1 + 0.13229078 * l0_2);\n    float l1_18 = tanh(-1.47711034 + 2.53668668 * l0_0 + 2.29539525 * l0_1 + 1.42687046 * l0_2);\n    float l1_19 = tanh(-1.34192705 + -3.92170645 * l0_0 + 0.31931545 * l0_1 + 1.35454175 * l0_2);\n    float l2_0 = tanh(-0.61739108 + -1.34373050 * l1_0 + 0.49696195 * l1_1 + 0.13238358 * l1_2 + 0.42055655 * l1_3 + 0.45070058 * l1_4 + -0.06000904 * l1_5 + -1.18145825 * l1_6 + -0.17818012 * l1_7 + -0.50664858 * l1_8 + -1.18172930 * l1_9 + -0.01681928 * l1_10 + -1.00511220 * l1_11 + -0.12931473 * l1_12 + 0.68301580 * l1_13 + -0.22582444 * l1_14 + -0.43164002 * l1_15 + -1.08386522 * l1_16 + 0.50918389 * l1_17 + 0.44221231 * l1_18 + -0.68723546 * l1_19);\n    float l2_1 = tanh(0.13191584 + 0.16548979 * l1_0 + -0.23317622 * l1_1 + -0.18063491 * l1_2 + -1.38259631 * l1_3 + -0.70917867 * l1_4 + -0.43593393 * l1_5 + -0.13959971 * l1_6 + 1.63834404 * l1_7 + -0.72622761 * l1_8 + 0.38269789 * l1_9 + -0.29077177 * l1_10 + -0.26381171 * l1_11 + -0.06639727 * l1_12 + -0.29195364 * l1_13 + 1.54929066 * l1_14 + 0.29474441 * l1_15 + 0.25717831 * l1_16 + 0.36299691 * l1_17 + -0.16285121 * l1_18 + 0.17394618 * l1_19);\n    float l2_2 = tanh(-0.86450900 + -0.75588470 * l1_0 + 1.13726874 * l1_1 + -0.68704473 * l1_2 + -0.66838438 * l1_3 + -0.19898747 * l1_4 + 0.17461368 * l1_5 + -0.54165617 * l1_6 + 0.18888749 * l1_7 + -0.17260755 * l1_8 + 0.33620217 * l1_9 + 1.27265267 * l1_10 + 0.05619054 * l1_11 + -0.10073513 * l1_12 + 0.32230783 * l1_13 + -0.11614486 * l1_14 + 0.27517933 * l1_15 + -0.21495326 * l1_16 + -0.14406267 * l1_17 + 0.66854204 * l1_18 + -0.07207757 * l1_19);\n    float l2_3 = tanh(0.98458332 + 1.11681420 * l1_0 + -0.25101834 * l1_1 + 0.15317615 * l1_2 + -0.11055457 * l1_3 + 0.07843758 * l1_4 + 0.33808385 * l1_5 + 0.55491298 * l1_6 + 0.00245950 * l1_7 + 0.40981668 * l1_8 + 0.80024901 * l1_9 + -0.46144057 * l1_10 + 0.45273973 * l1_11 + 0.61137086 * l1_12 + -0.18340323 * l1_13 + -0.11232976 * l1_14 + -0.59149385 * l1_15 + 0.94586448 * l1_16 + 0.79071600 * l1_17 + 0.52905499 * l1_18 + -0.00424649 * l1_19);\n    float l2_4 = tanh(0.86794310 + -0.10695838 * l1_0 + -0.17713764 * l1_1 + 0.91072823 * l1_2 + -0.75498619 * l1_3 + -1.21617857 * l1_4 + 1.05910956 * l1_5 + 3.10818245 * l1_6 + 0.83725712 * l1_7 + 0.41799648 * l1_8 + -0.27311111 * l1_9 + -0.40455060 * l1_10 + 0.66599605 * l1_11 + 1.36331570 * l1_12 + 0.10352090 * l1_13 + -0.49205825 * l1_14 + 0.68336630 * l1_15 + -0.64432826 * l1_16 + -0.61849964 * l1_17 + -0.15540055 * l1_18 + -0.90638281 * l1_19);\n    float l2_5 = tanh(-0.50691827 + -0.99411854 * l1_0 + 0.85113469 * l1_1 + -0.33535885 * l1_2 + -1.31384939 * l1_3 + 0.32254332 * l1_4 + 0.38445726 * l1_5 + 0.17581650 * l1_6 + -0.90495995 * l1_7 + -1.27039095 * l1_8 + 1.16242020 * l1_9 + 1.05385823 * l1_10 + -0.25714992 * l1_11 + -0.61252238 * l1_12 + 0.14120999 * l1_13 + -0.52680920 * l1_14 + 0.25374725 * l1_15 + -0.21367343 * l1_16 + -0.20572567 * l1_17 + 0.23809343 * l1_18 + 0.54754426 * l1_19);\n    float l2_6 = tanh(-0.10387458 + 0.55746335 * l1_0 + 0.92796991 * l1_1 + 0.33688731 * l1_2 + 1.40536338 * l1_3 + 0.04527336 * l1_4 + 0.47678304 * l1_5 + 0.02825633 * l1_6 + -0.95984300 * l1_7 + -0.37275236 * l1_8 + -0.56841685 * l1_9 + 0.21955018 * l1_10 + 0.48738392 * l1_11 + 0.61343990 * l1_12 + -0.54341024 * l1_13 + -0.37609137 * l1_14 + -1.00334254 * l1_15 + 0.13269811 * l1_16 + 0.60921184 * l1_17 + -0.41500727 * l1_18 + -0.71645809 * l1_19);\n    float l2_7 = tanh(-0.48356982 + -1.15068037 * l1_0 + -0.10408659 * l1_1 + -0.16902433 * l1_2 + 0.81789139 * l1_3 + -0.03231258 * l1_4 + -0.18396344 * l1_5 + -0.18083732 * l1_6 + 0.00105547 * l1_7 + -0.14472333 * l1_8 + 0.54967887 * l1_9 + 0.34992278 * l1_10 + 1.04041843 * l1_11 + 0.77095793 * l1_12 + -0.13638862 * l1_13 + -0.96838452 * l1_14 + -0.97465031 * l1_15 + -0.95758288 * l1_16 + -0.39317178 * l1_17 + 0.19589301 * l1_18 + -0.69101652 * l1_19);\n    float l2_8 = tanh(-0.20340957 + -0.10523241 * l1_0 + -0.79286395 * l1_1 + -0.37303614 * l1_2 + -0.21135740 * l1_3 + -0.15679715 * l1_4 + -0.15351668 * l1_5 + -0.73253109 * l1_6 + 0.78106056 * l1_7 + 0.29866634 * l1_8 + 0.70054896 * l1_9 + -0.29818400 * l1_10 + 0.25517799 * l1_11 + 0.39319163 * l1_12 + -0.04720556 * l1_13 + 0.32885870 * l1_14 + 1.01180143 * l1_15 + -0.16900014 * l1_16 + 0.27743662 * l1_17 + -0.17914667 * l1_18 + -0.34840769 * l1_19);\n    float l2_9 = tanh(1.38211053 + -0.39970690 * l1_0 + 1.23715340 * l1_1 + 0.53142890 * l1_2 + -0.64971723 * l1_3 + 0.22951680 * l1_4 + -0.77769203 * l1_5 + 1.63594078 * l1_6 + 0.38203114 * l1_7 + -0.50579149 * l1_8 + -0.95128774 * l1_9 + -0.38146705 * l1_10 + -0.18185546 * l1_11 + 0.90799610 * l1_12 + -0.15213404 * l1_13 + -0.03378455 * l1_14 + 0.03488177 * l1_15 + -0.20106873 * l1_16 + 0.05678864 * l1_17 + 0.32278917 * l1_18 + 0.13262530 * l1_19);\n    float l2_10 = tanh(-0.00728130 + -0.07738917 * l1_0 + 0.01823718 * l1_1 + 0.51459238 * l1_2 + -0.46021221 * l1_3 + 0.95901254 * l1_4 + 0.26132676 * l1_5 + 0.69092823 * l1_6 + 0.58166444 * l1_7 + 0.51377654 * l1_8 + -0.27526548 * l1_9 + -0.62938462 * l1_10 + 0.73330329 * l1_11 + 1.39103928 * l1_12 + -2.12166472 * l1_13 + 0.37687477 * l1_14 + 0.23640083 * l1_15 + 1.77389135 * l1_16 + -0.76496419 * l1_17 + 0.47892735 * l1_18 + -0.42751755 * l1_19);\n    float l2_11 = tanh(0.31305721 + 0.14246434 * l1_0 + 0.66575295 * l1_1 + -0.03159984 * l1_2 + -0.41688820 * l1_3 + -0.19897675 * l1_4 + -0.50336478 * l1_5 + 0.45720336 * l1_6 + 0.02866392 * l1_7 + -0.31412121 * l1_8 + 0.75175364 * l1_9 + 0.67424120 * l1_10 + -0.11242531 * l1_11 + -0.32992379 * l1_12 + 0.06185201 * l1_13 + 0.79912374 * l1_14 + -0.86638477 * l1_15 + 0.28154115 * l1_16 + -1.05670309 * l1_17 + -0.33261284 * l1_18 + 0.61936259 * l1_19);\n    float l2_12 = tanh(-0.55575429 + 0.98279365 * l1_0 + 0.00646069 * l1_1 + -0.11073757 * l1_2 + -0.02097271 * l1_3 + 0.04909127 * l1_4 + -0.48759520 * l1_5 + -0.48193010 * l1_6 + -1.82404828 * l1_7 + 0.49796277 * l1_8 + 1.14268094 * l1_9 + -0.33930802 * l1_10 + -0.08294819 * l1_11 + 1.12138419 * l1_12 + -0.89385139 * l1_13 + -0.21537274 * l1_14 + -0.61823003 * l1_15 + -0.31108578 * l1_16 + 0.03561240 * l1_17 + -0.48311330 * l1_18 + -1.15240437 * l1_19);\n    float l2_13 = tanh(-0.55448017 + -0.28351512 * l1_0 + 0.62828656 * l1_1 + 0.20001055 * l1_2 + -0.08851308 * l1_3 + -0.34377574 * l1_4 + 0.24578000 * l1_5 + 0.01977611 * l1_6 + -1.03357245 * l1_7 + 0.08781663 * l1_8 + -0.54281265 * l1_9 + 0.74301693 * l1_10 + 0.41893503 * l1_11 + 0.00871656 * l1_12 + -0.16368603 * l1_13 + 0.40150323 * l1_14 + 0.14615813 * l1_15 + -0.03964546 * l1_16 + -1.20799840 * l1_17 + -0.65370825 * l1_18 + 0.57782678 * l1_19);\n    float l2_14 = tanh(1.33424613 + 0.01778773 * l1_0 + 0.04830881 * l1_1 + 1.02726137 * l1_2 + 1.71352835 * l1_3 + -0.79581247 * l1_4 + 0.22026223 * l1_5 + 2.18769908 * l1_6 + 1.16338829 * l1_7 + -0.04570771 * l1_8 + -0.30064321 * l1_9 + 0.67986016 * l1_10 + 1.23786694 * l1_11 + 0.07858945 * l1_12 + 1.32958042 * l1_13 + -1.27339743 * l1_14 + 0.22133412 * l1_15 + 0.42110241 * l1_16 + 0.13415449 * l1_17 + -1.03149481 * l1_18 + -0.43592383 * l1_19);\n    float l2_15 = tanh(1.28011033 + 0.02129508 * l1_0 + 1.41508632 * l1_1 + 0.95154005 * l1_2 + 0.10460259 * l1_3 + -0.44452167 * l1_4 + -0.28579510 * l1_5 + -0.22482967 * l1_6 + 0.55859606 * l1_7 + -0.63505475 * l1_8 + 0.46461704 * l1_9 + 0.63028867 * l1_10 + -0.80983685 * l1_11 + -1.00766641 * l1_12 + -0.58521395 * l1_13 + -0.17862537 * l1_14 + 0.66563832 * l1_15 + -0.36786809 * l1_16 + -0.19007922 * l1_17 + -0.06093303 * l1_18 + 0.43624941 * l1_19);\n    float l2_16 = tanh(0.22086035 + 0.10201244 * l1_0 + -0.10601162 * l1_1 + -0.36064925 * l1_2 + 0.47011188 * l1_3 + 0.09976796 * l1_4 + 0.05407430 * l1_5 + -0.93099515 * l1_6 + 0.13881436 * l1_7 + 0.22178932 * l1_8 + 0.87647113 * l1_9 + 0.71136681 * l1_10 + -0.50326672 * l1_11 + -0.91280985 * l1_12 + -0.02022056 * l1_13 + 0.10274351 * l1_14 + 1.52781256 * l1_15 + -0.09933025 * l1_16 + -0.26914537 * l1_17 + -0.08453344 * l1_18 + -0.10147086 * l1_19);\n    float l2_17 = tanh(0.33098066 + 1.37623655 * l1_0 + -0.05797965 * l1_1 + 0.03204574 * l1_2 + 0.54332070 * l1_3 + 1.75930183 * l1_4 + -0.25939938 * l1_5 + 1.83010762 * l1_6 + -0.02233724 * l1_7 + 0.34263332 * l1_8 + -1.46880016 * l1_9 + 0.33103506 * l1_10 + 0.20888477 * l1_11 + 0.39221319 * l1_12 + -0.22924733 * l1_13 + 0.73340696 * l1_14 + 0.16850124 * l1_15 + -0.08913723 * l1_16 + -0.17692687 * l1_17 + -0.73441168 * l1_18 + -0.08177275 * l1_19);\n    float l2_18 = tanh(-1.50578925 + 0.03442867 * l1_0 + 0.06911640 * l1_1 + -0.84314633 * l1_2 + 0.95481853 * l1_3 + -1.40815348 * l1_4 + 0.36194608 * l1_5 + 0.97452918 * l1_6 + 0.30218573 * l1_7 + 0.11624426 * l1_8 + -0.34175201 * l1_9 + -0.94378934 * l1_10 + -1.28866666 * l1_11 + -0.82564698 * l1_12 + -1.57051479 * l1_13 + 0.06438064 * l1_14 + 0.54578617 * l1_15 + 0.04607956 * l1_16 + -0.62338873 * l1_17 + -1.15510806 * l1_18 + 0.14640975 * l1_19);\n    float l2_19 = tanh(-0.99963019 + -0.52417468 * l1_0 + -0.41982108 * l1_1 + -0.56806874 * l1_2 + -0.25280424 * l1_3 + -0.02468746 * l1_4 + 0.37141243 * l1_5 + -0.28011022 * l1_6 + -0.33573328 * l1_7 + -1.07472457 * l1_8 + -1.00379002 * l1_9 + 0.79569266 * l1_10 + 0.98110080 * l1_11 + 0.66542894 * l1_12 + 0.33263255 * l1_13 + 0.11598955 * l1_14 + -1.02350169 * l1_15 + -0.11062187 * l1_16 + 0.85643567 * l1_17 + 0.60022052 * l1_18 + -0.00776241 * l1_19);\n    float l3_0 = 0.92313957 + -0.60431151 * l2_0 + 0.33725815 * l2_1 + -0.43434061 * l2_2 + 0.57690528 * l2_3 + -0.27627629 * l2_4 + -0.22562560 * l2_5 + 0.34499122 * l2_6 + -0.59788412 * l2_7 + -0.55552794 * l2_8 + 0.38620787 * l2_9 + -0.27057965 * l2_10 + -0.69706163 * l2_11 + -0.17523293 * l2_12 + -0.54956773 * l2_13 + 0.13276041 * l2_14 + 0.57384402 * l2_15 + -0.87525821 * l2_16 + -0.26747914 * l2_17 + -0.11611546 * l2_18 + -0.41926703 * l2_19;\n    return l3_0;\n}\nfloat sdNN(vec3 p) {\n    float box = length(max(abs(p) - 1., 0.0));\n    vec3 boxp = min(abs(p), 1.) * sign(p);\n    return box + sdNNLocal(boxp) * 0.5 + 0.5;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 141, 141, 169], [172, 172, 207, 207, 448], [450, 450, 474, 474, 685], [687, 687, 732, 732, 786], [788, 788, 844, 844, 2210]], "test": "untested"}
{"id": "sstXR8", "name": "Fractal Computer", "author": "byt3_m3chanic", "description": "Dumb little shader that i've been playing with - trying to do some title effects - very nerdy I know..", "tags": ["raymarching", "fractal", "refraction", "computer", "replica"], "likes": 55, "viewed": 794, "published": 3, "date": "1632846283", "time_retrieved": "2024-07-30T18:58:52.080858", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Fractal Computer\n\n    Buffer A / Fragment Shader\n    Buffer B / Title and Text Overlay\n\n*/\n\n#define R iResolution\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n\tvec2 uv = F.xy/R.xy;\n    \n    vec3 A = texture(iChannel0, uv).rgb;\n    vec4 B = texture(iChannel1, uv);\n    vec3 C = mix(A,vec3(B.rgb),B.w);\n    \n    // output\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Fractal Computer\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nfloat tmod,ga1,ga2,ga3,ga4,ga5,ca1;\n\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// polar mod\nfloat modPolar(inout vec2 p, float rep) {\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (rep/2.)) ? abs(c) : c;\n} \n\n//globals\nmat2 tprot, rx, ry;\n\n//folds\nvoid siepr(inout vec4 p, float k1, float k2, float k3, float k4) {\n\tif (p.x + p.y<0.0) p.xy = -p.yx;\n\tif (p.x + p.z<0.0) p.xz = -p.zx;\n\tif (p.y + p.z<0.0) p.zy = -p.yz;\n\tp.xyz = p.xyz*k1 - vec3(k2, k3, k4)*(k1 - 1.0);\n\tp.w *= k1;\n}\n\nconst float zoom = 10.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n    vec3 pp = p;\n    \n    p.x+=(ga5*14.5)-2.5;\n    p.y+=.75;\n    \n    p.x=mod(p.x+7.25,14.5)-7.25;\n    vec4 P = vec4(p.xyz, 1.0);\n\n    P.yz*=rot(ga2*PI);\n    P.xz*=rot(ga1*PI);\n    P.x+=1.75; \n    siepr(P,1.,1.,1.,1.); \n    \n    vec3 q = P.xyz;\n    \n    float fw = 2.75+1.25*sin(ga4);\n    q.x=abs(q.x)-((ga3*5.));\n    q.z=abs(q.z)-((ga2*2.5)+1.);\n    q.y+=1.;\n    \n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(0,2.50,.775),vec3(1.3,1.,1.1));\n    float cutbox_lower = sdbox(vec3(q.xy,abs(q.z))-vec3(0,-.225 ,.775),vec3(.75,1.5,.3 ));\n\n    cutbox = min(cutbox_lower, cutbox);\n    mainbox = max(mainbox, -cutbox);\n\n    vec3 fq = vec3(q.y,abs(q.x),q.z);\n    float frame = sdframe(q-vec3(0,1.1,0),vec3(1.6,3.1,.82),.075)-.0125;\n    frame = min(sdbox(fq-vec3(.020,.835,.1),vec3(1.675,.05,.75)),frame);\n    frame = min(sdbox(fq-vec3(-.20,.425,.6),vec3(1.6,.05,.15)),frame);\n\n    float screen = sdbox(q-vec3(0,2.50,.825),vec3(1.4,1.1,.05));\n    screen = max(screen, -cutbox);\n    frame = min(screen-.0125,frame);\n    \n    // parts\n    vec3 cq = vec3(q.y,q.z,abs(q.x));\n    //frame = min(sdbox(q-vec3(0,2.05,.5),vec3(.45,.195,.06)),frame);\n    frame = min(cap(cq-vec3(2.8,-.1,.625),.25,.6),frame);\n    frame = min(cap(cq-vec3(1.95,.15,.725),.125,.15),frame);\n    frame = min(cap(cq-vec3(2.05,.15,1.05),.075,.15),frame);\n    frame = min(sdbox(q-vec3(0,1.3,.6),vec3(.445,.35,.15)),frame);\n\n    mainbox = min(mainbox, frame);\n\n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n\n    vec3 tq1 = q.yzx-vec3(2.8,.25,.65);\n    vec3 pq1 = tq1;\n    pq1.xz*=tprot;\n    modPolar(pq1.xz,3.);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09,.09,.075));\n    \n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n\n    vec3 tq2 = q.yzx-vec3(2.8,.25,-.65);\n    vec3 pq2 = tq2;\n    pq2.xz*=tprot;\n    modPolar(pq2.xz,2.);\n    float tcby = sdbox(pq2-vec3(.4,0,0),vec3(.09,.09,.075));\n    float tape2 = cap(tq2,.575,.05);\n    tape2=max(tape2,-tcby);\n    \n    tape1 = min(tape1, tape2);\n    \n    if(tape1<res.x) res = vec2(tape1/P.w,3.);\n\n    // buttons\n    vec3 bq = q-vec3(.0,3.85,.65);\n    bq.x=abs(abs(bq.x)-.5)-.25;\n    bq.y=abs(bq.y)-.1;\n    float btn1 = sdbox(bq,vec3(.2,.05,.25))-.0125;\n    btn1 = min(sdbox(q-vec3(0,2.05,.5),vec3(.45,.195,.06))-.0125,btn1);\n    if(btn1<res.x) res = vec2(btn1/P.w,2.);\n\n    if(mainbox<res.x) res = vec2(mainbox/P.w,1.);\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d,.5);\n    vec3 lpos =  vec3(8,10,-8);\n    lpos.xz*=ry;\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.3);\n    \n    if(m==1.) h=mix(vec3(.05),vec3(.3),clamp((p.y+4.)*.1,0.,1.));\n\n    if(m==2.) {\n        vec3 h2=mix(vec3(0.596,0.110,0.690),vec3(0.129,0.467,0.831),clamp((p.x+4.)*.07,0.,1.));\n        h=mix(vec3(0.016,0.431,0.008),h2,clamp((p.z+4.)*.07,0.,1.));\n    }\n    if(m==3.) {\n        vec3 h2 = h=mix(vec3(0.639,0.596,0.000),vec3(0.165,0.698,0.180),clamp((p.x+4.)*.1,0.,1.));\n        h=mix(h2,vec3(0.169,0.569,0.871),clamp((p.y+4.)*.1,0.,1.));\n    }\n    \n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    \n    tprot=rot(T*75.*PI/180.);\n    //all the timing stuff\n    tmod = mod(time, 16.);\n    float t1 = lsp(0.0, 2.0, tmod);\n    float t2 = lsp(6.0, 7.0, tmod);\n    \n    float t3 = lsp(2.0, 3.5, tmod);\n    float t4 = lsp(9.0, 10.0, tmod);\n    \n    float t5 = lsp(4.0, 5.0, tmod);\n    float t6 = lsp(9.0, 10.0, tmod);\n\n    float t7 = lsp(4.0, 6.0, tmod);\n    float t8 = lsp(14.0, 16.0, tmod);\n    float t9 = lsp(11.0, 15.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n \n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3; \n    \n    ga4 = eoc(t7-t8);\n    ga4 = ga4*ga4*ga4;\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = (t9);//+floor(time*.1);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .125 - .0625) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * .125 - .0625) * PI;\n   \n    float msw = mod(time*.5,32.);\n    float m1 = lsp(0.0, 4.0, msw);\n    float m2 = lsp(16.0, 20.0, msw);\n    ca1 = eoc(m1-m2);\n    ca1 = ca1*ca1*ca1; \n    \n    x += mix(-.38539816339,-.78,ca1);\n    y += mix(2.35,.64,ca1);\n    \n    rx = rot(x);\n    ry = rot(y);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(.0075);\n    vec3  p = ro + rd;\n    float atten = .95;\n    float k = 1.;\n    float d = 0.;\n    //@blackle's transparent \n    //marcher modified\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<48 ? ray.x*.25 : ray.x;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .575;\n            p += rd*.075;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n\n            if(m==3.) {\n                rd=reflect(-rd,n);\n                p+=n*.05;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    //C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    09/28/21 @byt3_m3chanic \n    Title Overlay Template\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat time,tmod,ga1,ga2,ga3,ca1,ca2,ca3;\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= .5;\n    v += char(p, 46);      p.x -= .95;\n    v += pInt(p,fract(n)*1e2);\n    return v;\n}\n////////////////////////////////////////////////////////\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getHeader(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)+vec2(1.95,+.5) )/.5;\n\n    C(6); low C(18);C(1);C(3);C(20);C(1);C(12); spc caps\n    \n    C(3); low C(15);C(13);C(16);C(21);C(20);C(5);C(18); spc caps\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    float ofs = ca3*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.03),vec2(ofs ,.0425));\n    tapeline=smoothstep(px,.001-px,tapeline);\n\n    return vec4(vec3(C),ca3>0.?clamp(tapeline-shadetext,0.,1.):0.);\n}\n\nvec4 getDate(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)+vec2(1.825,.5) )/.35;\n\n    low C(2);C(25);C(20);U.x-=.4;\n    O+=pInt(U,3.);\n    spc\n    C(13);U.x-=.475;\n    O+=pInt(U,3.);\n    C(3);C(8);C(1);C(14);C(9);C(3);\n    spc spc\n    \n    O+=pInt(U,9.);C(-49); spc spc\n    O+=pInt(U,28.);C(-49); spc spc\n    O+=pInt(U,21.);\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    float ofs = ca2*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.04),vec2(ofs ,.025));\n    tapeline=smoothstep(px,.001-px,tapeline);\n    \n    return vec4(C,ca2>0.?clamp(tapeline-shadetext,0.,1.):0.);\n}\n\nfloat getHatch(vec2 p, float res) {\n    p *= res;\n    float hRnd = hash21(floor(p*.5));\n\n    if (hRnd > 0.33) p*= rot(1.57079632679);\n    float hatch = clamp(sin((p.x - p.y)*PI*2.)*2. + .5, 0., 1.);\n    return hatch;\n}\n\nvec4 getFrame(vec2 uv, float px) {\n\n    vec2 fv = uv;\n    fv.y += .0085*sin(fv.x*70.+T*10.);\n    float frame=box(fv-vec2(.7,-.59),vec2(.25,.25));\n    frame=smoothstep(px,-px,frame);\n    \n    vec3 h2 =mix(vec3(0.639,0.000,0.565),vec3(0.165,0.698,0.180),clamp((uv.x)*2.,0.,1.));\n    vec3 C=mix(h2,vec3(0.122,0.122,0.122),1.-clamp((uv.y+.615)*1.75,0.,1.));\n    float hatch = getHatch(uv,100.);\n    C = mix(C,vec3(0.271,0.271,0.271),hatch);\n    return vec4(C,frame);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n    time = T+50.;\n\n    float msw = mod(time,32.);\n    float m1 = lsp(0.0, 4.0, msw);\n    float m2 = lsp(16.0, 20.0, msw);\n    \n    ca1 = eoc(m1-m2);\n    ca1 = ca1*ca1*ca1;\n    \n    float m3 = lsp(20.0, 21.0, msw);\n    float m4 = lsp(31.0, 32.0, msw);\n    \n    ca2 = eoc(m3-m4);\n    ca2 = ca2*ca2*ca2;\n    \n    float m5 = lsp(19.5, 20.5, msw);\n    float m6 = lsp(30.5, 31.5, msw);\n    \n    ca3 = eoc(m5-m6);\n    ca3 = ca3*ca3*ca3;\n    \n    vec2 vuv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float px = .002;\n    vec3 C = vec3(0,0,0);\n\n    vec4 frame = getFrame(vuv+vec2(0,ca1), px);\n    C = mix(C,frame.rgb,frame.w);\n  \n    vec4 logo = getHeader(vuv-vec2(.65,-(.4+ca1)), px);\n    C = mix(C,logo.rgb,logo.w);\n    \n    vec4 date = getDate(vuv-vec2(.65,-(.475+ca1)), px);\n    C = mix(C,date.rgb,date.w);\n    \n    float alpha = clamp(frame.w+logo.w+date.w,0.,1.);\n    O = vec4(C,alpha);\n}\n\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[246, 246, 287, 287, 499]], "test": "untested"}
{"id": "7scSzM", "name": "basic dome", "author": "jorge2017a2", "description": "basic dome", "tags": ["basicdome"], "likes": 2, "viewed": 238, "published": 3, "date": "1632838744", "time_retrieved": "2024-07-30T18:58:53.131051", "image_code": "//por jorge2017a1\n//referencia\n//https://www.shadertoy.com/view/7sc3RB-----dr2\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\nconst float pi = 3.14159;\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\n\nvec3 copula(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    float sds1=sdSphere(p, 4.5 );\n    float sdb1= sdBox(p-vec3(0.0,0.0,-3.0), vec3(5.0,5.0,3.0) );\n    \n    \n    //https://www.shadertoy.com/view/7sc3RB-----dr2\n      float rEx = 5.;\n      vec3 q = DodecSym (p);\n      float d = length (q) - rEx;\n      float a1 = 0.5 * acos (-1. / sqrt (5.));\n      float a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  \n      d = SmoothMax (d, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.04, 0.04);\n      \n    \n    float dif1=differenceSDF(d,sds1);\n    dif1=differenceSDF(dif1,sdb1);\n    res =opU3(res, vec3(dif1,3.0,-1.0)); \n    return res;\n}   \n\nvec3 tdoCopula(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    p= rotate_x( p, radians(90.0));\n    vec3 co1= copula(p);\n    res =opU3(res, co1); \n    p=pp;\n    p.x=abs(p.x)-4.0;\n    p.z=abs(p.z)-2.5;\n    \n    float sdcy1= sdCylinderXZ( p-vec3(0.0,-2.0,0.0), vec2(0.5,3.0) );\n    res =opU3(res, vec3(sdcy1,2.0,-1.0));\n    return res;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p= rotate_x( p, radians(90.0));\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,8.0));\n    p.y=p.y-5.0;\n    \n    p= rotate_y( p, radians(90.0));\n    vec3 tc1=tdoCopula(p-vec3(10.0,0.0,0.0));\n    res =opU3(res, tc1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n        \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-15.0);\n   //ro= getMouse(ro);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_z(rd, iTime*0.5);\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[566, 566, 602, 602, 623], [624, 624, 656, 656, 740], [741, 741, 787, 787, 874], [875, 875, 914, 914, 1009], [1010, 1010, 1049, 1049, 1144], [1145, 1145, 1184, 1184, 1279], [1281, 1325, 1372, 1372, 1399], [1400, 1400, 1443, 1443, 1470], [1471, 1471, 1519, 1519, 1547], [1549, 1574, 1608, 1608, 1704], [1705, 1705, 1739, 1739, 1830], [1831, 1831, 1865, 1865, 1956], [1957, 1957, 1991, 1991, 2086], [2089, 2089, 2134, 2134, 2226], [2228, 2228, 2273, 2273, 2311], [2312, 2312, 2342, 2342, 2455], [2457, 2457, 2488, 2488, 2552], [2554, 2554, 2578, 2578, 3129], [3132, 3132, 3153, 3153, 3853], [3858, 3858, 3882, 3882, 4208], [4211, 4211, 4236, 4236, 4561], [4563, 4563, 4587, 4587, 4749], [4751, 4751, 4800, 4800, 5467], [5469, 5469, 5505, 5505, 5750], [5752, 5752, 5779, 5779, 5796], [5798, 5798, 5834, 5834, 5926], [5927, 5927, 5973, 5973, 6098], [6100, 6100, 6137, 6137, 6413], [6416, 6416, 6483, 6483, 6760], [6763, 6763, 6846, 6846, 7773], [7775, 7775, 7868, 7868, 7998], [8000, 8000, 8032, 8032, 8229], [8231, 8279, 8307, 8307, 8495], [8497, 8497, 8544, 8544, 8780], [8782, 8782, 8875, 8875, 9216], [9218, 9218, 9249, 9249, 9848], [9850, 9850, 9876, 9876, 9986], [9988, 9988, 10046, 10046, 10098], [10100, 10100, 10157, 10157, 10756]], "test": "untested"}
{"id": "Nd3XzM", "name": "point-in-triangle", "author": "Arthas_me", "description": "Determine if a point is in a triangle.", "tags": ["sdf"], "likes": 1, "viewed": 225, "published": 3, "date": "1632820542", "time_retrieved": "2024-07-30T18:58:53.954848", "image_code": "\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 n) {\n    return length((p - a) - dot((p - a), n) * n);\n}\n\n\nbool pointInTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    return cross(b - a, p - a).z > 0. &&\n        cross(c - b, p - b).z > 0. &&\n        cross(a - c, p - c).z > 0.;\n}\n\n\nvec2 lineIntersection(in vec2 p1, in vec2 n1, in vec2 p2, in vec2 n2) {\n  float a = n1[1] / (n1[0] + 1e-10);\n  float c = p1[1] - a * p1[0];\n\n  float b = n2[1] / (n2[0] + 1e-10);\n  float d = p2[1] - b * p2[0];\n\n  float x = (d - c) / (a - b);\n  float y = a * x + c;\n\n  return vec2(x, y);\n}\n\n\nfloat N = sqrt(0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y; // -1 <> 1 by height\n\n    float r = 0.01;\n\n    vec2 a1 = vec2(0.7, 0.), n1 = vec2(N, N);\n    vec2 a2 = vec2(0.7, 0.), n2 = vec2(-N, N);\n    vec2 a3 = vec2(0., 0.), n3 = vec2(sin(iTime) , cos(iTime));\n    \n\n    float c = sdLine(p, a1, n1) - r;\n    c = min(c, sdLine(p, a2, n2) - r);\n    c = min(c, sdLine(p, a3, n3) - r);\n    \n    \n    vec3 A = vec3(lineIntersection(a3, n3, a1, n1), 0.);\n    vec3 B = vec3(lineIntersection(a1, n1, a2, n2), 0.);\n    vec3 C = vec3(lineIntersection(a3, n3, a2, n2), 0.);\n\n    float x = pointInTriangle(vec3(p, 0.), A, B, C) && c > 0.08 ? 1. : 0.;\n    c = step(c, 0.02);\n    c = max(c, x);\n    c *= (1. - pow(length(p), 2.));\n\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3XzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 49, 49, 101], [104, 104, 170, 170, 287], [290, 290, 361, 361, 577], [602, 602, 659, 659, 1459]], "test": "untested"}
{"id": "NdcSzM", "name": "Light at the End of the K hole", "author": "xenn", "description": "An impression of an alien eye can occur more apparently under higher resolutions\n\n ~ Kaiju [eye of] Sauron ~\n\n. Try going full screen then Alt-1 (to refresh/force 100% pixel canvas extents\nmouse click influences general direction ", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 4, "viewed": 308, "published": 3, "date": "1632819451", "time_retrieved": "2024-07-30T18:58:55.060891", "image_code": "\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 3.51;\n    float b = 01.03;\n    float c = 1.43;\n    float d = 1.59;\n    float e = 02.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = max(col,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                     col2 = min(col,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col2,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),(550.0 * abs(sin(iTime / 13.0))) +150.);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(-1,-1,2));\n    float diff=clamp(dot(n,light),0.05,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)-vec4(diff)*vec4(spec);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom -0.1\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.013456\n#define iBlob2ColorPulseSpeed -0.012345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 64;\nfloat blur = 01.5; \nfloat falloff = 5.50; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 2.975;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = .666;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .444;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 2.5;\nconst float iFeedbackMouseShiftFactor = .0025;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 3.1))), dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * (iFeedbackMouseShiftFactor * (2.0 * sin(iTime / 2.0)))\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * ( iFeedbackColorShiftZoom * (1.5 * sin(iTime / 2.81))) * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.rg/colorShift.gr * 1.5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n    prevColor = mix(prevColor , prevColor2,(0.75 + ( 0.5 * cos(iTime))));\n\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * (iColorShiftOfRadius * cos(iTime / 3.3));\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    \n//         vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel2,uv);\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col,col2,0.025);\n  \n // fragColor=blend;\n  \n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col3,(0.5 +( 0.5 * sin(iTime))));\n  col = mix(blend,col2, 0.025);\n  blend = min(blend,col);\n  col = mix(blend,col2, 0.025);\n   blend = max(blend,col);\n  blend = blend - ((blend / 50.50) * (col2 / 1.0));\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.00251*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 139, 139, 218], [220, 220, 243, 243, 385], [387, 387, 444, 444, 1795]], "test": "untested"}
{"id": "NscXRM", "name": "sdLine", "author": "Arthas_me", "description": "Distance to a line(represented by a point and direction)", "tags": ["sdf"], "likes": 0, "viewed": 261, "published": 3, "date": "1632818162", "time_retrieved": "2024-07-30T18:58:55.912614", "image_code": "\nfloat sdLine(in vec2 p, in vec2 a, in vec2 d) {\n    return length((p - a) - dot((p - a), d) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 a = vec2(1., 0.);\n    vec2 dir = vec2(sin(iTime), cos(iTime));\n\n\tfloat d =  sdLine(p, a, dir) - 0.2;\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d =  sdLine(p, a, dir) - 0.2;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 100], [102, 102, 159, 159, 875]], "test": "untested"}
{"id": "7sdSzN", "name": "Voxel Sub-Object Relfections #3", "author": "Yusef28", "description": "An extension of the voxel shaderby jt: Cast Voxels March Sub-Objects\nhttps://www.shadertoy.com/view/7sdSzH\nThis(my code) is not an efficient example of a voxel renderer. Just a proof of \nconcept, here showing clearly that the reflections are accurate. ", "tags": ["reflection", "voxel", "subobject"], "likes": 6, "viewed": 260, "published": 3, "date": "1632807608", "time_retrieved": "2024-07-30T18:58:56.845120", "image_code": "/*\n\nVoxel Sub-Object Reflections\nAn extension of the voxel shader by jt:\n\nCast Voxels March Sub-Objects\nhttps://www.shadertoy.com/view/7sdSzH\n\nThis shader demonstrates reflections within\na voxel shader, that reflect the image based on\nwhat objects (SDFs in this case) are stored\ninside each voxel.\n\nThere is another purely voxel relflection shader\nby wildniklin:\nVoxel Reflections\nhttps://www.shadertoy.com/view/NsjSWy\n\nand iq has another voxel shader with sub-voxel\nobjects with emissive objects (so multiple light \nbounces)\n\nBTW this could be way faster. I did everything \nin the voxel marching the slowest way with branching.\n\nIt was more for me to review what is actually going\non. \n\nThe code is bloated over all.\n*/\n#define far 50.\n\nfloat formID = 0.;\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat Sphere_Box_LERP(vec3 p){\n\n    float id = formID;\n    \n    float left = (sdBox(p,vec3(0.3)) - id/6.)*(step(0.,p.x));\n    float right = (sdSphere(p,0.5))*(step(p.x,0.));\n    //return  right;\n    return mix(sdSphere(p,0.5),\n               sdBox(p,vec3(id*0.4)) \n               - (1.-id*0.3)/4., id);\n    \n}\nbool getVoxel(vec3 c) {\n    //c.xz *= rot(iTime);\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(sdSphere(p-vec3(-4.,0.,0.), 2.5), \n                  sdBox(p-vec3(4.,0.,0.), vec3(2.0)));\n    //float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\n\n\nbool map(vec3 p){\n    return getVoxel(p);\n    //return length(p) - 1.5 < 0.;//\n    return (5.-length(p.xy + vec2(sin(p.z/8.)*6., 0.))) < 0.00;\n}\n\nfloat fMap(vec3 p){\n    \n    return Sphere_Box_LERP(p);\n    return length(p)-0.5;\n}\n\n\nvec3 ray(vec2 uv, vec3 ro, vec3 lk){\n    vec3 fwr = normalize(lk - ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = cross(uu,fwr);\n    vec3 up = cross(fwr,ri);\n    return normalize(ri * uv.x + up * uv.y + fwr);\n}\n\nvec3 normal(vec3 p){\n\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(\n    fMap(p - e.xyy) - fMap(p + e.xyy),\n    fMap(p - e.yxy) - fMap(p + e.yxy),\n    fMap(p - e.yyx) - fMap(p + e.yyx)\n    ));\n}\n\nfloat trace(vec3 ro,vec3 rd){\n    float t = 0., d;\n    \n    for(float i = 0.; i < 50.; i++){\n        d = fMap(ro + rd*t);\n        \n        if(d < 0.001 ) return t;\n        \n        t += d;\n    }\n    return far;\n}\n\nfloat voxelTrace(inout vec3 ro, \n                 inout vec3 rd,\n                 inout vec3 col){\n\n    vec3 pos = floor(ro);\n    vec3 delta = abs(1./rd + 0.001);\n    vec3 steps = vec3(0.);\n    \n    vec3 light1 = vec3(0.,sin(iTime)*8.,0.);\n    \n    steps.x = rd.x < 0. ? \n      (ro.x - pos.x)*delta.x : \n      (pos.x + 1. - ro.x)*delta.x;\n    \n    steps.y = rd.y < 0. ? \n      (ro.y - pos.y)*delta.y : \n      (pos.y + 1. - ro.y)*delta.y;\n      \n    steps.z = rd.z < 0. ? \n      (ro.z - pos.z)*delta.z : \n      (pos.z + 1. - ro.z)*delta.z;\n    \n    vec3 richtung = sign(rd);\n    \n    float t = 100.;\n    \n    for(int i = 0; i < 100; i++ ){\n    \n        if(map(pos)) {\n            //throw this in here, make a global\n            //id for the shape of the  sub-object.\n            float id = rnd(pos);\n            formID = id;\n            \n            // this: ro - pos - 0.5; shifts the \n            // null forward because we always check \n            // the space around 0.,0.! \n            // and -0.5 is for the same reason \n            // because we always shoot rays in from \n            // a place on a cube, it's like \n            // shooting into a square screen and \n            // we need to shift the world \n            // 0.5 in every dimention \n            vec3 shift = pos + 0.5;\n            //  the - shift is then \n            // -(pow + 0.5) = -pos - 0.5\n            \n            \n                   \n                   \n            float h = trace(ro - shift, rd);\n            \n               if( h < far && h > 0.){\n                   \n                   t = h;\n                   vec3 p = (ro - shift + rd*t);\n                   \n                   vec3 l = light1 - shift;\n                   vec3 ldir = l - p;\n                   vec3 n = normal(p);\n                   \n                   float ldist = max(length(l),0.);\n                   ldir/=ldist;\n                   \n                   float diff = max(dot(-ldir,n),0.);\n                   float spec = pow(max(dot(reflect(-ldir,n),-rd),0.),8.);\n                   \n                   col += diff*vec3(0.5,id,id*id)*1.+ spec;\n                   \n                   //needed a plus five here to work!\n                   //wow\n                   ro = pos + 0.5;// + n*.01;//nothing changes\n                   rd = reflect(rd, n);\n                   // + n*0.01;\n                   \n                   return h;\n            }\n            \n        }\n        \n        if(min(steps.x,min(steps.y,steps.z)) \n            == steps.x){\n            //adding 1's and -1's to the position\n            pos.x += richtung.x;\n            //adding delta components to the t line\n            steps.x += delta.x;\n        }\n        else if(min(steps.x,min(steps.y,steps.z)) \n                    == steps.y){    \n            pos.y += richtung.y;\n            steps.y += delta.y;\n        }\n        else\n        {\n            pos.z += richtung.z;\n            steps.z += delta.z;\n        }\n    }\n    return far;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,0., -4.);\n    ro.xz*= rot(iTime/8.);\n    vec3 lk = vec3(0.,0.,0.);\n    vec3 rd = ray(uv, ro, lk);\n    //rd.xz*= rot(iTime);\n    vec3 col = vec3(0.);\n    vec3 rcol = vec3(0.);\n    // Time varying pixel color\n   float t = voxelTrace(ro,rd,col);\n   if(t < far) voxelTrace(ro,rd,rcol);\n   //col = vec3((1.-t)*vec3(0.7,0.37,0.0));\n   col += rcol*0.38;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "mat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat rnd(vec3 st){\n    return fract(sin(dot(vec2(12.44,74.92),st.xz) + st.y)*43134.0);\n    }\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[757, 757, 790, 790, 818], [820, 820, 851, 851, 942], [945, 945, 975, 975, 1254], [1255, 1255, 1278, 1304, 1554], [1558, 1558, 1575, 1575, 1702], [1704, 1704, 1723, 1723, 1787], [1790, 1790, 1826, 1826, 2002], [2004, 2004, 2024, 2024, 2207], [2209, 2209, 2238, 2238, 2421], [2423, 2423, 2521, 2521, 5392], [5393, 5393, 5450, 5500, 5986]], "test": "untested"}
{"id": "7stSzN", "name": "Northern Melter", "author": "TEttinger", "description": "This changes the \"Northern Elves\" shader drastically by switching from sin and cos to Quilez' Basic Noise. It looks like melting liquid metal, which is fun.", "tags": ["noise", "basic", "plasma", "metal", "melter", "northern"], "likes": 9, "viewed": 657, "published": 3, "date": "1632800610", "time_retrieved": "2024-07-30T18:58:57.608080", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 69.42; // starts off with a \"melting face\"\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\nconst vec3 SECTION = fract(COEFFS.zxy - COEFFS.yzx * 1.618);\n\n// Quilez Basic Noise, from https://www.shadertoy.com/view/3sd3Rs (MIT-license)\nvec3 bas( vec3 x )\n{\n    // setup    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    vec3 s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    vec3 k = fract(SECTION * i + i.yzx);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// this is different from other swayRandomized in Northern demos because it uses Quilez basic noise instead of trigonometry.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return bas(seed.xyz + value.zxy - bas(seed.zxy + value.yzx) + bas(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con)\n    ) * 0.5;\n    //+ swayRandomized(c + 1.1, con.xyz)\n    //+ swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = (fragCoord + cos(iTime * 0.3) * 64.0) * (2.125 + sin(iTime * 0.25));\n    vec2 uv = (fragCoord * 0.1) + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx - fragCoord.yxy * 0.004).xy * 42.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj.yzx)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con);\n    \n    fragColor = vec4(sin(con * 3.1416) * 0.5 + 0.5,1.0);\n//    fragColor = vec4(swayRandomized(COEFFS + 3.0, con) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 439, 459, 476, 752], [754, 879, 923, 923, 1019], [1021, 1235, 1266, 1266, 1417], [1419, 1419, 1476, 1561, 2272]], "test": "untested"}
{"id": "7d3Sz4", "name": "Damped Spring ODE", "author": "oneshade", "description": "My first second order ODE. Especially fun because afterwards I can make a fun animation with it! :)\nSolving process (updated): https://www.desmos.com/calculator/z8c1limv0t", "tags": ["solution", "spring", "oscillation", "damping", "ode"], "likes": 13, "viewed": 289, "published": 3, "date": "1632788971", "time_retrieved": "2024-07-30T18:58:58.521638", "image_code": "// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\n// mx'' + ux' + kx = 0\nfloat springODE(in float t, in float t0, in float x0, in float v0,\n                in float m, in float u, in float k) {\n\n    t -= t0;\n    float alpha = -u / (2.0 * m);\n    float discr = alpha * alpha - k / m;\n    float beta = sqrt(abs(discr));\n\n    if (discr < 0.0) { // Normal oscillation\n        float w = beta * t;\n        return (x0 * cos(w) - (alpha * x0 - v0) / beta * sin(w)) * exp(alpha * t);\n    }\n\n    if (abs(discr) < 1e-3) { // No oscillation - edge case\n        return (x0 - (alpha * x0 - v0) * t) * exp(alpha * t);\n    }\n\n    // No oscillation\n    return (((beta - alpha) * x0 + v0) * exp((alpha + beta) * t) +\n            ((beta + alpha) * x0 - v0) * exp((alpha - beta) * t)) / (2.0 * beta);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0 * cos(iTime), sin(0.5 * iTime)) * 2.0;\n\n    // Constants: mass (m), springiness (k), resistance/friction (u)\n    float m = 1.0;\n    float k = 100.0;\n    float u = 0.8;\n\n    // Initial position (x0) and initial velocity (v0)\n    float x0 = 3.0;\n    float v0 = 0.0;\n\n    // Position vs. time graph\n    float y = springODE(iTime - uv.x, 0.0, x0, v0, m, u, k) - 2.0;\n    float dx = (springODE(iTime - uv.x + 0.001, 0.0, x0, v0, m, u, k) - 2.0 - y) / 0.001;\n    if (uv.x > 0.0 && uv.x < iTime) drawSDF(abs(uv.y - y) / sqrt(1.0 + dx * dx), vec3(1.0, 0.0, 0.0));\n\n    // Spring and weight\n    float x = springODE(iTime, 0.0, x0, v0, m, u, k) - 2.0;\n    if (uv.y < 8.0 && uv.y > x) drawSDF(udTriangleWave(vec2(uv.y - 4.0, uv.x), 12.0 / (4.0 - x), 0.7), vec3(0.0));\n    drawSDF(sdDisk(uv, vec2(0.0, x), 0.5), vec3(0.0, 0.0, 1.0));\n\n    // Vignette\n    color *= 1.0 - 2.0 * pow(length(fragCoord / iResolution.xy - 0.5), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3Sz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 56, 56, 88], [90, 90, 137, 137, 245], [247, 288, 350, 350, 603], [605, 628, 748, 748, 1337], [1419, 1419, 1474, 1474, 2748]], "test": "untested"}
{"id": "sstXz4", "name": "Evangelion Leliel Angel", "author": "boddiul", "description": "...", "tags": ["waves"], "likes": 0, "viewed": 227, "published": 3, "date": "1632782379", "time_retrieved": "2024-07-30T18:58:59.374359", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 120;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 my_mod( vec3 p, float m) {\n    return p - m * round(p / m);\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length(p-c) - 1.0;////length ( my_mod(p, 5.0) - c ) - 1.0;\n}\n\nfloat dObj ( vec3 p )\n{\n\n    //p.x = sin(p.x);\n    \n    //p.y = sin(p.y);\n    \n    //return length(p)-1.0;\n    \n    int n = 0;\n\n\n    /*if (mod(p.x,2.0)<1.0)\n        {p=vec3(0.0,p.z,p.y);}\n        \n        \n     \n    \n    return length(p) - 1.0;*/\n    \n    /*\n    if (p.x>0.0 )\n        return length(p)-10.0;//return length(p) - 1.0;\n    else\n    {\n        \n    }*/\n    \n    \n    \n    if (p.x<-5.0)\n    {\n        return -iTime-sin(p.x*2.0+p.y*2.0);\n    }\n    else\n    {\n        if (length(p)<10.0 )\n            return sin(p.x+iTime/2.0+p.y-p.z)+10.0*cos(iTime*p.x+p.y-p.z);\n        else\n            return length(p)-10.0;\n    \n    }\n    \n    \n    \n    \n    \n    \n    /*\n    vec3 +1 = vec3(10,10,10);\n\tvec3 a2 = vec3(-10,-10,10);\n\tvec3 a3 = vec3(10,-10,-10);\n\tvec3 a4 = vec3(-10,10,-10);\n    vec3 cc;\n    vec3 z = p;\n    int Iterations = 100;\n    float Scale = 0.5;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < Iterations) {\n\t\t cc = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { cc = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { cc = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { cc = a4; dist=d; }\n\t\tz = Scale*z-cc*(Scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(Scale, float(-n));*/\n    \n    /*\n    int Iterations = 100;\n    float Scale = 0.5;\n    vec3 Offset;\n    vec3 z = p;\n    float r;\n    int n = 0;\n    while (n < Iterations) {\n       if(z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.0) z.zy = -z.yz; // fold 3\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n    */\n\n}\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   q += 30.0-min(iTime,20.0) ;\n    \n    //return dSphere ( q, vec3 ( 0, 0, 0 ) );\n    return dObj ( q);\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\t//return smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 100.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 185, 212, 212, 359], [361, 399, 426, 426, 573], [575, 575, 606, 606, 641], [643, 643, 680, 680, 749], [751, 751, 774, 857, 2372], [2373, 2373, 2402, 2402, 2470], [2472, 2472, 2501, 2501, 2588], [2591, 2591, 2624, 2624, 2705], [2707, 2707, 2749, 2749, 2819], [2821, 2821, 2846, 2941, 2985], [2987, 2987, 3023, 3023, 3289], [3291, 3291, 3358, 3358, 3674], [3676, 3676, 3728, 3728, 4097], [4099, 4099, 4156, 4211, 5077]], "test": "untested"}
{"id": "sdtXz4", "name": "Peacock feather pulse", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "spiral"], "likes": 7, "viewed": 242, "published": 3, "date": "1632781796", "time_retrieved": "2024-07-30T18:59:00.136321", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=(iTime)/16.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += t;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.25;\n        float scale1 = 1.9;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = sin(uv.yx/s1)*s1;\n            uv= -fract(uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))*scale/scale1;\n            uv.y /= -scale1;\n            scale1 += (uv.x*(.005*fract(uv.x+t*s1)));\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.0;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 808]], "test": "untested"}
{"id": "fddSR4", "name": "star #2", "author": "jorge2017a2", "description": "star #2", "tags": ["star2"], "likes": 0, "viewed": 200, "published": 3, "date": "1632754296", "time_retrieved": "2024-07-30T18:59:01.076807", "image_code": "//por jorge2017a1\n//https://iquilezles.org/articles/distfunctions2d\n//https://iquilezles.org/articles/distfunctions\n///---------------\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\nconst vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\nreturn length(p)*sign(p.y);\n}\n\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n// c is the sin/cos of the angle, h is height\n// Alternatively pass q instead of (c,h),\n// which is the point at the base in 2D\nvec2 q = h*vec2(c.x/c.y,-1.0);\nvec2 w = vec2( length(p.xz), p.y );\nvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\nvec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\nfloat k = sign( q.y );\nfloat d = min(dot( a, a ),dot(b, b));\nfloat s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y) );\nreturn sqrt(d)*sign(s);\n}\n\n\nvec3 estrellatd(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    p= rotate_y(p, radians(-iTime*10.0));\n    vec3 pp=p;\n   \n    p= rotate_x( p-vec3(0.0,1.0,0.0), radians(90.0));\n    float sdh1= sdHexagram( p.xy, 5.5 );\n    float sdb1=sdBox(p, vec3(12.0,12.0,2.0) );\n    float sint1= intersectSDF(sdb1, sdh1);\n    res =opU3(res, vec3(sint1,11.0,-1.0) );\n    \n    vec3 p1=pp;\n    p1.y+=2.0;\n    p1= rotate_x( p1, radians(90.0));\n    float sdh2= sdHexagram( p1.xy, 8.0 );\n    float sdb2=sdBox(p1, vec3(19.0,19.0,2.0) );\n    float sint2= intersectSDF(sdb2, sdh2);\n    res =opU3(res, vec3(sint2,12.0,-1.0) );\n    p=pp;\n    float sdco1= sdCone(p-vec3( 5.0,7.0,0.0),vec2(0.5,3.0), 5.5 );\n    float sdco2= sdCone(p-vec3(-5.0,7.0,0.0),vec2(0.5,3.0), 5.5 );\n    float sdco3= sdCone(p-vec3(0.0,7.0,6.0),vec2(0.5,3.0), 5.5 );\n    float sdco6= sdCone(p-vec3(0.0,7.0,-6.0),vec2(0.5,3.0), 5.5 );    \n    res =opU3(res, vec3(sdco1,13.0,-1.0) );\n    res =opU3(res, vec3(sdco2,10.0,-1.0) );\n    res =opU3(res, vec3(sdco3,13.0,-1.0) );\n    res =opU3(res, vec3(sdco6,10.0,-1.0) );\n    return res;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n   \n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    vec3 es1= estrellatd(p);\n    res =opU3(res,es1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n        \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,20.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd=rotate_x(rd, radians(45.0));\n   \n    light_pos1=ro;\n    light_pos2=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n   \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 627, 627, 711], [712, 712, 758, 758, 845], [846, 890, 937, 937, 964], [965, 965, 1008, 1008, 1035], [1036, 1036, 1084, 1084, 1112], [1113, 1151, 1190, 1190, 1234], [1235, 1300, 1334, 1334, 1430], [1431, 1431, 1465, 1465, 1556], [1557, 1557, 1591, 1591, 1682], [1683, 1683, 1717, 1717, 1812], [1814, 1814, 1857, 1857, 2090], [2093, 2093, 2140, 2268, 2581], [2584, 2584, 2609, 2609, 3662], [3665, 3665, 3690, 3690, 3891], [3893, 3893, 3917, 3917, 4079], [4081, 4081, 4130, 4130, 4761], [4764, 4764, 4800, 4800, 5045], [5047, 5047, 5074, 5074, 5091], [5093, 5093, 5129, 5129, 5221], [5222, 5222, 5268, 5268, 5393], [5395, 5395, 5432, 5432, 5708], [5711, 5711, 5778, 5778, 6055], [6058, 6058, 6141, 6141, 7078], [7080, 7080, 7173, 7173, 7303], [7305, 7305, 7337, 7337, 7534], [7536, 7584, 7612, 7612, 7800], [7802, 7802, 7849, 7849, 8075], [8077, 8077, 8170, 8170, 8511], [8514, 8514, 8545, 8545, 9144], [9146, 9146, 9172, 9172, 9282], [9284, 9284, 9342, 9342, 9394], [9396, 9396, 9453, 9453, 10029]], "test": "untested"}
{"id": "sdcXRN", "name": "Slowtember 13-15: Sky", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 9, "viewed": 304, "published": 3, "date": "1632738623", "time_retrieved": "2024-07-30T18:59:01.923542", "image_code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return fract(v);\n}\n\nmat2 rot(float angle) {\n    return mat2(\n        cos(angle * 2. * PI), -sin(angle * 2. * PI),\n        sin(angle * 2. * PI), cos(angle * 2. * PI)\n    );\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv *= rot(angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = sqrt((size.x * .5) * (size.x * .5) - (size.y * .5) * (size.y * .5));\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = sqrt((size.y * .5) * (size.y * .5) - (size.x * .5) * (size.x * .5));\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define SKY vec3(.4, .9, 1.)\n#define CLOUD_COMPLEXITY 20\n\nfloat cloud_base(vec2 uv, float seed) {\n    float cloud = .0;\n    \n    float min_x = .0;\n    float max_x = .0;\n    \n    float posx, posy;\n    vec2 pos, size;\n    \n    for(int i = 0; i < CLOUD_COMPLEXITY; i++) {\n        size = vec2(.1 + rand(seed++) * .2, .1 + rand(seed++) * .1);\n        posx = rand(seed++);\n        posy = rand(seed++);\n        pos = vec2((posx*posx - .5) * .5, (posy*posy) * .1 + size.y * .2);\n    \n        min_x = min(min_x, pos.x);\n        max_x = max(max_x, pos.x);\n    \n        cloud += ell(uv, pos, size, .0, (rand(seed++) - .5) * .1, E);\n    }\n    \n    return n(cloud);\n}\n\nvec3 cloud(vec3 c, vec2 uv, float t, float y) {\n    uv += vec2(t, .0);\n    float seed = floor(uv.x + .5);\n    uv.x = fract(uv.x + .5) - .5;\n    \n    uv -= vec2(rand(seed++) * .1, y + (rand(seed++) - .5) * .3);\n\n    float base = cloud_base(uv, seed);\n    float shadow_in = base - cloud_base(uv - vec2(.01, .05), seed) * base;\n\n    c = mask(c, vec3(1.), .9 * (base - shadow_in));\n    c = mask(c, vec3(.9), .9 * shadow_in);\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t) {\n    vec3 c = SKY;\n    \n    c = cloud(c, uv, t * .3, .2);\n    c = cloud(c, uv, t * .4, .0);\n    c = cloud(c, uv, t * .5, -.2);\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 c = image(uv, iTime);\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 55, 55, 89], [91, 91, 108, 108, 152], [154, 154, 202, 202, 260], [262, 262, 300, 300, 342], [344, 344, 368, 368, 449], [451, 451, 474, 474, 604], [606, 606, 681, 681, 1122], [1345, 1345, 1384, 1384, 1941], [1943, 1943, 1990, 1990, 2384], [2386, 2386, 2416, 2416, 2563], [2565, 2565, 2620, 2620, 2793]], "test": "untested"}
{"id": "sscSR4", "name": "golfing  bubbles (loopless) :297", "author": "FabriceNeyret2", "description": "golfing 707 chars  [url]https://shadertoy.com/view/7stSz8[/url]. See comments there.\n", "tags": ["golf", "loopless"], "likes": 7, "viewed": 407, "published": 3, "date": "1632732778", "time_retrieved": "2024-07-30T18:59:02.761302", "image_code": "// golfing  707 chars  https://shadertoy.com/view/7stSz8\n// More readable at the bottom ;-)\n\n\n// -16 by Xor -2 by Coyote\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2  R = iResolution.xy,\n          H = fract( 4e5 * sin( ceil(U = 5.*(U+U - R)/R.y).x * R ));\n    \n    float t = iTime * ( .5 + H.y ),\n          x = U.y += 3.*H.x;\n          x = floor( x-t -   .6*cos(x)  / ( 1.- .6*sin(x) )  ) + t;\n    O = 1. - R.yyyy/15.* abs( length( vec2( U.y - x - .6*cos(x) -.5+.3*sin(x) , \n                                            fract( U + .1*sin(x/.1) ) -.5 )\n                                    ) - mod( 8e4 * sin( H+(x-t) * R ), .2).y \n                            );\n}\n\n\n\n\n\n\n/* // --- 315 chars\n\n#define H(p)  fract( 4e5 * sin( p * R ) )\n  \n#define f   ( x + .6*cos(x) ) \n#define d   ( 1.- .6*sin(x) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 5.*( u+u - R ) / R.y,\n          H = H(ceil(U.x));\n    \n    float t = iTime * ( .5 + H.y ),\n          x = U.y += 3.*H.x;\n          x = floor( x-t -  ( f - x ) / d ) + t;\n    O = 1. - R.yyyy/15.* abs( length( vec2( U.y - f -.5*d , \n                                            fract( U + .1*sin(x/.1) ) -.5 )\n                                    ) - .2*H(H+(x-t)).y \n                            );\n}\n\n\n\n\n\n\n/* // --- 318 chars\n\n#define H(p)  fract( 4e5 * sin( p * R ) )\n  \n#define f   ( x + .6*cos(x+t) ) \n#define d   ( 1.- .6*sin(x+t) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 5.*( u+u - R ) / R.y,\n          H = H(ceil(U.x));\n    \n    float t = iTime * ( .5 + H.y ),\n          x = U.y += 3.*H.x - t;\n          x = floor( x -  ( f - x ) / d );\n    O = 1. - R.yyyy/15.* abs( length( vec2( U.y - f -.5*d , \n                                            fract( U + .1*sin(x/.1-t/.1) ) -.5 )\n                                    ) - .2*H(H+x).y \n                            );\n}\n\n\n\n\n\n\n/* // --- 352 chars\n\n#define H(p)  fract( 4e5 * sin( (p)* vec2(13,79)) )\n  \n#define f(x)   ( x + .6*cos(x+t) ) \n#define d(x)   ( 1.- .6*sin(x+t) ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 5.*( u+u - R ) / R.y,\n          H = H(ceil(U.x));\n    \n    float t = iTime * ( .5 + H.y ),\n          x = U.y += 3.*H.x - t,\n          y = x -  ( f(x) - x ) / d(x),\n          j = floor(y);\n    O = 1. - R.yyyy/15.* abs( length( vec2( U.y - f(j) -.5*d(j) , \n                                            fract( U + .1*sin(j/.1-t/.1) ) -.5 )\n                                    ) - .2*H(j+H).y \n                            );\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 158, 158, 663]], "test": "untested"}
{"id": "NscSzN", "name": "Triangle segment", "author": "Yahor10", "description": "Simple triangle with atan function", "tags": ["triangle"], "likes": 1, "viewed": 298, "published": 3, "date": "1632729392", "time_retrieved": "2024-07-30T18:59:03.659900", "image_code": "\nfloat sdfboxing(vec2 uv){\nif(uv.y <.4){\nreturn smoothstep(.29,.3,length(atan(uv.x,uv.y)));// triangle\n}\nelse\n return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    vec4 triangle = vec4(sdfboxing(uv));\n    vec4 tr1 = vec4(triangle)  + vec4(.0,.3,1.0,1.0);\n    fragColor =tr1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 124], [126, 126, 183, 233, 402]], "test": "untested"}
{"id": "fdcSzN", "name": "single pass CFD API", "author": "MacroMachines", "description": "the self-advection is done purely rotational, therefore no need for divergence-free-step.\ntry changing RotNum.\npress i-key to init image (e.g. in fullscreen)", "tags": ["simulation", "fluid", "cfd", "fluiddynamics"], "likes": 9, "viewed": 570, "published": 3, "date": "1632728001", "time_retrieved": "2024-07-30T18:59:04.523590", "image_code": "// Fork of \"single pass CFD\" by flockaroo. https://shadertoy.com/view/MdKXRy\n// 2021-09-27 07:31:20\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 3\n#define angRnd 1.0\n#define posRnd 0.0\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float ang2 = angRnd*randS(uv).x*ang;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    }\n    rot/=float(RotNum);\n    return rot;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / Res.xy;\n    vec2 scr=uv*2.0-vec2(1.0);\n    \n    float sc=1.0/max(Res.x,Res.y);\n    vec2 v=vec2(0);\n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n        float ang2 = angRnd*ang*randS(uv).y;\n        vec2 p = vec2(cos(ang2),sin(ang2));\n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2=p*sc;\n            float rot=getRot(uv+p2,sc);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v+=p2.yx*rot*vec2(-1,1); //maybe faster than above\n            p = m*p;\n        }\n      \tsc*=2.0;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor=texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    // add a little \"motor\" in the center\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) init(fragColor,fragCoord);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[864, 864, 921, 921, 1001]], "test": "untested"}
{"id": "sstXzn", "name": "fake light pebbles (153 chars)", "author": "hnh", "description": "Simple illumination effect.\nSee also https://www.shadertoy.com/view/fdV3Dt", "tags": ["2d", "illumination", "bumpmapping", "short", "golf"], "likes": 7, "viewed": 360, "published": 3, "date": "1632726844", "time_retrieved": "2024-07-30T18:59:05.402241", "image_code": "\nvoid mainImage(out vec4 O, vec2 P){\n\n//*\n// Shortest colored version (so far) by coyote: 153 chars\n  O= ( smoothstep(.9, 1.2, O= 3.* texture(iChannel0, P/5e2))\n       * (.02 - sin(O.a= .3*iTime)*dFdx(O) - cos(O.a)*dFdy(O)) ).r\n     * vec4(9,8,7,0);\n\n/*/\n// Monochrome version by GregRostami: 141 chars\n  O+= (.02 + sin(iTime)*dFdx(O.a= 3.*texture(iChannel0,P/5e2).r)\n      - cos(iTime)*dFdy(O.a)) * 9.*smoothstep(.9,1.,O.a);\n\n/* /\n// Reduced to 157 chars thanks to FabriceNeyret2 \n  float u= 3.* texture(iChannel0, P/5e2).r,\n        t= .3*iTime;\n  O= (.02 - sin(t)*dFdx(u) - cos(t)*dFdy(u))\n     * vec4(9,8,7,0) * smoothstep(.9,1.2,u);\n//     * mix(vec4(9,8,7,0),vec4(2,2,.5,0),1.-smoothstep(.9,1.2,u));  // \"puddle\" look\n\n/* /\n// Initial version (165 chars)\n  float u= texture(iChannel0, P/5e2).r,\n  t= .3*iTime;  \n  O= (.2 - 30.*vec4(sin(t)*dFdx(u) + cos(t)*dFdy(u)))\n     * vec4(.9,.8,.7,0)*smoothstep(.3,.4,u);\n//*/\n\n}\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 99, 923]], "test": "untested"}
{"id": "fd3SRN", "name": "Deconstructive Cube ", "author": "Tater", "description": "You can turn on shadows if you have extra fps. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 81, "viewed": 1256, "published": 3, "date": "1632725036", "time_retrieved": "2024-07-30T18:59:06.663869", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n//https://www.shadertoy.com/view/fdyGDt\n//https://www.shadertoy.com/view/7dVGDd\n\n//heavily inspired by\n//https://twitter.com/adamswaab/status/1437498093797212165\n\n//Toggle Shadows\n//#define USE_SHADOWS \n\n\n\n\n#define MDIST 350.0\n#define STEPS 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\nfloat nsdf = 0.;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    vec3 po = p;\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/4.);\n    \n    float MIN_SIZE = 0.5;\n    float ITERS = 5.;\n    float PAD_FACTOR = 1.01;\n    float BREAK_CHANCE = 0.2;\n   \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        if(i==0.0){\n        divHash = vec3(0.49,0.5,.51);\n        }\n        if(i>0.){\n            vec3 center = -(dMin + dMax)/2.0;\n\n            vec3 cs = vec3(0.3);\n            divHash = clamp(divHash,vec3(cs*sign(center)),vec3(1.0-cs*sign(-center)));\n\n        }\n        vec3 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE * PAD_FACTOR , dMax - MIN_SIZE * PAD_FACTOR );\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        \n        float minSize = min( minAxis.x, min( minAxis.y, minAxis.z ) );\n        bool smallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        if (i  > 0. && h11( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if (smallEnough && i  > 0.) { willBreak = true; }\n        if( willBreak ) {\n            break;\n        }\n\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 1.0);\n    \n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n\n    \n    if(any(isEdge)) {\n        float expand = 1.0+(3.0-h11(id)*3.)*swave(t*3.0+h11(id)*1.5,0.17);\n        if(isEdge.x){\n        center.x*=expand;\n        }\n        else if(isEdge.y){\n        center.y*=expand;\n        }\n        else if(isEdge.z){\n        center.z*=expand;\n        }\n    }\n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n    if(!any(isEdge)){\n        a=b;\n\n        nsdf =5.;\n    }\n    else nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(10.);\n    vec3 rd2 = rdg;\n\n    p.xz*=rot(t);\n    rd2.xz*=rot(t);\n    p.xy*=rot(pi/4.);\n    rd2.xy*=rot(pi/4.);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*2.0)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,3.5,-20)*2.;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.,1.,0));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.4,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        \n        float shadow = 1.;\n        \n#ifdef USE_SHADOWS\n        rdg = ld;\n        for(float h = 0.09; h<10.0;){\n            vec3 dd = map(p+ld*h+n*0.2);\n            if(dd.x<0.001){shadow = 0.3; break;}\n            //shadow = min(shadow,dd.z*20.0);\n            h+=dd.x;\n        }\n#endif\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.65)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres*shadow;\n        col*=pow(ao,0.2);\n        col*=max(shadow,0.7);\n\n    }\n    col = pow(col,vec3(0.9));\n    vec3 bg = vec3(0.698,0.710,0.878)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,pow(clamp(dO/MDIST,0.,1.),2.0));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 519, 586, 586, 625], [626, 626, 646, 646, 717], [718, 718, 739, 739, 791], [792, 792, 818, 818, 877], [878, 891, 920, 920, 1007], [1009, 1009, 1039, 1039, 1142], [1180, 1180, 1219, 1219, 3981], [3983, 3983, 4000, 4000, 4307], [4308, 4308, 4326, 4326, 4454], [4455, 4455, 4512, 4512, 6493]], "test": "untested"}
{"id": "4s3yR2", "name": "3D abstract volume cube sound", "author": "MacroMachines", "description": "i tried to rebuild the technique that creates the ambience sounds in my game project. it's based on additive synthesis. go ahead and \"listen\" to various textures :)", "tags": ["sound", "additive", "synthesis", "creepy"], "likes": 4, "viewed": 400, "published": 3, "date": "1632721514", "time_retrieved": "2024-07-30T18:59:07.746972", "image_code": "// Fork of \"sound - digital ambience\" by srtuss. https://shadertoy.com/view/MdXXW2\n// 2018-02-24 13:41:48\n\n// srtuss 2014\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n#define ITS 6\n\nvec2 circuit(vec3 p)\n{\n\tp = mod(p, 2.0) - 1.0;\n\tfloat w = 1e38;\n\tvec3 cut = vec3(1.0, 0.0, 0.0);\n\tvec3 e1 = vec3(-1.0);\n\tvec3 e2 = vec3(1.0);\n\tfloat rnd = 0.23;\n\tfloat pos, plane, cur;\n\tfloat fact = 0.9;\n\tfloat j = 0.0;\n\tfor(int i = 0; i < ITS; i ++)\n\t{\n\t\tpos = mix(dot(e1, cut), dot(e2, cut), (rnd - 0.5) * fact + 0.5);\n\t\tplane = dot(p, cut) - pos;\n\t\tif(plane > 0.0)\n\t\t{\n\t\t\te1 = mix(e1, vec3(pos), cut);\n\t\t\trnd = fract(rnd * 9827.5719);\n\t\t\tcut = cut.yzx;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2 = mix(e2, vec3(pos), cut);\n\t\t\trnd = fract(rnd * 15827.5719);\n\t\t\tcut = cut.zxy;\n\t\t}\n\t\tj += step(rnd, 0.2);\n\t\tw = min(w, abs(plane));\n\t}\n\treturn vec2(j / float(ITS - 1), w);\n}\n\nfloat scene(vec3 p)\n{\n\tvec2 cir = circuit(p);\n\treturn exp(-100.0 * cir.y) + pow(cir.x * 1.8 * (sin(p.z * 10.0 + iTime * -5.0 + cir.x * 10.0) * 0.5 + 0.5), 8.0);\n}\n\nfloat nse(float x)\n{\n    return fract(sin(x * 297.9712) * 90872.2961);\n}\n\nfloat nseI(float x)\n{\n    float fl = floor(x);\n    return mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(float x)\n{\n    return nseI(x) * 0.5 + nseI(x * 2.0) * 0.25 + nseI(x * 4.0) * 0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 suv = uv;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0, iTime * 0.92, 0.51);\n\tvec3 rd = normalize(vec3(uv, 0.39));\n\tro.xz = rotate(ro.xz, iTime * 0.91);\n\tro.xy = rotate(ro.xy, 0.02);\n\trd.xz = rotate(rd.xz, iTime * 0.2);\n\trd.xy = rotate(rd.xy, 0.92);\n\tfloat acc = 0.0;\n\tvec3 r = ro + rd * 0.95;\n\tfor(int i = 0; i < 10; i ++)\n\t{\n\t\tacc += scene(r + nse(r.x) * 0.053);\n\t\tr += rd * 0.05;\n\t}\n\tvec3 col = pow(vec3(acc * 0.04), vec3(0.2, 0.6, 0.10) * 8.0) * 2.0;\n\t//col -= exp(length(suv - 0.5) * -2.5 - 0.2);\n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col *= fbm(iTime * 6.0) * 2.0;\n\tcol = pow(col, vec3(1.0 / 2.2));\n\t//col = clamp(col, vec3(0.0), vec3(1.0));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "#define NSPC 32\n#define pi2 6.283185307179586476925286766559\n\nvec2 synth(float t)\n{\n\tvec2 v = vec2(0.0);\n\tfloat base = 100.0 ;//+ sin(t * 0.1) * 60.0;\n\tfloat flt = cos(t * 0.50) * 6.0 + 10.0;\n\tfloat fmd = smoothstep(-0.1, 0.1, sin(t * 10.0)) * 8.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 7);\n\t\tfloat inten = 1.0 / h;\n\t\tinten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.59 + 0.1;\n\t\tvec2 ti = texture(iChannel0, vec2(h / 256.0, t * 0.1)).xy;\n\t\tfloat f = ti.y * fmd;\n\t\tinten *= pow(ti.x, 14.0);\n\t\tinten *= exp(-max(8.0 - h * 4.0, 0.0));\n\t\tinten *= mod(h, 1.050);\n\t\tv.x += inten * sin(h + pi2 * (t * base * h) + f);\n\t\tv.y += inten * sin(pi2 * (t * base * h) + f);\n\t}\n\treturn v;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n\tvec2 m;\n\tm = synth(time);\n\tfloat ec = 0.5, fb = 0.18, et = 0.93, tm = 0.3;\n\tm += synth(time - et) * ec * vec2(1.0, 0.2); ec *= fb; et += tm;\n\tm += synth(time - et).yx * ec * vec2(0.2, 1.0); ec *= fb; et += tm;\n\t//m += synth(time - et) * ec * vec2(1.0, 0.2); ec *= fb; et += tm;\n\t//m += synth(time - et).yx * ec * vec2(0.2, 1.0); ec *= fb; et += tm;\n\tm *= 8.8;\n\treturn m;\n}", "sound_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3yR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 227], [244, 244, 266, 266, 894], [896, 896, 917, 917, 1058], [1060, 1060, 1080, 1080, 1132], [1134, 1134, 1155, 1155, 1254], [1256, 1256, 1276, 1276, 1351], [1353, 1353, 1410, 1410, 2184]], "test": "untested"}
{"id": "fdcSRN", "name": "2D_FLUID_single pass CFD Audio 3", "author": "MacroMachines", "description": "the self-advection is done purely rotational, therefore no need for divergence-free-step.\ntry changing RotNum.\npress i-key to init image (e.g. in fullscreen)", "tags": ["simulation", "fluid", "cfd", "fluiddynamics"], "likes": 3, "viewed": 358, "published": 3, "date": "1632720839", "time_retrieved": "2024-07-30T18:59:08.802151", "image_code": "// Fork of \"single pass CFD\" by flockaroo. https://shadertoy.com/view/MdKXRy\n// 2018-04-18 11:55:03\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    //fragColor += texture(iChannel1, fragColor.rg).rrrr;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// Modified with audio reactivity by www.axiom-crux.net\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 8 //cos(iTime*4.0)\n#define angRnd -8.0 //*cos(iTime*8.0) //*pow(fract(iTime*2.0)*2.0,4.50)\n#define posRnd -0.0\n#define intensity 1.0 //sin(iTime*0.5)+0.50)*2.50\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float fft = texture(iChannel2,fract(uv)).x-0.5*6.;\n    float ang2 = angRnd*randS(uv).x*ang ;//  * fft;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        //v+= fft;\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    } //while(RotNum > 0.0);\n    rot/=float(RotNum);\n    return rot*fft*1.25;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n\n#define INIT iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / Res.xy;\n    vec2 scr = uv*2.0-vec2(1.0);\n    \n    float sc = 1.0/max(Res.x,Res.y);\n    \n    vec2 v   = vec2(0);\n    \n    vec2 uuvv = vec2(length(uv-0.5),length(uv-0.50));\n    vec2 puv = atan(uv-0.5,uuvv);//uuvv);//,uv+0.5);\n  \n    vec4 fft = texture(iChannel2,(puv))*0.53;\n    vec4 fft2= texture(iChannel2,uuvv*0.1)*0.51;\n    vec4 fft4= fft2+fft*2.0;\n    vec4 fft3= texture(iChannel2,uv*vec2(0.25,0.0))*4.-1.5;\n    float fft33 = step(fft3.r,0.5);\n    \n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n       // if ( fft4.r > 0.21) break;\n        \n        float ang2 = angRnd * ang * randS(uv).y * fft3.r;\n        \n        vec2 p = vec2(cos(ang2),sin(ang2));\n        \n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2 = p*sc;\n            float rot = getRot(uv+p2, sc-0.01);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v += p2.yx * rot * vec2(-1,1.1); //maybe faster than above\n            p = m*p;\n        }\n        \n      \tsc *= 2.0 ;\n        sc /= fft4.r*1.0925051;\n        sc *= 2.01;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor = texture(iChannel0,fract(uv+(v*2.0-4.)/Res.x));\n    \n    fragColor = mix(fragColor,texture(iChannel2, fragColor.xy).rrrr*2.0-0.5009,0.02);\n    \n    \n    if(uv.y < 0.03 || uv.y > 0.99){ fragColor.rgb += fft33*0.975; fragColor.gb *= fft33*0.75;\n    }\n    //if(uv.y > 0.29 && uv.y < 0.71){ \n    //fragColor.gb += fft33*0.15; fragColor.gb *= fft33*0.15;\n   // }\n   fragColor += fft2.rrrr*0.01;\n    \n    \n   // scr += fft.rr;\n   \n     // add a little \"motor\" in the center\n    fragColor.xy += (0.02*intensity*scr.xy / (dot(scr,scr)/0.15+0.3));\n\n   // fragColor.xy += 0.01*fft.rg-0.00015;\n    \n    if(iFrame<=4 || INIT<0.5) fragColor = uv.rgrg;//init(fragColor,fragCoord);\n    \n    //fragColor /= fft.rrrr*1.1;//uuvv.rgr;\n    fragColor.rg *= 0.959+uv*0.051;\n    //fragColor += 1.0-texture(iChannel2,uv/2.);//-uv.rgrg*-0.01;\n}\n", "buffer_a_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[864, 864, 921, 921, 1059]], "test": "untested"}
{"id": "Ns3SRN", "name": "2D_FLUID_single pass CFD Audio 2", "author": "MacroMachines", "description": "the self-advection is done purely rotational, therefore no need for divergence-free-step.\ntry changing RotNum.\npress i-key to init image (e.g. in fullscreen)", "tags": ["simulation", "fluid", "cfd", "fluiddynamics"], "likes": 2, "viewed": 294, "published": 3, "date": "1632720167", "time_retrieved": "2024-07-30T18:59:09.697756", "image_code": "// Fork of \"single pass CFD\" by flockaroo. https://shadertoy.com/view/MdKXRy\n// 2018-04-18 11:55:03\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    //fragColor += texture(iChannel1, fragColor.rg).rrrr;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// Modified with audio reactivity by www.axiom-crux.net\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 8 //cos(iTime*4.0)\n#define angRnd -8.0 //*cos(iTime*8.0) //*pow(fract(iTime*2.0)*2.0,4.50)\n#define posRnd -0.0\n#define intensity 1.0 //sin(iTime*0.5)+0.50)*2.50\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float fft = texture(iChannel2,fract(uv)).x-0.5*5.;\n    float ang2 = angRnd*randS(uv).x*ang ;//  * fft;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        //v+= fft;\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    } //while(RotNum > 0.0);\n    rot/=float(RotNum);\n    return rot*fft;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n\n#define INIT iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / Res.xy;\n    vec2 scr = uv*2.0-vec2(1.0);\n    \n    float sc = 1.0/max(Res.x,Res.y);\n    \n    vec2 v   = vec2(0);\n    \n    vec2 uuvv = vec2(length(uv-0.5),length(uv-0.50));\n    vec2 puv = atan(uv-0.5,uuvv);//uuvv);//,uv+0.5);\n  \n    vec4 fft = texture(iChannel2,(puv))*0.53;\n    vec4 fft2= texture(iChannel2,uuvv*0.1)*0.51;\n    vec4 fft4= fft2+fft*2.0;\n    vec4 fft3= texture(iChannel2,uv*vec2(0.25,0.0))*4.-1.5;\n    float fft33 = step(fft3.r,0.5);\n    \n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n       // if ( fft4.r > 0.21) break;\n        \n        float ang2 = angRnd * ang * randS(uv).y * fft3.r;\n        \n        vec2 p = vec2(cos(ang2),sin(ang2));\n        \n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2 = p*sc;\n            float rot = getRot(uv+p2, sc-0.01);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v += p2.yx * rot * vec2(-1,1.1); //maybe faster than above\n            p = m*p;\n        }\n        \n      \tsc *= 2.0 ;\n        sc /= fft4.r*1.0925051;\n        sc *= 2.01;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor = texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    fragColor = mix(fragColor,texture(iChannel2, fragColor.xy).rrrr*2.0-0.5009,0.02);\n    \n    \n    if(uv.y < 0.03 || uv.y > 0.99){ fragColor.rgb += fft33*0.975; fragColor.gb *= fft33*0.75;\n    }\n    //if(uv.y > 0.29 && uv.y < 0.71){ \n    //fragColor.gb += fft33*0.15; fragColor.gb *= fft33*0.15;\n   // }\n   fragColor += fft2.rrrr*0.01;\n    \n    \n   // scr += fft.rr;\n   \n     // add a little \"motor\" in the center\n    fragColor.xy += (0.02*intensity*scr.xy / (dot(scr,scr)/0.15+0.3));\n\n   // fragColor.xy += 0.01*fft.rg-0.00015;\n    \n    if(iFrame<=4 || INIT<0.5) fragColor = uv.rgrg;//init(fragColor,fragCoord);\n    \n    //fragColor /= fft.rrrr*1.1;//uuvv.rgr;\n    //fragColor\n    //fragColor += 1.0-texture(iChannel2,uv/2.);//-uv.rgrg*-0.01;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3SRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[864, 864, 921, 921, 1059]], "test": "untested"}
{"id": "fs3SRN", "name": "01- Circle", "author": "ramiawar", "description": "Just a circle", "tags": ["tutorial"], "likes": 0, "viewed": 179, "published": 3, "date": "1632719479", "time_retrieved": "2024-07-30T18:59:10.661180", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x;\n\n    float d = length(uv);\n    float r = 0.2;\n\n    float c = smoothstep(r, r-0.005, d);\n\n    // if(d < 0.4) c = 1.;\n    // else c = 0.;\n\n    // Output to screen\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 404]], "test": "untested"}
{"id": "NscXR4", "name": "Gradient Tetrahedral Looped", "author": "spalmer", "description": "riffing on Thomas Hooper's idea, which tweaks iq's simplex gradient [url=http://iquilezles.org/articles/normalsSDF/normalsSDF.htm]here[/url]\nleft=central difference, right=one of my simplex looped", "tags": ["gradient", "simplex", "derivative", "tetrahedral", "hooper"], "likes": 4, "viewed": 314, "published": 3, "date": "1632702913", "time_retrieved": "2024-07-30T18:59:11.524873", "image_code": "// I made some more variants of iq/Hooper simplex gradient\n\n// iq's looped simplex gradient, loop idea by Thomas Hooper\n// http://iquilezles.org/articles/normalsSDF \"An Important Implementation Detail\"\n\nfloat dscene(vec3 q);\n\n#define IZERO min(0, iFrame)\n\n// floating point variant\nvec3 gscene6(vec3 q, float h)\n{\n\tvec3 n, e;\n\tfor (float i = min(0., iTime) + 4.; i-- > 0.; ) {\n\t\te = mod(floor(.5 * (i + vec3(3, 0, i))), 2.) * 2. - 1.; // have feeling could trim this teeny bit more w effort\n\t\tn += dscene(h * e + q) * e;\n\t}\n\treturn n;\n}\n\n// spalmer updated variant of Thomas Hooper's looped variant of iq's simplex gradient\nvec3 gscene5(vec3 q, float h)\n{\n\tvec3 n; // = vec3(0); // glsl inits locals to 0\n\tfor (int i = IZERO + 4; i-- > 0; ) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += dscene(h * e + q) * e;\n\t}\n\treturn n;\n}\n\n// WIP spalmer variant of Thomas Hooper's looped variant of iq's simplex gradient\n// works, not super efficient though with extra multiply by e.w etc.\nvec3 gscene4(vec3 q, float h)\n{\n\tvec3 n = vec3(0); vec4 e = vec4(1,1,1,-1);\n\tfor (int i = IZERO + 4; i-- > 0; e = e.yzwx)\n\t\tn -= dscene(q - h * e.w * e.xyz) * e.w * e.xyz;\n\treturn n;\n}\n\n// these were originally in March 3D http://shadertoy.com/view/tlGXDK\n\n// spalmer variant of Thomas Hooper's looped variant of iq's simplex gradient\nvec3 gscene3(vec3 q, float h)\n{\n\tvec3 n = vec3(0);\n\tfor (int i = IZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += dscene(q + e * h) * e;\n\t}\n\treturn n;\n}\n\n// a variation of iq/Hooper's simplex gradient made by Clément Baticle (a.k.a. Klems):\nvec3 gscene2(vec3 p, float h) // for function f(p)\n{\n\tvec3 n = vec3(0);\n\tfor (int i=IZERO; i<4; ++i)\n\t{\n\t\tvec3 e = (2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n\t\tn += e * dscene(p + e*h);\n\t}\n\treturn n;\n}\n\n// unlooped variation for comparison:\n\n// iq's simplex gradient, unlooped, so stresses compiler inlining scene:\n// I took from mandelbulb http://shadertoy.com/view/ltfSWn\nvec3 gscene1(vec3 q, float h)\n{\n\tvec2 e = h * vec2(1,-1);\n\treturn e.xyy * dscene(q + e.xyy) + \n\t       e.yyx * dscene(q + e.yyx) + \n\t       e.yxy * dscene(q + e.yxy) + \n\t       e.xxx * dscene(q + e.xxx);\n}\n\n// standard central difference gradient for comparison\nvec3 gscene0(vec3 q, float h)\n{\n    vec2 e = vec2(h * sqrt(3.), 0);  // sqrt(3.) to match lack of sqrt(1./3.) in others\n    return .5 * (vec3(\n       dscene(q + e.xyy),\n       dscene(q + e.yxy),\n       dscene(q + e.yyx)\n       ) - vec3(\n       dscene(q - e.xyy),\n       dscene(q - e.yxy),\n       dscene(q - e.yyx)\n       ));\n}\n// you can tell on left edge of sphere bottom that it\n// works differently than the simplex gradient does\n\n/* TODO see nimitz norcurv http://shadertoy.com/view/Xts3WM\n// 5 taps total, returns both normal (in xyz) and curvature (in w)\nvec4 norcurv(vec3 p)\n{\n    vec2 e = vec2(-1, 1)*.001;   \n    float t1 = dscene(p + e.yxx), t2 = dscene(p + e.xxy),\n          t3 = dscene(p + e.xyx), t4 = dscene(p + e.yyy);\n    return vec4(normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4), \n        .25/e.y*(t1 + t2 + t3 + t4 - 4. * dscene(p)));\n}\n*/\n\nfloat dscene(vec3 q)\n{\n    return min(min(length(q) - 2., 6. - length(q)), q.y + 1.)\n        // any ideas to exhibit the technique better? maybe some patterned surface?\n        + dot(sin(q*16.), vec3(1)) * .015\n        //+ noise(q*4.) * .05\n    ;\n}\n\n// fork of Nano March http://shadertoy.com/view/3s2fDW (still private because it's still not short enough to compete)\n// fork of Fabrice's helix http://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 p)\n{\n    O = vec4(1);\n    vec3 R = iResolution, r = R, q = 5./r.yyz;\n    // TODO maybe rotating the camera would allow witnessing artifacts on all sides\n    r = normalize(vec3(.5*r.xy - p, r.y)); // / r.y); // strangely backward\n    q -= 3. * r;\n    for (int i = 96 + IZERO; i-- > 0 && abs(O.a) > .01;\n         q -= r * (O.a = dscene(q)));\n    // really precision shouldn't be constant but should depend on the distance to camera etc.\n    // here just change w time so can see the effect it has.\n    // you can only really notice the gradient methodology when precis is large,\n    // otherwise it tends to just look \"correct\".\n    float precis =\n        //(1. - abs(sin(iTime))) * .1 + // * (1. + blur); // not too small, beware inaccuracies in far distance\n        1e-2; \n    // normalized gradient (normal) of scene at p\n    float split = sin(.3*iTime) * .5 + .5 - p.x / R.x; //r.x - .5*sin(.3*iTime); // splitscreen\n    vec3 g = split < 0. // compare\n        ? gscene5(q, precis) // right\n        : gscene0(q, precis) // left\n    , n = normalize(g);\n//    O.rgb *= dot(n, vec3(sqrt(1./3.))); // lit\n    O.rgb *= n * .5 + .5;\n    O.rgb *= 1. - exp2(-4.* R.y * abs(split));\n//    n *= 1.001; //.999; // TEST\n    O.gb *= exp2(-5e3 * abs(1. - length(n))); // detect unnormalized normals\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 282, 313, 313, 536], [538, 624, 655, 655, 833], [835, 986, 1017, 1017, 1170], [1243, 1321, 1352, 1352, 1497], [1499, 1587, 1639, 1639, 1792], [1833, 1965, 1996, 1996, 2170], [2172, 2227, 2258, 2258, 2553], [3093, 3093, 3115, 3115, 3341], [3522, 3522, 3558, 3558, 4841]], "test": "untested"}
{"id": "7dtGzB", "name": "Pixel Perfect Pulse Ring", "author": "patrickdoc", "description": "A basic circle SDF, with a scalable pixel effect", "tags": ["sdf", "pixel"], "likes": 5, "viewed": 339, "published": 3, "date": "1632698661", "time_retrieved": "2024-07-30T18:59:12.293815", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Target resolution\n    vec2 desiredResolution = vec2(64.0,32.0);\n    // Radius of circle in pixels of target resolution\n    float radius = 12.0;\n    \n    // Shift (0,0) to the center of the screen)\n    vec2 pixel = fragCoord - (iResolution.xy / vec2(2,2));\n    // Downscale image\n    pixel = trunc(pixel / (iResolution.xy / desiredResolution));\n    \n    // Circle SDF, radius in pixels of target resolution\n    float dist = length(pixel) - radius;\n    if (abs(dist) < 0.49) {\n        // Red outer ring\n        fragColor = vec4(1,0,0,1);\n    }\n    \n    if (abs((radius - 1.0) * (sin(iTime) + 1.0) / 2.0 + dist + 1.0) < 0.49) {\n        // Green inner ring\n        fragColor = vec4(0,1,0,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 82, 760]], "test": "untested"}
{"id": "fdcSR4", "name": "hello_triangle", "author": "rytis_p", "description": "Playing around; sines, Voronoi, triangle, kinda spheres. Also, kinda slow (:", "tags": ["2d", "voronoi"], "likes": 8, "viewed": 291, "published": 3, "date": "1632693035", "time_retrieved": "2024-07-30T18:59:13.058770", "image_code": "#define PI 3.14159265359\n\nfloat pretty_sine(vec2 uv)\n{\n    float d = (sin(uv.x) - uv.y);\n    float d1 = 4.0 * d;\n    float d2 = 16.0 * d;\n    float sine = 0.5 * sin(uv.x + iTime);\n    float s = mix(d1, d2, sine + 0.5);\n    float result = 1.0 + 0.75 * (-sine + 0.5) - abs(s);\n    return result;\n}\n\nfloat circle(vec2 p, float r) \n{\n    float result = length(p) - r;\n    return result;\n}\n\n// NOTE(rytis): Taken from https://iquilezles.org/articles/smin\nvec2 smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nvec2 random2(vec2 p)\n{\n    vec2 result = fract(sin(vec2(dot(p, vec2(389.9, 441.1)),\n                                 dot(p, vec2(598.3, 290.4)))) * PI * 20000.0);\n    return result;\n}\n\nstruct Pretty_Sine_Data\n{\n    vec2 uv;\n    vec3 color;\n    float multiplier;\n};\nvec4 edge(vec2 uv, vec2 p0, vec2 p1)\n{\n    vec2 diff = p1 - p0;\n    vec2 n_diff = normalize(diff);\n    float half_diff_length = 0.5 * length(diff);\n    vec2 uv_x = vec2(1.0, 0.0);\n    vec2 uv_y = vec2(0.0, 1.0);\n    \n    float cos_a = dot(uv_x, n_diff);\n    float sin_a = dot(uv_y, n_diff);\n    vec2 p = vec2(cos_a * uv.x + sin_a * uv.y,\n                  -sin_a * uv.x + cos_a * uv.y);\n\n    vec2 offset = 0.5 * (p0 + p1);\n    vec2 xn = cos_a * uv_x + sin_a * uv_y;\n    vec2 yn = -sin_a * uv_x + cos_a * uv_y;\n    \n    vec2 new_offset = vec2(dot(offset, xn), dot(offset, yn));\n    \n    p -= new_offset;\n    \n    Pretty_Sine_Data data[8] = Pretty_Sine_Data[8](\n        Pretty_Sine_Data(      vec2(p.x + 0.22 * iTime, 2.0 * p.y),       vec3(0.5, 0.5, 2.0),  1.0),\n        Pretty_Sine_Data(      vec2(p.x + 0.13 * iTime, 1.6 * p.y),       vec3(0.3, 0.7, 1.0),  1.0),\n        Pretty_Sine_Data(2.0 * vec2(p.x + iTime, 2.0 * p.y),              vec3(0.8, 0.2, 0.6),  1.0),\n        Pretty_Sine_Data(1.3 * vec2(p.x + 0.5 * iTime, 1.7 * p.y),        vec3(0.4, 0.3, 0.7),  1.0),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime, 2.5 * p.y),              vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.5, 2.5 * p.y), 0.8  * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.9, 2.5 * p.y), 0.64 * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(3.5 * vec2(p.x - 1.24 * iTime, p.y),             vec3(1.7, 0.7, 0.0),  1.0)\n    );\n    \n    float output_dist = 0.0;\n    vec3 output_color = vec3(0.0);\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        float d = pretty_sine(data[i].uv);\n        float limit = (p.x < -half_diff_length || p.x > half_diff_length) ? 0.0 : 1.0;\n        float cd = limit * data[i].multiplier * clamp(d, 0.0, 1.0);\n        output_color += cd * data[i].color;\n        output_dist += cd;\n    }\n    return vec4(output_color, -0.125 * output_dist);\n}\n\n// NOTE(rytis): Taken from https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/\nfloat edge_f(vec2 p, vec2 e0, vec2 e1)\n{\n    float result = (e0.y - e1.y) * p.x + (e1.x - e0.x) * p.y + e0.x * e1.y - e0.y * e1.x;\n    return result;\n}\n\nstruct Point\n{\n    vec3 color;\n    float d;\n    vec2 p;\n};\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n    uv.x -= 0.5 * (aspect_ratio - 1.0);\n    uv = uv * 2.0 - 1.0;\n    \n    uv *= 8.0;\n\n    vec2 p0 = vec2(-3.0 + sin(iTime), -5.0 + cos(iTime));\n    vec2 p1 = vec2(7.0 + cos(0.5 * iTime), 0.0 - sin(iTime));\n    vec2 p2 = vec2(-2.0 + cos(0.5 * iTime), 5.0 - sin(0.44 * iTime));\n\n    Point points[3] = Point[3](\n        Point(vec3(0.5), circle(uv - p0, 1.2), p0),\n        Point(vec3(0.5), circle(uv - p1, 1.2), p1),\n        Point(vec3(0.5), circle(uv - p2, 1.2), p2)\n    );\n    \n    vec3 color = vec3(0.0);\n    float area_tri = 0.5 * edge_f(p0, p1, p2);\n    float inv_area_tri = 1.0 / area_tri;\n    float area_p01 = edge_f(uv, p0, p1);\n    float area_p12 = edge_f(uv, p1, p2);\n    float area_p20 = edge_f(uv, p2, p0);\n\n    float multiplier = smoothstep(-0.25, 0.5, -inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    float waves = 0.0;\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 8.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(vec2(uv.x, -uv.y) / 4.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 2.0));\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float min_dist = 1.0;\n    for(int i = -1; i <= 1; ++i)\n    {\n        for(int j = -1; j <= 1; ++j)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 random_point = random2(i_uv + neighbor);\n            random_point = 0.5 + 0.5 * vec2(sin(2.0 * PI * random_point + 0.5 * iTime));\n            vec2 diff = neighbor + random_point - f_uv;\n            float dist = length(diff);\n            min_dist = min(dist, min_dist);\n        }\n    }\n    vec2 waves_smooth = smin(min_dist, waves, 0.1);\n    color += multiplier * 3.0 * smoothstep(0.5, -0.5, -waves_smooth.y) * vec3(0.20, 0.23, 0.3);\n    color += multiplier * min_dist * vec3(0.20, 0.23, 0.3);\n    \n    \n    if(area_p01 >= 0.0 && area_p12 >= 0.0 && area_p20 >= 0.0)\n    {\n        color = mix(color, vec3(0.5), 3.0 * inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    }\n    \n    vec4 e0 = edge(uv, p0, p1);\n    vec4 e1 = edge(uv, p1, p2);\n    vec4 e2 = edge(uv, p2, p0);\n    color += e0.xyz;\n    color += e1.xyz;\n    color += e2.xyz;\n    float edge_dist = min(min(e0.w, e1.w), e2.w);\n    for(int i = 0; i < 3; ++i)\n    {\n        if(points[i].d < edge_dist)\n        {\n            vec2 smooth_dist = smin(points[i].d, edge_dist, 0.3);\n            vec2 p_on_sphere = uv - points[i].p;\n            vec3 sphere_normal = normalize(vec3(p_on_sphere.x, p_on_sphere.y, smooth_dist.x));\n            vec3 light_dir = normalize(-vec3(uv.x, uv.y, 4.0));\n            float atten = max(dot(sphere_normal, light_dir), 0.0);\n            color = mix(points[i].color * (0.5 + 0.5 * atten * atten), color, smooth_dist.y);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 295], [297, 297, 329, 329, 384], [386, 450, 490, 490, 634], [636, 636, 658, 658, 819], [901, 901, 939, 939, 2823], [2825, 2920, 2960, 2960, 3071], [3132, 3132, 3187, 3187, 6084]], "test": "untested"}
{"id": "7stXzH", "name": "small house", "author": "jorge2017a2", "description": "small house", "tags": ["smallhouse"], "likes": 3, "viewed": 247, "published": 3, "date": "1632686252", "time_retrieved": "2024-07-30T18:59:13.851650", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nvec3 techotri(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);  \n    float sdt1= sdTriangleIsosceles( vec2(p.x,-p.y), vec2(6.,4.0) );\n    float sdt2= sdTriangleIsosceles( vec2(p.x,-p.y), vec2(5.,4.5) );\n    float sdr1= sdRoundBox( p, vec3(7.0,5.0,7.0), 1.0);\n    float sdr2= sdRoundBox( p-vec3(0.0,-1.0,0.0), vec3(6.0,5.0,6.0), 1.0);\n    //4 postes    \n    p.x=abs(p.x)-4.5;\n    p.z=abs(p.z)-4.5;\n    float sdp1= sdRoundBox( p-vec3(0.0,-5.0,0.0), vec3(0.15,1.0,0.15), 0.5);\n    float sinter1= intersectSDF(sdt1, sdr1);\n    float sinter2= intersectSDF(sdt2, sdr2);\n    sinter1=differenceSDF(sinter1, sinter2);\n    res =opU3(res, vec3(sinter1,3.0,-1.0));\n    res =opU3(res, vec3(sdp1,4.0,-1.0));\n    \n    return res;\n}\n\nvec3 techotdo(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    vec3  t1=techotri(p-vec3(0.0,22.,0.0));\n    float sdr1= sdRoundBox(p-vec3(0.0,5.0,0.0), vec3(5.0,10.0,5.0), 1.0 );\n     res =opU3(res, vec3(sdr1,2.0,-1.0));\n     res =opU3(res, t1);\n    return res;\n}\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.xz= opRep2D(p.xz, vec2(30.0,40.0) );\n    \n    vec3 t1=techotdo(p);\n    res =opU3(res, t1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n        \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(-10.0,3.0,-25.0+t);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd=rotate_y(rd, radians(45.0));\n   rd=rotate_x(rd, radians(-45.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n   \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 460, 492, 492, 576], [577, 577, 623, 623, 710], [711, 755, 802, 802, 829], [830, 830, 873, 873, 900], [901, 901, 949, 949, 977], [978, 1016, 1055, 1055, 1099], [1100, 1165, 1199, 1199, 1295], [1296, 1296, 1330, 1330, 1421], [1422, 1422, 1456, 1456, 1547], [1548, 1548, 1582, 1582, 1677], [1680, 1680, 1731, 1731, 2039], [2040, 2040, 2063, 2063, 2756], [2758, 2758, 2781, 2781, 3036], [3037, 3037, 3062, 3062, 3312], [3314, 3314, 3338, 3338, 3500], [3502, 3502, 3551, 3551, 4182], [4185, 4185, 4221, 4221, 4466], [4468, 4468, 4495, 4495, 4512], [4514, 4514, 4550, 4550, 4642], [4643, 4643, 4689, 4689, 4814], [4816, 4816, 4853, 4853, 5129], [5132, 5132, 5199, 5199, 5476], [5479, 5479, 5562, 5562, 6499], [6501, 6501, 6594, 6594, 6724], [6726, 6726, 6758, 6758, 6955], [6957, 7005, 7033, 7033, 7221], [7223, 7223, 7270, 7270, 7496], [7498, 7498, 7591, 7591, 7932], [7934, 7934, 7965, 7965, 8564], [8566, 8566, 8592, 8592, 8702], [8704, 8704, 8762, 8762, 8814], [8816, 8816, 8873, 8873, 9494]], "test": "untested"}
{"id": "7sdXRH", "name": "Glacial valleys v2", "author": "jarble", "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 6, "viewed": 321, "published": 3, "date": "1632677701", "time_retrieved": "2024-07-30T18:59:14.732295", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.5;\n    float n1 = 0.;\n    vec2 uv2 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = noise(uv*freq) -n1*value*amplitude;\n        //n1 = noise(uv*freq+n1/2.);\n        //n1 = noise(uv * freq)-n1;\n        //float n1 = noise(uv * freq+noise(uv1));\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value -= abs(n1-1.) * amplitude;\n        \n        //erosion\n        value = sqrt(value*value+.001);\n\n        \n        amplitude *= 1./5.+1./(5.-value);\n        \n        freq *= 2.05;\n        //uv1 = uv*freq;\n\n        uv = uv.yx-(n1*(amplitude)-n1/freq);\n        //uv = uv.yx-vec2(n1*(amplitude)-n1/freq,n1/freq);\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+2);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,4)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 79], [100, 100, 135, 184, 950], [952, 952, 974, 974, 1004], [1006, 1006, 1036, 1036, 1086], [1088, 1088, 1108, 1108, 1162], [1164, 1164, 1197, 1197, 1391], [1393, 1393, 1460, 1460, 1678], [1680, 1680, 1732, 1732, 2277], [2279, 2279, 2330, 2330, 2531], [2533, 2533, 2559, 2559, 2635], [2704, 2704, 2761, 2761, 4721]], "test": "untested"}
{"id": "7stSz8", "name": "bubbles ( loopless )", "author": "FabriceNeyret2", "description": "procedural bubbles rising at irregular speed. Loopless ( appart 3 iterations for solving the inverse ).\nvelocity = x + cos(x+t)  ( = stop and go )\nYpos = integral(v).  procedural draw → inverse it.", "tags": ["short", "loopless"], "likes": 26, "viewed": 536, "published": 3, "date": "1632662027", "time_retrieved": "2024-07-30T18:59:15.510215", "image_code": "//#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hash(p)  fract(sin( (p)* vec2(12.9898, 78.233)) * 43758.5453)\n  \nfloat A = .6, t, d=0.;\n#define f(x)   ( d+x + A*cos(x+t) ) // function to inverse\n#define df(x)  ( 1.- A*sin(x+t) )   // first derivative\n#define ddf(x)    ( -A*cos(x+t) )   // second derivative\n\nfloat invF(float x) {    // --- iterative solving the inverse function https://www.shadertoy.com/view/sd3XRH\n    float y0 = x-d, D;\n    for (int i = 0; i < 3; i++ )\n#if 1                                  // using order1 Taylor series : slow conv if A > .6 \n        y0 += ( x-f(y0) ) / df(y0);    // Note that here, even 1 step of TS1 is enough\n#else                                  // using order2 Taylor series : fast convergence\n        D  = df(y0)*df(y0) -2.*ddf(y0)*(f(y0)-x),\n        y0 += ( -df(y0) + sqrt(D) ) / ddf(y0);\n#endif\n    return y0;\n}\n\n#define Sa(v) smoothstep( 1.5*min(fwidth(v),10./R.y), 0., abs(v) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y;\n // U /= 5. - U.y;   // perspective  ( comment for sky view )\n    t = iTime;\n    float i = floor(U.x);              // column id\n    vec2 H = hash(i);                  // attributes\n    t *= .5 + H.y;                     // random speed\n    U.y += 3.*H.x - t;                 // random offset + rise\n    \n // for (float k=-1.; k<1.; k++){      // if you want to avoid trimmed bubbles\n    float y0 = invF( U.y ),// +k ,     // get bubble y location\n           j = floor(y0),\n          v0 = df(j), x;\n    vec2  H0 =  hash(j+H.x);           // bubble attributes\n           x = U.x + .1*sin(10.*j-10.*t); // horizontal offset\n          y0 = U.y - f(j),\n       \n    O = Sa( length(vec2(fract(x)-.5,y0-.5*v0))-.2*H0.y ) * vec4(.5,1,1,0);\n // O +=                                               //  hue(H.x);\n}//}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[958, 958, 996, 996, 1864]], "test": "untested"}
{"id": "fsdSRH", "name": "Northern Elves", "author": "TEttinger", "description": "It's a significant variation on my \"Onward to Thule\" shader, with more emphasis on strangely-shifting extremely-bright colors.", "tags": ["noise", "plasma", "lights", "northern", "elves"], "likes": 4, "viewed": 410, "published": 3, "date": "1632638397", "time_retrieved": "2024-07-30T18:59:16.273176", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con)) * 0.5;\n//    + swayRandomized(c + 1.1, con.xyz)\n//    + swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = (fragCoord + cos(iTime * 0.3) * 64.0) * (2.125 + sin(iTime * 0.25));\n    vec2 uv = (fragCoord * 0.25) + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx - fragCoord.yxy * 0.01).xy * 42.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj.yzx)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * 4.0) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 548], [550, 764, 795, 795, 941], [943, 943, 1000, 1085, 1743]], "test": "untested"}
{"id": "fstXz8", "name": "reverse wagon", "author": "jorge2017a2", "description": "reverse wagon", "tags": ["reversewagon"], "likes": 5, "viewed": 240, "published": 3, "date": "1632623975", "time_retrieved": "2024-07-30T18:59:17.044114", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nint escena;\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 paredCil(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);\n    p.z= opRep1D( p.z, 80.0 );\n    p.y= opRep1D( p.y, 0.7 );\n    float sdcy1=sdCylinderYZ(p, vec2(0.25,12.0) );\n    float sdb1= sdBox( p, vec3(13.0,13.0,2.0) );\n    \n    float sinte= intersectSDF(sdcy1,sdb1);\n    res =opU3(res, vec3(sinte,1.0,-1.0));\n    return res;\n}\n\nvec3 vagon(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n    p.z=opRep1D(p.z, 34.0 );\n    \n    float sdb1= sdRoundBox(p, vec3(15.0,10.0,15.0), 1.5 );\n    float sdb2= sdRoundBox(p, vec3(14.0,9.0,16.0), 1.5 );\n    //ventanas\n    float sdb3= sdRoundBox(p-vec3(0.0,1.0,8.0), vec3(17.0,2.0,2.0), 0.5 );\n    float sdb4= sdRoundBox(p-vec3(0.0,1.0,0.0), vec3(17.0,2.0,2.0), 0.5 );\n    float sdb5= sdRoundBox(p-vec3(0.0,1.0,-8.0), vec3(17.0,2.0,2.0),0.5 );\n    \n    float px=abs(p.x)-5.0;\n    float sdbl1= sdRoundBox(p-vec3(p.x-px,8.0,0.0), vec3(0.08,0.08,15.0),0.15 );\n    px=abs(p.x)-15.0;\n    float sdbl2= sdRoundBox(p-vec3(p.x-px,-2.0,0.0), vec3(0.05,0.05,15.0),0.15 );\n    float sdbl3= sdRoundBox(p-vec3(p.x-px,-3.0,0.0), vec3(0.05,0.05,15.0),0.15 );\n    float sdbl4= sdRoundBox(p-vec3(p.x-px,-5.0,0.0), vec3(5.0,0.25,15.0),0.15 );   \n    //base suelo\n    float sdb6= sdRoundBox(p-vec3(0.0,-10.5,0.0), vec3(11.0,0.5,12.0),0.5 );\n    float dif1= differenceSDF(sdb1, sdb2);\n    dif1= differenceSDF(dif1, sdb3);\n    dif1= differenceSDF(dif1, sdb4);\n    dif1= differenceSDF(dif1, sdb5);\n   \n    res =opU3(res, vec3(dif1,2.0,-1.0));\n    res =opU3(res, vec3(sdbl1,1.0,-1.0));\n    res =opU3(res, vec3(sdbl2,3.0,-1.0));\n    res =opU3(res, vec3(sdbl3,4.0,-1.0));\n    res =opU3(res, vec3(sdbl4,5.0,-1.0));\n    res =opU3(res, vec3(sdb6,13.0,-1.0));\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n\n    p.y=p.y-12.0;\n    vec3 v1= vagon(p);\n    res =opU3(res, v1);\n    vec3 p1= paredCil(p-vec3(0.0,0.0,0.0));\n    res =opU3(res, p1);\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{     vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n                \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*7.0,100.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, 10.0 ); light_color2 =vec3( 1.0 ); \n    \n   \n   vec3 ro;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    float t1=mod(iTime,11.0);\n    float t2=mod(iTime,22.0);\n    if(t1<t2)\n    {  \n        escena=1;\n        ro=vec3(0.0,10.0,0.0-t);\n    }\n    else\n    {\n        escena=0;\n        ro=vec3(0.0,10.0,0.0+t);\n        \n    }\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 504, 504, 588], [589, 589, 635, 635, 722], [723, 723, 762, 762, 857], [858, 902, 949, 949, 976], [977, 977, 1020, 1020, 1047], [1048, 1048, 1096, 1096, 1124], [1125, 1163, 1199, 1199, 1244], [1245, 1245, 1284, 1284, 1328], [1329, 1329, 1368, 1368, 1412], [1413, 1413, 1445, 1445, 1470], [1471, 1511, 1545, 1545, 1640], [1642, 1642, 1665, 1665, 1971], [1973, 1973, 1993, 1993, 3325], [3327, 3327, 3352, 3352, 3648], [3650, 3650, 3674, 3674, 3836], [3838, 3838, 3887, 3887, 4518], [4520, 4520, 4556, 4556, 4801], [4803, 4803, 4830, 4830, 4847], [4849, 4849, 4885, 4885, 4977], [4978, 4978, 5024, 5024, 5149], [5151, 5151, 5188, 5188, 5462], [5465, 5465, 5532, 5532, 5809], [5811, 5811, 5894, 5894, 6822], [6824, 6824, 6917, 6917, 7047], [7049, 7049, 7081, 7081, 7278], [7281, 7281, 7374, 7374, 7530], [7532, 7532, 7563, 7563, 8162], [8164, 8164, 8190, 8190, 8300], [8302, 8302, 8360, 8360, 8412], [8414, 8414, 8471, 8471, 9203]], "test": "untested"}
{"id": "NdtXR8", "name": "Rainbow screensaver animation", "author": "takumif", "description": " ", "tags": ["colorful", "animation", "background", "rainbow", "screensaver"], "likes": 4, "viewed": 343, "published": 3, "date": "1632615438", "time_retrieved": "2024-07-30T18:59:17.907805", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = iTime*0.2;\n    \n    // Calculate two points on screen.\n    \n    vec2 c1 = vec2(sin(time)*0.5, cos(iTime)*0.7);\n    vec2 c2 = vec2(sin(time*0.7)*0.9, cos(iTime*0.65)*0.6);\n    \n    //Determine length to point 1 & calculate color.\n    float d1 = length( uv - c1);\n    vec3 col1 = palette( d1+time,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\t\n    //Determine length to point 2 & calculate color.\n    float d2 = length( uv - c2);\n    vec3 col2 = palette( d2+time,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\n    \n    // Output to screen\n    fragColor = vec4( (col1+col2) / 2.0 ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 111, 111, 154], [156, 156, 213, 263, 968]], "test": "untested"}
{"id": "sd3XRH", "name": "fast computation of inverse func", "author": "FabriceNeyret2", "description": "red: plot the inverse function  ( custom #def f() )\ngreen: plot trochoid\nblue: displace points.x as f()  .  right: without dot distortion", "tags": ["iteration", "inverse", "trochoid", "solving"], "likes": 10, "viewed": 403, "published": 3, "date": "1632597029", "time_retrieved": "2024-07-30T18:59:18.671762", "image_code": "float A = .9, t, d=0.;\n#define f(x)   ( d+ x + A*cos(x-t) )   // function to inverse\n#define df(x)  (    1.- A*sin(x-t) )   // first derivative\n#define ddf(x)       ( -A*cos(x-t) )   // second derivative\n//#define df(x)   ( dFdx(f (x))/dFdx(x) )  // second derivative\n//#define ddf(x)  ( dFdx(df(x))/dFdx(x) )  // second derivative (attention: can't use both hardware derivatives)\n\nfloat invF(float x) {    // --- iterative solving the inverse function\n    float y0 = x-d, D;\n    for (int i = 0; i < 3; i++ )\n#if 0                                  // using order1 Taylor series : slow conv if A > .6 \n        y0 += ( x-f(y0) ) / df(y0);\n#else                                  // using order2 Taylor series : fast convergence\n        D  = df(y0)*df(y0) -2.*ddf(y0)*(f(y0)-x),\n        y0 += ( -df(y0) + sqrt(D) ) / ddf(y0);\n#endif\n    return y0;\n}\n\n#define S(v)  smoothstep( 1.5*min(fwidth(v),.1), 0., v )\n#define Sa(v) smoothstep( 1.5*fwidth(v), 0., abs(v) )\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------\n{\n    vec2 R = iResolution.xy,\n         U = 10.*( 2.*u - R ) / R.y, U0=U;\n    O-=O;\n    O.r = Sa( U.y - invF(U.x) );         // red: plot the inverse function\n    \n    t = iTime;\n    U.x = invF(U.x);\n    O.g = Sa( U.y - A*sin(U.x-t) );      // green: plot trochoid\n    \n    if (U0.x<0.) O.b = S( length( fract(U)-.5) -.1 ); // blue: displace points.x as f()\n    else {                                    // right: without dot distortion\n        float v = df(floor(U.x));\n        U.x = U0.x - f(floor(U.x)),\n        O.b = S( length( vec2(U.x-.5*v, fract(U.y)-.5) ) -.1 );\n        O.g += .5*O.b;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 959, 1035, 1035, 1635]], "test": "untested"}
{"id": "7d3Xz8", "name": "Roni's Homage to Bridget Riley", "author": "jhancock532", "description": "Credit for original artwork design goes to Roni Kaufman\nhttps://twitter.com/KaufmanRoni/status/1440285424425918467\nI attempted to replicate his work using a shader.\nI also made a CodePen, if you want to fork it: https://codepen.io/jhancock532/pen/GREXeWE", "tags": ["abstract", "generative", "pattern"], "likes": 8, "viewed": 301, "published": 3, "date": "1632591512", "time_retrieved": "2024-07-30T18:59:19.489576", "image_code": "//Credit for original artwork design goes to Roni Kaufman\n//https://twitter.com/KaufmanRoni/status/1440285424425918467\n//I attempted to replicate his work using a shader.\n//The below color scheme was copied from his colour palette library\n\nvec3 colorScheme(float x) {\n    \n    if (x < 0.071428) return vec3(242.,235.,138.) / 255.;\n    if (x < 0.142857) return vec3(254.,208.,0.) / 255.;\n    if (x < 0.214285) return vec3(252.,132.,5.) / 255.;\n    if (x < 0.285713) return vec3(237.,54.,26.) / 255.;\n    if (x < 0.357141) return vec3(226.,240.,243.) / 255.;\n    if (x < 0.428569) return vec3(179.,220.,224.) / 255.;\n    if (x < 0.500000) return vec3(68.,100.,161.) / 255.;\n    if (x < 0.571428) return vec3(32.,48.,81.) / 255.;\n    if (x < 0.6428) return vec3(255.,197.,199.) / 255.;\n    if (x < 0.7142) return vec3(243.,152.,195.) / 255.;\n    if (x < 0.7857) return vec3(207.,56.,149.) / 255.;\n    if (x < 0.8571) return vec3(109.,53.,138.) / 255.;\n    if (x < 0.9285) return vec3(6.,180.,176.) / 255.;\n    if (x < 1.0001) return vec3(75.,138.,95.) / 255.;\n\n    return vec3(0.);\n}\n\n//The book of shaders noise function\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Split into cubes at least 45 pixels wide\n    uv *= floor(iResolution.xy / 45.);\n\n    //Scale cube height before and after transformation\n    //to get the right sine curve effect\n    uv.y *= 1.5;\n    \n    //Subtract x and add a sin function to the cube, \n    //skewing it in the y axis with a wave\n    uv.y += (sin(uv.x * 3.1415) * 0.2) - uv.x;\n    \n    //Subdivide y-axis into integers for the large curved pieces\n    vec2 largeDivs = floor(uv);\n    \n    uv.y *= 3.0;\n    \n    //Subdivide y-axis into more integers for the smaller curved pieces\n    vec2 smallDivs = floor(uv);\n    \n    //Paint the base layer of large pieces\n    vec3 color = colorScheme(random(largeDivs));\n    \n    //For 15% of the smaller pieces, overwrite the base layer colour\n    float smallRandom = random(smallDivs);\n    if (smallRandom < 0.15) {\n      color = colorScheme(smallRandom * 6.66666666);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3Xz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 267, 267, 1080], [1082, 1119, 1143, 1143, 1216], [1218, 1218, 1275, 1325, 2300]], "test": "untested"}
{"id": "7ddSzn", "name": "Polar Subdivision", "author": "SnoopethDuckDuck", "description": "Fork of tater's shader: https://www.shadertoy.com/view/7sV3WD\n\nNot sure how to get rid of the -pi/pi line but apart from that, it looks okay", "tags": ["2d", "circles", "polar", "subdivide"], "likes": 8, "viewed": 280, "published": 3, "date": "1632590508", "time_retrieved": "2024-07-30T18:59:20.262509", "image_code": "#define pi 3.1415926535\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h11 (float a) {\n    return fract(sin(a * 12.9898) * 43758.5453123);\n}\n\n//iq palette\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n/*\nfloat getAngleLength(float a, float b) {\n    return min(1. - abs(a-b), abs(a-b));\n}\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.y += 0.04 * cos(iTime);\n    \n    // polar uv\n    vec2 puv = vec2(atan(uv.y, uv.x), length(uv));\n    vec3 col = vec3(0);\n    float t = mod(iTime * 1., 6000.);\n    float px = 1. / iResolution.y;\n    \n    vec2 aRange = vec2(-pi, pi);\n    vec2 lRange = vec2(0., 0.5);\n    \n    float aLength = 2. * pi;\n    float lLength = 0.5;\n        \n    float id = 0.;\n    vec2 diff;\n    float seed = floor(t / 6.);\n    float a;\n        \n    //PLAY WITH THESE VARIABLES :D\n    float minAngle = pi / 32.;\n    float minLength = 0.015;\n    \n    float iters = 5.;\n    float borderSize = 0.0;\n    float minIters = 1.;\n\n    // replace this with polar equations to get cool shape\n    float lengthDistort = 1.1 * puv.y;\n    //float angleDistort = puv.x;\n\n    for(float i = 0.; i < iters; i++) {   \n        float rand  = h21(vec2(i + id, seed));\n        float rand2 = h21(vec2(i - id, seed));\n        float rand3 = h21(vec2(i + 0.5 * id, seed));\n        \n        float aSplit  = rand  * aLength + aRange.x; // split angle below length split\n        float aSplit2 = rand2 * aLength + aRange.x; // split angle above length split\n        float lSplit  = rand3 * lLength + lRange.x; // split length\n        \n        aSplit  = clamp(aSplit,  aRange.x + minAngle,  aRange.y - minAngle);\n        aSplit2 = clamp(aSplit2, aRange.x + minAngle,  aRange.y - minAngle);\n        lSplit  = clamp(lSplit,  lRange.x + minLength, lRange.y - minLength);\n        \n        //if(h21(vec2(aSplit, lSplit)) > 0.9 && i+1. > minIters) break;\n\n        // diff is used to give unique id to each sector\n        diff = vec2(0);\n        \n        if(lengthDistort < lSplit){\n            if(puv.x + .5 * (1. + cos(aSplit2 + iTime)) < aSplit){\n                aRange = vec2(aRange.x, aSplit);\n                diff.x = aSplit;\n            }\n            else{\n                aRange = vec2(aSplit, aRange.y);\n                diff.x = -lSplit;\n            }\n            lRange = vec2(lRange.x, lSplit);\n            diff.y = -aSplit;\n        }\n        else{\n            if(puv.x + .5 * (1. + cos(aSplit + iTime)) < aSplit2){\n                aRange = vec2(aRange.x, aSplit2);\n                diff.x = aSplit;\n            }\n            else{\n                aRange = vec2(aSplit2, aRange.y);\n                diff.x = -lSplit;\n            }\n            lRange = vec2(lSplit, lRange.y);\n            diff.y = lSplit;\n        }\n\n        // + 10. ensures topleft, bottomright have different Ids\n        id = length(diff * 100. + 10.);  \n        \n        aLength = aRange.y - aRange.x;\n        lLength = lRange.y - lRange.x;\n    }\n    \n    float fade = 1.- abs(pow(cos(t * 2. * pi / 6.),10.));\n\n    a += step(puv.x, aRange.y) * step(lengthDistort, lRange.y) \n    * (1.-smoothstep(-10. * px, 100. * px,.5 * lRange.x + .5 * lRange.y-0.5 * fade));\n       \n    col = vec3(a);\n    vec3 e = vec3(0.5);\n    vec3 al = pal(id * 0.5, e * 1.1, e * 1.1, vec3(1,.7,.4), vec3(0,.15,.2));\n    // vec3 al = pal(id * 0.1, e * 1.2, e, e * 2.0, vec3(0, 0.33, 0.66));\n    col = a * al;\n    \n    fragColor = vec4(col, 1.);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 120], [122, 122, 143, 143, 197], [199, 212, 278, 278, 327], [328, 418, 473, 473, 3583]], "test": "untested"}
{"id": "NscXzH", "name": "Gabor Filter Kernel", "author": "mosan_hoshi", "description": "Gabor Filter Kernel ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n(*) Gaussian is not Normalized.", "tags": ["2d", "imageprocessing", "spatialfilter"], "likes": 7, "viewed": 320, "published": 3, "date": "1632577914", "time_retrieved": "2024-07-30T18:59:21.035443", "image_code": "// writen by mossan-hoshi\n//// twitter : https://twitter.com/mossan_hoshi\n//// GitHub : https://github.com/mossan-hoshi/\n//// ShaderToy : https://www.shadertoy.com/user/mosan_hoshi\n//\n// Gabor Filter ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n//\n\n\n#define PI 3.14159265359\n#define MARGIN 0.01\n#define PADDING 0.1\n#define TILE_LOCAL_LENGTH 10.\n#define TILE_LENGTH ((1. - 2. * ( MARGIN + PADDING)) / 3.)\n#define LEFT_CENTER   vec2(MARGIN + .5 * TILE_LENGTH                               , MARGIN + .5 * TILE_LENGTH)\n#define CENTER_CENTER vec2(MARGIN + .5 * TILE_LENGTH +       PADDING + TILE_LENGTH , MARGIN + .5 * TILE_LENGTH)\n#define RIGHT_CENTER  vec2(MARGIN + .5 * TILE_LENGTH + 2. * (PADDING + TILE_LENGTH), MARGIN + .5 * TILE_LENGTH)\n#define TEXT_WIDTH   (0.068)\n#define TEXT_START_Y (2. * MARGIN + TILE_LENGTH)\n#define TEXT_START_X (.3)\n// gaussian\n#define SIGMA_MIN .75\n#define SIGMA_MAX 3.\n#define GAUSSIAN_CONST_GAIN 0.3989422804  // 1./sqrt(2*PI)\n#define GAUSSIAN_TRANSITION_PERIOD 3.8\n// carrier\n#define CARRIER_WAVELENGTH_MIN .2\n#define CARRIER_WAVELENGTH_MAX .8\n#define CARRIER_WAVELENGTH_PERIOD 3.8\n#define CARRIER_ROTATION_PERIOD 20.\n\n\nvec3 displayGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n  vec3 val1 = 12.92 * rgb;\n  vec3 val2 = vec3(pow(rgb.x, 1.0 / 2.2),pow(rgb.y, 1.0 / 2.2),pow(rgb.z, 1.0 / 2.2)) * 1.055 - 0.055;\n  return (1.0 - step(0.0031308,rgb)) * val1 + step(0.0031308,rgb) * val2;\n}\n\nfloat errorCheckUV(vec2 checkUV){\n  return float((checkUV.x < .0)||(checkUV.y < .0)||(checkUV.x > 1.)||(checkUV.y > 1.));\n}\n\nvec2 errorCheckUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckUV(checkUV);\n  return step(0.1,errorFlg) * (-1.,-1.) + (1.0 - step(0.1,errorFlg)) * returnUV;\n}\n\nfloat errorCheckLocalUV(vec2 checkUV){\n  return float((abs(checkUV.x) > .5 * TILE_LOCAL_LENGTH)||(abs(checkUV.y) > .5 * TILE_LOCAL_LENGTH));\n}\n\nvec2 errorCheckLocalUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckLocalUV(checkUV);\n  return step(.1, errorFlg) * (-1. * TILE_LOCAL_LENGTH, -1. * TILE_LOCAL_LENGTH) + step(.1, 1. - errorFlg) * returnUV;\n}\n\nvec2 uv2LocalUV(vec2 uv, vec2 centerPoint){\n  vec2 localUV = TILE_LOCAL_LENGTH * vec2((uv.x - centerPoint.x)/ TILE_LENGTH, \n                                          (uv.y - centerPoint.y)/ TILE_LENGTH);\n  return errorCheckLocalUV(localUV, localUV);\n}\n\nfloat waveValue(float period,float  minVal,float  maxVal){\n  return (cos(2. * PI * iTime / period) + 1.) * .5 * (maxVal - minVal) + minVal;\n}\n\nvec2 localUV2uv(vec2 localUV, vec2 startPoint){\n  vec2 gainedLocalUV = vec2(localUV.x * TILE_LENGTH, \n                            localUV.y * TILE_LENGTH);\n  vec2 uv = vec2((gainedLocalUV.x + startPoint.x) , \n                 (gainedLocalUV.y + startPoint.y) );\n  return errorCheckUV(localUV, uv);\n}\n\nvec3 gaussian(vec2 uv, float sigma){\n  float channelValue = GAUSSIAN_CONST_GAIN * exp(-dot(uv,uv)/(2. * sigma * sigma)); // / sigma; // Here I don't apply normalization because of visibility.\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nvec3 carrier(vec2 uv, float carrier_wavelength, float rotation_angle){\n  vec2[2] rotation_matrix = vec2[](\n    vec2(cos(rotation_angle),-sin(rotation_angle)),\n    vec2(sin(rotation_angle), cos(rotation_angle))\n  );\n  vec2 rotatedUV = vec2(dot(rotation_matrix[0],uv),\n                        dot(rotation_matrix[1],uv));\n  float channelValue = (cos(rotatedUV.x / carrier_wavelength) ) ;\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nfloat lineMask(vec2 uv, vec2 linePoint1,vec2 linePoint2, float threshold){\n  // rotate line to y-axis\n  vec2 v1 = (linePoint1 - linePoint2);\n  float lineLength = sqrt(dot(v1,v1));\n  v1 = v1 / lineLength;\n  float theta = atan(v1.x, v1.y);\n  vec2[2] rotateMat = vec2[](\n    vec2(cos(theta), -sin(theta)),\n    vec2(sin(theta),  cos(theta))\n  );\n  vec2 rotatedUV = vec2((dot(rotateMat[0], (uv - linePoint2))),\n                        (dot(rotateMat[1], (uv - linePoint2))));\n  return float(\n               (abs(rotatedUV.x ) < threshold)&&\n               (rotatedUV.y       > -threshold)&&\n               (rotatedUV.y       < lineLength + threshold)\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const\n  float sigma = waveValue(GAUSSIAN_TRANSITION_PERIOD, SIGMA_MAX, SIGMA_MIN);\n  float carrier_wavelength = waveValue(CARRIER_WAVELENGTH_PERIOD, CARRIER_WAVELENGTH_MAX, CARRIER_WAVELENGTH_MIN);\n  float rotation_angle = mod(2. * PI * iTime / CARRIER_ROTATION_PERIOD, 2. * PI);\n\n  // normalize position(x,y:.0~1.0)\n  vec2 uv = fragCoord.xy/ iResolution.x;\n\n  // get local positions\n  vec2 leftUV = uv2LocalUV(uv, LEFT_CENTER);\n  vec2 centerUV = uv2LocalUV(uv, CENTER_CENTER);\n  vec2 rightUV = uv2LocalUV(uv, RIGHT_CENTER);\n\n  // draw gaussian (center)\n  vec3 leftGaussianRegion = gaussian(leftUV, sigma);\n  // draw gaussian (center)\n  vec3 centerCarrierRegion = carrier(centerUV, carrier_wavelength, rotation_angle);\n  \n  // draw gaussian (center)\n  vec3 rightGaussianRegion = gaussian(rightUV, sigma);\n  vec3 rightCarrierRegion = carrier(rightUV, carrier_wavelength, rotation_angle);\n  \n  // draw left side(image(iChannel0))\n  float leftMask = 1. - errorCheckLocalUV(leftUV);\n  float centerMask = 1. - errorCheckLocalUV(centerUV);\n  float rightMask = 1. - errorCheckLocalUV(rightUV);\n  vec3 rgb = leftMask   * (.5 + leftGaussianRegion) + \n             centerMask * centerCarrierRegion + \n             rightMask  * (.5 + rightGaussianRegion * rightCarrierRegion);\n  float lineMaskAll = // multiply\n                      lineMask(uv, vec2(.35, .1),vec2(.3 , .15), .004) + \n                      lineMask(uv, vec2(.3,  .1),vec2(.35, .15), .004) + \n                      // equal\n                      lineMask(uv, vec2(.65,  .12),vec2(.7, .12), .004) + \n                      lineMask(uv, vec2(.65,  .14),vec2(.7, .14), .004) +\n                      // text(gabor)\n                      //// G\n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +  \n                      lineMask(uv, vec2(.07   + TEXT_START_X, .025 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +\n                      //// A\n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) +\n                      //// B\n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + 2. * TEXT_WIDTH + TEXT_START_X, .036 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .033 + TEXT_START_Y),\n                                   vec2(.076  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y),\n                                   vec2(.073  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.072  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) +\n                      //// O\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      //// R\n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) \n                      ;\n  rgb = lineMaskAll * 1. + (1. - lineMaskAll) * rgb;\n\n  rgb = displayGamma(rgb);\n\n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1174, 1174, 1203, 1339, 1545], [1547, 1547, 1580, 1580, 1670], [1672, 1672, 1719, 1719, 1844], [1846, 1846, 1884, 1884, 1988], [1990, 1990, 2042, 2042, 2210], [2212, 2212, 2255, 2255, 2463], [2465, 2465, 2523, 2523, 2606], [2608, 2608, 2655, 2655, 2907], [2909, 2909, 2945, 2945, 3159], [4274, 4274, 4330, 4341, 10936]], "test": "untested"}
{"id": "fd3SzH", "name": "gold/blue dress", "author": "FabriceNeyret2", "description": "center: the 2 strip colors in the photo. see refs below.\nleft: subtracting the ambiant color assumed dark yellow.\nright: undoing the lighting assumed clear blue.\n", "tags": ["illusion", "perception"], "likes": 13, "viewed": 273, "published": 3, "date": "1632568947", "time_retrieved": "2024-07-30T18:59:21.908109", "image_code": "vec4 C1 = .5 - .25*vec4(0,0,1,0),     // dark color  ( seen black or gold )\n     C2 = .5 + .25*vec4(0,0,1,1);     // clear color ( seen blue or white )\n     \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u - R ) / R.y;\n         \n    O = fract(2.*U.y) < .5 ? C1 : C2; // strips\n    \n    if ( U.x < -.7 ) O -= C1;         // subtract ambiant = dark color\n // if ( U.x >  .7 ) O += C1;  \n    if ( U.x >  .7 ) O /= C2;         // undo lighting = clear color\n    \n // if ( U.x < -1.6 ) O = .5+C1;      // back-transform how grey bg would appear in photo\n // if ( U.x >  1.6 ) O = .5*C2;      // back-transform how grey bg would appear in photo\n // if ( U.x < -1.6 ) O = C1;         // back-transform how black bg would appear in photo\n // if ( U.x >  1.6 ) O = C2;         // back-transform how white bg would appear in photo\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 197, 197, 862]], "test": "untested"}
{"id": "fscSzH", "name": "Smokey Bubbles dUTCH oVEN", "author": "xenn", "description": "NOTHING LAST FOREVER", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 7, "viewed": 338, "published": 3, "date": "1632568604", "time_retrieved": "2024-07-30T18:59:23.055044", "image_code": "\n// Fork of \"Barbarella's Lava Lamp 2\" by xenn. https://shadertoy.com/view/Ndd3Ws\n// 2021-09-17 15:03:30\n\n/*\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *(0.92 - (.01*sin(iTime))) + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel2,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel2,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel2,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, cos(iTime) );\n\n    fragColor = vec4(col,1.0);\n}\n*/\n\n// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,col2);\n                      color = min(col2,col);\n                 //     col2 = mix(col2,color,0.05);\n                     col2 = min(col,color);\n                      \n                       \n    //  color = max(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col2,(color))))*noise), 1.0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.75;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n//    vec3 envMap = texture(iChannel1, dir).rgb;\n//    envMap = envMap * envMap;\n//    float kEnvmapExposure = 0.99999;\n//    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.0f - (1.0f - fresnelA) * (1.0f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.5, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 200.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = 1.0;\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n    colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Margins 0.\n#define TS abs(sin(iTime / 3.0))\n#define TC abs(cos(iTime / 2.50))\n#define TS2 abs(sin(iTime / 2.0))\n#define TC2 abs(cos(iTime / 2.0))\n\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.95);\n//  blend = max(blend, (fract((pos+v*vec2(-1,1)*2.0)/Res.xy),0.));\n//  blend = (col * col2)  + blend * col;\n // fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n// fragColor=vec4(fract((pos+v*vec2(-1,1)*2.0)/Res.xy),1.);\n//  fragColor=blend;\n    fragColor=blend,texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if USE_THIN_FILM_LOOKUP\n    if (iFrame > 0)\n    {\n        int segmentCount = 32;\n        int segment = iFrame % segmentCount;\n        int currSegment = int(floor((fragCoord.y * float(segmentCount) / iResolution.y)));\n        \n        if ( segment != currSegment )\n        {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            return;\n        }\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec3 result = GetThinFilmColour(uv.x, uv.y);  \n\n    fragColor = vec4(result,1.0);\n#else\n    discard;\n#endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,(0.005 * TS));\n     vec4 blendy = mix(col2,col,(0.09 * TC));\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n    blend = min(blend,blendy);\n       blend = max(blend,blendo);\n //      blend = max(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col * col2)  + blend * col;\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.0001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2049, 2049, 2069, 2069, 2148], [2150, 2150, 2173, 2173, 2328], [2330, 2330, 2387, 2387, 3733]], "test": "untested"}
{"id": "Nd3XRH", "name": "quite a nice yucky mess", "author": "xenn", "description": "Wouldn't be out of place in her ship", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 10, "viewed": 392, "published": 3, "date": "1632562654", "time_retrieved": "2024-07-30T18:59:24.173054", "image_code": "\n// Fork of \"Barbarella's Lava Lamp 2\" by xenn. https://shadertoy.com/view/Ndd3Ws\n// 2021-09-17 15:03:30\n\n/*\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *(0.92 - (.01*sin(iTime))) + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel2,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel2,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel2,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, cos(iTime) );\n\n    fragColor = vec4(col,1.0);\n}\n*/\n\n// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,col2);\n                      color += max(col2,col);\n                      col2 = mix(col2,color,0.05);\n                     col2 = min(col,color);\n                      \n                       \n      color = max(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,0.005);\n     vec4 blendy = max(col2,col);\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n   //    blend = min(blend,blendy);\n       blend = mix(blend,blendo,0.05);\n       blend =max(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col + col2)  * (blendo - blendy);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Margins 0.\n#define TS abs(sin(iTime / 3.0))\n#define TC abs(cos(iTime / 2.50))\n#define TS2 abs(sin(iTime / 2.0))\n#define TC2 abs(cos(iTime / 2.0))\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .01;\nconst float iFeedbackColorShiftImpact = -0.001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.5;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = .8;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .142;\nconst float iBlob2Radius              = .95;\nconst float iBlob2PowFactor           = 30.;\nconst float iBlob2ColorPulseSpeed     = .234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nfloat SCALE = 0.75;\nfloat SPEED = 0.025;\nfloat INTENSITY = 20.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.05;\nfloat FADING = 0.5;\nfloat GLOW = 2.50 ;\n\n#define M_2_PI 6.28318530\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n// vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n         vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n          float dist1 = mapcircle(uv.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col3 = vec3((0.4 * TC2), 0.0, (0.95 * TC)) * pow(RADIUS/dist1, (GLOW / TS2));\n\tvec3 col1 = vec3((0.99 * TC), .0, (0.45 * TS2)) * pow(RADIUS/dist2, (GLOW / TS));\n\tvec3 col2 = vec3((1.0 * TC), (1.0 * TS), (0.5 * TS2)) * pow(RADIUS/dist3, (GLOW / TC));\n    \n//  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  \n    vec2 uv2 = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv2 - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv2 - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.bg - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv2 - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * (iColorShiftOfRadius * (1.0 * (sin(iTime / 1.3))));\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    \n //    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n  \n\t\n\tvec3 col=(col1+col2+col3)*(2.*GLOW);\n    fragColor = mix(vec4(col, 1.0), vec4(color, 1.),0.5);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),-1750.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n//\tfragColor = mix((texture(iChannel0,uv)*vec4(diff)-vec4(spec)),texture(iChannel0,uv)*vec4(diff)-vec4(spec),0.25);\nfragColor = ((texture(iChannel0,uv)*vec4(diff)*vec4(spec)));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,(0.005 * TS));\n     vec4 blendy = mix(col2,col,(0.09 * TC));\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n    blend = max(blend,blendy);\n //      blend = max(blend,blendo);\n //      blend = max(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col * col2)  + blend * col;\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3XRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2049, 2049, 2069, 2069, 2148], [2150, 2150, 2173, 2173, 2328], [2330, 2330, 2387, 2387, 3735]], "test": "untested"}
{"id": "fs3SRH", "name": "大龙猫 - WiReZ", "author": "totetmatt", "description": "Not so crappy, got some perf drop when close to wireframe but it's fine.", "tags": ["tunnel", "wireframe"], "likes": 8, "viewed": 283, "published": 3, "date": "1632560764", "time_retrieved": "2024-07-30T18:59:25.139470", "image_code": "\n/**\n\n== Do not buy NFT made with my art. ==\n\n== Do not make NFT with my Creative-Commons artworks. ==\n\n== If you respect my art, remember and apply this. ==\n\n*/\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat elev(vec3 p){\n  float s = 0.;\n  vec4 pp= vec4(p*.5,1.1);\n  const float lim = 8.;\n  for(float i=0.;i<lim;i++){\n     pp.xzy = abs(pp.xzy)-vec3(1.125,1.5,1.2);\n        pp.xz*=rot(-.785+i);\n      pp *=1.3;\n  float m = min(pp.x,pp.z);\n      s += sqrt(clamp( \n       ( \n         tan(sin(m-pp.x*3.))\n         +tan(cos(m+pp.z*7.))\n    )/(pow(3.,i+1.))\n   \n    \n    ,-0.0,1.3))*.5;\n  }\n  return s/lim;\n}\nfloat diam2(vec2 p,float s){\n   p = abs(p);\n   return (p.x+p.y-s)*inversesqrt(3.);\n  }\nvec2 sdf(vec3 p){\n  p.xy *=rot(p.z*.3);\n  p.y = -(abs(p.y)-1.);\n  \n  vec2 h;\n  \n  vec3 hp= p;\n  h.x = dot(p,vec3(0.,1.,0.))+elev(hp)*2.0;;\n  //h.x = mix(h.x,+elev(hp+vec3(551.51,55.2,55.))*2.0,.5);\n  h.y= 1.;\n  \n  vec2 t ;\n  vec3 tp = p;\n  vec2 ltp = vec2(log(length(p.xy)),atan(p.y,p.x))*3.;\n  ltp.x +=iTime;\n\n  ltp = fract(ltp);\n  \n  \n  tp.y +=asin(sin(p.z));\n  tp.xy *= rot(tp.z*.1)*.7;\n  tp.xz /=2.;\n  tp.xz = fract(tp.xz)-.5;\n  \n  t.y =2.;\n  t.x = min(diam2(tp.zy,.05),diam2(tp.xy,.05));\n  \n  h = t.x < h.x ? t:h;\n \n  return h;\n  \n}\n\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n  vec3 pal(float t){return vec3(0.,.5,.0)+vec3(.0,.5,.1)*cos(6.28*(vec3(1.,1.0,10.)*t+vec3(.0,.3,.7)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n\tvec3 col = vec3(.01);\n  vec3 ro = vec3(0.,0.2,-7.+iTime);\n\n  vec3 rt = vec3(0.+sin(iTime*.2)*3.,-1.0,ro.z+cos(iTime*.2)*10.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  rd.xy*=rot(iTime*.1);\n  vec3 rp =ro;\n  \n  vec3 light = ro+vec3(1.,2.,-1.);\n  float dd = 0.;\n  float side = 1.;\n  vec3 acc = vec3(0.);\n  float sat = 0.;\n  for(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n    dd +=d.x;\n    d.x *=side;\n    if(dd>50.) break;\n    if(d.x < .001){\n      vec3 n = norm(rp,.005);\n      float diff = max(0.,dot(normalize(light-rp),n));\n        if(d.y == 1.){\n        \n          col = vec3(.02)*diff;\n          break;\n        } \n        if(d.y == 2.){\n            vec3 n2 = norm(rp,.001);\n          float l = length(n-n2);\n            float di = step(.1,l);\n            acc += vec3(di)*pal(+fract(rp.z*.1));\n            sat = min(1.,sat+sqrt(di));\n        \n          side *=-1.;\n              \n          rp +=rd*.05;\n         \n        \n          }\n      }\n    rp +=rd*d.x;\n    }\n col +=acc;\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 162, 180, 180, 227], [228, 228, 247, 247, 628], [629, 629, 657, 657, 715], [716, 716, 733, 733, 1253], [1281, 1281, 1308, 1308, 1384], [1387, 1387, 1405, 1405, 1489], [1491, 1491, 1548, 1598, 2806]], "test": "untested"}
{"id": "NscXR8", "name": "ARQVOID :: 240 chars", "author": "ENDESGA", "description": "///////", "tags": ["spiral", "golf", "void"], "likes": 26, "viewed": 1150, "published": 3, "date": "1632549692", "time_retrieved": "2024-07-30T18:59:26.015129", "image_code": "// 240 chars by Xor (with aspect ratio fix)\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 p=iResolution,d = -.5*vec3(I+I-p.xy,p)/p.x,c = d-d, i=c;\n    for(;i.x<1.;c += length(sin(p.yx)+cos(p.xz+iTime))*d)\n        p = c,\n        p.z -= iTime+(i.x+=.01),\n        p.xy *= mat2(sin((p.z*=.1)+vec4(0,11,33,0)));\n    O = vec4(10,0,2.5,9)/length(c);\n}\n\n// ORIGINAL: 258 chars\n/*void mainImage(out vec4 O, in vec2 I) {\n    vec3 d = .5-vec3(I,1)/iResolution, p, c;\n    for(float i=0.;i<99.;i++) {\n        p = c;\n        p.z -= iTime+i*.01;\n        p.z *= .1;\n        p.xy *= mat2(sin(p.z),-cos(p.z),cos(p.z),sin(p.z));\n        c += length(sin(p.yx)+cos(p.xz+iTime))*d;\n    }\n    O.rgb = vec3(5./length(c))*vec3(2.,.0,.5);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 80, 80, 344]], "test": "untested"}
{"id": "7ddXzr", "name": "tunnel-ship", "author": "jorge2017a2", "description": "tunnel-ship", "tags": ["tunnelship"], "likes": 10, "viewed": 266, "published": 3, "date": "1632533763", "time_retrieved": "2024-07-30T18:59:27.044376", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 cilindroTunel(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdc1= sdCylinderXY(p , vec2(15.0,10.0) );\n    float sdc2= sdCylinderXY(p , vec2(13.0,11.0) );\n    float sdb1=sdBox(p-vec3(12.0,0.0,0.0),vec3(5.0,7.0,11.) );\n    float sdb2=sdBox(p-vec3(-12.0,0.0,0.0),vec3(5.0,3.0,5.) );\n    float sdb3=sdBox(p-vec3(-13.0,0.0,0.0),vec3(2.0,3.5,5.) );\n    \n    float dif= differenceSDF(sdc1, sdc2);\n    dif= differenceSDF(dif, sdb1);\n    \n    dif= differenceSDF(dif, sdb2);\n    float dif2= differenceSDF(sdb3,sdb2 );\n    \n    vec3 posAnillo=p;\n    posAnillo.z=abs(posAnillo.z)-10.0;\n    float sdc3a= sdCylinderXY(posAnillo,vec2(15.0,1.0) );\n    float sdc3b= sdCylinderXY(posAnillo,vec2(12.0,1.5) );\n    float dif3= differenceSDF(sdc3a, sdc3b);\n    \n    res =opU3(res, vec3(dif,101.0,-1.0));\n    res =opU3(res, vec3(dif2,4.0,-1.0));\n    res =opU3(res, vec3(dif3,5.0,-1.0));\n    \n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    float tt=iTime*15.0;\n    p.z+=tt;\n    p.y=p.y-5.0;\n    p.z= opRep1D(p.z, 21.0 );\n    float sds1=sdSphere(pp-vec3(0.0+2.0*cos(iTime),5.0+3.0*sin(iTime),0.0), 5.0 );\n    res =opU3(res, vec3(sds1,7.0,-1.0));\n    vec3 c1= cilindroTunel(p);\n    res =opU3(res, c1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 )\n    { \n    float tt=iTime*15.0;\n    p.z+=tt;\n    p.z= opRep1D(p.z, 21.0 );\n    return tex3D(iChannel1, p/32., nor); \n    }\n    \n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   vec3 col=texture(iChannel0, mObj.uv*0.5-vec2(-0.5,-0.5)).rgb;\n    return col;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd; mObj.ro=ro; vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(-200.0, -360.0, -230.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(-200.0, -60.0, -260.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(25.0,7.0,-25.0);\n   float t1=mod(iTime,6.0);\n   float t2=mod(iTime,5.0);\n   \n   if (t1<t2)\n    ro=vec3(25.0,7.0,-25.0);\n   else\n    ro=vec3(40.0,7.0,-25.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(-45.0) );\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "buffer_a_code": "//---buffer A\n//https://glslsandbox.com/e#75275.2\n#define num_layers 6.\n\nmat2 rot(float a) {float s=sin(a) , c=cos(a);    return mat2(c, -s, s, c);}    \n\nfloat star(vec2 uv, float flare) \n{\n    float d = length (uv);\n\tfloat m = .05 / d;\n\tfloat rays = max (0. , 1. -abs (uv.x * uv.y * 1000.));\n\tm +=rays * flare;\n\tuv *=rot(3.1415/4.);\n    rays = max (0. , 1. -abs (uv.x * uv.y * 1000.));\n\tm +=rays*.3 * flare;\n    m *= smoothstep(1.,.2,d);\n    return m;\n}  \n\nfloat hash (vec2 p) {\n    p = fract(p*vec2(123.34,456.567));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 starlayer (vec2 uv)\n{\nvec3 col = vec3(0);\n\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    for (int y=-1;y<=1;y++) {\n        for (int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x,y);\n            float n = hash(id+offs); // random value\n            float size = fract(n*456.32);\n\n            float star1 = star (gv-offs-vec2(n,fract (n*34.))+.5, smoothstep(.85,1.,size));\n            \n            vec3 color = vec3(0.4+(sin(uv.y+uv.x*2.0+n*1121.43)*.5),0.5,1.);\t//sin(vec3(.2,.5,.9)*fract(n*4232.4)*6.28)*.5+.5;\n            //color = color * vec3(1.,1,1.);\n            //star1 *= sin(time*2.+n*12.56)*.5+1.;\n\t\tcolor.b *= 0.5+sin(n*17.7)*0.5;\n            col+= star1*size*color;\n            \n        }\n    }\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\t\n    vec3 col = vec3 (0.);\n    float t = iTime*.021+iTime/100.;\n\tuv *= rot(t);\n    for (float i=0.;i < 1.;i += 1./num_layers)\n    {\n        float depth = fract(i+t);\n        float scale = mix (20., .5, depth);\n        float fade = depth*smoothstep (1.,.9,depth);;\n        col+= starlayer(uv*scale+i*347.9)*fade;\n    }\n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 534, 534, 555], [556, 556, 588, 588, 672], [673, 673, 712, 712, 807], [809, 853, 900, 900, 927], [928, 928, 971, 971, 998], [999, 999, 1047, 1047, 1075], [1076, 1114, 1150, 1150, 1195], [1196, 1261, 1295, 1295, 1391], [1392, 1392, 1426, 1426, 1517], [1518, 1518, 1552, 1552, 1643], [1645, 1645, 1673, 1673, 2549], [2551, 2551, 2576, 2576, 2905], [2907, 2907, 2931, 2931, 3093], [3095, 3095, 3144, 3144, 3811], [3813, 3813, 3849, 3849, 4094], [4096, 4096, 4123, 4123, 4140], [4142, 4142, 4178, 4178, 4270], [4271, 4271, 4317, 4317, 4442], [4444, 4444, 4481, 4481, 4757], [4759, 4759, 4842, 4842, 5421], [5423, 5423, 5472, 5472, 5802], [5804, 5804, 5897, 5897, 6027], [6029, 6029, 6061, 6061, 6143], [6145, 6145, 6238, 6238, 6556], [6558, 6558, 6589, 6589, 7182], [7184, 7184, 7210, 7210, 7320], [7322, 7322, 7380, 7380, 7432], [7434, 7434, 7491, 7491, 8220]], "test": "untested"}
{"id": "sddXzr", "name": "Differential Eq with Slope Field", "author": "oneshade", "description": "Never thought I would be able to, but now I'm learning about differential equations! Drag with the mouse to set the initial conditions (starting point).", "tags": ["math", "graph", "differential", "slopefield", "differentialequation", "diffeq"], "likes": 10, "viewed": 300, "published": 3, "date": "1632532541", "time_retrieved": "2024-07-30T18:59:27.840249", "image_code": "// Learning from https://tutorial.math.lamar.edu/Classes/DE/IntroFirstOrder.aspx\n// Really great website for learning mathematics!\n//\n// A few examples I've solved:\n// https://www.desmos.com/calculator/jlvblaiscz\n// https://www.desmos.com/calculator/pjiqmyoxdu\n// https://www.desmos.com/calculator/zxnoa3soqo\n// https://www.desmos.com/calculator/qd3ewftatc\n\nfloat slopeField(in vec2 p) {\n    float co = cos(p.x), si = sin(p.x);\n    return 2.0 * co * co * si - (1.0 + si * p.y) / co; // dy/dx\n}\n\nvec2 solveIVP(in float x, in vec2 init) {\n    float coInit = cos(init.x), siInit = sin(init.x);\n    float C = coInit * coInit + (siInit + init.y) / coInit; // undefined when init.x is an odd multiple of pi/2\n    float co = cos(x), si = sin(x);\n    return vec2((C - co * co) * co - si, (3.0 * co * co - C) * si - co); // y, dy/dx\n}\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n\tvec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (p.x * q.y - p.y * q.x), k * (p.y - q.y));\n\treturn sqrt(d) * sign(s);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0 * cos(iTime), sin(0.5 * iTime)) * 2.0;\n\n    // Square grid tiling\n    vec2 cellId = floor(uv * 3.0) / 3.0 + 0.5 / 3.0;\n    vec2 cellUv = uv - cellId;\n\n    // Slope field cell\n    float slope = slopeField(cellId);\n    float lineY = cellUv.x * slope;\n    drawSDF(abs(cellUv.y - lineY) / sqrt(1.0 + slope * slope), vec3(0.0));\n\n    // Draw particular solution (exact)\n    vec2 y = solveIVP(uv.x, mouse);\n    drawSDF(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.02, vec3(1.0, 0.0, 0.0));\n\n    // Plot the starting point\n    drawSDF(sdDisc(uv, mouse, 0.15), vec3(0.5, 0.0, 1.0));\n\n    // Plot particle path through the slope field\n    for (float x=mouse.x; x < 8.0; x += 1.0) {\n        vec2 y = solveIVP(x, mouse);\n        vec2 arrowUv = uv - vec2(x, y.x);\n        vec2 dir = normalize(vec2(1.0, y.y));\n        arrowUv *= mat2(-dir.y, dir.x, -dir);\n        drawSDF(sdIsosceles(arrowUv, vec2(0.15, 0.4)), vec3(0.0, 0.0, 0.5));\n    }\n\n    // Vignette\n    color *= 1.0 - 2.0 * pow(length(fragCoord / iResolution.xy - 0.5), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 387, 387, 493], [495, 495, 536, 536, 825], [827, 835, 883, 883, 915], [917, 968, 1009, 1009, 1307], [1389, 1389, 1444, 1444, 2822]], "test": "untested"}
{"id": "wttGzn", "name": "buildings by night", "author": "rcargou", "description": "hi", "tags": ["raymarching"], "likes": 9, "viewed": 403, "published": 3, "date": "1632520435", "time_retrieved": "2024-07-30T18:59:28.787716", "image_code": "#define AA 3  // make this 2 or 3 for antialiasing\n// Derived from IQ raymarcher and is, as such, educational only\n\n//snoise(vec3 uv, float res)\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\nfloat sdBuildings(vec3 p) {\n    vec3 box = vec3(.7f, 4.7f, .4f);\n    vec3 q = p;\n    \n    float modsize = 3.0f;\n    \n    p.xz = mod(p.xz, modsize) - modsize/2.0f;\n\n    float d =  length( max ( abs(p) - box, .0f  )) - .003f;\n    return d;\n}\n\n\n\nvec2 map( in vec3 pos )\n{\n\n    vec2 res = vec2( 1e10, 0.0 );\n    res.x = sdBuildings(pos);\n    if (pos.y + .5f < res.x) {\n        res.x = pos.y + .5f;\n        res.y = 2.0f;\n    }\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 40.0;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<400 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 lighting(vec3 ro, vec3 rd, float t, float mat) {\n\n    vec3 col = vec3(.0f);\n    float li = 1.3f;\n    vec3 light_col = li * vec3(.5f, .5f, .9f);\n    vec3 light_dir = vec3(0, 0, -1.0);\n   \n    vec3 nor = calcNormal(ro + rd*t);\n    float ndotl = max(.2f, dot(nor, light_dir) );\n    col =  light_col * ndotl;\n    \n    vec3 l_pos = ro;\n    \n    vec3 l_dir = normalize(- (rd * t));\n    \n    float ndotl_car = max(.0f, dot(nor, l_dir) );\n    float spec = abs( dot (reflect(rd, nor), l_dir ) );\n    //return vec3(ndotl_car / (t*t));\n    //ndotl_car = pow(ndotl_car, 5.0f);\n    ndotl_car /= (t*t * t * .1f);\n    \n    //col += vec3(10.0f ) * ndotl_car;\n    spec = 40.0f * pow(spec, 5.0f)  / (t * t);\n    return vec3(spec);\n    col += vec3(ndotl_car);\n    return col;\n}\n\nvec3 background(vec3 ro, vec3 rd, vec2 uv) {\n    float f = smoothstep(0.0f, .2f, rd.y);\n    uv.y -= iTime / 20.0f;\n    vec3 sky = vec3(0.03,0.03,0.07) + pow( texture(iChannel0, uv/1.0f).x, 10.0f) * .5f;\n    return mix(vec3(0.05,0.06,0.07), sky, f);\n}\n\nfloat roadline(vec3 p ) {\n    return smoothstep(0.01f, .0f, abs((p).x)) + \n    smoothstep(0.01f, .0f, abs((p).x + .5f))\n    + smoothstep(0.01f, .0f, abs((p).x - .5f));\n           \n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n\n    float b = .1f;\n   // distance *= 2.0f;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.05,0.06,0.07);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat fog(vec3 ro, vec3 rd, float t)\n{\n    return .1f / t;\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec4 shadeBuilding(vec3 p, vec3 nor) {\n    \n    vec2 qf = round ( fract( ( p.xy - vec2(.0f, .0f) )  / .2f) );\n    vec2 qid =  round( ( ( ( p.xy - vec2(.0f, .0f) )  / .2f) ));\n    float l = clamp( .0f, 1.0f, round ( hash1( qid.xy ) * 2.0f));\n    vec2 q = mod(p.xy, .8) - .4f;\n    if (abs(nor.x) > .3f)\n        qf = round ( fract( ( p.yz - vec2(.0f, .0f) )  / .2f) );\n    float f = smoothstep(.03f, .2f, p.y) * qf.x * qf.y;\n    f = f * .1f + f * .9f * l;\n\n    vec2 tuv = mix(p.xy, p.zy, nor.x);\n    vec3 bcol = texture(iChannel1, tuv).xyz / 10.0f;\n    vec3 col =  mix(bcol, vec3(1.0f, 1.0f, 3.0f / 5.0f), f);\n    return (vec4(col, f));     \n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 nor;\n    if (res.x > .0f) {\n    vec3 pos = ro+rd*t;\n    nor = calcNormal(ro + rd * t);\n    float emi = .0f;\n        if (res.y == 2.0f) {\n            col = vec3(.1f, .1f, .1f);\n            float a =  roadline(ro + rd * t) * .1f;\n            \n            col = vec3(a)     +  texture(iChannel2,  (ro+rd*t).xz * 2.0f ).xyz * 0.01f * smoothstep(.5f, 0.51f, abs(pos.x));\n;\n            }\n        else{\n        vec4 r = shadeBuilding(ro + rd * t, nor);\n            col = r.xyz;\n            emi = r.w;\n            }\n         //   return lighting(ro, rd, res.x, res.y);\n    \tcol = lighting(ro, rd, res.x, res.y) * col + col * emi;\n    }\n    else \n        col = background(ro, rd, uv);\n    col = applyFog(col, t);\n    //col *=.7f;\n   \treturn vec3(col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(0, -0.3, 0.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0, -0.4, 1.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        ro.z = iTime * 1.3f;\n        ro.x = -.2f;\n        vec3 rd = normalize( vec3(p.xy,2.0)  ) *ca;\n\n        // render\t\n        vec3 col = render( ro, rd, p );\n\n\t\t// gamma\n        col = pow( col, vec3(1.5545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 372, 372, 467], [470, 470, 497, 497, 709], [713, 713, 738, 738, 909], [938, 938, 978, 978, 1401], [1404, 1449, 1527, 1550, 1891], [1893, 1939, 1971, 1971, 2181], [2183, 2183, 2225, 2225, 2541], [2544, 2544, 2596, 2596, 2773], [2775, 2775, 2828, 2828, 3538], [3540, 3540, 3584, 3584, 3790], [3792, 3792, 3817, 3817, 3973], [3975, 3975, 4105, 4105, 4287], [4288, 4288, 4326, 4326, 4348], [4350, 4350, 4373, 4373, 4450], [4452, 4452, 4490, 4490, 5092], [5094, 5094, 5142, 5142, 5993]], "test": "untested"}
{"id": "ss3Szr", "name": "1 Hour Practice #001", "author": "byt3_m3chanic", "description": "Took a break from raymarching/3D to do some 2D tiling stuff - pretty fun motion/patterns using ID's and linear stepping functions / some cubic ease in/out via book-of-shaders.\n\nOriginal https://www.shadertoy.com/view/ssVGDd (saved for later use)", "tags": ["2d"], "likes": 13, "viewed": 313, "published": 3, "date": "1632519610", "time_retrieved": "2024-07-30T18:59:29.558654", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    What can you do in one hour? This is about as far as I can get\n    Was just playing with tiles / shifting sections based on id's\n    \n    @byt3_m3chanic 1 Hour Practice #001 / slide tiles\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define TAU         6.28318530718\n\nfloat time;\nconst float scale = 7.;\nconst vec3 d = vec3(0.957,0.439,0.043);\n\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\nvec3 hue(float t){ return .55 + .45*cos(TAU*t*(vec3(.95,.97,.98)*d)); }\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T;\n    float tmod = mod(time, 10.);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    uv.x +=.075;\n    vec2 vuv = uv;\n    float px = fwidth(vuv.x*TAU);\n    uv.y += T*.1;\n    vec3 C = vec3(0);\n\n    vec2 id = floor(uv*scale);\n    vec2 dd = (id*.2);\n    float sw;\n\n    id += vec2(0,5);\n    id.x = abs(id.x);\n    float yid = floor(mod(id.x,8.));\n    //movement\n    float t3 = lsp(yid, yid+2.75, tmod);\n    t3 = eoc(t3);\n    t3 = t3*t3*t3;\n    float ga1 = (time*.1);\n    sw = (t3*.5);\n    uv.y+=sw+(floor(ga1)*.5);\n    \n    //rest id to new pos\n    id = floor(uv*scale);\n    //do truchet stuff\n    float rnd = hash21(id);\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n    if(rnd>.5) uv.x*=-1.;\n    \n    vec2 qv = fract(uv*scale)-.5;\n\n    float circle = length(qv-vec2(.5,-.5))-.5;\n          circle = min(length(qv-vec2(-.5,.5))-.5,circle);\n    float circle3 = abs(circle)-.05;\n    \n    float c2 = smoothstep(-px,px,abs(abs(circle)-.05)-.025);\n    circle = (rnd>.5^^chk>.5) ? smoothstep(px,-px,circle) : smoothstep(-px,px,circle);\n\n    circle3 = smoothstep(.125,-px,circle3);\n    float dots = length(abs(qv)-vec2(.5,0))-.25;\n    dots = min(length(abs(qv)-vec2(0,.5))-.25,dots);\n\n    dots = abs(abs(abs(dots)-.05)-.025)-.0125;\n    dots = smoothstep(px,-px,dots);\n    \n    float hs = hash21(vuv)*.15;\n    C =  clamp(hue(52.+id.x*.05)+hs,C,vec3(1));\n    \n    C = mix(C,C*.75,dots);\n    C = mix(C,C*.75,circle3);\n    C = mix(C,C*.70,clamp(max(circle,-c2),0.,1.));\n    C = mix(C,vec3(.93),clamp(min(circle,c2),0.,1.));\n \n    // Output to screen\n    O = vec4(C,1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Szr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[525, 525, 547, 547, 609], [610, 610, 654, 654, 709], [710, 710, 730, 730, 768], [770, 770, 788, 788, 841]], "test": "untested"}
{"id": "ss33Rj", "name": "Seifert surface (implicit)", "author": "arifr123", "description": "Implicit equation plotter v2!!!\nCONTROLS:\n* Mouse\n* Space\n* Keys 1 - 3\n\n(x + iy)^p + (z + iw)^q = 0", "tags": ["implicitequation", "seifertsurface"], "likes": 13, "viewed": 240, "published": 3, "date": "1632501223", "time_retrieved": "2024-07-30T18:59:30.517091", "image_code": "vec3 normal(vec3 p, vec3 camera)\n{\n    vec3 normal = normalize(vec3(R(transpose(mat2x3(p, vec3(1, 0, 0))), iTime).y,\n                                 R(transpose(mat2x3(p, vec3(0, 1, 0))), iTime).y,\n                                 R(transpose(mat2x3(p, vec3(0, 0, 1))), iTime).y));\n                                 \n    normal *= sign(dot(normal, p - camera));\n    \n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, coord, 0);\n    \n    CastParams params = to_params(state);\n    \n    vec3 col = vec3(1, 0, 0);\n    \n    if(params.best_t >= 0.)\n    {\n        GLOBALS;\n    \n        const vec3 light = normalize(vec3(1, 2, 0));\n        \n        vec3 intersection = camera + ray * params.best_t;\n    \n        col = vec3(0.5 * dot(normal(intersection, camera), light) + 0.5);        \n    }\n    \n    \n    #if 0\n    \n    int lod = 4;\n    float min_best_t = neighbors_best_t(coord, ivec2(0, 0), lod);\n    \n    col = vec3(min_best_t / 15.);\n    \n    #endif\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct CastResult\n{\n    bool zero;\n    bool out_of_range;\n    bool local_min;\n    vec3 p;\n    int iterations;\n    AdamParams adam;\n};\n\n\n#define zero_threshold 0.05\n// 0.1 0.05 0.01\n\nCastResult cast_ray(CastParams params, vec3 origin, vec3 ray, int iterations, float alpha, bool adam, bool min_fail)\n{\n    // R(camera + t * ray) = 0\n    //\n    // MIN R(camera + t * ray)^2\n    // 2 * R * dR/dt\n    //\n    // MIN abs(R(camera + t * ray))\n    // sign(R) * dR/dt\n    //\n    // MIN abs(R(camera + t * ray))^n\n    // n * abs(R)^(n-1) * sign(R) * dR/dt\n    // n = 1.5\n    // 1.5 * abs(R)^0.5 * sign(R) * dR/dt\\\n    \n    /////////// ADAM ///////////\n    const float b1 = 0.9;\n    const float b2 = 0.999;\n    ////////////////////////////\n    \n    const float min_delta = 0.01;  // 0.001 0.05 Too big? may cause fail before zero.\n    \n    float t = 0.;\n    vec3 p = vec3(0.);\n    \n    float next_t = params.adam.t;\n    vec3 next_p = origin + next_t * ray;\n    \n    origin += next_t * ray;\n    // origin = next_p;\n    \n    float m = params.adam.m;\n    float v = params.adam.v;\n    \n    bool out_of_range = false;\n    bool zero = false;\n    bool local_min = false;\n    \n    for(; 0 <= iterations && !out_of_range && (!min_fail || !local_min) && !zero; iterations--)\n    {\n        p = next_p;\n        t = next_t;\n        \n        vec2 res = R(transpose(mat2x3(p, ray)), iTime);\n        \n        float r_value = res.x;\n        float dr_dt = res.y;\n        \n        float grad = sign(r_value) * dr_dt;  // 2. * res.x * res.y;\n        \n        m = b1 * m + (1. - b1) * grad;\n        v = b2 * v + (1. - b2) * sq(grad);\n        \n        float m_hat = m / (1. - b1);\n        float v_hat = v / (1. - b2);\n        \n        float delta = alpha * m_hat / (sqrt(v) + 1e-8);\n        if(!adam) delta = alpha * grad;\n                \n        next_t = t - delta;\n        next_p = p - ray * delta;\n        \n        local_min = abs(delta) < abs(r_value) * min_delta;\n        out_of_range = next_t < 0. || (0. <= params.best_t && params.best_t < next_t);\n        zero = abs(res.x) <= zero_threshold;\n    }\n    \n    return CastResult(zero, out_of_range, local_min, p, iterations, AdamParams(t, m, v));\n}\n\nCastResult cast_ray(CastParams params, vec3 origin, vec3 ray, int iterations)\n{\n    const float alpha = 0.001;  // 0.01 0.001\n    const bool adam = true;\n    const bool min_fail = true;\n    return cast_ray(params, origin, ray, iterations, alpha, adam, min_fail);\n}\n\n\nivec2 rand_shift(float rand, float r, bool center)\n{\n    float angle = rand * TWO_PI;\n    vec2 f_shift = hash11(500. * rand) * r * cis(angle);\n    \n    if(center) return ivec2(f_shift);\n    else return ivec2(ceil(abs(f_shift)) * sign(f_shift));\n}\n\n//float avg_neighbors_best_t(ivec2 coord, ivec2 shift, int lod)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = to_vec4(CastParams(AdamParams(0., 0., 0.), -1.));\n        return;\n    }\n\n    GLOBALS;\n    \n    \n    ivec2 coord = ivec2(fragCoord);\n    CastParams params = accessState(coord);\n    \n    /*if(isnan(params.adam.t) || isinf(params.adam.t))\n    {\n        params.adam = AdamParams(0., 0., 0.);\n        params.\n    }*/\n    \n    \n    ///////////////// BEST OPTIMIZATION /////////////////\n    \n    CastResult best_res = cast_ray(CastParams(AdamParams(params.best_t, 0., 2.), -1.), camera, ray, 500, 0.01, true, false);\n    \n    if(best_res.zero)\n    {\n        params.best_t = best_res.adam.t;\n    }\n    else\n    {\n        params.best_t = -1.;\n    }\n    \n    /*if(abs(R(transpose(mat2x3(camera + params.best_t * ray, ray))).x) > zero_threshold)\n    {\n        params.best_t = -1.;\n    }*/\n    \n    /////////////////////////////////////////////////////\n    \n    \n    int iterations = 10;\n    \n    while(0 <= iterations)\n    {\n        CastResult res = cast_ray(params, camera, ray, iterations);\n        iterations = res.iterations;\n        params.adam = res.adam;\n\n        if(res.out_of_range || res.local_min || res.zero)\n        {\n            if(res.zero)\n            {\n                params.best_t = params.adam.t;  // = res.t\n            }\n\n            params.adam.m = 0.;\n            params.adam.v = 0.;\n\n            float rand = RAND();\n            \n            \n            //if(!res.zero)  // If fail\n            \n            \n\n            bool set_t = true;\n\n            #if 1\n            \n            if(!res.zero) \n            {\n                for(int lod = 0; 0 <= lod && lod <= 4; lod++)\n                {\n                    float other_best_t = neighbors_best_t(coord, rand_shift(rand, 5., false), lod);\n                    //other_best_t += 2. * (rand - 0.5);\n\n                    if(0. <= other_best_t && (other_best_t < params.best_t || params.best_t < 0.))\n                    {\n                        params.adam.t = other_best_t;\n\n                        set_t = false;\n                        break;\n                    }\n                }\n            }\n\n            #endif\n            \n            #if 0\n            \n            \n            float other_best_t = -1.;\n            if(0. < uv.x)\n            {\n                other_best_t = neighbors_best_t(coord, rand_shift(rand, 2., true), 3);\n            }\n            else\n            {\n                CastParams other = accessState(coord + rand_shift(rand, 2., false));\n                other_best_t = other.best_t;\n            }\n            //other_best_t += 2. * (rand - 0.5);\n\n            if(0. <= other_best_t && (other_best_t < params.best_t || params.best_t < 0.))\n            {\n                params.adam.t = other_best_t;\n\n                set_t = false;\n                break;\n            }\n            \n            #endif\n            \n            if(set_t)\n            {\n                if(params.best_t < 0.)\n                {\n                    params.adam.t = 15. * rand;\n                }\n                else\n                {\n                    params.adam.t = rand * params.best_t;\n                }\n            }\n        }\n    }\n    \n    fragColor = to_vec4(params);\n    return;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sq(x) dot(x, x)\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define cis(a) vec2(cos(a), sin(a))\n\n\nvec2 Mul(vec2 a, vec2 b) { return vec2(a.x * b.x, a.y * b.x + b.y * a.x); }\nmat2x2 Mul(vec2 a, mat2x2 b) { return mat2x2(Mul(a, b[0]), Mul(a, b[1])); }\nvec2 Sq(vec2 a) { return vec2(sq(a.x), 2. * a.x * a.y); }\nvec2 Sqrt(vec2 a) { return vec2(sqrt(a.x), 0.5 * a.y * inversesqrt(a.x)); }\nvec2 Div(vec2 a, vec2 b) { return vec2(a.x / b.x, (a.y * b.x - b.y * a.x) / sq(b.x)); }\nmat2x2 Div(mat2x2 a, vec2 b) { return mat2x2(Div(a[0], b), Div(a[1], b)); }\nmat4x2 Div(mat4x2 a, vec2 b) { return mat4x2(Div(a[0], b), Div(a[1], b), Div(a[2], b), Div(a[3], b)); }\nvec2 Exp(vec2 a) { return exp(a.x) * vec2(1., a.y); }\nvec2 Log(vec2 a) { return vec2(log(a.x), a.y / a.x); }\n\n\n// Complex:\nvec2 mul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\nmat2x2 Mul(mat2x2 a, mat2x2 b)\n{\n    return mat2x2(Mul(a[0], b[0]) - Mul(a[1], b[1]), Mul(a[0], b[1]) + Mul(a[1], b[0]));\n}\nmat2x2 Sq(mat2x2 z) { return mat2x2(Sq(z[0]) - Sq(z[1]), 2. * Mul(z[0], z[1])); }\nvec2 AbsSq(mat2x2 z) { return Sq(z[0]) + Sq(z[1]); }\nmat2x2 Conj(mat2x2 z) { return matrixCompMult(z, mat2x2(vec2(1.), vec2(-1.))); }\nmat2x2 Inverse(mat2x2 z) { return Div(Conj(z), AbsSq(z)); }\nmat2x2 Div(mat2x2 a, mat2x2 b) { return Mul(a, Inverse(b)); }\nvec2 Abs(mat2x2 z) { return Sqrt(AbsSq(z)); }\nmat2x2 Normalize(mat2x2 z) { return Div(z, Abs(z)); }\nmat2x2 Cis(vec2 a)\n{\n    return mat2x2(cos(a.x), -sin(a.x) * a.y,\n                  sin(a.x), cos(a.x) * a.y);\n}\nvec2 Atan(mat2x2 z)\n{\n    // (-y*x' + x*y') / (x**2 + y**2)\n    return vec2(atan(z[1].x, z[0].x), dot(vec2(-z[1].x, z[0].x), vec2(z[0].y, z[1].y)) / (sq(z[0].x) + sq(z[1].x)));\n}\nmat2x2 Exp(mat2x2 z) { return Mul(Exp(z[0]), Cis(z[1])); }\nmat2x2 Log(mat2x2 z) { return mat2x2(0.5 * Log(AbsSq(z)), Atan(z)); }\nmat2x2 Pow(mat2x2 z, float n)  { return Exp(    n * Log(z)); }\nmat2x2 Pow(mat2x2 z, vec2 n)   { return Exp(Mul(n, Log(z))); }\nmat2x2 Pow(mat2x2 z, mat2x2 n) { return Exp(Mul(n, Log(z))); }\n\n\n#define c(x) vec2(x, 0)\n\n#define SPACE 32\n#define ZERO 48\n\nvec2 R4(mat4x2 p, float t, sampler2D keys)\n{\n    mat2x2 z = mat2x2(p[0], p[1]);  // Complex\n    mat2x2 w = mat2x2(p[2], p[3]);  // Complex\n    \n    float period = 12.;\n    \n    float p_param = 4.;\n    float q_param = 4.;\n    \n    if(texelFetch(keys, ivec2(ZERO + 1, 2), 0).x > 0.)\n    {\n        p_param = 5.;\n        q_param = 3.;\n    }\n    else if(texelFetch(keys, ivec2(ZERO + 2, 2), 0).x > 0.)\n    {\n        p_param = 3.;\n        q_param = 5.;\n    }\n    else if(texelFetch(keys, ivec2(ZERO + 3, 2), 0).x > 0.)\n    {\n        p_param = 3.;\n        q_param = 2.;\n    }\n    \n        \n    mat2x2 pol = Pow(w, p_param) + Pow(z, q_param);  // Complex\n    \n    float angle = (0.5 * sin(TWO_PI / period * round(t)) + 1.) * PI;\n    angle = mix(PI, angle, texelFetch(keys, ivec2(SPACE, 2), 0).x);\n    \n    return AbsSq(Normalize(pol) - mat2x2(c(cos(angle)), c(sin(angle))));\n}\n\n#define R(p, t) _R(p, t, iChannel2)\nvec2 _R(mat3x2 p, float t, sampler2D keys)  // R(p) == 0\n{\n    //return Sq(p[2]) + Sq(Sqrt(Sq(p[0]) + Sq(p[1])) - c(1.)) - c(sq(0.5));\n    \n    vec2 s = Sq(p[0]) + Sq(p[1]) + Sq(p[2]);\n    \n    return R4(Div(mat4x2(s - c(1.), 2.*p[2], 2.*p[0], 2.*p[1]), s + c(1.)), t, keys);\n}\n\n#define GLOBALS  \\\n    vec2 rots = vec2(-1, 1) * 2. * PI * iMouse.xy / iResolution.xy;  \\\n      \\\n    vec3 forward = vec3(cos(rots.y) * vec2(cos(rots.x), sin(rots.x)), sin(rots.y));  \\\n    vec3 right = vec3(-sin(rots.x), cos(rots.x), 0);  \\\n    vec3 up = cross(forward, right);  \\\n      \\\n    vec3 camera = -10. * forward;  \\\n      \\\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);  \\\n      \\\n    float zoom = 1.;  \\\n    vec3 ray = mat3x3(right, up, forward) * vec3(uv, zoom);  \\\n    ray = normalize(ray);\n\n\n////// Hash functions from https://www.shadertoy.com/view/4djSRW //////\n// Copyright (c)2014 David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n///////////////////////////////////////////////////////////////////////\n\n#define RAND() hash13(vec3(fragCoord.xy, iTime*.3) + iTime * 500. + 50.0)\n\n\n\n\nstruct AdamParams\n{\n    float t;\n    float m;\n    float v;\n};\n\nstruct CastParams\n{\n    AdamParams adam;\n    float best_t;\n};\n\n// Format:\n//     vec4(t, m, v, best_t);\nvec4 to_vec4(CastParams params)\n{ \n    return vec4(params.adam.t, params.adam.m, params.adam.v, params.best_t);\n}\nCastParams to_params(vec4 state)\n{\n    return CastParams(AdamParams(state.x, state.y, state.z), state.w);\n}\n\n#define accessState(coord) to_params(texelFetch(iChannel0, coord, 0));\n\n#define MIN 0\n#define AVG 1\n#define NEIGHBORS_BEST_TYPE MIN\n#define L_EXP 30.\n\n\n#define neighbors_best_t(coord, shift, lod) _neighbors_best_t(coord, shift, lod, iChannel1)\n\nfloat _neighbors_best_t(ivec2 coord, ivec2 shift, int lod, sampler2D iChannel1)\n{\n    int two_to_lod = (1 << lod);\n\n    vec4 state = texelFetch(iChannel1, (coord - two_to_lod / 2) / two_to_lod + shift, lod);\n    \n    state *= sq(float(two_to_lod));\n    \n    float sum = state.x;\n    float count = state.y;\n    \n    #if NEIGHBORS_BEST_TYPE == AVG\n    \n    if(count < 0.5) return -1.;\n    sum /= count;\n    return sum;\n    \n    #else\n    \n    if(0. < sum) return pow(sum, 1. / L_EXP);\n    else return -1.;\n        \n    #endif\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    CastParams params = accessState(ivec2(fragCoord));\n    \n    if(0. <= params.best_t)\n    {\n        #if NEIGHBORS_BEST_TYPE == AVG\n        fragColor = vec4(params.best_t, 1., 0., 0.);\n        #else\n        fragColor = vec4(pow(params.best_t, L_EXP), 1., 0., 0.);\n        #endif\n    }\n    else\n    {\n        fragColor = vec4(0.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 387], [389, 389, 446, 446, 1085]], "test": "untested"}
{"id": "NddSRn", "name": "Sinusoidal Warp (SH)", "author": "ShadyHeadstash", "description": "Sinusoidal warp, sans-bump map.", "tags": ["specular", "warp", "bump", "sinusoidal"], "likes": 7, "viewed": 344, "published": 3, "date": "1632498438", "time_retrieved": "2024-07-30T18:59:31.281049", "image_code": "// --- Original \"Bumped Sinusoidal Warp\" shader by Shane from https://www.shadertoy.com/view/4l2XWK\n// Modified by Mikael Ems (Shady Headstash)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define brightness 0.5\n#define refraction 0.4\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p+3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos( p.yx*3. + vec2(t,1.57))/3.;\n        p += sin( p.yx + t + vec2(1.57,0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p +=  fract(sin(p+vec2(13, 7))*5e5)*.03-.015;\n\n    return mod(p,2.)-1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    // Texture lookup.\n    vec2 tu = W(u);\n\n    u += vec2(0.) * 0.25;\n    fragColor.w = length(W(u));\n    //fragColor = texture(iChannel0, u + tu*refraction);\n    //fragColor = (vec4(.7, .4, .1, 1) * pow(max((fragColor.w-length(W(u - .01))), 0.)*8. + 1., 4.)*.1 + .5)*fragColor.w;\n\n    // Shading.\n    float c = (1.0-length(tu));\n    c *= sqrt(c);\n    c = pow(c, 1.1-brightness);\n\n\n    // Texture color.\n    fragColor = vec4(c) * texture(iChannel0, u + tu*(refraction*0.1));\n    //fragColor = smoothstep(.05, .5, fragColor*fragColor);\n\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSRn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[279, 446, 461, 461, 892], [894, 894, 950, 977, 1572]], "test": "untested"}
{"id": "fdtSRn", "name": "XY Chromaticity Diagram(CIE1964)", "author": "mosan_hoshi", "description": "CIE (1964) 10-deg chromaticity coordinates.\n[When Left Image Clicked] Displaying clicked pixel color on XY Chromaticity Diagram.\n[When Right Diagram Clicked] Fill the left image area with yellow\n(Triangle is sRGB color space)", "tags": ["2d", "color", "static", "cie"], "likes": 9, "viewed": 412, "published": 3, "date": "1632495948", "time_retrieved": "2024-07-30T18:59:32.255444", "image_code": "// writen by mossan-hoshi\n//// twitter : https://twitter.com/mossan_hoshi\n//// GitHub : https://github.com/mossan-hoshi/\n//// ShaderToy : https://www.shadertoy.com/user/mosan_hoshi\n\n\n#define MARGIN 0.05\n#define TILE_WIDTH ((1. - 3. * MARGIN) / 2.)\n#define TILE_HEIGHT TILE_WIDTH\n#define RIGHT_START  vec2(MARGIN * 2. + TILE_WIDTH,MARGIN)\n#define LEFT_START  vec2(MARGIN,MARGIN)\n#define TEXTURE_ASPECT_RATIO (iChannelResolution[0].y / iChannelResolution[0].x)\n#define INSIDE_CIRCLE_RADIUS 0.003\n#define OUTSIDE_CIRCLE_RADIUS 0.01\n#define NEAR_COLOR_DISTANCE 0.02\n#define GAMMA_VALUE 2.2\n\nvec3 xy2Rgb(vec2 xy){\n  // xyz to rgb matrix\n  // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n  vec3 xyz = vec3(xy, 1. - xy.x - xy.y);\n\n  // xyz => CIE \n  // vec3[3] matxyz2RGB = vec3[](vec3( 2.3655, -0.8971, -0.4683),\n  //                             vec3(-0.5151,  1.4264,  0.0887),\n  //                             vec3( 0.0052,  0.0144,  1.0089));\n  // xyz => sRGB\n  vec3[3] matxyz2RGB = vec3[](vec3( 3.2410, -1.5374, -0.4986),\n                              vec3(-0.9692,  1.8760,  0.0416),\n                              vec3( 0.0556, -0.2040,  1.0507));\n  vec3 rgb = vec3(dot(matxyz2RGB[0],xyz),\n                  dot(matxyz2RGB[1],xyz),\n                  dot(matxyz2RGB[2],xyz));\n  return rgb;\n}\n\nvec3 RGB2xyz(vec3 RGB){\n  // xyz to rgb matrix\n  // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n  vec3 rgb = RGB / (RGB.x + RGB.y + RGB.z);\n  \n  // CIE => xyz\n  //vec3[3] matrgb2xyz = vec3[](vec3(.4898, .3101, .2001),\n  //                            vec3(.1769, .8124, .0107),\n  //                            vec3(.0000, .0100, .9903));\n  // sRGB => xyz\n  vec3[3] matrgb2xyz = vec3[](vec3(.4124, .3576, .1805),\n                              vec3(.2126, .7152, .0722),\n                              vec3(.0193, .1192, .9505));\n  \n  vec3 xyz = vec3(dot(matrgb2xyz[0],rgb),\n                  dot(matrgb2xyz[1],rgb),\n                  dot(matrgb2xyz[2],rgb));\n  xyz = xyz / (xyz.x + xyz.y + xyz.z);\n  return xyz;\n}\n\n// vec3 sRGB2xy(vec3 rgb){\n//   // xyz to rgb matrix\n//   // http://k-ichikawa.blog.enjoy.jp/etc/HP/js/CIEXYZ2/cie3.html\n// }\n\n\nbool isInside(vec3[71] convexPoints, vec2 center, in vec2 uv){\n  int n = 71; // point num\n\n  // inside-outside check(Crossing Number Algorithm)\n  // https://edom18.hateblo.jp/entry/2018/11/28/200032\n  int crossNumber = 0;\n  for(int i=0;i<n;i+=1){\n    int i2 = (i + 1) % n;\n\n    // cross check of two lines \n    // line1: convexPoints[i]~convexPoints[i+1]\n    // line2:              uv~(1.0, uv.y))\n    // y = a * x + b\n    // dy = a * dx\n    // a = (y2-y1)/(x2-x1)\n    // dy = (uv.y -y1)\n    float a = (convexPoints[i2].y - convexPoints[i].y) / (convexPoints[i2].x - convexPoints[i].x);\n    float dy = uv.y - convexPoints[i].y;\n    float dx = dy / a;\n    float b = convexPoints[i].y - a * convexPoints[i].x;\n    // uv.y = a * x2 + b\n    float x2 = (uv.y - b) / a;\n    crossNumber += int((abs(convexPoints[i2].x - convexPoints[i].x) > .0001)&&\n     ((convexPoints[i].y > uv.y) && (convexPoints[i2].y <= uv.y)||\n     ((convexPoints[i].y <= uv.y) && (convexPoints[i2].y > uv.y)))&&\n      (uv.x <= x2));\n  }\n\n  return crossNumber == 1;\n}\n\nbool isInsideHourseShoe(vec2 uv){\n  \n  // CIE (1964) 10-deg chromaticity coordinates\n  //// http://www.cvrl.org/cie.htm\n  //// x    ,    y   ,    z   ,   wave length[nm]\n  vec3[71] horseShoe = vec3[](\n    vec3(.182218, .019978, .797804),// 360,\n    vec3(.182098, .019938, .797964),// 365,\n    vec3(.181923, .019879, .798198),// 370,\n    vec3(.181671, .019797, .798532),// 375,\n    vec3(.181333, .019685, .798982),// 380,\n    vec3(.180906, .019542, .799552),// 385,\n    vec3(.180313, .019348, .800339),// 390,\n    vec3(.179466, .019044, .801491),// 395,\n    vec3(.178387, .018711, .802902),// 400,\n    vec3(.177122, .018402, .804476),// 405,\n    vec3(.175488, .018134, .806378),// 410,\n    vec3(.173231, .017806, .808963),// 415,\n    vec3(.170634, .017849, .811517),// 420,\n    vec3(.167902, .018708, .813390),// 425,\n    vec3(.165027, .020283, .814690),// 430,\n    vec3(.162170, .022487, .815343),// 435,\n    vec3(.159022, .025725, .815253),// 440,\n    vec3(.155391, .030017, .814592),// 445,\n    vec3(.151001, .036439, .812560),// 450,\n    vec3(.145945, .045217, .808838),// 455,\n    vec3(.138922, .058920, .802158),// 460,\n    vec3(.129520, .077870, .792610),// 465,\n    vec3(.115180, .109040, .775780),// 470,\n    vec3(.095732, .159090, .745178),// 475,\n    vec3(.072777, .229239, .697984),// 480,\n    vec3(.045167, .327343, .627490),// 485,\n    vec3(.020987, .440113, .538900),// 490,\n    vec3(.007302, .562523, .430175),// 495,\n    vec3(.005586, .674543, .319871),// 500,\n    vec3(.021874, .752578, .225548),// 505,\n    vec3(.049540, .802302, .148157),// 510,\n    vec3(.085024, .816976, .098000),// 515,\n    vec3(.125236, .810194, .064569),// 520,\n    vec3(.166408, .792172, .041421),// 525,\n    vec3(.207057, .766282, .026661),// 530,\n    vec3(.243642, .739873, .016486),// 535,\n    vec3(.278588, .711300, .010112),// 540,\n    vec3(.313230, .681278, .005492),// 545,\n    vec3(.347296, .650090, .002614),// 550,\n    vec3(.381161, .618164, .000675),// 555,\n    vec3(.414213, .585787, .000000),// 560,\n    vec3(.446924, .553076, .000000),// 565,\n    vec3(.479038, .520962, .000000),// 570,\n    vec3(.509641, .490359, .000000),// 575,\n    vec3(.538560, .461440, .000000),// 580,\n    vec3(.565444, .434556, .000000),// 585,\n    vec3(.589960, .410040, .000000),// 590,\n    vec3(.611597, .388403, .000000),// 595,\n    vec3(.630629, .369371, .000000),// 600,\n    vec3(.647127, .352873, .000000),// 605,\n    vec3(.661224, .338776, .000000),// 610,\n    vec3(.673055, .326945, .000000),// 615,\n    vec3(.682660, .317340, .000000),// 620,\n    vec3(.689759, .310241, .000000),// 625,\n    vec3(.695483, .304517, .000000),// 630,\n    vec3(.700989, .299011, .000000),// 635,\n    vec3(.705873, .294127, .000000),// 640,\n    vec3(.710249, .289751, .000000),// 645,\n    vec3(.713713, .286287, .000000),// 650,\n    vec3(.715619, .284381, .000000),// 655,\n    vec3(.716790, .283210, .000000),// 660,\n    vec3(.717887, .282113, .000000),// 665,\n    vec3(.718732, .281268, .000000),// 670,\n    vec3(.719344, .280656, .000000),// 675,\n    vec3(.719763, .280237, .000000),// 680,\n    vec3(.720016, .279984, .000000),// 685,\n    vec3(.720160, .279840, .000000),// 690,\n    vec3(.720296, .279704, .000000),// 695,\n    vec3(.720358, .279642, .000000),// 700,\n    vec3(.720324, .279676, .000000),// 705,\n    vec3(.720227, .279773, .000000)//,// 710,\n    // Trim non convex frequency\n    // vec3(.720090, .279910, .000000),// 715,\n    // vec3(.719911, .280089, .000000),// 720,\n    // vec3(.719694, .280306, .000000),// 725,\n    // vec3(.719447, .280553, .000000),// 730,\n    // vec3(.719186, .280814, .000000),// 735,\n    // vec3(.718906, .281094, .000000),// 740,\n    // vec3(.718609, .281391, .000000),// 745,\n    // vec3(.718292, .281708, .000000),// 750,\n    // vec3(.717959, .282041, .000000),// 755,\n    // vec3(.717607, .282393, .000000),// 760,\n    // vec3(.717240, .282760, .000000),// 765,\n    // vec3(.716859, .283141, .000000),// 770,\n    // vec3(.716464, .283536, .000000),// 775,\n    // vec3(.716057, .283943, .000000),// 780,\n    // vec3(.715637, .284363, .000000),// 785,\n    // vec3(.715208, .284792, .000000),// 790,\n    // vec3(.714770, .285230, .000000),// 795,\n    // vec3(.714325, .285675, .000000),// 800,\n    // vec3(.713872, .286128, .000000),// 805,\n    // vec3(.713411, .286589, .000000),// 810,\n    // vec3(.712943, .287057, .000000),// 815,\n    // vec3(.712471, .287529, .000000),// 820,\n    // vec3(.711999, .288001, .000000),// 825,\n    // vec3(.711523, .288477, .000000) // 830,\n  );\n  \n  vec2 whitePoint = vec2(0.3333,0.3333);\n\n  return isInside(horseShoe, whitePoint, uv);\n}\n\n\nvec3 deGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n rgb = vec3(pow(rgb.x, GAMMA_VALUE),pow(rgb.y, GAMMA_VALUE),pow(rgb.z, GAMMA_VALUE));\n return rgb;\n}\n\n\nvec3 displayGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n  vec3 val1 = 12.92 * rgb;\n  vec3 val2 = vec3(pow(rgb.x, 1. / 2.4),pow(rgb.y, 1. / 2.4),pow(rgb.z, 1. / 2.4)) * 1.055 - .055;\n  return (1. - step(.0031308,rgb)) * val1 + step(.0031308,rgb) * val2;\n}\n\nvec3 drawXYChromaticityDiagram(in vec2 uv){\n\n\n  vec3 rgb = xy2Rgb(uv);\n  float rgbSum = uv.x + uv.y;\n  rgbSum = 1. - step(1., rgbSum);\n\n  // display gamma\n  rgb = displayGamma(rgb * rgbSum);\n  rgb = step(.01,float(isInsideHourseShoe(uv))) * rgb;\n  return rgb;\n}\n\nfloat errorCheckUV(vec2 checkUV){\n  return float((checkUV.x < .0)||(checkUV.y < .0)||(checkUV.x > 1.)||(checkUV.y > 1.));\n}\n\nvec2 errorCheckUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckUV(checkUV);\n  return step(0.1,errorFlg) * (-1.,-1.) + (1. - step(.1,errorFlg)) * returnUV;\n}\n\nvec2 uv2LeftUV(vec2 uv){\n  vec2 leftUV = vec2((uv.x - LEFT_START.x)/ TILE_WIDTH,(uv.y - LEFT_START.y)/ TILE_HEIGHT);\n  leftUV.y = leftUV.y / TEXTURE_ASPECT_RATIO;\n  return errorCheckUV(uv, leftUV);\n}\n\nvec2 normalizeLeftUV(vec2 leftUV){\n  vec2 normalizedLeftUV = leftUV;\n  normalizedLeftUV.y = normalizedLeftUV.y * TEXTURE_ASPECT_RATIO;\n  return errorCheckUV(leftUV, normalizedLeftUV);\n}\n\nvec2 leftUV2uv(vec2 leftUV){\n  vec2 uv = vec2((leftUV.x * TILE_WIDTH + LEFT_START.x) ,(leftUV.y * TILE_HEIGHT + LEFT_START.y) );\n  return errorCheckUV(uv, leftUV);\n}\n\nvec2 uv2RightUV(vec2 uv){\n  vec2 rightUV = vec2((uv.x - RIGHT_START.x)/ TILE_WIDTH,(uv.y - RIGHT_START.y)/ TILE_HEIGHT);\n  return errorCheckUV(uv, rightUV);\n}\n\nvec2 rightUV2uv(vec2 rightUV){\n  vec2 gainedRightUV = vec2(rightUV.x * TILE_WIDTH,rightUV.y * TILE_HEIGHT);\n  vec2 uv = vec2((gainedRightUV.x + RIGHT_START.x) ,(gainedRightUV.y + RIGHT_START.y) );\n  return errorCheckUV(rightUV, uv);\n}\n\nfloat lineMask(vec2 uv, vec2 linePoint1,vec2 linePoint2, float threshold){\n  // rotate line to y-axis\n  vec2 v1 = (linePoint1 - linePoint2);\n  float lineLength = sqrt(dot(v1,v1));\n  v1 = v1 / lineLength;\n  float theta = atan(v1.x, v1.y);\n  vec2[2] rotateMat = vec2[](\n    vec2(cos(theta), -sin(theta)),\n    vec2(sin(theta),  cos(theta))\n  );\n  vec2 rotatedUV = vec2((dot(rotateMat[0], (uv - linePoint2))),\n                        (dot(rotateMat[1], (uv - linePoint2))));\n  return float(\n               (abs(rotatedUV.x ) < threshold)&&\n               (rotatedUV.y       > -threshold)&&\n               (rotatedUV.y       < lineLength + threshold)\n               );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // normalize position(x,y:.0~1.0)\n  vec2 uv = fragCoord.xy/ iResolution.x;\n  vec4 m = iMouse / iResolution.x;\n\n  // get local positions\n  vec2 leftUV = uv2LeftUV(uv);\n  vec2 normalizedLeftUV = normalizeLeftUV(leftUV);\n  vec2 leftMouseUV = uv2LeftUV(m.xy);\n  vec2 normalizedMouseLeftUV = normalizeLeftUV(leftMouseUV);\n  vec2 rightMouseUV = uv2RightUV(m.xy);\n  float leftMouseMask = errorCheckUV(leftMouseUV);\n  vec2 rightUV = uv2RightUV(uv);\n\n  // draw XY Chromaticity Diagram\n  vec3 rgbXY = drawXYChromaticityDiagram(rightUV);\n  \n  // draw left side(image(iChannel0))\n  vec3 rgbImage = texture(iChannel0, clamp(leftUV,0.,1.)).xyz;\n  float leftImageMask = float((leftUV.x >= .0)&&(leftUV.y >= .0)&&(leftUV.x <= 1.)&&(leftUV.y <= 1.));\n  vec3 rgb = max((leftImageMask * rgbImage) , ((1. - leftImageMask) * rgbXY));\n\n  // draw left mouse cursol\n  float validLeftMouseFlg = 1. - errorCheckUV(normalizedMouseLeftUV);\n  float nearLeftMouseFlg = validLeftMouseFlg * float((distance(m.xy, uv) > INSIDE_CIRCLE_RADIUS)&&\n                                                     (distance(m.xy, uv) < OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearLeftMouseFlg * vec3(1., 1., .0) + (1. - nearLeftMouseFlg) * rgb;\n  //// draw right cursol\n  vec2 rightPos = (1. - leftMouseMask) * rightUV2uv(RGB2xyz(deGamma(texture(iChannel0, leftMouseUV).xyz)).xy) + \n                  leftMouseMask * (0.5, 0.5);\n  float nearRightFlg = validLeftMouseFlg * float((distance(rightPos,uv)>INSIDE_CIRCLE_RADIUS)&&\n                                  (distance(rightPos,uv)< OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearRightFlg * vec3(1., 1., .0) + (1. - nearRightFlg) * rgb;\n\n  // draw right mouse cursol\n  float validRightMouseFlg = 1. - max(errorCheckUV(rightMouseUV), float(!isInsideHourseShoe(rightMouseUV)));\n  float nearRightMouseFlg = validRightMouseFlg * float((distance(rightUV2uv(rightMouseUV),uv)>INSIDE_CIRCLE_RADIUS)&&\n                                  (distance(rightUV2uv(rightMouseUV),uv)< OUTSIDE_CIRCLE_RADIUS));\n  rgb = nearRightMouseFlg * vec3(1.,1.,0.) + (1. - nearRightMouseFlg) * rgb;\n  //// Fill the left image area with yellow, the same color as the clicked position in the XY diagram on the right.\n  float nearColorFlg = leftImageMask * float(distance(RGB2xyz(deGamma(texture(iChannel0, leftUV).xyz)).xy,rightMouseUV) < NEAR_COLOR_DISTANCE);\n  rgb = nearColorFlg * vec3(1.,1.,0.) + (1. - nearColorFlg) * rgb;\n  \n\n  // draw grid\n  float nearGridFlg = (1. -errorCheckUV(rightUV)) * float(((abs(mod(rightUV.x, .1)) < .004)||(abs(mod(rightUV.y, .1)) < .004)));\n  rgb = nearGridFlg * vec3(1.,1.,1.) + (1. - nearGridFlg) * rgb;\n  \n  \n  // draw sRGB triangle\n  //// https://en.wikipedia.org/wiki/SRGB\n  vec2 sRGBxyR = vec2(.64, .33);\n  vec2 sRGBxyB = vec2(.33, .6);\n  vec2 sRGBxyG = vec2(.15, .06);\n  float nearTriangleFlg = lineMask(rightUV, sRGBxyR,sRGBxyB, .002)+\n                          lineMask(rightUV, sRGBxyB,sRGBxyG, .002)+\n                          lineMask(rightUV, sRGBxyG,sRGBxyR, .002);\n  rgb = nearTriangleFlg * vec3(.0, .0, .0) + (1. - nearTriangleFlg) * rgb;\n\n\n  fragColor=vec4(rgb, 1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7785, 7785, 7809, 7945, 8046], [8049, 8049, 8078, 8214, 8413], [8415, 8415, 8458, 8458, 8676], [8678, 8678, 8711, 8711, 8801], [8803, 8803, 8850, 8850, 8973], [8975, 8975, 8999, 8999, 9174], [9176, 9176, 9210, 9210, 9361], [9363, 9363, 9391, 9391, 9528], [9530, 9530, 9555, 9555, 9688], [9690, 9690, 9720, 9720, 9924], [10594, 10594, 10650, 10686, 13725]], "test": "untested"}
{"id": "sscXzr", "name": "basic mesh -3d", "author": "jorge2017a2", "description": "basic mesh -3d", "tags": ["basicmesh3d"], "likes": 2, "viewed": 215, "published": 3, "date": "1632494684", "time_retrieved": "2024-07-30T18:59:33.019401", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{   float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n     q = mat2(d.x,-d.y,d.y,d.x)*q;\n     q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat lineas(vec2 p)\n{   float mind=9999.9;\n    vec2 p2= rotatev2(p, radians(90.0));\n    float paso=0.5;//0.125\n    float rangox=3.5;\n    for(float i=-rangox; i<rangox; i+=paso)\n    {   float sds1=sdOrientedBox(p-vec2(-0.5+i,-0.5), vec2(-2.0,-2.0) ,vec2(3.0,3.0), 0.05 );\n        mind=unionSDF(mind,sds1);\n    } \n    \n    for(float i=-rangox; i<rangox; i+=paso)\n    {   float sds2=sdOrientedBox(p2-vec2(-0.5+i,-0.5), vec2(-2.0,-2.0), vec2(3.0,3.0), 0.05 );\n        mind=unionSDF(mind,sds2);\n    } \n    return mind;\n}\n\nfloat opScaleLineas( in vec2 p)\n{   float s=10.0;\n    float res =lineas(p/s)*s;\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.y=p.y-5.0;\n    float l1= opScaleLineas(p.xy);\n    float d1= sdBox( p, vec3(20.0,20.0,3.0) );\n    float sint1= intersectSDF(d1, l1);\n    \n    float l2= opScaleLineas(p.xy);\n    float d2= sdBox( p-vec3(0.0,0.0,10.0), vec3(20.0,20.0,1.0) );\n    float sint2= intersectSDF(d2, l2);\n   \n   res =opU3(res, vec3(sint1,100.0,-1.0));\n    res =opU3(res, vec3(sint2,2.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    return color;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\t}\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-20.0+5.0*sin(t));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n///--------------------------------------------FIN\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) return Arrcolores[i];\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 529, 529, 613], [614, 658, 705, 705, 732], [733, 733, 776, 776, 803], [804, 804, 852, 852, 880], [881, 921, 955, 955, 1050], [1052, 1052, 1118, 1118, 1323], [1325, 1325, 1347, 1347, 1841], [1843, 1843, 1876, 1876, 1940], [1942, 1942, 1967, 1967, 2449], [2451, 2451, 2475, 2475, 2637], [2639, 2639, 2688, 2688, 3314], [3316, 3316, 3352, 3352, 3597], [3599, 3599, 3626, 3626, 3643], [3645, 3645, 3681, 3681, 3773], [3774, 3774, 3820, 3820, 3945], [3947, 3947, 3984, 3984, 4260], [4262, 4262, 4345, 4345, 4924], [4926, 4926, 4975, 4975, 5214], [5216, 5216, 5309, 5309, 5439], [5441, 5441, 5473, 5473, 5670], [5672, 5720, 5748, 5748, 5936], [5938, 5938, 6031, 6031, 6347], [6349, 6349, 6380, 6380, 6979], [6981, 6981, 7007, 7007, 7117], [7119, 7119, 7177, 7177, 7229], [7231, 7231, 7288, 7288, 7793]], "test": "untested"}
{"id": "fscSzn", "name": "Second Reality Inspired Effect", "author": "ohanegby", "description": "This is an effect inspired by the demo Second Reality\n\nby Ori Hanegby\n", "tags": ["effect", "opticalillusion", "perception", "secondreality"], "likes": 5, "viewed": 349, "published": 3, "date": "1632466037", "time_retrieved": "2024-07-30T18:59:33.850180", "image_code": "// Second Reality inspired effect\n// By Ori Hanegby\n\n#define PI 3.14159265\nfloat map(vec2 uv, float angle, float dist) {\n    float newX = uv.x*cos(angle) - uv.y*sin(angle);\n    return sin((newX - dist/2.)*dist)> 0. ? 1. : 0.;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n    float angle = iTime*8.;\n    float aLag = (PI/4.) * sin(iTime*0.7);\n    float c=0.;\n\n    for (int i=0; i<4; i++) {\n        angle += aLag;\n        c+=map(uv, angle, 25.)*0.2;\n    }\n    \n    vec3 col = vec3(c); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 120, 120, 229], [231, 231, 288, 288, 596]], "test": "untested"}
{"id": "NdyGWc", "name": "Luminance spectra sampling", "author": "copperbotte", "description": "Uses importance sampling / inverse transform sampling to estimate human luminance frequency response. (CIE XYZ's Y coordinate)\n\nBlends two sampled states using a transformed bezier curve.", "tags": ["color", "physics", "statistics"], "likes": 3, "viewed": 295, "published": 3, "date": "1632461515", "time_retrieved": "2024-07-30T18:59:34.630095", "image_code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// CIE 1931 Color matching function approximation\n// Y is used as a luma curve\n// https://en.wikipedia.org/wiki/CIE_1931_color_space#Color_matching_functions\n\n// piecewise gaussian\nfloat p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\n// CIE 1931 standard observer\nvec3 spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    X  = p_gauss(wavelength_nm, 1.056, 599.8, 37.9, 31.0);\n    X += p_gauss(wavelength_nm, 0.362, 442.0, 16.0, 26.7);\n    X += p_gauss(wavelength_nm,-0.065, 501.1, 20.4, 26.2);\n\n    Y  = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    Z  = p_gauss(wavelength_nm, 1.217, 437.0, 11.8, 36.0);\n    Z += p_gauss(wavelength_nm, 0.681, 459.0, 26.0, 13.8);\n    \n    return vec3(X, Y, Z);\n}\n\n// close enough\n// an unbiased importance sampler would divide the pdf of gaussian\n//     to the pdf of the integrated, shifted atanh. The max\n//     absolute error between erf(x) and tanh(x / (sqrt(pi)/2) is\n//     around 0.035. This implies that the inverse tanh function\n//     is a pretty good approximation of erf(x), when scaled.\n//\n// This function is no longer used, as euler's gassian integral works instead. However, its still interesting nonetheless\nfloat erfinv(float x)\n{\n    return atanh(x) * sqrt(3.141592) / 2.0;\n}\n\n// Performs an importance sample of the luminance spectra\nfloat isample_luma()\n{\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    \n    // normalized distribution sample\n    vec4 Lum = vec4(0.0);\n    Lum[0] = 0.821 * 46.9 * sqpi_2;\n    Lum[1] = 0.821 * 40.5 * sqpi_2;\n    Lum[2] = 0.286 * 16.3 * sqpi_2;\n    Lum[3] = 0.286 * 31.1 * sqpi_2;\n    \n    vec4 csum = vec4(0.0);\n    csum[0] = Lum[0];\n    csum[1] = csum[0] + Lum[1];\n    csum[2] = csum[1] + Lum[2];\n    csum[3] = csum[2] + Lum[3];\n    \n    float weight = rnd() * csum[3];\n    int i=0;\n    for(; i<4; ++i)\n    {\n        if(weight <= csum[i])\n            break;\n    }\n    \n    // from the given selection, inverse sample the distribution\n    vec4 mus = vec4(568.8, 568.8, 530.9, 530.9);\n    vec4 sigmas = vec4(-46.9, 40.5, -16.3, 31.1);\n    \n    vec2 xi = vec2(rnd(), rnd());\n    float r = sqrt(-2.0*log(1.0 - xi.x)) * sin(xi.y * 3.141592);\n    return r*sigmas[i] + mus[i];\n}\n\nfloat pdf_luma(float wavelength_nm)\n{\n    // Find the normalized luminance for this frequency\n    //norm = 106.9224850198325\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    const float norm = (0.821 * (46.9 + 40.5) + 0.286 * (16.3 + 31.1)) * sqpi_2;\n\n    float Y = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    return Y / norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect ratio adjusted coordinates\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.y *= iResolution.y/iResolution.x;\n    xy = (xy + 1.0) / 2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Luminance curve\n    float nm = mix(350.0, 850.0, xy.x);\n    float luma = spectra_to_XYZ(nm).y;\n    \n    // re-scale nm to xy coords\n    vec2 pt = vec2(nm, luma);\n    pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n    pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n    \n    // color the curve\n    if(xy.y < pt.y)\n        col = mix(col, vec3(0.0), 0.66);\n    if(length(pt - xy) < 0.005)\n        col *= 0.0;\n    \n    // Generate 512 samples using a standard key\n    const int pt_count = 512;\n    const float dt = 4.0;\n    \n    //const int pt_count = 16;\n    //const float dt = 0.4;\n    \n    \n    const bool isample_each_frame = false;\n    if(isample_each_frame)\n    {\n        seed = iTime;\n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            vec2 pt = vec2(nm, pct);\n\n            // re-scale into xy coords\n            float luma = spectra_to_XYZ(nm).y;\n            pt.y *= luma;\n\n            pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n            pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n\n            if(length(pt - xy) < 0.002)\n                col = wavelength_to_srgb(nm);\n        }\n    }\n    else\n    {\n        seed = float(int(iTime / dt)) * dt;\n        vec2 points[pt_count];\n        //points have the unit of (nm, pct)\n        \n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            points[i] = vec2(nm, pct);\n        }\n\n        // Generate a second set of points to blend \n        seed = float(int(iTime / dt) + 1) * dt;\n        vec2 points_dst[pt_count];\n\n        for(int i=0; i<pt_count; ++i)\n        {\n            float nm = isample_luma();\n            float pct = rnd();\n            points_dst[i] = vec2(nm, pct);\n        }\n\n        // Blend points and render using sdf\n        for(int i=0; i<pt_count; ++i)\n        {\n            float t = mod(iTime, dt) / dt;\n\n            // adds a delay at the end of each cycle\n            t = (t - 0.1) / (0.9 - 0.1);\n            t = clamp(t, 0.0, 1.0);\n\n            // Function-bounded Bezier mix\n            vec2 pt0 = points[i];\n            vec2 pt1 = points_dst[i];\n\n            // Lerp mix\n            //vec2 pt = mix(pt0, pt1, t);\n\n            // Bezier mix\n            vec2 d_pt = pt1 - pt0;\n            vec2 pt = pt0 + t*t*(3.0*d_pt - 2.0*t*d_pt);\n\n            // re-scale into xy coords\n            float nm = pt.x;\n            float luma = spectra_to_XYZ(nm).y;\n            pt.y *= luma;\n\n            pt.y = mix(0.25, 0.75, pt.y); // re-scale into xy coords\n            pt.x = (pt.x - 350.0) / (850.0 - 350.0); // inverse lerp into xy coords\n\n            if(length(pt - xy) < 0.002)\n                col = wavelength_to_srgb(nm);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\n// Color space transforms are hidden away in common for clarity of isample\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 XYZ_to_lsrgb(vec3 XYZ)\n{\n    mat3 tolsrgb = transpose(mat3( 3.2406,-1.5372,-0.4986,\n                                  -0.9689, 1.8758, 0.0415,\n                                   0.0557,-0.2040, 1.0570));\n    return tolsrgb * XYZ;\n}\n\n// this is a copy of the function used in main, to avoid a redefinition.\n// its used for the convinience funciton wavelength_to_srgb below.\nfloat _p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\nvec3 _spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    float ang = wavelength_nm * 10.0;\n    X  = _p_gauss(ang, 1.056, 5998.0, 379.0, 310.0);\n    X += _p_gauss(ang, 0.362, 4420.0, 160.0, 267.0);\n    X += _p_gauss(ang,-0.065, 5011.0, 204.0, 262.0);\n\n    Y  = _p_gauss(ang, 0.821, 5688.0, 469.0, 405.0);\n    Y += _p_gauss(ang, 0.286, 5309.0, 163.0, 311.0);\n\n    Z  = _p_gauss(ang, 1.217, 4370.0, 118.0, 360.0);\n    Z += _p_gauss(ang, 0.681, 4590.0, 260.0, 138.0);\n    \n    return vec3(X, Y, Z);\n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        //hsv.yz /= hsv.z;\n        hsv.z /= hsv.z;\n    \n    if(1.0 < hsv.y)\n        //hsv.yz /= hsv.z;\n        hsv.y /= hsv.y;\n    \n    return hsv2rgb(hsv);\n}\n\nvec3 wavelength_to_srgb(float wavelength)\n{\n    vec3 XYZ = _spectra_to_XYZ(wavelength);\n    vec3 lsrgb = XYZ_to_lsrgb(XYZ);\n    \n    //lsrgb is apparently clipped here? this feels off, like it should be projected instead\n    //https://photo.stackexchange.com/questions/67990/what-should-i-do-with-negative-values-when-computing-srgb-colors-from-spectra\n    lsrgb = clamp(lsrgb, vec3(0.0), vec3(1.0));\n    \n    return lsrgb2srgb(lsrgb);\n}\n\nfloat plancks_law(float wavelength_nm, float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    float m = wavelength_nm * 1.0e-9;\n    float m2 = m*m;\n\n    float Rayleigh_Jeans = 2.0*h*c*c/(m2*m2*m);\n    float quantum_temp_ratio = h*c/(k*m*temperature);\n    float Wien = exp(quantum_temp_ratio) - 1.0;\n    \n    return Rayleigh_Jeans / Wien;\n}\n\nfloat plancks_law_max(float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    // dPlanck / dlambda = 0\n    // (hc/lkT) / (1-exp(-hc/lkT)) = 5\n    // x = hc/lkT\n    // x / (1-exp(-x) = 5\n    // x = 5 - 5exp(-x)\n    // 0 = 5 + (x-5)exp(x)\n    // -5exp(-5) = (x-5)exp(x-5)\n    // W(-5exp(-5)) + 5 = x\n    // 1/x is approximately 0.2014052352726422\n    // l = hc / xkT\n    return (h*c/(k*temperature)) * 0.2014052352726422;\n}\n\nfloat plancks_law_normalized(float wavelength_nm, float temperature)\n{\n    float planck = plancks_law(wavelength_nm, temperature);\n    planck /= plancks_law(plancks_law_max(temperature), temperature);\n    return planck;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 93, 106, 106, 149], [310, 332, 409, 409, 576], [578, 608, 650, 650, 1117], [1119, 1580, 1603, 1603, 1649], [1651, 1709, 1731, 1731, 2584], [2586, 2586, 2623, 2710, 2986], [2988, 2988, 3045, 3095, 6277]], "test": "untested"}
{"id": "fdKGDt", "name": "SmoothMin() neighbors in 4 taps", "author": "iY0Yi", "description": "SmoothMin() neighbors in 4 taps.\nUntil now, I thought I needed 9 taps...", "tags": ["neighbors"], "likes": 24, "viewed": 551, "published": 3, "date": "1632455929", "time_retrieved": "2024-07-30T18:59:35.653359", "image_code": "vec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float cL = 25.;\n    const vec3 forcus = vec3(0,-5,0);\n    const float fov = .5;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,5.5,0);\n    pos.xz = vec2(.7,-.7)*cL;\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// I forgot where I found these bx_cossin()...\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    #if 1\n    float rad = .2;\n    #else // animate radius. they can't move at raius 1.0.\n    float rad = abs(sin(3.14+iTime*.1))*0.9+.1;\n    #endif\n    \n    vec3 q = p;\n    q.xz = mod(q.xz,1.);\n    \n    #if 1 // Spheres.\n        q.y-= rad;\n    #else // Shrink the height. You can see more clearly the range of movement of each sphere.\n        q.y-= rad*.1;\n        q.y*=4.;\n    #endif\n    \n    float speed = 2.;\n    vec3 pm=MAT_ERNST2;\n    for(int i=-1; i<1; i++)\n    for(int j=-1; j<1; j++)\n    {\n        vec2 offset = vec2(i,j);\n        vec3 qq = q;\n        vec2 iqq = floor((p.xz-offset));\n        vec2 rnd = hash22(iqq);\n        \n        qq.xz+=offset;\n        float v =  rnd.x * iTime * speed * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(1.-rad/* max range is ±(cellSize-Radius) */);\n        qq.xz+= sq;\n        \n        //qq.y-=.25*abs(sin(rnd.x*3.+iTime*3.*4.)); // jumping. just for fun.\n        \n        #if 0 // reduce population\n        if(rnd.y<.1 || rnd.x<.1)\n        #endif\n        {\n            vec2 iq = abs(floor((p.xz-offset)));\n            iq = vec2(int(iq.x)%2, int(iq.y)%2);\n            float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n            vec3 m = (rnd.y<.5) ? (tile<.5)?MAT_ERNST0:MAT_ERNST3 : (tile<.5)?MAT_ERNST1:MAT_ERNST4;\n\n            res = v4OpUnionSmooth(vec4(length(qq)-rad, m), res, .01);\n\n            if(sat(sin(iTime*.5))>0.){\n                //pm = mix(pm,m,.5);\n                res = v4OpUnion(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -rad, sq.y), .01), m), res);\n                res = v4OpUnion(vec4(length(q+vec3(i,rad,j))-.05, m), res);\n            }\n        }\n    }\n    vec2 iq = abs(floor((p.xz)));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .85 : .85; \n    res = v4OpUnion(vec4(p.y, pm*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < 20; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 8;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv;\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l;\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n\t\tfloat shininess = .5;\n\t\tfloat intensity = .05;\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\t//renDat.ao = ambientOcclusion(p, renDat.normal, .1, 1.5);\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .5, 1.5);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 2., 4.);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 4., 8.);\n\t\trenDat.ao = smoothstep(-0.3, 1.5, renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\t#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST*3.5;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.2;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result.rgb = sms(-.01,.9,renDat.result.rgb);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 500.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(1.000,0.980,0.400)\n#define MAT_ERNST1 vec3(1.000,0.424,0.361)\n#define MAT_ERNST2 vec3(0.631,0.525,0.408)\n#define MAT_ERNST3 vec3(0.322,0.773,1.000)\n#define MAT_ERNST4 vec3(0.345,0.976,0.502)\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 118], [119, 119, 141, 141, 778], [871, 918, 938, 938, 986], [987, 987, 1011, 1011, 1041], [1043, 1043, 1095, 1095, 1216], [3181, 3181, 3198, 3198, 3487], [3489, 3489, 3510, 3636, 3847], [3849, 3849, 3878, 3878, 4165], [4167, 4315, 4346, 4346, 4449], [4450, 4450, 4494, 4494, 4590], [4591, 4591, 4674, 4674, 5072], [5074, 5146, 5160, 5160, 6895], [6897, 7000, 7012, 7012, 7551], [7553, 7625, 7679, 7679, 8116]], "test": "untested"}
{"id": "NdcSzn", "name": "Memory & Aging", "author": "chenglou", "description": "Tiny abstract art on the decay of memory and attention span from aging.\n[b]Mouse click + drag[/b]\n\nComing back to 2D and exploring how far we can take simple calculations! No fancy ray marching =)\n", "tags": ["sdf", "chromaticaberration"], "likes": 5, "viewed": 378, "published": 3, "date": "1632454494", "time_retrieved": "2024-07-30T18:59:36.415321", "image_code": "float map(vec2 uv) {\n    vec2 repeat = vec2(.5, .6);\n    vec2 modUV = mod(uv + vec2(sin(iTime) / 1.5, iTime / 3.), repeat); // split cells, move them\n    float sdCells = length(modUV - repeat / 2.) - .1;\n    vec2 mouseOffset = iMouse.z > 0. ? (2. * iMouse.xy - iResolution.xy) / iResolution.y : vec2(.0);\n    float sdCrawler = length(uv - mouseOffset) - .55;\n    return abs(clamp(sdCells / 2.5, 0., 1.) + sdCrawler / 2.); // abs gives the magic embossing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y; // y from -1 to -1\n    \n    vec3 color = vec3(map(uv - .02), vec2(map(uv + .02))); // chromatic abberation\n    color = pow(color, vec3(1./2.2)); // gamma\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 456], [458, 458, 515, 515, 774]], "test": "untested"}
{"id": "7dVGDd", "name": "Box Singularity", "author": "Tater", "description": "Can you believe I'm still not done with this subdivision thing? ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 38, "viewed": 775, "published": 3, "date": "1632452634", "time_retrieved": "2024-07-30T18:59:37.186260", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n//https://www.shadertoy.com/view/fdyGDt\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\n//No Cell bounds SDF of the blocks\nfloat nsdf = 0.;\nbool rnsdf = false;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/8.)+0.2;\n    \n    float MIN_SIZE = .2;\n    float ITERS = 12.;\n    float PAD_FACTOR = 1.05;\n    \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        // divide the box into eight\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        //Use this to remove the random divisions\n        /*\n        divHash = vec3(\n            0.49,\n            0.5,\n            0.51\n        );\n        //*/\n        vec3 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE*PAD_FACTOR , dMax - MIN_SIZE*PAD_FACTOR );\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        \n        float minSize = min( minAxis.x, min( minAxis.y, minAxis.z ) );\n        bool smallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        //if (i - 1. > MIN_ITERS && h11( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if (smallEnough && i  > 0.) { willBreak = true; }\n        if( willBreak ) {\n            break;\n        }\n    \n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        // id will be used for coloring and hash seeding\n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n\n    \n    if(any(isEdge)) {\n    \n        float expand = 1.2+0.75*(sin(length(center+100.0)*0.4+t*3.0)*0.5+0.5)*0.75;\n        //expand = 1.5; \n        if(isEdge.x){\n        dim.x+=abs(center.x*expand-center.x)*2.0;\n        center.x*=expand;\n        }\n        if(isEdge.y){\n        dim.y+=abs(center.y*expand-center.y)*2.0;\n        center.y*=expand;\n        }\n        if(isEdge.z){\n        dim.z+=abs(center.z*expand-center.z)*2.0;\n        center.z*=expand;\n        }\n        //id = 1.;\n    }\n    \n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n\n\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n\n    nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(10,10,10);\n    vec3 rd2 = rdg;\n    p.yz*=rot(t*0.5);\n    rd2.yz*=rot(t*0.5);\n    p.xy*=rot(t*0.5);\n    rd2.xy*=rot(t*0.5);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*1.3)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.55;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n   // else ro.xz*=rot(t*0.3);\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.7)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres;\n        col*=pow(ao,0.2);\n        \n    }\n    col = pow(col,vec3(0.9));\n    vec3 bg = vec3(0.698,0.710,0.878)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 402, 469, 469, 508], [509, 509, 529, 529, 600], [601, 601, 622, 622, 674], [675, 675, 701, 701, 760], [761, 774, 804, 804, 891], [893, 893, 923, 923, 1026], [1119, 1119, 1158, 1158, 4188], [4190, 4190, 4207, 4207, 4527], [4528, 4528, 4546, 4546, 4674], [4675, 4675, 4732, 4732, 6401]], "test": "untested"}
{"id": "Nd3SRn", "name": "house sphere", "author": "jorge2017a2", "description": "house sphere", "tags": ["housesphere"], "likes": 34, "viewed": 422, "published": 3, "date": "1632447318", "time_retrieved": "2024-07-30T18:59:38.134724", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 esferacut(vec3 p, float idcol, float idmat)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    float sds1=sdSphere(p, 12.0 );\n    float sds2=sdSphere(p, 10.0 );\n    \n    float sdb1= sdBox( p-vec3(-10.0,6.0,-8.0), vec3(12.0,6.0,4.5) );\n    float sdb2= sdBox( p-vec3(-7.0,7.0,-8.0), vec3(12.0,4.5,4.5) );\n    float sdb3= sdBox( p-vec3(-3.0,5.0,-8.0), vec3(2.0,7.5,4.5) );\n    float sdb4= sdBox( p-vec3(-2.0,2.0,-8.0), vec3(1.0,7.5,4.5) );\n    float sdb5= sdBox( p-vec3(0.0,7.0,5.0), vec3(5.0,8.0,8.0) );\n    float sdb6= sdBox( p-vec3(0.0,0.0,.0), vec3(15.0,5.0,2.0) );\n    \n    float dif= differenceSDF(sds1, sds2);\n    dif= differenceSDF(dif, sdb1);\n    dif= differenceSDF(dif, sdb2);\n    dif= differenceSDF(dif, sdb3);\n    dif= differenceSDF(dif, sdb4);\n    dif= differenceSDF(dif, sdb5);\n    dif= differenceSDF(dif, sdb6);\n    \n    res =opU3(res, vec3(dif,idcol,idmat));\n    \n    return res;\n}\n\nvec3 opScaleEsfera1( in vec3 p )\n{\n    float s=4.0;\n    \n    vec3 res=esferacut(p/s, 101.0,-1.0);\n    res=vec3( res.x*s, res.y, res.z);\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.y=p.y-10.0;\n    \n    float tt=iTime*36.0;\n    p= rotate_y(p, radians(tt));\n    \n    vec3 es1= esferacut(p,100.0,-1.0);\n    vec3 es2=opScaleEsfera1(p);\n    \n    res =opU3(res, es1);\n    res =opU3(res, es2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n   \n    return color;\n    \n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\t\n    float tt=iTime*36.0;\n    if (i==100 )\n    {       \n      p= rotate_y(p, radians(tt));\n      vec3 col=tex3D(iChannel0, p/16., nor); return col; \n    }\n\tif (i==101 ) \n    {\n        p= rotate_y(-p, radians(tt));\n        return tex3D(iChannel0, p/16., nor)*0.25; \n    }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nfloat random(vec2 uv) \n{ return fract(sin(dot(uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color>-1 && id_color<100 )\n\t\t{ colobj=getColor(int( id_color)); }\n     \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(30.0, -20.0, 30.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(10.0, 50.0, 20.0 ); light_color2 =vec3( 1.0 ); \n \n   vec3 ro=vec3(0.0,12.0,-35.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec2 uvP;\n    vec3 pRot;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n///--------------------------------------------FIN\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3SRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 534, 534, 555], [556, 556, 588, 588, 672], [673, 717, 764, 764, 791], [792, 792, 835, 835, 862], [863, 863, 911, 911, 939], [940, 1003, 1037, 1037, 1133], [1134, 1134, 1168, 1168, 1259], [1260, 1260, 1294, 1294, 1385], [1387, 1387, 1437, 1437, 2276], [2278, 2278, 2312, 2312, 2431], [2433, 2433, 2458, 2458, 2776], [2778, 2778, 2802, 2802, 2964], [2966, 2966, 3015, 3015, 3646], [3649, 3649, 3685, 3685, 3930], [3932, 3932, 3959, 3959, 3976], [3978, 3978, 4014, 4014, 4106], [4107, 4107, 4153, 4153, 4278], [4280, 4280, 4317, 4317, 4593], [4595, 4595, 4678, 4678, 5276], [5278, 5278, 5327, 5327, 5710], [5712, 5712, 5805, 5805, 5935], [5937, 5937, 5969, 5969, 6166], [6168, 6168, 6192, 6192, 6259], [6261, 6261, 6354, 6354, 6694], [6696, 6696, 6727, 6727, 7326], [7328, 7328, 7354, 7354, 7464], [7466, 7466, 7524, 7524, 7576], [7578, 7578, 7635, 7635, 8124]], "test": "untested"}
{"id": "7dV3Wd", "name": "Volcanic calderas", "author": "jarble", "description": "A simple volcanic terrain based on Karang's \"Desert biome\" shader.", "tags": ["procedural", "terrain", "mountain", "volcano", "volcanic", "caldera"], "likes": 4, "viewed": 251, "published": 3, "date": "1632435860", "time_retrieved": "2024-07-30T18:59:39.010383", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    \n    float c1 = 4.;\n    float amplitude = 1./c1;\n    float freq = c1;\n    float n1 = 0.;\n    uv /= c1*2.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv-n1) * (freq))/freq;\n        n1 = abs(n2-n1-amplitude);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = abs(value-(n1-value-.5) * amplitude);\n        freq *= c1;\n        amplitude /= c1*(.3+value);\n        //c1 += value+freq;\n        \n        //uv = uv.yx;\n        //amplitude -= c1;\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n        //c1 += n1/(freq+value);\n        uv = uv.yx;\n        //uv = uv.yx/(1.+n1);\n        //uv.x += sin(uv.x/freq)*freq;\n        \n        //c1 /= 1.1;\n\n\n}\n    return value*c1*2.;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\t//int norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tint norLOD = geoLOD;\n    vec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime*2.;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1535], [1538, 1538, 1569, 1569, 1831], [1897, 1897, 1942, 1942, 2228], [2230, 2230, 2268, 2268, 2523], [2525, 2525, 2592, 2592, 2819], [2821, 2821, 2852, 2852, 4296], [4298, 4298, 4355, 4355, 4992]], "test": "untested"}
{"id": "ssK3Wd", "name": "Matrix Colors (from iq's tweet)", "author": "Zi7ar21", "description": "I don't know if IQ bothered making this into a shader at some point https://twitter.com/iquilezles/status/1440847977560494084?s=20", "tags": ["iq", "matrix"], "likes": 3, "viewed": 285, "published": 3, "date": "1632431721", "time_retrieved": "2024-07-30T18:59:39.847146", "image_code": "// https://twitter.com/iquilezles/status/1440847977560494084?s=20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\n    color = pow( color, vec3(3.0/2.0, 4.0/5.0, 3.0/2.0) );\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 124, 124, 288]], "test": "untested"}
{"id": "ssK3Dt", "name": "Moving Star Constellations", "author": "Scintoth", "description": "Modified version of https://www.shadertoy.com/view/3lsGW2", "tags": ["stars"], "likes": 4, "viewed": 437, "published": 3, "date": "1632427907", "time_retrieved": "2024-07-30T18:59:40.673935", "image_code": "float distLine( vec2 p, vec2 a, vec2 b){\n    vec2 pa = (p - a) / 2.0;\n    vec2 ba = (b - a) / 2.0;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0,1.0);\n    return length(pa - ba*t);\n}\n\nfloat noiseFloat(vec2 p){\n    p = fract(p * vec2(213.53, 970.19));\n    p = p + dot(p, p+548.23);\n    return fract(p.x * p.y);\n}\n\nvec2 noiseVector(vec2 p){\nfloat n = noiseFloat(p);\n    return vec2(n, noiseFloat(p+n) * 1.0);\n}\n\n\nvec2 GetPos(vec2 id, vec2 offsets){\nvec2 n = noiseVector(id + offsets) * 500.0 * ((iDate.w + 8000.0 + iTime) / 50000.0);\n    return (sin(n) * 0.9) + offsets;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = smoothstep(0.15, 0.01, d * 10.0);\n    m = m * smoothstep(0.9, 0.32, length(a-b));\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -1.0*iResolution.xy)/iResolution.y * 6.0;\n\t\n    float m = 0.0;\n    uv = uv * 10.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for(float y = -1.0; y<=1.0; y++){\n    \tfor(float x = -1.0; x<=1.0; x++){\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    for(int i=0; i<9; i++){\n    \tm = m + Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (50.0 / (8000.0 + iTime));\n      \n        m = m + sparkle * (sin(((8000.0 + iTime)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    \n    m = m + Line(gv, p[1], p[3]);\n    m = m + Line(gv, p[1], p[5]);\n    m = m + Line(gv, p[7], p[3]);\n    m = m + Line(gv, p[7], p[5]);\n    \n    vec3 col = vec3(m * 0.28, m * 0.28, m * 0.4);    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 185], [187, 187, 212, 212, 314], [316, 316, 341, 341, 411], [414, 414, 449, 449, 573], [575, 575, 610, 610, 751], [754, 754, 811, 861, 1733]], "test": "untested"}
{"id": "fdV3Wt", "name": "Ascending onions", "author": "SnoopethDuckDuck", "description": "No idea how this works, somehow botched transparency into existence and a few artifacts on top of the oniony bits, but looks gd", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 294, "published": 3, "date": "1632420688", "time_retrieved": "2024-07-30T18:59:41.472799", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    //float d = sdBox(p, vec3(1));\n    float r1 = 2. + cos(p.y + iTime);\n    float r2 = 0.2;\n    \n    float d1 = length(p.xz) - r1;\n\n    float a = atan(p.x,p.z);\n    float b = .5 + .5 * cos(iTime);\n    \n    float cd = length(p.xz) - 0.2\n    - abs(pow(cos(0.8 * p.y - iTime),1.5 + .5 * cos(iTime)));\n \n    p.y = cos(1. + 3. * cos(3. * a + p.z + p.x + iTime) * cos(3. * p.y));\n    float td2 = length(vec2(d1, -0.3 + 0.2 *sin(2. +  p.y - 0.4 * iTime) -0.2 * cos(2. * a + 4. *iTime))) -r2;\n    \n    // 0.5 *\n    td2 += 0.8 * cos(0.4 * iTime) *(0.9 * cos(5. * a + 2. * iTime));\n    \n    cd -= 0.3 * cos(0.5 * p.y + iTime);\n    cd *= 0.5;\n    \n    return min(cd, td2* 0.5);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    n *= (n-1.); // i added this\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(8. * cos(iTime), 4. + 0.6 * iTime, 8. * sin(iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,-2. + 0.6 * iTime,0), 0.85 + 0.05 * cos(iTime));\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    d =  RayMarch(ro + rd * 2. * d, -rd);\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float spec = pow(max(0., r.y),16.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        dif = 4. * dif * (1.-dif);\n        col = vec3(dif);\n        float a = atan(p.x,p.z);\n        col = mix(Bg(r), vec3(spec), 1.) + 0.2 * spec + Bg(r) * 0.6 *cos(2. * a + 0.1 * p.y + iTime);\n      //  col = mix(col, vec3(.5 + .5 * cos(iTime),0.,0.),.1);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3Wt.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1597, 1597, 1689], [1691, 1691, 1720, 1720, 1801], [1804, 1804, 1827, 1862, 2497], [2499, 2499, 2533, 2533, 2744], [2746, 2746, 2770, 2770, 2989], [2991, 2991, 3041, 3041, 3232], [3234, 3234, 3252, 3252, 3350], [3352, 3352, 3409, 3409, 4441]], "test": "untested"}
{"id": "sdKGWt", "name": "大龙猫 - Quicky#059", "author": "totetmatt", "description": "Some lighting (wrongly working)  and camera move. Quite happy with the result overall ", "tags": ["quicky"], "likes": 7, "viewed": 280, "published": 3, "date": "1632420449", "time_retrieved": "2024-07-30T18:59:42.240746", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 ln ;\nvec2 sdf(vec3 p){\n\n    vec2 h;\n  vec3 ph=p;\n    ph.x += asin(.2*sin(p.y*10.))*.2;\n  h.x=length(ph.xz)-1.;\n    h.y=1.;\n  \n  \n  vec2 t;\n  vec3 pt = p;\n    pt.y +=+iTime*.35;\n    float idy = floor(pt.y);\n    pt.xz *=rot(iTime*.33+idy);\n    pt.xz = abs(pt.xz)-1.;\n \n    pt.y = fract(pt.y)-.5;\n    t.x  = min(.25,length(pt)-(.2+fract(iTime)*.2));\n    t.y = 2.+ mod(idy,2.);\n    ln = pt;\n   \n  h = t.x < h.x ? t:h;\n\n  \n    \n  \n  return h;\n }\n#define q(s) s*sdf(p+s).x\n\n float ao(vec3 rp, vec3 n, float k){\n    vec2 d = sdf(rp+n*k);\n    if(d.y==2.){\n       return 1.;\n      }\n     return d.x /k;\n   }\n\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n float timer = fract(iTime*.06);\n \n  vec3 col = vec3(.1);\n\n  vec3 ro = mix(vec3(0.,0.,-7.),vec3(0.,100.,-1.25),timer);\n  vec3 rt = mix(vec3(0.,0.,-0.),vec3(0.,110.,-0.),timer);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rp = ro;\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  \n  vec3 light = vec3(1.,2.,-3.);\n  float dd =0.;\n  vec3 acc = vec3(0.);\n  bool nohit = false;\n  for(float i=0.;i<=128.;i++){\n    \n      vec2 d = sdf(rp);\n    \n    dd +=abs(d.x);\n    if(dd > 60.){nohit= true; break;}\n    \n    if(d.y==2. && d.x <.1){\n      \n        acc += vec3(1.,.30,.0)*exp(-abs(d.x))/18.;\n        d.x = max(.002,abs(d.x));\n      }\n      if(d.x <.001){\n          vec3 l2 = normalize(ln);\n          vec3 n = norm(rp,.0003);\n          float diff = max(0.,dot(normalize(light-rp),n));\n          float diff2 = max(0.,dot(l2,n));\n     \n          if(d.y==1.) { \n            col = vec3(.1)*diff+ vec3(1.,.30,.0)*diff2;;  \n             rd = reflect(rd,n);\n             rp+=rd*.1;\n           \n          } else if (d.y==3.){\n              col = vec3(.1,.1,.1)*diff;\n                break;\n              }\n          \n    \n       \n          \n          }\n          rp+=rd*d.x;\n }\n  col +=acc;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [76, 76, 93, 93, 511], [540, 540, 575, 575, 669], [671, 671, 698, 698, 774], [775, 775, 832, 882, 2253]], "test": "untested"}
{"id": "fdV3Dt", "name": "minimal bump mapping (87 chars)", "author": "hnh", "description": "Not sure if this actually qualifies as bump mapping - but hey...", "tags": ["bumpmapping", "short", "golf"], "likes": 10, "viewed": 323, "published": 3, "date": "1632413959", "time_retrieved": "2024-07-30T18:59:43.005701", "image_code": "\nvoid  mainImage(out vec4 O, vec2 P){\n\n/*   // switch: \"//*\" -> \"/*\"\n// -5, modified version by Shane (front illumination):\n  O = 1. - fwidth(5e1*texture(iChannel0, P/5e2).rrrr);\n\n/*/\n// -2 by Xor (upper left illumination):\n  O = dFdx(O = 5e1*texture(iChannel0, P/5e2).rrrr) - dFdy(O);\n\n/* /\n// -9 by Xor:\n  O = 5e1*texture(iChannel0, P/5e2).rrrr; O = dFdx(O) - dFdy(O);\n\n/* /\n// starting at 98 chars:\n  float u= texture(iChannel0, P/5e2).r;\n  O= 5e1*vec4(dFdx(u) - dFdy(u));\n\n//*/\n}\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 223, 483]], "test": "untested"}
{"id": "fsKGWt", "name": "Matrix colour filter", "author": "FiXato", "description": "Based on https://libranet.de/display/0b6b25a8-1961-4c8a-41a2-730221069039", "tags": ["matrix"], "likes": 1, "viewed": 259, "published": 3, "date": "1632408444", "time_retrieved": "2024-07-30T18:59:43.901306", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    float rr = (3.0 / 2.0);\n    float rg = (4.0 / 5.0);\n    float rb = (3.0 / 2.0);\n    col.r = pow(col.r, rr);\n    col.g = pow(col.g, rg);\n    col.b = pow(col.b, rb);\n\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 394]], "test": "untested"}
{"id": "ssG3Wt", "name": "Sea the Night", "author": "crocidb", "description": "Shader inspired by some of the art by https://instagram.com/matialonsor", "tags": ["waves", "sea", "moon", "night", "reproduction"], "likes": 145, "viewed": 4163, "published": 3, "date": "1632402924", "time_retrieved": "2024-07-30T18:59:44.913599", "image_code": "//\n// Sea the Night\n// by Bruno Croci - https://bruno.croci.me/\n// \n// Inspired by: https://instagram.com/matialonsor\n// Depth of Field code: https://www.shadertoy.com/view/lstBDl\n//\n\n#define DISPLAY_GAMMA 1.9\n\n#define GOLDEN_ANGLE 2.39996323\n#define MAX_BLUR_SIZE 30.0\n\n#define RAD_SCALE 0.5 // Smaller = nicer blur, larger = faster\n#define uFar 12.0\n#define FOCUS_SCALE 35.0\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n    vec4 Input = texture(iChannel0, texCoord).rgba;\n    float centerDepth = Input.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = Input.rgb;\n    float tot = 1.0;\n    \n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.0; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n    {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * texelSize * radius;\n        \n        vec4 sampleInput = texture(iChannel0, tc).rgba;\n\n        vec3 sampleColor = sampleInput.rgb;\n        float sampleDepth = sampleInput.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        \n        if (sampleDepth > centerDepth)\n        {\n        \tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n    }\n    \n    return color /= tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv).rgba;\n    \n    float focusPoint = 58.0 - sin(iTime * 0.3) * 20.0;\n    color.rgb = depthOfField(uv, focusPoint, FOCUS_SCALE);\n\n    //tone mapping\n    color.rgb = vec3(1.7, 1.8, 1.6) * color.rgb / (1.0 + color.rgb);\n    \n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.0);\n    \n    // Debug depth\n    //fragColor.rgb = vec3(color.a)*0.015;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nmat2 rot(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noiseo(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noiseo(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n#define DRAG_MULT 0.048\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations, float time){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, time);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}", "buffer_a_code": "#define AA 1\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t200\n#define MAX_DIST\t\t\t25.0\n#define SURFACE_DIST\t\t0.001\n\n#define Time iTime\n#define clamp01(x) max(min(x, 1.0), 0.0)\n\nvec3 ro;\n\nvec2 map(vec3 p, bool complete)\n{\n    vec2 v = vec2(MAX_DIST, 0.0);\n    \n    // water\n    float final = getwaves(p.xz * .35, 20, iTime * .5) * (getwaves(p.xz * .15 + vec2(2.2, 2.2), 3, iTime * .5) * 1.5 + .4) * 1.05;\n    float f = dot(p, vec3(0.0, 1.0, 0.0)) - final;\n    v = vec2(f, 1.0);\n    \n    return v;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e, true).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n       \t\n        obj = map(p, true);\n        \n        if (abs(obj.x) < SURFACE_DIST || abs(t) > MAX_DIST) break;\n        \n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.0026f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t, true);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 1.85) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.5, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t, false);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Renderer\nvec4 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    \n    const vec3 background_color = vec3(0.0, 0.01, 0.02);\n    vec3 background = background_color;\n    \n    vec2 pos = uv - vec2(0.0, 0.2) - vec2(0.0, 0.2) * sin(iTime * 0.5) * 0.1;\n    background += pow(clamp01(1.0 - length(pos * 1.5)), 1.9) * background * 20.0;\n    background += pow(clamp01(1.0 - length(pos * 6.5)), 3.9) * background * 80.0;\n    \n    float n = fbm_2(vec3(pos * 52.0 + iTime * 0.1, 1.0)) * 1.8;\n    n = smoothstep(0.72, 0.78, n) * 8.5;\n    \n    background += n * background_color;\n    float c = 1.0;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = background;\n    }\n    else\n    {\n        vec3 albedo = vec3(0.0, 0.0, 0.0);\n        \n        float a = pow(1.0 - clamp(dot(-rd, normal), 0.0, 1.0), 2.6);\n        float m = pow(length(ro - p) * 0.2, 1.4) * 0.8;\n\n        c = pow(clamp01(1.0 - length((uv - vec2(0.0, -0.4)) * .4)), 5.0) * 3.0;\n\n        float diff_mask = a * m * c;\n        float ambient_mask = a * m + .06;\n        albedo = vec3(0.0, 0.044, 0.09) * 10.0;\n        float spec_power = 80.0;\n        float spec_mask = 6.7 * m;\n        \n        // Moon Light\n        #if 1\n        {\n            const vec3 light_pos = vec3(-0.0, 40.0, 100.4);\n            const vec3 light_col = vec3(0.2, 0.2, 0.2);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * 1.86;\n            col += spec * (light_col * albedo) * spec_mask * visibility * c;\n        }\n        #endif\n        \n        // Fill Light\n        #if 1\n        {\n            const vec3 light_pos = vec3(0.0, 100.0, 0.0);\n            const vec3 light_col = vec3(0.0, 0.4, 0.2);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * .1;\n            col += spec * (light_col * albedo) * spec_mask * visibility * .03;\n        }\n        #endif\n        \n        \n        // Ambient light\n        #if 1\n        col += albedo * 0.2 * ambient_mask;\n        #endif\n    }\n    \n    return vec4(col, obj.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float v = 1.7 + sin(iTime * 0.5) * 0.5;\n    const vec3 ta = vec3(0.0, 0.0, 20.0);\n    vec3 ro = vec3(\n        0.0,\n        v,\n        0.0\n    );\n\n    vec4 tot = vec4(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.3 * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec4 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4(tot);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssG3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 446, 446, 561], [563, 563, 633, 633, 1656], [1658, 1658, 1715, 1715, 2188]], "test": "untested"}
{"id": "ssy3Wd", "name": "Scramble/descramble", "author": "Kypsis", "description": "Scrambling/descrambling using modular multiplicative inverse function. Press mouse left button for descrambling.", "tags": ["inverse", "reversible", "scramble"], "likes": 1, "viewed": 188, "published": 3, "date": "1632401843", "time_retrieved": "2024-07-30T18:59:45.682543", "image_code": "// ...and descramble output from BufferA\n\nuint un_rhashx(uint n) {\n    return (n * 567u) % 640u;\n}\n\nuint un_rhashy(uint n) {\n    return (n * 247u) % 360u;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Mouse\n    vec4 m = iMouse / iResolution.x;\n    \t\n    // If mouse down, modify iChannel0 from Buffer A (descramble)\n\tif(m.z > 0.0) {\n        // Discard coordinates outside screen range\n        if (int(fragCoord.y) > 359 || int(fragCoord.x) > 639) discard;\n        fragColor = texelFetch(\n            iChannel0, \n            ivec2(\n                un_rhashx(uint(fragCoord.x)),\n                un_rhashy(uint(fragCoord.y))\n            ), \n            0);\n\n    } \n    else {\n    // else just show the texture from Buffer A\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Scramble iChannel0 input using modular multiplicative inverse function...\n\nuint rhashx(uint n) {\n    return (n * 3463u) % 640u;\n}\n\nuint rhashy(uint n) {\n    return (n * 3463u) % 360u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Discard coordinates outside screen range\n    if (int(fragCoord.y) > 359 || int(fragCoord.x) > 639) discard;\n    \n    fragColor = texelFetch(\n        iChannel0, \n        ivec2(\n            rhashx(uint(fragCoord.x)),\n            rhashy(uint(fragCoord.y))\n        ), \n        0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssy3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 66, 66, 98], [100, 100, 124, 124, 156], [159, 159, 216, 230, 820]], "test": "untested"}
{"id": "7dGGDt", "name": "uv映射", "author": "Jatpeng", "description": "屏幕上下左右映射", "tags": ["uv"], "likes": 2, "viewed": 206, "published": 3, "date": "1632389419", "time_retrieved": "2024-07-30T18:59:46.454480", "image_code": "\nint num_blocks = 3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 texcoord =(fragCoord/iResolution.xy);;\n        vec2 uv =(fragCoord/iResolution.xy);;\n    uv = vec2(uv.x,uv.y);\n        \n    float xcount = 3.0;\n    float ycount = 3.0;\n    \n    vec2 uv_index = vec2(0.0,0.0);\n    uv_index = vec2(uv_index.x,ycount-uv_index.y-1.0);\n\n       \n    float x = (uv_index.x)/xcount;\n    float y = (uv_index.y)/ycount;\n    \n    texcoord = vec2(uv.x/xcount+x,uv.y/ycount+y);\n    \n    // 从纹理中获取颜色并输出\n    fragColor = texture(iChannel0, texcoord);\n   //fragColor = vec4(uv.x*4.0,uv.y,0.0,1.0);\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 630]], "test": "untested"}
{"id": "Nsy3Dd", "name": "random puzzle cubes 2", "author": "gormonboza", "description": "Task for Tatev", "tags": ["task"], "likes": 4, "viewed": 328, "published": 3, "date": "1632385640", "time_retrieved": "2024-07-30T18:59:47.215445", "image_code": "float rand(vec2 co){\n    return fract( sin ( dot (co, vec2(12.9898, 78.233))) * 43758.5453 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nUV = (uv - .5) * iResolution.xy / vec2(iResolution.y);\n\tint count = 6;\n\tnUV *= float(count);\n\tfloat cellSize = iResolution.y / float(count);\n\tivec2 gRes = ivec2(count);\n\tgRes.x = int(ceil(iResolution.x / cellSize) + 1.);\n\tint gCount = gRes.x * gRes.y;\n\tvec2 gUV = fract(nUV) - .5;\n\tvec2 id = floor(nUV);\n\tfloat act = step(1., float(int(iTime) % 2));\n\tid += float(int(iTime));\n\tint newID = int(rand(id) * float(gCount));\n\tvec2 lookup = vec2(newID % gRes.x, int(newID / gRes.x));\n\tvec2 cellCenter0 = uv - gUV * iResolution.y / iResolution.xy / float(count);\n\tvec2 cellCenter1 = ((cellSize * lookup) - (cellSize / 2.)) / iResolution.xy;\n\tcellCenter1 = clamp(cellCenter1, cellSize / 2. / iResolution.xy, 1. - cellSize / 2. / iResolution.xy);\n\tcellCenter0 = cellCenter0 * act + cellCenter1 * (1. - act);\n\tvec2 cellUV = cellCenter0 + gUV * iResolution.y / iResolution.xy / float(count);\n\tvec4 color = texture(iChannel0, cellUV);\n\tfragColor = color;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsy3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 95], [97, 97, 154, 154, 1149]], "test": "untested"}
{"id": "fdyGDt", "name": "Animated Subdivision 3D", "author": "Tater", "description": "I might keep making these until I run out of ideas. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 24, "viewed": 594, "published": 3, "date": "1632383518", "time_retrieved": "2024-07-30T18:59:47.991370", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\n//global ray direction\nvec3 rdg = vec3(0);\n//block scale factor\nfloat gscl = 1.;\n\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime*(11./8.);\n      \n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    float id = 0.;\n    \n    \n    float MIN_SIZE = 0.3;\n    float ITERS = 6.;\n    float MIN_ITERS = 1.;\n    float PAD_FACTOR = 1.01;\n    float seed = floor(t/(ITERS+5.0))+0.1;\n    t = mod(t,ITERS+5.0);\n\n    //Offset and clamp the time at 0 so the cube stays uncut for a short time\n    t= clamp(t-1.0,0.0,ITERS);\n    \n    //calculate initial box dimensions\n    vec3 dim = dMax - dMin;\n    \n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n    \n        //If this is the final cut when animating then break\n        if(i>floor(t)) break;\n        \n        //divide the box into eight\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        vec3 divide = divHash * dim + dMin;\n        \n        //Clamp Division Line\n        divide = clamp(divide, dMin + MIN_SIZE * PAD_FACTOR, dMax - MIN_SIZE * PAD_FACTOR);\n        \n        //Un-altered division line for coloring moving cells \n        vec3 divideFull = divide;\n        \n        //find smallest dimension of divison\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min(minAxis.x, min(minAxis.y, minAxis.z));\n        \n        //if the next cut will be below the minimum cut size then break out\n        if (minSize < MIN_SIZE && i + 1. > MIN_ITERS) {break ;}\n\n        //If the current iteration is the cutting one\n        //Smooth it between 0 and its final position\n        float tt = smoothstep(0.,1.,fract(t));\n        if(i == floor(t) &&mod(t,2.0)<1.0){\n            divide=mix(dMin,divide,tt);\n        }\n        else if(i == floor(t)){\n            divide=mix(dMax,divide,tt);\n        }\n\n        \n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        // id will be used for coloring and hash seeding\n        vec3 diff = mix( -divideFull, divideFull, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n\n    //Calculate the distance to the outside of the current cell bounds\n    //to avoid overstepping\n    vec3 edgeAxis = mix( dMin, dMax, step( 0.0, rd ) );\n    vec3 dAxis = abs( p - edgeAxis ) / ( abs( rd ) + 1E-4 );\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    float b=dEdge;\n\n    vec3 d = abs(center);\n\n    //Scale the cubes down so they stay the same size when they \"explode\"\n    dim*=gscl;\n    float a = box(p-center,dim*0.5);\n    \n    //Take the minimum between the actual box and the intersection \n    //to the outside of the cell\n    a = min(a, b);\n    \n    //extra randomize the ID\n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n//This is a smooth square wave approximation function but I really like\n//The curve it makes so I'm using it instead of a smoothstep to animate the\n//spin and \"explode\". It's a bit long because I made it start at 0 and repeat every 3. \nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec2 map(vec3 p){\n    float t = iTime*(11./8.);\n    //The cycle for the spinning and explosion doesn't exaclty line up\n    //with the cycle for the cutting because the spin needs to continue after the\n    //cuts have reset, so the cycle is offset fowards a bit\n    t = mod(t-1.0,11.0)+1.0;\n    \n    //timing out the spin+explode animation and making sure it happens\n    //once per cycle\n    float wav = swave(clamp(t*0.78-4.0,0.0,6.0),0.1);\n    \n    //Set the global scale variable that controls the exploding of boxes\n    gscl = 1.0-wav*0.5;\n    \n    //rotation amount\n    float rotd = wav*pi*4.02;\n    \n    //rotate the cube\n    p.xz*=rot(rotd);\n    \n    //move the cube up when it rotates so it fits nicely in the screen\n    p.y-=wav*3.0;\n    \n    //Scale space so the entire thing gets bigger (but the boxes are later re-sized,\n    //so it looks like they stay the same time)\n    p*=gscl;\n    \n    //Initalize output sdf, with vec2 for ID\n    vec2 a = vec2(1);\n    \n    //Size of the subdivision fractal\n    vec3 scl = vec3(10);\n    \n    //get the global ray direction and rotate it with the same rotation\n    //as the cube so that the outside cell intersection still works correctly\n    vec3 rd2 = rdg;\n    rd2.xz*=rot(rotd);\n    \n    a = blocks(p,scl,rd2)+0.01;\n    \n    //use a box to optimize areas outside of the fractal to minimize steps\n    //Also I found you can instead the step distance of the fractal when it explodes\n    //without causing artifacts which is free performance\n    a.x = max(box(p,vec3(scl*0.49)),a.x*(1.0+wav));\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.0001,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.45;\n    if(iMouse.z>0.){\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(gscl*0.9+0.13)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(d.x<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST||i==STEPS-1.){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        float diff = length(sin(n*2.)*.5+.8)/sqrt(3.);\n        col = al*diff;\n        float shadow = 1.;\n        \n        //Mini hard shadow code\n        //Need to make sure global ray direction is updated\n        rdg = ld;\n        for(float h = 0.09; h<10.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }     \n        col*=shadow;\n    }\n    vec3 bg = vec3(0.741,0.498,0.498)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 312, 379, 379, 418], [419, 419, 439, 439, 510], [511, 511, 532, 532, 584], [585, 585, 611, 611, 670], [754, 754, 793, 793, 3767], [3768, 4004, 4034, 4034, 4137], [4138, 4138, 4155, 4155, 5701], [5702, 5702, 5720, 5720, 5850], [5851, 5851, 5908, 5908, 7435]], "test": "untested"}
{"id": "sdGGDc", "name": "simplified fluid advect", "author": "noobdawn", "description": "a fluid simulator", "tags": ["fluid"], "likes": 2, "viewed": 318, "published": 3, "date": "1632365428", "time_retrieved": "2024-07-30T18:59:48.761312", "image_code": "// https://www.shadertoy.com/view/4sd3WB\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 udu = texture(iChannel0, uv).xy;\n    float u = udu.x;\n    float du = udu.y;\n    \n    //fragColor = vec4(texture(iChannel0, uv).zw, 0.0, 1.0);\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    // init property\n    if (iTime < 0.1)\n    {\n        if ((uv.x > 0.1) && (uv.x < 0.9) && (uv.y > 0.4) && (uv.y < 0.5))\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        else\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    vec4 origin = texture(iChannel0, uv);\n    float du = origin.y;\n    // check mouse input position\n    vec2 r = fragCoord.xy - iMouse.xy;\n    float dist = 0.001 * dot(r, r);\n    if (iMouse.z > 0.0 && dist < 0.2) {\n        fragColor = vec4(0.0, 0.2, origin.zw);\n        return;\n    }\n    // copy\n    float _X = texture(iChannel0, vec2(uv.x + d.x, uv.y)).x;\n    float _x = texture(iChannel0, vec2(uv.x - d.x, uv.y)).x;\n    float _Y = texture(iChannel0, vec2(uv.x, uv.y + d.y)).x;\n    float _y = texture(iChannel0, vec2(uv.x, uv.y - d.y)).x;\n    vec2 n = -vec2((_X - _x) / d.x, (_Y - _y) / d.y);\n    vec2 offset = n.xy;\n    if ((abs(n.x) < 0.001) && (abs(n.y) < 0.001))\n        offset = vec2(0);\n    float np = texture(iChannel0, uv + offset * 0.01).z;   \n    fragColor = vec4(origin.xy, np, origin.w);\n    \n    //fragColor = vec4(origin.xy, n);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 origin = texture(iChannel0, uv);\n    \n    float u = origin.x;\n    float du = origin.y;\n    \n    float ux = texture(iChannel0, vec2(uv.x + d.x, uv.y)).x;\n    float umx = texture(iChannel0, vec2(uv.x - d.x, uv.y)).x;\n    float uy = texture(iChannel0, vec2(uv.x, uv.y + d.y)).x;\n    float umy = texture(iChannel0, vec2(uv.x, uv.y - d.y)).x;\n    float uxy = texture(iChannel0, vec2(uv.x + d.x, uv.y + d.y)).x;\n    float umxy = texture(iChannel0, vec2(uv.x - d.x, uv.y + d.y)).x;\n    float uxmy = texture(iChannel0, vec2(uv.x + d.x, uv.y - d.y)).x;\n    float umxmy = texture(iChannel0, vec2(uv.x - d.x, uv.y - d.y)).x;\n    \n    \n    // edge\n    \n    float nu = u + du + 0.25 * (umx + ux + umy + uy + 0.707 * (uxy + umxy + uxmy + umxmy) - 8.0 * u);\n    //  u + du + 0.5 * (umx + ux + umy + uy - 4.0 * u);\n    nu = 0.9 * nu;\n    \n    fragColor = vec4(nu, nu - u, origin.zw);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 98, 98, 333]], "test": "untested"}
{"id": "sdK3Dc", "name": "basic geometric images", "author": "jorge2017a2", "description": "basic geometric images\n\n", "tags": ["basicgeometricimages"], "likes": 3, "viewed": 238, "published": 3, "date": "1632363708", "time_retrieved": "2024-07-30T18:59:49.526266", "image_code": "//basic geometric images\n\n//https://iquilezles.org/articles/distfunctions2d\n\n///por jorge2017a2...2021-sep-19\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nvec3 circulosvarios(vec2 p, vec3 col, float pradio  )\n{\n    float pr=0.272;\n    p.x=mod(p.x,pr);\n    p.y=mod(p.y,pr);\n    float r1=iTime/100.0;    \n    r1=pradio;\n    float c1=sdCircle( p-vec2(.0,.0), r1 );\n    float c2=sdCircle( p-vec2(.25,.0),r1 );\n    float c3=sdCircle( p-vec2(.0,.25),r1 );\n    float c4=sdCircle( p-vec2(.25,.25),r1 );\n    \n    col= DrawFigBorde(vec3(1.0), col, abs(c1) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c2) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c3) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c4) );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    //vec3 col=vec3(0.4,0.4,0.4);\n    vec3 col=vec3(0.6);\n    \n    col= circulosvarios(uv, col,0.2); \n    col= circulosvarios(uv, col,0.15+0.07*sin(iTime)); \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 301, 337, 337, 382], [387, 387, 426, 426, 470], [472, 516, 563, 563, 590], [591, 591, 634, 634, 661], [662, 662, 710, 710, 738], [744, 744, 806, 806, 938], [940, 940, 997, 997, 1063], [1065, 1065, 1100, 1100, 1123], [1125, 1125, 1180, 1180, 1688], [1691, 1691, 1748, 1748, 2024]], "test": "untested"}
{"id": "7dVGWc", "name": "pendant shape", "author": "mds2", "description": "prototyping a shape I'm considering getting 3d printed as a necklace pendant. Experimenting with super-ellipse toroids.  Dirt simple lighting.", "tags": ["raycast", "sdf", "squircle"], "likes": 4, "viewed": 245, "published": 3, "date": "1632352045", "time_retrieved": "2024-07-30T18:59:50.289227", "image_code": "#define MAX_DIST 20.0\n\nconst float rad1 = 1.0;\nconst float rad2 = 0.075;\n\nfloat squircle_toroid(in vec3 pt, in float radius1, in float radius2, in float squish) {\n  vec3 pows = pt * pt;\n  pows = pows * pows;\n  float radial = sqrt(sqrt(pows.x + pows.z)) - radius1;\n  radial = radial * radial;\n  radial = radial * radial;\n  return sqrt(sqrt(squish * radial + pows.y)) - radius2;\n}\n\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\n\nfloat sdf(in vec3 pt) {\n  float v1 = squircle_toroid(pt, rad1, rad2, 0.5);\n  float v2 = squircle_toroid((-pt - 0.84 * vec3(1.25 * rad1, 0.0, 1.25 * rad1)).yzx +\n                             vec3(0.25 * rad1, 0.25 * rad1, 0.0),\n                             0.125 * rad1,\n                             rad2,\n                             4.0);\n  return checked_smooth_min(v1, v2, 0.2 * rad1);\n}\n\nfloat rayCast(in vec3 orig, in vec3 dir) {\n  float along = 0.0;\n  \n  for(int i = 0; i < 256; ++i) {\n    vec3 p = orig + along * dir;\n    float dist = sdf(p);\n    if (along > MAX_DIST || dist < 1.0e-5) {\n      return along;\n    }\n    along += 0.75 * dist;\n  }\n  return along;\n}\n\nvec3 sdfGrad(in vec3 pt) {\n  const float h = 0.001;\n  const float inv_h = 1000.0;\n  float v = sdf(pt);\n  return inv_h * vec3(sdf(pt + vec3(h, 0.0, 0.0)) - v,\n                      sdf(pt + vec3(0.0, h, 0.0)) - v,\n                      sdf(pt + vec3(0.0, 0.0, h)) - v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) * scale;\n    \n    vec3 dir = normalize(vec3(uv, -3.0));\n    vec3 orig = vec3(0.0, 0.0, 4.0);\n    \n    const mat3 pitch = mat3(1.0, 0.0, 0.0,\n                            0.0, 0.8, -0.6,\n                            0.0, 0.6, 0.8);\n\n    float ct = cos(iTime);\n    float st = sin(iTime);\n    mat3 yaw = mat3(ct, 0.0, st,\n                    0.0, 1.0, 0.0,\n                    -st, 0.0, ct);\n    \n    dir = pitch * yaw * dir;\n    orig = pitch * yaw * orig;\n    vec3 bounce = dir;\n\n    float blend = 0.25;\n    float d = rayCast(orig, dir);\n    \n    if (d < MAX_DIST) {\n      vec3 pt = orig + d * dir;\n      vec3 norm = normalize(sdfGrad(pt));\n      blend = 1.0;\n      bounce = reflect(dir, norm);\n    }\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * bounce;\n    \n    col = mix(vec3(0.5), col, blend);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 162, 162, 378], [759, 759, 819, 819, 860], [1073, 1073, 1096, 1096, 1463], [1465, 1465, 1507, 1507, 1741], [1743, 1743, 1769, 1769, 2013], [2016, 2016, 2073, 2073, 3097]], "test": "untested"}
{"id": "XssGRH", "name": "Balance", "author": "mare", "description": " - sunrise and sunset\n - water with raindrops from the clear sky\n - some strings and sea noise totally unrelated to rain\n - visual overlay to cover initial buffer raw state", "tags": ["audio", "meditation"], "likes": 20, "viewed": 700, "published": 3, "date": "1632346490", "time_retrieved": "2024-07-30T18:59:51.055179", "image_code": "vec3 yinYang( in vec2 fragCoord )\n{\n    // some old unpublished shader utilized\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2( .5,.5 );\n\tfloat aspect = iResolution.x / iResolution.y;\n\tuv.x *= aspect;\n\tvec3 col = vec3( 1.0, 1.0, 1.0 );\n\tvec2 offset = vec2( uv.y, -uv.x );\n\tvec2 uv2 = uv + offset * sin( length( uv ) * 20.0 + iTime) * 1.55;\n\tfloat lightness = 1.0 * sin( 10.0 *uv2.x ) * cos( 10.0 * uv2.y );\n\tlightness += 1.0 * cos( 10.0 *uv.x ) * sin( -10.0 * uv.y );\n\tlightness = pow( clamp(lightness, .0, 1.0 ), .45 );\n\tlightness *= 2.0 - 2.9 * dot( uv, uv );\n\treturn col * max( lightness, .0 );\n}\n\nvec3 sky( vec3 ray )\n{\n    float horizonLight = .2 - ray.y;\n    ray.y = max( .0, ray.y );\n    float dayTime = cos( iTime * .05);\n    \n    vec3 moonDir = normalize( vec3( .1, -.2 * dayTime + .1, .9 ) );\n    float moonDot = dot( moonDir, ray );\n    float moon = smoothstep( .996, .997, moonDot );\n    vec3 ret = vec3( .0, .07, .12);\n    ret += moon * vec3( 1.5, .6, .4 );\n    ret += smoothstep( .9, 1.0, moonDot ) * vec3( .1, .0, .0 );\n    float dayTimeN = .5 + .5 * dayTime;\n    vec3 horizonColor =  (1.0 -  dayTimeN) * vec3( .1, .95, .4 ) + dayTimeN * vec3( 1., .3, -.1 );\n    ret += horizonLight * horizonColor ;\n    ret *= 3.0;\n    ret *= clamp( .15 * iTime - .6, .0, 1.0 );\n    \n    float yinYangVal = clamp( iTime, .0, 1.0 );\n    \n    yinYangVal *= max( cos( iTime * .1 ) - .3, .0 );\n    yinYangVal *= yinYangVal * yinYangVal;\n    \n    ret += yinYangVal * yinYang( (ray.xy + vec2(.25, .0)) * iResolution.x * 1.6 );\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= vec2( .5,.7 );\n    uv *= .5;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tuv.x *= aspect;\n    \n    vec3 ray = vec3( uv.x, uv.y, 1.0 );\n    ray = normalize( ray );\n    \n    if( ray.y >= .0 )\n    {\n        fragColor = vec4( sky(ray), 1.0 );\n        return;\n    }\n    \n    vec2 targetUv = vec2( .5 + ray.x * .07 / -ray.y, ray.z * .07 / -ray.y );\n    targetUv *= iResolution.y / 300.;\n    targetUv.y += sin( iTime * .03 );\n    targetUv.x += cos( iTime * .03 );\n    \n    float tex = texture( iChannel0, fract( targetUv ) ).x - .5;\n    targetUv *= vec2( 1.0 - .502 * tex );\n    targetUv *= 200.0 / iResolution.y;\n    \n    vec2 scale = 1. / iResolution.xy;\n    vec2 offs = vec2(1.0, 1.0) * scale;\n    \n    tex = texture( iChannel0, fract( targetUv ) ).x;\n    \n    float texL = texture( iChannel0, fract( targetUv - vec2(offs.x, .0) ) ).x;\n    float texD = texture( iChannel0, fract( targetUv - vec2(.0, offs.y) ) ).x;\n    vec3 normal = vec3( tex - texL, .4, tex - texD );\n    normal /= length( normal );\n    \n    vec3 reflection = normalize( ray - 2. * dot( ray, normal ) * normal );\n    \n    float fresnel = ( 1.0 - 3.0 * dot( normal, reflection ) );\n    fragColor = vec4( sky(reflection) * fresnel, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define TONE(f,i) sin((f)*float(i)*1.424759e-4)\n#define BOOST_SUB(f,fr) -50.0*abs( fract( f/fr  -.5 ) - .5)\n\n\n#define ATT1(t) max(sin((t)*0.75+2.0),.0)\n#define ATT2(t) max(sin((t)*1.00-2.0),.0)\n#define ATT3(t) max(sin((t)*1.25+2.0),.0)\n#define ATT4(t) max(sin((t)*1.33+4.0),.0)\n\n#define COUNT 1024\n#define COUNT_F 1024.0\n\n#define BOOST \\\n        float \\\n        boost = max( boost1_1 + BOOST_SUB( f,tone1_1 ),.0); \\\n        boost = max( boost1_2 + BOOST_SUB( f,tone1_2 ),boost); \\\n        boost = max( boost1_3 + BOOST_SUB( f,tone1_3 ),boost); \\\n        boost = max( boost1_4 + BOOST_SUB( f,tone1_4 ),boost); \\\n        boost = max( boost2_1 + BOOST_SUB( f,tone2_1 ),boost); \\\n        boost = max( boost2_2 + BOOST_SUB( f,tone2_2 ),boost); \\\n        boost = max( boost2_3 + BOOST_SUB( f,tone2_3 ),boost); \\\n        boost = max( boost2_4 + BOOST_SUB( f,tone2_4 ),boost); \\\n        boost = min( boost, .1 ); \\\n\nfloat ratios [4] = float[4]( 1.0, 1.25, 1.5, .75 );\nvec2 mainSound( int samp, float time )\n{\n    float f = 20.0;\n    float factor = 1.0;\n    float domPhase = time * .25;\n    int index1 = int( floor( ( domPhase + 1.5707963267 ) / 6.2831853071 ) ) & 3;\n    int index2 = int( floor( ( domPhase - 1.5707963267 ) / 6.2831853071 ) ) & 3;\n    \n    float tone1_1 = 220.0 * ratios[ index2 ];\n    float tone1_2 = 275.0 * ratios[ index2 ];\n    float tone1_3 = 330.0 * ratios[ index2 ];\n    float tone1_4 = 440.0 * ratios[ index2 ];\n    \n    float tone2_1 = 330.0 * ratios[ index1 ];\n    float tone2_2 = 577.5 * ratios[ index1 ];\n    float tone2_3 = 247.5 * ratios[ index1 ];\n    float tone2_4 = 412.5 * ratios[ index1 ];\n    \n    float domFactor = clamp( sin( domPhase ) * 3.0 + .25, .0, 1.0 );\n    float resFactor = clamp( sin( domPhase ) * -3.0 + .25, .0, 1.0 );\n    \n    float lt = time;\n    \n    float boost1_1 = resFactor * ( ATT1(lt) + .3*ATT1(lt - .2 ) + .1*ATT1(lt - .4 ) );\n    float boost1_2 = resFactor * ( ATT2(lt) + .3*ATT2(lt - .2 ) + .1*ATT2(lt - .4 ) );\n    float boost1_3 = resFactor * ( ATT3(lt) + .3*ATT3(lt - .2 ) + .1*ATT3(lt - .4 ) );\n    float boost1_4 = resFactor * ( ATT4(lt) + .3*ATT4(lt - .2 ) + .1*ATT4(lt - .4 ) );\n    float boost2_1 = domFactor * ( ATT1(lt) + .3*ATT1(lt - .2 ) + .1*ATT1(lt - .4 ) );\n    float boost2_2 = domFactor * ( ATT2(lt) + .3*ATT2(lt - .2 ) + .1*ATT2(lt - .4 ) );\n    float boost2_3 = domFactor * ( ATT3(lt) + .3*ATT3(lt - .2 ) + .1*ATT3(lt - .4 ) );\n    float boost2_4 = domFactor * ( ATT4(lt) + .3*ATT4(lt - .2 ) + .1*ATT4(lt - .4 ) );\n    \n    float left = .0;\n    for( int i = 1; i < COUNT; ++i )  \n    {\n        f = 90.0 + ( 7.501 + 2.10 * sin( float(i) ) ) * float( i );\n        BOOST\n        float fc = factor*factor; fc*=factor;\n        left += TONE( f,samp ) * ( min(f/500.0, 1.0)*fc + boost * 24.0 ) * fc;\n        factor -= 1.0 / COUNT_F;  \n    }\n    \n    factor = 1.0;\n    \n    float right = .0;\n    for( int i = 1; i < COUNT; ++i )  \n    {\n        f = 92.0 + ( 5.499 + .010 * sin( float(i) ) ) * float( i );\n        BOOST\n        float fc = factor*factor; fc*=fc;\n        right += TONE( f,samp ) * ( min(f/500.0, 1.0)*fc + boost * 24.0 ) * fc;\n        factor -= 1.0 / COUNT_F;\n    }\n    \n    float rotationPhase = time * .7;\n    float outRight =  sin( rotationPhase ) * left + cos( rotationPhase ) * right;\n    float outLeft =  sin( rotationPhase ) * right + cos( rotationPhase ) * left;\n    float waveValue = .8 + .2 * sin( sin( time ) * 3.0 + 1.5 * time );\n    time -= .5;\n    waveValue *= .8 + .2 * sin( sin( time ) * 3.0 + 1.5 * time );\n    waveValue *= 6.0;\n    \n    return min( time * .2, 1.0) *  ( vec2( outLeft, outRight ) *.8 + vec2( outLeft + outRight ) * .1 )* waveValue / COUNT_F;\n}", "sound_inputs": [], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterUpd( fragColor, fragCoord, iResolution.xy, iTime, iChannel0 );\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    waterUpd( fragColor, fragCoord, iResolution.xy, iTime, iChannel0 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float moise2(vec2 c, float t)\n{\n\treturn fract(sin(dot(vec2(18.69781,79.98463),fract(c + t))) * 4958.1694);\n}\n\nvoid waterUpd( out vec4 fragColor, in vec2 fragCoord, vec2 resolution, float time, sampler2D sampler )\n{\n    vec2 uv = fragCoord.xy / resolution;\n    float val = moise2( uv, floor( time * 4. ) * .1234);\n    float rain = 1.0 - step( val, .9998 );\n    rain *= max( 1.0 - fract( time * 4.) - .7, .0 );\n\n    if( time < 2.0 )\n    {\n        fragColor = vec4( vec3( .5 ), 1.0 );\n        return;\n    }\n    \n    vec2 uv1 = fract( ( fragCoord.xy + vec2( 1., .0 )) / resolution );\n    vec2 uv2 = fract( ( fragCoord.xy + vec2( -1., .0 )) / resolution );\n    vec2 uv3 = fract( ( fragCoord.xy + vec2( 0., 1.0 )) / resolution );\n    vec2 uv4 = fract( ( fragCoord.xy + vec2( 0., -1.0 )) / resolution );\n    \n    vec4 inCenter = texture( sampler, uv );\n    float neighbourAvg = \n        texture( sampler, uv1 ).x + \n        texture( sampler, uv2 ).x +\n        texture( sampler, uv3 ).x +\n        texture( sampler, uv4 ).x;\n    float curSpd = inCenter.y - .5;\n    float curAlt = inCenter.x - .5; \n    float spring = neighbourAvg * .25 - .5 - curAlt;\n    spring -= curAlt * .2;\n    curSpd *= .996;\n    curSpd += spring * .32;\n    curSpd += rain * 100.0;\n    curAlt += curSpd * .15;\n    curAlt *= .996;\n    curSpd = clamp( curSpd, -.5, .5 ) + .5;\n    curAlt = clamp( curAlt, -.5, .5 ) + .5;\n    fragColor = vec4( curAlt, curSpd, .0, 1.0 );\n    \n}", "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 79, 609], [611, 611, 633, 633, 1552], [1554, 1554, 1611, 1611, 2869]], "test": "untested"}
{"id": "7dV3W3", "name": "Lava Lamp :)", "author": "SpencerKuan", "description": "A simple shader with mostly PBR lighting. ", "tags": ["raymarching", "pbr"], "likes": 9, "viewed": 267, "published": 3, "date": "1632343202", "time_retrieved": "2024-07-30T18:59:51.824123", "image_code": "/*\n\n\nI originally created this on Khan Academy :)\n\n\n\n*/\n\n\n\n\nprecision lowp float;\nconst vec2 u_res = vec2(1280, 720);\n\n/* uncomment for anti-aliasing: */\n//#define MULTIPASS; \n\n#define pi 3.1415926\n\n//point-light source structure\nstruct Light {\n    vec3 o;\n    vec3 col;\n};\n\n//light ray structure\nstruct lightR {\n    vec3 col;\n    vec3 dir;\n};\n\n//material structure\nstruct material {\n    vec3 albedo;\n    float rough;\n    float metal;\n};\n\n//lights array\nLight lights[4];\n\n//sdBox, sdCone, and smin by Inigo Quilez\nfloat sdBox( vec3 p, vec3 b ) \n{ \n    vec3 q = abs(p) - b; \n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); \n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n\n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat blob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 30.0;\n    float s = clamp((h + 50.0) / 50.0, 0.5, 1.0);\n    return length(p + vec3(i.x, h, i.y)) - i.w * s;\n}\n\n/*float Bblob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 150.0;\n    return length(p + vec3(i.x, h - 20.0, i.y)) - i.w;\n}*/\n\n\n//transparent signed dist func\nfloat tsdf(vec3 p)\n{\n    float shape = max(sdCone(p+vec3(0,-180,0),vec2(sin(.09),cos(.09)),188.0), p.y - 70.0);\n\n    float d = max(shape, p.y - 49.3);\n\n    return d;\n}\n\n\n//main signed dist function\nfloat sdf(vec3 p)\n{\n\n    //time\n    float t = iTime * 0.2;\n\n    //floor\n    float d = p.y + 80.0;\n\n    //pedestal\n    d = min(d, sdBox(p+vec3(0,70,0),vec3(40,10,40)));\n\n    //walls\n    d = min(d, -sdBox(p, vec3(200)));\n\n    //translated blob position\n    vec3 mp = p + vec3(0, -20, 0);\n\n    //lamp components\n    float top = max(sdCone(p+vec3(0,-90,0),vec2(sin(.3),cos(.3)),40.), p.y - 70.0);\n    float bottom = max(sdCone(-p+vec3(0,-49,0),vec2(sin(.4),cos(.4)),40.), -p.y - 50.);\n    float base = sdCone(p+vec3(0,20,0),vec2(sin(.4),cos(.4)),40.);\n\n    //adding the lamp pieces\n    d = min(d, top);\n    d = min(d, bottom);\n    d = min(d, base);\n\n    //lava blobs\n    float b = d;\n\n    b = smin(b, blob(mp, vec4(-6,5,1,5), t), 10.);\n    b = smin(b, blob(mp, vec4(-3,0,2.3,5), t), 10.);\n    b = smin(b, blob(mp, vec4(0,8,3,2), t), 10.);\n    b = smin(b, blob(mp, vec4(0,7,4,2), t), 10.);\n    b = smin(b, blob(mp, vec4(-8,-4,5,3), t), 10.);\n    b = smin(b, blob(mp, vec4(7,0,6,3), t), 10.);\n    b = smin(b, blob(mp, vec4(2,2,7,4), t), 10.);\n\n    //constrain blobs to the container\n    float container = tsdf(vec3(p.xz, clamp(p.y, -3.0, 44.0)).xzy);\n    b = max(b, container + 2.0);\n    b = max(b, p.y - 50.0);\n    b = max(b, -p.y - 10.0);\n\n    d = min(d, b);\n\n    return d;\n}\n\nmaterial getMaterial(vec3 p)\n{\n\n    //walls\n    if(max(abs(p.x), abs(p.z)) > 199.0){\n        return material(\n            vec3(1),\n            0.1,\n            0.0\n        );\n    }\n\n    if(max(abs(p.x), abs(p.z)) < 50.0)\n    {\n        //blob stuff\n        if( p.y > -11.0 && p.y < 49.9 && length(p.xz) < 16.0)\n        {\n            return material(\n                vec3(0.4, 0.1, 0.4),\n                0.1,\n                0.0\n            );\n        }\n\n        //shiny lamp metal\n        if( p.y > -59.5 && p.y < 80.0)\n        {\n            return material(\n                vec3(0.2),\n                0.2,\n                1.0\n            );\n        }\n    }\n\n    return material(\n        vec3(0.1, 0.4, 0.5),\n        1.0,\n        0.0\n    );\n\n}\n\n//normal calculation\nvec3 getNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = sdf(pos);\n    return normalize(vec3(\n        sdf(pos + vec3(h, 0, 0)) - dist1,\n        sdf(pos + vec3(0, h, 0)) - dist1,\n        sdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//glass normal calculation\nvec3 getGlassNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = tsdf(pos);\n    return normalize(vec3(\n        tsdf(pos + vec3(h, 0, 0)) - dist1,\n        tsdf(pos + vec3(0, h, 0)) - dist1,\n        tsdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//create a ray for a given screen position\nvec3 createRay(vec2 pos)\n{\n    return normalize(vec3(pos, 200.0));\n}\n\n//raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 70;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = sdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat glassmarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 20;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = tsdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat shadowmarch(vec3 rc, vec3 ld, float md)\n{\n    const int MAX_STEPS = 50;\n    const float step = 0.1;\n\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        float s = sdf(rc + ld * t);\n        if(t > md) return 1.0;\n        if(s < 0.0) return 0.0;\n        t += max(step, s);\n    }\n\n    return 1.0;\n}\n\n//normal distribution function\nfloat NDF(vec3 h, vec3 n, float a)\n{\n    float a2 = a * a;\n    float dotHN = dot(h, n);\n    float x = dotHN * dotHN * (a2 - 1.0) + 1.0;\n\n    return a2 / (pi * x * x);\n}\n\n//geometry function\nfloat GF(vec3 v, vec3 n, float a)\n{\n    float dotNV = max(dot(n, -v), 0.0);\n    float a2 = a * a;\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n\n    return dotNV / (dotNV * (1.0 - k) + k);\n}\n\n//fresnel function\nvec3 FF(vec3 v, vec3 n, vec3 f0)\n{\n    float x = clamp(1.0 - dot(v, n), 0.0, 1.0);\n    return f0 + (1.0 - f0) * pow(x, 5.0);\n}\n\n//calculate contribution of individual light\nvec3 calcLight (material c, vec3 n, vec3 rd, lightR lr)\n{\n\n    vec3 dir = lr.dir;\n    vec3 l = lr.col;\n\n    //material values\n    vec3 a = c.albedo;\n    float rough = c.rough;\n    float metal = c.metal;\n\n    //halfway vector\n    vec3 h = normalize(rd + dir);\n\n    vec3 f0 = mix(vec3(0.01), a, metal);\n\n    //normal distribution\n    float nd = NDF(dir, n, rough);\n\n    //geometry occulsion\n    float g = GF(dir, n, rough)*GF(rd, n, rough);\n\n    //fresnel\n    vec3 f = FF(-rd, n, f0);\n\n    //some dot products\n    float dotDN = max(dot(-dir, n), 0.0);\n    float dotRN = max(dot(-rd, n), 0.0);\n\n    //specular denominator\n    float specDenom = 2.0 * dotDN * dotRN + .0001;\n    vec3 spec = g * nd * f / specDenom;\n\n    //diffuse contribution\n    vec3 kd = (vec3(1) - f) * (1.0 - metal);\n\n    vec3 fin = ((kd * a / pi) + spec) * l * dotDN;\n    return fin;\n}\n\n//calculate contribution of all lights\nvec3 doLighting(material c, vec3 n, vec3 rc, vec3 rd, bool doShadow)\n{\n    vec3 fCol = vec3(0.0);\n\n    const int len = 4;\n    for(int i = 0; i < 4; i++)\n    {\n        //get the light\n        Light light = lights[i];\n\n        //find light ray direction\n        vec3 dir = normalize(rc - light.o);\n\n        //light radius\n        float r = length(rc - light.o);\n\n        //light brightness (attenuation)\n        float b = 1.0 / r;\n\n        //resulting light ray color\n        vec3 l = light.col * b;\n\n        //light ray\n        lightR lr = lightR(l, dir);\n\n        //shadows\n        float s = doShadow ? shadowmarch(rc, -dir, r) : 1.0;\n\n        //final light contribution\n        vec3 fin = calcLight(c, n, rd, lr) * s;\n\n        fCol += fin;\n    }\n\n    //ambient light\n    fCol += c.albedo * (1.0 - c.metal) * 0.1;\n\n\n    //global directional lighting \n    //const vec3 sCol = vec3(0.1);\n    //const vec3 sDir = normalize(vec3(1, -5, 0));\n    //float s = shadowmarch(rc, -sDir);\n    //fCol += calcLight(c, n, rd, lightR(sCol, sDir))*s;\n\n    //fog\n    float fog = exp(-length(rc) * 0.01);\n\n    return fCol * fog;\n}\n\n//create a matrix\nmat3 yMat(float a){\n    return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 xMat(float a){\n    return mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nvec4 shadeP (float t, vec3 cam, mat3 rot, vec2 unit)\n{\n    //ray initial values\n    vec3 ro = rot * cam;\n    vec3 rd = rot * createRay(unit);\n\n    //raymarch the ray\n    bool hit;\n    float d = raymarch(ro, rd, hit);\n\n\n    //fragment color\n    vec3 col = vec3(0);\n\n    if(!hit){\n        return vec4(col, 1);\n    }\n\n    //find ray collision\n    vec3 rc = ro + rd * d;\n\n    //find collision normal\n    vec3 normal = getNormal(rc);\n\n    //find material\n    material c = getMaterial(rc);\n\n    //raymarch the glass\n    bool glass;\n\n    const material glassMat = material(vec3(1), 0.4, 1.0);\n    const vec3 glassTint = vec3(2, 1, 2);\n\n    float gd = glassmarch(ro, rd, glass);\n    vec3 gc = gd * rd + ro;\n    bool glassVis = gd < d || !hit;\n\n    //shade material\n    col = doLighting(c, normal, rc, rd, true);\n\n    //glass shading\n    if(glass && glassVis)\n    {\n        col *= glassTint;\n        col += doLighting(glassMat, getGlassNormal(gc), gc, rd, false) * 0.1;\n\n\n    }\n\n    //cheap HDR\n    col = col / (col + 1.0);\n\n    //gamma correction\n    col = pow(col, vec3(1.0 / 2.2));\n\n    return vec4(col, 1);\n}       \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set the light positions\n    lights[0] = Light(\n        vec3(80, 10, 100), vec3(200, 100, 100)\n    );\n\n    lights[1] = Light(\n        vec3(120, 80, -130), vec3(250, 250, 500)\n    );\n\n    lights[2] = Light(\n        vec3(-50, 120, 120), vec3(300)\n    );\n\n    lights[3] = Light(\n        vec3(-90, 110, -80), vec3(100, 200, 100)\n    );\n\n    //time increment\n    float t = mod(iTime * 0.4, 2.0 * pi);\n\n    //create rotation matrix\n    mat3 rot = yMat(t) * xMat(sin(t)*.1-0.4);\n\n    //find the screen scale\n    float scale = 2.0 / min(iResolution.x, iResolution.y);\n\n    //create clip-space-ish coordinates\n    vec2 clip = (fragCoord.xy - iResolution.xy / 2.0)*scale;\n\n    //translate clip space into unit space\n    vec2 unit = clip * 100.0;\n\n    //camera position\n    const vec3 cam = vec3(10, -10, -199);\n\n\n    # ifdef MULTIPASS\n        fragColor = (\n            shadeP(t, cam, rot, unit) + \n            shadeP(t, cam, rot, unit + vec2(0.25))\n        ) * 0.5;\n\n    # else\n        fragColor = shadeP(t, cam, rot, unit);\n\n    # endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 514, 546, 546, 638], [640, 640, 679, 679, 763], [765, 765, 804, 938, 1269], [1271, 1271, 1308, 1308, 1447], [1587, 1618, 1638, 1638, 1785], [1788, 1816, 1835, 1847, 3087], [3089, 3089, 3119, 3132, 3831], [3833, 3854, 3880, 3901, 4111], [4113, 4140, 4171, 4192, 4406], [4408, 4451, 4477, 4477, 4519], [4521, 4540, 4588, 4588, 4916], [4918, 4918, 4968, 4968, 5297], [5299, 5299, 5346, 5346, 5615], [5617, 5648, 5684, 5684, 5816], [5818, 5838, 5873, 5873, 6025], [6027, 6046, 6080, 6080, 6172], [6174, 6219, 6276, 6276, 7071], [7073, 7112, 7182, 7182, 8223], [8225, 8243, 8262, 8262, 8329], [8331, 8331, 8350, 8350, 8417], [8419, 8419, 8473, 8498, 9522], [9532, 9532, 9589, 9620, 10625]], "test": "untested"}
{"id": "7sKGW3", "name": "BufferA_001", "author": "catafest", "description": "simple example with one BufferA and old example https://www.shadertoy.com/view/XlSBz3.", "tags": ["shader", "shaders", "buffera", "catafest"], "likes": 0, "viewed": 483, "published": 3, "date": "1632342263", "time_retrieved": "2024-07-30T18:59:52.879301", "image_code": "//Display the buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// the my old example: https://www.shadertoy.com/view/XlSBz3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    // set center for circle\n\tvec2 center = iResolution.xy * 0.5;\n    // set radius of circle\n\tfloat radius = 0.30 * iResolution.y;\n    // create circle with delta and theta function\n    // make delta \n    float d = length(center - uv) - radius;\n    // make theta with color transparency to 0.4 and set 1 for clamp\n    // the clamp is a returned value computed as min(max( x , minVal ), maxVal ).\n\tfloat t = clamp(d, 0.4, 1.0);\n\tfragColor = vec4( t, center, (120,230,0));\n}    ", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 78, 78, 159]], "test": "untested"}
{"id": "sdKGW3", "name": "fake 3d", "author": "jorge2017a2", "description": "fake 3d", "tags": ["fake3d"], "likes": 3, "viewed": 225, "published": 3, "date": "1632340907", "time_retrieved": "2024-07-30T18:59:53.798843", "image_code": "\n//https://iquilezles.org/articles/distfunctions2d\n\n///por jorge2017a2...2021-sep-19\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n//fake 3d =) 2d\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 nubes(vec2 p, vec3 colOut)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    float c1= sdCircle(p-vec2(0.0,0.05), 0.105);\n    float c2= sdCircle(p-vec2(0.15,0.02), 0.065);\n    float c3= sdCircle(p-vec2(-0.15,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.04), vec2(0.22,0.045 ) );\n    \n    float res=unionSDF(c1, c2);\n    res=unionSDF(res, c3);\n    res=differenceSDF(res,b1 );\n    \n    colOut=DrawFigBorde(vec3(1.0), colOut, res );\n\treturn colOut;\n    \n}\n\nvec3 arbol(vec2 uv, vec3 col)\n{\n    float sdbtronco= sdBox(uv-vec2(0.5,0.0), vec2(0.0125,0.05));\n    float sdc1= sdCircle(uv-vec2(0.5,0.1), 0.05 );\n   \n    col=DrawFig(vec3(1.0,0.5,0.0), col, sdbtronco);\n    col=DrawFig(vec3(0.0,0.5,0.0), col, sdc1);\n    return col;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 casav1(vec2 p, vec3 col)\n{\n    float sdbcasa1= sdBox(p-vec2(0.0,0.0), vec2(0.2,0.2));\n    float sdbventana= sdBox(p-vec2(0.1,0.0), vec2(0.05,0.05));\n    float sdbPuerta= sdBox(p-vec2(-0.1,-0.1), vec2(0.05,0.1));\n    float sdt1= sdTriangleIsosceles( -p-vec2(0.0,-0.4),vec2(0.2,0.2) );  \n\n    col=DrawFig(vec3(0.3,0.5,0.0), col, sdbcasa1);\n    col=DrawFig(vec3(0.8,0.7,0.0), col, sdbventana);\n    col=DrawFig(vec3(0.3,0.7,0.3), col, sdbPuerta);\n    col=DrawFig(vec3(0.0), col, sdt1);\n    col= arbol(p-vec2(0.0,-0.1),col);\n    col= arbol(p-vec2(0.2,-0.1),col);  \n    return col;\n}    \n\nvec3 casav2(vec2 p, vec3 col)\n{\n    float sdbcasa1= sdBox(p-vec2(0.0,0.0), vec2(0.2,0.2));\n    float sdbPuerta= sdBox(p-vec2(0.0,-0.05), vec2(0.15,0.15));\n    \n    col=DrawFig(vec3(0.3,0.8,0.9), col, sdbcasa1);\n    col=DrawFig(vec3(0.3,0.7,0.3), col, sdbPuerta);\n    return col;\n}\n\nvec3 casav3(vec2 p, vec3 col)\n{\n    float sdbcasa1= sdBox(p-vec2(0.025,0.05), vec2(0.225,0.25));\n    float sdbPuerta= sdBox(p-vec2(0.0,-0.075), vec2(0.15,0.125));\n    float sdbventana= sdBox(p-vec2(0.0,0.2), vec2(0.15,0.05));\n    \n    col=DrawFig(vec3(1.,0.5,0.2), col, sdbcasa1);\n    col=DrawFig(vec3(0.3,0.7,0.3), col, sdbPuerta);\n    col=DrawFig(vec3(0.0,0.0,1.), col, sdbventana);\n    return col;\n}\n\nvec3 casav4(vec2 p, vec3 col)\n{\n   float sdbcasa1= sdBox(p-vec2(0.0,0.08), vec2(0.3,0.28));\n   float sdbPuerta= sdBox(p-vec2(0.0,-0.05), vec2(0.15,0.15));\n   col=DrawFig(vec3(0.0,0.8,0.9), col, sdbcasa1);\n   col=DrawFig(vec3(0.3,0.1,0.3), col, sdbPuerta);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    vec3 col=vec3(0.0,0.0,1.0);\n   \n    vec2 pos=uv;\n        float horizon = 0.1;   //0.2\n        float fov = .5; \n        float scaling = 0.5;\n\t\n    \n    float theta=radians(15.0);\n    float l;\n    l=1.0/100.0;\n    float xp=pos.x+l*cos(theta);\n    float yp=pos.y+l*sin(theta);\n    \n    vec3 p2 = vec3(xp, fov, yp - horizon);\n    p2= rotate_y(p2, radians(90.0));\n\tvec2 s2p2 = vec2(p2.x/p2.z, p2.y/p2.z) * scaling;\n    \n    s2p2.y=opRep1D(s2p2.y+iTime*0.5, 4.0);\n    s2p2= rotatev2(s2p2, radians(90.0));\n    \n     if (s2p2.y<0.0)\n    { col=vec3(0.01,0.4,0.05);  }\n    else\n    {   col=vec3(0.1,0.1,0.8);// cielo\n        vec2 uv2=uv;\n        uv2.x+=mod(iTime*0.5, 3.0)-1.7;\n        col= nubes(uv2*1.5-vec2(0.0,0.4), col);\n        col= nubes(uv2*1.5-vec2(0.5,0.6), col);\n        col= nubes(uv2*2.5-vec2(-1.5,0.7), col);\n    }\n    \n   if (uv.x<0.0)\n   {col=casav1(s2p2-vec2(0.0,0.0), col);\n    col=casav2(s2p2-vec2(0.40,0.0), col);\n    col=casav3(s2p2-vec2(0.8,0.0), col);\n    col=casav4(s2p2-vec2(1.35,0.0),col);\n      \n   }\n   else\n    {   \n     \n     col=vec3(0.0);  \n    s2p2= -s2p2;\n    col=casav1(s2p2+vec2(0.0,0.0), col);\n    col=casav2(s2p2+vec2(0.40,0.0), col);\n    col=casav3(s2p2+vec2(0.8,0.0), col);\n    col=casav4(s2p2+vec2(1.35,0.0),col);\n    }\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 287, 321, 321, 417], [418, 418, 452, 452, 543], [544, 544, 578, 578, 669], [671, 671, 705, 705, 800], [802, 833, 869, 869, 914], [920, 920, 959, 959, 1003], [1005, 1049, 1096, 1096, 1123], [1124, 1124, 1167, 1167, 1194], [1195, 1195, 1243, 1243, 1271], [1277, 1277, 1339, 1339, 1471], [1473, 1473, 1530, 1530, 1596], [1598, 1598, 1635, 1635, 1715], [1717, 1717, 1752, 1752, 1775], [1777, 1777, 1810, 1810, 2228], [2230, 2230, 2261, 2261, 2498], [2500, 2500, 2551, 2551, 2859], [2861, 2861, 2892, 2892, 3443], [3449, 3449, 3480, 3480, 3729], [3731, 3731, 3762, 3762, 4133], [4135, 4135, 4166, 4166, 4407], [4409, 4409, 4466, 4466, 5842]], "test": "untested"}
{"id": "fdVGDc", "name": "rr", "author": "aliva", "description": "d", "tags": ["ss"], "likes": 4, "viewed": 210, "published": 3, "date": "1632334444", "time_retrieved": "2024-07-30T18:59:54.741323", "image_code": "const float SceneDurationSeconds = 400.;\nconst float Complexity = 18.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.7031, 1500, .0953, .3099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/max(iResolution.x, iResolution.y);\n    uv.x --;\n    uv /= 4.;\n\n    float scene = floor((iTime+98.)/SceneDurationSeconds);\n    vec4 hscene = hash42(vec2(scene));\n    uv += scene;\n    \n    float t = iTime*mix(.01,.06,hscene.y);\n    uv -= t*.5;\n\n    vec2 uvn = C/iResolution.xy-.5;\n    float ds = max(abs(uvn.x), abs(uvn.y))*4.;\n    \n    for (float i = 1.; i < Complexity; ++ i) {\n        vec2 c = floor(uv);\n        vec4 h = hash42(c);\n        vec2 p = fract(uv);\n        vec2 a = abs(p-.5);\n        float sd = .5-max(a.x, a.y);\n        o = h*sqrt(sd)*4.;\n        uv *= 2.;\n        float sc = 1./i;\n        uv += fract(abs(fract(uv.yx/sc+t)-.5)*sc-1.) * sign(hscene.x - .5);\n    }\n  \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 93, 93, 240], [242, 242, 278, 278, 978]], "test": "untested"}
{"id": "NsV3Wc", "name": "Desert mountains v2", "author": "jarble", "description": "A simple desert terrain based on Karang's \"Desert biome\" shader.\n(Here's [url=https://www.shadertoy.com/view/NdcXzn]another version[/url] with a slightly more complicated formula).", "tags": ["procedural", "planet", "mountain", "desert", "biome"], "likes": 5, "viewed": 303, "published": 3, "date": "1632333483", "time_retrieved": "2024-07-30T18:59:55.600027", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 3./2.;\n    float freq = 1./3.;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv) * freq);\n        n1 = abs(n2-n1-.5-amplitude);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = abs(value-n1 * amplitude);\n        freq *= 1.25+freq+1./(1.+amplitude);\n        amplitude *= 1./3.;\n        \n\n        uv = uv.yx-n1/freq;\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\t//int norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tint norLOD = geoLOD;\n    vec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1290], [1293, 1293, 1324, 1324, 1586], [1652, 1652, 1697, 1697, 1983], [1985, 1985, 2023, 2023, 2278], [2280, 2280, 2347, 2347, 2574], [2576, 2576, 2607, 2607, 4051], [4053, 4053, 4110, 4110, 4744]], "test": "untested"}
{"id": "ssG3W3", "name": "Spherical Metropolis", "author": "dr2", "description": "Spherically projected downtown with trucks; mouseable, mouse in lower-right swaps with regular view", "tags": ["projection", "city", "traffic", "skyscraper"], "likes": 25, "viewed": 482, "published": 3, "date": "1632299414", "time_retrieved": "2024-07-30T18:59:56.544502", "image_code": "// \"Spherical Metropolis\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Skyscraper\" series\n    \"Gotham City\"               (XljXR3)\n    \"Pannini Flies Gotham\"      (4s3XzN)\n    \"Urban Growth\"              (XdXcRM)\n    \"Alphaville\"                (XtfczN)\n    \"Alphapolis\"                (4scyDj)\n    \"Urban Smog\"                (NsdGDN)\n*/\n\n#define AA       0  // = 0/1 - optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, qHit, sunDir;\nvec2 cId, cIdT, bIdV, cTimeV;\nfloat dstFar, tCur, cCar, qcCar, cDir, flrHt, bShape, bWid, bWidU, bHt, bHtU, hiMid,\n   tWid, twHt, nFloor, fDayLt, ltMode;\nint idObj;\nconst float pi = 3.14159;\nconst int idBldgF = 1, idBldgC = 2, idTwr = 3, idTwrTop = 4, idRoad = 5, idSWalk = 6, idTrLight = 7,\n   idStLight = 8, idPool = 9, idTrnk = 10, idTree = 11, idCarBdy = 12, idCarWhl = 13;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldgParms ()\n{ //  (based on \"Urban Growth\")\n  if (Hashfv2 (9. * cId) > 0.5 || mod (cId.x, 3.) + mod (cId.y, 3.) != 0.) {\n    bHt = (0.25 * Hashfv2 (13. * cId) + 0.05) * (1. + 0.15 / flrHt) + 0.1;\n    nFloor = floor (bHt * (0.6 + 0.4 * length (sin (0.125 * pi * cId))) / flrHt);\n    bHt = (nFloor + 0.3) * flrHt;\n    bWid = floor ((0.17 + Hashfv2 (11. * cId) * 0.1) / flrHt + 0.5) * flrHt;\n    bShape = Hashfv2 (17. * cId);\n    cIdT = mod (cId + 8., vec2 (16.)) - 8.;\n    hiMid = 0.75 * clamp (4. / max (length (cIdT), 1.), 0., 1.);\n    bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * cId)) / flrHt + 0.5) * flrHt;\n    bHt = (0.5 * Hashfv2 (13. * cId) + 0.05) * hiMid * (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n    bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * cId) - 0.5) * hiMid + 0.05;\n    bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n    bHtU = floor (bHtU / flrHt) * flrHt;\n    bHtU += 0.2 * flrHt * step (0., bHtU);\n    if (cIdT == vec2 (0.)) {\n      bHt = max (bHt, 40.2 * flrHt);\n      bHtU = max (bHtU, 20.2 * flrHt);\n    }\n    tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n  } else {\n    bHt = 0.;\n  }\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 pp, q;\n  vec2 s;\n  float d;\n  q = p;\n  d = q.y;\n  DMINQ (idRoad);\n  pp = p;\n  pp.xz = fract (pp.xz) - vec2 (0.5);\n  q = pp;\n  q.y -= 0.0015;\n  d = PrBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  DMINQ (idSWalk);\n  if (bHt > 0.) {\n    q.y -= bHt - 0.2 * flrHt + 0.0005;\n    if (bShape > 0.25) {\n      d = PrBoxDf (q, vec3 (bWid, bHt, bWid));\n      DMINQ (idBldgF);\n    } else {\n      d = PrCylDf (q.xzy, bWid, bHt);\n      DMINQ (idBldgC);\n    }\n    q.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n    if (bHtU > 0.) {\n      if (bShape > 0.5) {\n        d = max (PrBoxDf (q, vec3 (bWidU, bHtU, bWidU)),\n           - PrBoxDf (q - vec3 (0., bHtU, 0.), vec3 (tWid, 0.1 * flrHt, tWid)));\n        DMINQ (idBldgF);\n      } else {\n        d = max (PrCylDf (q.xzy, bWidU, bHtU),\n           - PrCylDf ((q - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n        DMINQ (idBldgC);\n      }\n    }\n    q.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (q.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      DMINQ (idBldgC);\n    } else if (bShape > 0.7) {\n      d = PrBoxDf (q, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      DMINQ (idBldgF);\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      q.y -= twHt;\n      d = PrCapsDf (q.xzy, 0.3 * flrHt, twHt);\n      DMINQ (((q.y > 0.9 * twHt) ? idTwrTop : idTwr));\n    }\n    if (cIdT == vec2 (0.)) {\n      q = pp;\n      q.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (q.xzy, 0.3, flrHt);\n      DMINQ (idBldgC);\n    }\n  } else {\n    d = PrCylDf (q.xzy, 0.19, 0.005);\n    DMINQ (idPool);\n    q.xz = abs (q.xz) - 0.21;\n    q.y -= 0.7 * flrHt;\n    d = PrCylDf (q.xzy, 0.005, 0.7 * flrHt);\n    DMINQ (idTrnk);\n    q.y -= 0.6 * flrHt;\n    d = PrSphDf (q, 0.4 * flrHt);\n    DMINQ (idTree);\n  }\n  q = pp;\n  q.y -= 0.025;\n  q.xz = mod (q.xz + 0.05, 0.1) - 0.05;\n  s = abs (pp.xz) - vec2 (0.5);\n  d = max (min (PrCylDf (q.xzy, 0.0012, 0.025), PrCylDf ((q - vec3 (0., 0.025, 0.)).xzy, 0.005, 0.0007)),\n     - min (PrBox2Df (pp.xz, vec2 (0.45)), max (PrBox2Df (s, vec2 (0.18)), - PrBox2Df (s, vec2 (0.05)))));\n  DMINQ (idStLight);\n  q = pp;\n  q.y -= 0.023;\n  q.xz = abs (q.xz) - vec2 (0.345);\n  d = PrCylDf (q.xzy, 0.002, 0.02);\n  DMINQ (idTrLight);\n  return dMin;\n}\n\nvec3 CarPos (vec3 p)\n{ // (noncolliding traffic flow from \"Gotham City\")\n  vec3 q, s;\n  float vDir, fqx;\n  s.xz = abs (fract (p.xz) - 0.5) - 0.35;\n  vDir = (cDir == 0. && s.z > 0. || cDir == 1. && s.x < 0.) ? 0. : 1.;\n  if (vDir == 0.) p.xz = vec2 (- p.z, p.x);\n  q = p;\n  fqx = floor (q.x);\n  q.x -= fqx + 0.5;\n  q.z += 3. * fqx;\n  q.z *= sign (q.x);\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * (step (0.6, Hashff (11. * cCar)) + 0.5 * Hashff (13. * cCar));\n  return q;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{  // (simplified version from \"Truck Driving\")\n  vec3 q, qq, b;\n  float d, h, bf, szFac;\n  szFac = 0.06;\n  q = CarPos (p);\n  bf = PrBox2Df (q.xz + vec2 (0., -0.1), vec2 (0.015, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  dMin /= szFac;\n  q /= szFac;\n  q.y -= 0.15;\n  b = vec3 (0.13, 0.09, 0.3);\n  qq = q;\n  b.x -= 0.2 * abs (qq.y + 0.02 * qq.z + 0.01);\n  h = ((qq.z > 0.05) ? 0.21 : 0.13) * abs (qq.z - 0.05);\n  qq.y -= - h;\n  b.yz -= vec2 (h, 0.1 * abs (qq.y - 0.03));\n  d = max (PrBoxDf (qq, b), - PrBoxDf (q - vec3 (0., 0.01, -0.2), vec3 (0.115, 0.05, 0.09)));\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (0.11, 0.2);\n  h = 0.15 * abs (qq.z);\n  qq.y += 0.08 + h;\n  d = max (d, - PrBoxDf (qq, vec3 (0.015, 0.04, 0.06) - vec3 (0., h, 0.06 * qq.y)));\n  d = max (d, bf);\n  if (d < dMin) qcCar = cCar;\n  DMINQ (idCarBdy);\n  qq = q;\n  qq.y -= -0.088;\n  d = PrBoxDf (qq, vec3 (0.13, 0.003, 0.14));\n  d = max (d, bf);\n  if (d < dMin) qcCar = cCar;\n  DMINQ (idCarBdy);\n  qq = vec3 (abs (q.xz) - vec2 (0.118, 0.2), q.y + 0.095).xzy;\n  d = PrRoundCylDf (qq.yzx, 0.048, 0.007, 0.02);\n  d = max (d, bf);\n  DMINQ (idCarWhl);\n  return 0.7 * szFac * dMin;\n}\n\nvec4 CarCol ()\n{\n  vec4 col4;\n  float z, r, s;\n  col4 = vec4 (HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.5,\n     0.4 + 0.6 * vec3 (Hashff (qcCar * 47.)))), 0.5);\n  if (idObj == idCarBdy) {\n    z = abs (qHit.z - 0.05);\n    if (qHit.y > 0.015 && abs (z - 0.078) < 0.072 && (abs (qHit.x) < 0.12 - 0.2 * qHit.y ||\n       qHit.y < 0.085 - 2. * ((qHit.z > 0.05) ? 0.21 : 0.13) * z)) col4 = vec4 (0., 0., 0., -2.);\n    else if (qHit.z < - 0.298 && abs (qHit.y + 0.01) < 0.005 && abs (qHit.x) < 0.125)\n       col4 = vec4 (1., 0., 0., -1.);\n    else if (qHit.z > 0.298 && abs (qHit.y + 0.02) < 0.005 && abs (qHit.x) < 0.125)\n       col4 = vec4 (1., 1., 0.8, -1.);\n    else if (qHit.y < - 0.075 || abs (qHit.y) < 0.085 && z < 0.0008 || \n       abs (qHit.y + 0.009) < 0.031 && abs (qHit.z - 0.201) < 0.0008 ||\n       abs (qHit.y + 0.015) < 0.061 && abs (qHit.z + 0.101) < 0.0008) col4.rgb *= 0.6;\n    else if (qHit.z > 0.28 && abs (qHit.y + 0.05) < 0.015 && abs (qHit.x) < 0.08)\n       col4.rgb *= 1. - 0.3 * step (0.2, cos (80. * pi * qHit.x));\n    else if (qHit.y > -0.05 && abs (qHit.x) < 0.11 && abs (qHit.z + 0.2) < 0.085)\n       col4.rgb *= 0.9 + 0.1 * cos (160. * pi * qHit.x);\n  } else if (idObj == idCarWhl) {\n    s = sign (qHit.z);\n    qHit = vec3 (abs (qHit.xz) - vec2 (0.118, 0.2), qHit.y + 0.095).xzy;\n    r = length (qHit.yz);\n    if (r < 0.02) {\n      qHit.yz = Rot2D (qHit.yz, - pi * tCur * s);\n      if (abs (abs (qHit.y) - abs (qHit.z)) < 0.01) col4 = vec4 (0.9, 0.9, 1., 0.3);\n    } else if (r > 0.03) col4 = vec4 (0.3, 0.3, 0.3, 0.);\n  }\n  return col4;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, rdi;\n  float dHit, d;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = 0.01;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    d = ObjDf (p);\n    dHit += min (d, 0.001 + max (0., Minv2 ((cId + step (0., rd.xz) - p.xz) * rdi.xy)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.00005, -0.00005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  cIdP = vec2 (-999.);\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    h = BldgDf (p, dstFar);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  idObj = idObjT;\n  return sh;\n}\n\nvec4 BldgCol (vec3 vn)\n{\n  vec4 col4;\n  vec2 g;\n  float wFac, f;\n  wFac = 1.;\n  col4 = vec4 (HsvToRgb (vec3 (0.7 * Hashfv2 (19. * cId), 0.2,\n     0.4 + 0.2 * Hashfv2 (21. * cId))), 0.3);\n  if (abs (vn.y) < 0.05) {\n    f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n    wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n       0.801 * step (abs (f), 0.22);\n    if (wFac < 0.2) {\n      f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n         length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n      wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n         (1. + Hashfv2 (51. * cId))), 1.);\n    }\n    col4.rgb *= wFac;\n  } else if (vn.y > 0.95) {\n    g = step (0.05, fract (qHit.xz * 70.));\n    col4.rgb *= mix (0.8, 1., g.x * g.y);\n  }\n  if (vn.y < 0.95 && wFac > 0.5)\n     col4.rgb *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  if (wFac < 0.5) col4.a = -2.;\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  vec2 g, b;\n  float f, ff, y;\n  col4 = vec4 (0.);\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col4 = BldgCol (vn);\n  } else if (idObj == idTwr) {\n    col4 = vec4 (0.3);\n  } else if (idObj == idTwrTop) {\n    col4 = vec4 (1., 0., 0., -2.);\n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col4.rgb = mix (vec3 (0.1, 0.1, 0.12), vec3 (0.1), step (g.x, 0.355));\n    f = ((step (abs (g.x - 0.495), 0.002) + step (abs (g.x - 0.365), 0.002)) +\n       step (abs (g.x - 0.44), 0.0015) * step (fract (g.y * 18. + 0.25), 0.7)) *\n       step (g.y, 0.29);\n    col4.rgb = mix (col4.rgb, vec3 (0.6, 0.5, 0.1), f);\n    f = step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) * step (abs (g.y - 0.32), 0.02);\n    col4 = mix (col4, vec4 (0.7, 0.7, 0.7, 0.2), f);\n    g = abs (g) - 0.493;\n    f = step (0., Minv2 (g));\n    col4 = mix (col4, vec4 (0.7, 0.7, 0.7, 0.2), f);\n    if (fDayLt > 0.5) {\n      b = CarPos (ro).xz;\n      g = abs (b + vec2 (0., -0.1)) - vec2 (0.015, 0.2);\n      if (Maxv2 (g) < 0.) col4 *= 0.6 + 0.4 * smoothstep (0.001, 0.003,\n         length (max (abs (vec2 (b.x, mod (b.y, 0.05) - 0.025)) - 0.06 * vec2 (0.13, 0.3), 0.)));\n    } else {\n      g = abs (fract (qHit.xz) - 0.5);\n      f = 1.3 * (1. - smoothstep (0.05, 0.2, length (g - 0.5)));\n      if (g.x < g.y) g = g.yx;\n      f += step (g.y, 0.35) * (1. - smoothstep (0.02, 0.05,\n         length ((vec2 (0.8 * abs (g.x - 0.437) - 0.015, mod (g.y + 0.05, 0.1) - 0.05)))));\n      col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.7), 0.2 * f);\n    }\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col4.rgb = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n    if (bHt > 0.) {\n      f = ((bShape > 0.25) ? max (abs (qHit.x), abs (qHit.z)) : length (qHit.xz)) - bWid;\n      if (f < 0.02) col4.rgb *= 2.;\n      else if (f < 0.025) col4 = vec4 (vec3 (1., 1., 0.7) * max (0.5 - 0.5 * rd.y, 0.), -1.);\n    } else {\n      if (length (abs (qHit.xz) - 0.21) < 0.01) col4.rgb *= 0.7;\n    }\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) / pi + 1.) + 0.5;\n    ff = floor (f);\n    y = qHit.y - 0.014;\n    if (abs (y) < 0.004 && abs (f - ff) > 0.3) {\n      col4 = vec4 (mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.), step (0., y)), -1.);\n      col4.rgb *= 1. - 0.8 * step (0., y * sign (cDir - 0.5) * sign (mod (ff, 2.) - 0.5));\n    } else {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.5);\n    }\n  } else if (idObj == idStLight) {\n    if (qHit.y > 0.024 && vn.y < 0.1) {\n      col4 = vec4 (vec3 (0.8, 0.8, 0.4) * (0.7 - 0.3 * vn.y), -1.);\n    } else {\n      col4 = vec4 (vec3 (0.5, 0.5, 0.55) * (1. + 0.3 * sin (128. * 2. * pi * qHit.y)), 0.5);\n    }\n  } else if (idObj == idPool) {\n    col4 = (length (qHit.xz) < 0.18) ? vec4 (0.4, 0.4, 0.5, -2.) :\n       vec4 (0.2, 0.3, 0.5, 0.1) * (0.6 + 0.4 * fDayLt);\n  } else if (idObj == idTrnk) {\n    col4 = vec4 (0.4, 0.2, 0., 0.1);\n  } else if (idObj == idTree) {\n    col4 = vec4 (0., 0.5, 0.1, 0.1);\n  } else if (idObj == idCarBdy || idObj == idCarWhl) {\n    col4 = CarCol ();\n    if (idObj == idCarBdy && fDayLt < 0.5 && col4.a > 0.) {\n      g = abs (fract (ro.xz) - 0.5);\n      f = 1.3 * (1. - smoothstep (0.05, 0.2, length (g - 0.5)));\n      if (g.x < g.y) g = g.yx;\n      f += step (g.y, 0.35) * (1. - smoothstep (0.02, 0.05, length ((vec2 (0.8 *\n         abs (g.x - 0.437) - 0.015, mod (g.y + 0.05, 0.1) - 0.05)))));\n      col4.rgb = mix (col4.rgb, vec3 (0.7, 0.7, 0.5), 0.4 * f);\n    }\n  }\n  return col4;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{  // (from \"Dark Heart\", etc)\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 6. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 dyCol, ntCol, col, skCol, sunCol, p, rds, mDir, vn, clCol;\n  float ds, fd, att, attSum, d, sd, mRad, bs, ts, f, ff;\n  rd.y = (rd.y + 0.1) / 1.1;\n  rd = normalize (rd);\n  col = vec3 (0.6);\n  if (rd.y >= 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    if (ltMode == 0.) {\n      p += ro;\n      p.xz += 4. * tCur;\n      p *= 0.01;\n      ff = Fbm2 (p.xz);\n      f = smoothstep (0.2, 0.8, ff);\n      fd = smoothstep (0.2, 0.8, Fbm2 (p.xz + 0.01 * sunDir.xz)) - f;\n      clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n         smoothstep (0., 0.05, abs (fd)));\n      skCol = vec3 (0.4, 0.5, 0.8);\n      sd = max (dot (rd, sunDir), 0.);\n      skCol = mix (skCol, vec3 (1., 1., 0.8), step (0.1, sd) *\n           0.5 * pow (sd, 128.) + 0.8 * pow (sd, 2048.));\n      col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n    } else {\n      ds = 0.1 * sqrt (length (p));\n      p += ro;\n      fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n      p.xz *= fd;\n      p.xz += 0.1 * tCur;\n      att = 2. * Fbm2 (p.xz);\n      attSum = att;\n      d = fd;\n      ds *= fd;\n      for (int j = 0; j < 4; j ++) {\n        attSum += 2. * Fbm2 (p.xz + d * sunDir.xz);\n        d += ds;\n      }\n      attSum *= 0.3;\n      att *= 0.3;\n      sd = clamp (dot (sunDir, rd), 0., 1.);\n      skCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n      sunCol = vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n      col = mix (vec3 (0.5, 0.75, 1.), skCol, exp (-2. * (3. - sd) *\n         max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n      attSum = 1. - smoothstep (1., 9., attSum);\n      col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n         vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n    }\n    if (fDayLt < 0.5) {\n      dyCol = col;\n      mDir = normalize (vec3 (-0.5, 0.2, 0.2));\n      mRad = 0.03;\n      ntCol = mix (vec3 (0.1, 0.1, 0.), vec3 (0.02, 0.02, 0.04), smoothstep (0., 0.05, abs (rd.y)));\n      ntCol += vec3 (0.06, 0.04, 0.02) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n      bs = dot (rd, mDir);\n      ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n      if (ts > 0.) {\n        ts = bs - sqrt (ts);\n        if (ts > 0.) {\n          vn = normalize ((ts * rd - mDir) / mRad);\n          ntCol += 0.8 * vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (0.5, 0.4, -0.77), vn) *\n             (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n        }\n      } else ntCol += StarPat (rd, 8.);\n      col = mix (ntCol, dyCol, smoothstep (0.3, 0.5, fDayLt));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rdr;\n  vec2 g, vf;\n  float dstObj, sh, s, f;\n  flrHt = 0.07;\n  vf = vec2 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    cId = floor (ro.xz);\n    SetBldgParms ();\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      if (idObj == idRoad) vf = vec2 (512., 1.);\n      else if (idObj == idBldgF || idObj == idBldgC) vf = vec2 (512., 0.5);\n      else if (idObj == idTrnk) vf = vec2 (256., 0.5);\n      else if (idObj == idTree) vf = vec2 (128., 2.);\n      else if (idObj == idSWalk && bHt == 0.) {\n        s = length (qHit.xz) - 0.2;\n        vn = normalize (vec3 ((1. - smoothstep (0., 0.02,\n           abs (s))) * sign (s) * normalize (qHit.xz), 2.)).xzy;\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n      sh = (fDayLt > 0.5) ? mix (1., 0.5 + 0.5 * ObjSShadow (ro, sunDir), fDayLt) : 1.;\n      col = col * (0.3 + 0.3 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.2 * max (vn.y, 0.) + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         step (0.95, sh) * col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      if (idObj == idBldgF || idObj == idBldgC) col *= 0.5 + 0.5 * smoothstep (0.3, 0.7, fDayLt);\n      if (fDayLt > 0.5) col *= vec3 (1., 0.9, 0.8);\n    }\n    if (col4.a == -2.) {\n      rdr = reflect (rd, vn);\n      g = Rot2D (rdr.xz, 5.1 * atan (20. + cId.y, 20. + cId.x));\n      f = step (1., 0.3 * ro.y + 4. * rdr.y -\n         0.1 * floor (5. * IFbm1 (0.6 * atan (g.y, g.x) + pi) + 0.05));\n      if (idObj == idBldgF || idObj == idBldgC) {\n        if (ltMode == 3.) {\n          col *= 0.5 + 3.5 * floor (2. * Hashff (73. * (floor (qHit.y / flrHt) -\n             floor (0.5 * nFloor * tCur))));\n        } else {\n          if (f == 1.) col = mix (0.3 * col, BgCol (ro, rdr), 0.5);\n          else col *= 0.3;\n          if (fDayLt < 1.) {\n            s = Hashfv2 (37. * cId);\n            f = step (fDayLt, 0.2 + 0.3 * Hashfv2 (47. * cId));\n            col = mix (0.2 * col, vec3 (0.5 + 0.2 * s, 0.6 - 0.4 * s, 0.3), f);\n          }\n        }\n      } else if (idObj == idPool) {\n        if (f == 1.) col = 0.9 * BgCol (ro, rdr);\n        else col *= 0.3;\n      } else if (idObj == idCarBdy) {\n        if (f == 1.) col = mix (0.3 * col, BgCol (ro, rdr), 0.5);\n        else col *= 0.3;\n        col = mix (vec3 (0.2, 0.1, 0.), col, fDayLt);\n      }\n    }\n    if (col4.a == -2.) col *= 1. - 0.95 * smoothstep (0.4, 0.7, dstObj / dstFar);\n    if (ltMode == 0.) col = mix (col, vec3 (0.3), smoothstep (0.6, 1., dstObj / dstFar));\n    else col = mix (col, BgCol (ro, rd), smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{ \n  vec3 p;\n  float pLen, s, cCount;\n  pLen = 2.;\n  p.y = 0.1 + 2.5 * SmoothBump (0.2, 0.8, 0.1, mod (0.05 * t, 1.));\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= pLen;\n  return p;\n}\n\nvoid FlyerPM (float s)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, ca, sa;\n  float ds, rlFac, elFac, el, az, rl;\n  ds = 0.12;\n  elFac = 0.7;\n  rlFac = 0.02;\n  fpF = 0.5 * (TrackPath (s + 2. * ds) + TrackPath (s + ds));\n  fpB = 0.5 * (TrackPath (s - 2. * ds) + TrackPath (s - ds));\n  vel = normalize (fpF - fpB);\n  acc = (fpF - 2. * TrackPath (s) + fpB) / (2.25 * ds * ds);\n  flPos = 0.5 * (fpF + fpB);\n  va = cross (acc, vel);\n  el = - elFac * asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = rlFac * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\n#define LT_MODE  4  // = 0/1/2/3/4 - different lighting modes (day, sunset, night, etc)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur, ds4;\n  vec3 ro, rd, col, vuPos;\n  vec2 canvas, uv, uvv, ut, mSize, mMid, msw;\n  float zmFac, el, az, asp, sr, cTime, spd, regId;\n  int vuMode;\n  bool sphProj, show;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 7200.) + floor (dateCur.w / 7200.);\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid = vec2 (asp - mSize.x, - 1. + mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuMode = 0;\n  if (Maxv2 (ut) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuMode = 1 - vuMode;\n  }\n  el = 0.;\n  az = 0.001 * pi;\n  if (mPtr.z > 0.) {\n    msw = (mPtr.xy * vec2 (asp, 1.) - 0.5 * mMid) / mSize;\n    regId = 0.;\n    if (Maxv2 (abs (msw)) < 0.5) regId = 1.;\n    else msw = mPtr.xy;\n    if (vuMode == 0) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n    if (regId == 1.) vuMode = 1 - vuMode;\n  }\n  sphProj = (vuMode == 0);\n  spd = 0.2;\n  FlyerPM (spd * tCur);\n  vuPos = flPos;\n  vuPos.xz += 0.01;\n  ltMode = clamp (float (LT_MODE), 0., 4.);\n  fDayLt = (ltMode == 4.) ? SmoothBump (0.2, 0.8, 0.1, mod (tCur / 20., 1.)) :\n     ((ltMode < 2.) ? 1. : 0.);\n  sunDir = normalize ((ltMode == 0.) ? vec3 (1., 2., -1.) : vec3 (1., 0.5, -1.));\n  cTime = 0.15 * tCur;\n  cDir = mod (floor (cTime), 2.);\n  cTimeV = vec2 (floor (0.5 * floor (cTime)), fract (cTime));\n  if (sphProj) az += pi;\n  else el -= 0.2 * pi * smoothstep (1., 2., vuPos.y);\n  vuMat = StdVuMat (el, az);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    show = true;\n    if (sphProj) {  // (from \"Dolphin Orb\")\n      dstFar = 16.;\n      ds4 = SphHit (vuMat * vec3 (0., 0., -8.2), vuMat * normalize (vec3 (uvv, 8.)), 1.);\n      if (ds4.x < dstFar) rd = ds4.yzw * vec3 (-1., 1., 1.);\n      else show = false;\n    } else {\n      zmFac = 1.8;\n      rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / (asp * zmFac))) * asp * zmFac,\n         uvv.y, zmFac));\n    }\n    if (show) {\n      dstFar = 50.;\n      col += (1. / naa) * ShowScene (vuPos, rd * flMat);\n    } else col += (1. / naa) * vec3 (0., 0., 0.1);\n  }\n  if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 2.) col = vec3 (0.2, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssG3W3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1683, 1683, 1705, 1735, 2805], [2807, 2807, 2842, 2842, 5081], [5083, 5083, 5105, 5155, 5662], [5664, 5664, 5698, 5744, 6835], [6837, 6837, 6853, 6853, 8397], [8399, 8399, 8421, 8421, 8522], [8524, 8524, 8557, 8557, 9092], [9094, 9094, 9115, 9115, 9374], [9376, 9376, 9413, 9413, 9857], [9859, 9859, 9883, 9883, 10804], [10806, 10806, 10847, 10847, 14354], [14356, 14356, 14391, 14420, 14873], [14875, 14875, 14906, 14906, 17517], [17519, 17519, 17554, 17554, 20287], [20289, 20289, 20315, 20315, 20724], [20726, 20726, 20750, 20750, 21514], [21516, 21516, 21559, 21559, 21760], [21851, 21851, 21907, 21907, 24494], [24496, 24496, 24528, 24528, 24628], [24630, 24630, 24663, 24663, 24752], [24754, 24754, 24787, 24787, 24814], [24816, 24816, 24858, 24858, 24909], [24911, 24911, 24968, 24968, 25044], [25046, 25046, 25089, 25089, 25153], [25155, 25155, 25177, 25177, 25204], [25206, 25206, 25228, 25228, 25255], [25257, 25257, 25279, 25279, 25317], [25319, 25319, 25376, 25376, 25459], [25461, 25461, 25497, 25497, 25703], [25705, 25705, 25735, 25735, 25848], [25850, 25850, 25874, 25874, 25991], [26025, 26025, 26049, 26049, 26086], [26088, 26088, 26112, 26112, 26172], [26174, 26174, 26198, 26198, 26251], [26253, 26253, 26277, 26277, 26389], [26391, 26391, 26415, 26415, 26558], [26560, 26560, 26585, 26585, 26731], [26733, 26733, 26758, 26758, 26944], [26946, 26946, 26971, 26971, 27196], [27198, 27198, 27220, 27220, 27374], [27376, 27376, 27399, 27399, 27563], [27565, 27565, 27586, 27586, 27741], [27743, 27743, 27772, 27772, 27984], [27986, 27986, 28025, 28025, 28277]], "test": "untested"}
{"id": "fdy3Dc", "name": "triangle wave vfx", "author": "pugbyte", "description": "Simple example replicating the damage indicator from here: https://www.youtube.com/watch?v=xvuTdf-GGs4&t=29s", "tags": ["2d"], "likes": 2, "viewed": 262, "published": 3, "date": "1632287198", "time_retrieved": "2024-07-30T18:59:57.442102", "image_code": "// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://en.wikipedia.org/wiki/Triangle_wave\nfloat triangleWave(float t, float period) {\n    return 2. * abs(t/period - floor(t/period + .5));\n}\n\nfloat edgeEffect(float x, float y, float scale, float iTime) {\n    \n    // Make these shader uniforms and use game logic to manipulate the effect\n    float period = .07;\n    float amplitude = .07;\n    float border = mix(.0, .2, sin(iTime)*.5+.5);\n    float wave = mix(.0, .06, sin(x*scale*15.+iTime*10.)*.5+.5);\n    float shift = -iTime*.3;\n    \n    float ty = triangleWave(scale*(x+shift), period);\n    \n    return step(1.-abs(y), scale*(ty*amplitude+border+wave));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    float aspectRatio = iResolution.y/iResolution.x;\n    \n    vec3 col = vec3(0);\n    vec3 rainbow = hsv2rgb(vec3(iTime*.1, .9, .9));\n    \n    // top/bottom\n    col = mix(col, rainbow, edgeEffect(uv.x, uv.y, 1., iTime));\n    // left/right\n    col = mix(col, rainbow, edgeEffect(uv.y, uv.x, aspectRatio, iTime));\n\n    // Gamma correction\n    col = pow(max(col,0.), vec3(1./2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 81, 81, 250], [252, 299, 342, 342, 398], [400, 400, 462, 545, 868], [870, 870, 927, 978, 1469]], "test": "untested"}
{"id": "ssy3WV", "name": "Segment Park", "author": "Yusef28", "description": "Experimenting with Segments. Feels a lot like a Byt3_m3chanic knock off and that's ok with me.\nThe trace, doColor and getSky routines are from shane. Copied, pasted, and modified a bit.\nDistance to line segment derivation is commented in common tab.\nmouse", "tags": ["segment"], "likes": 17, "viewed": 328, "published": 3, "date": "1632278469", "time_retrieved": "2024-07-30T18:59:58.541164", "image_code": "\nfloat mid = 0.;\n\nfloat cyl(vec3 p, float r, float h){\n    return max(length(p.xz) - r, abs(p.y)-h);\n}\n\nfloat spinnerCage(vec3 p, float id){\n\n   // p.xz +=0.5;\n    //unit of rotation \n    float a0 = float(floor(8. + 6.*(1.-id))) / pi; \n    //create an id for each \n    float a = round(atan(p.z, p.x) * a0) / a0;\n    \n    //push p to a new location along the vector (c,0,s) \n    //scaled by whatever\n    p = p - vec3(cos(a), 0.0, sin(a))/2.6 ;\n\n    \n    float segs = seggy(p-vec3(0.,-0.0,0.), vec3(0.), vec3(0.,0.14,0.));\n\n    \n    return segs;\n}\n\n\nfloat spinner(vec3 p){\n    float dist;\n    \n    vec3 sp = p;\n    \n    //T\n    sp.xz += +0.5;\n    sp.y += 0.3;\n    \n    \n    vec2 id = floor(sp.xz);\n    float ii = noise(id);\n    sp.y += ii*0.4+sin(iTime*ii)*0.3;\n    \n    sp.xz = mod(sp.xz+0.5,2.)-1.;//fract(sp.xz)-0.5;\n    \n    //R\n    sp.xz *= rot(iTime*(0.3+ii)*3.);\n    dist = cyl(sp,0.4,0.01);\n    \n    float node = cyl(sp-vec3(0.2,0.05,0.2),0.05,0.01);;//length(sp-vec3(0.2,0.05,0.2))-0.05;\n    dist = min(dist,node);\n    \n    float base = cyl(sp-vec3(0.,-0.4,0.),0.05, 0.4);\n    dist = min(dist,base);\n    \n    float cage = spinnerCage(sp,ii);\n    dist = min(dist,cage);\n    \n    float top = cyl(sp-vec3(0.,0.14,0.),0.4,0.01);\n    float cut = cyl(sp-vec3(0.,0.14,0.),0.36,0.014);\n    top = max(top, -cut);\n    dist = min(dist,top);\n    return dist;\n\n}\n\nfloat glow = 0.;\nfloat map(vec3 p){  \n\t\n    p.y+=0.9;\n    \n    float sphere_radius = 0.35;\n    vec3 sp = p;\n    float alle  = 1000.;\n    \n    sp = p;\n    sp.y += 0.5;\n    vec3 csp = sp;\n    sp.xz = fract(p.xz)-0.5;\n    \n    ////////////////////CYL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    float ride = spinner(p);\n    \n    \n    /////////////////////SEGS////////////////////////////\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t =  iTime/6.;\n    \n    \n    float gross = 1.3;\n    float depth = 0.6;\n    \n    float height = fbm2(id+t)*gross+depth;\n    float heightL = fbm2((id + vec2(0.,1.))+t)*gross+depth;\n    float heightR = fbm2((id + vec2(0.,-1.))+t)*gross+depth;\n    float heightV = fbm2((id + vec2(-1.,0.))+t)*gross+depth;\n    float heightH = fbm2((id + vec2(1.,0.))+t)*gross+depth;\n    \n    vec3 vor = vec3(-1.,heightV,0.);\n    vec3 hin = vec3(1.0,heightH,0.0);\n    vec3 links = vec3(0.,heightR,-1.);\n    vec3 rechts = vec3(0., heightL,1.0);\n    vec3 zentrum = vec3(0.,height,0.);\n    \n    \n    float k = seggy(sp, zentrum, vor);\n    float segs = k;\n    k = seggy(sp, zentrum, links);\n    segs = min(segs, k);\n    k = seggy(sp, zentrum, rechts);\n    segs = min(segs, k);\n    k = seggy(sp, zentrum, hin);\n    segs = min(segs, k);\n    \n    k = seggy(sp, zentrum, vec3(0.,-depth,0.));\n    segs = min(segs, k);\n    \n    alle = min(segs,alle);\n    \n    //#######################BALL0000000000000000000000000000000000\n    \n    \n    float ball = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.02;\n    \n    \n    \n    alle = min(alle, ball);\n    \n    ////////////////PLANE_____________________________________\n    float plane = sp.y+0.6;\n    \n    ////////////////////ID@!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    if(plane < alle && plane < segs && plane < ride)mid = 2.;\n    else if(ball < plane && ball < segs && ball < ride){\n        mid = 1.;\n        //glow += (0.00001/(0.75*pow((ball),2.)));\n        }\n    else if (segs < plane && segs < ball && segs < ride)mid = 0.;\n    else if (ride < plane && ride < ball)mid = 3.;\n    \n    //float ride = \n    alle = min(alle,ride);\n    return min(alle, plane);//-fbm4(p.xz));\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 196; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001 || t>FAR) break;        \n        t += d*0.5;\n    }\n    \n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 14; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n/*\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(\n    vec3(map(p + e.xyy) - map(p - e.xyy), \n    map(p + e.yxy) - map(p - e.yxy),\t\n    map(p + e.yyx) - map(p - e.yyx)));\n}*/\n\nvec3 getNormal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(0.001,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\n\n//doColor routine from Shane\nvec4 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = 0.5+0.5*cos(vec3(1.,2.,4.)+hash13(floor(sp.xzx+0.54))*10.);//getObjectColor(sp);\n    if(mid == 1.)objCol = vec3(.3,0.,0.7);\n    else if(mid == 2.){\n        float checkX = floor(sp.x*2.+0.5);\n        float checkY = floor(sp.z*2.+0.5);\n    \n        objCol = vec3(mod(checkX+checkY,2.))*0.5+0.25;\n        }\n    else if(mid == 3.)objCol = 0.5+0.5*cos(vec3(7.,4.,2.)+hash13(floor(sp.xzx+0.5))*10.);\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*3. + .15) + vec3(1., 0.95,1.)*spec*3.) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    vec3 sky = mix(vec3(0.8,0.3,0.0),vec3(0.),clamp(sp.y,0.,3.));\n    \n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return vec4(sceneCol,fogF);\n    \n}\n\n//Sky routine from Shane\nvec3 getSky(vec3 ro, vec3 rd){\n\n    vec3 sunDir = normalize(vec3(0.,-.5,1.));\n    float sun = max(dot(rd,sunDir),0.);\n    float horiz = pow(1.-max(rd.y,0.), 3.)*0.35;\n    \n    vec3 col = mix(vec3(0.09, 0.2, 0.5), \n                   vec3(0.7, 0.37, 0.035), \n                       sun*0.75);\n                       \n   col =  mix(col, vec3(1, 0.9,0.7), horiz);\n   //col =  mix(col, vec3(0.3,0.,0.), rd.y+0.1);\n   \n   col += 0.25*vec3(1.,0.7,0.4)*pow(sun,5.);\n   col += 0.25*vec3(1.,0.8,0.6)*pow(sun,64.);\n   col += 0.25*vec3(1.,0.9,0.7)*max(pow(sun,512.),0.3);\n   \n    vec3 sc = ro + rd*FAR*100.; \n    sc.y *= 3.;\n    \n    \n   return mix(col,vec3(1.,0.95,1.),\n              0.95*smoothstep(0.,1.,fbm4(.001*sc.xy))\n              *clamp(rd.y*4.,0.,1.));\n                   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    float PosX = 1.0 - iMouse.x/iResolution.x*4. + .5;//0.2*2.*(rechts - links);\n    float PosY = 1.0 - iMouse.y/iResolution.y*4. + 0.5;\n    cs = cos(PosX), si = sin(PosX);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    //cs = cos(PosY), si = sin(PosY);\n    //rd.yz = mat2(cs, si, -si, cs)*rd.yz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., -2.+iTime);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 5., -0.5);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n   \n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n\n\n    vec4 stuff = doColor(ro, rd, sn, lp, t);\n    vec3 sceneColor = stuff.xyz;\n    float fog = stuff.w;\n    \n    vec2 st = (fragCoord.xy)/iResolution.y;\n    float vig = st.x*st.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15);\n    \n    \n    vec3 sky = getSky(ro,rd);\n    \n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n   sceneColor *= sh;\n    \n    rd = reflect(rd,sn);\n    vec3 reflected_stuff = texture(iChannel1,rd).rgb;\n    \n    sceneColor += reflected_stuff*0.13;\n    \n\n    \n    sceneColor = mix(sceneColor, sky, fog);\n    \n   // sceneColor = acesFilm(sceneColor);\n    //sceneColor += glow*0.003;\n\tfragColor = vec4(sqrt(clamp(sceneColor*vig, 0., 1.)), 1);\n  \n    \n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)\n#define FAR 20.\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n    return f/0.9375;\n}\nfloat fbm2( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    //f += 0.1250*noise( p ); p = m*p*2.01;\n    //f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //A point along a line segement from a to b\n    //P = A + t*(B-A);\n    \n    //the fact that the closest dstance from a point\n    //to te line will make a vector perpendicular\n    //that meansthe dot of that vector and the original\n    //line will be 0 (P-P3) is a vector from the best \n    //point on the line P3, to point in question P\n    //dot((P-P3),(B-A)) = 0\n    \n    //So we want to find the point on the line\n    //that is also the end point to a perpendicular\n    //line leading to out point in question\n    //so we substitute the point in question P\n    //with what P is in the first equation:\n    \n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    \n    //we expand by dotting (B-A) with everything in the\n    //first pair of bracekts:\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    \n    //Rearrange\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    \n    //get t by it's self. That's the t value that leads to\n    //the Point on the third line that will give us\n    //a perp line to the point in question P\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    \n    //from our derivation we know we'll use\n    //these two vectors in our calculation\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    //getting t\n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n    \n    //getting point 3\n    vec3 P3 = A + t*BA;       \n    \n    //getting the dist from point in question to\n    //the best point on line and subtracting some stuff\n    //to get the right radius\n    float dist = length(P - P3) - 0.003 - 0.01;\n    //returning dist\n    return dist;\n    \n    //nothing else happends in this function...\n    \n    //still nothing...\n    \n    //and then suddenly!...\n    \n    //nope still nothing.\n}\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssy3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 54, 54, 102], [104, 104, 140, 183, 545], [548, 548, 570, 570, 1356], [1375, 1375, 1393, 1393, 3531], [3532, 3532, 3562, 3562, 3751], [3753, 3753, 3797, 3914, 5211], [5418, 5418, 5441, 5441, 5644], [5646, 5675, 5745, 5745, 7342], [7344, 7369, 7399, 7399, 8142], [8143, 8143, 8199, 8227, 10123]], "test": "untested"}
{"id": "fsyGD3", "name": "Animated Subdivision", "author": "Tater", "description": "Cleaned up the code thanks to @0b5vr", "tags": ["2d", "squares", "subdivide"], "likes": 30, "viewed": 672, "published": 3, "date": "1632258638", "time_retrieved": "2024-07-30T18:59:59.337036", "image_code": "// Fork of \"Rectagular Subdivisor\" by Tater. https://shadertoy.com/view/7sV3WD\n// 2021-09-21 21:08:49\n\n#define pi 3.1415926535\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return max(d.x,d.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime*1.2,6000.);\n    float px = 1./iResolution.y;\n    \n    vec2 dMin = vec2(-0.5);\n    vec2 dMax = vec2(0.5);\n    dMin.x*=R.x/R.y;\n    dMax.x*=R.x/R.y;\n    vec2 dim = dMax - dMin;\n    float id = 0.;\n    float ITERS = 14.;\n    float seed = floor(t/ITERS)+0.2;\n\n    float a;\n    t = mod(t,ITERS);\n    \n    float MIN_SIZE = 0.015;\n    //float ITERS = its;\n    float BORDER_SIZE = 0.003;\n    float MIN_ITERS = 1.;\n    float borderSize = 0.003;\n\n    //BIG THANKS to @0b5vr for letting me use his cleaner subdiv formula\n    //https://www.shadertoy.com/view/NsKGDy\n    \n    for(float i = 0.;i<ITERS;i++){\n        // divide the box into quads\n        vec2 divHash = vec2(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed ))\n        );\n        vec2 divide = divHash * dim + dMin;\n        \n        //Clamp division line\n        //Interestingly this doesn't work as expected but the result is more interesting\n        //If you include a 1.01 factor on the MINE_SIZE it will divide nearly all the space\n        divide = clamp(divide, dMin + MIN_SIZE, dMax - MIN_SIZE);\n        \n        //Un-altered division line for coloring moving cells \n        vec2 divideFull = divide;\n        \n        //Find the minimum dimension size\n        vec2 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min( minAxis.x, minAxis.y);\n        \n        //if minimum dimension is too small break out\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > MIN_ITERS) { break; }\n        \n        //If the current iteration is the leading one smooth the division line\n        float tt = smoothstep(0.,1.,fract(t));\n        if(i == floor(t) &&mod(t,2.0)<1.0){\n            divide=mix(dMin,divide,tt);\n        }\n        else if(i == floor(t)){\n            divide=mix(dMax,divide,tt);\n        }\n        if(i>floor(t)) break;\n\n        // update the box domain\n        dMax = mix( dMax, divide, step( uv, divide ));\n        dMin = mix( divide, dMin, step( uv, divide ));\n\n        // id will be used for coloring and hash seeding\n        //vec2 diff = mix( -divide, divide, step( uv, divide));\n        vec2 diff2 = mix( -divideFull, divideFull, step( uv, divide));\n        id = length(diff2+10.0)*100.0;\n        \n        // recalculate the dimension\n        dim = dMax - dMin;\n\n    }\n    //Shrink boxes if before changing seed\n    float shr =1.0-abs(pow(abs(cos(t*pi/ITERS)),100.0));\n    //Calculate 2d box sdf\n    vec2 center = (dMin + dMax)/2.0;\n    a = box(uv-center,dim*0.5*shr);\n    \n    //Color box\n    id = h11(id)*1000.0;\n    vec3 e = vec3(0.5);\n    vec3 al = pal(id*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n    col = clamp(al,0.,1.);\n    col-=smoothstep(-px,px,a+borderSize);\n    //col = vec3(-a*10.0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 147, 147, 218], [219, 219, 240, 240, 292], [293, 306, 373, 373, 412], [413, 413, 439, 439, 489], [490, 490, 547, 547, 3449]], "test": "untested"}
{"id": "NdGGD3", "name": "ufo hat", "author": "jorge2017a2", "description": "ufo hat", "tags": ["ufohat"], "likes": 9, "viewed": 267, "published": 3, "date": "1632256691", "time_retrieved": "2024-07-30T19:00:00.197734", "image_code": "//----------image\n//por jorge2017a1-\n//referencia https://iquilezles.org/www/index.htm\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sminPoynomial( float a, float b )\n{   // polynomial \n    const float k = 0.5;\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nfloat sminExponential( float a, float b )\n{   // exponential\n    const float k = 5.8;\n    return -log(exp(-k*a)+exp(-k*b))/k;\n}\n\n//corregido por gest,  --1-feb-2024\nfloat sdHat(vec3 p) \n{\n\tfloat d, d1, d_cut;\n\t\n\td = sdTorus(p, vec2(10.0,4.0) );\n\td = abs(d) - 0.5;\n\td_cut = -p.y + 0.;\n\td = max(d, -d_cut);\n\t\n\td1 = sdSphere( p, 6.0);\n\td1 = abs(d1) - 0.5;\n\td_cut = p.y - 0.;\n\td1 = max(d1, -d_cut);\n\treturn  min(d, d1);\n}\n\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+1.0;  //piso inf\n    p.y=p.y-7.0;\n    \n    float tt=mod(iTime*5.0,50.0);\n    float gr= clamp(tt,0.0,70.0);\n    gr=radians(gr);\n    p=rotate_x(p, gr);\n    \n    mObj.uvP= vec2(atan(p.x, p.z), p.y * 0.3);\n    /*\n    //restar el mayor\n    float sdt1a= sdTorus(p, vec2(10.0,4.0) );\n    float sdt2= sdTorus(p, vec2(9.0,4.0) );\n    \n    //---mas chicos\n    float sdt1b= sdTorus(p, vec2(9.5,4.0) );\n    float sdt1c= sdTorus(p, vec2(9.0,4.0) );\n    float sdt1d= sdTorus(p, vec2(8.0,4.0) );\n    float sdt1e= sdTorus(p, vec2(7.0,4.0) );\n    \n    float sds1=sdSphere( p, 5.0 );\n    float sdb2= sdBox( p-vec3(0.0,-3.0,0.0), vec3(6.0,3.0,6.0) );\n    sds1= differenceSDF(sds1,sdb2);\n    \n    sdt1a=sminPoynomial( sdt1a,sdt1b);\n    sdt1a=sminPoynomial( sdt1a,sdt1c);\n    sdt1a=sminPoynomial( sdt1a,sdt1d);\n    sdt1a=sminPoynomial( sdt1a,sdt1e);\n    \n    float sdb1= sdBox( p-vec3(0.0,3.0,0.0), vec3(14.0,3.0,14.0) );\n    \n    float sdif= differenceSDF(sdt1a,sdt2);\n    sdif= differenceSDF(sdif,sdb1);\n    \n    res =opU3(res, vec3(sdif,-1.0,4.0));\n    res =opU3(res, vec3(sds1,-1.0,4.0));\n    */\n    \n    float d2=sdHat(p); //por gest\n    res =opU3(res, vec3(d2,-1.0,4.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n   \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n\n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n            \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);    \n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    return color*sh+ color*atten * occ;\n}\n\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==4.0)\n    {   vec2 uv=mObj.uvP;\n        float escala=2.125;\n    \tfloat d = mod(floor(uv.x*escala)+floor(uv.y*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n        \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n     vec2 uvP;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 583, 583, 604], [605, 605, 637, 637, 721], [722, 722, 756, 756, 818], [820, 864, 911, 911, 938], [939, 939, 982, 982, 1009], [1010, 1010, 1058, 1058, 1086], [1087, 1125, 1159, 1159, 1255], [1256, 1256, 1290, 1290, 1381], [1382, 1382, 1416, 1416, 1507], [1509, 1509, 1550, 1567, 1677], [1679, 1679, 1722, 1739, 1806], [1808, 1844, 1866, 1866, 2096], [2100, 2100, 2125, 2125, 3376], [3378, 3378, 3402, 3402, 3564], [3566, 3566, 3615, 3615, 4250], [4253, 4253, 4289, 4289, 4534], [4536, 4536, 4563, 4563, 4580], [4582, 4582, 4618, 4618, 4710], [4711, 4711, 4757, 4757, 4882], [4884, 4884, 4921, 4921, 5197], [5199, 5199, 5282, 5282, 6075], [6079, 6079, 6172, 6172, 6302], [6304, 6304, 6336, 6336, 6533], [6535, 6535, 6582, 6582, 6833], [6835, 6835, 6928, 6928, 7269], [7271, 7271, 7302, 7302, 7901], [7903, 7903, 7929, 7929, 8039], [8041, 8041, 8099, 8099, 8151], [8153, 8153, 8210, 8210, 8754]], "test": "untested"}
{"id": "NsK3DK", "name": "大龙猫 - Geode", "author": "totetmatt", "description": "No aa, glitchy af.", "tags": ["geode"], "likes": 9, "viewed": 327, "published": 3, "date": "1632245864", "time_retrieved": "2024-07-30T19:00:01.978972", "image_code": "\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.z,q.y)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nvec2 sdf(vec3 p){\n\n vec2 h;\n float s = 1000.;\n\n vec4 pp = vec4(p,1.);\n pp.xyz = asin(sin(p.xyz));\n for(float i =0.;i<=8.;i++){\n   s = min(pp.x,min(pp.y,pp.z))/pp.a;\n    pp.xyz = abs(pp.xyz)-(.3),\n    pp.xz*=rot(.785*i+i);  \n    pp.yz = pp.y < pp.z ? pp.zy:pp.yz;\n    pp*=1.05;\n    pp.xy *=rot(-.785*i);\n  \n }\n s /=pp.a;\n\n h.x = mix(abs(length(p+vec3(0.,0.,0.))-19.)-.01,s*1.5,.5);\n\nh.x = max(-(abs(p.y)-(1.)  ),h.x);\nvec2 t ;\nt.x = min(length(p.xz)-15.-s*s*s,h.x);\nt.x = max(abs(p.y)-15.,t.x);\n h.y = 1.+s;\nt.y = 2.;\n h = t.x < h.x ? t:h;\n return h;\n    \n}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv*=rot(.13*iTime);\n    vec3 ro = vec3(20.*sin(iTime*.033),0.,20.*cos(iTime*.033));\n      \n    vec3 rp = ro;\n    \n    vec3 rt  = vec3(.1+10.*sin(iTime*.033),0.1,.1+20.*cos(iTime*.033));\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0,-1,0)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,.95));\n    vec3 light = vec3(1.+20.*sin(iTime*.033),2.,-1.+20.*cos(iTime*.033));\n    vec3 col = vec3(.01);\n    vec3 acc = vec3(0.);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(d.y ==2.){\n            acc +=vec3(.01)*exp(-abs(d.x))/(15.+sin(atan(rp.x,rp.z)*40.)*14.);\n            d.x = max(0.,abs(d.x));\n        }\n        if(length(rp) > 100.) break;\n        if(d.x <.0001 && d.y != 2.){\n            vec3 n = norm(rp,.0003);\n            vec3 nn = norm(rp,.003);\n            float dif = dot(normalize(light-rp),n);\n            float spc = max(0.,dot(normalize(ro-rp),reflect(normalize(rp-light),n)));\n            spc = pow(spc,32.);\n          \n            col += max(0.,1.-dot(n,nn))*max(dif,spc)+vec3(1.9+sin(rp.y*10.),.9,1.9+cos(rp.x*10.))*spc*.59;\n            break;\n        }\n        rp +=rd*d.x;\n    \n    }\n    col = max(acc,col);\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 118], [119, 119, 137, 137, 184], [186, 186, 203, 203, 742], [769, 769, 795, 795, 873], [874, 874, 929, 929, 2243]], "test": "untested"}
{"id": "sdVGDV", "name": "Hello shadertoy. Newbie here", "author": "fyisic123", "description": "Hello shadertoy community =)  I am new to shaders and shadertoy, Here is my first  and hopefully not final upload. \nCriticism is very welcome =)", "tags": ["voronoi", "psychedelic", "hue", "psy"], "likes": 6, "viewed": 446, "published": 3, "date": "1632245310", "time_retrieved": "2024-07-30T19:00:02.865601", "image_code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )     // Credit: https: shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define rotate(a) mat2(cos( a + vec4(0,33,11,0)))                             // or on shadertoy: FabriceNeyret2                  \n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n\nvec2 hash22(vec2 p)  // Random noise. Credit: https://www.youtube.com/watch?v=l-07BXzNdPw\n{\n    vec3 a = fract(p.xyx * vec3(123.34,234.34,345.65));    \n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 UV = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  // Convert coordinate to (-1,-1) -> (1.0, 1.0)                    \n    \n        \n    UV += smoothstep(0.25  ,  -0.25, length(UV)-0.6); // Distortion effect    \n    UV *= (3.0 + (3.0 * abs(sin(t * 0.05))));  // Animate camera zoom    \n    UV *= rotate(sin((t+ sin(1.2)) * 0.5)); // Animate camera rotation        \n    UV += (2.0 + (1.0 * sin(t))) * vec2(sin(t), cos(t)); // Animate camera panning;\n    \n    \n    \n    vec2 GV = fract(UV) - 0.5;    // Voronoi  Credit: https://www.youtube.com/watch?v=l-07BXzNdPw\n    float minDist = 100.0;\n    vec2 ide = floor(UV);    \n    for (float y = -1.0; y <= 1.0; y++)\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n            vec2 n = hash22(ide + offs);\n            vec2 p = offs + sin(n * t) * 0.5;\n            float d = length(GV - p);\n            \n            if (d < minDist)\n            {\n                minDist = d;                \n                               \n            }\n            \n        }                       // end of Voronoi\n        \n        \n    \n    minDist = abs(sin(minDist * (4.0 + (3.0 * sin(t))))); // Animate mindist\n    \n    minDist -= smoothstep(0.8, 1.0, minDist); // make spaces between voronoi black\n    vec3 col = hue(fract(t * 0.1) + (0.85 *fract(minDist + (t * 0.2))));    // Apply hue color\n    fragColor = vec4(mix(vec3(0), col, minDist),1) ; // final color output\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 456, 456, 597], [600, 600, 657, 657, 2142]], "test": "untested"}
{"id": "7dKGWK", "name": "Tunnely Torus Thingy", "author": "SnoopethDuckDuck", "description": "Super happy with this one, backgrounds a bit empty. code is sloppy and not much color variation but i like it ", "tags": ["raymarching", "template", "artofcode"], "likes": 9, "viewed": 396, "published": 3, "date": "1632235625", "time_retrieved": "2024-07-30T19:00:03.639532", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 350.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    float r1 = min(20.,1.5 * iTime + 1.5);////iTime+ 0. + 0.1 * p.z, r2 = 0.3; //1.5\n    float r2 = 0.3;\n    vec2 cp = vec2(length(p.xy) - r1, p.z);\n    float a = atan(p.x,p.y);\n    cp.x = abs(cp.x) - 1.4 -4.* cos(0.8 * min(iTime,(30./4.) * 3.1415));\n    cp.x += cos(2. * a + 8. * iTime +  p.z) - 2.;\n    cp.y = 0.4;//cos(p.z + iTime) + sin(p.z - iTime);\n    cp *= Rot(9. * a + 1.4 *iTime );\n    cp.x = abs(cp.x)- 0.3 * abs(cp.y + min(1.8, 0.02 * p.z));// + 3.5 * cos(1.2 * p.z));\n    float td = length(cp)- r2;\n    td *= 0.5;\n    \n    float sd = sdSphere(p - vec3(2. * sin(1.8 * iTime),2. * cos(2. * iTime),-21. + 2. * iTime), 2.4 + 2. * sin(iTime));\n    //float bd = sdBox(p - vec3(0,0,-21.+2. * iTime), vec3(5.));\n    //d = min(td, p.z + 0.9 * iTime);\n    return min(sd,td);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    \n    float b1 = .5 + .5 * cos(iTime + (2./3.) * 3.1415);\n    float b2 = .5 + .5 * cos(iTime + (4./3.) * 3.1415);\n    float b3 = .5 + .5 * cos(iTime);\n    \n    float k = (b1 * rd.x + b2 * rd.y + b3 * rd.z) + .5;\n    //k = clamp(k,0.,1.);\n    vec3 col = mix(vec3(95,205,228)/255., vec3(0), k * (1.-k));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float s = 2.;\n    vec3 ro = vec3(s * cos(1.2 * iTime),s * sin(1.2 * iTime), 1. + 2. * iTime);\n    //vec3 ro = vec3(0.,0.,1. + 2. * iTime);\n   //  vec3 ro = vec3(0,0, 1. + iTime + cos(iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0.), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float a = atan(r.z, r.y);\n        vec2 r2 = r.xy * Rot( iTime);\n        vec2 r3 = r.xy * Rot((iTime + (2./3.) * 3.1415));\n        vec2 r4 = r.xy * Rot((iTime + (4./3.) * 3.1415));\n        \n        float spec2 = pow(max(0., r2.x ),32.);\n        float spec3 = pow(max(0., r3.x ),32.);\n        float spec4 = pow(max(0., r4.x ),32.);\n        \n        float dif = dot(n, normalize(vec3(0,0,0)))*.5+.5;\n        col = mix(Bg(r), vec3(dif), 0.5);\n        col += spec2 + spec3 + spec4;\n        \n        //col +=0.2 *( 1.- 16. * col * col * (1.-col) * (1.-col));// + spec;\n    }\n    \n   // col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGWK.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1670, 1670, 1703, 1703, 1731], [1733, 1733, 1756, 1756, 2569], [2571, 2571, 2605, 2605, 2816], [2818, 2818, 2842, 2842, 3032], [3034, 3034, 3084, 3084, 3275], [3277, 3277, 3295, 3295, 3618], [3620, 3620, 3677, 3677, 4963]], "test": "untested"}
{"id": "fsyGDK", "name": "Distorting Hexfield", "author": "sagieL", "description": "Thanks to Art of Code's tutorial on hexagonal tiling.\nI wanted to make a shader in which a distortion \"forcefield\" will manipulate a grid of cells.\nLeft click and move the mouse to control the forcefield yourself!", "tags": ["2d", "grid", "distortions", "tiling", "hexagons", "forcefield", "cineshader"], "likes": 24, "viewed": 1956, "published": 3, "date": "1632235286", "time_retrieved": "2024-07-30T19:00:04.420444", "image_code": "// \"Distorting Hexfield\" by Sagie Levy 2021.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:sagielevy21@gmail.com\n\n#define scale 16.\n#define distortionRadius 4.5\n#define displacementDistFactor 1.7 // Cannot be more than 2.1~ otherwise cells will be out of bounds of 2nd ring neighbour.\n#define minShrinkFactor .2\n\n#define gamma_dec(x) pow(x, vec3(2.2))\n#define gamma_enc(x) pow(x, vec3(0.454))\n\n#define colorA gamma_dec(vec3(0.914, 0.278, 0.047) * 7.)\n#define colorB gamma_dec(vec3(0.047, 0.482, 0.914) * 1.5)\n\n#define distortionOriginsCount 3\n\nvec3 hdrTonemap(vec3 hdrColor, float exposure) {\n  return 1.0 - exp(-hdrColor * exposure);\n}\n\n// Returns a psuedo-random float between 0 and 1.\nfloat Hash11(float c) {\n    return fract(4384.545 * sin(c * 734.322 + 143.));\n}\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\n// output: xy - local uv, zw - hex coords. \n// Note: zw are not whole numbers!\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r * .5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    vec2 id = uv-gv;\n    return vec4(gv.x, gv.y, id.x,id.y);\n}\n\nvec2 HexCoords2UV(vec4 hc) {\n    return hc.xy + hc.zw;\n}\n\n// Offsets to original hex cell and its first and second ring neighbours.\nvec2[] offsets = vec2[](\n    vec2(0, 0), vec2(1, 1.73) * .5, vec2(1, -1.73) * .5, vec2(1, 0), vec2(-1, 0), vec2(-1, -1.73) * .5, vec2(-1, 1.73) * .5,\n    vec2(2, 0), vec2(2. * .75, -1.73 * .5), vec2(2. * .75, 1.73 * .5), vec2(1, 1.73), \n    vec2(0, 1.73), vec2(-1, 1.73), vec2(-2, 0), vec2(-2. * .75, 1.73 * .5),\n    vec2(-2. * .75, -1.73 * .5), vec2(-1., -1.73), vec2(0, -1.73), vec2(1., -1.73)\n);\n\nint offsetsCount = 1 + 6 + 12;\n\n// Returns displace effect value as factor of distance from distortion origin.\n// Result is in 0..1 range where 0 is no effect and 1 is max effect.\nfloat DisplaceEffect(vec4 hexCoord, vec2 distortOrigin) {    \n    return 1. - smoothstep(.0, distortionRadius, length(hexCoord.zw - distortOrigin));\n}\n\n// Returns local position of displaced hex.\nvec2 DisplaceHex(vec4 hexcoords, vec2 distortOrigin) {\n    vec2 displacementDir = normalize(distortOrigin - hexcoords.zw);\n    vec2 displacement = (length(displacementDir) < 0.001 ? normalize(hexcoords.xy) : displacementDir) * \n        displacementDistFactor * DisplaceEffect(hexcoords, distortOrigin);\n    \n    return hexcoords.xy + displacement;\n}\n\nfloat DisplacedHexSize(vec4 hexcoords, vec2 distortOrigin) {\n    return mix(1., minShrinkFactor, DisplaceEffect(hexcoords, distortOrigin));\n}\n\nvec2 GetInteractiveDistortionOrigin() {\n    return (iMouse.xy - .5 * iResolution.xy) * scale / iResolution.y;\n}\n\nvec2 GetAutoDistortionOrigin(int i) {\n    i++; // Do not allow i to ever be 0 as all random values will be identical in that case.\n    \n    float xSpeed = (iTime + 12.43) * mix(.4, 2., Hash11(float(i) * 524.));\n    float ySpeed = (iTime + 87.98) * mix(.4, 2., Hash11(float(i) * 194.));\n    \n    float aspect = iResolution.x / iResolution.y;\n    return vec2(sin(xSpeed) * aspect, cos(ySpeed)) * .5 * scale;\n}\n\n// Applies depth in CineShader.\nfloat CalculateAlpha(vec4 hc, vec2 distortOrigin) {\n    float tileDist = length(hc.zw - distortOrigin);\n    \n    // Effect only non-distorting tiles.\n    tileDist *= step(distortionRadius, tileDist);\n    \n    return tileDist * (1. / scale);\n}\n\nvec4 ApplyInteractiveDistortionEffect(vec4 hc) {\n    vec3 col = vec3(0);\n    vec2 distortionOrigin = GetInteractiveDistortionOrigin();\n    \n    for (int i = 0; i < offsetsCount; i++) {\n        vec2 offset = offsets[i];\n        \n        vec4 currHC = HexCoords(HexCoords2UV(hc) - offset);\n        \n        vec2 displacedPos = DisplaceHex(currHC, distortionOrigin) + offset;\n        float displacedShrinkFactor = DisplacedHexSize(currHC, distortionOrigin);\n        float colorFactor = smoothstep(minShrinkFactor, 1., displacedShrinkFactor);\n        float currDistFromHexFactor = max(.5 * displacedShrinkFactor - HexDist(displacedPos), 0.);\n        \n        col += mix(colorA, colorB, colorFactor) * currDistFromHexFactor;\n        //col += vec3(DisplaceEffect(currHC, distortionOrigin), 0, 0); // Debug: show effect area.\n    }\n    \n    return vec4(col, CalculateAlpha(hc, distortionOrigin));\n}\n\nvec4 ApplyAutoDistortionEffect(vec4 hc) {\n    vec3 col = vec3(0);\n\n    for (int i = 0; i < offsetsCount; i++) {        \n        vec2 offset = offsets[i];\n        vec4 currHC = HexCoords(HexCoords2UV(hc) - offset);\n        \n        vec2 maxEffectDistortionOrigin;\n        float maxEffectValue = -1.;\n        \n        for (int j = 0; j < distortionOriginsCount; j++) {\n            vec2 currDistortionOrigin = GetAutoDistortionOrigin(j);\n            float currEffect = DisplaceEffect(currHC, currDistortionOrigin);\n            \n            if (maxEffectValue < currEffect) {\n                maxEffectValue = currEffect;\n                maxEffectDistortionOrigin = currDistortionOrigin;\n            }\n        }\n\n        vec2 displacedPos = DisplaceHex(currHC, maxEffectDistortionOrigin) + offset;\n        float displacedShrinkFactor = DisplacedHexSize(currHC, maxEffectDistortionOrigin);\n        float colorFactor = smoothstep(minShrinkFactor, 1., displacedShrinkFactor);\n        float currDistFromHexFactor = max(.5 * displacedShrinkFactor - HexDist(displacedPos), 0.);\n\n        col += mix(colorA, colorB, colorFactor) * currDistFromHexFactor;\n    }\n    \n    // Does not run in CineShader, so I didn't bother calculating the alpha.\n    return vec4(col, 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= scale;\n    \n    vec4 hc = HexCoords(uv);\n    vec4 col = (iMouse.z > 1.) ? ApplyInteractiveDistortionEffect(hc) : ApplyAutoDistortionEffect(hc);\n    \n    col.rgb = hdrTonemap(col.rgb, 1.);\n    col.rgb = gamma_enc(col.rgb);\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGDK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[594, 594, 642, 642, 686], [688, 738, 761, 761, 817], [819, 819, 842, 842, 949], [951, 1030, 1055, 1055, 1279], [1281, 1281, 1309, 1309, 1337], [1845, 1993, 2050, 2050, 2143], [2145, 2189, 2243, 2243, 2538], [2540, 2540, 2600, 2600, 2681], [2683, 2683, 2722, 2722, 2794], [2796, 2796, 2833, 2833, 3203], [3205, 3237, 3288, 3288, 3479], [3481, 3481, 3529, 3529, 4372], [4374, 4374, 4415, 4415, 5630], [5633, 5633, 5688, 5688, 6008]], "test": "untested"}
{"id": "7dyGWV", "name": "Insane Bumpy Terrain", "author": "jarble", "description": "A bumpy hilly landscape based on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "desert", "hill"], "likes": 6, "viewed": 300, "published": 3, "date": "1632193637", "time_retrieved": "2024-07-30T19:00:05.188391", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .25;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv) * freq);\n        n1 = abs(n2+n1+freq);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 1.5+1./(1.+amplitude);\n        amplitude *= (1./(1.+freq));\n        \n\n        uv = uv.yx+n1/(1.+amplitude);\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1)*2.;\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1287], [1290, 1290, 1321, 1321, 1583], [1649, 1649, 1694, 1694, 1980], [1982, 1982, 2020, 2020, 2275], [2277, 2277, 2344, 2344, 2571], [2573, 2573, 2604, 2604, 4021], [4023, 4023, 4080, 4080, 4717]], "test": "untested"}
{"id": "7sG3DK", "name": "track # 2", "author": "jorge2017a2", "description": "track # 2", "tags": ["track2"], "likes": 4, "viewed": 232, "published": 3, "date": "1632186046", "time_retrieved": "2024-07-30T19:00:06.118903", "image_code": "\n//https://iquilezles.org/articles/distfunctions2d\n\n///por jorge2017a2...2021-sep-\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 nubes(vec2 p, vec3 colOut)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    float c1= sdCircle(p-vec2(0.0,0.05), 0.105);\n    float c2= sdCircle(p-vec2(0.15,0.02), 0.065);\n    float c3= sdCircle(p-vec2(-0.15,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.04), vec2(0.22,0.045 ) );\n    \n    float res=unionSDF(c1, c2);\n    res=unionSDF(res, c3);\n    res=differenceSDF(res,b1 );\n    \n    colOut=DrawFigBorde(vec3(1.0), colOut, res );\n\treturn colOut;\n    \n}\n\n\nvec3 arbol(vec2 uv, vec3 col)\n{\n    float sdbtronco= sdBox(uv-vec2(0.5,0.0), vec2(0.0125,0.05));\n    float sdc1= sdCircle(uv-vec2(0.5,0.1), 0.05 );\n    \n    col=DrawFig(vec3(1.0,0.5,0.0), col, sdbtronco);\n    col=DrawFig(vec3(0.0,0.5,0.0), col, sdc1);\n    return col;\n}\n\n\nvec3 Carretera(vec2 p, vec3 col)\n{\n  \n  float sdb1= sdBox(p, vec2(0.08,3.0));\n  vec2 p2=p+vec2(0.0, -iTime*0.125);\n  p2.y= opRep1D(p2.y, 0.25 );\n  \n  float sdb2= sdBox(p2, vec2(0.003,0.025));\n  p.x=abs(p.x)-0.07;\n  float sdb3= sdBox(p, vec2(0.001,3.0));\n  col=DrawFig(vec3(0.45), col, sdb1);\n  col=DrawFig(vec3(1.0), col, sdb2);\n  col=DrawFig(vec3(1.0), col, sdb3);\n \n  return col;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    vec3 col;\n    \n    vec2 pos=uv;\n     float horizon = 0.1;   //0.2\n     float fov = 0.5; \n\tfloat scaling = 0.1;\n\t\n\tvec3 p = vec3(pos.x, fov, pos.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n    vec2 s2 = vec2(p.x/p.z, p.y/p.z)*0.75;\n    \n    if (s.y<0.0)\n    { col=vec3(0.01,0.4,0.05)-uv.y;   }\n    else\n    {   col=vec3(0.1,0.1,0.8)-uv.y;// cielo\n        vec2 uv2=uv;\n        uv2.x+=mod(iTime*0.5, 3.0)-1.7;\n        col= nubes(uv2*1.5-vec2(0.0,0.4), col);\n        col= nubes(uv2*1.5-vec2(0.5,0.6), col);\n        col= nubes(uv2*2.5-vec2(-1.5,0.7), col);\n    }\n    if (s.y<0.0)\n    col= Carretera(s,col);\n    \n    \n    if (s.y<0.0)\n    {\n        float tt=mod(iTime,4.0);\n        vec2 p2=uv+vec2(-tt*0.125,tt*0.125);\n        vec2 p3=uv+vec2(tt*0.125,tt*0.125)+vec2(1.15,0.2);\n        col= arbol(p2,  col);\n        col= arbol(p3,  col);\n        col= arbol(p3-vec2(0.2,0.5),  col);\n        col= arbol(p2-vec2(-0.5,0.5),  col);\n    }    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 278, 278, 373], [375, 406, 442, 442, 487], [493, 493, 532, 532, 576], [578, 622, 669, 669, 696], [697, 697, 740, 740, 767], [768, 768, 816, 816, 844], [850, 850, 912, 912, 1044], [1046, 1046, 1103, 1103, 1169], [1171, 1171, 1208, 1208, 1288], [1290, 1290, 1325, 1325, 1348], [1350, 1350, 1383, 1383, 1801], [1804, 1804, 1835, 1835, 2073], [2076, 2076, 2110, 2110, 2462], [2465, 2465, 2522, 2522, 3600]], "test": "untested"}
{"id": "Ndy3DV", "name": "Dune sandstorm", "author": "klk", "description": "Multioctave sine waves. Pseudo 3D desert landscape.", "tags": ["2d", "sand", "dune"], "likes": 16, "viewed": 671, "published": 3, "date": "1632175610", "time_retrieved": "2024-07-30T19:00:06.906796", "image_code": "void wave(inout float x, inout float y, inout float z, float T, int octaves, float a)\n{\n\tfloat R=8.;\n\tfloat S=.03;\n\tfloat W=-.05;\n\t#define RRRRS R*=.72;S*=1.27;W*=1.21;\n\tfor(int s=0;s<octaves;s++)\n\t{\n\t\tfloat da=1.8+(sin(T*0.021)*0.1+.41*sin(float(s)*.71+T*0.02))*a;\n\t\tfloat dx=cos(da);\n\t\tfloat dy=sin(da);\n\t\tfloat t=-dot(vec2(x-320.,y-240.),vec2(dx,dy));\n\t\tfloat sa=sin(T*W+t*S)*R;\n\t\tfloat ca=cos(T*W+t*S)*R;\n\n\t\tx-=ca*dx*2.;\n\t\ty-=ca*dy*2.;\n\t\tz-=sa;\n\t\tRRRRS\n\t}\n}\n\nfloat chkr(vec2 p, float t)\n{\n    vec2 fxy=vec2(p.x,p.y);\n  \tfxy=abs(fract((fxy+0.5)/2.0)-0.5)-0.25;\n    fxy=clamp(fxy*t+0.5,0.0,1.0);\n    float f=mix(fxy.x,1.0-fxy.x,fxy.y);\n    return f;\n}\n\nfloat tex(vec2 p)\n{\n    //return chkr(p*.1,100.);\n    float z=0.;\n    p=vec2(p.x+p.y*.3,p.y-p.x*.3);\n    p.x=p.x+17.;\n    p.y=p.y-150.;\n    wave(p.x, p.y, z, 12.21-iTime*.01,6,10.);\n    p.x*=18.;\n    p.y*=19.;\n    return sin(p.y*0.04+.1*z)*z*.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*vec2(640.,480.);\n    vec2 uv0=uv;\n    float z=0.;\n    wave(uv.x, uv.y, z, iTime*20., 17,1.);\n    z=z+22.;\n    z*=0.018;\n    vec3 col = vec3(.3+z*1.2,.2+z*.9,.1+z*.6);\n    uv=uv0+0.5*(uv-uv0);\n    //col.rgb*=.9+.1*vec3(.75+.25*tex(vec2(uv0.x,uv.y+iTime*10.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 463, 492, 492, 653], [655, 655, 674, 704, 902], [904, 904, 961, 961, 1293]], "test": "untested"}
{"id": "NsyGDV", "name": "Soundshader X-lines", "author": "made", "description": "optimized for OLED", "tags": ["sound"], "likes": 11, "viewed": 811, "published": 3, "date": "1632171475", "time_retrieved": "2024-07-30T19:00:07.677735", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 128.0;\nconst float PI = 3.1415;\nconst float RADIUS = 1.5;\nconst float BRIGHTNESS = 0.15;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 color){\n    vec4 konvert = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 calc = abs(fract(color.xxx + konvert.xyz) * 6.0 - konvert.www);\n    return color.z * mix(konvert.xxx, clamp(calc - konvert.xxx, 0.0, 1.0), color.y);\n}\n\nfloat luma(vec3 color) {\n  //return dot(color, vec3(0.299, 0.587, 0.114));\n  return dot(color, vec3(0.299, 0.587, 0.5));\n}\n\nfloat getFrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getFrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getFrequency(index), getFrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getFrequency_blend(float x) {\n    return mix(getFrequency(x), getFrequency_smooth(x), 0.5);\n}\n\nvec3 circleIllumination(vec2 fragment, float radius) {\n\tfloat distance = length(fragment);\n\tfloat ring = 1.0 / abs(distance - radius - (getFrequency_smooth(0.0)/4.50));\n\t\n\t//float brightness = distance < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcolor += hsv2rgb( vec3( ( angle + iTime * 2.5 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * BRIGHTNESS;\n\t\n\tfloat frequency = max(getFrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcolor *= frequency;\n\t\n\t// Black halo\n\t//color *= smooth//step(radius * 0.5, radius, distance);\n\t\n\treturn color;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.5, 0.9, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * .99, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 1.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n\t\n    \n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n    color += doLine(rot, (RADIUS ), rot.x);\n    \n    float c1 = sin(iTime * SPEED);\n    float s1 = cos(iTime * SPEED);\n    vec2 rot1 = mat2(c1,s1,-s1,c1) * fragPos;\n    color += doLine(rot1, (RADIUS ), rot1.y);\n    \n\n    \n    \n    color += max(luma(color) - 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 181, 206, 206, 423], [425, 425, 449, 499, 547], [549, 549, 578, 578, 671], [673, 673, 709, 709, 920], [922, 922, 957, 957, 1021], [1023, 1023, 1077, 1077, 1627], [1629, 1629, 1680, 1680, 1931], [1933, 1933, 1990, 1990, 2591]], "test": "untested"}
{"id": "Ndy3WV", "name": "Polar audio visualizer22", "author": "made", "description": "Polar audio visualizer", "tags": ["audio", "visualizer", "polar"], "likes": 0, "viewed": 283, "published": 3, "date": "1632169943", "time_retrieved": "2024-07-30T19:00:08.440695", "image_code": "// Fork of \"Polar audio visualizer\" by edo_m18. https://shadertoy.com/view/tlB3Ry\n// 2021-09-20 20:30:34\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.141592653589793\n#define PI_TWO 6.283185307179586\n\nvoid mainImage(out vec4 O, in vec2 U)\n{    \n    vec2 uv = (U.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n    vec2 nuv = normalize(uv);\n    float r = length(uv);\n    float th = fract(atan(nuv.y, nuv.x) / PI_TWO);\n    \n    float c = texture(iChannel0, vec2(th, 0.5)).x;\n    float y = S(0.1, 0.2, (c - r) - 0.1);\n    float m = step(0.2, r);\n\n    O.rgb = (mod(th * 360., 3.) < 1.)\n        ? hue2rgb(th) * y * m\n        : vec3(0.0);\n}", "image_inputs": [{"id": 18773, "src": "https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 hue2rgb(float h)\n{\n    return clamp(abs(mod(h * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 247, 247, 646]], "test": "untested"}
{"id": "fdVGWy", "name": "I Want My MTV", "author": "byt3_m3chanic", "description": "I liked @jorge's shader - so wanted to make my version of the MTV Logo! https://www.shadertoy.com/view/NsKGWy\n", "tags": ["raymarching", "reflections", "letter", "reproduction", "mtv"], "likes": 13, "viewed": 357, "published": 3, "date": "1632162488", "time_retrieved": "2024-07-30T19:00:09.451991", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    I want My MTV \n    09/20/21 | byt3_m3chanic\n\n    Was inspired after seeing @jorge's MTV Logo shader \n    https://www.shadertoy.com/view/NsKGWy\n    \n    had fun playing with the 80's textures and stuff\n    need to tweak a few things but enjoy!\n    \n    technical inspiration for reflections @jeyko \n    https://www.shadertoy.com/view/tdXcWM\n    liked the setup of loop/marcher in main\n\n*/\n\n#define COLOR(COORD) texture(iChannel0,(COORD))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n    vec3 color = COLOR(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = COLOR(uv - vec2(f*0.001,0.)).x;\n    fgclr.y = COLOR(uv + vec2(f*0.001,.002)).y;\n    fgclr.z = COLOR(uv + vec2(f*0.002,.001)).z;\n \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*2.15;\n    dt = smoothstep(0.,.8,1.-dt);\n    vec3 C = mix(fgclr,color,dt);\n    // output -gamma correct\n    fragColor = vec4(pow(C, vec3(0.4545)),1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n\n    I want My MTV \n    09/20/21 | byt3_m3chanic\n\n    Was inspired after seeing @jorge's MTV Logo shader \n    https://www.shadertoy.com/view/NsKGWy\n    \n    technical inspiration for reflections @jeyko's \n    https://www.shadertoy.com/view/tdXcWM\n    liked the setup of loop/marcher in main\n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// noise is buggy in \n// @morgan3d https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f;// * f * (3.-2.*f);  @Shane's tip for polygonized look..\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//generate terrain using above noise algorithm\nfloat fBm( vec2 p, float freq ) {\t\n\tfloat h = -1.5;\n\tfloat w = 2.50;\n\tfloat m = 0.25;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noise((p * m));\n\t\tw *= 0.5; m *= 2.0;\n\t}\n\treturn h;\n}\n\n//@iq sdf shapes & extrude\nfloat triangle( in vec2 p, in vec2 q ){\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat cap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat cylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n//global\nvec3 hp,hitPoint;\nvec2 gid,sid;\nfloat gtime,stime,ftime;\nmat2 r45,r95,r4;\n\nfloat getM(vec2 p) {\n    vec2 q = vec2(abs(p.x),p.y);\n    float b=box(q-vec2(.7,0),vec2(.35,1.));\n    q-=vec2(.175,.32);\n    q*=r45;\n    return min(box(q,vec2(.35,.6)), b);\n}\n\nfloat getTV(vec3 p, float ns) {\n    vec3 tp = p-vec3(.55,-.45,.35)-ns;\n    vec3 tt = p-vec3(.175,.05-ns,.35)-ns;\n    vec3 tv = p-vec3(.85,-.45-ns,.35-ns)-ns;\n    float t=cap(tp,.95,.045+tt.y*.035);\n    tt.xy*=r95;\n    t=smin(cap(tt,1.15,.075-tt.y*.055),t,.175);\n    t=smin(cap(tv,.65,.075),t,.22);\n    tv.xy*=r4;\n    t=smin(cap(tv,.95,.075-tt.y*.045),t,.15);\n    return t;\n}\nconst float sz = 5.5;\nconst float hf = sz/2.;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.y+=.25;\n    if(stime<1.) p.zx-=T*.73;\n    \n    float ns = fBm(p.xy*2.+T,4.)*.115;\n    gid=floor((p.xz+hf)/sz);\n    if(stime>1.) gid += floor(gtime); \n    if(stime<1.) p.xz=mod(p.xz+hf,sz)-hf;\n    \n    float outline=getM(p.xy);\n    \n    float bigM = opx(outline,p.z,.35)-.015;\n    if(bigM<res.x) {\n        res = vec2(bigM,2.);\n        hp=p;\n    }\n    \n    float bigTV = getTV(p,ns);\n    if(bigTV<res.x) {\n        res = vec2(bigTV,1.);\n        hp=p;\n    }\n    \n    float fx = cylinder(p+vec3(0,1.45,0),2.,.25);\n    if(fx<res.x) {\n        res = vec2(fx,3.);\n        hp=p;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        t.x *= .8;\n        if(t.x<.001) hit = true;\n        d += t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>30.&&steps>100||d>325.) break;\n    } \n    return vec2(d,m);\n}\n\n// compact sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.914,0.502,0.184);\n    return .45+.4*cos( .2*T+PI2*t*vec3(.95,.97,.88)*d ); \n}\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, bool ison) { \n    rd.y+=.1;\n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n    \n    float sun = clamp(dot(rd, ld), 0., 1.);\n    \n    vec3 Rayleigh = vec3(1);\n    vec3 Mie = vec3(1); \n\n    const float RayleighAtt = .2;\n\tconst float MieAtt = 1.; \n    float zAng = max(.1, rd.y);\n\n    // Haze particles and Mie scattering: \n    // Henyey-Greenstein phase function.\n\tconst float g = .95;\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1);\n    vec3 betaM = vec3(4e-2);\n    Mie *= betaM/betaR/(4.*3.14159)*(1. - g*g)/pow(1. + g*g - 2.*g*sun, 1.5);\n    \n    // In-scatter - Klassen's model.\n    vec3 inScatter = (Mie + Rayleigh)*(1. + sun*sun);\n    vec3 extinction = exp(-(betaR*RayleighAtt + betaM*MieAtt)/zAng);\t\n    vec3 col = inScatter*(1. - extinction);\n          \n    // Sun & haze\n    col += vec3(1.6, 1.4, 1)*pow(sun, 250.)*extinction*.5;\n    col += vec3(.1, .3, 1)*pow(sun, 2.)*extinction*.4;\n    col = clamp(ACESFilm(col), 0., 1.);\n    \n    // Clouds\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 uv = (ro + t*rd).xz;\n\tif(t>0.&&ison) {\n        col = mix(col, vec3(2), smoothstep(1., .45, fBm(vec2(4.*uv/1e5),6.))*\n                       smoothstep(.45, .65, (rd.y+.25)*.5 + .5)*.4);  \n    }\n    return col;\n} \n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float speed = .1375;\n    r45 = rot(-.78539816339);\n    //r15 = rot(.15);\n    r4  = rot(-.45);\n    r95 = rot(-.95);\n    gtime = T*speed;\n    stime = mod(gtime,2.);\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0, stime<1.?.25:-.25, 3.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // camera //\n    mat2 rx =stime<1.? rot((.08*sin(T*.18))-.4) : rot((.08*sin(T*.18))-.1);\n    mat2 ry =rot((.38*sin(T*.33)));\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 sky = getSky(ro,rd,vec3(.9,.15,stime<1.? -.42:.45),true);\n    vec3 fog = getSky(ro,rd,vec3(.9,.15,-.42),false);\n    \n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m=0., d=0., a=0., fA=0., f=0.;\n    bool hit = false;\n\n    int bnc = 3;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n    \n        vec2 ray = marcher(ro,rd,p, hit, i==0?132:i>2?99:72);\n        d = ray.x; m = ray.y;\n        \n        hitPoint = hp;\n        sid=gid;\n        if(i == 0) f = d;\n        fA = max(d, fA);\n\n        if(hit)\n        {\n            a=1.;\n            vec3 n = normal(p,d);\n            vec3 lpos =  vec3(15.5,11,stime<1.? -11.5: 11.5);\n            vec3 l = normalize(lpos-p);\n\n            float diff = clamp(dot(n,l),0.,1.);\n            \n            float shdw = 1.0,t=.025;\n            for( int i =0; i<40; i++ ) {\n                float h = map(p + l*t).x;\n                if( h<MIN_DIST ) { shdw = 0.; break; }\n                shdw = min(shdw, 18.*h/t);\n                t += h;\n                if( shdw<MIN_DIST || t>32. ) break;\n            }\n            diff = mix(diff,min(diff*shdw,shdw),.65);\n\n            float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 8.);\n            fresnel = mix(.0, .9, fresnel);\n        \n            vec3 view = normalize(p - ro);\n            vec3 ret = reflect(normalize(lpos), n);\n            float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n            vec3 h = vec3(.5);\n\n            if(m==1.) {\n                h=hue((mod(sid.x,12.)*.15)+(sid.y*.12));\n                ref = clamp(h-fresnel,vec3(0),vec3(.4));  \n            }\n            \n            if(m==2.) {\n                h=vec3(0.141,0.141,0.141);\n                float hs = hash21(sid);\n                \n                if(hs<.33) {\n                    vec3 qr = hitPoint;\n                    vec3 uv = qr*9.;\n\n                    vec3 uvu = fract(uv*.5)-.5;\n                    vec3 id = floor(uv*.5)-.5;\n\n                    float chk = mod(id.y + id.x + id.z,2.) * 2. - 1.;\n                    float px = fwidth(qr.x);\n                    float sw = .575+.600*sin(id.x*.25*id.z*.15-id.y*.15+T*.75+sid.y);\n                    float cl = length(uvu)-sw;\n                    cl=smoothstep(px,-px,cl);\n                    h=mix(h,stime<1.?vec3(.6):hue(hash21(sid)),cl);\n                }\n                if(hs>.33 && hs<.66) {\n                    h=hue(hs);\n                }\n                if(hs>.66) {\n                    vec3 uvu = fract(hitPoint*4.)-.5;\n                    vec3 id = floor(hitPoint*4.)-.5;\n                    if(hitPoint.y<.25) {\n                        if(uvu.x*uvu.y*uvu.z>0.) h=hue(hs);\n                            \n                    }\n                    float px = fwidth(hitPoint.x*.5);\n                    float b1 = box(hitPoint.xy-vec2(0,.27+.075*sin(hitPoint.x*8.)),vec2(5.25,.1));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,vec3(.75),b1);\n                }\n                ref = (h*.3)-fresnel;\n            }\n            \n            if(m==3.) {\n                vec2 hp = hitPoint.xz*4.;\n    \n                float px = fwidth(hitPoint.x*.5);\n                float hs = hash21(sid);\n                h=hue(hs);\n                \n                if(hs<.33) {\n                    vec2 lv = fract(hp)-.5;\n                    vec2 id = floor(hp)-.5;\n                    vec2 lx = fract(hp*.75)-.5;\n                    vec2 fd = floor(hp*.75)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                    float fw = .075*sin(hitPoint.x*10.5+T*5.);\n                    if(hitPoint.z<fw) {\n                        if(lv.x*lv.y>0.) h=vec3(.03);\n                    \n                    } else {\n                        float c1 = length(lx)-.45;\n                        c1=smoothstep(px,-px,c1);\n                        if(fhk>.5) h = mix(h,hue((mod(sid.y,12.)*.25)+(sid.x*.22)),c1);\n                    }\n\n                    float b1 = box(hitPoint.xz-vec2(0,fw),vec2(5.25,.1));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,vec3(.03),b1);\n                }\n                \n                if(hs>.33 && hs<.66) {\n                \n                    vec2 lv = fract(hp*.5)-.5;\n                    vec2 id = floor(hp*.5)-.5;\n                    vec2 lx = fract(hp*.25)-.5;\n                    vec2 fd = floor(hp*.25)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                \n                    vec2 tx = lx;\n                    if(fhk>.5) {tx.y*=-1.;tx.y+=.45;}\n                    float t1 = triangle(tx,vec2(.25,.5));\n                    t1=smoothstep(px,-px,t1);\n                    h = mix(h,vec3(.03),t1);\n\n                    float c1 = length(lx-vec2(.25,.25))-.25;\n                    c1=smoothstep(px,-px,c1);\n                    if(fhk>.5) h = mix(h,vec3(1),c1);\n\n                    float c2 = length(lv)-.145;\n                    c2=smoothstep(px,-px,abs(abs(c2)-.024)-.012);\n                    if(chk<.5) h = mix(h,vec3(.9),c2);\n\n                    if(fhk>.5) lx*=rot(.78531);\n                    lx.y+=.0125*sin(lx.x*45.+T*5.5);\n                    lx.y=abs(lx.y)-.1;\n                    float b1 = box(lx-vec2(0,0),vec2(.25,.05));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,hue((mod(sid.x,12.)*.15)+(sid.y*.12)),b1);\n                }\n                \n                if(hs>.66) {\n                    vec3 bh = h;\n                    h=vec3(.9,.91,.94);\n                    \n                    vec2 lv = fract(hp*.45)-.5;\n                    vec2 id = floor(hp*.45)-.5;\n                    vec2 lx = fract(hp*.15)-.5;\n                    vec2 fd = floor(hp*.15)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                    \n                    float c2 = length(lv)-.35;\n                    c2=smoothstep(px,-px,abs(abs(c2)-.024)-.012);\n                    if(chk<.5) h = mix(h,vec3(.3),c2);\n                    \n                    vec2 tx = lx*rot(.53+fd.x+fd.y);\n                    float t1 = triangle(tx,vec2(.225,.4));\n                    t1=smoothstep(px,-px,t1);\n                    h = mix(h,bh,t1);\n                    \n                    if(fhk>.5) lx*=rot(.78531);\n                    lx.y+=.0125*sin(lx.x*85.+T*5.5);\n                    float b1 = box(lx-vec2(.24,-.2),vec2(.25,.025));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,hue((mod(sid.y,12.)*.15)+(sid.x*.22)),b1);\n                }\n                \n                if(hitPoint.y<-1.21)h=vec3(.65);\n                \n                ref=vec3(.2);\n            }\n\n            RC += h * diff + min(spec,shdw);\n            sky = getSky(ro,rd,vec3(.9,.15,-.42),true);\n            ro = p+n*.01;\n            rd = reflect(rd,n);\n\n        } else {\n            RC = sky;\n        } \n        \n        if(i!=0) RC = mix(RC,sky,smoothstep(0.,1.,fA*0.025));\n       \n        C += RC*fill;\n        fill *= ref;\n            \n    }\n    if(a==1.) C = mix(C,fog,smoothstep(0.,1.,f*0.025));\n    C = clamp(C,vec3(.03),vec3(1));\n    //C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[539, 539, 596, 596, 1131]], "test": "untested"}
{"id": "7dV3Dy", "name": "Twisty Torus Dudes", "author": "SnoopethDuckDuck", "description": "Following along with the art of code's torus video and made this, the colors are a bit off but I like it", "tags": ["raymarching", "template", "artofcode"], "likes": 8, "viewed": 252, "published": 3, "date": "1632157748", "time_retrieved": "2024-07-30T19:00:10.225922", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat myAbs(float k) {\n    return (1. - exp2(-4. * abs(k))) * abs(k);\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n   \n    float a =atan(p.x,p.z);\n   // p.xz *= Rot(3.1415 * cos(a + iTime));\n    p.x += 0.5 * cos(3. * a + 0.7 * iTime + myAbs(p.y) - 0.4);\n    p.z += 0.5 * sin(1.*a + iTime + myAbs(p.y) - 0.4);\n    //p.z += 0.5 * sin(2. * a + iTime);\n    p.y *= 0.;// + 0.01 * Hash21(100. * p.xz);\n    float d = myAbs(p.x) + myAbs(p.y) +  myAbs(p.z) - r;\n    return 0.35 * d;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sharpFunc(float x) {\n    return 1.-abs(cos(x));\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.;\n    float r2 = 0.08;\n    vec2 cp = vec2(length(p.xz) - r1, p.y);\n    float a = atan(p.x,p.z);\n    cp *= Rot(1.5 * a);\n    cp.x = abs(cp.x) - 0.4 - 0.4 * abs(cp.y);\n    cp.y = abs(cp.y) - 0.4 ;\n    vec3 e = vec3(1. + cos(10. * a + 4. * iTime), 0., 1. + sin(10. * a + 4. * iTime));\n  //  float d = length(cp) + .05 * smoothstep(0.,-1.,cos(10. * a + 4. * iTime)) *length(p + e) - r2;\n    float td = length(cp) + \n              .5 * sharpFunc(.5 * a + 3.1415 * cos(0.5 * a + iTime)) * length( p ) \n              - r2;\n    td *= 0.5;\n    //float bd = sdBox(p - vec3(0), vec3(0.5));\n    float sd = sdSphere(p, 0.8); //1.2\n    return min(td,sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y * .5 + .5;\n    float b1 = .5 + .5 * cos(iTime + (2./3.) * 3.1415);\n    float b2 = .5 + .5 * cos(iTime + (4./3.) * 3.1415);\n    float b3 = .5 + .5 * cos(iTime);\n    \n    \n    vec3 col = mix(vec3(b1,b2,b3), vec3(0.01 * Hash21(rd.xz)), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float t = -0.2 * iTime;\n    vec3 ro = vec3(5. * cos(t), 6. * cos(0.6 * iTime), 5. * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n     col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float spec = pow(max(0., r.y), 24.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(Bg(r), vec3(dif), 0.5);\n        col = 1.- 16. * col * col * (1.-col) * (1.-col) + spec;\n       // col = vec3(spec);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3Dy.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1580, 1580, 1674], [1676, 1676, 1698, 1698, 1747], [1750, 1750, 1783, 1783, 2144], [2146, 2146, 2175, 2175, 2256], [2258, 2258, 2284, 2284, 2313], [2315, 2315, 2338, 2338, 2998], [3000, 3000, 3034, 3034, 3245], [3247, 3247, 3271, 3271, 3461], [3463, 3463, 3513, 3513, 3704], [3706, 3706, 3724, 3724, 3998], [4000, 4000, 4057, 4057, 4918]], "test": "untested"}
{"id": "7sVGWG", "name": "interpolation changes distributi", "author": "FabriceNeyret2", "description": "Use Mouse.xy to change the sampling offset within the pixels of the white noise texture.\noffset(0,0) = Uniform distribution\noffset (.5,.5) = near-Gaussian distrib ( average of 4 uniforms )\n  cf https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution", "tags": ["noise", "distribution", "histogram", "pdf", "gpmipmap", "irwinhall"], "likes": 9, "viewed": 336, "published": 3, "date": "1632131492", "time_retrieved": "2024-07-30T19:00:11.098589", "image_code": "// other example on https://shadertoy.com/view/fsV3Dy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int  v = int( 1024.*(U.x-.5)/R.x ),   // histogram value stored in:\n         f = (v/256 + 5 ) %6,             //    face \n         c = (v%256)/64,                  //    color field\n         t =  v%64,                       //    tile id\n         x = t%8, y = t/8;                //    tile coords\n    if (f>2) x = 7-x;\n    vec3 V = vec3( 2.* (vec2(x,7-y)+.5)/8. - 1., // location in cubeMap\n                   f > 2 ? -1 : 1 \n                );\n    if (f==0) V.y = -V.y;\n    if (f==3) V.x = -V.x;\n    f = f%3; if (f==2) V.z=-V.z;\n    V = f==0 ? V.xzy : f==2 ? V.zyx : V; \n    O = vec4( U.y/R.y/200. < textureLod(iChannel0, V ,7.)[c] ) ;\n    \n    U = (2.*U-R)/R;if (U.x>0.&&U.y>0.) U.y=1.-U.y, O += texture(iChannel0,vec3(2.*U-1.,-1));\n // O = texture(iChannel0, vec3(2.*U/R - 1.,1) ) / 1023.;\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// #define T(U)  texture(iChannel0, (U)/128.).r   // Britney\n   #define T(U)  texture(iChannel1, (U+iMouse.xy/R+float(iFrame))/256.).r // white noise with interpolation offset\n// #define T(U)  texture(iChannel2, (U)/1024.).r  // Blue noise\n\nvoid mainCubemap( out vec4 O, vec2 U,  vec3 C, vec3 D )\n{\n    ivec2 I = ivec2(U)/128;                                      // tile bi-Id\n    vec3 A = abs(D);\n    int  f = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2,  // faceId\n         s = I.x + 8*I.y,                                        // tile Id\n         i = int(1023.* T( mod(U,128.) ) );                      // discretize signal\n    if ( D[f] < 0. ) f += 3;                                     // full face Id.\n    O = f<4 ? vec4( equal( ivec4(i), s + 64*ivec4(0,1,2,3) + 256*f )) // isolate one value within 256                                \n            : vec4(T(U/R*128.),0,0,0);                           //  2 useless : free to show the image ! \n\n// O = .5*vec4(  ( s + 64*ivec4(0,1,2,3) + 256*f) );    // cubeMap calibration\n}", "cube_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 93, 93, 893]], "test": "untested"}
{"id": "fsV3Dy", "name": "instant histogramming", "author": "FabriceNeyret2", "description": "Switch CubeA:#def to test Britney vs White noise, etc \n\nisolate tiles following one given signal values in 8x8 tiles, 4 channels, 4 faces of a CubeMap.\nuse MIPmap to count the bits in this.\n( Coding-decoding locations in CubeMaps is always a nightmare )", "tags": ["histogram", "gpmipmap"], "likes": 11, "viewed": 521, "published": 3, "date": "1632131261", "time_retrieved": "2024-07-30T19:00:11.978237", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    int  v = int( 1024.*(U.x-.5)/R.x ),   // histogram value stored in:\n         f = (v/256 + 5 ) %6,             //    face \n         c = (v%256)/64,                  //    color field\n         t =  v%64,                       //    tile id\n         x = t%8, y = t/8;                //    tile coords\n    if (f>2) x = 7-x;\n    vec3 V = vec3( 2.* (vec2(x,7-y)+.5)/8. - 1., // location in cubeMap\n                   f > 2 ? -1 : 1 \n                );\n    if (f==0) V.y = -V.y;\n    if (f==3) V.x = -V.x;\n    f = f%3; if (f==2) V.z=-V.z;\n    V = f==0 ? V.xzy : f==2 ? V.zyx : V; \n    O = vec4( U.y/R.y/64. < textureLod(iChannel0, V ,7.)[c] ) ;\n    \n    U = (2.*U-R)/R;if (U.x>0.&&U.y>0.) U.y=1.-U.y, O += texture(iChannel0,vec3(2.*U-1.,-1));\n // O = texture(iChannel0, vec3(2.*U/R - 1.,1) ) / 1023.;\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "   #define T(U)  texture(iChannel0, (U)/128.).r   // Britney\n// #define T(U)  texture(iChannel1, (U+iMouse.xy/R)/256.).r // white noise with interpolation offset\n// #define T(U)  texture(iChannel2, (U)/1024.).r  // Blue noise\n\nvoid mainCubemap( out vec4 O, vec2 U,  vec3 C, vec3 D )\n{\n    ivec2 I = ivec2(U)/128;                                      // tile bi-Id\n    vec3 A = abs(D);\n    int  f = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2,  // faceId\n         s = I.x + 8*I.y,                                        // tile Id\n         i = int(1023.* T( mod(U,128.) ) );                      // discretize signal\n    if ( D[f] < 0. ) f += 3;                                     // full face Id.\n    O = f<4 ? vec4( equal( ivec4(i), s + 64*ivec4(0,1,2,3) + 256*f )) // isolate one value within 256                                \n            : vec4(T(U/R*128.),0,0,0);                           //  2 useless : free to show the image ! \n // O = .5*vec4(  ( s + 64*ivec4(0,1,2,3) + 256*f) );    // cubeMap calibration\n}", "cube_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 837]], "test": "untested"}
{"id": "7sKGWG", "name": "Importance sampled glass ", "author": "NLIBS", "description": "Importance sampled glass with anti aliasing, dispersion, and background dof. (Lots of settings on this one)\nMove around it with the mouse\n", "tags": ["sdf", "metaballs", "glass", "pathtracer", "spectral", "importance"], "likes": 43, "viewed": 1501, "published": 3, "date": "1632129102", "time_retrieved": "2024-07-30T19:00:12.740199", "image_code": "//21/09/20 : Simplified the sdf, added new roughness settings, and fixed the spectrum function.\n//14/11/20 : Fixed the way light bounced\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    O = texture(iChannel0,U/iResolution.xy);\n    O = 1. - exp(-O); //Tone mapping\n\tO = pow(max(O,0.), vec4(1./2.2)); //Gamma correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//0: no tint, 1: orange-blue tint, 2: orange-green-blue-red tint\n#define TINTED 2\n//Use environment cubemap\n#define USEENV\n//Depth of field radius\n#define DOF 0.06\n//New shape time inverval\n#define SHAPEINTERVAL 7.\n\n//1.0: realistic, 0.5: sharp, 0.0: off. (no performance impact)\n#define ANTIALIAS 1.0\n//Epsilons\n#define EPS_SDF 0.001\n#define EPS_GLASS 0.005\n\n//1.0: realistic, >1.0: sexy\n#define DISPERSION 10.\n//0.0: clear, 0.3: translucent\n#define ROUGHNESS 0.0\n//Recursion depth limit\n#define MAXBOUNCES 30\n\n\n//Refractive index of air\nconst float N_AIR = 1.0;\n\n//Glass properties\nconst vec3 GLASS_COL = vec3(.8,.9,.8);\n\n//Smooth minimum\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n//Line sdf\nfloat line(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//Custom sdf\nfloat map(vec3 p, vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n{ \n    const float k = 0.35;\n    float d = line(p, p1,p2);\n    d = smin(d,line(p, p1,p3),k);\n    d = smin(d,line(p, p1,p4),k);\n    d = smin(d,line(p, p2,p3),k);\n    d = smin(d,line(p, p2,p4),k);\n    d = smin(d,line(p, p3,p4),k);\n    return d-0.03;\n}\n\n//High quality sdf from finite difference\nvec3 get_norm(vec3 p, vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n{\n    \n\tvec2 t = vec2(EPS_SDF,0.);\n\treturn normalize(-vec3(\n    \tmap(p - t.xyy,p1,p2,p3,p4) - map(p + t.xyy,p1,p2,p3,p4),\n    \tmap(p - t.yxy,p1,p2,p3,p4) - map(p + t.yxy,p1,p2,p3,p4),\n    \tmap(p - t.yyx,p1,p2,p3,p4) - map(p + t.yyx,p1,p2,p3,p4) \n    ));\n}\n\n//Raymarching loop\nfloat march(vec3 rd, vec3 ro, vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n{\n    float sgn = sign(map(ro,p1,p2,p3,p4));\n    float t = 0.;\n    for (int i = 0; i<200; i++) {\n        vec3 p = ro+rd*t;\n        float h = map(p,p1,p2,p3,p4)*sgn;\n        t+=h;\n        if (h<EPS_SDF) return t;\n        if (h>2.5) return 0.;\n    }\n    return t;\n}\n\n//Some fresnel function I found\nfloat get_fresnel(vec3 rd, vec3 n, float n1, float n2)\n{\n    float cosI = abs(dot(rd, n));\n    float cosR = n1/n2 * sqrt(1.-cosI*cosI);\n    if(cosR > 1.0) return 1.0; // total internal reflection\n    cosR = sqrt(1.0 - cosR * cosR);\n    float Rs = (n1*cosI - n2*cosR)/(n1*cosI + n2*cosR);\n    float Rp = (n1*cosR - n2*cosI)/(n1*cosR + n2*cosI);\n    return (Rs*Rs+Rp*Rp)*0.5;\n}\n\n//Cube map sampling\nvec3 _sample(vec3 rd)\n{\n    #ifdef USEENV\n\tvec3 col = texture(iChannel0,rd).rgb;\n    col = pow(col*1.5,vec3(2.2+3.5));\n    #else\n    vec3 col = vec3(pow(rd.z*0.5+0.5,3.));\n    #endif\n    \n    #if TINTED > 0\n    col *= mix(vec3(0.1,0.3,0.9),vec3(0.9,0.27,0.08),rd.x*0.5+0.5);\n    #if TINTED > 1\n    col *= mix(vec3(0.1,0.9,0.3),vec3(1.,.5,.2),rd.z*0.5+0.5);\n    #endif\n    #endif\n    \n    return col;\n}\n\n//Cauchy's equation for Borosilicate glass (BK7), also applying dispersion factor\nfloat get_n_glass(float lambda, float disp)\n{\n    lambda *= 1e-3;\n    return 1.5046 + 0.0042*disp / (lambda*lambda);\n}\n\n//spectral_zucconi6 but corrected so it integrates to white (1,1,1) ---------------------\nvec3 bump3(vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp(y-yoffset,0.,1.);\n    return y;\n}\n\nvec3 spectral(float lambda)\n{\n    float x = (lambda - 400.)/ 300.;\n    const vec3 c1 = vec3(3.54585, 2.93225, 2.41594);\n    const vec3 x1 = vec3(0.69549, 0.49228, 0.27700);\n    const vec3 y1 = vec3(0.02313, 0.15225, 0.52608);\n    const vec3 c2 = vec3(3.90307, 3.21183, 3.96587);\n    const vec3 x2 = vec3(0.11749, 0.86755, 0.66078);\n    const vec3 y2 = vec3(0.84897, 0.88445, 0.73949);\n    return pow((bump3(c1 * (x - x1), y1) + bump3(c2 * (x - x2), y2)),vec3(2.2)) * vec3(3.64499, 4.4228, 15.6893);\n}\n//---------------------------------------------------------------------------------------\n\n//Hash function for blurring background (https://www.shadertoy.com/view/XlXcW4)\nconst uint k2 = 1103515245U;\nvec3 hash3(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k2;\n    x = ((x>>8U)^x.yzx)*k2;\n    x = ((x>>8U)^x.yzx)*k2;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 R = iResolution.xy;\n    vec2 uv0 = (2.*U-R)/R.x;\n    \n    //Grab some blue noise\n    vec3 noise0 = texelFetch(iChannel1,ivec2(U)%1024,0).rgb;\n    vec3 noise = fract(noise0+vec3(2.7182818, 3.1415927, 1.6180340)*float(iFrame%1000))-vec3(0.5,0.5,0.);\n    \n    //Calculate point positions\n    float time = floor(iTime/SHAPEINTERVAL)*30.+30.;\n    vec3 s = vec2(0.85,0.7).xyx;\n    \n    vec3 p1 = vec3(sin((time+10.)*vec3(0.06045,0.23919,0.86241)));\n    vec3 p2 = vec3(sin((time+15.)*vec3(0.39773,0.48066,0.08272)));\n    vec3 p3 = vec3(sin((time+20.)*vec3(0.33694,0.49604,0.54413)));\n    vec3 p4 = vec3(sin((time+25.)*vec3(0.90110,0.47410,0.68659)));\n    \n    p1 *= s/length(p1);\n    p2 *= s/length(p2);\n    p3 *= s/length(p3);\n    p4 *= s/length(p4);\n    \n    vec3 avg = 0.25*(p1+p2+p3+p4);\n    p1 -= avg;\n    p2 -= avg;\n    p3 -= avg;\n    p4 -= avg;\n    \n    \n    //Find camera's origin and ray direction\n    float a = (iMouse.x/R.x+0.25)*6.283185;    \n    vec3 viewPos = vec3(0,0,-1.7);\n    vec2 uv = uv0 + noise.rg/R.x*2.*ANTIALIAS;\n    mat2 mat = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 ro = viewPos;\n    ro.xz = mat * ro.xz;\n    vec3 rd = normalize(vec3(uv,0.9));\n    rd.xz = mat * rd.xz;\n\n    //Hit depth, pos and normal\n    float t = march(rd,ro,p1,p2,p3,p4);\n    vec3 p = ro + rd*t;\n    vec3 n = get_norm(p,p1,p2,p3,p4);\n\n    vec3 col;\n    if (t>0.) {\n        //Initialise variables\n        float lambda = 400.+300.*noise.z;\n        float n_glass = get_n_glass(lambda,DISPERSION);\n\n        vec3 b_rd = rd;\n        vec3 b_p = p;\n        float b_t = t;\n        vec3 b_n = n;\n\n        float sgn = 1.;\n        vec3 factor = vec3(1.);\n        \n        //Loop through light bounces\n        for (int branch = 0; branch<MAXBOUNCES; branch++) {\n            float n1 = (sgn>0.) ? N_AIR : n_glass;\n            float n2 = n_glass+N_AIR-n1;\n\n            float fresnel = get_fresnel(b_rd,b_n,n1,n2);\n            float choice = fract(noise0.x+1.61803398*float(branch+(iFrame%1000)*MAXBOUNCES));\n            if (choice<fresnel) {\n                //Calculate reflected ray\n                b_rd = reflect(b_rd,b_n);\n                b_rd = normalize(b_rd+ROUGHNESS*normalize(hash3(uvec3(uvec2(U),branch*1000+iFrame%1000))));\n\n                b_t = march(b_rd,b_p+b_rd*EPS_GLASS,p1,p2,p3,p4);\n                \n                if (sgn<0.) factor *= pow(GLASS_COL,vec3(b_t));\n\n                if (b_t==0.) { col = _sample(b_rd)*factor; break; };\n\n                b_t += EPS_GLASS;\n                b_p += b_rd*b_t;\n                b_n = sgn*get_norm(b_p,p1,p2,p3,p4);\n            } else {\n                sgn *= -1.;\n                \n                //Calculate refracted ray\n                b_rd = refract(b_rd,b_n,n1/n2);\n                b_rd = normalize(b_rd+ROUGHNESS*normalize(hash3(uvec3(uvec2(U),branch*1000+iFrame%1000))));\n                \n                b_t = march(b_rd,b_p+b_rd*EPS_GLASS,p1,p2,p3,p4);\n                \n                if (sgn<0.) factor *= pow(GLASS_COL,vec3(b_t));\n\n                if (b_t==0.) { col = _sample(b_rd)*factor; break; }\n\n                b_t += EPS_GLASS;\n                b_p += b_rd*b_t;\n                b_n = sgn*get_norm(b_p,p1,p2,p3,p4);\n            }\n        }\n\n        //Use as a spectral componant\n        col *= spectral(lambda);\n    } else {\n        //Background with dof\n        vec3 hash = hash3(uvec3(uvec2(U),iFrame%1000));\n        vec2 pos = vec2(cos(6.283185*hash.x),sin(6.283185*hash.x))*sqrt(hash.y)*DOF;\n        \n        vec4 cs = vec4(cos(pos),sin(pos));\n        rd.yz = mat2(cs.y,cs.w,-cs.w,cs.y)*rd.yz;\n        rd.xz = mat2(cs.x,cs.z,-cs.z,cs.x)*rd.xz;\n        col += _sample(rd);\n    }\n    \n    //Blending with previous frame\n    vec4 prev = texture(iChannel2,U/R);\n    float w = mod(prev.w,1000.);\n    \n    if (floor(iTime/SHAPEINTERVAL)!=floor(prev.w/1000.) || iMouse.z>0.) w = 0.;\n    \n    col = prev.rgb*w/(w+1.) + col/(w+1.);\n    w = min(w+1.,1000.);\n    \n    w = w+floor(iTime/SHAPEINTERVAL)*1000.;\n    col = (U.y/R.y<0.015 && U.x/R.x < fract(iTime/SHAPEINTERVAL)) ? vec3(1) : col;\n    \n    O = vec4(col,w);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 177, 177, 315]], "test": "untested"}
{"id": "fsKGDy", "name": "Tsunami", "author": "emh", "description": "Waves crashing", "tags": ["waves", "water", "forces"], "likes": 15, "viewed": 734, "published": 3, "date": "1632119758", "time_retrieved": "2024-07-30T19:00:13.503159", "image_code": "// Fork of \"Organic Snirklets\" by emh. https://shadertoy.com/view/fdKGWy\n// 2021-09-20 05:37:27\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv);\n    //color.r = mod(color.r, 1.0);\n    color.r = 0.2 * color.b;\n    \n    vec3 light = vec3(1.0, 1.0, -1.0);\n    light = normalize(light);\n    float c = 0.15 + 0.5 * dot(color.yzw, light);\n    color.rgb = vec3(c) * vec3(0.000,0.616,1.000) * 5.0;\n    \n    //color.g = 0.5 * color.b;\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.1415926\n\nconst int k = 5;\nconst int mindensity = 4;\nconst int maxdensity = 4;\nconst int startspeed = 1;\nconst float anglespeed = 0.015;\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if (iTime >= 4.0 && mod(iTime, 16.0) < 0.1) {\n    //    fragColor = vec4(0.0);\n    //    return;\n    //}\n\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    vec2 center = iResolution.xy * 0.5;\n    vec2 centerRight = center;\n    centerRight.x *= 2.0;\n    centerRight.y *= 1.25;\n    \n    if (distance(fragCoord, centerRight) < 1.0) {\n        //fragColor = vec4(0.01, 0.0, 1.0, 0.0);\n        fragColor = vec4(sin(iTime * 1.0), 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;       \n    \n    color = vec4(0.0);\n    bool done = false;\n    //bool empty = true;\n    int nonEmpty = 0;\n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n            vec2 fc = fragCoord + vec2(dx, dy);\n            vec2 uv = fc / iResolution.xy;\n            vec4 previous = texture(iChannel0, uv);\n            float rawAngle = previous.x;\n            float angle = rawAngle * 2.0 * M_PI;\n            //empty = empty && (!done || angle == 0.0);\n            nonEmpty += angle != 0.0 ? 1 : 0;\n            if (!done && angle != 0.0) {\n                for (int speed = startspeed; speed <= k; speed++) {\n                    int x2 = int(floor(float(fc.x) + float(speed) * cos(angle)));\n                    int y2 = int(floor(float(fc.y) + float(speed) * sin(angle)));\n                    if (x == x2 && y == y2) {\n                        float a = rawAngle + anglespeed * (rand(sin(iTime) * fc) - 0.0);\n                        a = a <= 0.01 ? rand(fc) : a;\n                        //color += vec4(a, a * 0.125, a * a * 0.5, 1.0);\n                        \n                        // color += vec4(0.0, 0.35, 0.75, 1.0);\n                        color += vec4(0.0, cos(angle), 1.0, sin(angle));\n                        fragColor.x = a;\n                    }\n                }\n                // done = true;\n            }\n        }\n    }\n    int density = 1000; // int(mod(iTime, float(maxdensity - mindensity))) + mindensity; \n    if (nonEmpty <= density) {\n        float d2 = sqrt(0.5) - distance(fragCoord / iResolution.xy, center / iResolution.xy);\n        float d = 5.0;\n        //d *= float(nonEmpty) / 50.0;\n        fragColor.yzw = d * color.yzw / float(max(1, nonEmpty));\n    }\n    //fragColor = color;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 204, 621]], "test": "untested"}
{"id": "fdKGDy", "name": "Psynthetika", "author": "xenn", "description": "Custom mandelbox by loicvdb. https://shadertoy.com/view/3t3GWH mixed with a nice cube map sky thingy someone kindly made. Luscious colours, thanks whoever you are, I forget", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 19, "viewed": 576, "published": 3, "date": "1632119061", "time_retrieved": "2024-07-30T19:00:14.540386", "image_code": "\n// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MaxSteps 64\n#define MaxShadowSteps 16\n#define AmbientLightSteps 8\n#define MaxDist 2.0\n#define MinDist .015\n#define GIStrength .3\n#define AOStrength .52\n\nvec3 CamPos = vec3(0, 0, -17.);\nvec3 CamRot = vec3(0);\nfloat CamFocalLength = 01.5;\n\nvec3 LightDir;\nvec3 LightColor = vec3(.7, .5, .3) * 10.;\nfloat LightRadius = .05;\n\nfloat Scale = 2.25;\nfloat Radius = .25;\nint Iterations = 9;\nmat3 Rotation;\n\nfloat distanceEstimation(vec3 position){\n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 2) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float dist){\n  vec2 k = vec2(dist, 0);\n  return normalize(vec3(distanceEstimation(pos + k.xyy),\n\t  \t\t\t\t\tdistanceEstimation(pos + k.yxy),\n  \t\t\t\t\t\tdistanceEstimation(pos + k.yyx))\n\t\t\t\t - vec3(dist));\n}\nvec3 normalEstimation(vec3 pos){\n  float dist = distanceEstimation(pos);\n  return normalEstimation(pos, dist);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel0, dir).rgb;\n}\n\n//blurred cubemap for ambient lighting\nvec3 backgroundColorHemi(vec3 dir){\n    return textureLod(iChannel0, dir, 9.5).rgb;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 pos0 = pos;\n    float dist0 = distanceEstimation(pos);\n    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);\n    float ao = 1., dist = dist0;\n    for(int i = 0; i < AmbientLightSteps; i++){\n        float expectedDist = dist * (1. + .8);\n        dist = distanceEstimation(pos);\n        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));\t//more weight to first samples\n        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);\n        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //\"smoothed\" normal to avoid artifacts\n        pos += normal * .8*dist; //slightly shorter to avoid artifacts\n        al += backgroundColorHemi(normal);\n        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples\n    }\n    gi *= GIStrength/2.0;\n    return gi + al/float(AmbientLightSteps) * ao;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            n = normalEstimation(pos);\n            for(int j = 0; j < 3; j++){\n                dist = distanceEstimation(pos) - 2.*MinDist;\n        \t\tpos += dist * dir;\n            }\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\n\nvec4 rayTrace(vec3 pos, vec3 dir){\n    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist\n        float dist = distanceEstimation(pos);\n        pos += dist * dir;\n        if(dist < MaxDist) break;\n    }\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(backgroundColor(dir), 20.0);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime + 43.;\n    \n    //fractal animation\n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    //light animation\n    LightDir = normalize(vec3(sin(time*.6), -1, cos(time*.6)));\n    \n    //camera animation\n    CamRot.z = sin(time*.4)*.2;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n\n    fragColor = rayTrace(CamPos, rayDir);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 col = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_b_code": "//first DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .05\n#define DoFClamping .35\n#define DoFSamples 32\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 2.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 2.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 263], [265, 265, 322, 322, 627], [629, 629, 686, 686, 946]], "test": "untested"}
{"id": "fdKGWy", "name": "Organic Snirklets", "author": "emh", "description": "Forces creating snirklets.", "tags": ["forces", "snirklets"], "likes": 12, "viewed": 317, "published": 3, "date": "1632104056", "time_retrieved": "2024-07-30T19:00:15.316312", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv);\n    color.r = mod(color.r, 1.0);\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.1415926\n#define T(U) texture(iChannel0, (U)/iResolution.xy)\n\nconst float density = 6.0; \nconst float k = 3.0;\nconst float startspeed = 0.0;\nconst float anglespeed = 0.3;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime >= 4.0 && mod(iTime, 4.0) < 0.1) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec2 xy = floor(fragCoord);\n    \n    vec2 center = iResolution.xy * 0.5;\n    \n    if (distance(fragCoord, center) < 1.0) {\n        fragColor = vec4(sin(iTime * 1.0), 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 color = T(fragCoord);\n    fragColor = color;       \n    \n    bool done = false;\n    float nonEmpty = 0.0;\n    for (float dx = -k; dx <= k; dx++) {\n        for (float dy = -k; dy <= k; dy++) {\n            vec2 fc = fragCoord + vec2(dx, dy);\n            vec4 previous = T(fc);\n            float rawAngle = previous.x;\n            float angle = rawAngle * 2.0 * M_PI;\n            if (angle > 0.0) {\n                nonEmpty++;\n            }\n            if (!done && angle != 0.0) {\n                for (float speed = startspeed; speed <= k; speed += 1.0) {\n                    vec2 xy2 = floor(fc) + speed * vec2(cos(angle), sin(angle));\n                    if (distance(xy, xy2) < 1.0) {\n                        float a = rawAngle + anglespeed * (rand(sin(iTime) * fc) - 0.5);\n                        color += vec4(fract(a), 0.25, 0.0, 0.0);\n                    }\n                }\n                done = true;\n            }\n        }\n    }\n    if (nonEmpty <= density) {\n        fragColor = color;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 276]], "test": "untested"}
{"id": "NsKGWy", "name": "logo-mtv", "author": "jorge2017a2", "description": "logo-mtv", "tags": ["logomtv"], "likes": 6, "viewed": 296, "published": 3, "date": "1632100123", "time_retrieved": "2024-07-30T19:00:16.078275", "image_code": "\n//https://iquilezles.org/articles/distfunctions2d\n\n///por jorge2017a2...2021-sep-19\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 musicM(vec2 p, vec3 col)\n{\n     float sdb1= sdBox(p-vec2(-0.2,0.0), vec2(0.11,0.3) );//izq\n     float sdb2= sdBox(p-vec2(0.2,0.0), vec2(0.11,0.3) ); //der\n     float sdb3= sdBox(p-vec2(0.0,0.15), vec2(0.1,0.15) ); //centro\n     float sdt1= sdTriangleIsosceles(p-vec2(0.0,0.21), vec2(0.1,0.1) );\n     float sdt2= sdTriangleIsosceles(p-vec2(0.0,-0.1), vec2(0.1,0.11) );\n     sdb3= differenceSDF(sdb3, sdt1);\n     sdb3= unionSDF(sdb3, sdt2);\n     float sdtdmtv=unionSDF(sdb1, sdb3);\n     sdtdmtv=unionSDF(sdtdmtv, sdb2);\n     \n     col= DrawFigBorde(vec3(1.0,1.0,0.0)-p.y*1.5, col,sdtdmtv);\n     return col;\n}\n\nvec3 musicTv(vec2 p, vec3 col)\n{    float sdb1= sdBox(p-vec2(0.15,0.0), vec2(0.025,0.18) );\n     vec2 p1= rotatev2(p-vec2(0.15,0.12), radians(-25.0));\n     float sdb2= sdBox(p1, vec2(0.15,0.03) );//izq\n     float sunT=unionSDF(sdb1, sdb2);\n     vec2 p2= rotatev2(p-vec2(0.25,-0.05), radians(-10.0));\n     vec2 p3= rotatev2(p-vec2(0.33,-0.005), radians(25.0));\n     float sdbv1= sdBox(p2, vec2(0.025,0.12) );\n     float sdbv2= sdBox(p3, vec2(0.025,0.17) );\n     float sunv=unionSDF(sdbv1, sdbv2);\n     col= DrawFigBorde(vec3(1.0,0.0,0.0)-p.y*1.5, col,sunT);\n     col= DrawFigBorde(vec3(1.0,0.0,0.0)-p.y*1.5, col,sunv);\n     return col;\n}\n\nvec3 zigzag(vec2 p,vec3 colIn,  vec3 colOut)\n{\n     float wi=0.045;\n     float he=0.15;\n     float sk=0.1;\n     vec2 p1= rotatev2(p-vec2(0.2,0.0), radians(45.0));\n     float sdb1= sdBox(p1, vec2(0.025,0.12) );\n     vec2 p2= rotatev2(p-vec2(0.34,0.0), radians(-45.0));\n     float sdb2= sdBox(p2, vec2(0.025,0.12) );\n     \n     float sunb=unionSDF(sdb1, sdb2);\n     colOut= DrawFigBorde(colIn, colOut,sunb);\n     return colOut;\n} \n\nvec3 zig1(vec2 uv, vec3 colIn,vec3  colOut)\n{    float px=iTime;\n    vec2 uv2a=uv-vec2(px,0.0);\n    vec2 uv2b=uv-vec2(px,0.0);\n    uv2a.x= opRep1D(uv2a.x, 0.9 );\n    uv2a.y= opRep1D(uv2a.y, 0.22 );\n    \n    uv2b.x= opRep1D(uv2b.x+0.3, 0.9 );\n    uv2b.y= opRep1D(uv2b.y, 0.22 );\n    colOut=zigzag(uv2a,colIn,colOut);\n    colOut=zigzag(uv2b,colIn,colOut);\n    return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    vec3 col=vec3(1.0)-uv.y;\n    \n    col= zig1(uv, vec3(0.0,1.0,0.0), col);\n    \n    vec2 uv2=uv-vec2(1.0,0.0);\n    uv2= rotatev2(uv2, radians(45.0));\n    col= zig1(uv2, vec3(0.0,0.0,1.0), col);\n    \n    float py =uv.y + 0.015*sin(iTime*5.2 + uv.x*30.0);\n    \n    col= DrawFigBorde(vec3(0.5, 0., 1.)-uv.y*0.75, col, (py+0.3) );\n    col= DrawFig(vec3(1.0, 0., 0.)-uv.y, col, abs(py+0.33)-0.025 );\n    \n    col=musicM(uv, col);\n    col=musicTv(uv, col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 280, 280, 375], [377, 408, 444, 444, 489], [495, 495, 534, 534, 578], [580, 624, 671, 671, 698], [699, 699, 742, 742, 769], [770, 770, 818, 818, 846], [852, 852, 914, 914, 1046], [1048, 1048, 1105, 1105, 1171], [1173, 1173, 1210, 1210, 1290], [1292, 1292, 1343, 1343, 1651], [1654, 1654, 1685, 1685, 2265], [2267, 2267, 2299, 2299, 2903], [2905, 2905, 2951, 2951, 3332], [3335, 3335, 3380, 3380, 3709], [3711, 3711, 3768, 3768, 4363]], "test": "untested"}
{"id": "NsVGWG", "name": "- swallow v1 -", "author": "anahit_movsesyan", "description": "A different version of https://www.shadertoy.com/view/NsyGzt", "tags": ["sdf", "bird", "walls", "swallow"], "likes": 13, "viewed": 311, "published": 3, "date": "1632087550", "time_retrieved": "2024-07-30T19:00:16.841234", "image_code": "#define PI 3.1415\n\nvec2 rotate(vec2 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -log2(exp2(-k * a) + exp2(-k * b)) / k;\n}\n\nfloat sdfFw(float d) {\n    return smoothstep(0., fwidth(d) * 1.5 * 720. / iResolution.y, d);\n}\n\nfloat sdf(float d) {\n    return smoothstep(0., .002 * 720. / iResolution.y, d);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat sdWing(vec2 q) {\n    float f1 = 5. * smoothstep(-0.9, 1.1, sin(iTime * 1.5));\n    float f2 = (sin(iTime * 18.) + 1.) * 1.5;\n\n    q = rotate(q, ((f1 * f2) / 19.) + PI / 2.02);\n    q.x -= sin(q.y * 22. + 1.5) * 0.01;\n    return sdLine(q, vec2(0., -0.45), vec2(0)) - 0.05 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdTail(vec2 q) {\n    float f = 5. * smoothstep(0.8, -1.9, 2. * sin(iTime*1.5));\n\n    q = rotate(q, f / 40. + PI / 2.25);\n    q.x -= sin(q.y * 7. + 1.) * 0.005 + sin(q.y * 15.) * 0.003;\n    return sdLine(q, vec2(0., -0.35), vec2(0)) - 0.035 * smoothstep(-0.23, 0., q.y);\n}\n \nfloat sdBird(vec2 p) {\n    float d, d1;\n    \n    // head\n    vec2 q = p - vec2(0.17, -0.045);\n    d = sdCircle(q, 0.045);\n    \n    q = p - vec2(0.205, -0.0415);\n    d1 = sdCircle(q, 0.03);\n    d = smoothMin(d, d1, 180.);\n    \n    // nose\n    q = p - vec2(0.2125, -0.055);\n    q = rotate(q, -PI / 3.5);\n    q.x -= sin(q.y * 0.01 + 1.) * 0.005 + sin(q.y * 0.01) * 0.005;\n    d1 = sdLine(q, vec2(0., -0.03), vec2(0)) - 0.0175 * smoothstep(-0.03, 0., q.y);\n    d = min(d, d1);\n    \n    // eye\n    q = p - vec2(0.21, -0.05);\n    d1 = sdCircle(q, 0.008);\n    d = max(d, -d1);\n    \n    // tail\n    q = p - vec2(0.08, -0.045);\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.08, -0.05);\n    q.y *= -1.;\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    // wings\n    q = p - vec2(0.105, -0.015);\n    d1 = sdWing(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.105, -0.075);\n    q.y *= -1.;\n    d1 = sdWing(q);\n    d = min(d, d1);\n\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/ max(iResolution.x, iResolution.y);\n    uv.y += sin(iTime * 1.55) / 10.;\n    \n    float signF = (step(fract(iTime / 5.) * 2. - 1., 0.) * 2. - 1.);\n    float bla = signF * (uv.x / 3. + fract(iTime / 2.5) * 2. - 1.);\n   \n    uv = rotate(uv, sin(iTime * 1.55 + PI / 3.5) / 10.);       \n    float k = 20.;\n    float birdD = smoothMin(sdBird(uv * 1.1), 1., 8.);\n    \n    float fd = mix(1. - sdf(smoothMin(birdD, -bla, k)), \n                   sdf(smoothMin(birdD, bla, k)), \n                   sdfFw(bla));\n    \n    vec3 c = vec3(sin(iTime / 5.) * 0.5 + 0.5, 0.8, 0.2);\n    fragColor = vec4((fd + 0.2) * (hsv2rgb(c) + 0.6), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 53, 53, 141], [143, 143, 187, 187, 240], [242, 242, 264, 264, 336], [338, 338, 358, 358, 419], [421, 421, 454, 454, 482], [484, 484, 521, 521, 653], [655, 655, 677, 677, 961], [963, 963, 985, 985, 1240], [1243, 1243, 1265, 1265, 2195], [2197, 2197, 2219, 2219, 2343], [2345, 2345, 2400, 2400, 3074]], "test": "untested"}
{"id": "NdKGWG", "name": "brief study of iridescent snails", "author": "pali6", "description": "Ok, tehcnically just snail *shells* but that's better than no snail at all!\n\nVectors go brr until they hit a colour on a \"ring\" around the screen.\nNumber of iterations corresponds to saturation and value, angle corresponds to hue.", "tags": ["iterative"], "likes": 2, "viewed": 229, "published": 3, "date": "1632084252", "time_retrieved": "2024-07-30T19:00:17.603197", "image_code": "#define MAX_ITER 40\n#define BOUNDARY 2.\n#define PI 3.141592653589\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + 4.;\n    vec2 uv = fragCoord / iResolution.xy * 2. - vec2(1., 1.);\n    vec2 last = uv;\n    uv *= 2.;\n    \n    int i = 0;\n    for(; i < MAX_ITER; i++)\n    {\n        if(length(uv) > BOUNDARY)\n        {\n            uv = last + (uv - last) * ((BOUNDARY - length(last)) / (length(uv) - length(last)));\n            break;\n        }\n        last = uv;\n        uv = rotate(uv, 0.01 * PI * sin(time / 10.));\n        uv *= 1.03;\n        uv += vec2(cos(time / 5.), sin(time / 5.)) * 0.4;\n        uv += 0.5 * rotate(uv, PI / 2.);\n    }\n    if(false && length(uv) < BOUNDARY - 0.05)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    float h = atan(uv.y, uv.x) / (2. * PI) + 0.5;\n    float s = float(i) / float(MAX_ITER);\n    float v = s;\n    s *= 1.5;\n    fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 258], [260, 260, 290, 290, 374], [376, 376, 433, 433, 1258]], "test": "untested"}
{"id": "sdy3Dy", "name": "at the roseflower accretion disk", "author": "pali6", "description": "Vectors go brr until they hit a colour on a \"ring\" around the screen.\nNumber of iterations corresponds to saturation and value, angle corresponds to hue.", "tags": ["iterative"], "likes": 4, "viewed": 231, "published": 3, "date": "1632082695", "time_retrieved": "2024-07-30T19:00:18.370148", "image_code": "#define MAX_ITER 100\n#define BOUNDARY 2.\n#define PI 3.141592653589\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + 4.;\n    vec2 uv = fragCoord / iResolution.xy * 2. - vec2(1., 1.);\n    \n    int i = 0;\n    for(; i < MAX_ITER; i++)\n    {\n        if(length(uv) > BOUNDARY)\n            break;\n        uv = rotate(uv, time / 10.);\n        uv *= 1.03;\n        uv += vec2(cos(time / 5.), sin(time / 5.));\n        // uv += rotate(uv, PI / 2.);\n    }\n    if(length(uv) < BOUNDARY)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    float h = atan(uv.y, uv.x) / (2. * PI) + 0.5;\n    float s = float(i) / float(MAX_ITER);\n    float v = s;\n    s *= 1.5;\n    fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 90, 90, 259], [261, 261, 291, 291, 375], [377, 377, 434, 434, 1047]], "test": "untested"}
{"id": "sdyGDy", "name": "Cinema 180°", "author": "Sergeindamix", "description": "Cinema 180°", "tags": ["screen", "seats", "roof"], "likes": 0, "viewed": 242, "published": 3, "date": "1632078616", "time_retrieved": "2024-07-30T19:00:19.501123", "image_code": "\n// Created by SergeInDaMix\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat2 rot(float a) {\treturn mat2(cos(a), sin(a), -sin(a), cos(a)); }\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\n/////////////////////////\n\n\n// signed distance to a regular octogon\nfloat sdOctogon(in vec2 p, in float r)\n{\n    // >>>>>> (iestyn) <<<<<<  This is IQ's original version (https://www.shadertoy.com/view/llGfDG)\n    if (mod(T*0., 2.0) < 1.0)\n    {\n        // pi/8: cos, sin, tan.\n        const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN\n            0.4142135623); // sqrt(2)-1          // TAN\n// reflections\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.x, k.y), p), 0.0)*vec2(k.x, k.y);\n        p -= 2.0*min(dot(vec2(-k.x, k.y), p), 0.0)*vec2(-k.x, k.y);\n        // Polygon side.\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        return length(p)*sign(p.y);\n    }\n    // >>>>>> (iestyn) <<<<<<  This is my modified version, rotated by pi/8\n    else\n    {\n        // The tradeoff is swapping a reflection (dot, min, mul) for a 2D rotation (dot, dot)\n        // The two dot products are independent and can thus be pipelined, so it's possible that\n        // this version is marginally faster... though frankly it probably depends upon which GPU you use :)\n\n        // pi/8: cos, sin, tan (plus sin pi/4)\n        const vec4 k = vec4(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS PI/8\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN PI/8\n            0.4142135623,   // sqrt(2)-1          // TAN PI/8\n            0.7071067812); // 1/sqrt(2)          // SIN PI/4\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.w, -k.w), p), 0.0)*vec2(k.w, -k.w);    // Reflect about pi/4 plane\n        p = vec2(dot(p, vec2(-k.y, -k.x)), dot(p, vec2(-k.x, k.y)));   // Rotate by 22.5 degrees\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);                   // Collapse the polygon edge to a point\n        return length(p)*sign(p.y);\n    }\n}\nvec3 sdgBox(in vec2 p, in vec2 b)\n{\n    vec2 w = abs(p) - b;\n    vec2 s = vec2(p.x < 0.0 ? -1 : 1, p.y < 0.0 ? -1 : 1);\n    float g = max(w.x, w.y);\n    vec2  q = max(w, 0.0);\n    float l = length(q);\n    return vec3((g > 0.0) ? l : g,\n        s*((g > 0.0) ? q / l : ((w.x > w.y) ? vec2(1, 0) : vec2(0, 1))));\n}\nfloat smax(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h*(1.0 - h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return q;\n}\n\nfloat column(vec3 p)\n{\n    float box = sdBox(p, vec3(1, 1, .25));\n    float d = box;\n    vec2 h = vec2(1., 1.1);\n\n    float oct = sdOctogon(p.xy - vec2(-.7, .10), h.x);\n\n    d = smax(oct, d, .05);\n\n\n\n\n    return d;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz)*p3.zy);\n}\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\nvec4 circ(vec2 uv)\n{\n    //uv += 1;//\n    //uv *= .5;\n    vec4 col = vec4(1.0);\n    uv.x += iTime * 0.1;\n    uv += 12.0;\n    vec2 id = floor(uv*8.0);\n    vec2 ruv = fract(uv*8.0) - 0.5;\n\n    vec2 n = vec2(pow(sin(iTime*0.4 + hash22(id).x*1.5), 2.0),\n        pow(cos(iTime*1.2 + hash22(id*3.0 + 2.0).y*5.0), 2.0));\n\n    float d = max(dot(vec2(0.9, -0.8), n), 0.01);\n    float c = smoothstep(0.51, 0.3, length(ruv));\n    vec3 mcol = mix(vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), d)*c*d;\n\n    col.xyz = mcol;\n    float w = 0.1;\n    vec2 a = vec2(uv.x - 0.5, uv.y - 0.66);\n    vec2 b = a * 0.15 / float(10.0);\n\n    uv += b * (hash(uv.xy + fract(iTime))*2.0);\n\n    for (float i = 1.0; i > 0.0; i -= 0.02)\n    {\n        uv -= 0.5;\n        uv *= i;\n        uv += 0.5;\n\n        col.rgb += mcol * w * 1.5;\n        w *= 0.97;\n    }\n    col *= 0.9;\n\n    return col;\n\n}\n//////////////////\n\n////////////////////////////\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) int(k)^int(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x - y)*(y*y + x) + x) / 2.14e9;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep((0.), (1.), fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x, uv.y);\n    float h2 = hash(uv.x + 1., uv.y);\n    float h3 = hash(uv.x, uv.y + 1.);\n    float h4 = hash(uv.x + 1., uv.y + 1.);\n    return mix(mix(h1, h2, crds.x), mix(h3, h4, crds.x), crds.y);\n}\n\nvec2 map(vec2 uv) {\n    return (uv + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n}\n\nvec4 projector(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    float rot = cos(sin(cos(iTime*0.01)*8.)*8.)*0.5;\n    uv*=mat2(cos(0.01*rot), sin(0.01*rot), -sin(0.01*rot), cos(0.01*rot));\n\n    float ntime = floor(iTime*25.) / 25.;\n    float trackingy = hash(ntime, ntime);\n    float trackingx = hash(trackingy, ntime);\n    float trackinglight = hash(trackingx, ntime)*0.05 + 1.;\n    uv.y += trackingy / iResolution.y*0.4;\n    uv.x += trackingx / iResolution.y*0.1;\n\n    vec4 color = vec4(0.0);\n    for (int i = -2; i < 3; i++) {\n        for (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i, j) / iResolution.y / 4.*2.2;\n            float dispersion = hash(hash(hash(uv.x, uv.y), iTime), hash(float(i), float(j)))*0.02 + 1.;\n            float red = texture(iChannel0, map(uv*dispersion*1.03 + off)).x;\n            float green = texture(iChannel0, map(uv*dispersion*1.01 + off)).y;\n            float blue = texture(iChannel0, map(uv*dispersion*1.0 + off)).z;\n            color += pow(vec4(red, green, blue, 1.), vec4(2.));\n        }\n    }\n\n    vec3 satstr = vec3(0.1);\n    mat3 desaturate = (1. - satstr.x*2.) + mat3(satstr, satstr, satstr);\n\n    float bounds = smoothstep(0.02, -0.02, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4)) * smoothstep(2., 0., length(uv));\n    float filmgrain = (noise((uv + mod(floor(ntime*60.), 100.))*iResolution.y / 1.5)*0.5 + 0.5)*0.05;\n    float shotnoise = abs(hash(hash(uv.x, uv.y), ntime))*0.05;\n    fragColor.xyz = smoothstep(-0.4, 2., desaturate*bounds*sqrt(color.xyz / color.w)*trackinglight);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(1., .7))), 3.)*0.25*(sign(trackingy + 0.99)*0.5 + 0.5);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(-1., .7))), 3.)*0.5;\n    fragColor.xyz += filmgrain * mix(0.3, 1.2, bounds) + shotnoise * mix(1.5, 0.5, bounds) + smoothstep(0.06, -0.06, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4))*0.02;\n    fragColor.xyz *= smoothstep(2., 0.2, length(uv));\n    return fragColor;\n}\n/////////////////////////\nvec4 isom(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 a = vec2(2.0*I.x, I.x + I.y);\n    vec2 b = vec2(-2.0*I.x, -I.x + I.y);\n    vec2 c = vec2(-I.x - I.y, I.x - I.y);\n\n    fragColor = vec4(.0);\n\n    if (max(max(max(a.x, a.y), max(b.x, b.y)), max(c.x, c.y)) <= 1.0)\n        if (I.x >= 0.0 && I.x + I.y >= 0.0)\n            //fragColor = vec4(a,0.0,1.0);\n            fragColor = texture(iChannel0, a);\n        else if (I.x <= 0.0 && -I.x + I.y >= 0.0)\n            //fragColor = vec4(b,0.0,1.0);\n            fragColor = texture(iChannel1, b);\n        else\n            // fragColor = vec4(c,0.0,1.0);\n            fragColor = texture(iChannel2, c);\n    return fragColor;\n}\n\nvec4 lines(vec2 uv)\n{\t\t\t\t\n\n    float thickness = 0.21;\n    float speed = 0.5 * 0.;\n\n    float xPhase = mod(6.0*uv.x, 1.0) * 0.;\n    float yPhase = mod(1.09375*uv.y - speed * iTime, 1.0);\n    if (uv.y < 0.0)\n    {\n        yPhase = mod(.5*uv.y, 1.0);\n\n    }\n    float xIntensity = max(0.0, 1.0 - abs(0.5 - xPhase) / thickness);\n    float yIntensity = S(0.0, .1, 1. - yPhase / thickness);//**max(0.0, 1.0 - abs(0.5 - yPhase) / thickness);\n\n    vec4 color = vec4(0.3, 0.7, 1.0, 1.0);\n\n    vec4 result = (yIntensity + xIntensity)*color;\n\n    return result;\n}\n\nfloat cylix(vec3 p, float width, float height)\n{\n    float d = max(sdBox(p, vec3(width,height, width)),length(p.xz) - width);//cilindro\n\n    return d;\n}\n\nfloat arena(vec3 p, float width, float height)\n{\n\n    float d = cylix(p + vec3(0, 1. - height, 0), width, height);//width, height\n\n\n    return d;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat onion(in float d, in float h)\n{\n    return abs(d) - h;\n}\n\n//-------------------------------------------------\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat estadio(vec3 p)\n{\n    float c = 1e10;\n    // single onion cylinder\n    for (int i = 0; i < 10; i++)\n    {\n        float height = .1*float(i) + 1.;\n        float width = float(i) + 1.;\n        float addc = sdCappedCylinder(p, vec2(width, height));\n        //c = onion(addc, 0.02);\n        c = min(c, onion(addc, 0.52));\n        c = max(-arena(p + vec3(0, -height, 0), width, height), c);\n\n        c = max(c, -sdBox(p + vec3(0, -2.1, -6), vec3(11, 2, 6)));\n\n        //c = max(c, pos.y+.02*i);\n    }\n\n    return c;\n}\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h*h*k*(1.0 / 6.0);\n}\nfloat cabeza(vec3 p)\n{\n    float d = 1e10;\n    float r = .2;\n    vec3 q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    q.xy *= rot(.12);\n    q.y += .3;\n    d = min(d, length(q.xz) - r);//cilindro\n    d = max(d, q.y - .0);//cortar altura del cilindro\n    d = max(d, -q.y - .5);//cortar base del cilindro*/\n    q.xy *= rot(.54324);\n    d = smin(d, sdBox(q - vec3(.325, .1, 0), vec3(.2, .2, .2)), .6);\n    q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    d = smin(d, length(q) - .5, .515);\n\n    return d;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nvec3 map(vec3 p)\n{\n    float mid = 0.;\n\n    vec3 q = p;\n    vec3 pos = p;\n\n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    q.x = abs(p.x);\n    float d0 = column(q - vec3(2, 0, 0));\n    float box = sdBox(p + vec3(0, 0, 0), vec3(3, 1, 10));\n    box = abs(box) - .1;\n\n    float d = box;\n\n\n    vec3 quad = sdgBox(p.xy - vec2(-.25, .1), vec2(4, .5));\n    quad = abs(quad) - .0125;\n\n    d = max(d, d - quad.x);\n\n    q.y += .5;\n    float sph = length(q) - .5;\n    float cyl = sdBox(q, vec3(.35));//length(q.xz) - .4;//cilindro\n    //cyl=max(-box,cyl);\n    sph = max(-sph, cyl);\n\n    q.y -= .5;\n    q *= 1.021;\n    float d1 = column(q - vec3(2, 0, 0));\n    float box2 = sdBox(p + vec3(0, -0, 0), vec3(3, 1, 10));\n    box2 = abs(box2) - .11;\n\n    float box3 = sdBox(p + vec3(0, -.1, -9.875), vec3(3, .5, .010));\n\n    float bobb = sdBoundingBox(p, vec3(.5), .035);\n    float bobc = sdBox(p+vec3(0,-.0,0), vec3(.45));\n\n\n    float c = estadio(p);\n    float c1 = sdCylinder(p, vec2(10.));\n    c1 = abs(c1) - .1;\n    float roof = arena(p + vec3(0, -10, 0), 10., 1.);\n    float c2 = arena(p + vec3(0, -0, 0), 1., .6);\n    float head = cabeza(p+vec3(0,1,0));\n    for (int i = 0; i < 9; i++)\n    {\n        q = p/.5;\n        float headAdd = cabeza(RotateY(q, -22.5 * float(i)) + vec3(5, -2, float(i)*pi));\n        head = smin(head, headAdd, .1);\n    }\n    //q= RotateY(q, -22.5*T);\n    float stnd = sdBoundingBox(p + vec3(0, -.75, 0), vec3(.5), .035);\n    \n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    float screen = sdBox(q-vec3(0,4,0),vec3(1.5,2.,.01));\n\n    d = 1e10;\n\n\n    //if(d > sph){d = sph; mid = 2.;}\n    //if (d > d1) { d = d1; mid = 8.; }\n    //if (d > box2) { d = box2; mid = 9.; }\n    //if (d > box3) { d = box3; mid = 6.; }\n    //if (d > bobb) { d = bobb; mid = 8.; }\n    //if (d > bobc) { d = bobc; mid = 9.; }\n    if (d > c) { d = c; mid = 3.; }\n    if (d > c1) { d = c1; mid = 6.; }\n    if (d > c2) { d = c2; mid = 2.; }\n    if (d > roof) { d = roof; mid = 9.; }\n    //if (d > screen) { d = screen; mid = 6.; }\n    //if (d > stnd) { d = stnd; mid = 3.; }\n    //if (d > head) { d = head; mid = 3.; }\n\n\n    return vec3(d, mid, 0.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 124; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec3(t, res.y, res.z);\n}\n\nvec3 remap(vec3 p)\n{\n    p.xy = (p.xy + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n    return p;\n}\nvec3 remap2(vec3 p)\n{\n    p.xy *= .5 + .5;\n    return p;\n}vec3 remap3(vec3 p)\n{\n    p = remap2(p)/10.;\n\n    return p;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    //6 faces texturing\n    p = remap3(p);\n    vec4 colXZ = projector(p.xz) * 5. * circ(p.xz);//texture(_Tex6, p.xz*.5 + .5)*5;\n    vec4 colYZ = projector(p.yz) * 5. * lines(p.yz) * 5.;//texture(sam, p.yz*.5 + .5)*5;\n\n    vec4 colXY = texture(iChannel2, p.xy*.5 + .5)*5.; //\n\n    n = abs(n);\n\n\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n\n    return colYZ * n.x + colXZ * n.y + colXY * n.z;\n    //return p1 * abs(n.z) + p2 * abs(n.y) + p3 * abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\n\nfloat refl;\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n\t\t\t{\n    vec3 l0_pos = vec3(0., 3, 0);//0., 2.4, floor((p.z+5.)/10.)*10.);\n    vec3 l0_dir = normalize(l0_pos - p);\n    vec3 l0_col = vec3(1.);\n\n    vec3 mc = vec3(1., 1.02, 0.92);\n\n    refl = 0.;\n\n\n    if (mid > 8.)\n    {\n        mc = texcube(iChannel0, p.xyz*2., n).xyz;\n    }\n    else if (mid > 7.)\n    {\n        mc = vec3(.996, .945, .882)*.2;\n    }\n    else if (mid > 6.)\n    {\n        mc = vec3(1., 1., 1.1)*1.1;\n        mc.yz -= pow(texcube(iChannel3, p.yxz*.8, n).x, 3.5)*3.5;\n        mc = max(vec3(0.), mc);\n    }\n    else if (mid > 5.)\n    {\n        p += 10.;//\n        p.x *= .5;\n        p.y -= 10.;\n\n        p *= .1;\n\n        mc = texture(iChannel0, p.xy).xyz*2.;\n    }\n    else if (mid > 4.)\n    {\n\n        mc = vec3(0.1);\n    }\n    else if (mid > 3.)\n    {\n        mc = vec3(0.9, 0.0, 0.);\n        if (abs(p.y + 0.4) < 0.1)\n            mc = vec3(1.);\n    }\n    else if (mid > 2.)\n    {\n        mc = texture(iChannel1, p.xz*.1).xyz * 0.5;\n        refl = 1.;\n    }\n    else if (mid > 1.)\n    {\n        mc = vec3(20.0);\n    }\n    else if (mid > 0.)\n    {\n        mc = vec3(0.3, 0.9, 1.) * 0.4;\n\n    }\n    /*else\n    {\n        if(p.y<2.9)\n        {\n            n=bump_mapping(p, n, 0.2/(1.+dist*0.4));\n        }\n\n        if(p.y>0.5 && (abs(abs(p.y)-2.2)<0.67))\n            mc=vec3(0.3, 0.9, 1.) * 0.5;\n\n    }\n\n    if(p.y < 0.5 && abs(p.x)>2.2 && (abs(abs(p.y)-3.)<0.18))\n    {\n        mc=vec3(0.3, 0.9, 1.) * 0.2;\n        refl = 0.8;\n    }\n\n    // bloody\n    {\n        vec3 q = p;\n        if(q.x<0.&&q.y>-2.9)\n           q.z += 1.;\n\n        mc.yz -= pow(texcube(iChannel3, q.xyz*.08, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n\n    }*/\n\n\n    float occ = get_ao(p, n);\n    float dif = 8.*direct_light(p, l0_pos, n, 8.3);\n    float bac = max(0., dot(-l0_dir, n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(-rd, reflect(-l0_dir, n)), 0.0, 1.0), 20.0));\n\n    float env = 1.;\n\n    vec3 lin = vec3(0.);\n\n    lin += 4. * dif * occ;\n    lin += 0.5 * bac * (1.) * occ;\n    lin += 1.0 * bce * (1.) * occ;\n    lin += 1.0 * env * occ;\n    lin += 2.0* spe * (1.);\n    lin = lin * 0.2 * mc * (.5 + .5*occ);\n    return lin;\n}\n\n\nvec3 calc_reflection(vec3 ro, vec3 prev_rd, vec3 n, vec2 screen)\n{         \n    vec3 rd = reflect(prev_rd, n);\n    ro += 0.1 * n;\n\n    \n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    res = vec3(t, res.y, res.z);\n    \n    vec3 col = vec3(0.);\n    if(res.x > -.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        n = get_normal(pos);\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n    }\n    return col;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.3;\n    \n    vec3 look_at;\n    float yoffset=sin(iTime*2.)*0.02;\n    \n    if(iTime < 7.)\n    {\n   \t\tlook_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n    }\n    else if(iTime < 15.)\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -13.+iTime*0.1);\n    }\n    else\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n        /*look_at = vec3(5., 0., v);\n\n        ro = look_at + vec3(-6., -1.3+yoffset, -12.);*/\n\n    }\n      \n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0, 3, -3);\n       \n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    vec3 res = intersect(ro, rd);\n    \n    vec3 col = vec3(0.);\n    \n    if(res.x > -0.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 n = get_normal(pos);\n\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n        if(refl > 0.)\n        {\n            float f = .04 + (1.-.04)*pow(1.-max(dot(n,-rd),0.),5.);\n            col += f*refl*calc_reflection(pos, rd, n, fragCoord);\n            //col += 0.2*refl*calc_reflection(pos, rd, n, fragCoord);\n             // bloody\n    \t\t{ \n        \t\tcol.yz -= pow(texcube(iChannel3, pos.xyz*.08, n).x,4.5)*4.5;\n        \t\tcol = max(vec3(0.),col);\n        \n    \t\t}\n        }\n        col=mix(col, 0.15*vec3(0.4,0.75,1.0), 1.0-exp(-0.0015*res.x*res.x) );\n\n    }\n    \n    fragColor.xyz = col;\n    fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime));\n    /*if(iTime > 6.)\n    {\n        //fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(0.,1., iTime-6.));\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-7.));\n\n    }\n    if(iTime > 14.)\n    {\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-15.));\n\n    }*/\n\n\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Created by SergeInDaMix\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nmat2 rot(float a) {\treturn mat2(cos(a), sin(a), -sin(a), cos(a)); }\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\n/////////////////////////\n\n\n// signed distance to a regular octogon\nfloat sdOctogon(in vec2 p, in float r)\n{\n    // >>>>>> (iestyn) <<<<<<  This is IQ's original version (https://www.shadertoy.com/view/llGfDG)\n    if (mod(T*0., 2.0) < 1.0)\n    {\n        // pi/8: cos, sin, tan.\n        const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN\n            0.4142135623); // sqrt(2)-1          // TAN\n// reflections\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.x, k.y), p), 0.0)*vec2(k.x, k.y);\n        p -= 2.0*min(dot(vec2(-k.x, k.y), p), 0.0)*vec2(-k.x, k.y);\n        // Polygon side.\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n        return length(p)*sign(p.y);\n    }\n    // >>>>>> (iestyn) <<<<<<  This is my modified version, rotated by pi/8\n    else\n    {\n        // The tradeoff is swapping a reflection (dot, min, mul) for a 2D rotation (dot, dot)\n        // The two dot products are independent and can thus be pipelined, so it's possible that\n        // this version is marginally faster... though frankly it probably depends upon which GPU you use :)\n\n        // pi/8: cos, sin, tan (plus sin pi/4)\n        const vec4 k = vec4(-0.9238795325,   // sqrt(2+sqrt(2))/2  // COS PI/8\n            0.3826834323,   // sqrt(2-sqrt(2))/2  // SIN PI/8\n            0.4142135623,   // sqrt(2)-1          // TAN PI/8\n            0.7071067812); // 1/sqrt(2)          // SIN PI/4\n        p = abs(p);\n        p -= 2.0*min(dot(vec2(k.w, -k.w), p), 0.0)*vec2(k.w, -k.w);    // Reflect about pi/4 plane\n        p = vec2(dot(p, vec2(-k.y, -k.x)), dot(p, vec2(-k.x, k.y)));   // Rotate by 22.5 degrees\n        p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);                   // Collapse the polygon edge to a point\n        return length(p)*sign(p.y);\n    }\n}\nvec3 sdgBox(in vec2 p, in vec2 b)\n{\n    vec2 w = abs(p) - b;\n    vec2 s = vec2(p.x < 0.0 ? -1 : 1, p.y < 0.0 ? -1 : 1);\n    float g = max(w.x, w.y);\n    vec2  q = max(w, 0.0);\n    float l = length(q);\n    return vec3((g > 0.0) ? l : g,\n        s*((g > 0.0) ? q / l : ((w.x > w.y) ? vec2(1, 0) : vec2(0, 1))));\n}\nfloat smax(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h*(1.0 - h);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return q;\n}\n\nfloat column(vec3 p)\n{\n    float box = sdBox(p, vec3(1, 1, .25));\n    float d = box;\n    vec2 h = vec2(1., 1.1);\n\n    float oct = sdOctogon(p.xy - vec2(-.7, .10), h.x);\n\n    d = smax(oct, d, .05);\n\n\n\n\n    return d;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e)\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz)*p3.zy);\n}\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\nvec4 circ(vec2 uv)\n{\n    //uv += 1;//\n    //uv *= .5;\n    vec4 col = vec4(1.0);\n    uv.x += iTime * 0.1;\n    uv += 12.0;\n    vec2 id = floor(uv*8.0);\n    vec2 ruv = fract(uv*8.0) - 0.5;\n\n    vec2 n = vec2(pow(sin(iTime*0.4 + hash22(id).x*1.5), 2.0),\n        pow(cos(iTime*1.2 + hash22(id*3.0 + 2.0).y*5.0), 2.0));\n\n    float d = max(dot(vec2(0.9, -0.8), n), 0.01);\n    float c = smoothstep(0.51, 0.3, length(ruv));\n    vec3 mcol = mix(vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), d)*c*d;\n\n    col.xyz = mcol;\n    float w = 0.1;\n    vec2 a = vec2(uv.x - 0.5, uv.y - 0.66);\n    vec2 b = a * 0.15 / float(10.0);\n\n    uv += b * (hash(uv.xy + fract(iTime))*2.0);\n\n    for (float i = 1.0; i > 0.0; i -= 0.02)\n    {\n        uv -= 0.5;\n        uv *= i;\n        uv += 0.5;\n\n        col.rgb += mcol * w * 1.5;\n        w *= 0.97;\n    }\n    col *= 0.9;\n\n    return col;\n\n}\n//////////////////\n\n////////////////////////////\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) int(k)^int(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x - y)*(y*y + x) + x) / 2.14e9;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep((0.), (1.), fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x, uv.y);\n    float h2 = hash(uv.x + 1., uv.y);\n    float h3 = hash(uv.x, uv.y + 1.);\n    float h4 = hash(uv.x + 1., uv.y + 1.);\n    return mix(mix(h1, h2, crds.x), mix(h3, h4, crds.x), crds.y);\n}\n\nvec2 map(vec2 uv) {\n    return (uv + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n}\n\nvec4 projector(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    float rot = cos(sin(cos(iTime*0.01)*8.)*8.)*0.5;\n    uv*=mat2(cos(0.01*rot), sin(0.01*rot), -sin(0.01*rot), cos(0.01*rot));\n\n    float ntime = floor(iTime*25.) / 25.;\n    float trackingy = hash(ntime, ntime);\n    float trackingx = hash(trackingy, ntime);\n    float trackinglight = hash(trackingx, ntime)*0.05 + 1.;\n    uv.y += trackingy / iResolution.y*0.4;\n    uv.x += trackingx / iResolution.y*0.1;\n\n    vec4 color = vec4(0.0);\n    for (int i = -2; i < 3; i++) {\n        for (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i, j) / iResolution.y / 4.*2.2;\n            float dispersion = hash(hash(hash(uv.x, uv.y), iTime), hash(float(i), float(j)))*0.02 + 1.;\n            float red = texture(iChannel0, map(uv*dispersion*1.03 + off)).x;\n            float green = texture(iChannel0, map(uv*dispersion*1.01 + off)).y;\n            float blue = texture(iChannel0, map(uv*dispersion*1.0 + off)).z;\n            color += pow(vec4(red, green, blue, 1.), vec4(2.));\n        }\n    }\n\n    vec3 satstr = vec3(0.1);\n    mat3 desaturate = (1. - satstr.x*2.) + mat3(satstr, satstr, satstr);\n\n    float bounds = smoothstep(0.02, -0.02, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4)) * smoothstep(2., 0., length(uv));\n    float filmgrain = (noise((uv + mod(floor(ntime*60.), 100.))*iResolution.y / 1.5)*0.5 + 0.5)*0.05;\n    float shotnoise = abs(hash(hash(uv.x, uv.y), ntime))*0.05;\n    fragColor.xyz = smoothstep(-0.4, 2., desaturate*bounds*sqrt(color.xyz / color.w)*trackinglight);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(1., .7))), 3.)*0.25*(sign(trackingy + 0.99)*0.5 + 0.5);\n    fragColor.xyz += pow(1. / (1. + length(uv*vec2(2, 1) - vec2(-1., .7))), 3.)*0.5;\n    fragColor.xyz += filmgrain * mix(0.3, 1.2, bounds) + shotnoise * mix(1.5, 0.5, bounds) + smoothstep(0.06, -0.06, max(abs(uv.x) - 0.7, abs(uv.y) - 0.4))*0.02;\n    fragColor.xyz *= smoothstep(2., 0.2, length(uv));\n    return fragColor;\n}\n/////////////////////////\nvec4 isom(vec2 fragCoord)\n{\n    vec4 fragColor;\n    vec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 a = vec2(2.0*I.x, I.x + I.y);\n    vec2 b = vec2(-2.0*I.x, -I.x + I.y);\n    vec2 c = vec2(-I.x - I.y, I.x - I.y);\n\n    fragColor = vec4(.0);\n\n    if (max(max(max(a.x, a.y), max(b.x, b.y)), max(c.x, c.y)) <= 1.0)\n        if (I.x >= 0.0 && I.x + I.y >= 0.0)\n            //fragColor = vec4(a,0.0,1.0);\n            fragColor = texture(iChannel0, a);\n        else if (I.x <= 0.0 && -I.x + I.y >= 0.0)\n            //fragColor = vec4(b,0.0,1.0);\n            fragColor = texture(iChannel1, b);\n        else\n            // fragColor = vec4(c,0.0,1.0);\n            fragColor = texture(iChannel2, c);\n    return fragColor;\n}\n\nvec4 lines(vec2 uv)\n{\t\t\t\t\n\n    float thickness = 0.21;\n    float speed = 0.5 * 0.;\n\n    float xPhase = mod(6.0*uv.x, 1.0) * 0.;\n    float yPhase = mod(1.09375*uv.y - speed * iTime, 1.0);\n    if (uv.y < 0.0)\n    {\n        yPhase = mod(.5*uv.y, 1.0);\n\n    }\n    float xIntensity = max(0.0, 1.0 - abs(0.5 - xPhase) / thickness);\n    float yIntensity = S(0.0, .1, 1. - yPhase / thickness);//**max(0.0, 1.0 - abs(0.5 - yPhase) / thickness);\n\n    vec4 color = vec4(0.3, 0.7, 1.0, 1.0);\n\n    vec4 result = (yIntensity + xIntensity)*color;\n\n    return result;\n}\n\nfloat cylix(vec3 p, float width, float height)\n{\n    float d = max(sdBox(p, vec3(width,height, width)),length(p.xz) - width);//cilindro\n\n    return d;\n}\n\nfloat arena(vec3 p, float width, float height)\n{\n\n    float d = cylix(p + vec3(0, 1. - height, 0), width, height);//width, height\n\n\n    return d;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat onion(in float d, in float h)\n{\n    return abs(d) - h;\n}\n\n//-------------------------------------------------\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat estadio(vec3 p)\n{\n    float c = 1e10;\n    // single onion cylinder\n    for (int i = 0; i < 10; i++)\n    {\n        float height = .1*float(i) + 1.;\n        float width = float(i) + 1.;\n        float addc = sdCappedCylinder(p, vec2(width, height));\n        //c = onion(addc, 0.02);\n        c = min(c, onion(addc, 0.52));\n        c = max(-arena(p + vec3(0, -height, 0), width, height), c);\n\n        c = max(c, -sdBox(p + vec3(0, -2.1, -6), vec3(11, 2, 6)));\n\n        //c = max(c, pos.y+.02*i);\n    }\n\n    return c;\n}\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h*h*k*(1.0 / 6.0);\n}\nfloat cabeza(vec3 p)\n{\n    float d = 1e10;\n    float r = .2;\n    vec3 q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    q.xy *= rot(.12);\n    q.y += .3;\n    d = min(d, length(q.xz) - r);//cilindro\n    d = max(d, q.y - .0);//cortar altura del cilindro\n    d = max(d, -q.y - .5);//cortar base del cilindro*/\n    q.xy *= rot(.54324);\n    d = smin(d, sdBox(q - vec3(.325, .1, 0), vec3(.2, .2, .2)), .6);\n    q = p;\n    //q.xz = opRepLim(p.xz - vec2(0, 0), 3, vec2(0, -3), vec2(0, 1));\n\n    d = smin(d, length(q) - .5, .515);\n\n    return d;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nvec3 map(vec3 p)\n{\n    float mid = 0.;\n\n    vec3 q = p;\n    vec3 pos = p;\n\n    q = opRepLim(p, 5.0, vec3(1, 0, 1));\n    q.x = abs(p.x);\n    float d0 = column(q - vec3(2, 0, 0));\n    float box = sdBox(p + vec3(0, 0, 0), vec3(3, 1, 10));\n    box = abs(box) - .1;\n\n    float d = box;\n\n\n    vec3 quad = sdgBox(p.xy - vec2(-.25, .1), vec2(4, .5));\n    quad = abs(quad) - .0125;\n\n    d = max(d, d - quad.x);\n\n    q.y += .5;\n    float sph = length(q) - .5;\n    float cyl = sdBox(q, vec3(.35));//length(q.xz) - .4;//cilindro\n    //cyl=max(-box,cyl);\n    sph = max(-sph, cyl);\n\n    q.y -= .5;\n    q *= 1.021;\n    float d1 = column(q - vec3(2, 0, 0));\n    float box2 = sdBox(p + vec3(0, -0, 0), vec3(3, 1, 10));\n    box2 = abs(box2) - .11;\n\n    float box3 = sdBox(p + vec3(0, -.1, -9.875), vec3(3, .5, .010));\n\n    float bobb = sdBoundingBox(p, vec3(.5), .035);\n    float bobc = sdBox(p+vec3(0,-.0,0), vec3(.45));\n\n\n    float c = estadio(p);\n    float c1 = sdCylinder(p, vec2(10.));\n    c1 = abs(c1) - .1;\n    float roof = arena(p + vec3(0, -10, 0), 10., 1.);\n    float c2 = arena(p + vec3(0, -0, 0), 1., .6);\n    float head = cabeza(p+vec3(0,1,0));\n    for (int i = 0; i < 9; i++)\n    {\n        q = p/.5;\n        float headAdd = cabeza(RotateY(q, -22.5 * float(i)) + vec3(5, -2, float(i)*pi));\n        head = smin(head, headAdd, .1);\n    }\n    //q= RotateY(q, -22.5*T);\n    float stnd = sdBoundingBox(p + vec3(0, -.75, 0), vec3(.5), .035);\n\n\n    d = 1e10;\n\n\n    //if(d > sph){d = sph; mid = 2.;}\n    //if (d > d1) { d = d1; mid = 8.; }\n    //if (d > box2) { d = box2; mid = 9.; }\n    //if (d > box3) { d = box3; mid = 6.; }\n    //if (d > bobb) { d = bobb; mid = 8.; }\n    //if (d > bobc) { d = bobc; mid = 9.; }\n    if (d > c) { d = c; mid = 3.; }\n    if (d > c1) { d = c1; mid = 6.; }\n    if (d > c2) { d = c2; mid = 2.; }\n    if (d > roof) { d = roof; mid = 9.; }\n    //if (d > stnd) { d = stnd; mid = 3.; }\n    //if (d > head) { d = head; mid = 3.; }\n\n\n    return vec3(d, mid, 0.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec3 intersect(vec3 ro, vec3 rd)\n{\n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 124; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec3(t, res.y, res.z);\n}\n\nvec3 remap(vec3 p)\n{\n    p.xy = (p.xy + vec2(0.7, 0.4))*vec2(1., iResolution.x / iResolution.y)*0.7;\n    return p;\n}\nvec3 remap2(vec3 p)\n{\n    p.xy *= .5 + .5;\n    return p;\n}vec3 remap3(vec3 p)\n{\n    p = remap2(p)/10.;\n\n    return p;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    //6 faces texturing\n    p = remap3(p);\n    vec4 colXZ = projector(p.xz) * 5. * circ(p.xz);//texture(_Tex6, p.xz*.5 + .5)*5;\n    vec4 colYZ = projector(p.yz) * 5. * lines(p.yz) * 5.;//texture(sam, p.yz*.5 + .5)*5;\n\n    vec4 colXY = texture(iChannel2, p.xy*.5 + .5)*5.; //\n\n    n = abs(n);\n\n\n    n *= pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n\n    return colYZ * n.x + colXZ * n.y + colXY * n.z;\n    //return p1 * abs(n.z) + p2 * abs(n.y) + p3 * abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\n\nfloat refl;\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n\t\t\t{\n    vec3 l0_pos = vec3(0., 3, 0);//0., 2.4, floor((p.z+5.)/10.)*10.);\n    vec3 l0_dir = normalize(l0_pos - p);\n    vec3 l0_col = vec3(1.);\n\n    vec3 mc = vec3(1., 1.02, 0.92);\n\n    refl = 0.;\n\n\n    if (mid > 8.)\n    {\n        mc = texcube(iChannel0, p.xyz*2., n).xyz;\n    }\n    else if (mid > 7.)\n    {\n        mc = vec3(.996, .945, .882)*.2;\n    }\n    else if (mid > 6.)\n    {\n        mc = vec3(1., 1., 1.1)*1.1;\n        mc.yz -= pow(texcube(iChannel3, p.yxz*.8, n).x, 3.5)*3.5;\n        mc = max(vec3(0.), mc);\n    }\n    else if (mid > 5.)\n    {\n        p += 10.;//\n        p.x *= .5;\n        p.y -= 10.;\n\n        p *= .1;\n\n        mc = texture(iChannel0, p.xy).xyz*2.;\n    }\n    else if (mid > 4.)\n    {\n\n        mc = vec3(0.1);\n    }\n    else if (mid > 3.)\n    {\n        mc = vec3(0.9, 0.0, 0.);\n        if (abs(p.y + 0.4) < 0.1)\n            mc = vec3(1.);\n    }\n    else if (mid > 2.)\n    {\n        mc = texture(iChannel1, p.xz*.1).xyz * 0.5;\n        refl = 1.;\n    }\n    else if (mid > 1.)\n    {\n        mc = vec3(20.0);\n    }\n    else if (mid > 0.)\n    {\n        mc = vec3(0.3, 0.9, 1.) * 0.4;\n\n    }\n    /*else\n    {\n        if(p.y<2.9)\n        {\n            n=bump_mapping(p, n, 0.2/(1.+dist*0.4));\n        }\n\n        if(p.y>0.5 && (abs(abs(p.y)-2.2)<0.67))\n            mc=vec3(0.3, 0.9, 1.) * 0.5;\n\n    }\n\n    if(p.y < 0.5 && abs(p.x)>2.2 && (abs(abs(p.y)-3.)<0.18))\n    {\n        mc=vec3(0.3, 0.9, 1.) * 0.2;\n        refl = 0.8;\n    }\n\n    // bloody\n    {\n        vec3 q = p;\n        if(q.x<0.&&q.y>-2.9)\n           q.z += 1.;\n\n        mc.yz -= pow(texcube(iChannel3, q.xyz*.08, n).x,3.5)*3.5;\n        mc = max(vec3(0.),mc);\n\n    }*/\n\n\n    float occ = get_ao(p, n);\n    float dif = 8.*direct_light(p, l0_pos, n, 8.3);\n    float bac = max(0., dot(-l0_dir, n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(-rd, reflect(-l0_dir, n)), 0.0, 1.0), 20.0));\n\n    float env = 1.;\n\n    vec3 lin = vec3(0.);\n\n    lin += 4. * dif * occ;\n    lin += 0.5 * bac * (1.) * occ;\n    lin += 1.0 * bce * (1.) * occ;\n    lin += 1.0 * env * occ;\n    lin += 2.0* spe * (1.);\n    lin = lin * 0.2 * mc * (.5 + .5*occ);\n    return lin;\n}\n\n\nvec3 calc_reflection(vec3 ro, vec3 prev_rd, vec3 n, vec2 screen)\n{         \n    vec3 rd = reflect(prev_rd, n);\n    ro += 0.1 * n;\n\n    \n    vec3 res;\n    float t = 0.01;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.005 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    res = vec3(t, res.y, res.z);\n    \n    vec3 col = vec3(0.);\n    if(res.x > -.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        n = get_normal(pos);\n        col = lighting(ro, rd, pos, n, res.y, res.x);\n    }\n    return col;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.3;\n    \n    vec3 look_at;\n    float yoffset=sin(iTime*2.)*0.02;\n    \n    if(iTime < 7.)\n    {\n   \t\tlook_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n    }\n    else if(iTime < 15.)\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -13.+iTime*0.1);\n    }\n    else\n    {\n        look_at = vec3(0., 0., v);\n    \tro = look_at + vec3(0., -1.3, -23.+iTime*0.1);     \n        /*look_at = vec3(5., 0., v);\n\n        ro = look_at + vec3(-6., -1.3+yoffset, -12.);*/\n\n    }\n      \n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\t\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    ro = vec3(0, 3, -3);\n       \n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    vec3 res = intersect(ro, rd);\n    \n    vec3 col = vec3(0.);\n    \n    if(res.x > -0.5)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 n = get_normal(pos);\n\n        col = texture(iChannel2, vec2(0.22, 0.3) * (pos.zy + vec2(18.25, -5.6))).xyz;//col = lighting(ro, rd, pos, n, res.y, res.x);\n        if(refl > 0.)\n        {\n            float f = .04 + (1.-.04)*pow(1.-max(dot(n,-rd),0.),5.);\n            col += f*refl*calc_reflection(pos, rd, n, fragCoord);\n            //col += 0.2*refl*calc_reflection(pos, rd, n, fragCoord);\n             // bloody\n    \t\t{ \n        \t\tcol.yz -= pow(texcube(iChannel3, pos.xyz*.08, n).x,4.5)*4.5;\n        \t\tcol = max(vec3(0.),col);\n        \n    \t\t}\n        }\n        col=mix(col, 0.15*vec3(0.4,0.75,1.0), 1.0-exp(-0.0015*res.x*res.x) );\n\n    }\n    \n    fragColor.xyz = col;\n    fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime));\n    /*if(iTime > 6.)\n    {\n        //fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(0.,1., iTime-6.));\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-7.));\n\n    }\n    if(iTime > 14.)\n    {\n        fragColor.xyz = mix(fragColor.xyz, vec3(0.), smoothstep(1.,0., iTime-15.));\n\n    }*/\n\n\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyGDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1, 115, 134, 134, 182], [290, 330, 370, 471, 2081], [2082, 2082, 2117, 2117, 2393], [2394, 2394, 2435, 2435, 2539], [2542, 2542, 2571, 2571, 2659], [2660, 2660, 2709, 2709, 2774], [2776, 2776, 2798, 2798, 2992], [2994, 2994, 3040, 3040, 3363], [3366, 3366, 3387, 3387, 3527], [3529, 3529, 3549, 3549, 3604], [3606, 3606, 3626, 3659, 4463], [4740, 4740, 4770, 4770, 4858], [4860, 4860, 4882, 4882, 5173], [5175, 5175, 5194, 5194, 5274], [5276, 5276, 5308, 5308, 7308], [7309, 7335, 7362, 7362, 8060], [8062, 8062, 8083, 8083, 8615], [8617, 8617, 8665, 8665, 8769], [8771, 8771, 8819, 8819, 8918], [8920, 8920, 8954, 8954, 9061], [9062, 9062, 9099, 9099, 9124], [9179, 9179, 9219, 9219, 9326], [9327, 9327, 9350, 9350, 9846], [9847, 9847, 9886, 9886, 9978], [9979, 9979, 10001, 10001, 10548], [10549, 10549, 10585, 10585, 10746], [10748, 10748, 10766, 10766, 12876], [12878, 12878, 12903, 12903, 13130], [13132, 13132, 13166, 13166, 13451], [13453, 13453, 13473, 13473, 13569], [13570, 13570, 13591, 13591, 13628], [13628, 13628, 13649, 13649, 13689], [13691, 13691, 13736, 13736, 14293], [14295, 14295, 14323, 14323, 14404], [14406, 14406, 14455, 14455, 14719], [14721, 14721, 14751, 14751, 14939], [14941, 14941, 15002, 15002, 15197], [15213, 15213, 15288, 15288, 17454], [17457, 17457, 17523, 17523, 18072], [18078, 18078, 18132, 18132, 18868], [18872, 18872, 18927, 18927, 20353]], "test": "untested"}
{"id": "slsXRN", "name": "Checkerboard Double Integral", "author": "oneshade", "description": "My take on https://iquilezles.org/articles/checkerfiltering/checkerfiltering.htm\nDrag the corners of the blue rectangle (integration area).\nThe value in the corner is the number of white squares within the blue area.", "tags": ["2d", "checkerboard", "boxblur", "integration", "doubleintegral"], "likes": 8, "viewed": 190, "published": 3, "date": "1632076041", "time_retrieved": "2024-07-30T19:00:20.264083", "image_code": "// My take on https://iquilezles.org/articles/checkerfiltering\n// Desmos graph with derivation: https://www.desmos.com/calculator/wdu1remdvx\n\n// Uncomment me\n//#define BOX_BLUR_DEMO\n\n// Double integral of mod(floor(x) + floor(y), 2) over the\n// rectangular region bounded by points A and B\nfloat integrateCheckers(in vec2 A, in vec2 B) {\n    vec2 D1 = B - A, D2 = abs(mod(B, 2.0) - 1.0) - abs(mod(A, 2.0) - 1.0);\n    return (D1.x * D1.y - D2.x * D2.y) / 2.0;\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 Hash12(in float p) {\n\tvec3 p3 = fract(p * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n#define drawSDF(dist, color) fragColor.rgb = mix(fragColor.rgb, color.rgb, smoothstep(unit, 0.0, dist) * color.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 5.0;\n    float unit = 10.0 / iResolution.y;\n\n    #ifndef BOX_BLUR_DEMO\n    // Checkerboard\n    float checker = mod(floor(uv.x) + floor(uv.y), 2.0);\n    fragColor = vec4(checker);\n\n    // Animated integration bounds\n    vec2 A = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 B = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        vec2 anim = 0.5 * iTime + vec2(11.13, -85.73);\n        A = mix(Hash12(floor(anim.x)), Hash12(ceil(anim.x)), smoothstep(0.0, 1.0, fract(anim.x))) * 5.0 - 2.5;\n        B = mix(Hash12(floor(anim.y)), Hash12(ceil(anim.y)), smoothstep(0.0, 1.0, fract(anim.y))) * 5.0 - 2.5;\n    }\n\n    // Draw integration area\n    float box = sdBox(uv - 0.5 * (A + B), 0.5 * abs(B - A));\n    drawSDF(box, vec4(0.0, 0.0, 1.0, 0.5));\n    drawSDF(abs(box), vec4(0.0, 0.0, 1.0, 1.0));\n\n    // Draw integration bound corners\n    drawSDF(sdDisk(uv, A, 0.08), vec4(1.0, 0.0, 0.0, 1.0));\n    drawSDF(sdDisk(uv, B, 0.08), vec4(0.0, 1.0, 0.0, 1.0));\n\n    // Display double integral in the corner\n    vec2 corner = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    float area = integrateCheckers(min(A, B), max(A, B));\n    fragColor.rgb = digitIn(fragColor.rgb, vec3(1.0, 0.5, 0.0), uv * 0.2 + corner - 0.05, 100.0, area);\n\n    #else\n    vec2 blur = 0.25 + 0.25 * vec2(cos(0.5 * iTime), sin(iTime)) + 1e-3;\n\n    // Count white squares surrounding\n    // the pixel within the blur radius\n    fragColor = vec4(integrateCheckers(uv - blur, uv + blur));\n\n    // Divide by total integration area to average (mean filter or box blur)\n    fragColor /= 4.0 * blur.x * blur.y;\n\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Handy debugging font (which I also use for displaying numeric results) by @valalalalala\n// Thanks!\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "#define SELECTION_RADIUS 0.25\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor.xy = vec2(-1.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor.xy = vec2( 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < 2 && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 5.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            if (length(mouse - fragColor.xy) < SELECTION_RADIUS) {\n                fragColor.xy = mouse;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsXRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 290, 337, 337, 460], [462, 470, 518, 518, 550], [552, 552, 587, 587, 667], [669, 710, 735, 735, 863], [979, 979, 1034, 1034, 2726]], "test": "untested"}
{"id": "7sGGWy", "name": "LGBT+ Flag", "author": "Ravbug", "description": "Generating the lgbt flag using hsv", "tags": ["animation", "flag", "hsv", "gay", "hsb", "lgbt"], "likes": 2, "viewed": 272, "published": 3, "date": "1632072531", "time_retrieved": "2024-07-30T19:00:21.033028", "image_code": "// set to 0 to disable the waving animation\n#define WAVE 1\n\n// adjust the number of stripes\nconst float stripes = 6.0;\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n// linear value remap\nfloat remap(float value, float low1, float high1, float low2, float high2){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// step function w/ floor\nfloat stepf(float value,float steps){\n    return remap(floor(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// used to control position on the rainbow\nfloat hsbinfcufve(float x){\n    return pow(x,1.5);\n}\n\n// used to control brightness\nfloat b(float x){\n    return 1.0 - pow(x,3.0);\n}\n\n// prevent wraparound\nfloat clampInRange(float x){\n    return ((x >= 0.0 && x <= 1.0) ? x : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     #if WAVE\n     uv.y += (sin(10.0*(-iTime/3.0+uv.x))*0.03);\n     uv.y = clampInRange(uv.y);\n     #endif\n\n     // calculate where to sample on rainbow\n     float coord = hsbinfcufve(stepf(1.0-uv.y,stripes));\n     \n     // calculate color & brightness\n     vec3 resCol = hsb2rgb(vec3(coord,1.0,b(coord)));\n \n\n    // Output to screen\n    fragColor = vec4(resCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 194, 220, 220, 452], [455, 477, 552, 552, 622], [624, 650, 687, 687, 764], [766, 809, 836, 836, 861], [863, 893, 910, 910, 941], [943, 965, 993, 993, 1042], [1044, 1044, 1101, 1152, 1563]], "test": "untested"}
{"id": "NdV3Rd", "name": "Artistic Black hole", "author": "z0rg", "description": "kurzgesagt inspired black hole (https://www.youtube.com/channel/UCsXVk37bltHxD1rDPwtNM8Q)", "tags": ["blackhole", "kurzgesagt"], "likes": 18, "viewed": 872, "published": 3, "date": "1632072288", "time_retrieved": "2024-07-30T19:00:21.922648", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 3.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n\n    float bloomIntensity = 224./640.;  \n    vec3 bloomSample = doBloom(uv, 5./360., 237./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.8));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n\n\n    col = mix(col, col.zyx, pow(sat(length(cuv*2.)),4.));\n\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000., -1.);\n\n   acc = _min(acc, vec2(length(p)-1., 0.));\n\n    float plane = max(abs(p.y)-.01, length(p.xz)-3.);\n    acc = _min(acc, vec2(plane, 1.));\n\n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\nvec3 gradient(float f)\n{\n    vec3 colors[8];\n    colors[0] = vec3(1.,1.,1.);\n    colors[1] = vec3(1.,1.,1.);\n    colors[2] = vec3(1.000,0.784,0.322);\n    colors[3] = vec3(1.000,0.682,0.322);\n    colors[4] = vec3(0.973,0.325,0.051);\n    colors[5] = vec3(0.882,0.176,0.529)*.7;\n    colors[6] = vec3(0.349,0.141,0.600)*.5;\n    colors[7] = vec3(0.349,0.141,0.600)*.25;\n    f = sat(f);\n    return colors[int(7.0*f)];\n    \n}\nvec3 finalPos;\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    finalPos = ro;\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n\n            if (res.y == 0.)\n                accCol *= .75;\n            return vec3(res.x, distance(p, ro), res.y);\n        }\n        rd = normalize(rd-normalize(p)*.01*pow(1.-sat(length(p)-1.5),5.5));\n        accCol += .007*gradient(length(p)-1.6)*(1.-sat(res.x / .5));\n        p+= rd*res.x*.15;\n        finalPos = p;\n    }\n    return vec3(-1.);\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.078,0.043,0.157)*.35;\n    \n\n    uv *= r2d(.3);\n    float dist = 9.+sin(iTime*.35);\n    float t = iTime*.1;\n    vec3 ro = vec3(dist*cos(t),-2.+sin(iTime*.5),dist*sin(t));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n\n    vec3 res = trace(ro, rd, 512);\n    bool isHorizon = false;\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.x;\n        float idx = floor(length(finalPos)*7.);\n        if (res.z == 1.)\n            col += gradient(length(finalPos)-1.6)*mix(.7,1.,(sat(length(finalPos)-1.5))*sat(400.*sin(.25*pow(idx,.75)*iTime+5.*atan(finalPos.z, finalPos.x))));\n        else\n        {\n            col = vec3(0.);\n            isHorizon = true;\n        }\n    }\n    col += accCol;\n    vec3 finalDir = normalize(ro-finalPos);\n    if (!isHorizon)\n    {\n        col += 1.5*sat(length(uv*1.5))*pow(texture(iChannel0, 3.*vec2(atan(finalDir.z, finalDir.x), acos(finalDir.y))).x,10.);\n        vec2 uvSky = 2.*vec2(atan(finalDir.z, finalDir.x), acos(finalDir.y));\n        col += 1.2*vec3(0.984,0.639,0.455)*pow(texture(iChannel0, uvSky).x,2.)*(1.-sat(5.*abs(dot(finalDir, vec3(0.,1.,0.)))));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv *= 1.5;\n    vec3 col = rdr(uv);\n    col = pow(col, vec3(1.2));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3Rd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 449, 449, 957], [959, 959, 1016, 1016, 1467]], "test": "untested"}
{"id": "Nsy3Dy", "name": "Fractal 78_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 31, "viewed": 694, "published": 3, "date": "1632057810", "time_retrieved": "2024-07-30T19:00:22.754424", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.05*exp(-.45*i*i*e))\n    {\n        p=g*d-vec3(.05*sin(iTime*.5),.1,.7);\n        p=R(p,normalize(vec3(1,-2,2)),iTime*.5);\n        s=4.;\n        vec4 q=vec4(p,sin(iTime*.4)*.5);\n\t\tfor(int j=0;j++<8;)\n            q=abs(q),\n            q=q.x<q.y?q.zwxy:q.zwyx,\n            s*=e=1.35/min(dot(q,q),0.54),\n            q=q*e-vec4(0,4,.8,3);\n        g+=e=min(\n            length(q.w)/s,\n            length(cross(q.xyw,normalize(vec3(1,2,3))))/s-.0002\n        );\n    }\n    O=pow(O,vec4(5));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsy3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 801]], "test": "untested"}
{"id": "fsy3Dy", "name": "Electric Flower LSD", "author": "Krischan", "description": "Ohh look all those nice colors and vibes, a free visual drug which doesn't harm you :D I can't stop watching this.\n\nRemix of \"Electric Flower - WebGLSamples\" by oneshade. https://www.shadertoy.com/view/wt3cWB", "tags": ["cube", "psychedelic", "glow", "webglsamples", "electricflower"], "likes": 11, "viewed": 422, "published": 3, "date": "1632056472", "time_retrieved": "2024-07-30T19:00:23.522371", "image_code": "/*\n\nRecreation of \"Electric Flower\" by Henrik Rydgard: https://webglsamples.org/electricflower/electricflower.html\nI have no idea how he actually achieved the effect but this is what I came up with.\n\nRemix by Krischan, who has a rough idea how this works ;)\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0, 23, 21))\n#define uv2rgb(uv) .5 + .5 * cos( atan(uv.x,uv.y) + 6.3 * iTime + vec4(0,23,21,0) )\n\n#define MIX max(1.0/(iTime+1.0),0.05)\n\nfloat mapScene(in vec3 p) {\n    float r = iTime * 2.0;\n    float c = cos(r), s = sin(r);\n    mat2 rmat = mat2(c, -s, s, c);\n\n    p.yz *= rmat;\n    p.xz *= rmat;\n\n    vec3 q = abs(p) - 0.5;\n    float box = max(q.x, max(q.y, q.z));\n\n    box = max(box, -max(q.x, q.y) - 0.03);\n    box = max(box, -max(q.x, q.z) - 0.03);\n    box = max(box, -max(q.y, q.z) - 0.03);\n\n    return box;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    float aspect=iResolution.x/iResolution.y*0.66;\n    \n    fragColor = mix(texture(iChannel0, (fragCoord - screenCenter) * 0.98 / iResolution.xy + 0.5),uv2rgb(uv)/(aspect-length(uv)),MIX);\n\n    vec3 ro = vec3(0.0, 0.0, min(iTime,10.));\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += hue2rgb(iTime * 0.5) * 0.5;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsy3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 318, 318, 384]], "test": "untested"}
{"id": "fdG3Dy", "name": "Distance Field Quilting", "author": "paniq", "description": "applying Realtime Texture Quilting (Hugh Malan et al) to mixing isosurfaces across barycentric domains. A real world application would transfer this to mixing four microstructure SDF's in a tetrahedral mesh. The top vertex is interactive.", "tags": ["2d", "vector", "library", "graphics"], "likes": 13, "viewed": 487, "published": 3, "date": "1632053821", "time_retrieved": "2024-07-30T19:00:24.466846", "image_code": "// compute barycentric coordinates from three points and a coordinate\n// this is equivalent to the distance of a point to each of the three planes,\n// normalized by the determinant\nvec3 barycentric(vec2 p[3], vec2 t) {\n    vec2 u = p[1] - p[2];\n    vec2 v = p[2] - p[0];\n    vec2 nu = vec2(-u.y, u.x);\n    vec2 nv = vec2(-v.y, v.x);\n    float det = 1.0 / dot(u, nv);\n    t -= p[2];\n    float w0 = dot(t, nu)*det;\n    float w1 = dot(t, nv)*det;\n    // computing the third coordinate this way adds numerical stability\n    float w2 = 1.0 - w0 - w1;\n    return vec3(w0,w1,w2);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float cs = cos(a), sn = sin(a);\n    return p * mat2(cs, sn,-sn, cs);\n}\n\nvec2 p[3];\n\n\nvec2 rep(vec2 p, vec2 c) {\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdcircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// from https://iquilezles.org/articles/distfunctions2d\nfloat sdroundbox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat eval_field(vec2 o) {\n    vec3 w = barycentric(p, o);\n    \n    float d0 = sdcircle(rep(p[0] - o, vec2(0.23)), 0.1); \n    float d1 = sdcircle(rep(rotate(p[1] - o, radians(45.0)), vec2(0.12)),0.05);\n    float d2 = sdroundbox(rep(rotate(p[2] - o, radians(iTime)), vec2(0.25,0.22)),vec2(0.1,0.08), vec4(0.04,0.01,0.03,0.02));\n    \n    float d = dot(w*w, vec3(d0, d1, d2)) / dot(w,w);\n    \n    return d;\n}\n\nfloat fieldf(vec2 x) {\n\treturn eval_field(x);\n}\n\nfloat tri(float x) {\n    return 2.0 * abs( floor(x*0.5+0.5) - 0.5*x );\n}\nfloat isofieldf(vec2 x) {\n\treturn tri((eval_field(x)*100.0 - 0.5)*1.0)*2.0-1.0;\n}\n\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid paint() {\n    float t = iTime;\n\n    p[0] = vec2(-0.8,-0.8);\n    p[1] = vec2( 0.8,-0.8);\n    p[2] = (iMouse.z > 0.5)?get_query():vec2( 0.0, 0.8);\n\n    set_line_width_px(1.0);\n    vec3 w = barycentric(p, get_origin()); \n    float d = fieldf(get_origin());\n    set_source_rgb(((d > 0.0) || (min(w.x,min(w.y,w.z)) < 0.0))?vec3(1.0):viridis(-d*10.0));\n    clear();\n\n    set_source_rgba(0.0,0.0,0.0,0.5);\n    graph2D(isofieldf);\n    stroke();\n    \n    graph2D(fieldf);\n    set_line_width_px(2.0);\n    set_source_rgb(vec3(0.0));\n    stroke();\n\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(0.0));\n    move_to(p[0]);\n\tline_to(p[1]);\n    line_to(p[2]);\n    close_path();\n    stroke();\n    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdG3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 181, 218, 218, 574], [576, 576, 606, 606, 681], [696, 696, 722, 722, 757], [759, 759, 792, 792, 820], [822, 878, 931, 931, 1088], [1090, 1090, 1116, 1116, 1495], [1497, 1497, 1519, 1519, 1544], [1546, 1546, 1566, 1566, 1618], [1619, 1619, 1644, 1644, 1700], [1702, 1702, 1725, 1725, 2379], [2381, 2381, 2395, 2395, 3074], [3136, 3136, 3193, 3193, 3279]], "test": "untested"}
{"id": "fsyGWy", "name": "gpu sorting", "author": "yunhai", "description": "just for fun:D\nup is most green \nright is most red\nsettings is in 'Common'", "tags": ["jff"], "likes": 8, "viewed": 363, "published": 3, "date": "1632034588", "time_retrieved": "2024-07-30T19:00:25.360457", "image_code": "void mainImage( out vec4 O, in vec2 C )\n{\n    O = texelFetch(iChannel0,ivec2(C),0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    //sort x\n    ivec2 id=ivec2(C);//C-=.5;\n    int isEven=iFrame%2;\n    float isR=float((id.x+isEven)%2);\n    float dir=1.-2.*step(.5,isR);\n    vec4 lData=texelFetch(iChannel0,mapCoord(C,vec2(isR*dir,0.),iR),0),\n         rData=texelFetch(iChannel0,mapCoord(C,vec2((1.-isR)*dir,0.),iR),0),\n         sData=mix(lData,rData,isR),\n         tData=mix(rData,lData,isR);\n    O.rgb=length(lData.x)>length(rData.x)?tData.xyz:sData.xyz;\n    \n#ifdef SORT_RANDOM_COLOR\n    O.rgb=iFrame<10?randomVec3(C):O.rgb;\n#endif\n#ifdef SORT_TEX\n    O.rgb=iFrame<10?texture(iChannel1,C/iR).xyz:O.rgb;\n#endif\n#ifdef SORT_TEX2\n    O.rgb=iFrame<10?texture(iChannel2,C/iR).xyz:O.rgb;\n#endif\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*--------exp settings--------*/\n//#define SORT_RANDOM_COLOR\n#define SORT_TEX\n//#define SORT_TEX2\n/*--------exp settings--------*/\n\n#define iR iResolution.xy\n#define iT iTime\n\nvec3 randomVec3(vec2 seed)\n{\n    uint x=uint(seed.x),y=uint(seed.y),z;\n    x*=uint(867);\n    y*=uint(923);\n    x^=x<<11^x>>8;\n    y*=x;\n    y^=y<<16^y>>6;\n    x=y*(x<<11^x>>6^x);\n    \n    y=x<<13^y>>6;\n    z=y<<12^y>>7;\n    return vec3(x,y,z)/4294967297.;\n}\n\nivec2 mapCoord(vec2 c,vec2 dir,vec2 resol)\n{\n    ivec2 nc=ivec2(c+dir);\n    ivec2 resolution=ivec2(resol);\n    if(nc.x>=resolution.x||nc.x<0||\n        nc.y>=resolution.y||nc.y<0)\n        return ivec2(c);\n    return nc;\n}", "buffer_b_code": "void mainImage( out vec4 O, in vec2 C )\n{\n    //sort y\n    ivec2 id=ivec2(C);//C-=.5;\n    int isEven=iFrame%2;\n    float isU=float((id.y+isEven)%2);\n    float dir=1.-2.*step(.5,isU);\n    vec4 dData=texelFetch(iChannel0,mapCoord(C,vec2(0.,isU*dir),iR),0),\n         uData=texelFetch(iChannel0,mapCoord(C,vec2(0.,(1.-isU)*dir),iR),0),\n         sData=mix(dData,uData,isU),\n         tData=mix(uData,dData,isU);\n    O.rgb=length(dData.y)>length(uData.y)?tData.xyz:sData.xyz;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 85]], "test": "untested"}
{"id": "fsGGWy", "name": "Pulsar Neutron Star", "author": "DLC", "description": "Simple Pulsar star using smoothstep func for rays", "tags": ["pulsar"], "likes": 3, "viewed": 245, "published": 3, "date": "1632033500", "time_retrieved": "2024-07-30T19:00:26.130398", "image_code": "// 2D rotation matrix\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n//star\n    col.b += 0.15 * sin(14.0*iTime);\n    col.b += mix(0.05, 1.0, 0.06 / length(uv));\n//rotate uv\n    uv = rotate(uv, 3.0*iTime);\n//rays\n    float m = smoothstep(0.25 * smoothstep(-0.5, 0.5, (abs(uv.y) - 0.4)), 0.0, abs(uv.x));\n    col.b += m * abs(sin(5.0*iTime));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 52, 52, 148], [151, 151, 206, 206, 609]], "test": "untested"}
{"id": "7lj3Rw", "name": "Greenforest Seed", "author": "brianhaak", "description": "ASDW to draw wires while pressing mouse. ZQERTYU to place a multiplexer.\n` (backtick) for ground. 1 for power. X for intersection. L for reconfiguration port. Num 4-8-6-2: change parent pointer in the ownership tree.\nP to fill state with \"1\", G with \"0\".", "tags": ["cellular", "boolean", "circuit", "electronics"], "likes": 4, "viewed": 464, "published": 3, "date": "1632031266", "time_retrieved": "2024-07-30T19:00:27.265363", "image_code": "// MUX VLSI Boolean logic Cellular Automata\n// ASDW to draw wires while pressing mouse. ZQERTYU to place a multiplexer.\n// ` (backtick) for ground. 1 for power. X for intersection.\n// L for reconfiguration port. Num 4-8-6-2: change parent pointer in the ownership tree.\n\n#define WIRE_THICK (0.5)\n#define HALF_WIRE_THICK (0.5 * WIRE_THICK)\n#define CENTER (4.5)\n#define SPACING (2.0)\n#define HALF_SPACING (0.5 * SPACING)\n\n// Old stuff: I had no idea what I was doing\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n// Old stuff: I had no idea what I was doing\nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  vec2 rotated = rotate(vec2(x,y), iTime);\n  float d = max(abs(rotated.x), abs(rotated.y)) - size;\n  \n  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\n// Old stuff: I had no idea what I was doing\nfloat udSegment (vec2 p, float zoom, float th, vec2 a, vec2 b) {\n    vec2 ba = zoom * (b - a);\n    vec2 pa = p - zoom * a;\n    \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec2 sqrd = pa - h * ba;\n    vec2 sqrd2 = sqrd * sqrd;\n    return sqrd2.x + sqrd2.y - th;\n}\n\n// Old stuff: I had no idea what I was doing\nvec3 line(vec2 from, float dx, float dy, vec3 color, float th, float zoom, vec2 pos, vec3 mix_into) {\n    return mix(color, mix_into, step(0.0, udSegment(pos, zoom, th, from, from + vec2(dx, dy))));\n}\n\n// Geometry transformations\nvec2 rotate (vec2 point, float sine, float cosine, vec2 origin) {\n\n    // transform point position into origin's vector space:\n    vec2 point_in_origin_space = point - origin;\n\n    // rotate point\n    float Xnew = point_in_origin_space.x * cosine - point_in_origin_space.y * sine;\n    float Ynew = point_in_origin_space.x * sine + point_in_origin_space.y * cosine;\n    // TODO: simplify to mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n\n    // transform point back to the user vector space:\n    return vec2(Xnew, Ynew) + origin;\n}\n\nvec2 translate (vec2 point, float x, float y) {\n    return point + vec2(x, y);\n}\n\n// For composition to work, negative distance is where the the\n// composed \"internals\" of solids are.\nfloat right_of (float x, vec2 xy) {\n    return x - xy.x;\n}\n\nfloat left_of (float x, vec2 xy) {\n    return xy.x - x;\n}\n\n// We normalize 0 to be on top of the y axis\nfloat top_of (float y, vec2 xy) {\n    return xy.y - y;\n}\n\nfloat bottom_of (float y, vec2 xy) {\n    return y - xy.y;\n}\n\nfloat solid_rect (vec4 dim, vec2 xy) {\n    return max(right_of(dim.x, xy),\n        max(top_of(dim.w, xy),\n            max(bottom_of(dim.y, xy),\n                left_of(dim.z, xy)\n            )\n        )\n    );\n}\n\n// Constructive solid geometry: combintation operations\n\nfloat morph(float shape1, float shape2, float degree) {\n    return mix(shape1, shape2, degree);\n}\n\nfloat glue(float shape1, float shape2) {\n    return min(shape1, shape2);\n}\n\nfloat overlap(float shape1, float shape2) {\n    return max(shape1, shape2);\n}\n\nfloat subtract(float base, float removed) {\n    return max(base, -removed);\n}\n\nfloat xor(float d1, float d2) {\n    return max(min(d1, d2), -max(d1, d2)); // xor\n}\n\n// Constructive solid geometry: primitives\n\nfloat disc(vec2 pos, float diameter, vec2 xy) {\n    vec2 dist = xy - pos;\n    return dot(dist, dist) * 4.0 - diameter * diameter;\n}\n\n// DO NOT CHANGE THE ORDER of your calls to compose()\nvec3 compose(float shape, vec3 shape_color, vec3 color) {//, float anti_alias) {\n    //return mix(color, shape_color, step(shape, 0.0));\n    \n    //return mix(color, shape_color, smoothstep(5.0, -5.0, shape));\n    // return mix(color, shape_color, smoothstep(anti_alias, -anti_alias, shape));\n    return mix(color, shape_color, smoothstep(0.2, -0.3, 0.042 * zoom_factor * shape));\n}\n\n// Discs look better with different smooth factors to anti-alias\nvec3 compose_antialias(float shape, vec3 shape_color, vec3 color) {\n\n    return mix(color, shape_color, smoothstep(5.0, -1.0, 0.042 * zoom_factor * shape));\n}\n\nvec3 my_blend(vec3 source, vec3 dest, float alpha) {\n    return source * alpha + dest * (1.0 - alpha);\n}\n\nvec4 transparent_compose(float shape, vec4 shape_color, vec4 color) {\n    float shape_cutoff = step(shape, 0.0);\n\n    // Add two transparencies with saturation to 1.0 max.\n    float composed_alpha = min(shape_color.a + color.a, 1.0);\n    return vec4(mix(\n        color.rgb,\n        my_blend(shape_color.rgb * shape_cutoff,\n                 color.rgb,\n                 shape_color.a),\n                 shape_cutoff),\n        composed_alpha);\n}\n\n\n\nfloat consumes_from_the_left(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation < 0.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 1.5 && cell.orientation > 2.5) ||\n    (((cell.mode > 1.5 && cell.mode < 3.5) || cell.mode > 5.5)\n        && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 1.5 && cell.mode < 5.5\n        && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 3.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_left(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_bottom(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_right(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 2.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation > 2.5) ||\n    (cell.mode > 3.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 1.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 1.5 && cell.mode < 3.5 && cell.orientation < 0.5) ||\n    (cell.mode > 5.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_right(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_top(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_top(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 0.5 && cell.orientation < 1.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 3.5 && cell.orientation > 2.5) ||\n    (cell.mode > 1.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.orientation < 1.5 && cell.orientation > 0.5) &&\n        ((cell.mode > 1.5 && cell.mode < 3.5) || (cell.mode > 5.5)) ||\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_top(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_left(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_bottom(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 1.5 && cell.orientation < 2.5) ||\n    // a MUX with an input from the left\n    (cell.orientation > 2.5 && (\n        (cell.mode > 1.5 && cell.mode < 3.5) || cell.mode > 5.5)) ||\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 3.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 1.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_bottom(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_right(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nvec4 draw_crossbar_signal(vec2 center, float current, float next, vec4 visual, vec2 p) {\n\n    // TODO: I do too many computations based on black for \"1\" and white for \"0\".\n    // It will make it hard to adjust for bright and dark green palette, for example!\n    vec3 next_color = vec3(1.0 - next);\n    vec3 curr_color = vec3(1.0 - current);\n\n    float outer_disc = disc(center, 3.8 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    \n    float middle_disc = disc(center, 2.5 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    visual = vec4(compose_antialias(middle_disc, curr_color, visual.rgb), 1.0);\n    \n    //float inner_disc = disc(center, 2.0 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    //visual = vec4(compose(inner_disc, next_color, visual.rgb), 1.0);\n\n    return visual;\n}\n\nvec4 cfg_dbg(float val, float x, float y, vec2 p, vec4 visual, vec3 color) {\n    // float s = disc(vec2(x, y), 1.1 * WIRE_THICK, p);\n    float s = disc(vec2(x, y), 0.001 * WIRE_THICK, p);\n    visual = vec4(compose_antialias(5.0 * s, 8.0 * color * val, visual.rgb), 1.0);\n    \n    return visual;\n}\n\nvec4 draw_a_cell (Element cell, Element left, Element top, Element right, Element bottom, vec2 p, vec4 visual) {\n\n    // p spans from 0.01 to 7.99. There's a small gap of 0.5 a cell lacks at the right and bottom,\n    // it's placed slightly asymmetric to provide a good resolution even at 8x8 pixels per cell.\n\n\n/*\n----\n\\  |\n \\ |\n  \\|\n*/\n\n    /*\n    \n        We combine the DFF ring with all output wires because they reflect the same physical entity.\n    \n        We draw an output if the adjacent cell has one of its inputs pointing to this cell.\n        Outputs are canonical: all cells no matter their type have 4 outputs.\n        \n        We ALWAYS draw all input wires. In advanced vis, the wires might contain signal color inside.\n            GND and PWR: 0 inputs\n            MUX: 3 inputs\n            Crossbar: 4 inputs (not clear if we should draw those lines when no consumers)\n            Wire: 1 input.\n\n        We draw diagonal lines for the active MUX input and a short one looking like --/\n        showing the selector input.\n    */\n\n    float show_in_left = consumes_from_the_left(cell);\n    float show_out_right = consumes_from_the_left(right);\n\n    float show_in_right = consumes_from_the_right(cell);\n    float show_out_left = consumes_from_the_right(left);\n\n    float show_in_top = consumes_from_the_top(cell);\n    float show_out_bottom = consumes_from_the_top(bottom);\n\n    float show_in_bottom = consumes_from_the_bottom(cell);\n    float show_out_top = consumes_from_the_bottom(top);\n    \n    float no_connections = show_in_left+show_out_right+show_in_right\n      +show_out_left+show_in_top+show_out_bottom+show_in_bottom+show_out_top;\n\n\n    // Outputs\n\n    if (show_out_right > 0.5) {\n        float out_right = solid_rect(vec4(\n            2.5, CENTER - HALF_SPACING - HALF_WIRE_THICK,\n            8.0, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(out_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_left > 0.5) {\n        float out_left = solid_rect(vec4(\n            0.0, CENTER + HALF_SPACING - HALF_WIRE_THICK,\n            6.5, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(out_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_bottom > 0.5) {\n        float out_bottom = solid_rect(vec4(\n            CENTER + HALF_SPACING - HALF_WIRE_THICK, 2.5,\n            CENTER + HALF_SPACING + HALF_WIRE_THICK, 8.0), p);\n        visual = vec4(compose(out_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_top > 0.5) {\n        float out_top = solid_rect(vec4(\n            CENTER - HALF_SPACING - HALF_WIRE_THICK, 0.0,\n            CENTER - HALF_SPACING + HALF_WIRE_THICK, 6.5), p);\n        visual = vec4(compose(out_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    // ---------------------------------------\n    // Crossbar D flip-flop state bubbles\n    if (cell.mode < 0.5 && cell.orientation > 0.5 && cell.orientation < 1.5) {\n    \n        vec2 signal_bubble_center = vec2(1.9, 3.5);\n    \n        if (show_in_left * show_out_right > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.right, left.right, visual, p);\n        }\n        if (show_in_top * show_out_bottom > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.bottom, top.bottom, visual,\n                rotate(p, sin(radians(-90.0)), cos(radians(-90.0)), vec2(CENTER)));\n        }\n        if (show_in_right * show_out_left > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.left, right.left, visual,\n                rotate(p, sin(radians(-180.0)), cos(radians(-180.0)), vec2(CENTER)));\n        }\n        if (show_in_bottom * show_out_top > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.top, bottom.top, visual,\n                rotate(p, sin(radians(-270.0)), cos(radians(-270.0)), vec2(CENTER)));\n        }\n    }\n\n    // Draw inputs on top of crossbar DFF state bubbles\n    if (show_in_left > 0.5) {\n        float in_left = solid_rect(vec4(\n            0.0, CENTER - HALF_SPACING - HALF_WIRE_THICK,\n            1.56, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(in_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_right > 0.5) {\n        float in_right = solid_rect(vec4(\n            7.35, CENTER + HALF_SPACING - HALF_WIRE_THICK,\n            8.0, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(in_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_top > 0.5) {\n        float in_top = solid_rect(vec4(\n            CENTER + HALF_SPACING - HALF_WIRE_THICK, 0.0,\n            CENTER + HALF_SPACING + HALF_WIRE_THICK, 1.56), p);\n        visual = vec4(compose(in_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_bottom > 0.5) {\n        float in_bottom = solid_rect(vec4(\n            CENTER - HALF_SPACING - HALF_WIRE_THICK, 7.35,\n            CENTER - HALF_SPACING + HALF_WIRE_THICK, 8.0), p);\n        visual = vec4(compose(in_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (cell.mode > 0.5 || cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {\n    \n        float next_value = 0.0;\n        float l = 0.0;\n        if (cell.mode > 1.5) {\n\n            if (cell.orientation > 2.5) {\n                next_value = mux_action(cell.mode, left.right, right.left, bottom.top, top.bottom);\n                l = left.right;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = mux_action(cell.mode, top.bottom, bottom.top, left.right, right.left);\n                l = top.bottom;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                next_value = mux_action(cell.mode, right.left, left.right, top.bottom, bottom.top);\n                l = right.left;\n            } else if (cell.orientation < 0.5) {\n                next_value = mux_action(cell.mode, bottom.top, top.bottom, right.left, left.right);\n                l = bottom.top;\n            }\n        } else if (cell.mode < 1.5 && cell.mode > 0.5) {\n            // wire\n            if (cell.orientation > 2.5) {\n                next_value = right.left;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = bottom.top;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                next_value = top.bottom;\n            } else if (cell.orientation < 0.5) {\n                next_value = left.right;\n            }\n        } else if (cell.mode < 0.5) {\n            if (cell.orientation > 2.5) {\n                next_value = 1.0;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = 0.0;\n            } else if (is_reconf_port(cell) > 0.5) {\n                //l = cell.parent;\n                \n                if (cell.parent > 2.5) {\n                    l = left.right;\n                } else if (cell.parent < 2.5 && cell.parent > 1.5) { \n                    l = bottom.top;\n                } else if (cell.parent < 1.5 && cell.parent > 0.5) {\n                    l = right.left;\n                } else if (cell.parent < 0.5) {\n                    l = top.bottom;\n                }\n            }\n        }\n    \n        // Not a crossbar or reconf port\n\n        // MUX, GND, PWR, WIRE D flip-flop state (current and next)\n        // There are 4 discs on top of each other\n        float inner_disc = 0.0;\n        float bigger_inner_disc = 0.0;\n        float outer_disc = 0.0;\n        float smaller_outer_disc = 0.0;\n        \n        float outer_disc_diameter = 5.0;\n        \n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            // If it's wire, make shapes smaller please!\n            inner_disc = 100.0; //disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);\n            bigger_inner_disc = disc(vec2(4.5, 4.5), 4.1 * WIRE_THICK, p);\n            outer_disc_diameter = 4.1;\n        } else {\n            inner_disc = disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);\n            bigger_inner_disc = disc(vec2(4.5, 4.5), 5.0 * WIRE_THICK, p);\n        }\n        \n        outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter, p);\n        smaller_outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter - 2.0 * WIRE_THICK, p);\n        \n\n        visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        \n        \n        if (cell.mode > 0.5 || cell.mode < 0.5 && cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {\n\n            if (cell.right < 0.5) {\n                visual = vec4(compose_antialias(smaller_outer_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n\n                // Don't draw if 0->1\n                //if (next_value < 0.5 || cell.right > 0.5) {\n                //    visual = vec4(compose(bigger_inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n                //}\n            } else {\n                visual = vec4(compose_antialias(bigger_inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n            }\n        }\n        \n      \n        // MUX currently switched input (s ? a : b => s = 1 -> a : s = 0 -> b)\n        float rotate_sel = (3.0 - cell.orientation) * -90.0;\n        float rotate_curr = rotate_sel;\n        \n        float rotate_alt = 0.0;\n        float mux_mode = 7.0 - cell.mode;\n     \n        // Switch over 6 modes\n        if (mux_mode < 0.5) {\n            // rotate_curr = l > 0.5 ? b : t;\n            rotate_curr += l > 0.5 ? 90.0 : -90.0;\n        } else if (mux_mode > 0.5 && mux_mode < 1.5) {\n            //result = l > 0.5 ? t : b;\n            rotate_curr += l > 0.5 ? -90.0 : 90.0;\n        } else if (mux_mode > 1.5 && mux_mode < 2.5) {\n            //result = l > 0.5 ? r : t;\n            rotate_curr += l > 0.5 ? 180.0 : 270.0;\n        } else if (mux_mode > 2.5 && mux_mode < 3.5) {\n            //result = l > 0.5 ? t : r;\n            rotate_curr += l > 0.5 ? 270.0 : 180.0;\n        } else if (mux_mode > 3.5 && mux_mode < 4.5) {\n            //result = l > 0.5 ? r : b;\n            rotate_curr += l > 0.5 ? 180.0 : 90.0;\n        } else if (mux_mode > 4.5 && mux_mode < 5.5) {\n            //result = l > 0.5 ? b : r;\n            rotate_curr += l > 0.5 ? 90.0 : 180.0;\n        }\n        \n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            // WIRE\n            if (cell.orientation > 2.5) {\n                rotate_curr = 180.0;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                rotate_curr = 90.0;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                rotate_curr = -90.0;\n            } else if (cell.orientation < 0.5) {\n                rotate_curr = 0.0;\n            }\n            \n            // visual = transparent_compose(-1.0, vec4(1.0, 0.0, 0.0, 0.5), visual);\n        } else if (is_reconf_port(cell) > 0.5) {\n            rotate_curr = (4.0 - cell.parent) * 90.0;\n        }\n        \n        //---------------------------------------------\n        // Currently selected input (A or B) for MUX or THE input for wires\n        vec2 input_vertex = vec2(1.5, CENTER - HALF_SPACING);\n        float mux_current_input_halo = solid_rect(vec4(\n            input_vertex.x, input_vertex.y - 2.0 * WIRE_THICK,\n            CENTER, CENTER - HALF_SPACING + 2.25 * WIRE_THICK),\n            \n            rotate(\n                rotate(p,\n                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),\n                    vec2(CENTER)\n                ),\n                sin(radians(-18.0)), cos(radians(-18.0)),\n                input_vertex + vec2(0.0, HALF_WIRE_THICK)\n            )\n        );\n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            ;\n        } else if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose(mux_current_input_halo, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n        }\n        \n        float mux_current_input = solid_rect(vec4(\n            input_vertex.x - 0.1, input_vertex.y - HALF_WIRE_THICK,\n            CENTER, CENTER - HALF_SPACING + HALF_WIRE_THICK),\n            rotate(\n                rotate(p,\n                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),\n                    vec2(CENTER)\n                ),\n                sin(radians(-18.0)), cos(radians(-18.0)),\n                input_vertex + vec2(0.0, HALF_WIRE_THICK)\n            )\n        );\n\n        \n        // If 1 -> 0, don't draw this\n\n        /* if (cell.right < 0.5 && next_value < 0.5) {\n            // If 0 -> 0\n            visual = vec4(compose(inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n        } else if (next_value > 0.5) {\n            // If 1->1 or 0->1\n            visual = vec4(compose(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        } */\n        \n        if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose_antialias(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n            visual = vec4(compose(mux_current_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        }\n        \n        \n        // ------- MUX Selector Input --------------\n        \n        vec2 selector_input_vertex = vec2(1.5, CENTER - HALF_SPACING);\n        \n        if (cell.mode < 0.5) {\n            // l = 0.0; // reconf port clock source\n            rotate_sel = (3.0 - cell.parent) * 90.0;\n        }\n        \n        float engaged_selector_offset = l > 0.5 ? -0.05 : 0.55;\n        \n        float mux_selector_input = solid_rect(vec4(\n            selector_input_vertex.x,\n            selector_input_vertex.y - 2.0,\n            selector_input_vertex.x + 0.1 + WIRE_THICK,\n            selector_input_vertex.y + 0.2),\n            translate(\n                rotate(\n                    rotate(p,\n                        sin(radians(rotate_sel)), cos(radians(rotate_sel)),\n                        vec2(CENTER)\n                    ),\n                    sin(radians(-18.0)), cos(radians(-18.0)),\n                    selector_input_vertex + vec2(0.0, HALF_WIRE_THICK)\n                ),\n                engaged_selector_offset, // 0.4: not engaged; -0.1: engaged\n                -1.0\n            )\n        );\n        \n        if (cell.mode > 1.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose(mux_selector_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        }\n        \n        if (cell.mode > 1.5) {\n            visual = vec4(compose(-0.15 * (24.0 / zoom_factor), 1.0 * visual.rgb, 1.0 * vec3(1.0, 0.69, 0.1)), 1.0);\n        }\n    }\n    \n    //if (cell.write_pointer_counter > 0.5) {\n        visual = vec4(compose(0.0, vec3(1.0 - 2.0 * cell.write_pointer_counter * (1.0/14.0), 1.0, 1.0), visual.rgb), 1.0);\n    //}\n    \n    // Debug config signals:\n    /*\n    vec3 dat_clr = vec3(1.0, 0.0, 0.0);\n    visual = cfg_dbg(cell.LDO, 1.5, 2.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.TDO, 6.5, 1.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.RDO, 7.0, 6.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.BDO, 2.5, 7.0, p, visual, dat_clr);\n    \n    vec3 clk_clr = vec3(0.0, 0.0, 1.0);\n    visual = cfg_dbg(cell.LCO, 1.5, 2.5 - 1.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.TCO, 6.5 + 1.0, 1.5, p, visual, clk_clr);\n    visual = cfg_dbg(cell.RCO, 7.0, 6.5 + 1.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.BCO, 2.5 - 1.0, 7.0, p, visual, clk_clr);\n\n    visual = cfg_dbg(cell.PREV_CLK, 4.5, 4.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.WE_ARE_FULL_DFF, 4.5, 5.0, p, visual, dat_clr);\n    */\n    if (is_reconf_port(cell) > 0.5) {\n        visual = vec4(compose(0.01 * (24.0 / zoom_factor), vec3(0.2, 0.0, 1.0), visual.rgb), 0.8);\n    } else if (no_connections < 0.5 && cell.mode < 0.5 && cell.orientation > 1.5 && cell.orientation < 2.5) {\n        // skip drawing the GND cells\n        \n        return vec4(1.0);\n    }\n\n\n    \n\n    return visual;\n}\n\nvec4 render (in vec2 fragCoord) {\n\n    vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n\n    \n    //Bitset8Bits cfg = cfgBlockFromTexel(texture(iChannel0, vec2(0.0)));\n    //if (cfg.bit0.r > 0.5) {\n    //    zoom_factor = 128.0;\n    //}\n    \n    vec2 mouse_cell = cell_from_visual(m.xy, zoom_factor);\n    \n    float scale = 1.0 / zoom_factor;\n    vec2 tex_coord_from_screen = 1.0 / iResolution.xy;\n    \n   \n    vec2 cell_coord = floor((fragCoord - 0.5) * scale + vec2(0.5, 0.5) * scale);\n    \n    vec2 gpgpu_coord = (0.5 + cell_coord + vec2(0.0, 0.0));\n    \n    if (is_config_param_block(gpgpu_coord) > 0.5) {\n        return vec4(0.0);\n    }\n    \n    vec2 fetch_coord = gpgpu_coord / iChannelResolution[0].xy;\n    \n    vec4 gpgpu_data = texture(iChannel0, fetch_coord);\n    \n    //return gpgpu_data;\n    \n    // Fetch neighbor elements or IO surface bits\n    Element left = elementFromTexel(texture(iChannel0, (0.5 + cell_coord - vec2(1.0, 0.0)) / iChannelResolution[0].xy));\n    Element right = elementFromTexel(texture(iChannel0, (0.5 + cell_coord + vec2(1.0, 0.0)) / iChannelResolution[0].xy));\n    Element top = elementFromTexel(texture(iChannel0, (0.5 + cell_coord - vec2(0.0, 1.0)) / iChannelResolution[0].xy));\n    Element bottom = elementFromTexel(texture(iChannel0, (0.5 + cell_coord + vec2(0.0, 1.0)) / iChannelResolution[0].xy));\n\n    vec4 green_background = vec4(0.0, 0.5, 0.0, 1.0);\n    vec4 white_background = vec4(1.0, 1.0, 1.0, 1.0);\n    // vec4 visual = green_background;\n    vec4 visual = white_background;\n    \n    // Position within a tile\n    // vec2 p = mod(fragCoord, zoom_factor);\n    vec2 p = 8.0 * mod(fragCoord * scale, 1.0);// + vec2(0.5);\n    \n    // p = vec2(p.x, 8.0 - p.y);\n    //p = vec2(8.0 - p.x, p.y);\n\n\n    Element cell = elementFromTexel(gpgpu_data);\n    \n    if (zoom_factor > 15.0) {\n    \n        vec4 cell_visual = draw_a_cell(cell, left, top, right, bottom, p, visual);\n    \n        // Compose the cell over the background (can be transparent)\n        visual = transparent_compose(-1.0, vec4(cell_visual.rgb, 2.0), visual);\n    } else {\n        visual = transparent_compose(-1.0, vec4(vec3(1.0 - cell.right), 1.0), visual);\n    }\n    \n \n    // Uncomment to only show the ownership spanning tree\n    // vec3 col = vec3(1.0);\n\n    vec3 col = visual.rgb;\n    \n\n    vec2 center = vec2(0.55, 0.55);\n    vec3 overlay_color = vec3(1.0);\n    \n    vec3 parent_color = cell.PREV_CLK < 0.5 ? vec3(0.6, 0.4, 0.1) : vec3(0.8, 0.1, 0.1);\n    \n    // vec3 parent_color = vec3(0.6, 0.0, 0.0);\n    vec3 twig_color_clocked = vec3(0.0, 0.0, 0.0);\n    vec3 twig_color = vec3(0.1, 0.5, 0.0);\n    \n    float parent_thickness = zoom_factor * zoom_factor / 128.0 * 0.5;\n    float twig_thickness = zoom_factor * zoom_factor / 128.0 * 0.15;\n\n    // Children twigs\n    \n    p = mod(fragCoord, zoom_factor);\n    if (is_right(left.parent) > 0.5) {\n        vec3 twig_color = cell.LCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, -0.5, 0.0, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_bottom(top.parent) > 0.5) {\n        vec3 twig_color = cell.TCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.0, -0.5, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_left(right.parent) > 0.5) {\n        vec3 twig_color = cell.RCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.5, 0.0, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_top(bottom.parent) > 0.5) {\n        vec3 twig_color = cell.BCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.0, 0.5, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    // Parent twig\n    if (is_left(cell.parent) > 0.5) {\n        overlay_color = line(center - vec2(0.25, 0.0), -0.3, 0.0, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_top(cell.parent) > 0.5) {\n        overlay_color = line(center - vec2(0.0, 0.25), 0.0, -0.3, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_right(cell.parent) > 0.5) {\n        overlay_color = line(center + vec2(0.25, 0.0), 0.3, 0.0, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_bottom(cell.parent) > 0.5) {\n        overlay_color = line(center + vec2(0.0, 0.25), 0.0, 0.3, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    col = compose(-0.09 * (24.0 / zoom_factor), visual.rgb, overlay_color);\n    \n    //col = overlay_color;\n    \n    \n    //col = 1.5 * transparent_compose(-1.0, vec4(0.5 * col, 0.95),\n    //   vec4(5.0 * overlay_color, 0.0)).rgb;\n    //col = 1.5 * transparent_compose(-1.0, vec4(0.5 * col, 0.95),\n    //   vec4(5.0 * overlay_color, 0.0)).rgb;\n    //col = 2.0 * compose(-0.15, 0.25 * visual.rgb, 2.0 * overlay_color);\n    // col = transparent_compose(-1.0, vec4(overlay_color, 0.5), vec4(2.0 * col, 1.0)).rgb;\n    \n    //if (cell.conf_signal < 0.5) {\n    //    col = transparent_compose(-1.0, vec4(1.0, 1.0, 1.0, 0.4), vec4(col, 1.0)).rgb;\n    //}\n    \n\n    // m.z is button pressed\n    // m.w is button state changed from \"not pressed\" to \"pressed\" (only one frame)\n    if (m.z > 0.5 && abs(mouse_cell - gpgpu_coord).x < 0.5 && abs(mouse_cell - gpgpu_coord).y < 0.5) {\n    \n        return transparent_compose(-1.0, vec4(1.0, 1.0, 0.0, 0.35), vec4(col, 1.0));\n    }\n    \n    return vec4(col, 1.0);\n}\n\n\n// Circles and a \"proper\" SDF composition\nvec4 render2 (in vec2 xy) {\n    vec3 white_background = vec3(1.0, 1.0, 1.0);\n    \n    vec3 color = white_background;\n  \n    vec2 c = vec2(700.0, 700.0);\n    \n    //xy = mod(3.0 * xy + 0.5 * c, c) - 0.1 * c;\n    \n    xy = 8.0 * mod(xy / 256.0, 1.0);\n    \n    color = compose(//xor(\n             //1.0, //\n             glue(disc(vec2(4.500, 4.500), 4.000, xy),\n             1.0 //solid_rect(vec4(2.000, 3.000, 4.000, 5.000), xy)\n             )\n             ,\n        vec3(0.5, 0.5, 1.0), color);\n\n    float innrshp = glue(1.0,\n        glue(\n             disc(vec2(4.500, 4.500), 4.000, xy),\n             1.0//solid_rect(vec4(2.200, 3.000, 3.800, 5.500), xy)\n             ));\n    \n    //color = transparent_compose(innrshp, vec4(0.0, 0.0, 0.0, 0.35), color);\n\n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    fragColor = render(vec2(fragCoord.x, iResolution.y - fragCoord.y));\n    //fragColor = render(fragCoord);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Random number generator. Borrowed from https://www.shadertoy.com/view/wltcRS\n//\n// Usage:\n    \n//   rng_initialize(fragCoord, iFrame);\n    \n//   fragColor = rand4();\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nfloat whenGt (float l, float r) {\n  return max(sign(l - r), 0.0);\n}\n\nlowp vec2 ctrlOffset (float dir) {\n    \n  return vec2(-1.0,  0.0) * whenGt(dir, 0.5) * whenGt(1.5, dir) +\n         vec2( 0.0, -1.0) * whenGt(dir, 1.5) * whenGt(2.5, dir) +\n         vec2( 0.0,  1.0) * whenGt(dir, 2.5) * whenGt(3.5, dir) +\n         vec2( 1.0,  0.0) * whenGt(dir, 3.5) * whenGt(4.5, dir);\n}\n\n\nfloat at(float x, float y, vec2 fragCoord) {\n    if (fragCoord.x > (x + 0.1) && fragCoord.x < (x + 0.9) &&\n        fragCoord.y > (y + 0.1) && fragCoord.y < (y + 0.9)\n    ) {\n        return 1.0;\n    }\n    \n    return 0.0;\n}\n\n// \"mode\" \"orientation\" \"at\"\nElement moa(float mode, float orientation, float x, float y, Element elt, vec2 fragCoord) {\n    if (at(x, y, fragCoord) > 0.5) {\n        elt.mode = mode;\n        elt.orientation = orientation;\n    }\n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.write_pointer_counter = 0.0;\n    return elt;\n}\n\n// \"mode\" \"orientation\" \"value\" \"at\"\nElement mova(float mode, float orientation, float value, float x, float y, Element elt, vec2 fragCoord) {\n    if (at(x, y, fragCoord) > 0.5) {\n        elt.mode = mode;\n        if (value < 1.5) { // > 1.0 will keep random\n            elt.left = elt.top = elt.bottom = elt.right = value;\n        }\n        elt.orientation = orientation;\n    }\n    \n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.write_pointer_counter = 0.0;\n    return elt;\n}\n\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint kBacktick = 192, k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\nint kNumLeft=100, kNumUp=104, kNumDown=98, kNumRight=102;\n\nElement computeElement (in Element old, in vec2 fragCoord) {\n\n    Element elt = old;\n    \n    Bitset8Bits cfg = cfgBlockFromTexel(texture(iChannel0, vec2(0.0)));\n    if (cfg.bit0.r > 0.5) {\n        return old;\n    }\n\n    vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n    vec2 mouse_cell = cell_from_visual(m.xy, zoom_factor);\n    \n    // m.z is button pressed\n    // m.w is button state changed from \"not pressed\" to \"pressed\" (only one frame)\n    if (m.z > 0.5 && abs(mouse_cell - fragCoord).x < 0.5 && abs(mouse_cell - fragCoord).y < 0.5) {\n\n        float y = 0.0;\n        // Ground\n        if (texelFetch(iChannel1, ivec2(kG, 0), 0).x > 0.5) {\n            elt.left = elt.top = elt.bottom = elt.right = 0.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kBacktick, 0), 0).x > 0.5) {\n            // GND\n            return mova(0., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kP, 0), 0).x > 0.5) {\n            elt.left = elt.top = elt.bottom = elt.right = 1.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(k1, 0), 0).x > 0.5) {\n            // PWR\n            return mova(0., 3., 1., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kA, 0), 0).x > 0.5) {\n            // Wire from left\n            return mova(1., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kW, 0), 0).x > 0.5) {\n            // Wire from up\n            return mova(1., 1., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kS, 0), 0).x > 0.5) {\n            // Wire down\n            return mova(1., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kD, 0), 0).x > 0.5) {\n            // Wire right\n            return mova(1., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kE, 0), 0).x > 0.5) {\n            // MUX type 1\n            return mova(7., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kQ, 0), 0).x > 0.5) {\n            // MUX type 2\n            return mova(3., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kR, 0), 0).x > 0.5) {\n            // MUX type 3 (selector from the bottom)\n            return mova(5., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kT, 0), 0).x > 0.5) {\n            // MUX type 4 (selector from the left but one of the inputs from the right)\n            return mova(3., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kZ, 0), 0).x > 0.5) {\n            // MUX type 5\n            return mova(2., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kY, 0), 0).x > 0.5) {\n            // MUX type 6\n            return mova(6., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kU, 0), 0).x > 0.5) {\n            // MUX type 7 (selector from the bottom)\n            return mova(4., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kX, 0), 0).x > 0.5) {\n            // Intersection\n            return mova(0., 1., 1., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kL, 0), 0).x > 0.5) {\n            // Ownership subtree overlay entry (a reconfuguration port) \n            Element cfgport = mova(0., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n            cfgport.conf_signal = 0.0;\n            cfgport.parent = 0.0; // left\n            // cfgport.cfg_read = cfgport.cfg_write = 0.0;\n            // Subtree readback value\n            cfgport.left = cfgport.right = cfgport.top = cfgport.bottom = 0.0;\n            return cfgport;\n            \n        } else if (texelFetch(iChannel1, ivec2(kNumLeft, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 0.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumUp, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 1.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumRight, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 2.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumDown, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 3.0;\n            return elt;\n        }\n    }\n\n    // On mouse release when this cell is being rendered\n    //if (m.z < 0.5 && cfg.bit0.g > 0.5 && abs(mouse_cell - gpgpu_coord).x < 0.5 && abs(mouse_cell - gpgpu_coord).y < 0.5) {\n    //}\n    \n    // Fetch neighbor elements or IO surface bits\n    Element left = elementFromTexel(texture(iChannel0, (fragCoord - vec2(1.0, 0.0))/iChannelResolution[0].xy));\n    Element right = elementFromTexel(texture(iChannel0, (fragCoord + vec2(1.0, 0.0))/iChannelResolution[0].xy));\n    Element top = elementFromTexel(texture(iChannel0, (fragCoord - vec2(0.0, 1.0))/iChannelResolution[0].xy));\n    Element bottom = elementFromTexel(texture(iChannel0, (fragCoord + vec2(0.0, 1.0))/iChannelResolution[0].xy));\n    \n    // Cell reconfiguration local clock\n    lowp float CLK = 0.0;\n    \n    if (is_config_param_block(fragCoord + vec2(0.0, -1.0)) > 0.5) {\n        top.parent = 3.0; // bottom\n        top.conf_signal = 0.0;\n        top.mode = 0.0;\n        top.orientation = 2.0;\n    } else if (is_config_param_block(fragCoord + vec2(-1.0, 0.0)) > 0.5) {\n        left.parent = 2.0; // right\n        left.conf_signal = 0.0;\n        left.mode = 0.0;\n        left.orientation = 2.0;\n    }\n    \n    if (fragCoord.x < 0.9) {\n        left.parent = 2.0; // right\n        left.conf_signal = 0.0;\n        left.mode = 0.0;\n        left.orientation = 2.0;\n    } else if (fragCoord.x > COMPUTER_WIDTH - 1.0) {\n        right.parent = 0.0; // left\n        right.conf_signal = 0.0;\n        right.mode = 0.0;\n        right.orientation = 2.0;\n    }\n    \n    if (fragCoord.y < 0.9) {\n        top.parent = 3.0; // bottom\n        top.conf_signal = 0.0;\n        top.mode = 0.0;\n        top.orientation = 2.0;\n    } else if (fragCoord.y > COMPUTER_HEIGHT - 1.0) {\n        bottom.parent = 1.0; // top\n        bottom.conf_signal = 0.0;\n        bottom.mode = 0.0;\n        bottom.orientation = 2.0;\n    }\n        \n    // If element not configured, don't flow data\n    // Disabled due to the new coarse-grained mini-FPGA model\n    // Enabled again to try the fine grained cellular model. FPGAs are not necessary.\n    //if (elt.conf_signal > 0.5) {\n    \n    lowp float is_crossbar = 0.0;\n    \n    lowp float LDI = left.RDO;\n    lowp float LCI = left.RCO;\n    lowp float TDI = top.BDO;\n    lowp float TCI = top.BCO;\n    lowp float RDI = right.LDO;\n    lowp float RCI = right.LCO;\n    lowp float BDI = bottom.TDO;\n    lowp float BCI = bottom.TCO;\n\n    lowp float PARENT_IS_LEFT = is_left(elt.parent);\n    lowp float PARENT_IS_TOP = is_top(elt.parent);\n    lowp float PARENT_IS_RIGHT = is_right(elt.parent);\n    lowp float PARENT_IS_BOTTOM = is_bottom(elt.parent);\n\n    lowp float LEFT_IS_A_CHILD = LDI > 0.5 && PARENT_IS_LEFT < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_A_CHILD = TDI > 0.5 && PARENT_IS_TOP < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_A_CHILD = RDI > 0.5 && PARENT_IS_RIGHT < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_A_CHILD = BDI > 0.5 && PARENT_IS_BOTTOM < 0.5 ? 1.0 : 0.0;\n    \n    lowp float LEFT_IS_FULL = LDI > 0.5 && LCI > 0.5 && PARENT_IS_LEFT < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_FULL = TDI > 0.5 && TCI > 0.5 && PARENT_IS_TOP < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_FULL = RDI > 0.5 && RCI > 0.5 && PARENT_IS_RIGHT < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_FULL = BDI > 0.5 && BCI > 0.5 && PARENT_IS_BOTTOM < 0.5 ? 1.0 : 0.0;\n    \n    // In the clockwise direction from the parent\n    lowp float PRIORITY_CHILD_LEFT = 0.0;\n    lowp float PRIORITY_CHILD_FRONT = 0.0;\n    lowp float PRIORITY_CHILD_RIGHT = 0.0;\n    \n    lowp float LEFT_IS_AN_EMPTY_CHILD = LEFT_IS_A_CHILD > 0.5 && LEFT_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_AN_EMPTY_CHILD = TOP_IS_A_CHILD > 0.5 && TOP_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_AN_EMPTY_CHILD = RIGHT_IS_A_CHILD > 0.5 && RIGHT_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_AN_EMPTY_CHILD = BOTTOM_IS_A_CHILD > 0.5 && BOTTOM_IS_FULL < 0.5 ? 1.0 : 0.0;\n    \n    lowp float CLK_LEFT = 0.0;\n    lowp float CLK_TOP = 0.0;\n    lowp float CLK_RIGHT = 0.0;\n    lowp float CLK_BOTTOM = 0.0;\n    \n    lowp float DATA_OUT_L = 0.0;\n    lowp float DATA_OUT_T = 0.0;\n    lowp float DATA_OUT_R = 0.0;\n    lowp float DATA_OUT_B = 0.0;\n    \n    lowp float DATA_IN = 0.0;\n    \n    if (PARENT_IS_LEFT > 0.5) {\n        CLK = LCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = LDI;\n        PRIORITY_CHILD_LEFT = TOP_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = RIGHT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = BOTTOM_IS_AN_EMPTY_CHILD;\n        \n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = LDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = LDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = LDI;\n        }\n    } else if (PARENT_IS_TOP > 0.5) {\n        CLK = TCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = TDI;\n        PRIORITY_CHILD_LEFT = RIGHT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = BOTTOM_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = LEFT_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = TDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = TDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = TDI;\n        }\n    } else if (PARENT_IS_RIGHT > 0.5) {\n        CLK = RCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = RDI;\n        PRIORITY_CHILD_LEFT = BOTTOM_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = LEFT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = TOP_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = RDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = RDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = RDI;\n        }\n    } else if (PARENT_IS_BOTTOM > 0.5) {\n        CLK = BCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = BDI;\n        PRIORITY_CHILD_LEFT = LEFT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = TOP_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = RIGHT_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = BDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = BDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = BDI;\n        }\n    }\n    \n    // We set this signal to 1 if the cell is a reconfiguration port.\n    // All reconfiguration ports are always terminal leaves of subtree by design.\n    lowp float ALL_CHILDREN_ARE_FULL = is_reconf_port(elt) > 0.5 ? 1.0 :\n        (((LEFT_IS_FULL > 0.5 || LEFT_IS_A_CHILD < 0.5)\n        &&\n        (TOP_IS_FULL > 0.5 || TOP_IS_A_CHILD < 0.5)\n        &&\n        (RIGHT_IS_FULL > 0.5 || RIGHT_IS_A_CHILD < 0.5)\n        &&\n        (BOTTOM_IS_FULL > 0.5 || BOTTOM_IS_A_CHILD < 0.5)) ? 1.0 : 0.0);\n        \n\n    elt.LCO = (PARENT_IS_LEFT > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (LEFT_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_LEFT > 0.5 && LEFT_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.TCO = (PARENT_IS_TOP > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (TOP_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_TOP > 0.5 && TOP_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.RCO = (PARENT_IS_RIGHT > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (RIGHT_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_RIGHT > 0.5 && RIGHT_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.BCO = (PARENT_IS_BOTTOM > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (BOTTOM_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_BOTTOM > 0.5 && BOTTOM_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n        \n\n    elt.LDO = (PARENT_IS_LEFT > 0.5 || DATA_OUT_L > 0.5 && PARENT_IS_LEFT < 0.5) ? 1.0 : 0.0;\n    elt.TDO = (PARENT_IS_TOP > 0.5 || DATA_OUT_T > 0.5 && PARENT_IS_TOP < 0.5) ? 1.0 : 0.0;\n    elt.RDO = (PARENT_IS_RIGHT > 0.5 || DATA_OUT_R > 0.5 && PARENT_IS_RIGHT < 0.5) ? 1.0 : 0.0;\n    elt.BDO = (PARENT_IS_BOTTOM > 0.5 || DATA_OUT_B > 0.5 && PARENT_IS_BOTTOM < 0.5) ? 1.0 : 0.0;\n\n    if (elt.PREV_CLK < 0.5 && CLK > 0.5) {\n        float next_write_ptr_ctr = 0.0;\n        if (elt.write_pointer_counter < 6.5) {\n            next_write_ptr_ctr = elt.write_pointer_counter + 1.0;\n        } else {\n            next_write_ptr_ctr = 0.0;\n        }\n        \n        if (elt.WE_ARE_FULL_DFF > 0.5) {\n            // Our cell config update happens here!\n            // Note we USE the previous values!\n            elt.orientation = float(elt.new_cfg[0] + 2.0 * elt.new_cfg[1]);\n            elt.mode = float(elt.new_cfg[2] + 2.0 * elt.new_cfg[3] + 4.0 * elt.new_cfg[4]);\n            elt.parent = float(elt.new_cfg[5] + 2.0 * elt.new_cfg[6]);\n            elt.right = elt.left = elt.top = elt.bottom = 0.0;\n            // ^^^ these will be patched slightly (PWR will make elt.right = 1.0 for example)\n            // below vvv\n        }\n\n        if (ALL_CHILDREN_ARE_FULL > 0.5) {\n            elt.write_pointer_counter = next_write_ptr_ctr;\n            elt.new_cfg[0] = elt.new_cfg[1];\n            elt.new_cfg[1] = elt.new_cfg[2];\n            elt.new_cfg[2] = elt.new_cfg[3];\n            elt.new_cfg[3] = elt.new_cfg[4];\n            elt.new_cfg[4] = elt.new_cfg[5];\n            elt.new_cfg[5] = elt.new_cfg[6];\n            elt.new_cfg[6] = DATA_IN;\n        }\n    } else if (elt.PREV_CLK > 0.5 && CLK < 0.5) {\n        // This DFF is clocked on falling edge.\n        // It's the only component which does that!\n        elt.WE_ARE_FULL_DFF = elt.write_pointer_counter > 6.5 ? 1.0 : 0.0;\n    }\n\n    // MUX\n    if (elt.mode > 1.5) {\n\n        if (elt.orientation > 2.5) {\n            elt.right = mux_action(elt.mode, left.right, right.left, bottom.top, top.bottom);\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            elt.right = mux_action(elt.mode, top.bottom, bottom.top, left.right, right.left);\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            elt.right = mux_action(elt.mode, right.left, left.right, top.bottom, bottom.top);\n        } else if (elt.orientation < 0.5) {\n            elt.right = mux_action(elt.mode, bottom.top, top.bottom, right.left, left.right);\n        }\n        \n    } else if (elt.mode > 0.5 && elt.mode < 1.5) {\n        // Wire\n        if (elt.orientation > 2.5) {\n            elt.right = right.left;\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            elt.right = bottom.top;\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            elt.right = top.bottom;\n        } else if (elt.orientation < 0.5) {\n            elt.right = left.right;\n        }\n\n    } else if (elt.mode < 0.5) {\n        if (elt.orientation > 2.5) {\n            // PWR\n            elt.right = 1.0;\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            // GND\n            elt.right = 0.0;\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            // Crossbar\n            elt.right = left.right;\n            elt.left = right.left;\n            elt.top = bottom.top;\n            elt.bottom = top.bottom;\n            is_crossbar = 1.0;\n        } else if (elt.orientation < 0.5) {\n            // Reconfiguration port\n            // Will interpret read/write request commands from\n            // the parent pointer direction\n            // clocked from \"parent + 1.0\" (clockwise)\n            float dat = 0.0;\n            float clk = 0.0;\n            if (is_left(elt.parent) > 0.5) {\n                dat = left.right;\n                clk = top.bottom;\n                elt.RCO = clk;\n                elt.RDO = dat;\n                elt.right = right.LCO;\n            } else if (is_top(elt.parent) > 0.5) {\n                dat = top.bottom;\n                clk = right.left;\n                elt.BCO = clk;\n                elt.BDO = dat;\n                elt.right = bottom.TCO;\n            } else if (is_right(elt.parent) > 0.5) {\n                dat = right.left;\n                clk = bottom.top;\n                elt.LCO = clk;\n                elt.LDO = dat;\n                elt.right = left.RCO;\n            } else if (is_bottom(elt.parent) > 0.5) {\n                dat = bottom.top;\n                clk = left.right;\n                elt.TCO = clk;\n                elt.TDO = dat;\n                elt.right = top.BCO;\n            }\n            \n            // Sample the clk and dat,\n            // execute operations on clk change.\n            \n            /* if (elt.prev_clk < 0.5 && clk > 0.5) {\n                // If neither reading or writing, let's begin\n                // depending on the data. Emulate DFF behavior using the prev_dat.\n                if (elt.cfg_read < 0.5 && elt.cfg_write < 0.5) {\n                    if (elt.prev_dat < 0.5) {\n                        elt.cfg_read = 1.0;\n                        // elt.right = 1.0;\n                    } else { // if the first bit of reconf bitstream is \"1\",\n                        // the client wants to write a bitstream into the port\n                        elt.cfg_write = 1.0;\n                        // Set the \"busy\" signal so the reprogrammer-parent\n                        // can identify when the writing is fully complete.\n                        elt.right = 1.0;\n                    }\n                }\n                \n                // Readout value\n                // elt.right = dat;//1.0 - elt.right;\n            }*/\n\n            // Read-out output\n            //elt.right = elt.right;// 0.0;\n            //elt.prev_clk = clk;\n            //elt.prev_dat = dat;\n        }\n    }\n    \n    if (is_crossbar < 0.5) {\n        elt.left = elt.right;\n        elt.top = elt.right;\n        elt.bottom = elt.right;\n    }\n    \n    //}\n    \n    // Disabled due to the new coarse-grained mini-FPGA model\n    // Enabled again\n    // Spanning tree integrity\n\n    if (is_left(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((left.conf_signal + is_reconf_port(left)) * (1.0 - is_right(left.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = left.prev_clk;\n        }\n    } else if (is_top(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((top.conf_signal + is_reconf_port(top)) * (1.0 - is_bottom(top.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = top.prev_clk;\n        }\n    } else if (is_right(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((right.conf_signal + is_reconf_port(right)) * (1.0 - is_left(right.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = right.prev_clk;\n        }\n    } else if (is_bottom(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((bottom.conf_signal + is_reconf_port(bottom)) * (1.0 - is_top(bottom.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = bottom.prev_clk;\n        }\n    }\n    \n    // At first, ran out of internal bits in a 32-bit pixel\n    // But then had to find one bit to sample clock.\n    // Had to give up on prototype inheritance of MUX states (for this shader code),\n    // Which decreased the range of the main counter from 0..8 to 0..7, releasing one more bit!\n    /*if (elt.conf_signal < 0.5) {\n        elt.parent = elt.parent + 1.0;\n        if (elt.parent > 3.5) {\n            elt.parent = 0.0;\n        }\n    } // TODO later make it work in another way. This feature is important,\n    */// it supports failed FPGAs and automatically unstucks accidental ownership tree cycles.\n    \n    elt.PREV_CLK = CLK;\n    \n    return elt;\n}\n\n\nvec4 update (in vec2 fragCoord) {\n\n   \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        // Skip processing of data not in computer core\n        // or not being in IO\n        // Note that we can write in this buffer realtime external inputs\n        // (mouse, keyboard, etc.)\n        return gpgpu_data;\n    } else if (is_config_param_block(fragCoord) > 0.5) {\n        // Configuration parameters block\n        Bitset8Bits cfg = cfgBlockFromTexel(gpgpu_data);\n\n        vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n        \n        if (m.z > 0.5) {\n            cfg.bit0.g = 1.0;\n        }\n        \n        if (m.z < -0.5) {\n            cfg.bit0.g = 0.0;\n        }\n\n        const int KEY_LEFT  = 37;\n        const int KEY_UP    = 38;\n        const int KEY_RIGHT = 39;\n        const int KEY_DOWN  = 40;\n        \n        if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5) {\n            cfg.bit0.r = 1.0;\n        }\n        \n        if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5) {\n            cfg.bit0.r = 0.0;\n        }\n\n        return texelFromCfgBlock(cfg);\n    }\n\n    return texelFromElement(computeElement(elementFromTexel(gpgpu_data), fragCoord));\n}\n\n\nElement init_circuit(Element e, vec2 p) {\n\n    float y = 0.0;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 1.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 2.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 3.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 4.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 5.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 6.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 7.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 8.;\n    e=moa(0.,0., 1.,y,e,p);    e=moa(0.,0., 2.,y,e,p);     e=moa(0.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n\n    \n    return e;\n}\n\nvec4 init (in vec2 fragCoord) {\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        discard;\n    } else if (is_config_param_block(fragCoord) > 0.5) {\n        // Configuration parameters block\n        Bitset8Bits cfg;\n\n        cfg.bit0.r = 0.0;\n\n        return texelFromCfgBlock(cfg);\n    }\n    \n    // rng_initialize(fragCoord, 190); // with 24x13 size is interesting\n    rng_initialize(fragCoord, 115);//155);//198);//115); //155); //115; // 33 //119\n    \n    //rng_initialize(fragCoord, iFrame + 735375909);\n    //rng_initialize(fragCoord, iFrame + 42);\n    //rng_initialize(fragCoord, iFrame + 74974137);\n    \n    \n    vec4 randomValues = rand4();\n\n    Element elt = elementFromTexel(vec4(randomValues.r, randomValues.g, randomValues.b, 0.0));\n    //Element elt = elementFromTexel(vec4(0.0));\n    //Element elt;\n    //elt = mova(0., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n    \n    //elt.parent = floor(4.0 * randomValues.r);\n    \n    /*\n    elt = elementFromTexel(randomValues);\n    \n    // Higher the probability of wires:\n    for (int i = 0; i < 4; ++i) {\n        vec4 moreRandomValues = rand4();\n        if (elt.mode > 1.5 || elt.mode < 0.5) {\n            elt.mode = floor(8.0 * moreRandomValues.r);\n        } else {\n            break;\n        }\n    }\n    \n    // Lower the probability of MUXes:\n    for (int i = 0; i < 3; ++i) {\n        vec4 moreRandomValues = rand4();\n        if (elt.mode > 1.5) {\n            elt.mode = floor(8.0 * moreRandomValues.r);\n        } else {\n            break;\n        }\n    }*/\n    \n    // Reset all core counters so it starts in the consistent mode:\n    elt.LCO = elt.RCO = elt.BCO = elt.TCO = 0.0;\n    elt.LDO = elt.RDO = elt.BDO = elt.TDO = 0.0;\n    elt.write_pointer_counter = 0.0;\n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.conf_signal = 0.0;\n    elt.PREV_CLK = 0.0;\n    elt.parent = 0.0;\n    \n    //elt = init_circuit(elt, fragCoord);\n\n    \n    // Four state bits to store outputs (three used only for crosses)\n    // lowp float right;  // 0..1\n    /* elt.right = elt.top = elt.bottom = elt.left = 1.0;\n\n    // --- 5 bits of wiring and control configuration ---\n    \n    // 4 orientations 0..3 for MUX or wire. For special mode diff. meaning:\n    // 0: reconf. port; 1: cross; 2: GND; 3: PWR.\n    // [2 bits]\n    // float orientation;\n    elt.orientation = 3.0;\n\n    // 8 modes: 0 - special; 1 - wire; 2..7 - MUX\n    // [3 bits]\n    // float mode;\n    elt.mode = 0.0;\n    \n    return texelFromElement(elt); */\n    /** /\n    vec4 moreRandomValues = rand4();\n    vec4 moreRandomValues2 = rand4();\n    \n    // Lower the probability of MUXes:\n\n    if (elt.mode > 1.5) {\n        elt.mode = floor(8.0 * moreRandomValues.a);\n    }\n\n    \n    // Up the probability of reconf ports:\n    if (elt.mode > 0.5 && elt.orientation > 0.5) {\n        elt.mode = floor(8.0 * moreRandomValues2.r);\n        elt.orientation = floor(4.0 * moreRandomValues2.g);\n    }\n\n    // Made higher the probability of wires:\n    if (elt.mode > 1.5 || elt.mode < 0.5) {\n        elt.mode = floor(8.0 * moreRandomValues.r);\n        //elt.orientation = floor(4.0 * moreRandomValues2.g);\n        \n        if (elt.mode > 1.5 || elt.mode < 0.5) {\n            elt.mode = floor(8.0 * moreRandomValues.g);\n            //elt.orientation = floor(4.0 * moreRandomValues.a);\n            \n            if (elt.mode > 1.5 || elt.mode < 0.5) {\n                elt.mode = floor(8.0 * moreRandomValues.b);\n                \n                if (elt.mode > 1.5 || elt.mode < 0.5) {\n                    elt.mode = floor(8.0 * moreRandomValues2.r);\n                    \n                    if (elt.mode > 1.5 || elt.mode < 0.5) {\n                        vec4 moreRandomValues3 = rand4();\n                        elt.mode = floor(8.0 * moreRandomValues3.r);\n                        \n                        // Higher the probability of crosses:\n                        if (elt.mode > 0.5 || elt.orientation < 0.5 && elt.orientation > 1.5) {\n                            elt.mode = floor(8.0 * moreRandomValues2.r);\n                            elt.orientation = floor(4.0 * moreRandomValues2.g);\n                        }\n                    }\n                        \n                }\n            }\n            /*\n            if (elt.orientation > 0.5) {\n                elt.orientation = floor(4.0 * moreRandomValues2.r);\n                if (elt.orientation > 0.5) {\n                    elt.orientation = floor(4.0 * moreRandomValues2.g);\n                    if (elt.orientation > 0.5) {\n                        elt.mode = floor(8.0 * moreRandomValues2.b);\n                        elt.orientation = floor(4.0 * moreRandomValues2.a);\n                    }\n                }\n            }* /\n        }\n    }\n    */\n    \n    //if ((fragCoord.x > 10.0 || fragCoord.y > 21.0) && is_reconf_port(elt) > 0.5) {\n    //    elt.mode = 1.0;\n    //}\n    return texelFromElement(elt);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  \n    if (iFrame > 1) {\n        fragColor = update(fragCoord);\n    } else {\n        fragColor = init(fragCoord);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n# else\nprecision mediump float;\nprecision lowp int;\nprecision lowp sampler2D;\n# endif\n\nfloat zoom_factor = 64.0;\n\n//float zoom_factor = 24.0; // Beautiful most miniature render to study very large arrays\n\n//float zoom_factor = 16.0;\n\n//float zoom_factor = 1.0;\n\n\n#define COMPUTER_WIDTH (119.0)\n#define COMPUTER_HEIGHT (74.0)\n\n//#define COMPUTER_WIDTH (119.0)\n//#define COMPUTER_HEIGHT (67.0)\n\n// Try this bizarre settings:\n//float zoom_factor = 1.0;\n//#define COMPUTER_WIDTH (1920.0)\n//#define COMPUTER_HEIGHT (1080.0)\n\n//#define COMPUTER_WIDTH (2.0 * 1920.0)\n//#define COMPUTER_HEIGHT (2.0 * 1080.0)\n\n// 32 bits on bit-by-bit access\nstruct Bitset8Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n    vec4 bit4;\n    vec4 bit5;\n    vec4 bit6;\n    vec4 bit7;\n};\n\nvec4 when_gt (vec4 l, vec4 r) {\n  return max(sign(l - r), 0.0);\n}\n\n// 3 * 4 bits\nstruct Bitset4Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n};\n\nBitset4Bits unpack_4_numbers (vec4 numbers) {\n    Bitset4Bits result;\n\n    result.bit3 = when_gt(numbers, vec4(7.5));\n    \n    vec4 bits0to2 = numbers - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = numbers - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nBitset8Bits unpack_4_bytes (vec4 byte) {\n    Bitset8Bits result;\n    \n    result.bit7 = when_gt(byte, vec4(127.5));\n    \n    vec4 bits0to6 = byte - 128.0 * result.bit7;\n    result.bit6 = when_gt(bits0to6, vec4(63.5));\n    \n    vec4 bits0to5 = bits0to6 - 64.0 * result.bit6;\n    result.bit5 = when_gt(bits0to5, vec4(31.5));\n    \n    vec4 bits0to4 = bits0to5 - 32.0 * result.bit5;\n    result.bit4 = when_gt(bits0to4, vec4(15.5));\n    \n    vec4 bits0to3 = bits0to4 - 16.0 * result.bit4;\n    result.bit3 = when_gt(bits0to3, vec4(7.5));\n    \n    vec4 bits0to2 = bits0to3 - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = bits0to2 - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nstruct Array32Bits {\n    float bit[32];\n};\n\nArray32Bits unpack_32_bits (vec4 byte) {\n    Bitset8Bits bits = unpack_4_bytes(byte);\n    \n    Array32Bits a;\n    a.bit[0] = bits.bit0.r;\n    a.bit[1] = bits.bit1.r;\n    a.bit[2] = bits.bit2.r;\n    a.bit[3] = bits.bit3.r;\n    a.bit[4] = bits.bit4.r;\n    a.bit[5] = bits.bit5.r;\n    a.bit[6] = bits.bit6.r;\n    a.bit[7] = bits.bit7.r;\n    \n    a.bit[8] = bits.bit0.g;\n    a.bit[9] = bits.bit1.g;\n    a.bit[10] = bits.bit2.g;\n    a.bit[11] = bits.bit3.g;\n    a.bit[12] = bits.bit4.g;\n    a.bit[13] = bits.bit5.g;\n    a.bit[14] = bits.bit6.g;\n    a.bit[15] = bits.bit7.g;\n\n    \n    a.bit[16] = bits.bit0.b;\n    a.bit[17] = bits.bit1.b;\n    a.bit[18] = bits.bit2.b;\n    a.bit[19] = bits.bit3.b;\n    a.bit[20] = bits.bit4.b;\n    a.bit[21] = bits.bit5.b;\n    a.bit[22] = bits.bit6.b;\n    a.bit[23] = bits.bit7.b;\n    \n    a.bit[24] = bits.bit0.a;\n    a.bit[25] = bits.bit1.a;\n    a.bit[26] = bits.bit2.a;\n    a.bit[27] = bits.bit3.a;\n    a.bit[28] = bits.bit4.a;\n    a.bit[29] = bits.bit5.a;\n    a.bit[30] = bits.bit6.a;\n    a.bit[31] = bits.bit7.a;\n\n    return a;\n}\n\nstruct Element {\n\n    // ==== First block - [8 bits] of core config determining cell's function\n\n    // --- 5 bits of wiring and control configuration ---\n    \n    // 4 orientations 0..3 for MUX or wire. For special mode diff. meaning:\n    // 0: reconf. port; 1: cross; 2: GND; 3: PWR.\n    // [2 bits]\n    float orientation;\n\n    // 8 modes: 0 - special; 1 - wire; 2..7 - MUX\n    // [3 bits]\n    float mode;\n\n    // --- 2 bits Cartilage tree engine ---\n    \n    // Pointer to the owner element\n    // [2 bits]\n    float parent; // 0..3\n    \n    // Main state bit to store the output value\n    // In silicon, it represents electric charge.\n    // There is no inherent clock or D flip-flops. This bit is ephemeral\n    // (but initialized from config to support prototype inheritance).\n    \n    lowp float right;  // 0..1\n    \n    // ==== Ephemeral [8 bits] of Intersin clock and data wires\n    // (the wires neighbor cells interface with\n    // in the reconfiguration trees overlay network) representing charges\n    // while reconfiguration happens.\n    lowp float LCO;\n    lowp float LDO;\n    lowp float TCO;\n    lowp float TDO;\n    lowp float RCO;\n    lowp float RDO;\n    lowp float BCO;\n    lowp float BDO;\n    \n    // [13 bits] of non-copy-able \"hidden\" state (real DFFs)\n    \n    // ====== Third block [8 bits] shift register of configuration data.\n    // Applied to the main bits (orientation/mode/parent/state bit)\n    // when one subtree is completely filled with config bits.\n    // CLOCKED(!) with config clock sourced from one of the inputs\n    // into the subtree's reconfiguration port at its root.\n    lowp float new_cfg[8];\n\n    // [4 bits]\n    // Pointer of the currently written bit into the new_cfg register.\n    float write_pointer_counter;\n    // D flip-flop marking the completion of collection of new config bits\n    // in the new_cfg[7..0] shift register.\n    // [1 bit]\n    lowp float WE_ARE_FULL_DFF;\n\n    // ^^^ 29 bits consumed! ^^^\n    \n\n    // The three state bits used only to store outputs for crosses,\n    // In silicon, these represent charges. There is no inherent clock\n    // or D flip-flops. These bits are ephemeral.\n\n    lowp float left;  // 0..1\n    lowp float top;  // 0..1\n    lowp float bottom;  // 0..1\n    \n    // Spanning tree integrity. A technical signal preventing\n    // hidden ownership loops. In FPGA chains, implemented as a hops counter.\n    // We gave up on it because exhausted all 32 bits to encode electrical signals\n    // in wires. This implementation will require additional D flip-flop\n    // and protocol to send the presence signal.\n    lowp float conf_signal;\n\n    // The signal is supposed to be reflected from every leaf to the root, then re-emitted.\n    // If another signal is coming from the root, it means we got a cycle.\n    // Not implemented.\n    //lowp float conf_signal_leaf_to_root;\n    \n    // We have to sample the previous value of CLK to detect raising and falling edges.\n    lowp float PREV_CLK;\n};\n\nBitset8Bits cfgBlockFromTexel(vec4 texel) {\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n\n    return bits;\n}\n\nElement elementFromTexel (in vec4 texel) {\n\n    Element elt;\n\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n    \n  \n    elt.orientation = float(bits.bit0.r + 2.0 * bits.bit1.r);\n    elt.mode = float(bits.bit2.r + 2.0 * bits.bit3.r + 4.0 * bits.bit4.r);\n    elt.parent = float(bits.bit5.r + 2.0 * bits.bit6.r);\n\n    // Main state\n    elt.right = bits.bit7.r;\n\n    // Intersin signals\n    elt.LCO = bits.bit0.g;\n    elt.LDO = bits.bit1.g;\n    elt.TCO = bits.bit2.g;\n    elt.TDO = bits.bit3.g;\n    elt.RCO = bits.bit4.g;\n    elt.RDO = bits.bit5.g;\n    elt.BCO = bits.bit6.g;\n    elt.BDO = bits.bit7.g;\n\n    // New configuration buffer\n    elt.new_cfg[0] = bits.bit0.b;\n    elt.new_cfg[1] = bits.bit1.b;\n    elt.new_cfg[2] = bits.bit2.b;\n    elt.new_cfg[3] = bits.bit3.b;\n    elt.new_cfg[4] = bits.bit4.b;\n    elt.new_cfg[5] = bits.bit5.b;\n    elt.new_cfg[6] = bits.bit6.b;\n    // elt.new_cfg[7] = bits.bit7.b; // we needed a space :-/\n\n    // [4 bits]\n    // Pointer of the currently written bit into the new_cfg register.\n    // Counts from 0 to 7\n    elt.write_pointer_counter = float(\n        bits.bit0.a +\n        2.0 * bits.bit1.a +\n        4.0 * bits.bit2.a);/* +\n        8.0 * bits.bit3.a);*/\n        \n    // D flip-flop marking the completion of collection of new config bits\n    // in the new_cfg[7..0] shift register.\n    // Clocked on FALLING EDGE of CLK\n    // Its data input is sourced from the Boolean condition when\n    // elt.write_pointer_counter reaches 7.\n    // [1 bit]\n    elt.WE_ARE_FULL_DFF = bits.bit4.a;\n\n    // Used in cross only:\n    elt.left = bits.bit5.a;\n    elt.top = bits.bit6.a;\n    elt.bottom = bits.bit7.a;\n    \n    elt.PREV_CLK = bits.bit7.b;\n    elt.conf_signal = bits.bit3.a;\n\n    return elt;\n}\n\n\n//------------------------------------\n//\n//       structured data -> texels\n//\n\nvec4 pack_4_bytes (Bitset8Bits state) {\n\n  vec4 data;\n\n  data = vec4(state.bit0)\n    + 2.0 * vec4(state.bit1)\n    + 4.0 * vec4(state.bit2)\n    + 8.0 * vec4(state.bit3)\n    + 16.0 * vec4(state.bit4)\n    + 32.0 * vec4(state.bit5)\n    + 64.0 * vec4(state.bit6)\n    + 128.0 * vec4(state.bit7);\n\n  return data;\n}\n\nvec4 texelFromCfgBlock (Bitset8Bits bits) {\n\n    return pack_4_bytes(bits) / 255.0;\n}\n\nfloat is_config_param_block(vec2 fragCoord) {\n    // < 0.9 because normal fragCoord have 0.5 granularity\n    return fragCoord.x < 0.9 && fragCoord.y < 0.9 ? 1.0 : 0.0;\n}\n\nvec4 texelFromElement (in Element elt) {\n\n    Bitset8Bits bits;\n    \n    Bitset4Bits parameters = unpack_4_numbers(\n        vec4(elt.orientation, elt.mode, elt.parent,\n             elt.write_pointer_counter));\n    \n    // elt.orientation:\n    bits.bit0.r = parameters.bit0.r;\n    bits.bit1.r = parameters.bit1.r;\n    \n    // elt.mode:\n    bits.bit2.r = parameters.bit0.g;\n    bits.bit3.r = parameters.bit1.g;\n    bits.bit4.r = parameters.bit2.g;\n\n    // elt.parent:\n    bits.bit5.r = parameters.bit0.b;\n    bits.bit6.r = parameters.bit1.b;\n\n    // Main state\n    bits.bit7.r = elt.right;\n\n    bits.bit0.g = elt.LCO;\n    bits.bit1.g = elt.LDO;\n    bits.bit2.g = elt.TCO;\n    bits.bit3.g = elt.TDO;\n    bits.bit4.g = elt.RCO;\n    bits.bit5.g = elt.RDO;\n    bits.bit6.g = elt.BCO;\n    bits.bit7.g = elt.BDO;\n\n    bits.bit0.b = elt.new_cfg[0];\n    bits.bit1.b = elt.new_cfg[1];\n    bits.bit2.b = elt.new_cfg[2];\n    bits.bit3.b = elt.new_cfg[3];\n    bits.bit4.b = elt.new_cfg[4];\n    bits.bit5.b = elt.new_cfg[5];\n    bits.bit6.b = elt.new_cfg[6];\n    //bits.bit7.b = elt.new_cfg[7];\n    \n    // elt.write_pointer_counter:\n    bits.bit0.a = parameters.bit0.a;\n    bits.bit1.a = parameters.bit1.a;\n    bits.bit2.a = parameters.bit2.a;\n    //bits.bit3.a = parameters.bit3.a;\n    \n    \n    bits.bit4.a = elt.WE_ARE_FULL_DFF;\n\n    // Used in cross only:\n    bits.bit5.a = elt.left;\n    bits.bit6.a = elt.top;\n    bits.bit7.a = elt.bottom;\n    \n    bits.bit7.b = elt.PREV_CLK;\n    bits.bit3.a = elt.conf_signal;\n\n    return pack_4_bytes(bits) / 255.0;\n}\n\nfloat mux_action(float mode_code, lowp float l, lowp float r, lowp float b, lowp float t) {\n    float mode = 7.0 - mode_code;\n\n    float result = 0.0;\n    // Switch over 6 modes\n    if (mode < 0.5) {\n        result = l > 0.5 ? b : t;\n    } else if (mode > 0.5 && mode < 1.5) {\n        result = l > 0.5 ? t : b;\n    } else if (mode > 1.5 && mode < 2.5) {\n        result = l > 0.5 ? r : t;\n    } else if (mode > 2.5 && mode < 3.5) {\n        result = l > 0.5 ? t : r;\n    } else if (mode > 3.5 && mode < 4.5) {\n        result = l > 0.5 ? r : b;\n    } else if (mode > 4.5 && mode < 5.5) {\n        result = l > 0.5 ? b : r;\n    }\n    \n    return result;\n}\n\n\nfloat is_left(float ptr) {\n    return (ptr < 0.5) ? 1.0 : 0.0;\n}\n    \nfloat is_top(float ptr) {\n    return (ptr > 0.5 && ptr < 1.5) ? 1.0 : 0.0;\n}\n\nfloat is_right(float ptr) {\n    return (ptr > 1.5 && ptr < 2.5) ? 1.0 : 0.0;\n}\n\nfloat is_bottom(float ptr) {\n    return (ptr > 2.5 && ptr < 3.5) ? 1.0 : 0.0;\n}\n\nfloat is_reconf_port(Element elt) {\n    return (elt.mode < 0.5 && elt.orientation < 0.5) ? 1.0 : 0.0;\n}\n\n// Visual functions used due to inability of GPGPU shader to access mouse extent:\nvec2 cell_from_visual(vec2 visual, float zoom_factor) {\n\n    float scale = 1.0 / zoom_factor;\n   \n    vec2 cell_coord = floor((visual - 0.5) * scale + vec2(0.5, 0.5) * scale);\n    \n    vec2 gpgpu_coord = (0.5 + cell_coord + vec2(0.0, 0.0));\n    \n    return gpgpu_coord;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 465, 497, 497, 556], [558, 603, 653, 653, 862], [864, 909, 973, 973, 1195], [1197, 1242, 1343, 1343, 1442], [1444, 1472, 1537, 1598, 2004], [2006, 2006, 2053, 2053, 2086], [2088, 2190, 2225, 2225, 2248], [2250, 2250, 2284, 2284, 2307], [2309, 2354, 2387, 2387, 2410], [2412, 2412, 2448, 2448, 2471], [2473, 2473, 2511, 2511, 2684], [2743, 2743, 2798, 2798, 2840], [2842, 2842, 2882, 2882, 2916], [2918, 2918, 2961, 2961, 2995], [2997, 2997, 3040, 3040, 3074], [3076, 3076, 3107, 3107, 3159], [3205, 3205, 3252, 3252, 3336], [3338, 3392, 3449, 3684, 3774], [3776, 3841, 3908, 3908, 3999], [4001, 4001, 4053, 4053, 4105], [4107, 4107, 4176, 4176, 4549], [4553, 4553, 4597, 4618, 5290], [5292, 5292, 5337, 5358, 6040], [6042, 6042, 6085, 6106, 6795], [6797, 6797, 6843, 6864, 7556], [7558, 7558, 7646, 7815, 8494], [8496, 8496, 8572, 8628, 8792], [8794, 8794, 8906, 9842, 24634], [24636, 24636, 24669, 24669, 30139], [30142, 30184, 30211, 30211, 30971], [30973, 30973, 31030, 31030, 31142]], "test": "untested"}
{"id": "fdyGDG", "name": "Worley Noise and Voronoi Diagram", "author": "Felipe_Rodrigues", "description": "Worley Noise and Voronoi diagram implementation in web GLSL", "tags": ["voronoi", "noise", "random", "worley", "diagram", "voronoy"], "likes": 5, "viewed": 364, "published": 3, "date": "1632026854", "time_retrieved": "2024-07-30T19:00:28.046276", "image_code": "int VORONOI_POINTS = 100;\n\nvoid voronoi(out int point_index, out float node_magnitude, out vec2 node_position,in vec2 uv){\n    \n    // initialize variables\n    float minMagnitude = infinity;\n    vec2 closestPoint;\n    int index;\n    \n    for(int i=1;i<=VORONOI_POINTS;i++){\n        \n        //get a random point\n        vec2 pointPosition = randomVec2(i);\n        \n        //move each point at different speed\n        pointPosition+=vec2(sin(iTime*float(i)/float(VORONOI_POINTS)),cos(iTime*float(i)/float(VORONOI_POINTS)))/10.0;\n       \n        //Voronoi, closest point\n        float dist = distance(pointPosition,uv); \n        if(dist<minMagnitude){\n            closestPoint = pointPosition;\n            minMagnitude = dist;\n            index = i;\n        }\n    }\n    // return the information\n    point_index = index;\n    node_magnitude = minMagnitude;\n    node_position = closestPoint;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n\n    //initialize variables\n    vec2 closestPoint;\n    float minMagnitude;\n    int index;\n\n    //calculate\n    voronoi(index,minMagnitude,closestPoint,uv);\n\n    // Output to screen\n    fragColor = (vec4(closestPoint,0,0));\n    //fragColor += minMagnitude*sqrt(float(VORONOI_POINTS));\n    fragColor *= clamp(minMagnitude*100.0,0.0,1.0);\n    //fragColor += clamp(minMagnitude*100.0,0.0,1.0);\n    //fragColor += float(index)/float(VORONOI_POINTS);\n    //fragColor = vec4(uv,0,0);\n}", "image_inputs": [], "common_code": "\nfloat seed1 = 43.5453;\nfloat seed2 = 91.3458;\nfloat seed3 = 545.88558;\nfloat seed4 = 841.5544;\n\nconst float infinity = 9999999999999.999;\n\nfloat random_seed1_seed2(int number,float firstSeed,float secondSeed) {\n    return fract(sin(float(number)*(firstSeed)) * secondSeed); \n}\n\nvec2 randomVec2(int number){\n    return vec2(random_seed1_seed2(number,seed1,seed2),random_seed1_seed2(number,seed3,seed4));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 122, 155, 890], [893, 893, 950, 950, 1469]], "test": "untested"}
{"id": "fsGGDG", "name": "tunnel and distortion", "author": "heycharlieabbott", "description": "https://www.instagram.com/heycharlieabbott/", "tags": ["tunnel", "monochrome", "perspective"], "likes": 1, "viewed": 234, "published": 3, "date": "1632026328", "time_retrieved": "2024-07-30T19:00:28.810233", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3( 0.,0.,0.);\n    \n    float time = iTime;\n    \n    uv *= rotate2d( sin(uv.y * uv.x * 2.9) *sin(time/5.)/4. );\n   \n   \n    uv *= abs(cos(uv/1.8) +0.2);\n    \n    vec2 pos = vec2(0.5 + cos(time)/1.3,0.5 + sin(time)/8.) - uv;\n    float r = length(pos) * 80.;\n    float a = atan(cos(pos.x),sin(pos.y+ time/2.));\n    \n    a = abs(a*30.);\n    \n    r/= 30. * abs(sin(time)/3. + 1.);\n    float pattern = smoothstep(sin(pos.y*15. + time),sin(time/9.),cos(a/r + time * 20.)) * (pow(r,7.));\n    \n    col = vec3(pattern);\n    \n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [119, 119, 176, 176, 790]], "test": "untested"}
{"id": "fdy3WG", "name": "Fractal 77_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 32, "viewed": 649, "published": 3, "date": "1632022879", "time_retrieved": "2024-07-30T19:00:29.583166", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-i*i*e))\n    {\n        p=g*d;\n        p.z-=.6;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        s=4.;\n        for(int j=0;j++<8;)\n            p=abs(p),p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=1.8/min(dot(p,p),1.3),\n            p=p*e-vec3(12,3,3);\n        g+=e=length(p.xz)/s;\n  \n    }\n    O=pow(O,vec4(5));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 643]], "test": "untested"}
{"id": "fsGGWG", "name": "Magic Loader", "author": "Krischan", "description": "Modified, customizable Loader Animation for my game. Original by munrocket https://www.shadertoy.com/view/td3czf - three particles look better than just one :-D", "tags": ["glow", "particle", "loader"], "likes": 41, "viewed": 1063, "published": 3, "date": "1632015907", "time_retrieved": "2024-07-30T19:00:30.346126", "image_code": "// ================================================================================================\n//\n// MAGIC LOADER ANIMATION\n// original: https://www.shadertoy.com/view/td3czf\n// modified by Krischan\n//\n// ================================================================================================\n\nfloat SCALE = 0.5;\nfloat SPEED = 0.25;\nfloat INTENSITY = 20.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.020;\nfloat FADING = 0.125;\nfloat GLOW = 2.0;\n\n#define M_2_PI 6.28318530\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    float dist1 = mapcircle(uv.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col1 = vec3(1.0, 0.55, 0.25) * pow(RADIUS/dist1, GLOW);\n\tvec3 col2 = vec3(0.55, 1.00, 0.25) * pow(RADIUS/dist2, GLOW);\n\tvec3 col3 = vec3(0.25, 0.55, 1.00) * pow(RADIUS/dist3, GLOW);\n\t\n\tvec3 col=(col1+col2+col3)*(2.*GLOW);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[481, 546, 595, 595, 1170], [1172, 1172, 1193, 1193, 1278], [1280, 1280, 1306, 1306, 1460], [1462, 1515, 1552, 1552, 2056], [2058, 2058, 2093, 2093, 2582], [2584, 2584, 2640, 2640, 3143]], "test": "untested"}
{"id": "7sVGRd", "name": "Gay Flag", "author": "Ravbug", "description": "The 'g' in GPU stands for gay", "tags": ["gay", "lgbt"], "likes": 1, "viewed": 216, "published": 3, "date": "1632007995", "time_retrieved": "2024-07-30T19:00:31.111081", "image_code": "// set to 0 to disable the waving animation\n#define WAVE 1\n\n// adjust the number of stripes\nconst float steps = 2.0;\n\n// linear value remap\nfloat remap(float value, float low1, float high1, float low2, float high2){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// step function w/ floor\nfloat stepf(float value){\n    return remap(floor(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// step function w/ ceiling \nfloat stepc(float value){\n    return remap(ceil(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// keep in range\nfloat clampInRange(float x){\n    return ((x >= 0.0 && x <= 1.0) ? 1.0 : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     #if WAVE\n     uv.y += (sin(10.0*(-iTime/3.0+uv.x))*0.03);\n     #endif\n\n     // green, white, blue\n     vec3 col1 = vec3(0.24,0.54,0.44);\n     vec3 col2 = vec3(1.0,1.0,1.0);\n     vec3 col3 = vec3(0.22,0.13,0.45);\n     \n     float diff = 0.4;\n     \n     // gradient + step function\n     vec3 colorTop = mix(col1,col2,stepf(1.0-remap(uv.y,1.0-diff,1.0,0.0,1.0)));\n     vec3 colorBot = mix(col2,col3,stepc(1.0-remap(uv.y,0.0,diff,0.0,1.0)));\n     \n     vec3 resCol = uv.y < 0.5 ? colorBot : colorTop;\n \n\n    // Output to screen\n    fragColor = vec4(resCol * clampInRange(uv.y),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 140, 215, 215, 285], [287, 313, 338, 338, 415], [417, 446, 471, 471, 547], [549, 566, 594, 594, 645], [647, 647, 704, 755, 1382]], "test": "untested"}
{"id": "sdVGRd", "name": "Fractal 76_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 17, "viewed": 383, "published": 3, "date": "1632001067", "time_retrieved": "2024-07-30T19:00:31.880025", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-.8*i*i*e))\n    {\n        p=g*d-vec3(.3,.5,.8);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.1);\n        p=fract(p)-.5;\n        s=4.;\n        for(int j=0;j++<8;)\n            p=abs(p),\n            p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=1.7/min(dot(p,p),1.2),\n            p=p*e-vec3(16,4,4);\n        g+=e=length(p.xz)/s;\n  \n    }\n    O=pow(O,vec4(3));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 680]], "test": "untested"}
{"id": "7dVGRd", "name": "Ethereal capsule", "author": "SnoopethDuckDuck", "description": "First time raymarching so I think it's going well!\n\n( this is me just trying to break things)", "tags": ["cool"], "likes": 4, "viewed": 212, "published": 3, "date": "1632000997", "time_retrieved": "2024-07-30T19:00:32.652959", "image_code": "#define MAX_STEPS 10\n#define MAX_DIST 100.\n#define SURF_DIST 1.\n\nfloat myLength(vec3 p) {\n    float theta = atan(p.y, p.x);\n    float beta = atan(p.y, p.z);\n    float x = 0.5 * (1. + cos(beta + 0.3 * iTime));\n    float z = 0.5 * (1. + sin(theta + 0.3 * iTime));\n    x = 16. * x * x * (1.-x) * (1.-x);\n    z = 16. * z * z * (1.-z) * (1.-z);\n    return sqrt(pow(p.x + x, 2.) + p.y * p.y + pow(p.z + z, 2.));\n\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    //t = 0.8 * t + 0.2 * 4. * t * (1.-t);\n    vec3 c = a + t * ab;\n    float d = myLength(p - c) - r;\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1.3 + 0.2 * cos(iTime), 6, 1);\n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float b = 0.5 * (1. + cos(0.5 * iTime));\n    \n    float cd = sdCapsule(p, vec3(-cos(-iTime),1.5,6. + sin(-iTime)), vec3(cos(-iTime),1,6.-sin(-iTime)), .8);\n   // float cd2 = sdCapsule(p, vec3(-sin(-iTime),1,6. + cos(-iTime)), vec3(sin(-iTime),1.5,6.-cos(-iTime)), .8);\n   \n   \n    float d = min(cd, planeDist);\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + 1.4 * dO * rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO>MAX_DIST || dO<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 7. + 3. * cos(0.45 * iTime), 3);\n    vec3 lightPos2 = lightPos;\n    vec2 v = 6. * vec2(cos(0.4 * iTime), sin(0.4 * iTime));\n    lightPos.xz += v;\n    lightPos2.xz -= v;\n    vec3 l = normalize(lightPos - p);\n    vec3 l2 = normalize(lightPos2 - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    float dif2 = clamp(dot(n,l2),0.,1.);\n    //dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n    dif *= dif;\n    dif2 *= dif2;\n    float d = RayMarch(p + n * SURF_DIST * 2., l);\n   // if (d<length(lightPos-p))\n     //   dif *= .1;\n\n    return dif + dif2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro - 2. * rd * d;\n    \n    float dif = GetLight(p); \n    dif = 16. * dif * dif *(1.-dif) * (1.-dif);\n    col = vec3(dif);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 89, 89, 408], [410, 410, 460, 460, 689], [691, 691, 714, 714, 1177], [1180, 1180, 1214, 1214, 1437], [1439, 1439, 1463, 1463, 1664], [1666, 1666, 1690, 1690, 2294], [2296, 2296, 2353, 2353, 2737]], "test": "untested"}
{"id": "7dV3zt", "name": "Volcanic planet ", "author": "jarble", "description": "A volcanic landscape on an alien world.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "planet", "mountain", "volcano", "erosion", "volcanic"], "likes": 8, "viewed": 354, "published": 3, "date": "1631997657", "time_retrieved": "2024-07-30T19:00:33.417913", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq-n1*value)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude)+amplitude;\n        freq *= 2.55-amplitude;\n        amplitude *= 1./2.-value/2./2./2.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1501], [1504, 1504, 1535, 1535, 1797], [1863, 1863, 1908, 1908, 2194], [2196, 2196, 2234, 2234, 2489], [2491, 2491, 2558, 2558, 2785], [2787, 2787, 2818, 2818, 4235], [4237, 4237, 4294, 4294, 4928]], "test": "untested"}
{"id": "ssK3zt", "name": "Sandstone canyons", "author": "jarble", "description": "Yet another awe-inspiring desert terrain.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "desert", "canyon", "erosion", "cliff"], "likes": 3, "viewed": 291, "published": 3, "date": "1631995871", "time_retrieved": "2024-07-30T19:00:34.183865", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq-n1*value)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.5-amplitude;\n        amplitude *= 1./2.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1475], [1478, 1478, 1509, 1509, 1771], [1837, 1837, 1882, 1882, 2168], [2170, 2170, 2208, 2208, 2463], [2465, 2465, 2532, 2532, 2759], [2761, 2761, 2792, 2792, 4209], [4211, 4211, 4268, 4268, 4902]], "test": "untested"}
{"id": "7dVGzt", "name": "Sinkholes", "author": "jarble", "description": "An eroded terrain with many gaping holes.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "mountain", "desert", "erosion", "hill"], "likes": 5, "viewed": 322, "published": 3, "date": "1631992858", "time_retrieved": "2024-07-30T19:00:34.947823", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq)-n1*value);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.1-amplitude;\n        amplitude *= 1./3.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1475], [1478, 1478, 1509, 1509, 1771], [1837, 1837, 1882, 1882, 2168], [2170, 2170, 2208, 2208, 2463], [2465, 2465, 2532, 2532, 2759], [2761, 2761, 2792, 2792, 4209], [4211, 4211, 4268, 4268, 4902]], "test": "untested"}
{"id": "ssV3Rt", "name": "Polar Coordinates practice", "author": "mosan_hoshi", "description": "A practice shader for polar coordinates.", "tags": ["2d", "polarcoordinates", "practice"], "likes": 4, "viewed": 229, "published": 3, "date": "1631988418", "time_retrieved": "2024-07-30T19:00:35.827471", "image_code": "// written by mossan-hoshi( https://twitter.com/mossan_hoshi )\n\n#define UPDATE_FREQUENCY 8.\n#define PI 3.1415\n#define RANDOM_SEED 69340.3763\n\nfloat rand_with_time(float co,float freq) { \n  return sin(co*(freq*iTime-fract(freq*iTime))/freq * RANDOM_SEED);\n}\n\nfloat timer(float phase,float freq, float max_val){\n  float normalized_phase = mod(phase / freq, 2. * PI);\n  return mod((normalized_phase - fract(normalized_phase)) * freq, max_val);\n}\n\nfloat calc_value(vec2 uv){\n  float timer = timer(iTime, UPDATE_FREQUENCY, 5.);\n  // circular zone plate\n  float r2 = dot(uv, uv);\n  float radious_offset = 1.5 * iTime -fract(1.5 * iTime);\n  radious_offset = mod(1.3 * mod(radious_offset, 4.),.35);\n  float theta_resolution = 1. + 5. * abs(cos(timer));\n  theta_resolution = 2.0 * (theta_resolution - fract(theta_resolution));\n  float theta = fract(atan(uv.y,uv.x));\n  theta = (theta*theta_resolution - fract(theta*theta_resolution))/theta_resolution;\n  float dist = .1*(rand_with_time(theta,UPDATE_FREQUENCY))+ radious_offset;\n  float value = 1.0 - step(0.01,abs(dist*dist - r2));\n  return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // normalize position(x,y:.0~1.0)\n  vec2 uv= ((fragCoord.xy - .5 * iResolution.xy)/ min(iResolution.x,iResolution.y));\n\n  float default_val = calc_value(uv);\n  float shifted_val = calc_value(uv+vec2(0.0015*(1.+abs(rand_with_time(0.001,10.))),\n                                    0.0015*(1.+abs(rand_with_time(0.001,10.)))));\n  fragColor=vec4(shifted_val,\n                 default_val,\n                 default_val,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 185, 185, 256], [258, 258, 309, 309, 442], [444, 444, 470, 470, 1090], [1092, 1092, 1148, 1184, 1571]], "test": "untested"}
{"id": "7tlXDr", "name": "3D Bezier: linear-time algorithm", "author": "maras", "description": "I made this shader to make it easier to visualize Bezier curves in 3D and linear time algorithm.\nYou can find more shaders to learn about Bezier curves\non my playlist: https://www.shadertoy.com/pl\nMore info in comment below (sorry, characters limit).", "tags": ["3d", "bezier", "camera", "curve", "learning"], "likes": 2, "viewed": 329, "published": 3, "date": "1631982567", "time_retrieved": "2024-07-30T19:00:36.775935", "image_code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves in 3D and de Casteljau's algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n#define BEZIER_CURVE_POINTS 3 // int, minimum = 2, maximum = 13\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define DRAWING_STEPS 50 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.05   // anti-aliasing\n#define EDGE_LINE 0.0003\n#define SMOOTH_LINE 0.01\n#define SMOOTH 0.001  // anti-aliasing \n\nconst int max_count = BEZIER_CURVE_POINTS;\n\nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n\nconst float coPlanerThreshold = 0.7; // Some threshold value that is application dependent\nconst float lengthErrorThreshold = 0.1;\n\nvec3 control_points[13] = vec3[](\n                        vec3(-0.5, -0.5, 0.0),\n                        vec3(0.0, 2.0, 0.5),\n                        vec3(0.0, -1.0, 1.5),\n                        vec3(0.4, 1.6, 1.3),\n                        vec3(-1.4, 0.6, 0.3),\n                        vec3(0.4, -1.0, 2.8),\n                        vec3(-0.8, 1.0, 0.8),\n                        vec3(1.2, -0.2, 0.4),\n                        vec3(0.0, 0.0, -1.0),\n                        vec3(3.0, -1.0, 0.7),\n                        vec3(5.4, -4.0, 1.8),\n                        vec3(0.4, 4.0, 3.2),\n                        vec3(0.0, 0.0, 2.0)\n                        );\n\n// link to video explaining below function:\n// https://www.youtube.com/watch?v=ELQG5OvmAE8&ab_channel=EgoMoose\nfloat RaySegmentDistance(vec3 start, vec3 end, vec3 ray_origin, vec3 ray_screen_intersection) { \n\tvec3 q = start - ray_origin;\n    vec3 r = end - start;\n    vec3 s = ray_screen_intersection - ray_origin;\n    \n    float t = (dot(q, s) * dot(r, s)) - (dot(q, r) * dot(s, s));\n    t = t / ((dot(r, r) * dot(s, s)) - (dot(r, s) * dot(s, r)));\n    \n    float u = dot(q, s) + (t * dot(r, s)); \n    u = u / dot(s, s);\n    \n    if (t > 1.0 || t < 0.0 || u < 0.0) { return 100.0; }\n    \n    vec3 P0 = start + t * r;\n    vec3 P1 = ray_origin + u * s;\n    \n    return distance(P0, P1);\n}\n\nfloat DistLine(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    return length(cross(point - ray_origin, ray_direction)) / length(ray_direction);\n}\n\nfloat DrawPoint(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    float dist = DistLine(ray_origin, ray_direction, point);\n    //dist = 1.0 - smoothstep(0.01, 0.09, dist);\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n\n    float zoom = 1.0;\n    zoom = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 ).x;\n    vec3 ray_origin = vec3(0.0,  0.0, -3.0);     // camera point\n    \n    //ray_origin = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0 ) );\n    \n    ray_origin.zy = ray_origin.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray_origin.yz;\n    ray_origin.xz = ray_origin.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray_origin.zx;\n    \n    vec3 lookat = vec3(0.5); // center of scene\n    vec3 forward_vector = normalize(lookat - ray_origin);\n    vec3 right_vector = cross(vec3(0.0, 1.0, 0.0), forward_vector);\n    vec3 up_vector = cross(forward_vector, right_vector);\n\n    vec3 screen_center = ray_origin + forward_vector * zoom;\n\n    vec3 ray_screen_intersection = screen_center + uv.x * right_vector + uv.y * up_vector;\n    vec3 ray_direction = ray_screen_intersection - ray_origin; // point at screen\n    \n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    control_points[max_count - 1] = control_points[control_points.length() - 1];\n    \n    vec3 final_point = vec3(0.0);\n        \n    float t2 = (1.0 - t);\n                \n    float draw_start_point = DrawPoint(ray_origin, ray_direction, control_points[0]);\n    float draw_end_point = DrawPoint(ray_origin, ray_direction, control_points[max_count - 1]);\n    \n    vec3 col = vec3(1.0);\n    \n    // draw start point\n    if (draw_start_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_start_point = (EDGE - draw_start_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_start_point;\n    }\n    \n    // draw end point\n    if (draw_end_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_end_point = (EDGE - draw_end_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_end_point;\n    }\n\n    // draw bezier curve using linear-time algorithm\n    if (SHOW_BLACK_LINE) {\n        float end_algorithm = t;\n        float drawing_steps = float(DRAWING_STEPS);\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n        else { drawing_steps *= t; } // without this big DRAWING_STEPS and small t couses visual glitch (i don't know why :D)\n\n        float increaser = end_algorithm / drawing_steps;\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n                                \n        vec3 prev_point = control_points[0];\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            float h = 1.0;\n            float u = (1.0 - i);\n            int n = max_count - 1;\n            int n1 = n + 1;\n            vec3 Q = control_points[0];\n            \n            if (i != 0.0) {\n                if (i <= 0.5) {\n                    u = i / u;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * u * (float(n1) - float(k));\n                        h = h / (float(k) + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n                else {\n                    u = u / i;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * (float(n1) - float(k));\n                        h = h / (float(k) * u + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n            }\n            \n            vec3 point = Q;\n            \n            float dist = RaySegmentDistance(prev_point, point, ray_origin, ray_screen_intersection);\n            \n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= dist;\n            }\n            \n            prev_point = point;\n        }\n    }\n        \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        float dist = DrawPoint(ray_origin, ray_direction, control_points[i]);\n        \n        if (dist < EDGE + SMOOTH && show_support_points[i])\n        {\n            dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n            col *= vec3(0.0,0.0, float(max_count - i) / float(max_count) + 0.1) * dist;\n        }\n    }\n\n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            float dist = RaySegmentDistance(control_points[i], control_points[i + 1], ray_origin, ray_screen_intersection);\n\n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n\n    // draw support lines and points\n    float h = 1.0;\n    float u = (1.0 - t);\n    int n = max_count - 1;\n    int n1 = n + 1;\n    vec3 Q = control_points[0];\n    vec3 prev_Q = Q;\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                float dist = RaySegmentDistance(prev_Q, control_points[k], ray_origin, ray_screen_intersection) * 2.0;\n                if (dist < EDGE_LINE + SMOOTH_LINE && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                    col *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = DrawPoint(ray_origin, ray_direction, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1] && k < n)\n                {\n                    dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n                    col *= support_points_colors[k-1] * dist;\n                }\n                \n                prev_Q = Q;\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                float dist =  RaySegmentDistance(prev_Q, control_points[k], ray_origin, ray_screen_intersection) * 2.0;\n                if (dist < EDGE_LINE + SMOOTH_LINE && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                    col *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = DrawPoint(ray_origin, ray_direction, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1] && k < n)\n                {\n                    dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n                    col *= support_points_colors[k-1] * dist;\n                }\n                \n                prev_Q = Q;\n            }\n        }     \n    }\n    \n    // draw final point \n    h = 1.0;\n    u = (1.0 - t);\n    n = max_count - 1;\n    n1 = n + 1;\n    Q = control_points[0];\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n    }\n\n    vec3 point = Q;\n    \n    float dist = DrawPoint(ray_origin, ray_direction, point);\n    if (dist < EDGE + SMOOTH && SHOW_FINAL_DOT)\n    {\n        dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n        col *= final_dot_color * dist;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// camera \"drag and rotate\" system\n// taken almost directly from https://www.shadertoy.com/view/ldyGzW\n\nconst float accel = .01;\nconst float decay = .95; // how much velocity is preserved per frame (proportionally)\n\nconst float yMul = -1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            if ( camPos.y < .0 ) { fragColor.y = .0; }\n\n            \n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// zooming system\n// taken almost directly from https://www.shadertoy.com/view/4sVSDm\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0;\n    \n    if(iFrame>0) {\n        //read previous state\n        vec4 zoom_vec = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 );\n        zoom = zoom_vec.x;\n    }\n    \n    //read arrow button press and update state via changing the texture \n    if( texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x>0.1 ) { zoom *= 1.2; }\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x>0.1 ) { zoom /= 1.2; }\n\n    fragColor = vec4(zoom);\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6350, 6461, 6556, 6556, 7037], [7039, 7039, 7104, 7104, 7191], [7193, 7193, 7259, 7259, 7393]], "test": "untested"}
{"id": "NsVGzd", "name": "webcam_001", "author": "catafest", "description": "simple webcam example with predator heat effect.", "tags": ["heat", "webcam", "predator", "catafest"], "likes": 2, "viewed": 607, "published": 3, "date": "1631979875", "time_retrieved": "2024-07-30T19:00:37.535903", "image_code": "vec3 predatorHeat(float v) {\n    float value = 1.0 - v;\n    return (0.5+0.5*smoothstep(0.0, 0.1, value))*vec3(\n      \tsmoothstep(0.5, 0.3, value),\n      \tvalue < 0.3 ? smoothstep(0.0, 0.3, value) : smoothstep(1.0, 0.6, value),\n    \tsmoothstep(0.4, 0.6, value)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 temp = texture(iChannel0, uv);\n    vec4 temp2 = texture(iChannel1,uv);\n    \n    float average = ((temp.r + temp.g + temp.b) / 2.5);\n    \n    temp.rgb = vec3(predatorHeat(average));\n    \n    if(uv.x > 0.5)\n        fragColor = temp;\n    else\n        fragColor = temp2;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 265], [267, 267, 324, 374, 693]], "test": "untested"}
{"id": "fsKGzd", "name": "adminhelp.ogg but getting faster", "author": "pali6", "description": "knock knock knock knock knock knock knock\n(In the game Space Station 13 (branch Goonstation) the 4 knocks play when an administrator messages you. This simulates the experience of really screwing up and getting bombarded with admin PMs.)", "tags": ["sound", "ss13"], "likes": 1, "viewed": 372, "published": 3, "date": "1631977660", "time_retrieved": "2024-07-30T19:00:38.304847", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0) * aa(loop(iTime + uv.x - 0.5));\n    \n    if(uv.x >= 0.499 && uv.x <= 0.501)\n        fragColor = vec4(1., 1., 1., 2.) - fragColor;\n}", "image_inputs": [], "sound_code": "\n\nvec2 mainSound( int samp, float time )\n{\n    float time2 = loop(time);\n    float t = time / 0.004 * 2. * PI;\n    float a = sin(t);\n    a *= aa(time2);\n    return vec2( a );\n}", "sound_inputs": [], "common_code": "#define PI 3.141592653589\n\nfloat loop(float time)\n{\n    float baseTime = time;\n    // time = pow(time + 1., 1.2) - 1.;\n    if(time < 0.)\n        return 0.;\n    \n    /*float p1 = 2. - (0.6 + 0.6 * tanh(time * 0.2 - 10.));\n    time /= p1;\n    time = fract(time);\n    time *= p1;\n    */\n    /*time = log(fract(1. + exp(time * 0.1)));\n    time /= 0.1;\n    time *= 4.;\n    */\n    const float Q = 6.;\n    const float M = 0.1;\n    time = (time + Q) * M - log(floor(exp((time + Q) * M)));\n    time /= M;\n    \n    time = time / 0.2;\n    if(time >= 4.)\n        return 0.;\n    time = fract(time);\n    time = time * 0.2;\n    return time;\n}\n\nfloat aa(float time)\n{\n    if(time <= 0.)\n        return 0.;\n    float t = time / 0.004 * 2. * PI;\n    float t2 = time / 0.040 * 2. * PI;\n    float a = 1.;\n    a *= 0.7 + 0.3 * (1. - cos(t2));\n    a *= pow((0.2 - time) / 0.2, 2.);\n    if(time <= 0.01) a *= time / 0.01;\n    return a;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 423]], "test": "untested"}
{"id": "fsK3Rt", "name": "Eroded sandstone hills", "author": "jarble", "description": "A simple hill terrain with realistic-looking erosion.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "mountain", "desert", "erosion", "hill"], "likes": 13, "viewed": 434, "published": 3, "date": "1631961937", "time_retrieved": "2024-07-30T19:00:39.073791", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.-amplitude;\n        amplitude *= 1./3.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1468], [1471, 1471, 1502, 1502, 1764], [1830, 1830, 1875, 1875, 2161], [2163, 2163, 2201, 2201, 2456], [2458, 2458, 2525, 2525, 2752], [2754, 2754, 2785, 2785, 4202], [4204, 4204, 4261, 4261, 4895]], "test": "untested"}
{"id": "7sG3zd", "name": "snowflake lattice", "author": "pali6", "description": "It's the previous project but now all layers overlaid on top of each other and inverted pretty much.", "tags": ["tiling", "penrose"], "likes": 9, "viewed": 316, "published": 3, "date": "1631958550", "time_retrieved": "2024-07-30T19:00:39.836751", "image_code": "#define DEPTH 21\n#define PHI ((1. + sqrt(5.)) / 2.)\n#define PI 3.141592653589\n//#define DEPTH int(round(16. - 7. * cos(iTime / 5.)))\n\n\n#define S(M, O) (0.5 + 0.5 * sin(O + M * pos.x)) / 6.\n#define C(M, O) (0.5 + 0.5 * cos(O + M * pos.y)) / 6.\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool onRight(vec2 a, vec2 b, vec2 x)\n{\n    return cross(vec3(a - b, 0), vec3(x - b, 0)).z > 0.;\n}\n\nfloat cr(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat cr(vec2 a, vec2 b, vec2 c)\n{\n    return cr(b - a, c - b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = fragCoord / iResolution.xx;\n    \n    float scale = 72. + 18. * sin(iTime / 10.) + 20. * sin(4. + iTime / 15.) + 30. * sin(iTime / 6.);\n    vec2 camPos = vec2(0.5, 0.5);\n    float SF = 1. / pow(scale, 0.3);\n    camPos += vec2(0.02 * sin(iTime / 15.), -0.07 * cos(iTime / 19.)) * SF;\n    camPos += vec2(-0.1 * sin(3. + iTime / 37.), -0.1 * cos(4. + iTime / 27.)) * SF;\n    camPos += vec2(0.07 * sin(9. + iTime / 47.), -0.08 * cos(20. + iTime / 31.)) * SF;\n    camPos += vec2(0.04 * sin(19. + iTime / 7.), 0.06 * cos(25. + iTime / 5.)) * SF;\n    \n    pos -= vec2(0.5, 0.5);\n    pos = rotate(pos, iTime / 30. + PI * cos(iTime / 37.) + 2. * PI * sin(iTime / 87. + 10.));\n    pos /= scale;\n    pos += camPos;\n    \n    vec2 ota = vec2(-1., 0.);\n    vec2 otb = vec2(2., 0.);\n    \n    vec2 ta = ota;\n    vec2 tb = otb;\n    vec2 tc;\n    bool gn = true;\n    float fl = -1.;\n    \n    float f = 0.;\n    \n    // vec2 otc;\n    \n    float nDark = 0.;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        vec2 next;\n        if(gn)\n            tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n        else\n            tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n            \n        if(!(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n          !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5))\n        {\n            nDark += 1.;\n        }\n        \n        \n        if(gn)\n        {\n            next = tb + (ta - tb) / PHI;\n            if(abs(cr(next, tc, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(next, tc, pos) * cr(next, tc, tb) > 0.)//onRight(next, tc, pos))\n            {\n                gn = false;\n                ta = next;\n                tb = tc;\n                fl *= -1.;\n                i--;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        else\n        {\n            next = tc + (tb - tc) / PHI;\n            if(abs(cr(ta, next, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(ta, next, pos) * cr(ta, next, tb) > 0.)//onRight(ta, next, pos))\n            {\n                gn = false;\n                ta = tb;\n                tb = next;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        //if(i == 0)\n        //    otc = tc;\n    }\n    /*\n    fragColor =\n        (1. - nDark / float(DEPTH)) * vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        ) * 1.8 +\n        (nDark / float(DEPTH)) * vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n    */\n    fragColor =\n        (nDark / float(DEPTH)) * vec4(\n            0.10 + S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.) + S(1., 42.) + C(1.5, 73.),\n            0.10 + C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.) + S(1.2, 49.) + C(0.9, 79.),\n            0.15 + S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.) + S(0.7, 13.) + C(0.11, 31.),\n            1.\n        ) * 1.5;\n\n    /*\n    if(gn)\n        tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n    else\n        tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n    \n    if(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n      !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5)\n    {\n        fragColor = vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        );\n    }\n    else\n        fragColor = vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n        */\n    \n    // if(f > 0.) fragColor = vec4(1, 0, 0, 1);\n    \n    /*\n    if(length(uv - ota) <= 0.01)\n        fragColor += vec4(0.5, -0.5, -0.5, 0.0);\n    if(length(uv - otb) <= 0.01)\n        fragColor += vec4(-0.5, 0.5, -0.5, 0.0);\n    if(length(uv - otc) <= 0.01)\n        fragColor += vec4(-0.5, -0.5, 0.5, 0.0);\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 274, 274, 358], [360, 360, 398, 398, 457], [459, 459, 485, 485, 521], [523, 523, 557, 557, 588], [590, 590, 645, 645, 5258]], "test": "untested"}
{"id": "sdy3Rd", "name": "Fractal 75_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 17, "viewed": 399, "published": 3, "date": "1631952300", "time_retrieved": "2024-07-30T19:00:40.601706", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.4)*.02*exp(-.5*i*i*e))\n    {\n        p=R(g*d,vec3(.577),.2);\n        p.z+=iTime;\n        p=fract(p)-.5;\n        s=3.;\n        for(int j=0;j++<8;)\n            p=abs(p),\n            p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=2./min(dot(p,p),1.),\n            p=p*e-vec3(.2,1,4);\n        g+=e=length(p)/s;\n    } \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 625]], "test": "untested"}
{"id": "7sGGRd", "name": "tiktok fx", "author": "fofod", "description": "tiktok fx", "tags": ["tiktok"], "likes": 2, "viewed": 238, "published": 3, "date": "1631944354", "time_retrieved": "2024-07-30T19:00:41.366661", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 1.0;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec4 sampleColor = texture(iChannel0, uv);\n    vec4 sampleColor1 = texture(iChannel0, uv);\n    sampleColor.rgb = vec3((sampleColor.r * 0.3 + sampleColor.g * 0.59 + sampleColor.b * 0.11));\n    sampleColor.rgb = smoothstep(0.555,.588,sampleColor.rgb) * smoothstep(0.555,.588,sampleColor.rgb);\n    \n    float scale = 8.;\n    float scale1 = 8.;\n    float scale2 = 8.;\n    fragColor =  vec4(texture(iChannel0, uv * .97 + 0.03 * clamp(0.,sin(iTime * scale + 10.),1.)).r ,\n    texture(iChannel0, uv * .99 + 0.01 * clamp(0.,sin(iTime * scale + 3.),1.)).g,  \n    texture(iChannel0, uv * .95 + 0.05 * clamp(0.,sin(iTime * scale + 7.),1.)).b,1.);\n} ", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 920]], "test": "untested"}
{"id": "7dy3zt", "name": "holopunk", "author": "fofod", "description": "cool holo ring punk fx", "tags": ["punk"], "likes": 3, "viewed": 226, "published": 3, "date": "1631942252", "time_retrieved": "2024-07-30T19:00:42.192453", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xx -.5);\n\t//vec2 uv = (fragCoord.xy / iResolution.xx - 0.5)；\n\t float c = 0.02;\n         uv.y+=.22;\n\t//uv*= abs(cos(iTime) + 1.);\n    float iiTime = iTime * 0.1;\n\tuv*= mat2(sin(iiTime),cos(iiTime),-cos(iiTime),sin(iiTime));\n\tvec3 p = vec3(uv,1.0);\n\tc = .3/length(uv);\n\tvec3 mask = fract(p*10.);\n\tvec3 mask1 = fract(p*100.);\n\tmask*= vec3(.3,0.,0.);\n\tif(mask.x > .05 && mask.y > .05) {\n\t\tmask = vec3(0.);\n\t} else {\n\t\tmask = vec3(1.)*c;\n\t}\n\tif(mask1.x > .05 && mask1.y > .05) {\n\t\tmask1 = vec3(0.);\n\t} else {\n\t\tmask1 = vec3(1.)*c;\n\t}\n\tmask += mask1;\n\tvec3 col = mask * abs(sin(iiTime))* abs(sin(iiTime)) * vec3(p +.3);\n\n    // Output to screen\n    fragColor = vec4(cos(iTime * col) * sin(iTime * col) + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 856]], "test": "untested"}
{"id": "7sKGRy", "name": "Iterative Subdivison Fractal", "author": "Tater", "description": "Does this count as a fractal? Not sure. \n\nBased on 2D version from my previous shader: [url]https://www.shadertoy.com/view/7sV3WD[/url]", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 34, "viewed": 916, "published": 3, "date": "1631940566", "time_retrieved": "2024-07-30T19:00:42.963391", "image_code": "#define MDIST 150.0\n#define STEPS 300.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat volume(vec3 a){\n    return a.x*a.y*a.z;\n}\n//Based on code from bigwings comment here\n//https://www.shadertoy.com/view/Wl3fD2\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    p/=b;\n    vec3 dir = sign(rd)*.5;   \n    vec3 rc = (dir-p)/rd;\n    rc*=b;\n    float dc = min(min(rc.x, rc.y), rc.z)+0.001;\n    return dc;\n}\n\nvec3 rdg = vec3(0);\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n      \n    vec2 xRange = vec2(-0.5,0.5)*scl.x;\n    vec2 yRange = vec2(-0.5,0.5)*scl.y;\n    vec2 zRange = vec2(-0.5,0.5)*scl.z;\n    float id = 0.;\n    float seed = floor(t/6.)+0.1;\n    \n    //Some parameters to play with :D\n    float minSize = 0.15;\n    float iters = 12.;\n    float minIters = 1.;\n    float breakChance = 0.0;\n    float maxVolume = 5.0;\n    float destructionChance = 0.5;\n    float maxCenterDist = 4.5;\n    float padFact = 1.01;\n    \n    float xLength=0.;\n    float yLength=0.;\n    float zLength=0.;\n    \n    for(float i = 0.;i<iters;i++){\n        xLength = xRange.y-xRange.x;\n        yLength = yRange.y-yRange.x;\n        zLength = zRange.y-zRange.x;\n        \n        float dividex = h21(vec2(i+id,seed))*(xLength)+xRange.x;\n        float dividey = h21(vec2(i+id,seed))*(yLength)+yRange.x;\n        float dividez = h21(vec2(i+id,seed))*(zLength)+zRange.x;\n        \n        dividex= clamp(dividex,xRange.x+minSize*padFact,xRange.y-minSize*padFact);\n        dividey= clamp(dividey,yRange.x+minSize*padFact,yRange.y-minSize*padFact);\n        dividez= clamp(dividez,zRange.x+minSize*padFact,zRange.y-minSize*padFact);\n        \n        float mn = min(length(xRange.x-dividex),length(xRange.y-dividex));\n        mn = min(mn,min(length(yRange.x-dividey),length(yRange.y-dividey)));\n        mn = min(mn,min(length(zRange.x-dividez),length(zRange.y-dividez)));\n        bool willBreak = false;\n        if(i-1.>minIters && h11(id)<breakChance) willBreak = true;\n        if(mn<minSize&&i-1.>minIters||i==iters-1.) willBreak = true;\n        if(willBreak) {\n        //id = i*0.1*seed;\n        break;\n        }\n        vec3 diff = vec3(0);\n        if(p.x<dividex){\n            xRange = vec2(xRange.x,dividex);\n            diff.x+=dividex;\n        }\n        else{\n            xRange = vec2(dividex,xRange.y);\n            diff.x-=dividey;\n        }\n        if(p.y<dividey){\n            yRange = vec2(yRange.x,dividey);\n            diff.y-=dividex;\n        }\n        else{\n            yRange = vec2(dividey,yRange.y);\n            diff.y+=dividey;\n        }\n        if(p.z<dividez){\n            zRange = vec2(zRange.x,dividez);\n            diff.z-=dividex;\n        }\n        else{\n            zRange = vec2(dividez,zRange.y);\n            diff.z+=dividez;\n        }\n\n        id = length(diff+10.0);\n    }\n    \n    float volume = volume(vec3(xLength,yLength,zLength));\n    vec3 center = vec3((xRange.x+xRange.y)/2.,(yRange.x+yRange.y)/2.,(zRange.x+zRange.y)/2.);\n\n    //huge improvment in performance by using distance to intersection of empty cell\n    //to remove boxes (instead of using a negative box sdf)\n    //But it seems to cause artifacts rarely, idk why\n    float b = dibox(p-center,vec3(xLength,yLength,zLength),rd);\n    \n    float shr = 1.0-abs(pow(abs(cos(mod(t,6.)*pi/6.)),6.0));\n    shr = smoothstep(0.,1.,shr);\n    vec3 d = abs(center);\n    center.y-=yLength*(1.0-shr)*0.5;\n    yLength*=shr;\n    float a = box(p-center,vec3(xLength,yLength,zLength)*0.5);\n\n    //I found this helps to remove some of the artifacts from using the empty box intersection\n    if(abs(p.x)>scl.x*0.5) b=-a;\n    if(abs(p.z)>scl.z*0.5) b=-a;\n    \n    a=min(a,b);\n    if(max(d.x,max(d.y*0.5,d.z))>maxCenterDist)a=b;\n    else if(volume>maxVolume)a=b;\n    else if (h11(id*1.1)<destructionChance)a=b;\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec2 map(vec3 p){\n    float t = iTime;\n    p.y-=1.0;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 scl = vec3(10.0,14.,10);\n    vec3 rd2 = rdg;\n    a = blocks(p,scl,rdg)+0.02;\n    \n    a.x = max(box(p,vec3(scl*0.49)),a.x);\n    \n    p.y+=scl.y*0.5+5.2;\n    b.x = ebox(p,vec3(5.2))-0.2;\n    \n    a=(a.x<b.x)?a:b;\n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.00005,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,5,-20);\n    if(iMouse.z>0.){\n    ro.zx*=rot(7.0*iMouse.x/iResolution.x);\n    }\n    else ro.zx*=rot(iTime*0.3);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1,-1));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        vec3 e = vec3(0.5);\n        \n        vec3 al = pal(d.y*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n        if(d.y==2.0) al = vec3(1.);\n        col = al;\n        \n        //float diff = length(sin(n*2.)*.5+.8)/sqrt(3.);\n        float diff = mix(0.7,1.0,dot(ld,n)*0.5+0.5);\n\n        col = al*diff;\n        \n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<50.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }     \n        col*=shadow;\n    }\n    vec3 bg = mix(vec3(0.173,0.231,0.686),vec3(0.361,0.753,1.000),rd.y*0.5+0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 127, 194, 194, 233], [234, 234, 254, 254, 325], [326, 326, 347, 347, 399], [400, 400, 426, 426, 485], [486, 486, 513, 513, 600], [601, 601, 622, 622, 648], [649, 732, 767, 767, 911], [933, 933, 972, 972, 4330], [4332, 4332, 4349, 4349, 4682], [4683, 4683, 4701, 4701, 4832], [4833, 4833, 4890, 4890, 6447]], "test": "untested"}
{"id": "ssyGzt", "name": "Sound Experiment #1", "author": "oneshade", "description": "Experimenting with sound tab. Hope it doesn't hurt anyone's ears!", "tags": ["sound", "experiment", "short"], "likes": 6, "viewed": 181, "published": 3, "date": "1631939992", "time_retrieved": "2024-07-30T19:00:43.730341", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "common_code": "#define TAU 6.28\n\nfloat whiteNoise(in float time) {\n    return fract(495.381 * cos(937.385 * time + 18.387));\n}\n\nfloat squareWave(in float time) {\n    return mod(floor(2.0 * time), 2.0);\n}\n\nfloat triWave(in float time) {\n    return (1.0 - 2.0 * abs(1.0 - 2.0 * fract(time + 0.25)));\n}\n\nfloat sineWave(in float time) {\n     return sin(TAU * time);\n}\n\nfloat bump(in float time, in float width, in float sharpness) {\n    time = max(0.0, abs(time) - width) * sharpness;\n    return exp(-time * time);\n}\n\nfloat expFade(in float time, in float sharpness) {\n    return exp2(-time * sharpness);\n}\n\nfloat makeNoise(in float time) {\n    float time1 = mod(time, 2.5);\n    float sound = sineWave(time1 * 200.0);\n    sound += triWave(time1 * 100.0);\n    sound *= expFade(time1, 3.0);\n    sound *= min(1.0, expFade(time1, -3.0) * sineWave(time1 * 3.0));\n    if (time > 5.0) {\n        sound *= 2.0;\n    }\n\n    if (time > 12.0 && time < 18.0) {\n        float time2 = mod(time - 12.0, 2.0);\n        sound /= mix(1.0, pow(abs(sineWave(time2 * 25.0)), 2.0) + 0.1, expFade(time2, 1.0));\n    }\n\n    if (time > 18.0) {\n        sound *= 2.0;\n    }\n\n    if (time > 23.0) {\n        sound *= expFade(time - 23.0, 0.5);\n    }\n\n    return sound;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 574, 596, 1411]], "test": "untested"}
{"id": "7dGGzt", "name": "Analytic domain repetition", "author": "NLIBS", "description": "A function for ray tracing cubes repeated In one dimension. (no loops in the code)\nMove around with the mouse", "tags": ["raytracing", "domainrepetition", "shadows", "infinite"], "likes": 6, "viewed": 315, "published": 3, "date": "1631936316", "time_retrieved": "2024-07-30T19:00:44.499285", "image_code": "#define PI 3.14159265359\n#define EPS 0.001\n//#define BASIC\n\nfloat plane(vec3 ro, vec3 rd, float h) \n{\n    float t = (h-ro.y)/rd.y;\n    if (t<=0.) t = 1e5;\n    return t;\n}\n\nvec4 ray(vec3 ro, vec3 rd) \n{ \n    float t = plane(ro,rd,1.)*step(1.,ro.y);\n    vec3 n = vec3(0.,1.,0.);\n    \n    if (abs(ro.x)>.5-EPS) {\n        vec3 s = vec3(1.,sign(ro.x),1.);\n        float t2 = plane(ro.yxz*s,rd.yxz*s,.5-EPS)+EPS;\n        if (t2>=t) {\n            t = t2;\n            n = vec3(s.y,0.,0.);\n        }\n    }\n    \n    vec3 p = ro+rd*t;\n    float target = mix(p.z,floor(p.z+step(0.,rd.z)),mod(floor(p.z),2.));\n    float shift = (target-p.z)/rd.z;\n    t += shift;\n    if (abs(shift)>EPS) n = vec3(0.,0.,-sign(rd.z));\n    if (t<=0. || abs(ro.x+rd.x*t)>.5 || abs(ro.y+rd.y*t)>1.+EPS) t = 1e5;\n    \n    float t2 = plane(ro,rd,0.);\n    if (t2<t) {\n        t = t2;\n        n = vec3(0.,1.,0.);\n    }\n    \n    return vec4(t,n);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R   = iResolution.xy,\n         uv  = (2.*u-R)/R.x,\n         muv = -(2.*iMouse.xy-R)/R.x*PI*.5;\n    \n    muv = mix(vec2(.7,.3), muv, step(1.,iMouse.z));\n    //Camera\n    vec3 ro = vec3(muv.x*6.,2.,iTime),\n         rd = normalize(vec3(uv,1));\n         \n    //Add Mouse rotation\n    vec4 cs = vec4(cos(muv),sin(muv));\n    rd.yz = mat2(cs.y,cs.w,-cs.w,cs.y)*rd.yz;\n    rd.xz = mat2(cs.x,cs.z,-cs.z,cs.x)*rd.xz;\n    \n    vec3 col = vec3(0.);\n    \n    vec4 tn = ray(ro,rd);\n    vec3 p = ro+rd*(tn.x-EPS);\n    \n    vec3 ld = vec3(4.*sin(iTime),4.,iTime+6.)-p;\n    float d = length(ld)*0.05;\n    ld /= d;\n    \n    #ifdef BASIC\n    col = vec3(1.) * 0.5*(1.-sqrt(1.-min(0.01/(d*d),1.)));\n    #else\n    col = vec3(1.) * dot(tn.yzw,ld) * 0.5*(1.-sqrt(1.-min(0.01/(d*d),1.)));\n    vec4 tn2 = ray(p,ld);\n    if (tn2.x<1e4 || tn.x>1e4) col *= 0.;\n    #endif\n    \n    col = pow(max(1.-exp(-col),EPS),vec3(1./2.2));\n        \n    O = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 101, 101, 170], [172, 172, 201, 201, 908], [910, 910, 951, 951, 1892]], "test": "untested"}
{"id": "ssG3Rt", "name": "Marbled desert hills", "author": "jarble", "description": "A simple desert terrain based on Karang's \"Desert biome\" shader.", "tags": ["procedural", "planet", "mountain", "mountain", "desert", "hill", "biome"], "likes": 6, "viewed": 271, "published": 3, "date": "1631933680", "time_retrieved": "2024-07-30T19:00:45.273216", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/1.5)+cos(uv.y*1.5);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    float f2 = .1; //this constant changes the variation in mountain height\n    \n    float f1 = f2;\n    float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        uv += vec2(amplitude,freq);\n        n1 = abs(noise((uv) * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 2.1-amplitude;\n        amplitude *= 1./3.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    \n    return -value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssG3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 425], [427, 427, 466, 572, 1481], [1484, 1484, 1515, 1515, 1777], [1843, 1843, 1888, 1888, 2174], [2176, 2176, 2214, 2214, 2469], [2471, 2471, 2538, 2538, 2765], [2767, 2767, 2798, 2798, 4215], [4283, 4283, 4340, 4340, 5142]], "test": "untested"}
{"id": "fdy3zd", "name": "ADSR Filter Visual [Sound]", "author": "Yusef28", "description": "This filter cannot be mouse enabled because ADSR values can't be accessed in any kind of buffer for on the fly processing. I've created animation functions in common and I'm calling them in Image and Sound. Sounds like Tycho lol", "tags": ["procedural", "2d", "sound", "music", "utils", "adsr"], "likes": 12, "viewed": 399, "published": 3, "date": "1631928143", "time_retrieved": "2024-07-30T19:00:46.229658", "image_code": "///////////////////////////////////////////////\n//\n// Author:Yusef28\n// Start Date: 17-09-2021\n// Status: On Going\n// Topic: Audio Processing Start\n// Sources: Google ADSR or try FL studio \n\n\n#define line1Col vec3(0.,.2,1.)\n#define ringCol vec3(1.,.3,.3)\n#define letterCol vec3(0.0,0.4,1.)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 draw_line(vec2 A, vec2 B, vec2 uv, vec3 col){\n    return mix(col, line1Col, 1.0-smoothstep(0.01,0.02,\n    abs(distToLine(A, B, uv))));\n    \n}\n\nvec3 draw_point(vec2 Point, vec2 uv, vec3 col){\n    float f = 1.-smoothstep(0.01,0.012,\n    abs(length(uv-Point)-0.03));\n    col = mix(col, ringCol, f);\n    return col;\n    \n}\n\n// From oneshade\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, p / 16.0 + \n        fract(vec2(char, 15 - char / 16) / 16.0), \n        dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        \n        color = mix(color, charColor, val);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 st = uv;\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv += vec2(0.5,0.25);\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.8);\n    col = mix(col,vec3(0.9),1.0-length(uv/8.));\n   // float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.7),tex);\n    \n    //small grid lines\n    vec2 lines = fract(uv*3.);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.7),lines.x);\n    col = mix(col,vec3(0.7),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.3),lines.x);\n    col = mix(col,vec3(0.3),lines.y);\n    //axis lines\n    lines = smoothstep(0.02,0.025,abs(uv));\n    col = mix(col,vec3(0.,0.,0.0),1.0-lines.x);\n    col = mix(col,vec3(0.,0.,0.0),1.-lines.y);\n\n    //Animated ADSR Curve\n    vec2 Start = vec2(0.,0.);\n    vec2 A = vec2(0. + anim_Ax(iTime/2.), 1.);\n    vec2 D = vec2(0.4 + anim_Dx(iTime/2.), anim_Dy(iTime/4.));\n    vec2 S = vec2(0.8 + anim_Sx(iTime/2.), anim_Sy(iTime/2.));\n    vec2 R = vec2(1. + anim_Rx(iTime/2.), 0.);\n\n    float draw_scale = 1./4.;\n    st = uv-vec2(0.);\n    st *= draw_scale;\n    col = draw_line(Start,A,st,col);\n    col = draw_line(A,D,st,col);\n    col = draw_line(D,S,st,col);\n    col = draw_line(S,R,st,col);\n    \n    col = draw_point(Start,st,col);\n    col = draw_point(A,st,col);\n    col = draw_point(D,st,col);\n    col = draw_point(S,st,col);\n    col = draw_point(R,st,col);\n    \n    float time = iTime;//mod(iTime, 1.);\n    \n    //text rendering from oneshade\n    \n    //Render Word \"Attack\n  \n    vec2 word_start;\n    int word_attack_length = 6;\n    int word_attack[8];\n    vec2 letter_size = vec2(0.6);\n    \n    word_attack[0] = a;\n    word_attack[1] = t;\n    word_attack[2] = t;\n    word_attack[3] = a;\n    word_attack[4] = c;\n    word_attack[5] = k;\n    \n    word_start = A*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //Render Word Decay\n    word_attack_length = 5;\n    //word_attack[5];\n    \n    word_attack[0] = d;\n    word_attack[1] = e;\n    word_attack[2] = c;\n    word_attack[3] = a;\n    word_attack[4] = y;\n\n    \n    word_start = D*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n\n    //Render Word Sustain\n    word_attack_length = 5;\n    //word_attack[5];\n    \n    word_attack[0] = s;\n    word_attack[1] = u;\n    word_attack[2] = s;\n    word_attack[3] = t;\n    word_attack[4] = n;\n\n    \n    word_start = S*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //Render Word Sustain\n    word_attack_length = 7;\n    word_attack[7];\n    \n    word_attack[0] = r;\n    word_attack[1] = e;\n    word_attack[2] = l;\n    word_attack[3] = e;\n    word_attack[4] = a;\n    word_attack[5] = s;\n    word_attack[6] = e;\n    \n    \n    word_start = R*4.+vec2(0.5,0.);\n    \n    for(int i = 0; i < word_attack_length; i++){\n        drawChar(col, letterCol, uv, word_start, letter_size,\n        word_attack[i]);\n        word_start += vec2(0.25,0.);\n    }\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n\n// stereo sound output. x=left, y=right\nvec2 mainSound( in int samp, float time )\n{\n    \n    //ADSR Animation\n    vec2 Start = vec2(0.,0.);\n    vec2 A = vec2(0. + anim_Ax(time/2.), 1.);\n    vec2 D = vec2(0.4 + anim_Dx(time/2.), anim_Dy(time));\n    vec2 S = vec2(0.8 + anim_Sx(time/2.), anim_Sy(time));\n    vec2 R = vec2(1. + anim_Rx(time/2.), 0.);\n    \n    \n    float t = time;\n    time = mod(t, loop_length);\n\n    vec2 f = vec2(0.);\n    \n    f += adsrStab(time,freq_2,left_right,A,D,S,R);\n    f += adsrStab(time,freq_3,left_right,A,D,S,R);\n    f += adsrStab(time,freq_4,left_right,A,D,S,R);\n    f += adsrStab(time,freq_5,left_right,A,D,S,R);\n    \n    return f/16.;\n}", "sound_inputs": [], "common_code": "#define left_right vec2(1.,1.)\n//c5\n#define freq_1 523.25 \n//e5\n#define freq_2 659.25\n//g5\n#define freq_3 783.99\n//b5\n#define freq_4 987.77\n//d5\n#define freq_5 1174.66\n\n//kick \n#define c2 65.41\n\n//highest frequency in a kick's\n//frequency adsr will be c3\n#define kick_freq_max 130.81\n\n\n#define scale_x .005\n#define squareNum 10.\n#define pi acos(-1.)\n#define two_pi pi*2.\n//for square waves\n#define L 0.5 \n\n//for sequencing\n#define note_length 1.\n#define loop_length 1.\n\n#define basicA vec2(0.001, 1.)\n#define basicD vec2(0.4, 0.3)\n#define basicS vec2(0.8, 0.3)\n#define basicR vec2(1.5, 0.)\n\n#define snareA vec2(0.0002, 1.)\n#define snareD vec2(0.12, 0.09)\n#define snareS vec2(0.3, 0.09)\n#define snareR vec2(0.7, 0.)\n\n#define brushA vec2(0.05, 0.6)\n#define brushD vec2(0.2, 0.1)\n#define brushS vec2(0.22, 0.05)\n#define brushR vec2(0.5, 0.)\n\n#define hatA vec2(0.001, 1.)\n#define hatD vec2(0.02, 0.5)\n#define hatS vec2(0.02, 0.4)\n#define hatR vec2(0.1, 0.)\n\n#define kNoiseA vec2(0.0002, 1.)\n#define kNoiseD vec2(0.03, 0.1)\n#define kNoiseS vec2(0.05, 0.1)\n#define kNoiseR vec2(0.06, 0.)\n\n#define kick_A vec2(0.0002, 1.)\n#define kick_D vec2(0.2, 0.)\n#define kick_S vec2(0.22, 0.)\n#define kick_R vec2(0.22, 0.)\n\n//kick frequency adsr\n#define kick_fA vec2(0.001, 1.)\n#define kick_fD vec2(0.2, 0.0)\n#define kick_fS vec2(0.22, 0.0)\n#define kick_fR vec2(0.22, 0.)\n\n#define stab_A vec2(0.0002, 1.)\n#define stab_D vec2(0.2, 0.1)\n#define stab_S vec2(0.22, 0.071)\n#define stab_R vec2(0.92, 0.)\n\n#define anim_Start 0.\n#define anim_Ax(t) clamp(sin(t),0.,.2)\n#define anim_Dx(t) clamp(sin(t*0.8 + 3.),.2,.4)\n#define anim_Sx(t) clamp(sin(t*0.9+2.),0.4,.7)\n#define anim_Rx(t) clamp(sin(t*1.1 + 1.),0.7,1.)\n\n#define anim_Dy(t) clamp(cos(t*0.9 + 1.5),.2,.9)\n#define anim_Sy(t) clamp(cos(t*0.95 + 5.5),.0,.2)\n\n//a lerb between arbitrary start and end times\nfloat generic_lerp(float tStart, \n                   float tEnd, \n                   float t,\n                   float valA,\n                   float valB){\n            \n           //as tEnd-t goes to tEnd-tEnd\n           //we move to zero\n           //the only thing we need is 1 at the start\n           //and at the start the value is (tEnd-tStart)\n           //so let's use (tEnd-tStart)\n           \n    return (valA*(tEnd-t))/(tEnd-tStart)\n    \n           //t-tStart is 0 at start\n           // (t-tStart)/(tEnd-tStart)\n           //is both null at start and 1 at end\n           //becayse t-tStart will go to exactly\n           //that distance beyond where it is (0).\n           \n         + (valB*(t-tStart)/(tEnd-tStart));\n}\n\n//an adsr filter with linear functions for each component\nfloat naiveADSR(float t, vec2 A, vec2 D, vec2 S, vec2 R){\n\n    vec2 Start = vec2(0.);\n    \n    float adsr= 0.;\n    if(t < A.x) \n        adsr = generic_lerp(Start.x,A.x,t,Start.y,A.y);\n    \n    else if(t < D.x)\n        adsr = generic_lerp(A.x,D.x,t,A.y,D.y);\n    \n    else if(t < S.x)\n        adsr = generic_lerp(D.x,S.x,t,D.y,S.y);\n        \n    else if(t < R.x)\n        adsr = generic_lerp(S.x,R.x,t,S.y,R.y);\n       \n    else adsr = 0.;\n             \n    return adsr;\n}\n\n//all these functions are written for stereo\n//meaning you can adjust the volume per ear from the \n//input \"lr\"\nvec2 stereoNoise(float t, float freq, vec2 lr){\n    float f = fract(sin(freq*t*234.)*43153.);\n    //float adsr = naiveADSR(t,snareA,snareD,snareS,snareR);\n    float adsr = naiveADSR(t,kNoiseA,kNoiseD,kNoiseS,kNoiseR);\n    return vec2(f*lr)*adsr;\n}\n\nvec2 stereoSin(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,basicA,basicD,basicS,basicR);\n    return vec2(sin(freq*t*two_pi))*lr*adsr;\n}\n\nvec2 stereoStab(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,stab_A,stab_D,stab_S,stab_R);\n    return vec2(sin(freq*t*two_pi*0.5))*lr*adsr;\n}\n\nvec2 adsrStab(float t, float freq, vec2 lr,\n              vec2 A, vec2 D, vec2 S, vec2 R){\n               \n    float adsr = naiveADSR(t, A, D, S, R);\n    return vec2(sin(freq*t*two_pi*0.5))*lr*adsr;\n}\n\nvec2 stereoKick(float t, float freq, vec2 lr){\n    float adsr = naiveADSR(t,kick_A,kick_D,kick_S,kick_R);\n    float freq_adsr = naiveADSR(t,kick_fA,kick_fD,kick_fS,kick_fR);\n    freq = (freq+freq_adsr*kick_freq_max)*0.6;\n    return vec2(sin(freq*t*two_pi))*lr*adsr;\n}\n\n//letters and numbers from oneshade\n\nconst int SPACE = 32;\nconst int Exclame = 33;\nconst int DOUBLE_QUOTE = 34;\nconst int HASHTAG = 35;\nconst int DOLLAR = 36;\nconst int PERCENT = 37;\nconst int AMPERSAND = 38;\nconst int SINGLE_QUOTE = 39;\nconst int OPEN_PARENTHESIS = 40;\nconst int CLOSE_PARENTHESIS = 41;\nconst int ASTERISK = 42;\nconst int PLUS = 43;\nconst int COMMA = 44;\nconst int HYPHEN = 45;\nconst int PERIOD = 46;\nconst int SLASH = 47;\nconst int ZERO = 48;\nconst int ONE = 49;\nconst int TWO = 50;\nconst int THREE = 51;\nconst int FOUR = 52;\nconst int FIVE = 53;\nconst int SIX = 54;\nconst int SEVEN = 55;\nconst int EIGHT = 56;\nconst int NINE = 57;\nconst int COLON = 58;\nconst int SEMICOLON = 59;\nconst int LESS_THAN = 60;\nconst int EQUAL = 61;\nconst int GREATER_THAN = 62;\nconst int QUESTION = 63;\nconst int AT = 64;\n\nconst int OPEN_BRACKET = 91;\nconst int BACKSLASH = 92;\nconst int CLOSE_BRACKET = 93;\nconst int CIRCUMFLEX = 94;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\nconst int OPEN_BRACE = 123;\nconst int PIPE = 124;\nconst int CLOSE_BRACE = 125;\nconst int TILDE = 126;", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 332, 332, 534], [536, 536, 586, 586, 682], [684, 684, 731, 731, 859], [861, 956, 1059, 1059, 1351], [1352, 1352, 1409, 1461, 5342]], "test": "untested"}
{"id": "NsyGzt", "name": "- swallow -", "author": "anahit_movsesyan", "description": "Wanted to create something like this :octopus:\nhttps://33.media.tumblr.com/416c868980813011c098e56e8e81f28a/tumblr_nff3dhnTrO1qz6f9yo1_r2_500.gif", "tags": ["sdf", "bird", "walls", "swallow"], "likes": 12, "viewed": 383, "published": 3, "date": "1631912893", "time_retrieved": "2024-07-30T19:00:46.993616", "image_code": "#define PI 3.1415\n\nvec2 rotate(vec2 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -log2(exp2(-k * a) + exp2(-k * b)) / k;\n}\n\nfloat sdfFw(float d) {\n    return smoothstep(0., fwidth(d) * 1.5 * 720. / iResolution.y, d);\n}\n\nfloat sdf(float d) {\n    return smoothstep(0., .002 * 720. / iResolution.y, d);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat sdWing(vec2 q) {\n    q = rotate(q, ((sin(iTime * 15.) + 0.5) / 3.5) + PI / 1.85);\n    q.x -= sin(q.y * 22. + 1.5) * 0.01 + sin(q.y * 25. + iTime * 15.) * 0.004;\n    return sdLine(q, vec2(0., -0.45), vec2(0)) - 0.05 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdTail(vec2 q) {\n    float f = 5. * smoothstep(0.8, -1.9, 2. * sin(iTime*1.5));\n    q = rotate(q, f / 60. + PI / 2.25);\n    q.x -= sin(q.y * 7. + 1.) * 0.005 + sin(q.y * 15.) * 0.003;\n    return sdLine(q, vec2(0., -0.35), vec2(0)) - 0.035 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdHead(vec2 p) {\n    float d, d1;\n    \n    // head\n    vec2 q = p - vec2(0.17, -0.045);\n    d = sdCircle(q, 0.045);\n    \n    q = p - vec2(0.205, -0.0415);\n    d1 = sdCircle(q, 0.03);\n    d = smoothMin(d, d1, 180.);\n    \n    // nose\n    q = p - vec2(0.2125, -0.055);\n    q = rotate(q, -PI / 3.5);\n    q.x -= sin(q.y * 0.01 + 1.) * 0.005 + sin(q.y * 0.01) * 0.005;\n    d1 = sdLine(q, vec2(0., -0.03), vec2(0)) - 0.0175 * smoothstep(-0.03, 0., q.y);\n    d = min(d, d1);\n    \n    // eye\n    q = p - vec2(0.21, -0.05);\n    d1 = sdCircle(q, 0.008);\n    d = max(d, -d1);\n    \n    return d;\n}\n    \nfloat sdBird(vec2 p) {\n    float d = sdHead(p);\n    \n    // tail\n    vec2 q = p - vec2(0.08, -0.045);\n    float d1 = sdTail(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.08, -0.05);\n    q.y *= -1.;\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    // wings\n    q = p - vec2(0.105, -0.015);\n    d1 = sdWing(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.105, -0.075);\n    q.y *= -1.;\n    d1 = sdWing(q);\n    d = min(d, d1);\n\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/ max(iResolution.x, iResolution.y);\n    uv.y += sin(iTime * 1.55) / 5.;\n    \n    float signF = (step(fract(iTime / 3.) * 2. - 1., 0.) * 2. - 1.);\n    float bla = signF * (uv.x / 3. + fract(iTime / 1.5) * 2. - 1.);\n   \n    uv = rotate(uv, sin(iTime * 1.55 + PI / 3.5) / 7.);       \n    \n    float fd = mix(1. - sdfFw(smoothMin(sdCircle(uv, 0.06), -bla, 8.)),\n                   sdf(smoothMin(sdBird(uv * 1.1), 1., 8.)),\n                   sdfFw(bla));\n    \n    fd = mix(fd, sdf(smoothMin(sdHead(uv * 1.1), bla + .001, 18.)), fd * sdfFw(bla));\n    \n    vec3 c = vec3(sin(iTime / 5.) * 0.5 + 0.5, 0.8, 0.2);\n    fragColor = vec4((fd + 0.2) * (hsv2rgb(c) + 0.6), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 53, 53, 141], [143, 143, 187, 187, 240], [242, 242, 264, 264, 336], [338, 338, 358, 358, 419], [421, 421, 454, 454, 482], [484, 484, 521, 521, 653], [655, 655, 677, 677, 907], [909, 909, 931, 931, 1185], [1187, 1187, 1209, 1209, 1777], [1783, 1783, 1805, 1805, 2224], [2226, 2226, 2248, 2248, 2372], [2374, 2374, 2429, 2429, 3143]], "test": "untested"}
{"id": "Ndy3zt", "name": "Random Squares Transition", "author": "turboplay", "description": "Converted from gl-transitions", "tags": ["square", "transition"], "likes": 5, "viewed": 431, "published": 3, "date": "1631909442", "time_retrieved": "2024-07-30T19:00:47.771536", "image_code": "\n// https://gl-transitions.com/editor/randomsquares\n// Easy and nice\n\nvec2 size = vec2(10,10);\nfloat smoothness = 0.5; // 0-1\n \nfloat rand (vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   float r = rand(floor(vec2(size) * uv));\n   float j;\n   float m = smoothstep(0.0, -smoothness, r - (modf(iTime/2.,j) * (1.0 + smoothness)));\n   fragColor=  mix(texture(iChannel0,uv), texture(iChannel1,uv), m);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 150, 150, 220], [223, 223, 280, 280, 533]], "test": "untested"}
{"id": "fdy3zt", "name": "Waving Flag of Neutrality", "author": "zovox", "description": "Waving Flag of Neutrality", "tags": ["wavingflagofneutrality"], "likes": 1, "viewed": 194, "published": 3, "date": "1631908794", "time_retrieved": "2024-07-30T19:00:48.546464", "image_code": "#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy*2.0-1.0)*GR;\n    \n    //uv.xy += sin(length(uv.xy+PI)*E*GR+iTime)/PI/GR/E;\n\n    float outline = (abs(uv.x) > 1. || abs(uv.y) > 1.) ? 0. : 1.;\n\n    float magnitude;\n\n    if(uv.y > 0.) {\n        if(uv.x > 0.)\n            magnitude = 1.0-iTime;\n        else\n            magnitude = iTime;\n    }\n    else\n        magnitude = uv.x * .5 + .5+iTime;\n\n    magnitude = saw(magnitude)*outline;\n\n    // Output to screen\n    fragColor = vec4(vec3(magnitude)+(.5)*(1.-outline),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 167, 167, 272], [274, 274, 292, 292, 327], [328, 328, 346, 346, 391], [392, 392, 410, 410, 465], [467, 467, 524, 574, 1086]], "test": "untested"}
{"id": "Nl2SRc", "name": "Lovely Bubbles", "author": "P_Malin", "description": "Some lovely shadertoy bubbles.\nI've wanted to implement something with thin film interference for a while.", "tags": ["bubbles"], "likes": 54, "viewed": 1255, "published": 3, "date": "1631906278", "time_retrieved": "2024-07-30T19:00:49.499915", "image_code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.5;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos, out float index)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    index = -1.0f;\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         if ( d < minD )\n         {\n             minD = d;\n             index = p;\n         }\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n\n    float index;\n\n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz, index );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side, out float index )\n{\n\tfloat t = minDist;\n\n    index = -1.0;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n        float currIndex;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t, currIndex ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n            index = currIndex;\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n    vec3 envMap = texture(iChannel1, dir).rgb;\n    envMap = envMap * envMap;\n    float kEnvmapExposure = 0.99999;\n    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.0f - (1.0f - fresnelA) * (1.0f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif    \n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.5, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir, out float firstIndex )\n{    \n    float kFarClip = 200.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = 1.0;\n    \n    float minDist = 0.0;\n    \n    firstIndex = -1.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float currIndex;\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side, currIndex );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        if ( i == 0)\n        {\n            firstIndex = currIndex;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n    colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n    float firstIndex;\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir, firstIndex );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n    \n    //final = texture( iChannel0, fragCoord.xy/iResolution.xy).rgb;\n\t\n    //final = sin(firstIndex * vec3(1,2,3))*.5+.5;\n    \n\tfragColor = vec4(final, 1.0);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if USE_THIN_FILM_LOOKUP\n    {\n        int segmentCount = 32;\n        int segment = iFrame % segmentCount;\n        int currSegment = int(floor((fragCoord.y * float(segmentCount) / iResolution.y)));\n        \n        if ( segment != currSegment )\n        {\n            fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            return;\n        }\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec3 result = GetThinFilmColour(uv.x, uv.y);  \n\n    fragColor = vec4(result,1.0);\n#else\n    discard;\n#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 1\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\n#if 1\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}\n\n#else\n\n// The Technical Art of The Last of Us Part II by Waylon Brinck and Steven Tang || SIGGRAPH 2020\n// https://youtu.be/tvBIqPHaExQ?t=2873\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(1.0);\n\n    vec3 rgbLightWavelength = vec3(700,510,440);\n    float extraDistance = thickness / cosi;\n    vec3 phaseChangeEquivalentShift = vec3(0);\n    \n    bool doublePhase = true;\n    \n    if ( !doublePhase )\n    {\n        phaseChangeEquivalentShift = -rgbLightWavelength * .5;\n    }\n    \n    vec3 phaseOffset = vec3(extraDistance - phaseChangeEquivalentShift) / rgbLightWavelength;\n    vec3 superpositionAmplitude = abs(cos(phaseOffset * PI));\n    \n    float coherenceTerm = 1.0 - clamp( extraDistance * 1.0 / 1500., 0., 1. );\n    \n    superpositionAmplitude = mix( vec3(1.0), superpositionAmplitude, coherenceTerm);\n\n    float filmStrength = 2.0;\n    float filmStrengthTerm = filmStrength * cosi;\n\n    result = mix( result, superpositionAmplitude, filmStrengthTerm );\n\n    //result = superpositionAmplitude;\n\n    return result;\n}\n\n#endif", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 235, 235, 330], [332, 332, 415, 415, 684], [698, 698, 737, 737, 946], [948, 948, 985, 985, 1228], [1230, 1230, 1265, 1265, 1340], [1342, 1342, 1381, 1381, 1566], [1601, 1601, 1639, 1639, 1751], [1753, 1753, 1791, 1791, 1919], [1921, 1921, 1970, 1970, 3129], [3131, 3131, 3165, 3165, 3489], [3495, 3495, 3604, 3604, 4124], [4126, 4126, 4157, 4157, 4374], [4376, 4376, 4409, 4409, 4454], [4456, 4456, 4547, 4547, 6158], [6161, 6161, 6235, 6235, 7049], [7051, 7051, 7108, 7108, 7948]], "test": "untested"}
{"id": "7dy3Rc", "name": "Merging Spheres", "author": "personalizedrefrigerator", "description": "Click and drag the spheres!\n\nThe spheres should blend together on collision. Inspired by https://www.shadertoy.com/view/tscBz8.", "tags": ["raymarching", "mouse", "spheres", "smoothunion", "draggable"], "likes": 9, "viewed": 359, "published": 3, "date": "1631899024", "time_retrieved": "2024-07-30T19:00:50.552102", "image_code": "// MIT Licensed\n\n// Lower BLEND_K => More blending\n#define BLEND_K 0.6\n\n// Adjust number of spheres and lights in COMMON.\n\n#define SCENE_NEAR 0.3\n#define SCENE_FAR 1000.0\n#define SCENE_MIN_STEP 0.1\n\nstruct Scene\n{\n    Light[NUM_LIGHTS] lights;\n    Sphere[NUM_SPHERES] spheres;\n    \n    float near;\n    float far;\n    float min_step_size;\n};\n\nMarchResult Scene_map(in Scene scene, vec3 p)\n{\n    float res_dist = scene.far;\n    Material res_material = Material_new();\n    \n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        float dist = Sphere_sdf(scene.spheres[i], p);\n        float blend_factor = sigmoid(-BLEND_K * (dist - res_dist));\n        \n        res_material = Material_blend(scene.spheres[i].material, res_material, blend_factor);\n        res_dist = dist * blend_factor + res_dist * (1.0 - blend_factor);\n    }\n    \n    return MarchResult(res_dist, res_material);\n}\n\n// Define normal and march functions for the scene. Note that the high quality march\n// has a maximum of 100 raymarching steps.\nDEFINE_SCENE_NORMAL(Scene, Scene_normal, Scene_map)\nDEFINE_SCENE_MARCH(Scene, Scene_marchHighQuality, Scene_map, 100)\nDEFINE_SCENE_MARCH(Scene, Scene_marchLowQuality, Scene_map, 10)\n\n/// Build the scene and cast a ray.\nvec3 get_color(in Ray camera)\n{\n    Material red_material = Material_new(vec3(1.0, 0.0, 0.0), 5000.0);\n    Material white_material = Material_new();\n    Material blue_material = Material_new(vec3(0.0, 1.0, 1.0), 50.0);\n    Material green_material = Material_new(vec3(0.0, 1.0, 0.6), 200.0);\n    Material purple_material = Material_new(vec3(1.0, 0.0, 1.0), 6.0);\n    \n    Scene scene = Scene\n    (\n        Light[NUM_LIGHTS]\n        (\n            Light_new(vec3(0.0, 0.1, -0.1))\n        ),\n        Sphere[NUM_SPHERES]\n        (\n            SPHERE_NEW_FROM_IDX(0, red_material),\n            SPHERE_NEW_FROM_IDX(1, white_material),\n            SPHERE_NEW_FROM_IDX(2, blue_material),\n            SPHERE_NEW_FROM_IDX(3, green_material),\n            SPHERE_NEW_FROM_IDX(4, purple_material)\n        ),\n        \n        SCENE_NEAR,\n        SCENE_FAR,\n        SCENE_MIN_STEP\n    );\n    \n    MarchResult hit = Scene_marchHighQuality(scene, camera);\n    \n    if (hit.dist >= scene.far)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 hit_pos = Ray_at(camera, hit.dist);\n    \n    Ray normal = Scene_normal(scene, hit_pos);\n    vec3 result = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        vec3 current = vec3(0.0);\n        Light_apply(scene.lights[i], hit.material, normal, camera, scene, Scene_marchLowQuality, current);\n        result += current;\n    }\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = screen_to_world(fragCoord.xy, iResolution.xy);\n\n    // Time varying pixel color\n    vec3 col = get_color(Ray_new(vec3(0.0), vec3(uv, 1.0)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MIT Licensed\n\n\n/// Scene settings\n\n#define NUM_LIGHTS 1\n#define NUM_SPHERES 5\n\nfloat get_sphere_radius(int idx)\n{\n    return idx < 2 ? 5.0 : (2.0 + sin(float(idx)) / 4.0);\n}\n\n/// Get the DEFAULT position of a sphere given the current time.\n/// If the user interacts with the sphere, the sphere's position/velocity\n/// are no longer their defaults.\nvec3 get_sphere_default_position(int idx, float time)\n{\n    if (idx == 1)\n    {\n        return vec3(0.0, sin(time / 2.0) * 12.0, 50.0);\n    }\n    else if (idx == 2)\n    {\n        return vec3(sin(time / 2.0) * cos(time / 3.0) * 10.0, cos(time / 2.0) * 20.0, 50.0);\n    }\n    \n    return vec3(0.0, 0.0, 50.0);\n}\n\n///////\n\nconst float SMALL = 0.01;\n\nfloat sigmoid(float t)\n{\n    return 1.0 / (1.0 + exp(-t));\n}\n\n\nstruct Material\n{\n    vec3 color;\n    float specular_power;\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    \n    // Invariant: ||direction|| = 1\n};\n\nstruct MarchResult\n{\n    float dist;\n    Material material;\n};\n\n/// [typeName:\n///   {\n///     float min_step_size;\n///     float near;\n///     float far;\n///   }\n/// ] the scene.\n/// [marchName] the name of the function.\n/// [marchMaxSteps] maximum number of raymarching steps.\n#define DEFINE_SCENE_MARCH(typeName, fnName, mapFnName, marchMaxSteps) \\\nMarchResult fnName(in typeName scene, Ray r)\\\n{\\\n    float dist = scene.near;\\\n    for (int i = 0; i < marchMaxSteps; i++)\\\n    {\\\n        vec3 pt = Ray_at(r, dist);\\\n        MarchResult current = mapFnName(scene, pt);\\\n        dist += current.dist;\\\n        \\\n        if (abs(current.dist) < scene.min_step_size)\\\n        {\\\n            return MarchResult(dist, current.material);\\\n        }\\\n        else if (dist > scene.far)\\\n        {\\\n            return MarchResult(dist, Material_new());\\\n        }\\\n    }\\\n    \\\n    return MarchResult(scene.far, Material_new());\\\n}\\\n\n/// [typeName] The type of the scene.\n/// [fnName] The name of the function to generate\n/// [mapFnName] The name of the map function to use.\n#define DEFINE_SCENE_NORMAL(typeName, fnName, mapFnName) \\\nRay fnName(in typeName scene, vec3 p) \\\n{\\\n    float dist = ( mapFnName(scene, p) ).dist;\\\n    float withdel_x = ( mapFnName(scene, p + vec3(SMALL, 0.0, 0.0)) ).dist;\\\n    float withdel_y = ( mapFnName(scene, p + vec3(0.0, SMALL, 0.0)) ).dist;\\\n    float withdel_z = ( mapFnName(scene, p + vec3(0.0, 0.0, SMALL)) ).dist;\\\n    \\\n    vec3 direction = vec3\\\n    (\\\n        withdel_x - dist,\\\n        withdel_y - dist,\\\n        withdel_z - dist\\\n    ) / SMALL;\\\n    \\\n    return Ray_new(p, direction);\\\n}\n\n\n\n/// Material\n\n/// -> Empty material\nMaterial Material_new()\n{\n    return Material(vec3(1.0), 500.0);\n}\n\nMaterial Material_new(vec3 color, float specular_power)\n{\n    return Material(color, specular_power);\n}\n\nvec3 Material_getColor(in Material m, in Light light, float brightness, float specular)\n{\n    return m.color * light.color * (brightness + pow(specular, m.specular_power));\n}\n\nMaterial Material_blend(in Material a, in Material b, float factor)\n{\n    return Material\n    (\n        a.color * factor + b.color * (1.0 - factor), \n        a.specular_power * factor + b.specular_power * (1.0 - factor)\n    );\n}\n\n/// Sphere\n\nSphere Sphere_new(in vec3 origin, float radius, in Material material)\n{\n    return Sphere(origin, radius, material);\n}\n\nSphere Sphere_new(in vec3 origin, float radius)\n{\n    return Sphere_new(origin, radius, Material_new());\n}\n\n#define SPHERE_DATA_OFFSET(idx) BALL_DATA_START_IDX + idx * BALL_DATA_SIZE\n#define SPHERE_NEW_FROM_IDX(idx, material) \\\n    Sphere_new\\\n    (\\\n        get_data\\\n        (\\\n            iChannel0,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_X_OFFSET,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_Y_OFFSET,\\\n            SPHERE_DATA_OFFSET(idx) + BALL_POSITION_Z_OFFSET\\\n        ), \\\n        get_sphere_radius(idx),\\\n        material\\\n    )\n\nfloat Sphere_sdf(in Sphere s, in vec3 p)\n{\n    return length(p - s.center) - s.radius;\n}\n\n/// Ray\n\nRay Ray_new(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\nvec3 Ray_at(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\n/// Light\n\nLight Light_new(vec3 position, vec3 color, float intensity)\n{\n    return Light(position, normalize(color), intensity);\n}\n\nLight Light_new(vec3 position)\n{\n    return Light_new(position, vec3(1.0), 10.0);\n}\n\n/// Get the light's color contribution to a scene.\n/// [Light light]\n/// [Material material_in]\n/// [Ray normal]\n/// [vec3 camera]\n/// [Scene scene]\n/// [fn(Scene, Ray)→float march]\n/// [OUT vec3 out_color]\n#define Light_apply(light_in, material_in, normal_in, camera_in, scene_in, march_in, color_out) \\\n{\\\n    vec3 point = normal_in.origin;\\\n    vec3 norm = normal_in.direction;\\\n    vec3 to_light_hat = normalize(light_in.position - point);\\\n    float to_light_len = length(light_in.position - point);\\\n    \\\n    vec3 to_camera_hat = normalize(camera_in.origin - point);\\\n    \\\n    vec3 half_vec = normalize(to_light_hat + to_camera_hat);\\\n    float to_light_through_scene = march_in(scene_in, Ray(point, to_light_hat)).dist;\\\n    \\\n    float brightness = max(0.0, dot(to_light_hat, norm));\\\n    float specular = max(dot(half_vec, norm), 0.0);\\\n    \\\n    /* Shadows */\\\n    if (to_light_through_scene < to_light_len * 0.9)\\\n    {\\\n        brightness *= 0.3;\\\n        specular = 0.0;\\\n    }\\\n    \\\n    color_out = Material_getColor(material_in, light_in, brightness, specular); \\\n}\\\n\n\n/// Convert screen (0, resolution_x) x (0, resolution_y) to world coordinates.\nvec2 screen_to_world(vec2 p, vec2 resolution)\n{\n    return (p/resolution.xy - 0.5) * resolution.xy / max(resolution.x, resolution.y);\n}\n\n\n\n/// Fetching data\n\nconst int LAST_TIME_ID = 0;\nconst int LAST_MOUSE_POSITION_X_ID = 1;\nconst int LAST_MOUSE_POSITION_Y_ID = 2;\nconst int CURRENT_MOUSE_POSITION_X_ID = 3;\nconst int CURRENT_MOUSE_POSITION_Y_ID = 4;\nconst int CURRENT_MOUSE_DOWN_ID = 5;\nconst int LAST_MOUSE_DOWN_ID = 6;\nconst int BALL_TARGET_ID = 7;\nconst int BALL_DATA_START_IDX = 8;\n\nconst int BALL_POSITION_X_OFFSET = 0;\nconst int BALL_POSITION_Y_OFFSET = 1;\nconst int BALL_POSITION_Z_OFFSET = 2;\nconst int BALL_VELOCITY_X_OFFSET = 3;\nconst int BALL_VELOCITY_Y_OFFSET = 4;\nconst int BALL_DETATCH_FROM_DEFAULT_OFFSET = 5;\nconst int BALL_DATA_SIZE = 6;\n\nconst int NUM_DATA_IDS = 8 + BALL_DATA_SIZE * NUM_SPHERES;\n\nvec4 encode_float(float f)\n{\n    float sign_encode = f < 0.0 ? 0.5 : 1.0;\n    \n    f = abs(f);\n    float high = min(f / 256.0, 1.0);\n    float med = min(f * 256.0, 1.0);\n    float low = min(f, 1.0);\n    \n    return vec4(high, med, low, sign_encode);\n}\n\nfloat decode_float(vec4 d)\n{\n    float high = 0.0;\n    float med = 0.0;\n    float low = 0.0;\n    int count = 0;\n    \n    // Assuming 1 byte per channel.\n    float mx = 254.0 / 256.0;\n    \n    if (d.x < mx)\n    {\n        high = d.x * 256.0;\n        count++;\n    }\n    \n    if (d.y < mx)\n    {\n        med = d.y / 256.0;\n        count++;\n    }\n    \n    if (d.z < mx)\n    {\n        low = d.z;\n        count++;\n    }\n    \n    if (count == 0)\n    {\n        return 0.0;\n    }\n    \n    float sgn = d.w < 0.8 ? -1.0 : 1.0;\n    return sgn * (high + med + low) / float(count);\n}\n\nfloat get_data(sampler2D tex, int data_id)\n{\n    float bar_width = 1.0 / float(NUM_DATA_IDS);\n    \n    vec2 coord = vec2(float(data_id) + 0.5, 0.0) * bar_width;\n    \n    \n    vec4 tex_val = texture(tex, coord);\n    return decode_float(tex_val);\n}\n\nvec2 get_data(sampler2D tex, int data_x_id, int data_y_id)\n{\n    return vec2(get_data(tex, data_x_id), get_data(tex, data_y_id));\n}\n\nvec3 get_data(sampler2D tex, int data_x_id, int data_y_id, int data_z_id)\n{\n    return vec3(get_data(tex, data_x_id), get_data(tex, data_y_id), get_data(tex, data_z_id));\n}\n", "buffer_a_code": "\n/// Handles movement of the purple ball.\n\n#define LEFT_BOUND -0.5\n#define RIGHT_BOUND 0.5\n#define BOTTOM_BOUND -0.5\n#define TOP_BOUND 0.5\n\n// Multiplies the velocity by this every frame for some slowdown/\n// simulates friction.\n#define VELOCITY_SUSTAIN 0.999\n\n\nvoid handle_edge_bouncing(inout vec3 velocity, inout vec3 position, in vec2 bound_scaling)\n{\n    float left_bound = LEFT_BOUND * bound_scaling.x;\n    float right_bound = RIGHT_BOUND * bound_scaling.x;\n    float top_bound = TOP_BOUND * bound_scaling.y;\n    float bottom_bound = BOTTOM_BOUND * bound_scaling.y;\n    \n    if (position.x < left_bound)\n    {\n        velocity.x = abs(velocity.x);\n        position.x = left_bound;\n    }\n\n    if (position.x > right_bound)\n    {\n        velocity.x = -abs(velocity.x);\n        position.x = right_bound;\n    }\n    \n    if (position.y < bottom_bound)\n    {\n        velocity.y = abs(velocity.y);\n        position.y = bottom_bound;\n    }\n    \n    if (position.y > top_bound)\n    {\n        velocity.y = -abs(velocity.y);\n        position.y = top_bound;\n    }\n    \n    velocity.z = 0.0;\n}\n\n\n/// Returns true iff the current cell should store data for [data_id]\nbool is_data_cell(vec2 coord, int data_id)\n{\n    return int(floor(coord.x)) == data_id;\n}\n\n/// [key] Integer key to check for\n/// [value] to write out if [key] matches the current output location.\n#define SAVE_FLOAT_PROP(key, value)\\\nif (is_data_cell(uv, key))\\\n{\\\n    fragColor = encode_float(value);\\\n}\\\n\n#define INT_TO_WORLD_SCALE 50.0\n#define DATA_TX iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy * float(NUM_DATA_IDS) / iResolution.x;\n\n    vec2 next_mouse_position = screen_to_world(iMouse.xy, iResolution.xy);\n    vec2 current_mouse_position = get_data(DATA_TX, CURRENT_MOUSE_POSITION_X_ID, CURRENT_MOUSE_POSITION_Y_ID);\n    vec2 last_mouse_position = get_data(DATA_TX, LAST_MOUSE_POSITION_X_ID, LAST_MOUSE_POSITION_Y_ID);\n    \n    float current_mouse_down = get_data(DATA_TX, CURRENT_MOUSE_DOWN_ID);\n    float last_mouse_down = get_data(DATA_TX, LAST_MOUSE_DOWN_ID);\n    float next_mouse_down = iMouse.z > 0.0 ? 1.0 : 0.0;\n    \n    int ball_target_id = int(get_data(DATA_TX, BALL_TARGET_ID));\n    float last_time = get_data(DATA_TX, LAST_TIME_ID);\n    float current_time = iTime;\n    float dt = iTime - last_time;\n    \n    float max_res_dimen = max(iResolution.x, iResolution.y);\n    \n    \n    // Check for mouse intersection\n    \n    int intersects_id = -1;\n    \n    for (int ball_idx = 0; ball_idx < NUM_SPHERES; ball_idx++)\n    {\n        // Index offset.\n        int offset = BALL_DATA_START_IDX + ball_idx * BALL_DATA_SIZE;\n        \n        vec3 ball_position = get_data(DATA_TX, offset + BALL_POSITION_X_OFFSET, offset + BALL_POSITION_Y_OFFSET, offset + BALL_POSITION_Z_OFFSET);\n        float ball_radius = get_sphere_radius(ball_idx);\n        \n        ball_position /= INT_TO_WORLD_SCALE;\n        ball_radius /= INT_TO_WORLD_SCALE;\n        \n        // Check for mouse collision\n        bool mouse_in_ball = length(ball_position.xy - current_mouse_position) <= ball_radius;\n        \n        if (mouse_in_ball)\n        {\n            // Note that we're focusing on the current ball only if:\n            //    - We're not focusing on other balls (lower index than other balls to check)\n            // or - The current ball was targeted in previous updates.\n            if (ball_target_id == -1 || intersects_id == -1)\n            {\n                intersects_id = ball_idx;\n            }\n        }\n    }\n    \n    if (intersects_id != -1 && intersects_id != ball_target_id)\n    {\n        ball_target_id = intersects_id;\n    }\n    \n    // Default frag color, should we output nothing for this pixel.\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    // Update each ball.\n    for (int ball_idx = 0; ball_idx < NUM_SPHERES; ball_idx++)\n    {\\\n        int i = BALL_DATA_START_IDX + ball_idx * BALL_DATA_SIZE;\n    \n        vec3 ball_velocity = vec3(get_data(DATA_TX, i + BALL_VELOCITY_X_OFFSET, i + BALL_VELOCITY_Y_OFFSET), 0.0);\n        vec3 ball_position = get_data(DATA_TX, i + BALL_POSITION_X_OFFSET, i + BALL_POSITION_Y_OFFSET, i + BALL_POSITION_Z_OFFSET);\n        \n        ball_velocity /= INT_TO_WORLD_SCALE;\n        ball_position /= INT_TO_WORLD_SCALE;\n        \n        float detatched = get_data(iChannel0, i + BALL_DETATCH_FROM_DEFAULT_OFFSET);\n        \n        // If not under the control of the user/physics,\n        if (detatched < 0.5)\n        {\n            vec3 default_pos = get_sphere_default_position(ball_idx, iTime) / INT_TO_WORLD_SCALE;\n            ball_position = default_pos;\n        }\n        else\n        {\n            // Otherwise, we're using the ball's velocity/user interaction to update things.\n            \n            ball_velocity *= VELOCITY_SUSTAIN;\n\n            handle_edge_bouncing(ball_velocity, ball_position, iResolution.xy / max_res_dimen);\n            ball_position += ball_velocity * dt;\n        }\n        \n        bool mouse_in_ball = intersects_id == ball_idx;\n        \n        if (mouse_in_ball)\n        {\n            ball_target_id = ball_idx;\n        }\n\n        // Have we been clicked on?\n        if (current_mouse_down > 0.0 && ball_target_id == ball_idx)\n        {\n            // We're now controlled by physics!\n            detatched = 1.0;\n            \n            if (last_mouse_down < 1.0 && mouse_in_ball)\n            {\n                ball_position = vec3(current_mouse_position, ball_position.z);\n            }\n            else\n            {\n                ball_velocity *= 0.7;\n                ball_velocity += vec3(current_mouse_position - ball_position.xy, 0.0) / dt / 40.0;\n            }\n        }\n        \n        // Re-scale for saving.\n        ball_position *= INT_TO_WORLD_SCALE;\n        ball_velocity *= INT_TO_WORLD_SCALE;\n    \n        SAVE_FLOAT_PROP(i + BALL_POSITION_X_OFFSET, ball_position.x);\n        SAVE_FLOAT_PROP(i + BALL_POSITION_Y_OFFSET, ball_position.y);\n        SAVE_FLOAT_PROP(i + BALL_POSITION_Z_OFFSET, ball_position.z);\n        SAVE_FLOAT_PROP(i + BALL_VELOCITY_X_OFFSET, ball_velocity.x);\n        SAVE_FLOAT_PROP(i + BALL_VELOCITY_Y_OFFSET, ball_velocity.y);\n        SAVE_FLOAT_PROP(i + BALL_DETATCH_FROM_DEFAULT_OFFSET, detatched);\n    }\n    \n    \n    SAVE_FLOAT_PROP(LAST_TIME_ID, current_time);\n    SAVE_FLOAT_PROP(BALL_TARGET_ID, float(ball_target_id));\n    SAVE_FLOAT_PROP(LAST_MOUSE_POSITION_X_ID, current_mouse_position.x);\n    SAVE_FLOAT_PROP(LAST_MOUSE_POSITION_Y_ID, current_mouse_position.y);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_POSITION_X_ID, next_mouse_position.x);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_POSITION_Y_ID, next_mouse_position.y);\n    SAVE_FLOAT_PROP(CURRENT_MOUSE_DOWN_ID, next_mouse_down);\n    SAVE_FLOAT_PROP(LAST_MOUSE_DOWN_ID, current_mouse_down);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3Rc.jpg", "access": "api", "license": "mit", "functions": [[342, 342, 389, 389, 878], [1227, 1227, 1258, 1258, 2631], [2634, 2634, 2691, 2741, 2955]], "test": "untested"}
{"id": "sdyGR3", "name": "Spectral glass", "author": "NLIBS", "description": "Glass shader that integrates over wavelengths of light in visible spectrum instead of just r,g,b. \nAlso accounts for 3 light ray bounces\n\nMove around with the mouse", "tags": ["reflection", "refraction", "cubemap", "glass", "spectral"], "likes": 26, "viewed": 744, "published": 3, "date": "1631889690", "time_retrieved": "2024-07-30T19:00:51.335009", "image_code": "//21/09/20 : Fixed the spectrum function.\n\n#define exposure 1.\n#define DISPLAY_GAMMA 2.2\n#define DISPERSION 8.\n#define SAMPLES 8\nconst float N_AIR = 1.0;\n\nconst vec3 GLASS_COL = vec3(0.9);\n//const vec3 GLASS_COL = vec3(0.9,0.5,0.2);\n//const vec3 GLASS_COL = vec3(0.99,0.61,0.5);\nconst vec3 GLASS_REF = pow(GLASS_COL,vec3(0.6));\n\n//Minimal sphere raytrace\nfloat trace(vec3 rd, vec3 ro) {\n    float r = (sin(iTime/1.5)*0.5+0.5)*0.6+0.4;\n    float x0 = max(dot(-ro,rd),0.);\n    vec3 a = x0*rd+ro;\n    float b = dot(a,a);\n    float c = sqrt(r*r-b);\n    return (x0-c*sign(x0-c))*step(b,r*r);\n}\n\nfloat get_fresnel(vec3 rd, vec3 n, float n1, float n2){\n    float cosI = abs(dot(rd, n));\n    float cosR = n1/n2 * sqrt(1.-cosI*cosI);\n    if(cosR > 1.0) return 1.0; // total internal reflection\n    cosR = sqrt(1.0 - cosR * cosR);\n    float Rs = (n1*cosI - n2*cosR)/(n1*cosI + n2*cosR);\n    float Rp = (n1*cosR - n2*cosI)/(n1*cosR + n2*cosI);\n    return (Rs*Rs+Rp*Rp)*0.5;\n}\n\nvec3 _sample(vec3 rd) {\n\tvec3 col = texture(iChannel0,rd).rgb;\n    col = pow(col*1.3,vec3(DISPLAY_GAMMA+3.5));\n    col *= mix(vec3(0.1,0.3,0.9),vec3(0.9,0.27,0.08),rd.x*0.5+0.5);\n    //col *= mix(vec3(0.1,0.9,0.3),vec3(1.,.5,.2),rd.z*0.5+0.5);\n    return col;\n}\n\n//Cauchy's equation\nfloat get_n_glass(float lambda, float disp)\n{\n    lambda *= 1e-3;\n    return 1.5046 + 0.0042*disp / (lambda*lambda);\n}\n\n//spectral_zucconi6 but corrected so it integrates to white (1,1,1) ---------------------\nvec3 bump3(vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp(y-yoffset,0.,1.);\n    return y;\n}\n\nvec3 spectral(float lambda)\n{\n    float x = (lambda - 400.)/ 300.;\n    const vec3 c1 = vec3(3.54585, 2.93225, 2.41594);\n    const vec3 x1 = vec3(0.69549, 0.49228, 0.27700);\n    const vec3 y1 = vec3(0.02313, 0.15225, 0.52608);\n    const vec3 c2 = vec3(3.90307, 3.21183, 3.96587);\n    const vec3 x2 = vec3(0.11749, 0.86755, 0.66078);\n    const vec3 y2 = vec3(0.84897, 0.88445, 0.73949);\n    return pow((bump3(c1 * (x - x1), y1) + bump3(c2 * (x - x2), y2)),vec3(2.2)) * vec3(3.64499, 4.4228, 15.6893);\n}\n//---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*U-R)/R.x;\n    float a = (iMouse.z>0.) ? iMouse.x/R.x*3.14 : iTime*0.5;    \n    vec3 viewPos = vec3(0,0,-1.8);//-cos(iTime)*0.6);\n    \n    mat2 mat = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 ro = viewPos;\n    ro.xz = mat * ro.xz;\n    \n    vec3 rd = normalize(vec3(uv,0.8));\n    //vec3 rd = normalize(vec3(vec3(uv,0.,1. )));\n    rd.xz = mat * rd.xz;\n    \n    //Hit depth, pos and normal\n    float t = trace(rd,ro);\n    vec3 p = ro + rd*t;\n    p += rd*0.001;\n    vec3 n = normalize(p);\n    \n    vec3 acc;\n    \n    if (t>0.) {\n        float noise = texelFetch(iChannel1,ivec2(U)%1024,0).r;\n        noise = fract(noise+1.61803398*float(iFrame%100))*2.-1.;\n\n        for (float lambda = 400.+300.*(0.5+noise*0.5)/float(SAMPLES); lambda<700.; lambda+=300./float(SAMPLES)) {\n\n            float n_glass = get_n_glass(lambda,DISPERSION);\n            \n            float ratio = n_glass/N_AIR; //Swap these for an interesting (albeit incorrect) look\n            \n            //Bounce 1----------------------------\n            float fresnel = get_fresnel(rd,n,N_AIR,n_glass);\n            vec3 reflect_rd = reflect(rd,n);\n            vec3 refract_rd = refract(rd,n,N_AIR/n_glass); \n            \n            //Stop reflected ray\n            vec3 reflect_col = _sample(reflect_rd  ) * GLASS_REF;\n            \n            //Continue refracted ray\n            vec3 bounce_rd = refract_rd;\n            float t1 = trace(bounce_rd,p)*0.999;\n            vec3 bounce_p = p + bounce_rd*t1;\n            vec3 bounce_n = -normalize(bounce_p);\n            \n            //Bounce 2-----------------------------\n            float fresnel_2 = get_fresnel(bounce_rd,bounce_n,n_glass,N_AIR);\n            vec3 reflect_2_rd = reflect(bounce_rd,bounce_n);\n            vec3 refract_2_rd = refract(bounce_rd,bounce_n,ratio);\n            \n            //Stop refracted ray\n            vec3 refract_2_col = _sample(refract_2_rd);\n            \n            //Continue reflected ray\n            bounce_rd = reflect_2_rd;\n            float t2 = trace(bounce_rd,bounce_p)*0.999;\n            bounce_p = bounce_p+t2*bounce_rd;\n            bounce_n = -normalize(bounce_p);\n            \n            //Bounce 3-----------------------------\n            float fresnel_3 = get_fresnel(bounce_rd,bounce_n,n_glass,N_AIR);\n            vec3 reflect_3_rd = reflect(bounce_rd,bounce_n);\n            vec3 refract_3_rd = refract(bounce_rd,bounce_n,ratio);\n            \n            //Stop refracted ray\n            vec3 refract_3_col = _sample(refract_3_rd);\n            vec3 reflect_3_col = _sample(reflect_3_rd);\n            \n            //Continue reflected ray\n            bounce_rd = reflect_3_rd;\n            float t3 = trace(bounce_rd,bounce_p)*0.999;\n            bounce_p = bounce_p+t3*bounce_rd;\n            bounce_n = -normalize(bounce_p);\n            \n            //Combine results----------------------\n            vec3 reflect_2_col = mix(refract_3_col,reflect_3_col,fresnel_3); //Fresnel\n            reflect_2_col *= pow(GLASS_COL,vec3(t2));                        //Attenuation\n            \n            vec3 refract_col = mix(refract_2_col,reflect_2_col,fresnel_2); //Fresnel\n            refract_col *= pow(GLASS_COL,vec3(t1));                        //Attenuation\n            \n            vec3 col = mix(refract_col,reflect_col,fresnel); //Fresnel for bounce 1\n            \n            //Add as a spectral componant\n            acc += col*spectral(lambda);\n        }\n        \n        acc /= float(SAMPLES);\n    } else {\n        //Background\n        acc = _sample(rd)*0.8;\n    }\n    \n    vec3 col = acc;\n    \n    //Tone mapping\n    col = vec3(1.0) - exp(-col * exposure);\n    //Gamma correction\n\tcol = pow(max(col,0.), vec3(1./DISPLAY_GAMMA));\n    \n    \n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 355, 386, 386, 588], [590, 590, 645, 645, 964], [966, 966, 989, 989, 1227], [1229, 1249, 1294, 1294, 1367], [1369, 1459, 1493, 1493, 1566], [1568, 1568, 1597, 1597, 2068], [2160, 2160, 2199, 2199, 5979]], "test": "untested"}
{"id": "NsKGR3", "name": "Balls Falling", "author": "dr2", "description": "Spheres falling through an array of fixed spheres", "tags": ["collision", "dynamics", "physics"], "likes": 14, "viewed": 346, "published": 3, "date": "1631871029", "time_retrieved": "2024-07-30T19:00:52.285467", "image_code": "// \"Balls Falling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 37 in \"Ball Dynamics\" series\n    \"Molecular Dynamics\"        (4dG3RW)\n    \"Granular Vibration\"        (Mdy3RW)\n    \"Puck Dynamics\"             (MsV3zW)\n    \"Colliding Balls\"           (XsGGRm)\n    \"Pseudo Billiards\"          (4sy3Rm)\n    \"Pseudo Billiards 2\"        (ldy3zm)\n    \"Balls and Springs\"         (MsV3zw)\n    \"Reflecting Balls\"          (Xsy3WR)\n    \"Flashing Balls\"            (ldVGDR)\n    \"Quasi Billiards\"           (MsGGD1)\n    \"Trapped Balls\"             (4dV3RG)\n    \"Herding Balls\"             (4dKGRt)\n    \"Ball Run\"                  (XsyGWG)\n    \"Leaping Balls\"             (MdKGWc)\n    \"Leaping Balls Return\"      (4sG3Wt)\n    \"Stairway from Heaven\"      (4sG3Dt)\n    \"Faberge Balls\"             (MsdXWn)\n    \"Free the Balls\"            (lttGRn)\n    \"Balls and Springs 2\"       (XlGXzz)\n    \"More Balls\"                (MsfyRn)\n    \"Rolling Stones\"            (MdsfD7)\n    \"Ben-Hur Balls\"             (XtfBWf)\n    \"Refracted Colliding Balls\" (lljBDR)\n    \"Reflecting Ben-Hur Balls\"  (MsVfRW)\n    \"Quasi Billiards 2\"         (4ldBWl)\n    \"Ball Cluster\"              (3sfGD8)\n    \"Molecular Diffusion\"       (3d23z3)\n    \"Freezing and Melting\"      (3dj3Wy)\n    \"Racetrack\"                 (tscSDn)\n    \"Channeling Marbles\"        (wtfcRr)\n    \"Truchet Balls\"             (tlXBW4)\n    \"Marble Paths\"              (wddyDn)\n    \"Balls in Spinning Drum\"    (tdcyWs)\n    \"Magic Ball Sorter\"         (tsGyDy)\n    \"Balls In Motion\"           (WdGBRG)\n    \"Stairway to Hell\"          (sdl3WS)\n\n  (List includes both 3D and 2D dynamics, but not those in \"Sheet Dynamics\",\n  \"Chain Dynamics\", \"Rigid Body Dynamics\" series and those dealing with\n  mazes / slime / mondrians)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float s);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv3 (vec3 p);\nvec4 Loadv4 (int idVar);\n\nconst ivec3 nBallD = ivec3 (10, 4, 10);\nconst int nBall = nBallD.x * nBallD.y * nBallD.z;\n\nvec3 ltDir, vnBall, gId;\nfloat tCur, dstFar, gSize, gLim, sRad;\nint idBall, idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (sRad > 0.) d = min (d, PrSphDf (p - gSize * (gId + 0.5), sRad));\n  return d;\n}\n\nvoid SetGParm ()\n{\n  sRad = min (0.1 + 0.5 * Hashfv3 (17.1 * gId + 1.11), 0.5);\n  if (sRad < 0.2) sRad = 0.;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, gIdP, s;\n  float dHit, d, eps;\n  eps = 0.0002;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd;\n  gIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    if (Maxv3 (abs (gId)) < gLim) d = GObjDf (p);\n    else d = dstFar;\n    s = (gSize * (gId + step (0., rd)) - p) * rdi;\n    dHit += min (d, eps + max (0., Minv3 (s)));\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObjG, dstBall;\n  col = vec3 (0.05);\n  dstObjG = GObjRay (ro, rd);\n  dstBall = BallHit (ro, rd);\n  if (min (dstBall, dstObjG) < dstFar) {\n    if (dstObjG < dstBall) {\n      ro += dstObjG * rd;\n      vn = GObjNf (ro);\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (HsvToRgb (vec3 (mod (21. * float (idBall) / float (nBall) +\n         0.2 * BallChqr (idBall, vn), 1.), 1., 1.)), 0.2);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    rd = reflect (rd, vn);\n    if (dstObjG < dstBall) col += vec3 (0.05) * step (0.1, Minv2 (mod (4. *\n       vec2 (atan (rd.z, rd.x), asin (rd.y)) + 0.5, 1.) - 0.5));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 rd, ro, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (4 * nBall);\n  gSize = stDat.x;\n  gLim = stDat.y;\n  dstFar = 200.;\n  az = 0.;\n  el = -0.08 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.1 * tCur;\n  }\n  el = clamp (el, -0.1 * pi, 0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -80.);\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  zmFac = 6. / (1. - 0.7 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Balls Falling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Maxv3 (vec3 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashfv3 (vec3 p);\nvec4 Hashv4f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nBallD = ivec3 (10, 4, 10);\nconst int nBall = nBallD.x * nBallD.y * nBallD.z;\n\nfloat todCur, fOvlap, fricN, fricS, fricSW, fricT, gSize, gLim, bGap;\nconst float pi = 3.1415927;\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, gId;\n  float fDamp, fCent, grav, rSep, szN, szAv, ft, ms, drv, dt, sRad;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricS = 0.05;\n  fricSW = 1.;\n  fricT = 0.5;\n  fDamp = 0.01;\n  fCent = 0.02;\n  grav = 2.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n\n  gId = floor (rm / gSize);\n  if (Maxv3 (abs (gId)) < gLim) {\n    sRad = min (0.1 + 0.5 * Hashfv3 (17.1 * gId + 1.11), 0.5);\n    if (sRad > 0.) {\n      szAv = 0.5 * (sz + sRad);\n      dr = rm - gSize * (gId + 0.5);\n      rSep = length (dr);\n      if (rSep < szAv) {\n        CollFc (rSep, szAv, dr, vm, wm, am, wam);\n      }\n    }\n  }\n  \n  am.xz -= fCent * normalize (rm.xz);\n  am.y -= grav * ms;\n  am -= fDamp * vm;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 h;\n  vec3 nb;\n  float mIdf;\n  mIdf = float (mId);\n  nb = vec3 (nBallD);\n  rm.z = floor (mIdf / (nb.x * nb.y));\n  rm.y = floor (mod (mIdf, nb.x * nb.y) / nb.x);\n  rm.x = mod (mIdf, nb.x);\n  rm = bGap * (rm - 0.5 * (nb - 1.));\n  rm.y += 0.5 * bGap * nb.y + gSize * gLim + 8.;\n  vm.xz = -0.1 * sign (rm.xz);\n  vm.y = -0.1;\n  h = Hashv4f (mIdf);\n  qm = EulToQt (normalize (h.xyz));\n  wm = vec3 (0.);\n  sz = 1. - 0.2 * h.w;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag;\n  float sz, nStep;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 1) discard;\n  doInit = (iFrame <= 3);\n  if (doInit) {\n    nStep = 0.;\n    gSize = 1.5;\n    gLim = 6.;\n  } else {\n    stDat = Loadv4 (4 * nBall);\n    gSize = stDat.x;\n    gLim = stDat.y;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  bGap = 1.2;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else {\n      Step (mId, rm, vm, qm, wm, sz);\n      if (rm.y < - (0.5 * bGap * float (nBallD.y) + gSize * gLim + 8.))\n         Init (mId, rm, vm, qm, wm, sz);\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = pxId - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    stDat = vec4 (gSize, gLim, 0., nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2465, 2465, 2488, 2488, 2598], [2600, 2600, 2618, 2618, 2710], [2712, 2712, 2746, 2746, 3385], [3387, 3387, 3409, 3409, 3662], [3664, 3664, 3698, 3698, 4119], [4121, 4121, 4163, 4163, 4357], [4359, 4359, 4394, 4394, 5263], [5265, 5265, 5321, 5321, 6502], [6504, 6504, 6537, 6537, 6564], [6566, 6566, 6588, 6588, 6626], [6628, 6628, 6650, 6650, 6688], [6690, 6690, 6712, 6712, 6739], [6741, 6741, 6766, 6766, 7082], [7084, 7084, 7108, 7108, 7225], [7227, 7227, 7257, 7257, 7370], [7372, 7372, 7408, 7408, 7614], [7648, 7648, 7672, 7672, 7737], [7831, 7831, 7856, 7856, 7979]], "test": "untested"}
{"id": "fsyGzc", "name": "Hex Mosaic Video", "author": "ManuManu", "description": "display a video with a hex mosaic", "tags": ["video", "hex", "mosaic"], "likes": 2, "viewed": 121, "published": 3, "date": "1631865080", "time_retrieved": "2024-07-30T19:00:53.128214", "image_code": "\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec2 getUvCenter( vec2 uv, vec4 hc )\n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    \n    vec2 pos = hc.zw * .5;\n    \n    /*\n    if ( mod( hc.w, 2. ) > .5 )\n        pos += h;\n    //*/\n    \n    pos.y *= 2.;\n    \n    return pos;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //uv.y += 20.;\n    \n    //uv += .5;\n\n    vec3 col = vec3(0);\n    \n    float scale = 25.;\n    \n    uv *= scale;\n    \n    vec4 hc = HexCoords(uv);\n    \n    vec2 center = getUvCenter( uv, hc );\n    \n    float c = 0.;//smoothstep(.01, .03, hc.y*sin(hc.z*hc.w+iTime));\n    \n/*\n    if ( mod(hc.z, 2.) < .5 ) \n        col += vec3( 0.,0.,1.);\n    if ( mod(hc.z, 2.) > .5 ) \n        col += vec3( 0.,1.,1.);\n    if ( mod(hc.w, 2.) > .5 ) \n        col += vec3( 1.,0.,0.);\n       \n    col.x += hc.x;\n*/\n    col.r += abs( hc.z / 5.);\n    col.g += abs( hc.w / 5.);\n    \n    col = texture(iChannel0, center/scale + .5).rgb;\n\n    // colored outline ;\n    vec3 outlineColor = vec3( .5,.5, .5 );\n    c = 1.-smoothstep(.01, .05, hc.y);\n    col = mix( col, outlineColor, c );\n    \n\n    //fragColor = texture(iChannel0, center/scale + .5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 131], [133, 133, 158, 158, 436], [437, 437, 475, 475, 671], [673, 673, 730, 730, 1651]], "test": "untested"}
{"id": "7dy3R3", "name": "Onward to Thule", "author": "TEttinger", "description": "Thule, the fabled northern-most land! This is like my previous Northern Journey and Northern Warbler shaders combined. It's also somewhat more colorful.", "tags": ["noise", "plasma", "lights", "northern", "thule"], "likes": 13, "viewed": 485, "published": 3, "date": "1631845924", "time_retrieved": "2024-07-30T19:00:54.010854", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con.yzx)\n    + swayRandomized(c + 1.1, con.zxy)\n    + swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 64.0 + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx).xy * 32.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con + COEFFS);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * (3.14159265)) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 548], [550, 764, 795, 795, 933], [935, 935, 992, 1042, 1704]], "test": "untested"}
{"id": "NdG3z3", "name": "Distorted 3D Grapher", "author": "personalizedrefrigerator", "description": "An artifact-filled 3D grapher.\n\nControls: Arrow keys to move. 'A' and 'Z' control pitch.\nGraphs f(v, t). Currently uses a low-quality approximation of the sdf of a height-map of the given function.\n\nA small sphere has been placed at the origin.", "tags": ["keyboard", "graphing"], "likes": 1, "viewed": 235, "published": 3, "date": "1631837691", "time_retrieved": "2024-07-30T19:00:54.856593", "image_code": "/// MIT Licensed\n\n\n// Change these to adjust quality/performance.\n#define RAYMARCH_STEPS 50\n#define MAX_DIST 46.0\n//#define ANTI_ALIAS\n\n#define MIN_DIST 0.1\n#define SMALL 0.001\n#define GRAD_DESC_STEPS 3\n#define GRAD_DESC_RATE 0.8\n#define NUM_LIGHTS 2\n\n\n/** The function we're graphing! */\nfloat f(vec2 v, float t)\n{\n    return v.x * v.y / dot(v, v) * 6.0 + sin(t - v.x);\n}\n\n/** Gets the distance from the height map at [map_p] to [p] */\nfloat distance_map_to_p(vec2 map_p, in vec3 p)\n{\n    const float plane_y = -6.0;\n    \n    float vert_height = plane_y + f(map_p, iTime);\n    vec3 h_map_p = vec3(map_p.x, vert_height, map_p.y);\n    \n    return length(p - h_map_p) * sign(p.y - vert_height);\n}\n\nvec2 grad_distance_map_to_p(in vec2 map_p, in vec3 p)\n{\n    float dist_at = abs(distance_map_to_p(map_p, p));\n    \n    return vec2\n    (\n        abs(distance_map_to_p(map_p + vec2(SMALL, 0.0), p)) - dist_at,\n        abs(distance_map_to_p(map_p + vec2(0.0, SMALL), p)) - dist_at\n    ) / SMALL;\n}\n\nfloat map(in vec3 p)\n{\n    vec2 input_pt = p.xz;\n    float dist_to_fn = distance_map_to_p(input_pt, p);\n    float sgn = sign(dist_to_fn);\n    float rate = GRAD_DESC_RATE;\n    \n    // Approximate the distance to the function.\n    for (int k = 0; k < GRAD_DESC_STEPS; k++)\n    {\n        vec2 grad = grad_distance_map_to_p(input_pt, p);\n        \n        // Descend the gradient to minimize absolute value of distance.\n        input_pt -= rate * normalize(grad);\n        \n        float dist = distance_map_to_p(input_pt, p);\n        \n        if (abs(dist) <= abs(dist_to_fn))\n        {\n            dist_to_fn = dist;\n            \n            if (abs(dist) < MIN_DIST)\n            {\n                break;\n            }\n        }\n        else\n        {\n            rate *= 0.4;\n        }\n    }\n    \n    \n    return min\n    (\n        dist_to_fn,\n        \n        // Mark the origin.\n        length(p - vec3(0.0, 0.0, 0.0)) - 0.2\n    );\n}\n\n/// Approximate the normal to the scene at [p].\nvec3 scene_normal(in vec3 p)\n{\n    float dist_from_p = map(p);\n    \n    // Approx gradient of the sdf.\n    return normalize(vec3\n    (\n        map(p + vec3(SMALL, 0.0, 0.0)) - dist_from_p,\n        map(p + vec3(0.0, SMALL, 0.0)) - dist_from_p,\n        map(p + vec3(0.0, 0.0, SMALL)) - dist_from_p\n    ));\n}\n\nfloat march(in Ray r, int steps)\n{\n    float dist = MIN_DIST;\n    \n    for (int i = 0; i < steps; i++)\n    {\n        float current_dist = map(Ray_at(r, dist));\n        dist += current_dist;\n        \n        if (dist > MAX_DIST)\n        {\n            return MAX_DIST;\n        }\n        else if (abs(current_dist) < MIN_DIST)\n        {\n            return dist;\n        }\n    }\n    \n    return dist;\n}\n\nvec3 cast_ray(in Ray ray, in Light[NUM_LIGHTS] lights)\n{\n    float dist = march(ray, RAYMARCH_STEPS);\n    \n    if (dist >= MAX_DIST - SMALL || dist < 0.0)\n    {\n        return vec3(0.0);\n    }\n    \n    vec3 hit_pos = Ray_at(ray, dist);\n    vec3 normal = scene_normal(hit_pos);\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        vec3 current_color = vec3(0.0);\n        \n        Light_colorDueTo(lights[i], hit_pos, normal, ray, march, current_color);\n        color += current_color;\n    }\n    \n    // Checkerboard pattern.\n    color *= (mod(abs(floor(hit_pos.x) + floor(hit_pos.z)), 2.0) + 1.0) / 2.0;\n    \n    // Fade out near edge of view.\n    float fog = 1.0 - dist / MAX_DIST;\n    return color * fog;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cam = get_camera_pos(iChannel0);\n    vec3 cam_rotation = get_camera_rotation(iChannel0);\n    \n    Light[NUM_LIGHTS] lights = Light[]\n    (\n        Light_new(cam + vec3(0.0, 5.0 + 3.0 * sin(iTime / 4.0), 0.0),\n                        vec3(1.0, 0.5 + 0.5*sin(iTime / 8.0), 0.2), 0.5),\n        Light_new(20.0 * vec3(cos(iTime / 2.0), 1.0, sin(iTime / 2.0)), vec3(1.0), 10.4)\n    );\n    \n    vec3 col = vec3(0.0);\n    int count = 0;\n    \n    // Anti-aliasing\n    #ifdef ANTI_ALIAS\n    for (int dx = 0; dx <= 1; dx++)\n    {\n        for (int dy = -1; dy <= 1; dy++)\n        {\n    #else\n    {\n        int dx = 0;\n        int dy = 0;\n        \n        {\n    #endif\n            vec2 delta = vec2(float(dx), float(dy)) / 2.0;\n            \n            // Normalized pixel coordinates\n            vec2 uv = get_tex_coords(fragCoord + delta, iResolution.xy);\n            \n            Ray r = Ray_new(vec3(0.0), vec3(uv, 1.0));\n            rotate_ray(cam_rotation, r);\n            r.origin = cam + vec3(0.0, 3.0, 0.0);\n            \n            col += cast_ray(r, lights);\n            count ++;\n        }\n    }\n    \n    col /= float(count);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/// MIT Licensed\n\n\n#define CAMERA_POS_IDX vec2(0.0, 0.0)\n#define CAMERA_ROT_IDX vec2(5.0, 5.0)\n\n//// Ray\n\n/// Represents a ray.\n/// [direction] must have unit length.\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n/// Constructor\nRay Ray_new(vec3 origin, vec3 direction)\n{\n    return Ray(origin, normalize(direction));\n}\n\n/// Get [r] extended [t] units from its origin.\nvec3 Ray_at(Ray r, float t)\n{\n    return r.origin + r.direction * t;\n}\n\n//// Light\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\n/// Constructor\nLight Light_new(vec3 position, vec3 color, float intensity)\n{\n    return Light(position, normalize(color), intensity);\n}\n\nLight Light_new(vec3 position)\n{\n    return Light(position, vec3(1.0), 1.0);\n}\n\n/// Get [light]'s contribution to the color at [p] (where\n/// the normal to the scene is [normal]).\n/// [Light light]\n/// [Ray camera]\n/// [fn(Ray, int) march]\n/// Outputs color via [vec3 color]\n#define Light_colorDueTo(light, p, normal, camera, march, out_color) \\\n{ \\\n    vec3 to_camera = normalize(camera.origin - p); \\\n    vec3 to_light = normalize(light.position - p); \\\n    float brightness = dot(to_light, normal); \\\n    \\\n    vec3 half_vec = (to_camera + to_light) / 2.0;\\\n    float specular = pow(max(dot(to_light, half_vec), 0.0), 100.0);\\\n    \\\n    float dist_to_light = length(light.position - p);\\\n    float through_scene_to_light = march(Ray(p + to_light * 0.5, to_light), 5);\\\n    \\\n    if (through_scene_to_light < dist_to_light * 0.4 && through_scene_to_light > 0.0)\\\n    {\\\n        brightness *= 0.6;\\\n        specular = 0.0;\\\n    }\\\n    \\\n    brightness += specular;\\\n    \\\n    out_color = light.color * brightness \\\n            * sigmoid(1.0/pow(length(light.position - p) / light.intensity / 10.0, 2.0));\\\n}\\\n\n//// Math utils\n\n/// Atan-like shape that tends towards 0 at -inf\n/// and 1 at +inf.\nfloat sigmoid(float t)\n{\n    return 1.0 / (1.0 + exp(-t));\n}\n\n/// Get the \"smooth\" minimum of [a] and [b]. Smaller [k] -> smoother.\nfloat smin(float k, float a, float b)\n{\n    // First part tends towards 1 as (a-b) -> inf. In this case, a >> b, so we want to return b.\n    // Similarly, the second part tends towards 0 as (b - a) -> inf.\n    return b * sigmoid(k * (a - b)) + a * sigmoid(k * (b - a));\n}\n\n\n/**\n * Creates and applies a rotation matrix to a ray,\n * [ray]\n *\n * From https://www.shadertoy.com/view/fsK3zG\n */\nvoid rotate_ray(vec3 rotate, inout Ray ray)\n{\n    // x' = |r| cos(atan(y/x) + Δϑ)\n    //    = |r| (cos (atan y/x))(cos Δϑ) - |r| (sin (atan y/x))(sin Δϑ)\n    //    = (|r|·x/|r|)(cos Δϑ) - (|r|·y/|r|)(sin Δϑ)\n    //    = x cos Δϑ - y sin Δϑ for non-zero |r|.\n    // Similar process for y', where (x', y') are the transformed coordinates\n    // in the PLANE THAT WE'RE ROTATING IN.\n    \n    // Rotation in the XY plane\n    mat3 transform_z = mat3\n    (\n        cos(rotate.z), -sin(rotate.z), 0.0,\n        sin(rotate.z), cos(rotate.z), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Rotation in the XZ plane\n    mat3 transform_y = mat3\n    (\n        cos(rotate.y), 0.0, -sin(rotate.y),\n        0.0, 1.0, 0.0,\n        sin(rotate.y), 0.0, cos(rotate.y)\n    );\n    \n    // Rotation in the YZ plane\n    mat3 transform_x = mat3\n    (\n        1.0, 0.0, 0.0,\n        0.0, cos(rotate.x), -sin(rotate.x),\n        0.0, sin(rotate.x), cos(rotate.x)\n    );\n    \n    mat3 transform = transform_x * transform_y * transform_z;\n    \n    ray.origin *= transform;\n    ray.direction *= transform;\n    \n    ray.direction = normalize(ray.direction);\n}\n\n/// Get normalized, but not stretched, frag_coord, such that\n/// the x or y axis ranges from -0.5 to 0.5, the other with a range\n/// at least as large.\nvec2 get_tex_coords(vec2 frag_coord, vec2 resolution)\n{\n    // -> (-0.5, 0.5)\n    vec2 normalized = frag_coord / resolution.xy - vec2(0.5);\n    \n    // Re-expand to (-res.x/2, res.x/2) x (-res.y/2, res.y/2)\n    normalized = vec2(normalized.x * resolution.x, normalized.y * resolution.y);\n    normalized /= max(resolution.x, resolution.y);\n    \n    return normalized;\n}\n\n/// Get the camera position as stored in a buffer.\nvec3 get_camera_pos(sampler2D tex)\n{\n    return texture(tex, CAMERA_POS_IDX).xyz;\n}\n\nvec3 get_camera_rotation(sampler2D tex)\n{\n    return texture(tex, CAMERA_ROT_IDX).xyz;\n}\n\nfloat get_key(sampler2D keyboard, int key)\n{\n    // Reference: https://www.shadertoy.com/view/lsXGzf\n    \n    return texelFetch(keyboard, ivec2(key, 0), 0).x;\n}\n\nvec2 get_arrow_keys(sampler2D keyboard)\n{\n    const int LEFT = 37;\n    const int UP = 38;\n    const int RIGHT = 39;\n    const int DOWN = 40;\n    \n    return vec2(get_key(keyboard, RIGHT), get_key(keyboard, UP)) \n         - vec2(get_key(keyboard, LEFT), get_key(keyboard, DOWN));\n}\n", "buffer_a_code": "/// MIT Licensed\n\n// This buffer handles keyboard input and is currently **VERY**\n// inefficient.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 arrow_keys = get_arrow_keys(iChannel0) / 5.0;\n    \n    vec3 cam_pos = get_camera_pos(iChannel2);\n    vec3 cam_rot = get_camera_rotation(iChannel2);\n    \n    // Direction in which we're moving the camera\n    vec3 cam_move = vec3(0.0, 0.0, arrow_keys.y);\n    cam_rot.y -= arrow_keys.x / 6.0;\n    cam_rot.x += (get_key(iChannel0, 65) - get_key(iChannel0, 65 + 25)) / 24.0;\n    \n    // Only if we're moving the camera at all...\n    if (length(cam_move) > 0.1)\n    {\n        Ray move_direction = Ray_new(vec3(0.0), cam_move);\n        rotate_ray(cam_rot, move_direction);\n\n        cam_pos += move_direction.direction / 2.0;\n    }\n    \n    // If we're in the general area of the position output...\n    if (fragCoord.x < 25.0)\n    {\n        fragColor = vec4(cam_pos, 1.0);\n    }\n    else\n    {\n        // Otherwise, we'll output rotation.\n        \n        fragColor = vec4(cam_rot, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3z3.jpg", "access": "api", "license": "mit", "functions": [[253, 289, 315, 315, 372], [374, 437, 485, 485, 694], [696, 696, 751, 751, 990], [992, 992, 1014, 1014, 1923], [1925, 1973, 2003, 2003, 2278], [2280, 2280, 2314, 2314, 2678]], "test": "untested"}
{"id": "fdy3Rc", "name": "Experimental swirls", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 8, "viewed": 315, "published": 3, "date": "1631836883", "time_retrieved": "2024-07-30T19:00:55.702332", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.8 * iTime;\n    float div = 1.;\n    // Normalized pixel coordinates (from 0 to 1)\n    fragCoord = mod(fragCoord, div * iResolution.xy);\n    vec2 uv = (fragCoord - div *  0.5 * iResolution.xy)/iResolution.y;\n    //uv = mod(uv, 0.5);\n    float theta = atan(uv.y, uv.x);\n    float d = length(uv);\n    uv /= 0.03 + 0.01 * d;\n    uv += 2. * cos(uv.x + 4. * 3.14159 * cos(0.5* t)) + 2. * sin(uv.y + 2. * 3.14159 * sin(0.3 *t));\n    theta -= atan(uv.y,uv.x);\n    d = length(uv);\n    d = mod(d,1.4);\n    float s = 0.5 * (1. + cos(4. * theta + t));\n   // s = s * s;\n    float val = step(9./d,2.+10. * s);//,\n    //0. - 7. * (1.-s) + s * 7. * cos(5. * theta + t));\n    val *= 1.-0.08 * length(uv);\n    // Output to screen\n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 813]], "test": "untested"}
{"id": "NdG3Rc", "name": "Cosine Rainbow", "author": "Krischan", "description": "A single line function creates a nice RGB rainbow by just taking a value from 0...1\nOriginal by keyuliang https://www.shadertoy.com/view/Nt2XWc\n", "tags": ["color", "gradient", "rgb", "rainbow"], "likes": 8, "viewed": 515, "published": 3, "date": "1631833364", "time_retrieved": "2024-07-30T19:00:56.520145", "image_code": "#define rainbow(u) .5 + .5 * cos( atan(u.x,u.y) + 6.3 * iTime + vec3(0,23,21) )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U -= .5* iResolution.xy;\n    O = vec4(rainbow(U),1.0);\n}\n\n// original version\n/*\n#define rainbow(a) .5 + .5 * cos(6.283 * (a + vec3(0.,.33,.66)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x+=length(uv);\n    \n    fragColor = vec4(rainbow(fract(atan(uv.x, uv.y) / 3.1415 + iTime)),1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 122, 122, 183]], "test": "untested"}
{"id": "fdyGz3", "name": "tiling that has neat gradients", "author": "pali6", "description": "It does recurson on Robinsion triangles. The code sucks.", "tags": ["tiling", "penrose"], "likes": 5, "viewed": 299, "published": 3, "date": "1631824819", "time_retrieved": "2024-07-30T19:00:57.278118", "image_code": "#define DEPTH 15\n#define PHI ((1. + sqrt(5.)) / 2.)\n#define PI 3.141592653589\n//#define DEPTH int(round(16. - 7. * cos(iTime / 5.)))\n\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool onRight(vec2 a, vec2 b, vec2 x)\n{\n    return cross(vec3(a - b, 0), vec3(x - b, 0)).z > 0.;\n}\n\nfloat cr(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat cr(vec2 a, vec2 b, vec2 c)\n{\n    return cr(b - a, c - b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = fragCoord / iResolution.xx;\n    \n    float scale = 50. + 20. * sin(iTime / 10.) + 10. * sin(4. + iTime / 15.);\n    vec2 camPos = vec2(0.5, 0.5);\n    camPos += vec2(0.02 * sin(iTime / 15.), -0.07 * cos(iTime / 19.));\n    camPos += vec2(0.1 * sin(3. + iTime / 37.), -0.1 * cos(4. + iTime / 27.));\n    camPos += vec2(0.07 * sin(9. + iTime / 47.), -0.08 * cos(20. + iTime / 31.));\n    \n    pos -= vec2(0.5, 0.5);\n    pos /= scale;\n    pos += camPos;\n    \n    vec2 ota = vec2(-1., 0.);\n    vec2 otb = vec2(2., 0.);\n    \n    vec2 ta = ota;\n    vec2 tb = otb;\n    vec2 tc;\n    bool gn = true;\n    float fl = -1.;\n    \n    float f = 0.;\n    \n    // vec2 otc;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        vec2 next;\n        if(gn)\n        {\n            tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n            next = tb + (ta - tb) / PHI;\n            if(abs(cr(next, tc, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(next, tc, pos) * cr(next, tc, tb) > 0.)//onRight(next, tc, pos))\n            {\n                gn = false;\n                ta = next;\n                tb = tc;\n                fl *= -1.;\n                i--;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        else\n        {\n            tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n            next = tc + (tb - tc) / PHI;\n            if(abs(cr(ta, next, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(ta, next, pos) * cr(ta, next, tb) > 0.)//onRight(ta, next, pos))\n            {\n                gn = false;\n                ta = tb;\n                tb = next;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        //if(i == 0)\n        //    otc = tc;\n    }\n\n    if(gn)\n        tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n    else\n        tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n\n    #define S(M, O) (0.5 + 0.5 * sin(O + M * pos.x)) / 4.\n    #define C(M, O) (0.5 + 0.5 * cos(O + M * pos.y)) / 4.\n    if(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n      !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5)\n    {\n        fragColor = vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        );\n    }\n    else\n        fragColor = vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n        \n    \n    // if(f > 0.) fragColor = vec4(1, 0, 0, 1);\n    \n    /*\n    if(length(uv - ota) <= 0.01)\n        fragColor += vec4(0.5, -0.5, -0.5, 0.0);\n    if(length(uv - otb) <= 0.01)\n        fragColor += vec4(-0.5, 0.5, -0.5, 0.0);\n    if(length(uv - otc) <= 0.01)\n        fragColor += vec4(-0.5, -0.5, 0.5, 0.0);\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 165, 165, 249], [251, 251, 289, 289, 348], [350, 350, 376, 376, 412], [414, 414, 448, 448, 479], [481, 481, 536, 536, 3738]], "test": "untested"}
{"id": "fdy3z3", "name": "Hexagins", "author": "narida", "description": "Some shoddy workmanship.", "tags": ["2d", "hexagons", "myocdhatesthis"], "likes": 4, "viewed": 287, "published": 3, "date": "1631824494", "time_retrieved": "2024-07-30T19:00:58.028113", "image_code": "precision highp float;\nprecision highp int;\n\nfloat banded(float bandCount, float t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec2 banded(float bandCount, vec2 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec3 banded(float bandCount, vec3 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\nvec3 unmix(float a, float b, vec3 value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 hex2xy(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\n// correct the 3d coordinate of a hex coordinate.\nvec3 hexFix(vec2 hexXy) {\n    return vec3(hexXy, -(hexXy.x + hexXy.y));\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat min3(float a, float b, float c) {\n    return min(a, min(b, c));\n}\n\nfloat min3(vec3 a) {\n    return min(a.x, min(a.y, a.z));\n}\n\nfloat hexSdf(vec3 hex) {\n//    hex.x += 2.*hex.y/.6;\n//    hex.z = -(hex.x+hex.y);\n//    return max3(abs(hex.xyz));\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth_2315452051(vec3 hsv) {\n    vec3 rgb = clamp(\n    abs(mod(hsv.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0,\n    0.0, 1.0);\n\n    rgb = rgb*rgb*(3.0-2.0*rgb);// cubic smoothing\n\n    return hsv.z * mix(vec3(1.0), rgb, hsv.y);\n}\n\nconst float TAU = 6.283185307179586;\n// returns a random vector inside the unit circle\n// all points inside the circle are more likely,\n// ie. higher radiuses are more likely\nvec2 randomVector(vec2 random01) {\n    return fromPolar(sqrt(random01.x), random01.y * TAU);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nmat2 rot2d(float angleRad) {\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat2(\n    c, -s,\n    s, c);\n}\n\nvec2 tri2xy(vec3 uvR) {\n    float y = uvR.t * 0.866;\n    float x = uvR.s + uvR.t / 2.0;\n    return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n    float y = uv.t * 0.866;\n    float x = uv.s + uv.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 triCenter(vec3 uvR) {\n    vec3 base = floor(uvR);\n    vec2 centerOffset = mix(vec2(1./3.), vec2(2./3.), uvR.z);\n    return base + vec3(centerOffset, 0.0);\n}\n\nvec3 xy2hex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec3 xy2tri(vec2 xy) {\n    float v = xy.y / 0.866;\n    float u = xy.x - v / 2.0;\n    float R = float(fract(u) + fract(v) > 1.0);\n    return vec3(u, v, R);\n}\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\nuvec2 pcg(uvec2 v) {\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    return v;\n}\n\n// pcg3d renamed for overload\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec3 pcgf(out uvec3 v) {\n    v = pcg(v);\n    return vec3(v) / float(0xffffffffu);\n}\n\nvec4 linRgbColor(vec4 sRgbColor) {\n    return vec4(pow(sRgbColor.xyz, vec3(2.2)), sRgbColor.w);\n}\n\nvec4 getColorAt(ivec2 pos) {\n    uvec2 upos = uvec2(pos);\n\n    uvec3 rnd = uvec3(upos, upos.x ^ upos.y);\n    rnd = pcg(rnd);\n    rnd = pcg(rnd);\n    vec3 rndf = vec3(rnd) / float(0xffffffffu);\n    vec4 color = black;\n    //    color.xyz = rndf;\n    float s = .6;\n    //    float s = mix(.5, .7, color.y);\n    color.xyz = hsv2rgb_smooth_2315452051(vec3(rndf.x, s, 1.));\n    //        color.xyz = vec3(rndf.x);\n    color = linRgbColor(color);\n    //        return rnd.x>>31 == 0u ? black:white;\n    return color;\n}\n\nfloat calculateHexFalloff(float x) {\n    //        return  smoothstep(.3, .4, x);\n    return smoothstep(.520, .530, x);\n    //        return banded(5., smoothstep(a, a+.3, x));\n    //    return escalator(3., smoothstep(.4, .6, x), highResTimeStamp*.0001);\n}\n\nvec4 mix3(float s, float t, float u, vec4 a, vec4 b, vec4 c) {\n    return (a * s + b * t + c * u) / (s + t + u);\n}\n\nvec4 blend(vec4 source, vec4 dest) {\n    return source + dest * (1. - source.w);\n}\n\nvoid sortLayers2(out ivec2 a, out ivec2 b) {\n    if (a.x > b.x) {\n        ivec2 tmp = b; b = a; a = tmp;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 scaledCoord = fragCoord / min(iResolution.x, iResolution.y);\n    //    scaledCoord = mix(vec2(-1.), vec2(1.), scaledCoord);\n    scaledCoord *= 22.;\n    scaledCoord += iTime * normalize(vec2(100., 1.)) * 2.;\n\n    // UNIT GRID\n    vec2 unitGridDistances = scaledCoord - round(scaledCoord);\n    if (abs(unitGridDistances.x) < .01 || abs(unitGridDistances.y) < .01) {\n        fragColor = vec4(scaledCoord, 0., 1.);\n        //        return;\n    }\n\n    // TRIANGLE CENTER CIRCLES\n    vec3 tri = xy2tri(scaledCoord);\n    vec3 triTriangleCenter = triCenter(tri);\n    vec2 xyTriangleCenter = tri2xy(triTriangleCenter);\n    if (distance(xyTriangleCenter, scaledCoord) <.1) {\n        fragColor = black;\n        //                return;\n    }\n    vec3 triFract = fract(tri);\n    // TRIANGLE GRID\n    float w = .01;\n    if (abs(triFract.x-.5) > .5-w\n    || abs(triFract.y-.5) > .5-w\n    || abs(triFract.x + triFract.y - 1.) <w) {\n        fragColor = black;\n        //                        return;\n    }\n\n    // RENDER HEXAGONS\n    // As hexagons can potentially overlap each other, we cannot just calculate the nearest hexagon center and get the\n    // distance from that. Instead, we use the fact that each corner of a hex touches at most 3 triangles. Each corner\n    // of a hex matches the center of a triangle in a triangle grid (see above).\n    // For every triangle, we calculate the nearest three hex centers, and calculate the color of that hex and the\n    // distance to it.\n\n    // Depending on if we are in a up or down triangle, the offsets are differnt.\n    // Mobile browsers do NOT like vec2[3]:\n    // vec2[3] offsets = vec2[3](vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    mat3x2 offsets = mat3x2(vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    vec4[3] colors;\n    ivec2[3] order; // (z-index, i)\n    for (int i = 0; i < 3; i++) {\n        vec3 hexHexagonCenter = hexFix(floor(tri.xy) + offsets[i]);\n        vec2 xyHexagonCenter = hex2xy(hexHexagonCenter);\n        vec2 xyDiff = scaledCoord - xyHexagonCenter;\n        vec4 c = getColorAt(ivec2(hexHexagonCenter));\n        uvec2 upos = uvec2(ivec2(hexHexagonCenter));\n        uvec3 rnd = uvec3(upos, upos.x^upos.y);\n        vec3 rndf = pcgf(rnd);\n        // Calculate a smaller random int, so we can trigger random effects on specific values.\n        uint rndx = rnd.x >> 22;\n        //                uint rndx = rnd.x >> 28;\n        if (rndx == 7u) {\n            // angle wrong\n            xyDiff.xy *= rot2d(rndf.y);\n        }\n        if (rndx == 3u) {\n            // wrong position\n            xyDiff += .2*randomVector(rndf.yz);\n        }\n        if (rndx == 2u) {\n            // grayscale\n            c.xyz = c.xxx;\n        }\n        float d = hexSdf(xy2hex(xyDiff));\n\n        if (rndx == 4u) {\n            // wrong size\n            d += mix(-.15, .15, rndf.y);\n        }\n        if (rndx == 5u) {\n            // wrong shape: circle\n            d = length(xyDiff)*.9;\n        }\n        if (rndx == 6u) {\n            // wrong shape: square\n            d = max(abs(xyDiff.x), abs(xyDiff.y));\n        }\n        colors[i] = c*(calculateHexFalloff(1.-d));\n        order[i] = ivec2(hexHexagonCenter.x  + hexHexagonCenter.y*1000., i);\n    }\n\n    // Sort the hexagons into a consistent order, so there are no discontinuities at the triangle borders.\n    sortLayers2(order[0], order[1]);\n    sortLayers2(order[1], order[2]);\n    sortLayers2(order[0], order[1]);\n\n    // Blend colors together according to sorted order.\n    fragColor = black;\n    for (int i = 0; i < 3; i++) {\n        int j = order[i].y;\n        fragColor = blend(colors[j], fragColor);\n    }\n\n    // gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0/2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 85, 85, 155], [156, 156, 194, 194, 264], [265, 265, 303, 303, 373], [374, 374, 412, 412, 452], [454, 454, 503, 503, 546], [548, 548, 592, 592, 626], [627, 627, 669, 669, 703], [705, 705, 755, 755, 813], [815, 815, 856, 856, 911], [913, 913, 941, 941, 981], [983, 983, 1006, 1006, 1095], [1097, 1147, 1172, 1172, 1220], [1222, 1222, 1247, 1247, 1509], [1511, 1511, 1550, 1550, 1580], [1581, 1581, 1601, 1601, 1637], [1639, 1639, 1678, 1678, 1710], [1712, 1712, 1732, 1732, 1770], [1772, 1772, 1796, 1887, 1936], [1938, 1970, 2012, 2012, 2209], [2248, 2386, 2420, 2420, 2480], [2482, 2482, 2556, 2556, 2610], [2612, 2612, 2683, 2683, 2737], [2739, 2739, 2767, 2767, 2856], [2858, 2858, 2881, 2881, 2970], [2971, 2971, 2993, 2993, 3079], [3081, 3081, 3107, 3107, 3242], [3244, 3244, 3266, 3266, 3387], [3389, 3389, 3411, 3411, 3545], [3594, 3594, 3614, 3614, 3827], [3829, 3904, 3924, 3924, 4120], [4121, 4121, 4145, 4145, 4204], [4206, 4206, 4240, 4240, 4303], [4305, 4305, 4333, 4333, 4817], [4819, 4819, 4855, 4900, 5076], [5078, 5078, 5140, 5140, 5192], [5194, 5194, 5230, 5230, 5276], [5278, 5278, 5322, 5322, 5390]], "test": "untested"}
{"id": "7dV3zV", "name": "Desert mountains", "author": "jarble", "description": "A simple desert terrain based on Karang's \"Desert biome\" shader.", "tags": ["procedural", "planet", "mountain", "desert", "biome"], "likes": 9, "viewed": 348, "published": 3, "date": "1631819277", "time_retrieved": "2024-07-30T19:00:58.886817", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    float f2 = .1; //this constant changes the variation in mountain height\n    \n    float f1 = f2;\n    float f3 = 1.-f1;\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        uv += vec2(amplitude,freq);\n        n1 = abs(noise((uv) * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 2.1-amplitude;\n        amplitude *= .45;\n        \n        \n        float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx;\n        uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    \n    return -value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 356], [358, 358, 383, 383, 423], [425, 425, 464, 570, 1461], [1464, 1464, 1495, 1495, 1757], [1823, 1823, 1868, 1868, 2154], [2156, 2156, 2194, 2194, 2449], [2451, 2451, 2518, 2518, 2745], [2747, 2747, 2778, 2778, 4195], [4263, 4263, 4320, 4320, 5122]], "test": "untested"}
{"id": "fdV3RK", "name": "Simple drifting", "author": "NLIBS", "description": "My first time working with physics in shaders and trying some new effects.\nYeah the car model sucks but you get the idea\n\nNOTE: You can drive the car by uncommenting line 9 in Buffer A", "tags": ["2d", "smoke", "physics", "car", "opacity"], "likes": 9, "viewed": 418, "published": 3, "date": "1631805657", "time_retrieved": "2024-07-30T19:00:59.761478", "image_code": "float heightmap(vec2 pos)\n{\n    float h1 = exp(-length(pos)*5.)*0.08+0.92;\n    pos *= vec2(3,1);\n    float h2 = 2.0-max(abs(pos.x),min(abs(pos.y)+0.03,.05+0.03))*.6;\n    return h1*h2;\n}\n\nvec2 diff(vec2 pos)\n{\n    vec2 d = heightmap(pos) - heightmap(pos+vec2(0.001,0))*vec2(1,0) - heightmap(pos+vec2(0,0.001))*vec2(0,1);\n    return d/0.001;\n}\n\nvec3 gradient(float x)\n{\n    return vec3(0.3,0.0,0.7)+clamp(x,0.,1.3)*vec3(0.5,0.5,-0.2);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec3 col = gradient(U.x/R.x);\n    col *= 1.0-pow(texelFetch(iChannel1,ivec2(U),0).rgb,vec3(0.9))*0.7;\n         \n    vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n    pv.x = mod(pv.x+50.,100.)-50.;\n    vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n    vec2 p = pv.xy;\n    vec2 v = pv.zw;\n     \n    mat2 rot = mat2(cos(ra.x),sin(ra.x),-sin(ra.x),cos(ra.x));\n    \n    vec2 d = abs((p-uv)*rot)*vec2(1,2);\n    float m = pow(pow(d.x,6.0)+pow(d.y,6.0),1./6.);\n    vec4 car = vec4(1,0.05,0,smoothstep(0.04+txl*4.,0.04,m));\n    \n    vec2 n2 = -diff((p-uv)*rot*vec2(1,2)) * inverse(rot);\n    vec3 n = normalize(vec3(n2,1.5));\n    vec3 ref = reflect(vec3(uv,-10.0),n);\n    float t = -heightmap(d) / ref.z;\n    t=abs(t);\n    vec2 hit = U/R +  t*ref.xy*.1;\n    \n    car.rgb = gradient(hit.x);\n    car.rgb *= 1.0-texture(iChannel1,hit).rgb*0.7;\n    car.rgb = mix(gradient(hit.x)*0.2+0.6,car.rgb,exp(-3.*texture(iChannel2,hit).r));\n    car.rgb = vec3(1,1,0.1)*gradient(U.x/R.x+1.*n.x)*0.5 + car.rgb*0.5;\n    \n    col = mix(pow(gradient(U.x/R.x),vec3(0.3)),col,exp(-3.*texelFetch(iChannel2,ivec2(U),0).r));\n\n    O = mix(vec4(col,0),car,car.a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Buffer A: Physics\n\n#define ENGINE 1.0\n#define GRIP 0.00125\n#define TURNING 0.15\n#define DRAG 0.005\n#define DT iTimeDelta\n\n#define AUTONOMOUS\n\n// keysw\nint kA=65,kD=68,kS=83,kW=87;\nint kLeft=37,kUp=38,kRight=39,kDown=40;\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    //Position and Velocity\n    if (ivec2(U)==ivec2(0)) {\n        vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n        pv.x = mod(pv.x+50.,100.)-50.;\n        \n        vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n        \n        #ifdef AUTONOMOUS\n        float drive = DT;\n        #else \n        float drive = (min(texelFetch(iChannel1,ivec2(kW,0),0).x+texelFetch(iChannel1,ivec2(kUp  ,0),0).x,1.0)\n                      -min(texelFetch(iChannel1,ivec2(kS,0),0).x+texelFetch(iChannel1,ivec2(kDown,0),0).x,1.0) )*DT;\n        #endif\n\n        vec2 fwrd_dir = vec2(cos(ra.x),sin(ra.x));\n        vec2 rght_dir = fwrd_dir.yx*vec2(-1,1);\n        float fwrd = dot(pv.zw,fwrd_dir);\n        float rght = dot(pv.zw,rght_dir);\n        \n        //Accelerating, braking\n        fwrd = (max(drive,0.)*min(ENGINE,GRIP)+fwrd+max(min(drive,0.)*sign(fwrd)*GRIP,-abs(fwrd)));           \n        //Sideways tire grip\n        rght = max(abs(rght)-GRIP*DT,0.)*sign(rght);\n        pv.zw = fwrd_dir*fwrd  +  rght_dir*rght;\n        \n        float m = length(pv.zw)+.0001;\n        pv.zw *= max(m-DRAG*m*m,0.)/m;\n        \n        pv.xy += pv.zw*DT*144.;\n        pv.xy = (fract(pv.xy*R.x/R.xy*.47+.5)-0.5)/0.47*R.y/R.yx;\n        \n        if (abs(rght)>GRIP/60. || drive<0.&&fwrd>0.)\n            pv.x += 100.;\n        if (drive*ENGINE>GRIP+m*3.)\n            pv.x += 100.;\n        \n        O = pv;\n        \n    //Angle and Rotation speed\n    } else if (ivec2(U)==ivec2(1,0)) {\n        vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n        vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n        \n        pv.x = mod(pv.x+50.,100.)-50.;\n        vec2 fwrd_dir = vec2(cos(ra.x),sin(ra.x));\n        float fwrd = abs(dot(pv.zw,fwrd_dir));\n        fwrd *= 0.3+0.7*step(0.,fwrd);\n        \n        #ifdef AUTONOMOUS\n        float t = iTime*0.5;\n        float a = (sin(t*2.)/2.+sin(t*5.4)/5.4+sin(t*11.5)/11.5)*1.2985;\n        ra.y += min(sqrt(abs(a))*0.7,1.0)*sign(a)*DT*TURNING;\n        #else \n        ra.y += (min(texelFetch(iChannel1,ivec2(kA,0),0).x+texelFetch(iChannel1,ivec2(kLeft ,0),0).x,1.0)\n                -min(texelFetch(iChannel1,ivec2(kD,0),0).x+texelFetch(iChannel1,ivec2(kRight,0),0).x,1.0) )*DT*TURNING*min(fwrd*500.,1.);\n        #endif\n        \n        ra.y *= pow(.001,DT);\n        ra.x+=ra.y*DT*144.;\n        ra.x = mod(ra.x,6.283185);\n        \n        O = ra;\n    }\n    if (iFrame<1) O-=O;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Buffer B: Tyre rubber effect\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec4 pv = texelFetch(iChannel0,ivec2(0),0);\n    float slip = pv.x;\n    pv.x = mod(pv.x+50.,100.)-50.;\n    vec4 ra = texelFetch(iChannel0,ivec2(1,0),0);\n    float speed = length(pv.zw);\n    vec2 noise = texelFetch(iChannel2,ivec2(U)%1024,0).rg;\n    vec2 p = pv.xy - pv.zw*noise*iTimeDelta*144.;\n    vec2 v = pv.zw;\n    \n    vec4 col = texelFetch(iChannel1,ivec2(U),0)*pow(0.98,iTimeDelta);\n    col.a = 0.;\n    //col = texelFetch(iChannel1,ivec2(U+pv.zw*R*1.),0);\n    //col = texture(iChannel1,U/R+pv.zw);\n     \n    mat2 rot = mat2(cos(ra.x),sin(ra.x),-sin(ra.x),cos(ra.x));\n    \n    //float car = step(dot(p-uv,p-uv),0.0005);\n    float rubber = 0.0;\n    float slip_front = step(50.,slip)*0.5;\n    float slip_rear  = slip_front+step(100.,slip)*0.5;\n    \n    \n    //Rear right\n    vec2 d = abs((p-uv - vec2(0.032,0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_rear;\n    //Rear left\n    d = abs((p-uv - vec2(0.032,-0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_rear;\n    //Front right\n    d = abs((p-uv - vec2(-0.032,0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_front;\n    //Front left\n    d = abs((p-uv - vec2(-0.032,-0.015)*inverse(rot))*rot)*vec2(7.5,16);\n    rubber += smoothstep(0.04+txl*25.,0.04,max(d.x,d.y)) * slip_front;\n    \n    \n    rubber = min(rubber,1.0)*0.3*min(speed*200.,5.)*iTimeDelta*144.;\n    \n\n    O = col+rubber;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Buffer C: Smoke effect\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R  = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    float txl = 1./R.x;\n    \n    vec4 col = vec4(0);\n    \n    for (int i = 0; i<9; i++) {\n        col += texelFetch(iChannel1,ivec2(U)+ivec2(i%3-1,i/3-1),0);\n    }\n    col *= 0.11111*pow(0.94,iTimeDelta);\n    \n    float new_rubber = texelFetch(iChannel0,ivec2(U),0).a;\n    col += new_rubber*0.6;\n    \n    O = col;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 185], [187, 187, 208, 208, 341], [343, 343, 367, 367, 434], [436, 436, 475, 475, 1694]], "test": "untested"}
{"id": "NdGGRK", "name": "Cross function piston", "author": "gaz", "description": "A test to see the behavior of cross ()", "tags": ["cross"], "likes": 13, "viewed": 327, "published": 3, "date": "1631802342", "time_retrieved": "2024-07-30T19:01:00.519452", "image_code": "const float maxd=80.0;\n\nvec3 rot(inout vec3 p,vec3 axis,float theta){\n\taxis=normalize(axis);\n\treturn mix(axis*dot(p,axis),p,cos(theta))+sin(theta)*cross(p,axis);\n}\n\n\nvec2 polarAbs(vec2 p,float n)\n{\n  n*=0.5;\n  float a = asin(sin(atan(p.x,p.y)*n))/n;\n  return vec2(sin(a),cos(a))*length(p);\n}\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\n\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+2315.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);\n    }\n    return p;\n}\n\nvec3 targetVector0()\n{\n    return randVec(32892.+floor(iTime/2.));\n}\n\nvec3 axisVector()\n{\n    vec3 a = targetVector0();\n    vec3 b = a.yzx;\n    for(int i=0;i<100;i++)\n    {\n        if (all(equal(a, b))==false) break;\n        b.z += 0.1;\n        b = normalize(b);\n    }\n    vec3 w = a;\n    vec3 u = normalize(cross(b,w));\n    vec3 v = cross(w,u);\n    return v;\n}\n\nvec3 targetVectorA()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = -iTime;\n    return rot(v,a,t);    \n}\n\nvec3 targetVectorB()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = iTime;\n    return rot(v,a,t);\n}\n\n\nfloat deA(vec3 p)\n{\n    float de =1.;\n    vec3 target = targetVectorA();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    //p = inverse(mat3(u,v,w)) * p;\n    p = p * mat3(u,v,w);\n    vec3 q=p;\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de = min(de,length(p)-.01);\n    q.xz=polarAbs(q.xz,24.);\n    q.z-=1.12;\n    return min(de,(lpNorm(q,5.0)-.091+q.z*.3)*.8);\n}\n\nfloat deB(vec3 p)\n{\n    float de=1.;\n    vec3 target = targetVectorB();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = vec3(dot(p,u), dot(p,v), dot(p,w));\n    de=min(de,lpNorm(vec2(length(p.yz)-.95,p.x),5.0)-.07);\n    de=min(de,lpNorm(vec2(length(p.xz)-1.,p.y),5.0)-.1);\n    de=min(de,lpNorm(vec2(length(p.xz)-.15,p.y),5.0)-.07);\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de=min(de, length(p)-.01);\n    return de;\n}\n\nfloat deC(vec3 p)\n{\n    vec3 targetA = normalize(targetVectorA());\n    vec3 targetB = normalize(targetVectorB());\n    // cross() test\n    vec3 cx = cross(targetA, targetB);\n    vec3 axis = targetA;\n    vec3 w = normalize(cx);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = transpose(mat3(u,v,w)) * p;\n    //p = p * mat3(u,v,w);       \n    float len = length(cx); \n    p.z -= clamp(p.z, 0.0, len);\n    return lpNorm(p,3.)-.1;\n}\n\nfloat map(vec3 p)\n{\n    float de = 1.;\n    de = min(de, deA(p));\n    de = min(de, deB(p));\n    de = min(de, deC(p));\n    de = min(de, p.y + 1.2);\n    return de;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n    if(deC(p)<0.001) return vec3(1.8,0.5,0.2);\n    return vec3(0.3,0.5,0.8)+cos(p*0.5)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(1.5);\n    vec3 ta = randCurve(iTime*.3,1234.6)*.4;\n    vec3 rd = normalize(vec3(uv,2.0));\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = cross(u,w);\n    rd = mat3(u,v,w) * rd;\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n    \tvec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n    \tfloat sha = min(1.,calcShadow( lightPos, -li, len )+.8);\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.5;\n    \tcol *= max(0.5+0.5*n.y, 0.0);\n    \tcol *= exp2(-1.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n    \tcol += vec3(0.8,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 10.0);\n    \tcol = mix(vec3(0.1,0.1,0.2),col, exp(-0.03*t*t));\n    }\n    fragColor.xyz = col;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 69, 69, 163], [166, 166, 197, 197, 291], [293, 293, 324, 324, 382], [385, 385, 416, 416, 478], [519, 519, 542, 542, 642], [644, 644, 677, 677, 806], [808, 808, 830, 830, 876], [878, 878, 897, 897, 1169], [1171, 1171, 1193, 1193, 1301], [1303, 1303, 1325, 1325, 1428], [1431, 1431, 1450, 1450, 1936], [1938, 1938, 1957, 1957, 2505], [2507, 2507, 2526, 2526, 2958], [2960, 2960, 2979, 2979, 3122], [3124, 3124, 3149, 3149, 3292], [3294, 3294, 3348, 3348, 3515], [3517, 3517, 3569, 3569, 3652], [3654, 3654, 3676, 3676, 3772], [3774, 3774, 3831, 3831, 4954]], "test": "untested"}
{"id": "fdG3zV", "name": "That 70's Colour Palette", "author": "xenn", "description": "yeah\nmouse click influences general direction", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 6, "viewed": 386, "published": 3, "date": "1631795284", "time_retrieved": "2024-07-30T19:01:01.463926", "image_code": "\n// Tone mapping and post processing\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n// linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q / (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf /= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    const float brightness = 1.0;\n    vec2 pp = fragCoord.xy/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy/r.xy;\n    p.y *= r.y/r.x;\n   \n    // a little chromatic aberration\n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel1, pp, sampl).rgb;\n    \n    // final output\n    float vignette = 1.25 / (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    color = color*vignette+noise;\n    color = filmic_reinhard(brightness*color);\n    \n    color = smoothstep(-0.025, 1.0,color);\n    \n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),-500.0* (1. * abs(cos(iTime / 3.25))) - 95.);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1.0,1.0,2.0 ));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*1.5;\n    //spec=0.0;\n\tfragColor = mix(texture(iChannel0,uv)*vec4(diff)+vec4(spec),texture(iChannel1,uv)*vec4(diff)+vec4(spec),0.5);\n}\n// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n\n\nint sampleCount = 50;\nfloat blur = 0.6; \nfloat falloff = 2.50; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUTA iChannel0\n#define INPUTB iChannel1\n#define INPUTC iChannel2\n#define INPUTD iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * .250 * inverseSampleCount,\n                               velocity * .50 * inverseSampleCount,\n                               velocity * 1.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUTA, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTA, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTA, destCoord + offsets[2]).b; \n        \n        accumulator.r += texture(INPUTB, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTB, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTB, destCoord + offsets[2]).b; \n        \n        accumulator.r *= texture(INPUTC, destCoord + offsets[0]).r; \n        accumulator.g *= texture(INPUTC, destCoord + offsets[1]).g; \n        accumulator.b *= texture(INPUTC, destCoord + offsets[2]).b; \n        \n         accumulator.r += texture(INPUTD, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUTD, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUTD, destCoord + offsets[2]).b; \n        \n        \n        offsets -= increments;\n        \n   //     accumulator.rgb = clamp(accumulator.rgb, 0., 1.);\n \n// vec4 blendy = (blend + accumulator),1.0;\n    }\n    vec3 blend  = texture(INPUTA, destCoord + offsets[0]).rgb;\n    blend = clamp(blend.rgb, 0., 1.);\n    vec3 blendo = (accumulator / float(sampleCount));\n //blend += blend + accumulator;\nfragColor = mix(vec4(blend.rgb,1.0),vec4(blendo.rgb,1.0),0.975);\n//\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}\n\n*/", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.0011\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed -0.03456\n#define iBlob2ColorPulseSpeed 0.04321\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "/** \n * Brightness Contrast Saturation Hue\n * Demo: https://www.shadertoy.com/view/MdjBRy\n * starea @ ShaderToy\n * \n * Forked and remixed from: \n * [1] https://shadertoy.com/view/llGSzK\n * [2] https://shadertoy.com/view/MsjXRt\n *\n * Created 7/26/2017\n * Updated 8/11/2017\n **/\n\n/*\nmat4 brightnessMatrix( float b ) {\n    return mat4( \n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        b, b, b, 1 );\n}\n*/\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\n/*\nmat4 contrastMatrix( float c ) {\n\tfloat t = 0.5 - c * 0.5;\n    return mat4( \n        c, 0, 0, 0,\n        0, c, 0, 0,\n        0, 0, c, 0,\n        t, t, t, 1 );\n\n}\n*/\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\n// remixed from mAlk's https://www.shadertoy.com/view/MsjXRt\nvec4 shiftHue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n\tfloat brightness = 0.15;\n\tfloat contrast = 1.2;\n    float saturation = 1.5;\n    float _vibrance = 4.0;\n    float _hue = abs(sin(iTime * 0.1)); \n    \n    vec4 color = texture( iChannel0, fragCoord/iResolution.xy );\n    \n    fragColor = saturationMatrix(saturation) * color; \n    brightnessAdjust(color, brightness); \n    contrastAdjust(color, contrast); \n    fragColor = vibrance(fragColor, _vibrance);\n    fragColor = shiftHue(fragColor.rgb, _hue);\n    fragColor.a = 1.0;\n    if (iMouse.z > 0.5) fragColor = color; \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .998;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 2.5;\nconst float iBlobEdgeSmoothing        = .15;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .55;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = -.0;\nconst float iColorShiftOfRadius       = .5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.rb - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    vec4 blend = texture(iChannel3,uv);\nvec4 blendy = texture(iChannel2,uv);\nvec4    blendo = max(blend,blendy);\n    fragColor = mix(blendo,vec4(color, 1.),0.95);\n//      fragColor = min(blendo,vec4(color, 1.));\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = max(col,col2);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdG3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 37, 57, 57, 103], [171, 171, 210, 210, 278], [280, 280, 310, 310, 482], [501, 501, 543, 543, 920], [922, 922, 972, 972, 1693]], "test": "untested"}
{"id": "NdG3zK", "name": "warm shades of blurriness", "author": "pali6", "description": "🤔\nClick to re-generate.", "tags": ["blur", "colors"], "likes": 4, "viewed": 248, "published": 3, "date": "1631786461", "time_retrieved": "2024-07-30T19:01:02.285729", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R 3\n#define RC 0.512\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame <= 30 || iMouse.w > 0.)\n    {\n        vec2 rc = uv + 0.00001 * vec2(iDate.w + iDate.y, iDate.w + iDate.z);\n        if(rand(rc) <= RC + 0.002 && rand(rc) >= RC)\n            fragColor = vec4(0.1 + rand(rc + vec2(1, 0)), rand(rc + vec2(2, 0)), rand(rc + vec2(3, 0)), 0.8);\n        else\n            fragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec4 currentColor4 = texture(iChannel0, uv);\n    vec3 currentColor = currentColor4.rgb;\n    float cAlpha = currentColor4.a;\n    if(cAlpha >= 1.)\n    {\n        fragColor = currentColor4;\n        return;\n    }\n    vec3 sum;\n    float count = 0.;\n    for(int dx = -R; dx <= R; dx++)\n        for(int dy = -R; dy <= R; dy++)\n        {\n            if(dx == 0 && dy == 0)\n                continue;\n            float mul = 1. / length(vec2(dx, dy));\n            vec3 col = texture(iChannel0, uv + vec2(dx, dy) / iResolution.xy).rgb;\n            if(length(col) > 0.)\n            {\n                count += mul;\n                sum += mul * col;\n            }\n        }\n    if(count > 0.01)\n    {\n        vec3 avg = sum / count;\n        float al = max(0.0000000001, pow(cAlpha, 1.)); \n        avg = currentColor * al + avg * (1. - al);\n        float g = avg.g + avg.b - 1. * avg.r + 0.1 * (1. - length(avg) / 3.);\n        fragColor = vec4(avg, cAlpha - 0.004 * log(max(0.001, g)));\n        return;\n    }\n    fragColor = vec4(currentColor, 0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "NdK3zy", "name": "Boyd-Maxwell ball packings", "author": "neozhaoliang", "description": "Beautiful math produce beautiful images. This program draws 2d sections of 3d Boyd-Maxwell ball packings.", "tags": ["2d", "coxeter", "hyperbolic", "circlepacking"], "likes": 26, "viewed": 1122, "published": 3, "date": "1631768030", "time_retrieved": "2024-07-30T19:01:03.214247", "image_code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2d slices of 3D Boyd-Maxwell Ball packings\n\nauthors: Chen Hao: https://num.math.uni-goettingen.de/~hchen/\n         Zhao Liang: https://twitter.com/neozhaoliang\n\nReference: see Hao's Ph.D thesis:\n\n    https://refubium.fu-berlin.de/bitstream/handle/fub188/1147/diss_haochen.pdf?sequence=1&isAllowed=y\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name may sound unfamiliar to most people, but basically this is a kind of\nkaleidoscope structure in 4D hyperbolic space, we just draw their 2d slices here.\n\nFor a Coxeter group of rank 5 and level 2, the complement of its limit set form a dense\nball packing of the ideal boundary of hyperbolic 4-space, hence a ball packing of the\nEuclidean 3-space. We use z=c or y=c planes with varying c to see the circle packing patterns\non these slices.\n\n \nIn Hao's paper he listed out all Coxeter groups of level 2, the diagrams that\nhave 5 vertices with none of them surrounded by a blue box are all valid inputs for this program.\n\nUsage:\n\n1. Select a configuration below and uncomment it, or you can input one manually\n2. In common.frag, use `#define DrawLimitSet` to switch between the limit set view and circle packing view\n3. In common.frag, change `ZOOM` to zoom in/out.\n4. When drawing circle packings, use the bvec4 param 'isRealBall' to add/remove circles (explained below).\n5. In common.frag, use `#define DrawVerticalSections` to show vertical sections (suggested by @mla)\n\nExample:\n\nThis is a rank 5 group of level 2:\n     \n     v2\n     x\n       \\   5\n     |  o --- o --- x\n     | / v4   v1    v0\n     x\n     v3\n     \nEach vertex in the diagram represents a 'virtual mirror' in 3d space (a plane or a sphere),\nthe labels on the edges indicate the angles between the mirrors.\n\nA vertex drawn by `x` means it has a `real ball` correspondes to it,\nA vertex drawn by `o` means it does not have a real ball correspondes to it.\nThere are always 5 virtual balls and at least one real ball.\n\nIf we iteratively reflect the real balls across the virual balls, we will eventually get a dense packing of\nthe 3d space.\n\nThe set of virtual balls are called coclusters, the set of real balls are called clusters.\n\nYou can see there is a Euclidean triangle (333) in the diagram, this holds for almost all groups of rank 5 and level 2.\n\nThe input data requires you specify:\n\nparam 1:\n\nThe type of the Euclidean triangle, must be one of 244, 236 or 333. In this example it's 333.\nThese virual mirrors are labelled as v2, v3, v4.\n\n| For the remaining two vertices, at least one must be 'x', choose such one as v0. If both two are 'x',\n| choose either of them as v0, the remaining one is labelled v1.\n\nparam 2:\n\nThe labels between v0 and (v2, v3, v4), in this example it's (2, 2, 2) (in a Coxeter diagram\ndisjoint mirrors are orthogonal with each other, hence has dihedral angle PI/2, hence label 2)\n\nparam 3:\n\nThe labels between v1 and (v2, v3, v4), in this example it's (2, 2, 5). Note v1 and v4 are connected\nby an edge of label 5.\n\nparam 4:\n\nThe label between v0 and v1, in this example it's 3 (edges with labels 3 are represented by an unlabelled line)\n\nparam 5:\n\nFour bools indicate those virtual mirrors in (v1, v2, v3, v4) that have real balls corresponde to them.\nIn this example v2, v3 are represented by 'x', v1, v4 are represented by 'o', hence v2, v3 have real balls,\nwhile v1, v4 do not. So the four bools should be (false, true, true, false). Note by our choice v0 is\nalways 'x', so v0 has a real ball correspondes to it. This real ball is always the z=0 plane.\n\nSo the above diagram gives input\n\ninit(333, vec3(2, 2, 2), vec3(2, 2, 5), 3, bvec4(0, 1, 1, 0))\n\n\n!important:\n\nFor the 333 triangle, you can arbitrarily order them as (v2, v3, v4), it doesn't matter.\n\nBut for the 236 triangle, the ordering is fixed, you must label them as\n\n  6   3\n*---*---*\nv2  v3  v4\n\nAlso for the 244 triangle, the ordering must be\n\n  4   4\n*---*---*\nv2  v3  v4\n\n\nI have included ~60 examples below, a complete list would contain around ~180+ diagrams,\naccording to Hao's enumeration. You can find other diagrams in his thesis paper.\n\nNote: \n\n1. Some diagrams may give equivalent packings, though the visual effects are different.\n2. The bvec param 'isRealBall' does not take effect in the 'limit set' view in most times,\nit's mainly used for adding/removing circles in the circle packing view. You can change some\n1's in it to 0 to remove the corresponding real balls, hence produce holes in the pattern.\n*/\n\n\n#define TT (iTime+1.)\n//#define MS iMouse\n#define MS ((2.0*iMouse.xyz-iResolution.xyz)/iResolution.y)\n\n//*****************************************************************************\n\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 5., bvec4(0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 3, 3), vec3(3, 3, 3), 3., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(3, 3, 2), vec3(2, 3, 3), 3., bvec4(1, 1, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(3, 2, 3), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 6., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 3, 3), vec3(2, 3, 3), 2., bvec4(0, 0, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 3., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 3, 2), vec3(2, 4, 2), 2., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 5., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 6., bvec4(0, 1, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 6), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 6), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 6), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 5), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 4), vec3(3, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(2, 3, 2), 5., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(244, vec3(2, 4, 2), vec3(3, 2, 3), 2., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 6), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 5), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 5), 3., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 4), 3., bvec4(1, 0, 0, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 3, 2), vec3(3, 2, 4), 3., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 3), 4., bvec4(0))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 0, 0, 1))\n#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 3., bvec4(1, 0, 0, 0))\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = MS.xy;\n    float k = 1.0;\n    if (MS.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n#ifdef DrawVerticalSections\n    vec3 q = vec3(p.x, TT*0.1, p.y + 1.);\n#else\n    vec3 q = vec3(p, mod(TT*0.2 - 0.01, SECTION_HEIGHT - 0.02) + 0.01);\n#endif\n    return k*DE(q, index) * strong_factor;\n    \n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / clamp(iResolution.y, 400., 800.);\n\n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n#ifdef DrawLimitSet\n    float hue = fract(0.75*l-0.3*TT) + .45;\n#else\n    float hue = fract(0.15*l-0.3*TT) + .5;\n#endif\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n#ifdef DrawLimitSet\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n#else\n    col       = mix(col, bcol, 1. - step(-d, aa));\n#endif\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             4.\n#define inf              -1.\n\n// comment out this to show the circles\n#define DrawLimitSet\n\n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nfloat SECTION_HEIGHT;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 p, inout int index) {\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n#ifdef DrawLimitSet\n    float d = abs(p.z);\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = abs(sdistanceToBall(p, clusters[j]));\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n#else\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    \n#endif\n    return d / scale;\n}\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n    \n    SECTION_HEIGHT = B0.isplane ? 2.*B0.r : B0.n.z;\n    \n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdK3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9714, 9714, 9750, 9750, 10140], [10142, 10142, 10164, 10164, 10333], [10335, 10335, 10373, 10373, 10600], [10603, 10603, 10660, 10660, 12157]], "test": "untested"}
{"id": "7sVGzG", "name": "parallelogram path", "author": "jorge2017a2", "description": "parallelogram path", "tags": ["parallelogrampath"], "likes": 4, "viewed": 222, "published": 3, "date": "1631755758", "time_retrieved": "2024-07-30T19:01:03.971223", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p.z=opRep1D( p.z, 30.0 );\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.x+=4.5;\n    p.y=p.y-20.0;\n    \n    float wi=1.0;\n    float he=5.0;\n    float sk=5.0;\n    \n    float sdb0= sdBox( p-vec3(4.0,-25.0,0.0), vec3(15.0,2.0,15.0) );\n    float sdp1= sdParallelogram(p.xy, wi, he, sk );\n    float sdb1= sdBox( p, vec3(10.0,10.0,10.0) );\n    float sinter1= intersectSDF(sdp1,sdb1 );\n    \n    p= rotate_x( p-vec3(10.0,0.0,0.0), radians(180.0));\n    \n    float sdp2= sdParallelogram(p.xy, wi, he, sk );\n    float sdb2= sdBox( p, vec3(10.0,10.0,10.0) );\n    float sinter2= intersectSDF(sdp2,sdb2 );\n    res =opU3(res, vec3(sinter1,100.0,-1.0));\n    res =opU3(res, vec3(sinter2,100.0,-1.0));\n    \n    p=pp;\n    mObj.uvP= vec2(atan(p.x, p.z), p.y * 0.3);\n      p.x=abs(p.x)-5.0;\n    p.z=abs(p.z)-4.0;\n    \n    float sdc1= sdCylinderXZ( p-vec3(5.0,5.0,3.0), vec2(2.0,10.0) );\n    float sdc2= sdCylinderXZ( p-vec3(5.0,-2.0,3.0), vec2(2.5,1.0) );\n    float sdc3= sdCylinderXZ( p-vec3(5.0,14.0,3.0), vec2(2.5,1.0) );\n    res =opU3(res, vec3(sdc1,-1.0,10.0));\n    res =opU3(res, vec3(sdc2,11.0,-1.0));\n    res =opU3(res, vec3(sdc3,11.0,-1.0));\n    res =opU3(res, vec3(sdb0,-1.0,5.0));//suelo\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n     return color;\n    \n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\t\n   float es=16.0; //32.0\n    if (i==100 )\n    { vec3 col=hsv( tex3D(iChannel0, p/es, nor)); return col*1.25; }\n\tif (i==101 ) { return tex3D(iChannel1, p/es, nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/es, nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/es, nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/7sSXDz\nvec3 amigaTexture(vec2 pos, float n)\n{\n    float l = clamp(sin(pos.x*n)*sin(pos.y*n)*1000.0, 0.0, 1.0);\n    return vec3(0.0, 0.0, 0.0)*l+(vec3(1.0, 0.0, 1.0)*(1.0-l));\n}\n\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) )*vec3(1.0,0.0,1.0);\n    }\n    \n    if (id_material==10.0)\n   { return amigaTexture( mObj.uvP, 6.0); }\n   \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n    vec3 sky;\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n     col= render_sky_color(rd);\n    \n   \n    \n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,300.0);\n    itime=t;\n\t    \n \tlight_pos1= vec3(5.0, 40.0, 20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, -30.0, -20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0+10.0*abs(sin(iTime*0.5)),-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n   \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n     vec2 uvP;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 530, 530, 614], [615, 615, 654, 654, 749], [751, 795, 842, 842, 869], [870, 870, 913, 913, 940], [941, 941, 989, 989, 1017], [1018, 1056, 1092, 1092, 1137], [1138, 1203, 1237, 1237, 1333], [1334, 1334, 1368, 1368, 1459], [1460, 1460, 1494, 1494, 1585], [1587, 1587, 1653, 1653, 1995], [1997, 1997, 2022, 2022, 3272], [3274, 3274, 3298, 3298, 3460], [3462, 3462, 3511, 3511, 4142], [4145, 4145, 4181, 4181, 4426], [4428, 4428, 4455, 4455, 4472], [4474, 4474, 4510, 4510, 4602], [4603, 4603, 4649, 4649, 4774], [4776, 4776, 4813, 4813, 5089], [5091, 5091, 5174, 5174, 5764], [5766, 5766, 5815, 5815, 6091], [6093, 6093, 6186, 6186, 6316], [6318, 6318, 6350, 6350, 6547], [6549, 6589, 6627, 6627, 6758], [6761, 6761, 6808, 6808, 7119], [7121, 7121, 7214, 7214, 7702], [7704, 7704, 7735, 7735, 8363], [8365, 8365, 8391, 8391, 8501], [8503, 8503, 8561, 8561, 8613], [8615, 8615, 8672, 8672, 9191]], "test": "untested"}
{"id": "7dKGzG", "name": "Trippy patterns", "author": "SnoopethDuckDuck", "description": "sloppy code", "tags": ["cool"], "likes": 12, "viewed": 429, "published": 3, "date": "1631753123", "time_retrieved": "2024-07-30T19:01:04.722215", "image_code": "float myLength(vec2 uv, vec2 fragCoord) {\n//return length(mod(4. * (1.-uv) * uv,0.4));\nfloat x = cos(iResolution.x * abs(uv.x) + 0.2 * iTime);\nfloat y = sin(abs(uv.y) + x - 0.5 * iTime);\nfloat b = 0.5 * (1. + cos(0.3 * iTime));\nfloat b2 = 0.5 * (1. + cos(0.15 * iTime));\nreturn mod(x + y, (1.-b) * x * y + b * 0.4 * length(uv)) * ( b2 + (1.-b2)* 0.5 * (0.2 + sin(2. * uv.x * uv.y + iTime)));\n//return mod(x * y, abs(x * x - y * y) + 10.);// * length(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6. * (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    float theta = atan(uv.y, uv.x);\n    float k = 0.5 * (1. + cos(0.25 * t));\n    float s = 0.5 * (1. + cos(t));\n    //s = 1. - 4. * s * (1.-s);\n    s = (1.-k) * s + k * (1.-s);\n\n    float d = myLength(uv, fragCoord);\n    float p = 0.2;//0.5 * 3.14159;\n    float a = 0.2;\n    \n    float r = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float r2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    t -= a;\n    float g = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float g2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    t += 2. * a;\n    float b = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float b2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    \n    \n    \n    r = 1.- smoothstep(d, r2, r);\n    g = 1.- smoothstep(d, g2, g);\n    b = 1.- smoothstep(d, b2, b);\n    r = 16. * r * r * (1.-r) * (1.-r);\n    g = 16. * g * g * (1.-g) * (1.-g);\n    b = 16. * b * b * (1.-b) * (1.-b);\n    \n    float c1 = 0.5 * (1. + cos(t));\n    float c2 = 0.5 * (1. + cos(t + 3.14159 / 3.));\n    float c3 = 0.5 * (1. + cos(t - 3.14159 / 3.));\n    \n\n    fragColor = vec4(g + c1 * r,r + c2 * b,b + c3 * g,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 86, 456], [459, 459, 516, 516, 1960]], "test": "untested"}
{"id": "7sy3Ry", "name": "Cubemap + Buffer Execution Order", "author": "pyBlob", "description": "Visualizes the values that cubemap sides may access with respect to frame number. Code gets a little complicated, because we have to store 8 values into 4 float16. All cubemap faces will see the same textures.", "tags": ["cubemap", "shadertoy"], "likes": 6, "viewed": 425, "published": 3, "date": "1631743182", "time_retrieved": "2024-07-30T19:01:05.661703", "image_code": "/*\n      A  [ T ] =   mainA  (A[T-1], B[T-1], C[T-1], D[T-1], Cube[T-1])\n      B  [ T ] =   mainB  (A[ T ], B[T-1], C[T-1], D[T-1], Cube[T-1])\n      C  [ T ] =   mainC  (A[ T ], B[ T ], C[T-1], D[T-1], Cube[T-1])\n      D  [ T ] =   mainD  (A[ T ], B[ T ], C[ T ], D[T-1], Cube[T-1])\n    Cube [ T ] = mainCube (A[ T ], B[ T ], C[ T ], D[ T ], Cube[T-1])\n    Image[ T ] = mainImage(A[ T ], B[ T ], C[ T ], D[ T ], Cube[ T ])\n    \n    Main Logic:\n        ivec8 a, ..., image;\n        vec4 bufferImage(...);\n\n    Presentation:\n        everything else\n*/\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n\n    vec2 res = iResolution.xy * vec2(1. / columns, columns);\n    vec2 coord = vec2(mod(fragCoord.x, res.x), fragCoord.y + (columns-1. - floor(fragCoord.x / res.x)) * iResolution.y);\n\n    int i = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) / (bufs+1);\n    i = bufs-1 - i;\n    int j = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) % (bufs+1);\n    if (j < bufs)\n        j = bufs-1 - j;\n    if (i < 0)\n    {\n        i = 0;\n        j = bufs;\n    }\n\n    bool bar = false;\n    \n    if (i < bufs)\n        if (j < bufs)\n            bar = coord.x < float(v(i, j) * 10);\n\n    char = texelFetch(iChannel3, ivec2(fragCoord), 0).r;\n    \n    vec4 color = vec4[](\n        vec4(0 ,  .15,  1, 1),\n        vec4(1 ,  .20,  0, 1),\n        vec4(0 ,  .50,  0, 1),\n        vec4(.8,  .00,  0, 1),\n        vec4(.2,  .02,  1, 1),\n        vec4(.3,  .05,  0, 1),\n        vec4(1 ,  .05,  1, 1),\n        vec4(.4,  .40, .4, 1),\n        vec4(1 , 1.  ,  1, 1)\n    )[j];\n\n    fragColor = mix(vec4(0), color, abs(float(bar) - char));\n    fragColor.xyz = pow(fragColor.xyz, vec3(1. / 2.2));\n\n    if (_test)\n    {\n        vec2 coord = fragCoord / iResolution.xy * vec2(4, 3);\n        fragColor = vec4(0);\n        if (2. < coord.y && 3. < coord.x && coord.x < 4.)\n            fragColor = texture1(iChannel2, iPY, fract(coord));\n        if (1. < coord.y && coord.y < 2.)\n            fragColor = texture1(iChannel2, int[](iPX, iNZ, iNX, iPZ)[int(coord.x)], fract(coord));\n        if (coord.y < 1. && 3. < coord.x && coord.x < 4.)\n            fragColor = texture1(iChannel2, iNY, fract(coord));\n    }\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool _test    = false;\nint _testface = 5;\nfloat columns = 2.;\n\nint iPX = 0;\nint iNX = 1;\nint iPY = 2;\nint iNY = 3;\nint iPZ = 4;\nint iNZ = 5;\n\nvec3 cubeDir(int side, vec2 uv)\n{\n    uv = 2. * uv - 1.;\n    return vec3[](\n        vec3(   1., uv.y, -uv.x),\n        vec3(  -1., uv.y,  uv.x),\n        vec3( uv.x,    1., -uv.y),\n        vec3( uv.x,   -1., uv.y),\n        vec3( uv.x, uv.y,    1.),\n        vec3(-uv.x, uv.y,   -1.)\n    )[side];\n}\n\nvec4 texture1(samplerCube iCube, int side, vec2 uv)\n{\n    return texture(iCube, cubeDir(side, uv));\n}\n\nint bufs = 8;\n\n#define ivec8 int[8]\n\n// pack 8x unsigned 6-bit into 4x fp16\nvec4 pack(ivec8 a)\n{\n    vec4 v = vec4(0);\n    for (int i=0 ; i<8 ; ++i)\n        v[i / 2] += float(a[i] << ((i % 2) * 6));\n    return v - 2048.;\n}\n\n// unpack 4x fp16 into 8x unsigned 6-bit\nivec8 unpack(vec4 v)\n{\n    v += 2048.;\n    ivec8 a;\n    for (int i=0 ; i<8 ; ++i)\n        a[i] = (int(v[i / 2]) >> ((i % 2) * 6)) % (1 << 6);\n    return a;\n}\n\nivec8 a, px, nx, py, ny, pz, nz, image;\nvec4 bufferImage(int iFrame, vec2 fragCoord, vec3 iResolution, sampler2D bufferA, samplerCube cube)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    a = unpack(texture(bufferA, uv));\n    px = unpack(texture1(cube, iPX, uv));\n    nx = unpack(texture1(cube, iNX, uv));\n    py = unpack(texture1(cube, iPY, uv));\n    ny = unpack(texture1(cube, iNY, uv));\n    pz = unpack(texture1(cube, iPZ, uv));\n    nz = unpack(texture1(cube, iNZ, uv));\n    image = ivec8(iFrame % 64, a[0], px[0], nx[0], py[0], ny[0], pz[0], nz[0]);\n    return pack(image);\n}\n\nint v(int i, int j)\n{\n    return ivec8(a[j], px[j], nx[j], py[j], ny[j], pz[j], nz[j], image[j])[i];\n}\n\nvec2 charId;\nvec2 charCoord;\nbool marked;\nfloat char;\nvec2 xy, textCoord;\nvec2 f;\n\nvoid initText(vec2 iResolution, vec2 fragCoord, vec2 size)\n{\n    charId = vec2(-1);\n    charCoord = vec2(0);\n    marked = false;\n    char = 0.;\n    xy = size - vec2(0, 1);\n    f = iResolution.y / size.y * vec2(.5, 1);\n    textCoord = fragCoord;\n}\n\nvoid newline()\n{\n    xy.x = 0.;\n    xy.y -= 1.;\n    marked = false;\n}\n\nvoid mark()\n{\n    marked = !marked;\n}\n\nvoid putc(int code)\n{\n    if (code == -1)\n        newline();\n    else if (code == -2)\n        mark();\n    else if (code >= 0)\n    {\n        if (all(lessThan(xy, textCoord / f)) && all(lessThan(textCoord / f, xy + 1.)))\n        {\n            charId = vec2(code % 16, 15 - code / 16);\n            charCoord = (textCoord / f - (xy + .5)) * f / f.y;\n            if (marked)\n            {\n                charCoord /= .8;\n                charCoord += .5;\n                charCoord.y += .3;\n            }\n            else\n                charCoord += .5;\n            charCoord = clamp(charCoord, 0., 1.);\n        }\n        if (marked)\n            xy.x += .8;\n        else\n            xy.x += 1.;\n    }\n}\n\n/*\nprint(\n\t\",\\n\".join(\n\t\t\"// \" + line + \"\\n\"\n\t\t+ \", \".join(\n\t\t\t\"-1, -3\" if x == \"!\"\n\t\t\telse \"-2\" if x == \"#\"\n\t\t\telse hex(ord(x))\n\t\t\tfor x in line)\n\t\t+ (\"\" if line.endswith(\"!\") else \", -1\")\n\t\tfor line in [\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T-1).frame\",\n\t\t\t\"    .+X    = face   (+X, T-1).frame\",\n\t\t\t\"    .-X    = face   (-X, T-1).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T-1).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T-1).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T-1).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T-1).frame\",\n\t\t\t\"Buffer A:\",\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T-1).frame\",\n\t\t\t\"    .+X    = face   (+X, T-1).frame\",\n\t\t\t\"    .-X    = face   (-X, T-1).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T-1).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T-1).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T-1).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T-1).frame\",\n\t\t\t\"+X:!\",\n\t\t\t\"-X:!\",\n\t\t\t\"+Y:!\",\n\t\t\t\"-Y:!\",\n\t\t\t\"+Z:!\",\n\t\t\t\"-Z:!\",\n\t\t\t\"Image:\",\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T  ).frame\",\n\t\t\t\"    .+X    = face   (+X, T  ).frame\",\n\t\t\t\"    .-X    = face   (-X, T  ).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T  ).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T  ).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T  ).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T  ).frame\",\n\t\t\t]))\n*/\n\nvoid face()\n{\nint codes[] = int[](\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1\n);\n\n    for (int k=0 ; k<codes.length() ; ++k)\n        putc(codes[k]);\n}\n\nvoid text()\n{\nint codes[] = int[](\n// Buffer A:\n0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x41, 0x3a, -1,\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n// +X:!\n0x2b, 0x58, 0x3a, -1, -3,\n// -X:!\n0x2d, 0x58, 0x3a, -1, -3,\n// +Y:!\n0x2b, 0x59, 0x3a, -1, -3,\n// -Y:!\n0x2d, 0x59, 0x3a, -1, -3,\n// +Z:!\n0x2b, 0x5a, 0x3a, -1, -3,\n// -Z:!\n0x2d, 0x5a, 0x3a, -1, -3,\n// Image:\n0x49, 0x6d, 0x61, 0x67, 0x65, 0x3a, -1,\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1\n);\n    \n    for (int k=0 ; k<codes.length() ; ++k)\n    {\n        if (codes[k] == -3)\n            face();\n        else\n            putc(codes[k]);\n    }\n}\n", "buffer_a_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n}\n", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap(out vec4 fragColor, vec2 fragCoord, vec3 rayOri, vec3 rayDir)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n\n    if (_test)\n        //fragColor = vec4(fragCoord / iResolution.xy,0,0);\n        fragColor = texture(iChannel3, rayDir);\n}\n", "cube_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    if (false)\n    {\n        vec4 lastResolution = texelFetch(iChannel0, ivec2(0), 0);\n        if (fragCoord == vec2(.5))\n        {\n            fragColor = vec4(iResolution, 0);\n            return;\n        }\n\n        if (lastResolution.xy == iResolution.xy)\n        {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            return;\n        }\n    }\n    \n    vec2 res = iResolution.xy * vec2(1. / columns, columns);\n    vec2 coord = vec2(mod(fragCoord.x, res.x), fragCoord.y + (columns-1. - floor(fragCoord.x / res.x)) * iResolution.y);\n\n    int i = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) / (bufs+1);\n    i = bufs-1 - i;\n    int j = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) % (bufs+1);\n    if (j < bufs)\n        j = bufs-1 - j;\n    if (i < 0)\n    {\n        i = 0;\n        j = bufs;\n    }\n\n    bool bar = false;\n    \n    initText(res, coord, vec2(0, bufs * (bufs+1) + 0));\n    \n    if (i < bufs)\n        text();\n        \n        \n    if (charId.x >= 0.)\n        char = textureLod(iChannel3, (charId + charCoord) / 16., 5. - log2(f.y)).r;\n    \n    fragColor = vec4(char);\n}\n", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sy3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dyGzy", "name": "Music viz", "author": "JennySchub", "description": "Just a bit of fun", "tags": ["music", "radialwave"], "likes": 3, "viewed": 251, "published": 3, "date": "1631733183", "time_retrieved": "2024-07-30T19:01:06.414690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592653\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-1.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.8))\n\t);\n\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bass = texture(iChannel0,vec2(0.2)).r;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    vec4 last = texture(iChannel1,uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float pxl = 2./iResolution.x;\n\n    // Time varying pixel color\n    float d = length(uv)/(1.+bass);\n    float a = atan(uv.y,uv.x);\n    float b = 0.;\n    d *= (cos(a*6.+iTime*5.*d*pxl*sin(iTime))+cos(a*3.+1.+iTime)+.5*cos(a*12.+1.+iTime))*.1 + 1.;\n    \n    //for(float i=1.; i<26.; i+=1.)\n        b += smoothstep(0.,pxl,sin(d*140.+10.*iTime+(1.+sin(iTime))*10.));\n    \n    vec3 col = vec3(b*colMap(sin(iTime)*d*2.-(iTime + (1.+sin(iTime)))));\n\n    // Output to screen\n    \n    float smear = .93;\n    fragColor = vec4(colMap(col.r+.1)+colMap(col.b-.1),1.0)*1.5*(1.-smear) + smear*last;\n}", "buffer_a_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 198]], "test": "untested"}
{"id": "fdy3RG", "name": "LookingGlass blobs", "author": "z0rg", "description": "Test rendering on a looking glass", "tags": ["blobs", "quilt", "lookingglass"], "likes": 3, "viewed": 351, "published": 3, "date": "1631719749", "time_retrieved": "2024-07-30T19:01:07.208567", "image_code": "#define sat(a) clamp(a, 0.,1.)\n#define PI 3.14159265\n#define QUILT\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _wirecube(vec3 p, vec3 s, vec3 s2)\n{\n    vec3 l = abs(p)-s;\n    vec3 l2 = abs(l)-s2;\n    \n    float acc = 1000.;\n    \n    acc = min(acc, max(l2.x,l2.y));\n    acc = min(acc, max(l2.x,l2.z));\n    acc = min(acc, max(l2.y,l2.z));\n    acc = max(acc, max(l.x,max(l.y,l.z)));\n    return acc;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000.,-1.);\n    //p = p+vec3(1.,-1.,1.)*1.4;\n    p.xz *= r2d(iTime*.5);\n    p.yz *= r2d(PI*.25);\n    p.xy *= r2d(PI*.25);\n    vec3 cubesz = vec3(.5);\n    vec3 cubeth = vec3(.025);\n    acc = _min(acc, vec2(_wirecube(p, cubesz, cubeth), 0.));\n    \n    float box = _cube(p, cubesz-cubeth);\n    \n    \n    float accsph = 1000.;\n    for (int i = 0; i < 8; ++i)\n    {\n        float fi = float(i);\n        vec3 psph = p+.5*vec3(sin(fi), cos(fi*.5+iTime), cos(fi*10.+iTime));\n        float sph = length(psph)-.25;\n        accsph = opSmoothUnion(accsph, sph, 0.15);\n    }\n    acc = _min(acc, vec2(max(accsph, box), 1.));\n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro,vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return vec3(res.x, distance(p, ro), res.y);\n        }\n        if (res.y == 0.)\n            accCol += .1*vec3(sin(p.y+iTime*3.)*.5+.5,0.45,0.337)*(1.-sat(res.x/.2));\n        p+=rd*res.x*.35;\n    }\n    return vec3(-1.);\n}\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 res = trace(ro, rd, 256);\n    vec3 col = vec3(0.);//texture(iChannel0, rd).xyz;\n    if (res.y > 0.)\n    {\n        vec3 p = ro +rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 refl = reflect(rd, n);\n        vec3 rgb = vec3(0.);\n        if (res.z == 1.)\n            rgb = mix(vec3(.5), vec3(0.), sat((sin((p.x+p.y)*10.)+.9)*400.));\n        col = rgb+texture(iChannel0, refl*vec3(1.,-1.,1.)).xyz*pow(sat(dot(rd, refl)+.5),.9) ;\n        //col = vec3(1.);\n    }\n    col += accCol;\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,0.,-7.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    col = texture(iChannel0, rd).xyz;\n    if (res.y > 0.)\n    {\n        vec3 p = ro +rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 refl = reflect(rd, n);\n        vec3 rgb = vec3(0.);\n        if (res.z == 1.)\n            rgb = mix(vec3(.5), vec3(0.), sat((sin((p.x+p.y)*10.)+.9)*400.));\n        col = rgb+texture(iChannel0, refl*vec3(1.,-1.,1.)).xyz*pow(sat(dot(rd, refl)+.5),.9) ;\n        //col = vec3(1.);\n    }\n    col += accCol;\n    \n    return col;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro + vec3(0, 0, 9), rd), 1);\n}\n\n\n#ifndef QUILT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n#else // QUILT\n\n    #define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize = 2.0;\nconst float\taspectRatio = 0.75;\nconst vec3  \tVROffset = vec3(0, 0, 9);\nfloat quiltColumns\t=\t8.;\nfloat quiltRows\t\t=\t6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n#endif\n\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 86, 86, 144], [146, 146, 173, 173, 226], [228, 228, 257, 257, 318], [320, 320, 362, 362, 612], [615, 615, 667, 667, 766], [768, 768, 786, 786, 1435], [1437, 1437, 1468, 1468, 1625], [1627, 1627, 1658, 1658, 1773], [1787, 1787, 1827, 1827, 2204], [2206, 2206, 2243, 2243, 2780], [2782, 2782, 2801, 2801, 3480], [3481, 3481, 3523, 3523, 3687], [3689, 3689, 3767, 3767, 3826]], "test": "untested"}
{"id": "fsGGRy", "name": "Zone plate", "author": "mosan_hoshi", "description": "Circular zone plate", "tags": ["2d", "resolution", "viewerwarning"], "likes": 4, "viewed": 244, "published": 3, "date": "1631712206", "time_retrieved": "2024-07-30T19:01:08.071261", "image_code": "// written by mossan-hoshi( https://twitter.com/mossan_hoshi )\n\n#define K 1000.\n#define THRESHOLD\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const \n  // normalize position(x,y:.0~1.0)\n  vec2 uv= ((fragCoord.xy - .5 * iResolution.xy)/ min(iResolution.x,iResolution.y));\n  \n  // circular zone plate\n  float value = (1. + cos(K * mod(iTime, 20.) * dot(uv,uv)))* .5;\n  if(iMouse.z > 0.){ \n    // binalize on mouse down\n    value = step(.5,value);\n  }\n  fragColor=vec4(value,value,value,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 156, 204, 509]], "test": "untested"}
{"id": "fsy3RG", "name": "Something  gaz 228", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 8, "viewed": 320, "published": 3, "date": "1631708706", "time_retrieved": "2024-07-30T19:01:08.833223", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g,e=1.;++i<60.||e>.01;e<.01?O.xyz+=cos(d*p)/i:p){\n        p=g*d;\n        p=R(p, vec3(.577), iTime*.3);\n        for(int j=0;j++<9;)\n            p.xy=length(p.xy)*sin(vec2(0,1.57)+sin(atan(p.x,p.y)*3.)/3.),\n            p.y-=7.,\n            p=p.yzx,\n            p=R(p,vec3(1,0,0),.2);\n        g+=e=dot(abs(p),vec3(.3,.7,.2))-.8;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsy3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 527]], "test": "untested"}
{"id": "Ndy3RG", "name": "Wave Room 3", "author": "dr2", "description": "Kinetic art in a pentakis dodecahedral room", "tags": ["waves", "projection", "pentakis"], "likes": 10, "viewed": 302, "published": 3, "date": "1631707053", "time_retrieved": "2024-07-30T19:01:09.676968", "image_code": "// \"Wave Room 3\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar, tWav;\nint idObj;\nconst int idFace = 1, idEdge = 2;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  p.yz = Rot2D (p.yz, 0.067 * pi);\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2, s;\n  dMin = dstFar;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  s = abs (dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) + 2.);\n  d = SmoothMax (s - 0.07, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.03, 0.02);\n  DMIN (idEdge);\n  d = s - 0.02;\n  DMIN (idFace);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 4; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 8.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (- normalize (vec3 (0.4 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hn4;\n  vec3 col, vn, ltDir;\n  vec2 u;\n  float dstObj, rAz, rEl;\n  tWav = 0.2 * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idEdge) {\n      col4 = vec4 (0.95, 0.95, 1., 0.2);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == idFace) {\n      rAz = atan (ro.x, ro.z);\n      rEl = asin (ro.y / length (ro));\n      u = vec2 (rAz + pi, tan (2. * atan (0.5 * rEl))) / (2. * pi);\n      hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n      vn = StdVuMat (rEl, rAz) * normalize (hn4.xyz);\n      col4 = vec4 (mix (vec3 (1., 1., 0.3), vec3 (1., 0.4, 0.), smoothstep (0.3, 1., hn4.w)), 0.2);\n    }\n    ltDir = normalize (- ro);\n    col = col4.rgb * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.8);\n  zmFac = 1.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = vec2 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac, uv.y);\n    rd = vuMat * normalize (vec3 (uvv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3RG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[557, 557, 581, 581, 1166], [1168, 1168, 1190, 1190, 1638], [1640, 1640, 1673, 1673, 1856], [1858, 1858, 1879, 1879, 2136], [2138, 2138, 2161, 2161, 2694], [2696, 2696, 2719, 2719, 2946], [2948, 2948, 2983, 2983, 3878], [3895, 3895, 3951, 3951, 5015], [5017, 5017, 5048, 5048, 5112], [5114, 5114, 5159, 5159, 5251], [5253, 5253, 5298, 5298, 5336], [5338, 5338, 5368, 5368, 5481], [5483, 5483, 5519, 5519, 5725], [5759, 5759, 5783, 5783, 5895], [5897, 5897, 5922, 5922, 6108], [6110, 6110, 6139, 6139, 6351], [6353, 6353, 6392, 6392, 6649]], "test": "untested"}
{"id": "7tX3Wn", "name": "Sun color vs scattering", "author": "niels747", "description": "Used for my weather simulation: https://www.youtube.com/watch?v=jSkOlC72bvE", "tags": ["suncolor"], "likes": 1, "viewed": 245, "published": 3, "date": "1631702088", "time_retrieved": "2024-07-30T19:01:10.620445", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map_range(float value, float min1, float max1, float min2, float max2)\n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float scatter = uv.x;\n\n\n    vec3 col = hsv2rgb(vec3(0.015 + scatter * 0.15, min(2.0 - scatter*2.0, 1.), 1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 271, 271, 337], [341, 341, 398, 448, 665]], "test": "untested"}
{"id": "7dV3Dm", "name": "Tiny Watery Wavy Texture", "author": "choephix", "description": "What it says on the box", "tags": ["2d", "waves", "postprocessing", "postfx", "water", "water", "ocean", "effect", "wavy", "postprocess", "lake"], "likes": 2, "viewed": 286, "published": 3, "date": "1631697574", "time_retrieved": "2024-07-30T19:01:11.469176", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime;\n    float str = 2.0;\n\tvec3 raintex = texture(iChannel1,vec2(uv.x*str,uv.y*str*4.0+time*0.0325)).rgb/64.0;\n\tvec2 where = (uv.xy-raintex.xy);\n\tvec3 texchur1 = texture(iChannel0,vec2(where.x,where.y)).rgb;\n\t\n\tfragColor = vec4(texchur1,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 360]], "test": "untested"}
{"id": "NdK3Wm", "name": "vertical ribbon - more random", "author": "morisil", "description": "Inspired by Loie Fuller \n\nhttps://en.wikipedia.org/wiki/Loie_Fuller\n", "tags": ["ribbon"], "likes": 3, "viewed": 245, "published": 3, "date": "1631662569", "time_retrieved": "2024-07-30T19:01:12.371762", "image_code": "// Fork of \"vertical ribbon - Loie Fuller\" by morisil. https://shadertoy.com/view/NsVGWh\n// 2021-09-14 23:31:40\n\nconst int   RIBBON_COUNT = 13;\nconst float RIBBON_WIDTH = .005;\nconst float RIBBON_EDGE_WIDTH = .003;\nconst float RIBBON_EDGE_START = RIBBON_WIDTH - RIBBON_EDGE_WIDTH;\nconst float SCALE_CHANGE = .9;\nconst float SCALE_CHANGE_VARIATION = .02;\nconst float SCALE_CHANGE_SPEED = 1.7;\nconst float WAVE1_IMPACT = .1;\nconst float WAVE2_IMPACT = .3;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float wave1Period = sin(iTime * .3) * 30.;\n    float wave2Period = sin(iTime * .4) * 10.;\n    float wave1Speed = sin(iTime * .5) * .02;\n    float wave2Speed = sin(iTime * .7) * .01;    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0);\n    for (int i = 0; i < RIBBON_COUNT; i++) {\n        st *= (\n            SCALE_CHANGE\n            + (\n                sin(iTime * SCALE_CHANGE_SPEED)\n                * SCALE_CHANGE_VARIATION\n            )\n        );\n        float dist = length(st);\n        float shapeSpace = abs(\n            st.x\n            + sin(st.y * wave1Period + iTime * wave1Speed) * WAVE1_IMPACT * (1.2 - uv.y)\n            + sin(st.y * wave2Period + iTime * wave2Speed) * WAVE2_IMPACT * (1.1 - uv.y)\n        );\n        float ribbon = smoothstep(\n            RIBBON_WIDTH,\n            RIBBON_EDGE_START,\n            shapeSpace\n        );\n        color += vec3(ribbon);\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdK3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 511, 511, 1554]], "test": "untested"}
{"id": "fdKGDw", "name": "Fork дед инсайд oneWisdom 723", "author": "oneWisdom", "description": "CG course sdf practice", "tags": ["sdf", "trip"], "likes": 1, "viewed": 192, "published": 3, "date": "1631655604", "time_retrieved": "2024-07-30T19:01:13.163645", "image_code": "const float PI = 3.14;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat prism(vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.7+p.y*0.3,-p.y)-h.x*0.5);\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat smax ( float a, float b, float k )\n{\n\tfloat res = exp ( k*a ) + exp ( k*b );\n\treturn log ( res ) / k;\n}\n\n\nfloat scene_eyes(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    float k = min(\n        sphere(q, vec3(0.45, -0.7, 0.2), 0.3),\n        sphere(q, vec3(-0.45, -0.7, 0.2), 0.3)\n    );\n    return k;\n}\n\n\nfloat scene_head(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    \n    // prism transform\n    vec3 q2 = q + vec3(0., 1.6, 1.);\n    mat3 m2 = rotateY(PI / 2.) * rotateZ(PI / 180. * 30.);\n    q2 *= m2;\n    \n    float k = max(\n        -prism(q2, vec2(1., 1.5)),\n        sphere(q, vec3(0., 0., 0.), 1.)\n    );\n    \n    // ear radius\n    float a = 2.;\n    // ear thickness\n    float d = 0.2;\n    \n    vec3 ear_position1 = vec3(-1.1, 0, 1.0);\n    vec3 ear_position2 = vec3(1.1, 0, 1.0);\n        \n    float s1 =  smax(\n        -sphere(q,ear_position1 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position1, 1.), 10.0\n    );\n        \n    float s2 = smax(\n        sphere(q, ear_position1 + vec3(0., -a + d, 0.), a),\n        s1, 10.0\n    );\n    \n    float s3 =  smax(\n        -sphere(q,ear_position2 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position2, 1.), 10.0\n    );\n        \n    float s4 = smax(\n        sphere(q, ear_position2 + vec3(0., -a + d, 0.), a),\n        s3, 10.0\n    );\n    \n    \n    return min(s4, min(s2, k));\n}\n\n\nfloat scene(vec3 pos, mat3 m, int n) {\n    float dist;\n    if (n == 0) {\n\n        dist = scene_head ( pos, m );\n    }\n    else {\n        dist = scene_eyes ( pos, m );\n    } \n    return dist;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, mat3 m, int n)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n    int stepNum = 70;\n\tfor ( int steps = 0; steps < stepNum; steps++ )\n\t{\n        float dist = scene(p, m, n);\n\n        p += dist * dir;\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, mat3 m, int n)\n{\n    float eps = 0.01;\n    float e   = max (d * 0.5, eps );\n    float dx1 = scene(z + vec3(e, 0, 0), m, n);\n    float dx2 = scene(z - vec3(e, 0, 0), m, n);\n    float dy1 = scene(z + vec3(0, e, 0), m, n);\n    float dy2 = scene(z - vec3(0, e, 0), m, n);\n    float dz1 = scene(z + vec3(0, 0, e), m, n);\n    float dz2 = scene(z - vec3(0, 0, e), m, n);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 background(vec2 uv) {\n    //source: https://www.shadertoy.com/view/Xt2BDG\n    \n    vec4 result = vec4(0,0,0,1);\n\n    float t = 1.;\n    float offset = -5. * iTime;\n    float base = 100. * length(uv);\n\n    float d = sin(-iTime + 15. * length(uv));\n    d *= d * d;\n\n    mat2 rot = rotate(5. * length(uv));\n    uv += .5;\n    \n    uv = abs(rot * uv);\n    \n    for (int p = 0; p < 3; p++)\n    {\n        result[p] = sin(offset + t * base) - cos(20. * uv.x) - cos(20. * uv.y);\n        t += 0.05;\n    }\n\n    result.xyz *= result.xyz;\n    result.xyz = 1. - result.xyz;\n    \n    return result * d;\n}\n\nvec3 lightPos = vec3(0, -6., 0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    mat3 m;\n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    if ( iMouse.z > 0.) {\n        m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x );\n    }\n    else {\n        m = mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n    \n    vec3 cameraPos = vec3(0.,-5.-sin(iTime)*4., 0.);\n    vec3 cameraForward = vec3(0., 1, 0.);\n    vec3 cameraUp = vec3 (0., 0., 1.);\n    float cameraFocus = 5.;\n    \n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\n    \n    vec3 from = vec3(uv.x, (cameraPos + cameraForward * cameraFocus).z, uv.y);\n    vec3 dir = normalize(from - cameraPos);\n    \n    bool hit;\n    vec3 p1 = trace(cameraPos, dir, hit, m, 0);\n    float d1 = length(cameraPos - p1);\n     float c1 = length(p1);\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 surfaceColor = vec3(1., 1., 1.);\n    \n    vec4 col;\n    \n    if (hit) {\n\n       vec3 l = normalize(lightPos - p1);\n       vec3 n = generateNormal(p1, 0.001, m, 0);\n       vec3 v = normalize(cameraPos - p1);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n\n       col = 0.5*vec4 ( diffuse ) * vec4(1.0, 0.1, 0.4, 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n    else {\n       col = background(uv / 2.);\n    }\n   \n    vec3 p2 = trace(cameraPos, dir, hit, m, 1);\n    float d2 = length(cameraPos - p2);\n    float c2 = length(p2);\n\n    if (hit && (d2 < d1)) {\n\n       vec3 l = normalize(lightPos - p2);\n       vec3 n = generateNormal(p2, 0.001, m, 1);\n       vec3 v = normalize(cameraPos - p2);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n       \n       float t = abs(sin(70. * c2 + 20. * iTime) - 0.9);\n\n       col = 0.5 * vec4 ( diffuse ) * vec4(t, abs(t - 0.9), abs(t - 0.3), 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 198], [200, 200, 227, 227, 374], [377, 377, 404, 404, 551], [554, 554, 614, 614, 667], [669, 669, 699, 699, 781], [784, 784, 826, 826, 896], [899, 899, 941, 941, 1008], [1011, 1011, 1047, 1047, 1205], [1208, 1208, 1244, 1244, 2229], [2232, 2232, 2270, 2270, 2424], [2427, 2427, 2497, 2497, 2845], [2847, 2847, 2902, 2902, 3323], [3327, 3327, 3353, 3353, 3438], [3441, 3441, 3467, 3519, 4034], [4071, 4071, 4128, 4178, 6364]], "test": "untested"}
{"id": "fsKGDw", "name": "Fork sUBLIMATIN oneWisdom 432", "author": "oneWisdom", "description": " ~ like onion skin layers of smokey glass marbles , sort of, but maybe not ~\n\n. Try going full screen then Alt-1 (to refresh/force 100% pixel canvas extents\nmouse click influences general direction \nchanged noise", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 5, "viewed": 342, "published": 3, "date": "1631655459", "time_retrieved": "2024-07-30T19:01:14.203864", "image_code": "// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 2.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                   //   col = max(col,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                  //   col2 = min(col,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),(550.0 * abs(sin(iTime / 13.0)))+100.);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(-1,1,2));\n    float diff=clamp(dot(n,light),0.05,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.05\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 32;\nfloat blur = 1.0; \nfloat falloff = 4.0; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = -0.00051;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .95;\nconst float iBlobEdgeSmoothing        = .08;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .69;\nconst float iBlob2PowFactor           = 30.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 3.0;\nconst float iColorShiftOfRadius       = -.5;\nconst float iFeedbackMouseShiftFactor = .0013;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 3.1))), dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * (iFeedbackMouseShiftFactor * (2.0 * sin(iTime / 2.0)))\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * ( iFeedbackColorShiftZoom * (1.5 * sin(iTime / 2.81))) * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.br - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n    prevColor2 *= mix(prevColor , prevColor2,(0.75 + ( 0.5 * cos(iTime))));\n\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    \n//         vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel2,uv);\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col,col2,0.025);\n  \n // fragColor=blend;\n  \n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.0125);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 242, 242, 317], [319, 319, 342, 342, 497], [499, 499, 556, 556, 1910]], "test": "untested"}
{"id": "NdKGDw", "name": "Fork SuperNovae oneWisdom 281", "author": "oneWisdom", "description": "https://www.shadertoy.com/view/lts3RB \nChanged speed", "tags": ["fractal", "burning", "mouseinput", "supernovae", "fusion"], "likes": 6, "viewed": 339, "published": 3, "date": "1631655316", "time_retrieved": "2024-07-30T19:01:14.996744", "image_code": "\n//---------------------------------------------------------\n// Shader:   SuperNovaeFusion.glsl            by   I.G.P\n// original: https://www.shadertoy.com/view/4tfGRr\n// use mouse to rotate and look around\n//---------------------------------------------------------\n\n#define time iTime \n#define mouse iMouse\n#define resolution iResolution\n//varying vec2 surfacePosition;\n//varying vec2 surfaceSize;\n\n//---------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  \n{ \n    return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );\n}\n\nvec3 dmul( vec3 a, vec3 b )  \n{\n    float r = length(a);   \n    b.xy = cmul(normalize(a.xy), b.xy);\n    b.yz = cmul(normalize(a.yz), b.yz);\n    b.xz += 0.3 * cmul(normalize(a.xz), b.xz);\n    return r*b;\n}\n\nfloat field(in vec3 p) \n{\n    float res = 0.0;\n    vec3 c = p;\n    for (int i = 0; i < 10; ++i) \n    {\n        p = abs(p) / dot(p,p) - 1.0;\n        p = dmul(p,p) + 0.7;\n        res += exp(-6.0 * abs(dot(p,c)-0.15));\n    }\n    return max(0.0, res / 3.0);\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 1.5;\n    float dt = 0.25;\n    vec3 col = vec3(0.0);\n    for( int i=20; i<25; i++ )\n    {\n        float c = field(ro+t*rd);               \n        t+=dt / (0.35+c*c);\n        c = max(5.0 * c - .9, 0.0);\n        c = c*c*c*c;\n        col = 0.04*col + 0.04*vec3(0.1*c*c, 0.2*c, 0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= resolution.x / resolution.y;\n    //p += surfacePosition - 0.5;\n    float camspeed=1.8;\n    // camera\n    float angle = camspeed*time + 0.01 * mouse.x;\n    vec3 ro = vec3(3.2*cos(angle) + 0.5, 0.0 , 3.2*sin(angle) +0.5);\n    vec3 ta = vec3(0.0, 1.2 - 0.01*mouse.y, 0.0);\n    vec3 ww = normalize (ta - ro );\n    vec3 uu = normalize (cross (ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize (cross (uu, ww));\n    vec3 rd = normalize (p.x*uu + p.y*vv + 4.0*ww);\n    \n    // raymarch\n    vec3 col = raycast(ro, rd);\n    \n    // shade\n    col =  0.3 *(log(1.0+0.2*col));\n    fragColor = vec4(sqrt(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 462, 493, 493, 553], [555, 555, 586, 586, 759], [761, 761, 786, 786, 1016], [1018, 1018, 1055, 1055, 1373], [1375, 1375, 1432, 1432, 2121]], "test": "untested"}
{"id": "NsV3Ww", "name": "what did i even try to do?", "author": "Arrangemonk", "description": "this is some sort of fbm but, but the frequency increase is linear, and its rotated and then it got weird.\nand then i added power of two and then it looked less weird.... meh", "tags": ["fbmweirdmadness"], "likes": 0, "viewed": 232, "published": 3, "date": "1631654831", "time_retrieved": "2024-07-30T19:01:16.181576", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 1.;\nfloat octaves = 32.;\n\nfloat GammaToLinear(float gamma)\n{\n    return pow(gamma,0.4545454545454545);\n}\n\nvec3 GammaToLinear(vec3 gamma)\n{\n    return vec3(GammaToLinear(gamma.x),GammaToLinear(gamma.y),GammaToLinear(gamma.z));\n}\n\nfloat LinearToGamma(float linear)\n{\n    return pow(linear,2.2);\n}\n\nvec3 LinearToGamma(vec3 linear)\n{\n    return vec3(LinearToGamma(linear.x),LinearToGamma(linear.y),LinearToGamma(linear.z));\n}\n\n\nfloat flip(float x)\n{\n    return sign(cos(x * PI));\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\n\nvec3 rotfbm(vec3 pos)\n{\nvec3 result = vec3(0.);\nfloat m = 0.;\nfor(float i = 1.; i <= octaves;i++)\n    {\n    float f =flip(i);\n    float tmp = 1./i;\n    m += (f * tmp);\n    result += f * GammaToLinear(texture(iChannel0,rot(pos.xy*i * iters,PI * E * i)).xyz)* tmp;\n    }\nreturn mix(result /m,result *m,.5);\n}\n\n\nvec3 rotfbmp2(vec3 pos)\n{\nvec3 result = vec3(0.);\nfloat m = 0.;\nfor(float x = 1.; x <= octaves;x++)\n    {\n    float i = pow(2.,x);\n    float f =flip(i);\n    float tmp = 1./i;\n    m += (f * tmp);\n    result += f * GammaToLinear(texture(iChannel0,rot(pos.xy*i * iters,PI * E * x)).xyz)* tmp;\n    }\nreturn mix(result /m,result *m,.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float scale = sin(iTime* 0.05 * TAU)*0.5;\n    uv = (uv-vec2(.5,.25)) * mix(.001,1.,1.+scale) + vec2(.5,.0);\n\n    vec3 val = vec3(0.);\n    if(uv.x < .5)\n    val = rotfbmp2(vec3(uv,iTime));\n    else\n    val = rotfbm(vec3(uv,iTime));\n    \n    \n    uv = fragCoord/iResolution.x;\n    if (uv.x > .499 && uv.x < .501 ) {\n        val = vec3(0.0);\n    }\n    val = LinearToGamma(val);\n\n    fragColor = vec4( val,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 265, 265, 309], [311, 311, 343, 343, 432], [434, 434, 469, 469, 499], [501, 501, 534, 534, 626], [629, 629, 650, 650, 682], [684, 684, 714, 714, 794], [797, 797, 820, 820, 1103], [1106, 1106, 1131, 1131, 1439], [1442, 1442, 1499, 1499, 1952]], "test": "untested"}
{"id": "NdG3Ww", "name": "Buffer Execution Order", "author": "pyBlob", "description": "Visualizes the values that buffers may access with respect to frame number.", "tags": ["shadertoy", "buffer"], "likes": 15, "viewed": 610, "published": 3, "date": "1631652360", "time_retrieved": "2024-07-30T19:01:17.086159", "image_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    vec4 b = texture(iChannel1, uv);\n    vec4 c = texture(iChannel2, uv);\n    vec4 image = vec4(iFrame, a.r, b.r, c.r);\n\n    int i = int(fragCoord.y / iResolution.y * (4. * 5.)) / 5;\n    i = 3 - i;\n    int j = int(fragCoord.y / iResolution.y * (4. * 5.)) % 5;\n    if (j < 4)\n        j = 3 - j;\n\n    vec4 color = vec4[](\n        vec4(0 ,  .15, 1, 1),\n        vec4(1 ,  .20, 0, 1),\n        vec4(0 ,  .50, 0, 1),\n        vec4(.8,  .00, 0, 1),\n        vec4(1 , 1.  , 1, 1)\n    )[j];\n\n    bool bar = false;\n    \n    initText(iResolution, fragCoord, vec2(0, 4 * 5));\n    \n    if (i < 4)\n    {\n        vec4 value = vec4[](a, b, c, image)[i];\n\n        if (j < 4)\n            bar = fragCoord.x < mod(value[j] * 20., iResolution.x);\n\n        for (int k=0 ; k<codes.length() ; ++k)\n            putc(codes[k]);\n    }\n\n    if (charId.x >= 0.)\n        char = texture(iChannel3, (charId + charCoord) / 16.).r;\n    \n    fragColor = mix(vec4(0), color, abs(float(bar) - char));\n    fragColor.xyz = pow(fragColor.xyz, vec3(1. / 2.2));\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    bufferImage(fragColor, fragCoord, iResolution, iFrame, iChannel0, iChannel1, iChannel2);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    bufferImage(fragColor, fragCoord, iResolution, iFrame, iChannel0, iChannel1, iChannel2);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    bufferImage(fragColor, fragCoord, iResolution, iFrame, iChannel0, iChannel1, iChannel2);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "void bufferImage(out vec4 fragColor, vec2 fragCoord, vec3 iResolution, int iFrame, sampler2D iChannel0, sampler2D iChannel1, sampler2D iChannel2)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    vec4 b = texture(iChannel1, uv);\n    vec4 c = texture(iChannel2, uv);\n    fragColor = vec4(iFrame, a.r, b.r, c.r);\n}\n\nvec2 charId;\nvec2 charCoord;\nbool marked;\nfloat char;\nvec2 xy, textCoord;\nvec2 f;\n\nvoid initText(vec3 iResolution, vec2 fragCoord, vec2 size)\n{\n    charId = vec2(-1);\n    charCoord = vec2(0);\n    marked = false;\n    char = 0.;\n    xy = size - vec2(0, 1);\n    f = iResolution.y / size.y * vec2(.5, 1);\n    textCoord = fragCoord;\n}\n\nvoid newline()\n{\n    xy.x = 0.;\n    xy.y -= 1.;\n    marked = false;\n}\n\nvoid mark()\n{\n    marked = !marked;\n}\n\nvoid putc(int code)\n{\n    if (code == -1)\n        newline();\n    else if (code == -2)\n        mark();\n    else\n    {\n        if (all(lessThan(xy, textCoord / f)) && all(lessThan(textCoord / f, xy + 1.)))\n        {\n            charId = vec2(code % 16, 15 - code / 16);\n            charCoord = (textCoord / f - (xy + .5)) * f / f.y;\n            if (marked)\n            {\n                charCoord /= .5;\n                charCoord += .75;\n            }\n            else\n                charCoord += .5;\n            charCoord = clamp(charCoord, 0., 1.);\n        }\n        if (marked)\n            xy.x += .5;\n        else\n            xy.x += 1.;\n    }\n}\n\n/*\nprint(\n\t\",\\n\".join(\n\t\t\"// \" + line + \"\\n\"\n\t\t+ \", \".join(\n\t\t\t\"-2\" if x == \"#\"\n\t\t\telse hex(ord(x))\n\t\t\tfor x in line)\n\t\t+ \", -1\"\n\t\tfor line in [\n\t\t\t\"Buffer A:\",\n\t\t\t\"    iBufferA#T#.frame = iFrame\",\n\t\t\t\"    iBufferA#T#.fromA = texture(iBufferA#T-1#).frame\",\n\t\t\t\"    iBufferA#T#.fromB = texture(iBufferB#T-1#).frame\",\n\t\t\t\"    iBufferA#T#.fromC = texture(iBufferC#T-1#).frame\",\n\t\t\t\"Buffer B:\",\n\t\t\t\"    iBufferB#T#.frame = iFrame\",\n\t\t\t\"    iBufferB#T#.fromA = texture(iBufferA#T  #).frame\",\n\t\t\t\"    iBufferB#T#.fromB = texture(iBufferB#T-1#).frame\",\n\t\t\t\"    iBufferB#T#.fromC = texture(iBufferC#T-1#).frame\",\n\t\t\t\"Buffer C:\",\n\t\t\t\"    iBufferC#T#.frame = iFrame\",\n\t\t\t\"    iBufferC#T#.fromA = texture(iBufferA#T  #).frame\",\n\t\t\t\"    iBufferC#T#.fromB = texture(iBufferB#T  #).frame\",\n\t\t\t\"    iBufferC#T#.fromC = texture(iBufferC#T-1#).frame\",\n\t\t\t\"Image:\",\n\t\t\t\"    iScreen#T#.frame = iFrame\",\n\t\t\t\"    iScreen#T#.fromA = texture(iBufferA#T  #).frame\",\n\t\t\t\"    iScreen#T#.fromB = texture(iBufferB#T  #).frame\",\n\t\t\t\"    iScreen#T#.fromC = texture(iBufferC#T  #).frame\",\n\t\t\t]))\n*/\n\nint codes[] = int[](\n// Buffer A:\n0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x41, 0x3a, -1,\n//     iBufferA#T#.frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferA#T#.fromA = texture(iBufferA#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x41, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferA#T#.fromB = texture(iBufferB#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x42, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferA#T#.fromC = texture(iBufferC#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n// Buffer B:\n0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x42, 0x3a, -1,\n//     iBufferB#T#.frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferB#T#.fromA = texture(iBufferA#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x41, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferB#T#.fromB = texture(iBufferB#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x42, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferB#T#.fromC = texture(iBufferC#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n// Buffer C:\n0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x43, 0x3a, -1,\n//     iBufferC#T#.frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferC#T#.fromA = texture(iBufferA#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x41, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferC#T#.fromB = texture(iBufferB#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x42, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iBufferC#T#.fromC = texture(iBufferC#T-1#).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, 0x2d, 0x31, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n// Image:\n0x49, 0x6d, 0x61, 0x67, 0x65, 0x3a, -1,\n//     iScreen#T#.frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iScreen#T#.fromA = texture(iBufferA#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x41, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x41, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iScreen#T#.fromB = texture(iBufferB#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x42, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x42, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     iScreen#T#.fromC = texture(iBufferC#T  #).frame\n0x20, 0x20, 0x20, 0x20, 0x69, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6e, -2, 0x54, -2, 0x2e, 0x66, 0x72, 0x6f, 0x6d, 0x43, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x69, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x43, -2, 0x54, 0x20, 0x20, -2, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1\n);\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdKGWw", "name": "watching black and white road", "author": "jorge2017a2", "description": "watching black and white road\n\n", "tags": ["watchingblackandwhiteroad"], "likes": 5, "viewed": 270, "published": 3, "date": "1631651368", "time_retrieved": "2024-07-30T19:01:17.904968", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 170.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    p.y=p.y-3.0;\n    p.x=opRep1D( p.x,40.0 );\n    \n    //piso y techo\n    float sdb1a= sdBox( p, vec3(25.0,1.0,15.0) );\n    float sdb1b= sdBox( p-vec3(0.0,24.0,.0), vec3(25.0,1.0,15.0));\n    \n    p.x=abs(p.x)-10.0;\n    p.z=p.z-5.0;\n    \n    float sdb2a= sdBox( p-vec3(.0,2.0,.0), vec3(3.0,0.5,3.0) );\n    float sdb2b= sdBox( p-vec3(.0,20.0,.0), vec3(2.5,0.5,2.5) );\n    \n    float sdcy1= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(2.0,10.0) );\n    float sdcy1a= sdCylinderXZ( p-vec3(0.0,22.0,0.0), vec2(2.5,2.0) );\n    float sdcy1b= sdCylinderXZ( p-vec3(0.0,3.0,0.0), vec2(2.5,2.0) );\n     mObj.uvP= vec2(atan(p.z, p.x), p.y * 0.4);\n     \n    res =opU3(res, vec3(sdb1a,-1.0,5.0));\n    res =opU3(res, vec3(sdb1b,-1.0,6.0));\n    \n    res =opU3(res, vec3(sdcy1,-1.0,10.0));\n    res =opU3(res, vec3(sdcy1a,0.0,-1.0));\n    res =opU3(res, vec3(sdcy1b,0.0,-1.0));\n    \n    res =opU3(res, vec3(sdb2a,1.0,-1.0));\n    res =opU3(res, vec3(sdb2b,1.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n\n    \n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    return color;\n    \n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{\n    float t1=mod(iTime,2.0);\n    float t2=mod(iTime,3.0);\n    if (t1<t2)\n        return vec3(0.0);\n    else    \n    {\n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return  mix(sky, vec3(0.0), rd.y);\n    }\n}\n\n//https://www.shadertoy.com/view/7sSXDz\nvec3 amigaTexture(vec2 pos, float n)\n{\n    float l = clamp(sin(pos.x*n)*sin(pos.y*n)*10000.0, 0.0, 1.0);\n    return vec3(1.0, 0.0, 0.0)*l+(vec3(1.0, 1.0, 1.0)*(1.0-l));\n}\n\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n     if (id_material==10.0)\n    { return amigaTexture(mObj.uvP, 6.0); }\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 40.0, -20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0-t,14.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(-45.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec2 uvP;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 484, 484, 568], [569, 569, 608, 608, 703], [705, 705, 752, 752, 779], [780, 780, 823, 823, 850], [851, 851, 899, 899, 927], [928, 966, 1002, 1002, 1047], [1048, 1048, 1087, 1087, 1131], [1132, 1132, 1171, 1171, 1215], [1216, 1216, 1248, 1248, 1273], [1274, 1339, 1373, 1373, 1469], [1470, 1470, 1504, 1504, 1595], [1596, 1596, 1630, 1630, 1721], [1722, 1722, 1747, 1747, 2801], [2803, 2803, 2827, 2827, 2989], [2991, 2991, 3040, 3040, 3707], [3709, 3709, 3736, 3736, 3753], [3755, 3755, 3791, 3791, 3883], [3884, 3884, 3930, 3930, 4055], [4057, 4057, 4094, 4094, 4370], [4372, 4372, 4455, 4455, 5055], [5057, 5057, 5150, 5150, 5280], [5282, 5282, 5314, 5314, 5663], [5665, 5705, 5743, 5743, 5875], [5878, 5878, 5925, 5925, 6522], [6524, 6524, 6617, 6617, 6959], [6961, 6961, 6992, 6992, 7591], [7593, 7593, 7619, 7619, 7729], [7731, 7731, 7789, 7789, 7841], [7843, 7843, 7900, 7900, 8483]], "test": "untested"}
{"id": "7sG3Ww", "name": "Gamma Curve", "author": "mosan_hoshi", "description": "practice for 2d chart", "tags": ["2d", "chart"], "likes": 4, "viewed": 310, "published": 3, "date": "1631641155", "time_retrieved": "2024-07-30T19:01:18.809550", "image_code": "// written by mossan-hoshi( https://twitter.com/mossan_hoshi )\n\n#define MAX_GAMMA  2.2\n#define MARGIN  0.1\n#define IN_OUT_COLOR cyan\n\nvoid drawLine(vec2 p1, vec2 p2){\n\n}\n\nfloat gamma_function(float x, float gamma){\n  return  pow(x,1.0/gamma);\n}\n \nvoid gamma_curve(vec2 uv, float gamma, inout vec4 fragColor){\n  if(abs(uv.y - gamma_function(uv.x,gamma)) < 0.002 ){\n      vec3 color = vec3(0.8,0.5,0.8);\n      fragColor=vec4(color,1.0);\n  }\n}\n\nvoid in_out_line(float x, vec2 uv, float gamma, inout vec4 fragColor){\n  if((uv.y < gamma_function(x,gamma)&&(abs(uv.x - x) < 0.002))){\n      vec3 color = vec3(0.5,0.8,0.8);\n      fragColor=vec4(color,1.0);\n  }else if((abs(uv.y - gamma_function(x,gamma)) < 0.002)&&(uv.x < x)){\n      vec3 color = vec3(0.5,0.8,0.8);\n      fragColor=vec4(color,1.0);\n  }\n}\n \nvoid in_out_wave(float x, float input_range, vec2 uv, float gamma, float iTime, inout vec4 fragColor){\n  float x_max = x+input_range;\n  float x_min = x-input_range;\n  float y_max = gamma_function(x_max,gamma);\n  float y_min = gamma_function(x_min,gamma);\n  float y = (y_min + y_max) / 2.;\n  if((uv.y < gamma_function(uv.x,gamma)&&(abs(uv.x - (x + input_range * cos(100. * uv.y - 10. *iTime))) < 0.004))){\n      vec3 color = vec3(0.2,0.6,0.6);\n      fragColor=vec4(color,1.0);\n  }else if((uv.y > gamma_function(uv.x,gamma))&&\n           (abs(uv.y - ( y + ((y_max - y_min)/2.0) * cos(100. * uv.x + 10. *iTime))) < 0.004)){\n      vec3 color = vec3(0.2,0.6,0.6);\n      fragColor=vec4(color,1.0);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const \n  // normalize position(x,y:.0~1.0)\n  vec2 uv= fragCoord.xy/ min(iResolution.x,iResolution.y);\n  uv = uv * (1.0 + (2. * MARGIN));\n  vec2 offset = ((iResolution.xy / min(iResolution.x,iResolution.y)) - 1.0)/2.0;\n  \n  // draw color tiles\n  if((uv.x >= offset.x+MARGIN)&&(uv.x <= (1.007 + offset.x+MARGIN))&&\n     (uv.y >= offset.y+MARGIN)&&(uv.y <= (1.007 + offset.y+MARGIN))){\n\n    // background\n    if((uv.x>offset.x+MARGIN)&&(uv.x<1.0 + offset.x+MARGIN)){\n      float value = 0.9;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // thin lines\n    if(((mod(uv.x-offset.x, MARGIN) < 0.002)&&(mod(uv.y-offset.y,0.005) < 0.002))||\n       ((mod(uv.y-offset.y, MARGIN) < 0.002)&&(mod(uv.x-offset.x,0.005) < 0.002))){\n      float value = 0.2;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // thick lines\n    if((mod(uv.x-offset.x-MARGIN,0.5) < 0.007)||(mod(uv.y-offset.y-MARGIN,0.5) < 0.007)){\n      float value = 0.2;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // gamma curve\n    float range = MAX_GAMMA - 1.0 / MAX_GAMMA;\n    float gamma = MAX_GAMMA + (range / 2.)*(cos(iTime) - 1.0);\n    gamma_curve(uv - offset - MARGIN, gamma, fragColor);\n\n    // lines\n    float line_x = 0.3;\n    float input_range = 0.1;\n    in_out_line(line_x - input_range, uv - offset - MARGIN, gamma,fragColor);\n    in_out_line(line_x + input_range, uv - offset - MARGIN, gamma,fragColor);\n\n    // wave \n   in_out_wave(line_x, input_range, uv - offset - MARGIN, gamma, iTime,fragColor);\n    \n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 166, 166, 169], [171, 171, 214, 214, 244], [247, 247, 308, 308, 440], [442, 442, 512, 512, 796], [799, 799, 901, 901, 1496], [1498, 1498, 1554, 1602, 3066]], "test": "untested"}
{"id": "sddGWj", "name": "4D Medusa", "author": "dominionxvii", "description": "4D medusa chillin", "tags": ["raymarching4dcubeunderwater"], "likes": 3, "viewed": 225, "published": 3, "date": "1631640563", "time_retrieved": "2024-07-30T19:01:19.753027", "image_code": "\nvec2 pulseDir = vec2(-0.5, 0.866);\n\nbool IsInFrame(vec2 uv)\n{\n   return (uv.x > 0. && uv.y > 0. && uv.x < 1. && uv.y < 1.);\n}\n\nvec4 FakeVolumetricLight(vec2 uv, float thicc, float speed, float offset, float offsetHeight, float offsetAngle, uint state)\n{\n    float a = atan(pulseDir.y / pulseDir.x) + offsetAngle;\n    \n    float height = easeOutQuad(uv.y - offsetHeight);\n    vec2 prevUv = uv;\n    \n    uv -= 0.5;\n    uv = RotateZ(vec3(uv, 1.0), -a).xy;\n    uv += 0.5;\n    \n    if(uv.y > uv.x - thicc && uv.y < uv.x + thicc)\n    {\n        //God rays\n        float dist = height - distance(uv.y, uv.x);\n        float light = 0.2 * (sin(((iTime * speed) + offset) * TAU - PI/2.) * 0.5 + 0.5);\n        float godRay = light * height * dist;\n        return vec4(godRay);        \n    }\n\n    return vec4(0.0);\n}\n\nvec4 LightSparkles(vec2 uv)\n{\n    //Nasty rescaling from [0,1] to around [-.5, 5.] based on resolution\n    uv *= iResolution.xy;\n    uv = (uv-0.5*iResolution.xy)/iResolution.y;\n\n    uv.y -= iTime * 0.1;\n\n    float spread = 0.05;\n    uv /= spread;\n    \n    float size = 0.025;\n    \n    float cell = cellular(uv).x;\n    float dist = saturate(size - cell) / size;\n    \n    return vec4(dist);\n}\n\nvec4 LightStreak(vec2 uv, vec2 dir)\n{\n\n\n    //Poorly adjust the uv to compensate for the different uv \n    uv -= 0.5;\n    uv = RotateZ(vec3(uv, 1.0), -0.13).xy;\n    uv += 0.5;\n    \n    \n   vec4 sum = vec4(0.0);\n\n   float streakLen = 0.125;\n   int count = 50; //boost for bootiful\n   float steps = streakLen / float(count);\n   \n   float distoSpeed = 0.1;\n   float intensity = 1.25;\n\n   for(int i = 0; i < count; i++)\n   {   \n       vec2 uv2 = uv + dir * float(i) * steps;\n       float iratio = 1. - (float(i) / float(count - 1));\n       \n       bool verticalStreakInRange = dir.y == -1. && dir.x == 0.0 && uv2.y >= 0.;\n       bool radialStreakInRange = IsInFrame(uv2);\n       \n       if(verticalStreakInRange || radialStreakInRange)\n       {\n           vec4 col = texture(iChannel0, uv2);\n           sum += saturate(vec4(col.rgb * col.a, col.a)) * iratio;\n       }\n     }\n \n  // float filterNoise = norm(fbm_4r(vec3(uv * 5., iTime * 0.3), m3));\n   return (sum / float(count)) * intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    float speed = 0.25;\n    int godRayCount = 32;\n    float godRayRatio = 1. / float(godRayCount);\n    \n    vec4 godRayMask = vec4(0.);\n    \n    for(int i = 0; i < godRayCount; i++)\n    {\n        float ratio = float(i) * godRayRatio;\n        \n        uint seed = uint(floor(iTime * speed + ratio) + float(i) * 643.32);\n        uint state = WangHash(seed);\n    \n        float xOffset = NextFloat(-0.75, 0.75, state);\n        float size = NextFloat(0.001, 0.2, state);\n        float offsetAngle = NextFloat(-0.02, 0.02, state);\n        float amplitude = NextFloat(0.05, 0.15, state);\n        float height = NextFloat(0.0, 0.2, state);\n        vec4 light = FakeVolumetricLight(uv + vec2(xOffset, 0.0), size, speed, ratio, height, offsetAngle, state) * amplitude;\n        col += light;\n        godRayMask += light;\n    }\n\n    col += saturate(godRayMask * 10.) * LightSparkles(uv) * 0.15;\n    col += saturate(godRayMask * 10.) * LightSparkles(uv * 2.0) * 0.15;\n    col += saturate(godRayMask * 10.) * LightSparkles(uv * 3.0) * 0.15;\n\n    //col -= LightStreak(uv, pulseDir);\n    \n    col = saturate(col);\n    fragColor =col;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1416\n#define TAU 6.2831\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\nfloat norm(float x)\n{\n    return x * 0.5 + 0.5;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return vec3(saturate(x.x), saturate(x.y), saturate(x.z));\n}\n\nvec4 saturate(vec4 x)\n{\n    return vec4(saturate(x.x), saturate(x.y), saturate(x.z), saturate(x.w));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat unlerp(float x, float fromMin, float fromMax)\n{\n    return (x - fromMin) / (fromMax - fromMin);\n}\n\nfloat Remap(float fromMin, float fromMax, float toMin, float toMax, float x)\n{\n    float t = saturate(unlerp(x, fromMin, fromMax));\n    return mix(toMin, toMax, t);\n}\n\nfloat ReduceResolution(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec2 ReduceResolution(vec2 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\n\nvec3 RotateZ(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.y * s,   \n        p.x * s + p.y * c,\n        p.z);\n}\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c = cos(-a);\n    float s = sin(-a);\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.x * s + p.z * c);\n}\n\n//delay attack sustain release\nfloat DASRCurve(float t, float delay, float attack, float sustain, float release)\n{\n    if(t < delay)\n        return 0.0;\n    if(t < attack)\n        return Remap(delay, attack, 0.0, 1.0, t);\n    if(t < sustain)\n        return 1.0;\n    else if(t < release)\n        return Remap(sustain, release, 1.0, 0.0, t);\n    else\n        return 0.0;\n        \n}\nfloat remap(float v, float fmn, float fmx, float tmn, float tmx) {\n    return saturate((v-fmn) / (fmx-fmn)) * (tmx-tmn) + tmn;\n}\n\n//IQ https://iquilezles.org\n\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h >= 0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y <= 0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - ra*ra;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n\nvec3 opTwist(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\nvec3 opRepLim( in vec3 p, in vec3 c,  in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat pow2(float x) { return x * x; }\n\n//Ease, https://easings.net\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad(float x)\n{\n    return x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat easeOutBounce(float x)\n{\n    const float n1 = 7.5625;\n    const float d1 = 2.75;\n\n    if (x < 1.0 / d1) {\n        return n1 * x * x;\n    } else if (x < 2.0 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nfloat easeOutElastic(float x)\n{\n    const float c4 = (2.0 * PI) / 5.0;\n\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\nfloat easeInOutBack(float x) \n{\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n      : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat easeInBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat easeOutBack(float x)\n{\n    const float c1 = 1.70158;\n    const float c3 = c1 + 1.0;\n\n    return 1.0 + c3 * pow(x - 1.0, 3.0) + c1 * pow(x - 1.0, 2.0);\n}\n\nfloat easeInCirc(float x)\n{\n    return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat easeInQuad(float x)\n{\n    return x * x;\n}\n\nfloat easeOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat easeInCubic(float x)\n{\n    return x * x * x;\n}\n\nfloat easeOutCubic(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\nfloat easeOutCirc(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x) * (1.0 - x);\n}\n\n//HASH / noise\n\n\nfloat cheapNoise(vec2 v)\n{\n    return \n        0.333 * sin(v.x + 3.151) +\n        0.333 * sin(v.y + 8.357) + \n        0.333 * cos((v.x + v.y) + 3.723);\n\n}\n\nfloat cheapNoiseRepeat(float x, float t, float period, float amp)\n{\n    t = mod(t, period);\n    t /= period;\n    vec2 v = vec2(amp * sin(x + TAU * t), amp * cos(x + TAU * t));\n    \n    return cheapNoise(v);\n}\n\n\n\nvec3 cheapNoise(float x, float t)\n{\n    return vec3(\n        cheapNoise(vec2(x, x + t + 126.)),\n        cheapNoise(vec2(x + 26.34, x + t + 252.)),\n        cheapNoise(vec2(x + 12.63, x + t + 623.))\n        );\n}\n\n\nvec3 cheapNoise(vec3 v, float t)\n{\n    return vec3(\n        cheapNoise(vec2(v.x, v.y + t + 126.)),\n        cheapNoise(vec2(v.y, v.z + t + 252.)),\n        cheapNoise(vec2(v.z, v.x + t + 623.))\n        );\n}\n\n\n//Personal easing\n\nfloat OverShoot(float x, float overshoot, float undershoot, float sinSpeed, float sinAmp)\n{\n    float sinvalue = sinAmp * sin(x * TAU * sinSpeed);\n\n    float s = x * x * (3. - 2. * x); //smooth step\n    float a = overshoot * pow2(s);\n    float b = 1. - undershoot * pow2(s - 1.);\n    return easeInOutQuad(mix(a, b, s)) + sinvalue;\n}\n\n\nfloat OverShoot(float x)\n{\n    float sinSpeed = 2.;\n    float sinAmp = 0.075;\n    return OverShoot(x, 2.5, 0.5, sinSpeed, sinAmp);\n}\nfloat OverShootDx(float x)\n{\n    float dx = 0.001;\n    return (OverShoot(x + dx) - OverShoot(x)) / dx;\n}\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\n//Quaternions\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\n\n//Camera model\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, float fovFactor, out vec3 ro, out vec3 rd)\n{\n    vec3 forward = normalize(vec3(uv.x * fovFactor, uv.y * fovFactor, 1.0));\n\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\n\nvoid OrthographicCam(vec3 camPos, vec4 camRot, vec2 uv, float zoom, out vec3 ro, out vec3 rd)\n{    \n    vec3 up = qmul(camRot, vecY(1.0));\n    vec3 right = qmul(camRot, vecX(1.0));\n\n    ro = camPos + (up * uv.y + right * uv.x) * (1.0 / zoom);\n    rd = qmul(camRot, vecZ(1.0));\n}\n", "buffer_a_code": "//uncomment for hd\n#define HD\n\n\nconst int dimension = 4;\nconst int edgeLength = dimension * (2 << (dimension - 2));\nconst int verticeLength = (2 << dimension);\n\nconst int tentacleJoint = 12;\nconst float armLength = 0.25;\n\nconst int tentaclePosLength = tentacleJoint * verticeLength;\nconst float loopSteps = 4.;\n\n\nvec4 verticesRaw[verticeLength];\nvec3 vertices[verticeLength];\nivec2 edges[edgeLength];\nvec3 tentaclePos[tentaclePosLength];\n\nfloat cameraDist = 7.5;\n\nfloat timeScale = 1. / 7.2; // match to 100 bpm\nfloat iTimeS;\nmat4 rot;\n\nfloat pulse;\nfloat pulseRatio;\nfloat pulseDx;\n\nvec3 pulseDir = vec3(-0.5, 0.866, 0.0);\n\nstruct RayHit \n{\n    bool hasHit;\n    vec3 hitPos;\n    float dist;\n    float col;\n};\n\n\nmat4 rotation_XZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , 0.0, s  , 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(-s , 0.0, c  , 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 rotation_YZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, c  , -s , 0.0),\n        vec4(0.0, s  , c  , 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\nmat4 rotation_XY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , -s , 0.0, 0.0),\n        vec4(s  , c  , 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 rotation_XW(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(c  , 0.0, 0.0, -s ),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(s  , 0.0, 0.0, c  )\n    );\n}\n\nmat4 rotation_YW(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0  ),\n        vec4(0.0, c  , 0.0, -s),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, s  , 0.0, c  )\n    );\n}\n\nvec3 to3d(vec4 pos4d)\n{\n    vec4 pos4dRot = rot * pos4d;\n    pos4dRot.xyz += normalize(pos4dRot.xyz) * (pos4dRot.w + 0.5) * 0.7;\n    return pos4dRot.xyz;\n}\n\n//\n\nfloat MedusaIntersection(vec3 ro, vec3 rd)\n{\n    float capsuleSize = 0.02;\n    \n    float bodyAlpha = 1.0;\n    float tentacleAlpha = 0.5;\n    \n    for(int i = 0; i < edgeLength; i++)\n    {\n        vec3 v1 = vertices[edges[i].x];\n        vec3 v2 = vertices[edges[i].y];\n        \n        float wiggle = 0.01;\n        float d = capIntersect(ro, rd, v1, v2, capsuleSize);\n\n        if(d != -1.0)\n            return bodyAlpha;\n    }\n    \n    float maxAlpha = 0.0;\n    for(int i = 0; i < verticeLength; i++)\n    {\n        int offset = i * tentacleJoint;\n        \n        for(int j = 1; j < tentacleJoint; j++)\n        {\n            vec3 v1 = tentaclePos[offset + j - 1];\n            vec3 v2 = tentaclePos[offset + j];\n            vec3 ro2 = ro + 0.15 * cheapNoise(ro + rd, iTimeS);\n            \n            float ratio = float(j) / float(tentacleJoint - 1);\n            float foffset = float(offset);\n            vec3 offset = 0.05 * cheapNoise(v1 + ratio * 15.25, iTimeS * 2.0);\n            \n            float sphereScale = 0.15 * (1.0 - ratio);\n            float d = sphIntersect(ro, rd, v1 + offset, sphereScale).x;            \n            \n            if(d != -1.0)\n            {    \n                float depthAlpha = saturate(remap(d, cameraDist - 0.5, cameraDist + 0.5, 1.0, 0.25)); \n                float ratio = float(j) / float(tentacleJoint - 1);\n                float alpha =  ratio * tentacleAlpha * depthAlpha;\n                maxAlpha = max(maxAlpha, alpha);\n            }\n        }\n    }\n      \n    return maxAlpha;\n}\n\nRayHit RayCast(vec3 ro, vec3 rd)\n{\n    float col = MedusaIntersection(ro, rd);\n    RayHit rayHit;\n    \n    rayHit.hasHit = col != -1.0;\n    rayHit.col = col;\n    return rayHit;\n}\n\nvec4 GetColor(RayHit hit, vec3 viewDir, vec2 uv)\n{\n    return vec4(1.0);\n}\n\nvoid PrepareVertices()\n{\n    int i = 0;\n    for(int w = 0; w <= 1; w++)\n    for(int z = 0; z <= 1; z++)\n    for(int y = 0; y <= 1; y++)\n    for(int x = 0; x <= 1; x++)\n    {\n        \n        //norm between [-0.5, 0.5]\n        verticesRaw[i] = vec4(x, y, z, w) - vec4(0.5);\n        vertices[i] = to3d(verticesRaw[i]);\n        i++;\n    }   \n    \n    //tentacles\n    for(i = 0; i < verticeLength; i++)\n    {\n        int offset = i * tentacleJoint;\n        tentaclePos[offset] =  vertices[i];\n        for(int j = 1; j < tentacleJoint; j++)\n        {\n            int k = offset + j;\n            vec3 noPulseDir = normalize(vertices[i] - pulseDir * 1.75);\n            \n            vec3 invPulseDir = -pulseDir;\n            vec3 orthoDir = -normalize(cross(pulseDir, vertices[i]));\n            \n            vec3 pulseDir = mix(invPulseDir, orthoDir, 0.2);\n            \n            float ratio = float(j) / float(tentacleJoint - 1);\n            ratio = easeOutQuad(ratio);\n            \n            float pulseDxOffset = OverShootDx(fract(pulseRatio - 0.1));\n            float t = pulseDxOffset * ratio * 1.5;\n\n            vec3 currentDir = normalize(mix(noPulseDir, pulseDir, t));\n\n            tentaclePos[k] = tentaclePos[k - 1] + currentDir * armLength;\n        }\n    }\n}\n\nvoid PrepareEdges()\n{\n    edges[0] = ivec2(0, 1);\n\n    int l = 1;\n    for (int dim = 2; dim <= dimension; dim++)\n    {\n        int dimPower = 2 << (dim - 2);\n        int vertexOffset = dimPower;\n        int edgeNumber = dim * dimPower;\n        int count = l;\n\n        //duplicate all edges with offset\n        for (int i = 0; i < count; i++)\n        {\n            edges[l++] = ivec2(vertexOffset + edges[i].x, vertexOffset + edges[i].y);\n        }\n\n        count = edgeNumber - l;\n        for (int i = 0; i < count; i++)\n        {\n            edges[l++] = ivec2(i, i + count);\n        }\n    }\n}\n\nbool InSphere(vec2 uv, vec2 pos, float radius, float thicc)\n{\n    float d = distance(uv, pos);\n    return d < radius + thicc && d > radius;\n}\n\nvec4 BubbleBurst(vec2 uv, float uvScaling, float speed)\n{\n    float strip1 = 0.35;\n    float strip2 = 0.45;\n    float fwStrip = 0.5;\n    \n    vec2 rotuv = RotateZ(vec3(uv * uvScaling, 0.0), -15.0 / 360.0 * TAU).xy;\n    float upperStrip = Remap(strip1 - rotuv.x, strip2  - rotuv.x, 1.0, 0.0, rotuv.y);\n    float lowerStrip = Remap(-strip1 - rotuv.x, -strip2  - rotuv.x, 1.0, 0.0, rotuv.y);\n    float forwardStrip = saturate(rotuv.x - rotuv.y);\n    \n    float stripPower = min(min(upperStrip, lowerStrip), forwardStrip);\n    if(stripPower <= 0.0)\n        return vec4(0.0);\n    \n    float repeat = 0.2;\n    vec2 center = vec2(repeat / 2.0);\n    \n    uv += pulseDir.xy * pulse * 3.0 - vec2(0.0, 2.0) * pulseRatio;\n    uv *= uvScaling;\n    vec2 i = floor(uv / repeat);\n    uv = mod(uv, repeat);\n    \n   //debug lines\n    //if(uv.x < 0.005 || uv.y < 0.005)\n    //    return vec4(0.75);\n    \n    float bubbleRadiusMin = 0.01;\n    float bubbleRadiusMax = 0.02;\n\n    uint seed = 2u;\n    uint state = WangHash(seed + uint((23.0 + i.x) + (62.0 + i.y * 5.0)));\n\n    float bubbleRadius = NextFloat(bubbleRadiusMin, bubbleRadiusMax, state);\n    float bubbleThicc = 0.005;\n    float wiggleRadius = 0.15;\n    \n    float randomRange = center.x - bubbleRadius - bubbleThicc - wiggleRadius;\n    vec2 rmin = vec2(-randomRange);\n    vec2 rmax = vec2(randomRange);\n    vec2 rngOffset = NextVec2(rmin, rmax, state);\n    \n    if(InSphere(uv, center + rngOffset, bubbleRadius, bubbleThicc))\n    { \n        return vec4(1.0) * stripPower;\n    }\n    \n    return vec4(0.0);\n}\n\nvec4 GenerateBubbleBurst(vec2 uv)\n{\n    const int row = 15;\n    const int col = 10;\n    const float colAngle = TAU / float(col);\n    const float spinRow = 0.2;\n    \n    float radius = 0.01;\n    float thicc = 0.005;\n\n    float distRadius = 0.05;\n    \n    float spinAngle = pulse * TAU / 4.0;\n    \n    float rowHeight = 15.;\n    \n\n    vec4 rot = qAxisAngleRotation(pulseDir, PI / 4.0);\n    vec2 uv2 = RotateZ(vec3(uv.x, uv.y, 0.0), PI / 4.7).xy;\n    \n    float localY = uv2.y;\n    uv2.y += pulseRatio * 2.5;\n\n    float ypos = uv2.y + radius + thicc;\n    float i = floor(ypos * rowHeight);\n\n    float spinAngleRow = i * spinRow; \n    vec3 start = vecY(i / rowHeight);\n    \n    float cutoff = 0.5;\n    localY = -localY - 0.2;\n    float heightIntensity = DASRCurve(localY, -0.2, 0.2, cutoff, 1.0);\n    heightIntensity = \n        (localY <= cutoff) ?\n          easeOutCubic(heightIntensity) :\n          easeInCubic(heightIntensity);\n         \n    distRadius += -pulseDx * 0.02 + heightIntensity * 0.2;\n    \n    float curIntensity = 0.0;\n    for(int j = 0; j < col; j++)\n    {        \n        float a = float(j) * colAngle + spinAngleRow + spinAngle;            \n        vec3 pos = start + RotateY(vecZ(distRadius), a);\n        \n        if(InSphere(uv2, pos.xy, radius, thicc))\n        {   \n            float depthIntensity = saturate((pos.z + distRadius + 0.03) / (distRadius * 2.0));\n            float intensity = heightIntensity * depthIntensity;\n\n            curIntensity = max(curIntensity, intensity);\n        }\n    }\n\n    return vec4(curIntensity * 0.5);\n}\n\nvec4 GenerateBubble(vec2 f, ivec2 i, out vec2 bubbleCenter)\n{\n    uint seed = 2u + uint(i.x + i.y * 5);\n    //seed = seed % 1u;\n    \n    uint state = WangHash(seed);\n\n    //debug lines\n    if(f.x < 0.01 || f.y < 0.01)\n        return vec4(0.075);\n    \n    float bubbleRadiusMin = 0.002;\n    float bubbleRadiusMax = 0.05;\n\n    float bubbleRadius = NextFloat(bubbleRadiusMin, bubbleRadiusMax, state);\n    float bubbleThicc = 0.0075;\n    float wiggleRadius = 0.05;\n    \n    float randomRange = 0.5 - bubbleRadius - bubbleThicc - wiggleRadius;\n    vec2 rmin = vec2(-randomRange);\n    vec2 rmax = vec2(randomRange);\n    vec2 rngOffset = NextVec2(rmin, rmax, state);\n    \n    f += rngOffset;\n    \n    float wiggleSpeed = 10.0;\n    f += vec2(sin(wiggleSpeed * iTimeS + float(i.x) * 252.2), sin(wiggleSpeed * iTimeS + float(i.y) * 31.2)) * wiggleRadius;\n    \n    bubbleCenter = f;\n    float d = distance(bubbleCenter, vec2(0.5));\n    \n    if(d > bubbleRadius && d < bubbleRadius + bubbleThicc)\n        return vec4(1.0);\n        \n   return vec4(0.0);\n}\n\n\nvec4 GetBubbleColor(vec2 uv, float scaledown, vec2 offset, float speed)\n{\n    uv *= scaledown;\n    uv += offset;\n\n    //fake camera movement\n    float timeStep = floor(iTimeS);\n        \n       \n    float pulseDist = 6.0; //6\n    \n    //going fastttt\n    uv += pulseDist * (timeStep + pulse) * pulseDir.xy;\n    \n    //feels like the medusa is going down a bit when standing still\n    uv += vec2(0.0, -iTimeS * 2.0);\n    \n\n    float size = 0.75;\n    uv = (uv + vec2(0.5)) * size;\n  \n    uv += vec2(0.5, 1.0) * speed * iTimeS;\n \n    //vec2 loopOffset = ((vec3(1) - pulseDir) / loopSteps).xy;\n    //uv += loopOffset * pulseRatio;\n \n    ivec2 i = ivec2(floor(uv)); \n    vec2 f = fract(uv);\n    \n    vec2 bCenter;\n    vec4 bubbleCol = GenerateBubble(f, i, bCenter);\n    \n    \n    return bubbleCol;\n}\n\nvoid PrepareCubeData()\n{\n    pulseRatio = fract(iTimeS);\n    pulse = OverShoot(pulseRatio);  \n    pulseDx = OverShootDx(pulseRatio);\n        \n    float angle4D = pulse * (TAU / 4.0);\n\n    mat4 rotRoll = rotation_XY(1.0472);\n    mat4 rotYaw = rotation_XZ(PI / 8.0);  \n    mat4 rotPitch = rotation_YZ(pulse * PI + PI / 8.0);    \n    mat4 roll4D = rotation_XW(angle4D);\n    \n    rot = rotRoll * rotYaw * rotPitch * roll4D;\n    \n    PrepareVertices();\n    PrepareEdges();\n}\n\nvec4 Render(vec2 uv)\n{\n    vec4 col = vec4(0.);\n    float shakeIntensity = 0.1;\n    float shakeSpeed = 1.0;\n    //vec2 shakeNoise = vec2(cheapNoise(vec2(iTimeS * shakeSpeed, 0.0)),cheapNoise(vec2(0.0, iTimeS * shakeSpeed)));\n    vec2 shakeNoise = vec2(\n        cheapNoiseRepeat(2353., iTimeS * shakeSpeed, 1.0, 1.0),\n        cheapNoiseRepeat(3624., iTimeS * shakeSpeed, 1.0, 1.0));\n\n    uv += shakeIntensity * shakeNoise;\n    \n    //Pixelize\n    float resolution = 750.0;\n    //uv = ReduceResolution(uv, resolution);\n    \n    vec3 camPos = vec3(0.0, 0.0, -cameraDist);\n      \n    mat4 rotYaw = rotation_XZ(PI / 8.0);  \n    mat4 rotRoll = rotation_XY(PI / 8.0);\n\n    \n    vec4 camRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float zoom = 0.1;\n    \n    \n    vec2 uvMedusa = uv + sin(pulse * TAU) * pulseDir.xy * 0.2; \n\n    vec3 ro, rd;\n    OrthographicCam(camPos, camRot, uvMedusa, zoom, ro, rd);\n    //PerspectiveCam(camPos, camRot, uv, 1.0, ro, rd);\n    \n    \n    RayHit hit = RayCast(ro, rd);\n    if(hit.hasHit)\n    {\n        col = vec4(vec3(hit.col), 1.0);\n    }\n    else\n    {\n        col = vec4(0.0);\n    }\n    \n    float burstRatio = \n        DASRCurve(pulseRatio, 0.3, 0.43, 0.5, 1.0);\n    \n    //fragColor += GenerateBubbleBurst(uvMedusa) * burstRatio;\n    col += BubbleBurst(uvMedusa, 1.5, 1.0) * burstRatio * 1.0;\n    col += BubbleBurst(uvMedusa, 2.0, 1.0) * burstRatio * 0.75;\n    col += BubbleBurst(uvMedusa, 3.0, 1.0) * burstRatio * 0.5; \n    \n    \n    col += GetBubbleColor(uv, 4.0, vec2(2.0, 3.0), 0.2);\n    col += GetBubbleColor(uv, 7.0, vec2(5.3, 2.0), 0.2) * 0.5;\n    col += GetBubbleColor(uv, 8.0, vec2(8.2, 3.4), 0.2) * 0.25;\n    col += GetBubbleColor(uv, 10.0, vec2(2.7, 1.2), 0.2) * 0.125;\n    \n    return col;\n}\n\nvec4 RenderAntiAliasing(vec2 uv, vec2 fragCoord)\n{\n    vec4 colorSum = vec4(0.0);        \n    vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n\n    colorSum += Render(uv);\n    colorSum += Render(mix(uv, vec2(uv.x, nextUv.y), 0.5));\n    colorSum += Render(mix(uv, vec2(nextUv.x, uv.y), 0.5));\n    colorSum += Render(mix(uv, nextUv, 0.5));\n    colorSum /= 4.0;\n    return colorSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    iTimeS = iTime * timeScale;\n    \n    \n    //iTimeS = mod(iTimeS, loopSteps);\n    \n    PrepareCubeData();\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    fragColor = Render(uv);\n   \n#ifdef HD  \n    fragColor = RenderAntiAliasing(uv, fragCoord);  \n#else\n    fragColor = Render(uv); \n#endif\n\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 62, 62, 126], [128, 128, 254, 254, 804], [806, 806, 835, 908, 1196], [2189, 2189, 2246, 2246, 3455]], "test": "untested"}
{"id": "ssGGWw", "name": "Wet beach sand", "author": "jarble", "description": "Based on wachel's [url=https://www.shadertoy.com/view/ltcGDl]desert terrain[/url], inspired by TekF's [url=https://www.shadertoy.com/view/ldfXzS]\"Wet Sand\" terrain[/url].", "tags": ["terrain", "sand", "dune", "beach"], "likes": 14, "viewed": 557, "published": 3, "date": "1631639657", "time_retrieved": "2024-07-30T19:01:20.588792", "image_code": "//thank for https://www.shadertoy.com/view/MdX3Rr by iq\n\n#define PI 3.14159265359\n\n\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = (noise(uv * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-(n1) * amplitude);\n        \n        amplitude *= 1./3.;\n        \n        freq *= 2.;\n        \n        uv = uv.yx;\n        value *= .6+.1*noise(uv+n1*value);\n        \n        //value *= .9;\n\n}\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\nfloat terrainH( in vec2 p)\n{\n    p.x += iTime/2.;\n    return fbm(p*1.5)*1.5;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.1;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1./8.;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col = render( vec3(time,1.8,0.0), rd );\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 110, 110, 150], [171, 171, 206, 255, 742], [744, 744, 766, 766, 796], [797, 797, 825, 825, 875], [877, 877, 920, 941, 1194], [1197, 1197, 1270, 1270, 1458], [1461, 1461, 1502, 1502, 1743], [1745, 1745, 1784, 1784, 3253], [3255, 3255, 3312, 3312, 4174]], "test": "untested"}
{"id": "Ndy3Dw", "name": "Fork [SH16B] Sp oneWisdom 194", "author": "oneWisdom", "description": "I was listening to Blood Dragon Theme when the 2nd challenge was announced, so why not mix it with some speed?\nhttps://www.shadertoy.com/events/competition2016", "tags": ["retro", "demo", "challenge", "speed", "drive", "80", "shadertoycompetition", "sh16b"], "likes": 7, "viewed": 433, "published": 3, "date": "1631627240", "time_retrieved": "2024-07-30T19:01:21.634995", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // chromatic abberation\n    float caStrength\t= 0.005;\n    vec2 caOffset \t\t= screenUV - 0.5;\n\tvec2 caUVG\t\t\t= screenUV + sin(iTime)*sin(iTime)*sin(iTime)+ caOffset * caStrength;\n\tvec2 caUVB\t\t\t= screenUV + sin(iTime)*sin(iTime)+ caOffset * caStrength * 2.0;\n\n    vec3 color;\n    color.x = texture( iChannel0, screenUV ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;    \n    \n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Scene traycing\n\n//#define DEBUG_CAMERA\n//#define DEBUG_LIGHTING\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat gMaterial     \t\t= 0.0;\nfloat gTime         \t\t= 0.0;\nfloat gCarOffset    \t\t= 0.0;\nfloat gStreetLampDist\t\t= 100000.0;\nfloat gCarLampDist\t\t\t= 100000.0;\nfloat gReflStreetLampDist\t= 100000.0;\nfloat gFogDensity\t\t\t= 0.1;\nfloat gFogHeightFalloff\t\t= 0.1;\n\nconst float MTRL_ROAD           = 1.0;\nconst float MTRL_BUILDING       = 2.0;\nconst float MTRL_CAR            = 3.0;\nconst float MTRL_STREETLAMPS    = 4.0;\nconst float MTRL_TUNNEL\t\t\t= 5.0;\nconst float INTERIOR_START      = 59.0;\nconst float INTERIOR_END        = 67.0;\n\nfloat Saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat Torus( vec3 p, float r, float h )\n{\n    vec2 q = vec2( length( p.yz ) - h, p.x );\n    return length( q ) - r;\n}\n\nfloat Plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat HexPrism( vec3 p, float h, float r )\n{\n    vec3 q = abs( p );\n    return max( q.z - r, max( ( q.x * 0.866025 + q.y * 0.5 ), q.y ) - h );\n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nfloat Circle( vec2 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Intersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n    return min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat SubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r - a, r - b ), vec2( 0.0, 0.0 ) );\n    return max( r, min( a, b ) ) - length( u );\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat StreetLamps( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gStreetLampDist = min( gStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat Pyramid( vec3 p, float h ) \n{\n    vec3 q = abs( p );\n    return max( -p.y, ( q.x + q.y + q.z - h ) / 3.0 );\n}\n\nfloat Pyramids( vec3 p )\n{    \n    p += vec3( -1220.0, 0.0, 0.0 );    \n    vec3 t = p;\n\n    float rx = 200.0;\n    float rz = 150.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float a = Pyramid( t, 30.0 );\n    \n    t = p;\n\n    rx = 400.0;\n    rz = 300.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float b = Pyramid( t, 80.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Obelisks( vec3 p )\n{    \n    p += vec3( -1220.0, -50.0, 0.0 );       \n    \n    float rx = 200.0;\n    float rz = 150.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z = mod( p.z, rz ) - 0.5 * rz;\n    \n    Rotate( p.xz, 0.5 + gTime * 1.5 );\n    float a = Pyramid( p, 30.0 );\n    Rotate( p.xz, -1.0 - gTime * 3.0 );\n    \n    p.y += 7.0;\n    \n    Rotate( p.yx, -MATH_PI );\n    float b = Pyramid( p, 20.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Buildings( vec3 p )\n{        \n    vec3 t = p;\n    float rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float a = HexPrism( t.xzy, 18.0, 40.0 );\n    float at = HexPrism( t.xzy, 12.0, 50.0 );\n    a = Substract( a, at );    \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float b = Box( t, vec3( 20.0, 66.0, 20.0 ) );\n    float bt = Box( t + vec3( 0.0, -66.0, 0.0 ), vec3( 15.0, 6.1, 15.0 ) );\n    b = Substract( b, bt );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float c = Box( t, vec3( 20.0, 99.0, 20.0 ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float d = Cylinder( t, 20.0, 4.0 * 33.0 );\n    \n    return Union( Union( Union( a, b ), c ), d );\n}\n\nfloat Car( vec3 p )\n{        \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = Box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float b = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float c = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float d = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    Rotate( t.yx, -0.05 );\n    float e = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float f = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n    \n    t = p;\n    t.z = abs( t.z );\n    t += vec3( -3.9, -0.6, 0.0 );\n    float spoiler = Box( t, vec3( 0.2, 0.05, 1.7 ) );\n    spoiler = Union( spoiler, Box( t - vec3( 0.0, -0.25, 1.4 ), vec3( 0.2, 0.3, 0.15 ) ) );\n    \n    float bloom = Box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n    gCarLampDist = min( gCarLampDist, bloom );\n    \n    t = p + vec3( 1.0, -0.6, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float frontWindow = Box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float backWindow = Box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = Union( Substract( a, Union( Union( Union( b, c ), Intersect( d, e ) ), f ) ), spoiler );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    Rotate( t.yz, -0.9 );\n    float sideCutPlanes = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = SubstractChamfer( body, Union( backWindow, frontWindow ), 0.1 );\n    body = SubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.7 );\n    float wheel = Cylinder( t, 0.7, 1.0 );\n    body = Substract( body, wheel );\n    \n    wheel = Substract( Cylinder( t, 0.55, 0.3 ), Sphere( t + vec3( 0.0, -0.15, 0.0 ), 0.35 ) );\n    \n    body = Union( body, wheel );\n    \n    return body;\n}\n\nfloat Curb( vec3 p )\n{\n    float y = p.y - 0.5;\n    float z = -abs( p.z ) + 14.0;    \n    return max( y, z );   \n}\n\nfloat Tunnel( vec3 p )\n{\n    vec3 t = p;\n    t += vec3( -2510.0, 0.0, 0.0 );\n    float a = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float b = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    a = Substract( a, b );\n        \n    t = p;\n    t += vec3( -7870.0, 0.0, 0.0 );\n    float c = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float d = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    c = Substract( c, d );\n    \n    float rx = 12.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = abs( t.z );\n    b = Box( t + vec3( 0.0, 0.0, -16.0 ), vec3( 4.0, 12.0, 2.0 ) );   \n    \n    return Substract( Union( a, c ), b );\n}\n\nfloat CarInterior( vec3 p )\n{\n    p.y -= 3.0;\n    \n    vec3 t = p;\n    Rotate( t.xy, -0.7 );\n    float wheel     = Torus( t + vec3( 0.0, 3.2, 2.0 ), 0.24, 2.4 );\n    vec3 s = t + vec3( 0.0, sin( 0.3 * t.z - 1.7 ) * 0.3 + 0.1, 0.0 );\n    float dashboard = Box( s + vec3( -1.6, 2.0, 0.0 ), vec3( 0.8, 2.0, 10.0 ) );\n    Rotate( t.xy, 0.3 );\n    float d         = Box( t + vec3( -0.1, 2.2, 0.8 ), vec3( 1.0, 1.2, 7.0 ) );\n    dashboard = SubstractRound( dashboard, d, 0.4 );\n    \n    return Union( wheel, dashboard );\n}\n\nfloat TerrainAO( vec3 p )\n{\n    float ret = 1.0;\n    \n    vec3 t = p + vec3( -gCarOffset, -1.0, -3.0 );\n    float car = Box( t, vec3( 2.8, 5.0, 1.6 ) );\n    ret = min( ret, smoothstep( 0.0, 1.0, car * 0.9 ) );\n  \n    t = abs( p );\n    float rx = 50.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.y -= 2.0;\n    t.z -= 15.0;\n    float streetLamps = Cylinder( t, 0.2, 2.0 );\n    ret = min( ret, smoothstep( 0.0, 1.0, streetLamps * 0.1 ) );\n    \n    t = p;\n    rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float buildings = HexPrism( t.xzy, 18.0, 40.0 );        \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 66.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 99.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Cylinder( t, 20.0, 4.0 * 33.0 ) );\n    \n    ret = min( ret, smoothstep( 0.0, 1.0, buildings * 0.05 ) );\n    return mix( ret, 1.0, 0.5 );\n}\n\nfloat Scene( vec3 p )\n{    \n    float terrain   = Union( Plane( p, vec4( 0.0, 1.0, 0.0, 0.0 ) ), Curb( p ) );\n    float tunnel    = Tunnel( p );\n    \n    if ( gTime >= 77.0 )\n    {\n        vec3 t = p;\n        t.z = abs( p.z );\n        terrain = Substract( terrain, Plane( t, vec4( 0.0, 0.0, -1.0, 18.0 ) ) );\n        terrain = Union( terrain, Box( t + vec3( -7700.0, 0.0, -20.0 ), vec3( 10000.0, 3.0, 2.0 ) ) );\n    }\n\n    float buildings = gTime <= 25.0 ? Pyramids( p ) : ( gTime < 77.0 ? Buildings( p ) : Obelisks( p ) );\n    float streetLamps = StreetLamps( p );\n    \n    p += vec3( -gCarOffset, -1.0, -3.0 );\n    float car = gTime > INTERIOR_START && gTime < INTERIOR_END ? CarInterior( p ) : Car( p );\n                        \n    float ret = Union( Union( Union( Union( terrain, buildings ), streetLamps ), car ), tunnel );\n\n    gMaterial = MTRL_TUNNEL;    \n\tgMaterial = terrain \t<= ret ? MTRL_ROAD \t\t\t: gMaterial;\n    gMaterial = buildings \t<= ret ? MTRL_BUILDING\t\t: gMaterial;\n    gMaterial = car \t\t<= ret ? MTRL_CAR \t\t\t: gMaterial;\n    gMaterial = streetLamps <= ret ? MTRL_STREETLAMPS \t: gMaterial;\n \n    return ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 500.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 64; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n        Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n        Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n    return normalize( -nor );\n}\n\nfloat SpeedMeterY( vec2 p )\n{\n    p -= vec2( 4.0, 3.8 );\n    float d = Circle( p, 0.02 );\n    \n\tvec2 t = p;\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.08, 0.01 ) ) );\n    \n    t = p;\n    Rotate( t.xy, 0.4 );\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.03, 0.01 ) ) );\n    d = max( d, -Circle( p + vec2( 0.0, 0.71 ), 0.51 ) );\n    \n    return d;\n}\n\nfloat SpeedMeterR( vec2 p, float t )\n{\n    p -= vec2( 4.0, 3.8 );\n\n    Rotate( p.xy, t + 0.5 + 0.5 * sin( t + 2.0 * gTime ) );\n    float d = Rectangle( p + vec2( -0.32, 0.0 ), vec2( 0.18, 0.01 ) );\n    \n    return d;\n}\n\nvec3 Dashboard( vec3 p3 )\n{\n    p3.x -= gCarOffset;\n    \n    vec2 p;\n    p.x = p3.z;\n    p.y = p3.y * 1.3 + 1.8;\n\n\tvec3 color \t= vec3( 0.0 );\n    vec3 yellow = vec3( 0.9, 0.7, 0.1 );\n    vec3 red \t= vec3( 1.0, 0.1, 0.4 );\n    vec3 purple\t= vec3( 0.54, 0.42, 0.78 );\n    \n    float dy = min( SpeedMeterY( p ), SpeedMeterY( p + vec2( 2.0, 0.0 ) ) );\n    \n    float horBarsY = 100000.0;\n    // yellow horizontal bars\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 1.5 ) / 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) / 6.0;\n        horBarsY = min( horBarsY, Rectangle( p - vec2( 7.3 + sizeX, 3.05 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }\n    \n    float dr = 100000.0;\n    // vertical bars\n    for ( int i = 0; i < 3; ++i )\n    {\n        float sy = 0.45 + floor( ( 0.1 * ( 3.0 * sin( 14.0 * gTime ) + sin( 7.0 * gTime ) ) ) / 0.2 ) * 0.2;\n\t\tsy *= i == 1 ? 1.0 : 0.39;\n\t\tdr = min( dr, Rectangle( p - vec2( 5.6 + float( i ) * 0.4, 3.8 ), vec2( 0.1, sy ) ) );\n    }\n    \n    vec2 t = p;\n    t.y = mod( t.y, 0.2 ) - 0.5 * 0.2;\n\tfloat di = Rectangle( t, vec2( 100.0, 0.06 ) );\n    dr = max( dr, -di );\n    \n    dr = min( dr, min( SpeedMeterR( p, 0.0 ), SpeedMeterR( p + vec2( 2.0, 0.0 ), 1.0 ) ) );\n\n    // red horizontal bars\n    float horBarsR = 100000.0;\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 0.5 ) / 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) / 6.0;\n        sizeX = 0.7 * floor( sizeX * 6.0 ) / 6.0;\n        horBarsR = min( horBarsR, Rectangle( p - vec2( 7.3 + sizeX, 3.225 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }    \n    \n    // horizontal bar segments\n    t = p;\n    t.x += 0.2;\n    t.x = mod( t.x, 0.26 ) - 0.5 * 0.26;\n\tdi = Rectangle( t, vec2( 0.06, 100.0 ) );\n    dr = min( dr, max( horBarsR, -di ) );\n    dy = min( dy, max( horBarsY, -di ) );\n    \n    float dp = 100000.0;\n    p.x = mod( p.x, 2.0 ) - 1.0;\n    dp = min( dp, Rectangle( p - vec2( 0.0, 3.8 ), vec2( 0.01, 1.2 ) ) );\n    \n    color += 2.0 * yellow \t* Saturate( exp( -dy * 40.0 ) );\n    color += 1.5 * red \t\t* Saturate( exp( -dr * 40.0 ) );\n    color += 1.0 * purple\t* Saturate( exp( -dp * 40.0 ) );\n    return p3.x - p3.y * 0.3 > -0.7 ? color : vec3( 0.0 );\n}\n\nmat3 CameraLookAt( vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize( ta - ro);\n    vec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n    vec3 cu = normalize( cross( cw, cp ) );\n    vec3 cv = normalize( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 Sky( vec3 rayDir )\n{\n    // sky and sun\n    vec3 skyPos     = rayDir;\n    vec2 skyAngle   = vec2( atan( skyPos.z, skyPos.x ), acos( skyPos.y ) );\n\n    float sun = 1.0 - clamp( 6.0 * length( skyAngle - vec2( 0.0, 1.5 ) ) - 1.0, 0.0, 1.0 );\n    float sky = clamp( 1.0 - 1.5 * skyPos.y, 0.0, 1.0 );\n\n    float sunLines = 1.0 - clamp( sin( skyPos.y * skyPos.y * 500.0 ), 0.0, 1.0 );\n    vec3 sunColor = mix( vec3( 1.0, 0.2, 0.5 ), vec3( 1.0, 0.2, 0.0 ) * 4.0, clamp( skyPos.y * 6.0, 0.0, 1.0 ) );\n    sun *= gTime > 0.3 ? 3.0 - 2.0 * smoothstep( 0.0, 1.0, ( gTime - 0.3 ) * 0.5 ) : 1.0;\n    vec3 color = vec3( 0.54, 0.42, 0.78 ) * 0.2 * sky * 4.0 + sunColor * sun * sunLines;\n\n    // stars\n    vec2 starTile   = floor( skyAngle.xy * 20.0 );\n    vec2 starPos    = fract( skyAngle.xy * 20.0 ) * 2.0 - 1.0;\n    float starRand  = Rand( starTile + vec2( 0.1, 0.3 ) );\n    starRand = starRand > 0.9 ? starRand : 0.0;\n    color += vec3( 2.0 ) * starRand * clamp( 1.0 - ( 6.0 + 3.0 * sin( gTime * 2.0 + 20.0 * skyAngle.y ) ) * length( starPos ), 0.0, 1.0 ) * ( sun > 0.0 ? 0.0 : 1.0 );\n    return color;\n}\n\nfloat SceneRefl( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gReflStreetLampDist = min( gReflStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat CastReflectionRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 100.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 16; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = SceneRefl( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\nvec3 SceneReflection( vec3 pos, vec3 normal, vec3 rayDir )\n{\n\tvec3 reflDir = reflect( rayDir, normal );\n    float t = CastReflectionRay( pos + 0.5 * reflDir, reflDir );\n    float w = abs( normal.x - 1.0 ) < 0.5 ? 0.3 : 1.0;    \n    \n    vec3 color = Sky( reflDir ) * mix( 1.0, 0.7, w * float( t >= 0.0 ) );\n    color += w * vec3( 0.54, 0.42, 0.78 ) * 2.0 * vec3( Saturate( exp( -gReflStreetLampDist * 0.6 ) ) );\n    return color;\n}\n\nvec3 SceneBloom( vec3 rayOrigin, vec3 rayDir )\n{\n    vec3 color = vec3( 0.0 );\n\n    vec3 center = vec3( 25.0, 14.0, 16.0 );\n    vec3 left   = vec3( 0.0, 0.0, 1.0 );\n    center += left * clamp( dot( rayOrigin - center, left ), -7.0, 7.0 );   \n    \n\tcolor += vec3( 0.54, 0.42, 0.78 ) * 0.5 * vec3( Saturate( exp( -gStreetLampDist * 0.6 ) ) );\n    color += vec3( 1.2, 0.1, 0.2 ) * 0.3 * vec3( Saturate( exp( -gCarLampDist * 2.0 ) ) );\n\n    return color;\n}\n\nfloat SmoothNoise( vec3 v )\n{\n\tvec3 i = floor( v );\n\tvec3 f = fract( v );\n\n\tf = f * f * ( -2.0 * f + 3.0 );\n\n\tvec2 uv\t\t= ( i.xy + vec2( 7.0, 17.0 ) * i.z ) + f.xy;\n\tfloat lowz\t= textureLod( iChannel0, ( uv.xy + 0.5 ) / 64.0, 0.0 ).x;\n\n\tuv\t\t\t= ( i.xy + vec2( 7.0, 17.0 ) * ( i.z + 1.0 ) ) + f.xy;\n\tfloat highz = textureLod( iChannel0, ( uv.xy + 0.5 ) / 64.0, 0.0 ).x;\n\tfloat r\t\t= mix( lowz, highz, f.z );\n\n\treturn 2.0 * r - 1.0;\n}\n\nfloat DensityNoise( vec3 pos, vec3 noisePosScale, vec3 noisePosScaleBias, float noiseScale, float noiseBias )\n{\n\tpos = pos * noisePosScale + noisePosScaleBias;\n\n\tfloat noise = SmoothNoise( pos ) + 0.5 * SmoothNoise( pos * 3.07 );\n\tnoise = Saturate( noise * noiseScale + noiseBias );\n\n\treturn noise;\n}\n\nvoid VolumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT, vec2 fragCoord )\n{\n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( fragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = 0; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n        \tfloat s = DensityNoise( p, vec3( 0.3 ), vec3( 0.0, 0.0, 0.0 ), 1.0, 0.0 ) * exp( -p.y * gFogHeightFalloff );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - Saturate( fogAlpha );\n    color = color * fogAlpha + vec3( 1.0 ) * ( 1.0 - fogAlpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime       = iChannelTime[ 3 ];\n    gCarOffset  = 100.0 * gTime;\n    \n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * screenUV;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    float mbStrength\t= 1.0;\n    float fov\t\t\t= 1.2;\n    float cameraOffset  = gCarOffset;\n    float theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    float phi           = 6.0 * mo.x;\n    vec3 target         = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    float zoom          = 15.0;\n\n    // center game camera\n\tgFogDensity\t\t\t= 0.1;\n\tgFogHeightFalloff\t= mix( 0.1, 0.3, Saturate( ( gTime - 13.0 ) * 0.25 ) );\n    mbStrength\t\t\t= 1.0;\n    zoom            \t= 10.0 + 1.2 * sin( gTime );\n    cameraOffset    \t= gCarOffset;\n    target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );\n    phi             \t= 2.8;\n    theta           \t= 1.267;    \n\n    if ( gTime > 18.8 )\n    {\n        // right side near camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;        \n        mbStrength\t\t\t= 1.0;\n        float camWeight \t= smoothstep( 0.0, 1.0, Saturate( ( gTime - 18.8 ) * 0.25 ) );\n        zoom            \t= mix( zoom, 8.0 + sin( gTime ), camWeight );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );    \n        phi             \t= mix( phi, 2.35, camWeight );\n        theta          \t\t= mix( theta, 1.27, camWeight );\n    }\n    if ( gTime > 33.0 )\n    {\n        // top chase camera     \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.01;        \n        mbStrength\t\t\t= 0.0;        \n        zoom            \t= 130.0;\n        cameraOffset    \t= gCarOffset - ( gTime - 38.0 ) * 80.0;\n        target          \t= vec3( cameraOffset + 2.0, 5.0, 0.0 );\n        phi             \t= 2.3;\n        theta           \t= 0.4;\n    }\n    if ( gTime > 43.0 )\n    {\n        // building camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 10.0;        \n        mbStrength\t\t\t= 0.0;\n        fov\t\t\t\t\t= 2.0;\n        cameraOffset    \t= gCarOffset - 10.0;\n        target         \t \t= vec3( gCarOffset + 2.0, 15.0, -16.0 );    \n        zoom            \t= 1.0;    \n        phi             \t= 0.0;\n        theta           \t= 0.0;\n    }\n    if ( gTime > 53.5 )\n    {\n        // left side near low camera  \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;                \n        mbStrength\t\t\t= 1.0;\n        fov\t\t\t\t\t= min( 1.2 + ( gTime - 53.5 ) * 0.2, 0.8 );\n        zoom            \t= 8.0 + 3.0 * cos( gTime );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, -1.0 );\n        phi             \t= 3.14;\n        theta           \t= 1.4;\n    }\n    if ( gTime > INTERIOR_START )\n    {\n        // interior camera\n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 2.0;\n        zoom            = 7.0;    \n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 1.0, 2.8, 5.5 );        \n        phi             = 2.46;\n        theta           = 1.17;  \n    }\n    if ( gTime > INTERIOR_END )\n    {        \n        // center game camera and left side near camera     \n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 1.2;\n\t\tfloat camWeight = gTime < 95.0 ? smoothstep( 0.0, 1.0, Saturate( ( gTime - 80.0 ) * 0.25 ) ) : smoothstep( 1.0, 0.0, Saturate( ( gTime - 95.0 ) * 0.25 ) );\n        zoom            = mix( 10.0, 6.0, camWeight ) + 1.3 * sin( gTime );\n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 2.0, 5.0, mix( 3.0, -1.0, camWeight ) );\n        phi             = mix( 2.8, 3.5, camWeight );\n        theta           = mix( 1.267, 0.8, camWeight );\n    }\n    if ( gTime > 99.5 )\n    {\n        fov\t= max( 1.2 - ( gTime - 99.5 ) * 0.5, 0.5 );\n    }\n    if ( gTime > 100.0 )\n    {\n        gCarOffset += ( gTime - 100.0 ) * 10.0;\n    }\n    \n#ifdef DEBUG_CAMERA\n    // orbiting debug camera\n    cameraOffset  = gCarOffset;\n    theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    phi           = 6.0 * mo.x;\n    target        = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    zoom          = 5.0;\n#endif\n    \n    vec3 rayOrigin;    \n    rayOrigin.x = zoom * sin( theta ) * cos( phi ) + cameraOffset;\n    rayOrigin.y = zoom * cos( theta );\n    rayOrigin.z = zoom * sin( theta ) * sin( phi );\n\n    mat3 worldToCamera = CameraLookAt( rayOrigin, target, 0.0 );\n    \n    // ray direction\n    vec3 rayDir = worldToCamera * normalize( vec3(p.xy,fov) );  \n    vec3 color = vec3( 0.0 );\n    \n    float t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        vec3 sunDir = normalize( vec3( -300., -200.0, 0.0 ) ); // sun pos\n        vec3 sunColor = vec3( 1.0, 0.2, 0.0 ) * 0.5;\n        \n        vec3 posLS  = pos * 0.1;        \n        vec3 nrmLS  = normal;\n        vec3 absNrm = abs( nrmLS );\n\n        float maxAbsNrm = max( max( absNrm.x, absNrm.y ), absNrm.z );\n        vec2 uvXZ   = absNrm.x >= maxAbsNrm ? posLS.zy : posLS.xy; \n        vec2 uvXYZ  = absNrm.y >= maxAbsNrm ? posLS.xz : uvXZ;\n      \n        vec3 diffuseColor = vec3( 1.0 );\n        vec3 specularColor = vec3( 0.04 );\n        vec3 emissive = vec3( 0.0 );\n        \n        // road\n        diffuseColor = vec3( pos.y > 20.0 ? 0.3 : 0.5 );\n        if ( gMaterial == MTRL_ROAD && abs( pos.z ) < 14.0 )\n        {\n            diffuseColor = vec3( 0.5 );\n            if ( abs( pos.z ) < 0.2 )\n            {\n                diffuseColor = vec3( 1.0 );\n            }\n\n\t\t\tif ( ( abs( pos.z + 7.0 ) < 0.2 || abs( pos.z - 7.0 ) < 0.2 ) )\n            {\n                diffuseColor = vec3( 0.5 + 0.5 * exp( -4.0 * abs( 2.0 * fract( pos.x * 0.1 ) - 1.0 ) ) );\n            }\n            \n            // red trail\n            float trailX = pos.x - gCarOffset;\n            emissive = 1.2 * vec3( 1.1, 0.0, 0.0 ) \n                * Saturate( exp( -0.4 * abs( pos.z - 3.0 ) ) )\n                * Saturate( 1.0 + trailX * 0.002 )\n                * Saturate( -0.5 - trailX * 0.5 );\n        }\n        \n        // lamp\n        if ( gMaterial == MTRL_STREETLAMPS )\n        {\n            emissive = pos.y > 11.5 && normal.y > 0.5 ? vec3( 1.0 ) : vec3( 0.0 );\n        }        \n        \n        if ( gMaterial == MTRL_BUILDING && abs( normal.y ) < 0.1 )\n        {\n            diffuseColor = vec3( 0.7 );\n                \n            vec2 tilePos    = fract( uvXZ * 4.0 );\n            vec2 tileId     = uvXZ * 4.0 - tilePos;\n            vec2 edge       = min( clamp( ( tilePos - 0.2 ) * 5.0, 0.0, 1.0 ), clamp( ( 1.0 - tilePos ) * 5.0, 0.0, 1.0 ) );       \n            float bump      = edge.x * edge.y;\n\n            float tileRand = Rand( tileId );\n            vec3 tileColor = vec3( 0.3 );\n            tileColor = tileRand > 0.5 ? vec3( 1.0, 0.3, 0.5 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.7 ? vec3( 1.0, 0.5, 0.0 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.9 ? vec3( 1.0, 0.5, 0.9 ) * 1.2 : tileColor;\n            emissive = 1.0 * bump * tileRand * tileColor;\n            \n            emissive *= clamp( 4.0 * abs( tilePos.x - 0.5 ) + 0.5, 0.0, 1.0 );\n            emissive *= clamp( 4.0 * abs( tilePos.y - 0.5 ) + 0.5, 0.0, 1.0 );\n        }\n        \n        if ( gMaterial == MTRL_BUILDING )\n        {\n            float buildingLine = abs( 2.0 * fract( uvXZ.y * 2.0 - 0.05 ) - 1.0 );\n            emissive += 2.0 * vec3( 0.54, 0.42, 0.78 ) * ( exp2( -buildingLine * 4.0 ) );\n            if ( pos.y < 5.0 )\n            {\n                emissive = vec3( 0.0 );\n            }    \n            \n            if ( abs( -normal.y - 1.0 ) < 0.1 )\n            {\n                diffuseColor \t= vec3( 0.3 );\n                emissive \t\t= vec3( 0.0 );\n            }\n        }\n        \n        if ( gMaterial == MTRL_TUNNEL )\n        {\n            diffuseColor = vec3( 0.8 );\n        }        \n        \n        // car \n        if ( gMaterial == MTRL_CAR )\n        {\n            diffuseColor = vec3( 0.1 );\n            specularColor = vec3( 0.6 );\n            \n            // car lamp emissive\n            vec2 pl = pos.zy;\n            pl.x = abs( pl.x - 3.0 );\n            float dl = Rectangle( pl + vec2( -1.0, -1.3 ), vec2( 0.4, 0.06 ) );\n            float es = Saturate( exp( -dl * 20.0 ) );\n            emissive = 1.5 * vec3( 1.2, 0.1, 0.3 ) * es;\n            specularColor *= 1.0 - es;\n        }\n        \n        // car interior\n        if ( gMaterial == MTRL_CAR && gTime > INTERIOR_START && gTime < INTERIOR_END )\n        {\n            diffuseColor    = vec3( 0.2 );\n            specularColor   = vec3( 0.04 );\n            emissive        = Dashboard( pos );\n        }\n        \n        float wrap = 0.5;\n        vec3 diffuse = diffuseColor * sunColor * Saturate( ( dot( normal, sunDir ) + wrap ) / ( 1.0 + wrap ) );\n        color = diffuse;\n        \n        vec3 halfVec2       = normalize( sunDir + rayDir );\n        float NdotH2        = dot( normal, halfVec2 );\n        color += sunColor * specularColor * Saturate( dot( normal, sunDir ) ) * pow( clamp( NdotH2, 0.0, 1.0 ), 32.0 );        \n        \n        // local lights\n        vec3 pos2       = pos;\n        pos2.x = mod( pos2.x, 50.0 );                \n\n        vec3 tubeColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 tubePos    = vec3( 25.0, -10.0, 0.0 );\n        vec3 tubeLeft   = vec3( 0.0, 0.0, 1.0 );        \n        tubePos += tubeLeft * clamp( dot( pos2 - tubePos, tubeLeft ), -7.0, 7.0 );        \n        \n        vec3 tubeDir = normalize( tubePos - pos2 );\n        float tubeAtt = 1.0 / pow( length( tubePos - pos2 ), 2.0 );\n        color += diffuseColor * tubeColor * tubeAtt * Saturate( dot( normal, tubeDir ) );\n        \n        // car lights\n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = vec3( 3.1 + gCarOffset, -1.5, 3.0 );\n        vec3 spotDir    = normalize( spotPos - pos );\n        float spotAtt = 1.0 / pow( length( spotPos - pos ), 2.0 );\n        spotAtt *= Saturate( -spotDir.x * 6.0 - 4.0 );\n        color += diffuseColor * spotColor * spotAtt * Saturate( dot( normal, spotDir ) );                \n\n        // ambient\n        color += 0.1 * vec3( 0.54, 0.42, 0.78 ) * clamp( -normal.y + 0.5, 0.0, 1.0 );        \n        color *= gMaterial == MTRL_ROAD   ? TerrainAO( pos ) : 1.0;\n        \n        // emissive\n        color += emissive;\n                \n        // reflection\n        float fresnel = Saturate( pow( 1.0 + dot( rayDir, -normal ), 5.0 ) );\n        specularColor = mix( specularColor, vec3( 1.0 ), fresnel );\n        specularColor = gMaterial == MTRL_ROAD || gMaterial == MTRL_TUNNEL? specularColor * 0.05 : specularColor;        \n        color += specularColor * 0.5 * SceneReflection( pos, normal, rayDir );\n        \n        // back plane\n        color *= 1.0 - clamp( ( t - 200.0 ) * 0.01, 0.0, 1.0 ) * 0.8;\n        \n        // wireframe\n        vec2 tilePos = mod( uvXYZ * vec2( gMaterial == MTRL_BUILDING ? 2.0 : 0.5, 2.0 ), 1.0 );\n        tilePos = abs( 2.0 * tilePos - 1.0 );\n        float wireframe = ( exp2( -tilePos.x * 6.0 ) + exp2( -tilePos.y * 6.0 ) );         \n        float wireframeAlpha = gTime > 50.0 ? Saturate( ( pos.x - 7080.0 ) * 0.05 ) * Saturate( ( 8080.0 - pos.x ) * 0.05 ) : Saturate( 1.0 - ( gTime - 13.5 ) / 4.0 );\n        wireframeAlpha = gMaterial == MTRL_CAR ? 0.0 : wireframeAlpha;\n        \n        color = mix( color, Sky( rayDir ) + wireframe * vec3( 0.54, 0.42, 0.78 ) * 1.2, wireframeAlpha );\n        mbStrength *= 1.0 - wireframeAlpha;\n        \n#ifdef DEBUG_LIGHTING\n\t\tcolor = mix( vec3( 1.0, 0.5, 0.0 ), vec3( 0.0, 0.0, 1.0 ), 0.5 * normal.y + 0.5 );\n#endif\n    }\n    else\n    {\n        color \t\t= Sky( rayDir );\n        mbStrength \t= 0.0;\n    }\n    \n    VolumetricFog( color, rayOrigin, rayDir, t, fragCoord );\n\tcolor += SceneBloom( rayOrigin, rayDir );\n    color *= Saturate( ( 107.0 - gTime ) / 5.0 );\n    \n    fragColor = vec4( color, mbStrength );\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4160, "src": "https://soundcloud.com/daawatcha-1/blood-dragon-theme", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Post processing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    // radial blur\n    vec4 mainSample = texture( iChannel0, screenUV );    \n    vec2 blurOffset = ( screenUV - vec2( 0.5 ) ) * 0.002 * mainSample.w;\n    vec3 color = mainSample.xyz;\n\tfor ( int iSample = 1; iSample < 16; ++iSample )\n\t{\n\t\tcolor += texture( iChannel0, screenUV - blurOffset * float( iSample ) ).xyz;\n\t}    \n    color /= 16.0;\n    \n    // vignette\n    float vignette = screenUV.x * screenUV.y * ( 1.0 - screenUV.x ) * ( 1.0 - screenUV.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n    \n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;    \n        \n    fragColor = vec4( color, 1.0 );\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 572]], "test": "untested"}
{"id": "fsyGDw", "name": "大龙猫 - Space Debrit", "author": "totetmatt", "description": "F simple, nothing fancy but don't know, I like it :) ", "tags": ["space"], "likes": 26, "viewed": 559, "published": 3, "date": "1631624587", "time_retrieved": "2024-07-30T19:01:22.502675", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat diam(vec3 p,float s){\n     p = abs(p);\n     return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\nvec2 sdf(vec3 p){\n    p.xz*=rot(iTime*.1);\n    vec2 h;\n    h.x = 1000.+length(p)-1.;\n    vec4 pp = vec4(p,1.);\n    float s = 0.;\n    for(float i=0.;i<=9.;i++){\n        pp.xyz = abs(pp.xyz)-9.95;;\n        pp*=1.7;\n        pp.xz*=rot(.785+i);\n        pp.xy*=rot(-.785+i);\n        float q = (diam(pp.xyz,1.95))/pp.a;\n        h.x = mod(i,2.)==0. ? mix(q,h.x,0.75): min(q,h.x);\n        s+=clamp(cos(pp.y)+sin(pp.x),0.,1.);\n    }\n    s/=pp.a*1.8;\n    h.x = min(length(p)-1.-s,h.x);\n    h.y = 1.;\n    return h;\n}\n\n#define q(s) s*sdf(p+s).x\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define gao(rp,n) (ao(rp,n,.1)+ao(rp,n,.3)+ao(rp,n,.7))\nvec3 norm(vec3 p,float ee){ vec2 e=vec2(-ee,ee) ; return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=.5;\n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rp = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(.1);\n    vec3 light = vec3(1.,2.,-3.);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(d.x <=.001){\n            vec3 n = norm(rp,.0003);\n            float diff =max(0.,dot(normalize(light-rp),n));\n            col = vec3(1.)*diff;\n            col = mix(vec3(.1),col,gao(rp,n)/2.);\n            break;\n        \n        }\n        rp+=rd*d.x;\n    \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 93, 93, 157], [158, 158, 175, 175, 663], [784, 784, 811, 811, 889], [890, 890, 945, 945, 1537]], "test": "untested"}
{"id": "7sK3DR", "name": "Polygon Landscapes", "author": "byt3_m3chanic", "description": "Trying to master the art of placing items on a noise generated ground - and not float above or crash under. \n// also I guess I'm still tweaking this - lol, hard to put a shader down.", "tags": ["draftdiamondsancds"], "likes": 31, "viewed": 580, "published": 3, "date": "1631613280", "time_retrieved": "2024-07-30T19:01:23.326473", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Polygon Landsacpes\n    9/13/21 @byt3_m3chanic\n    \n    Putting stuff on the ground and making it look half \n    way natural is hard, beginning experiments with it.\n    \n    need better noise functions...\n    \n    Rock shape/object from @gaz https://twitter.com/gaziya5/status/1436924535463309318\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0005\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat hash21(vec2 p) {\n    // @Dave_Hoskins - Hash without sine\n    // but it's HEAVY compile time / sadly and it looks better..\n    // so using other low cost hash for now..\n    \n\t//vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //p3 += dot(p3, p3.yzx + 33.33);\n    //return fract((p3.x + p3.y) * p3.z);\n    return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); \n}\n\nfloat noise (in vec2 uv) {\n    // @morgan3d https://www.shadertoy.com/view/4dS3Wd\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f;// * f * (3.-2.*f);  @Shane's tip for polygonized look..\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//generate terrain using above noise algorithm\nfloat fbm( vec2 p, float freq ) {\t\n\tfloat h = -1.5;\n\tfloat w = 2.50;\n\tfloat m = 0.25;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noise((p * m));\n\t\tw *= 0.5; m *= 2.0;\n\t}\n\treturn h;\n}\n\nfloat gaz( vec3 p, float s) {\n    float e = abs(p.x+p.y)+abs(p.y+p.z)+abs(p.z+p.x)+abs(p.x-p.y)+abs(p.y-p.z)+abs(p.z-p.x)-s;\n    return e/3.5;\n}\n\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//http://mercury.sexy/hg_sdf/\nconst float angle = 2.*PI/6.;\nconst float hfang = angle*.5;\nvoid mpolar(inout vec2 p) {\n    float a = atan(p.y, p.x) + hfang;\n    float c = floor(a/angle);\n    a = mod(a,angle) - hfang;\n    p = vec2(cos(a), sin(a))*length(p);\n} \n\n//globals\nvec3 hitPoint,hit;\nvec2 gid,sid;\nfloat mvt = 0.,snh,gnh;\nmat2 turn,wts;\n\nconst float sz = .325;\nconst float hf = sz*.5;\nconst float db = sz *2.;\nconst float detail = 4.;\nconst float pwr = 1.75;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    p.x+=mvt;\n    float ter = fbm(p.xz*sz,detail)*pwr;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x) {\n       res = vec2(d2,2.);\n       hit=p;\n       gnh=ter;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5;    \n    vec2 r = p.xz - id/sz;\n    vec3 q = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = fbm(id,detail)*pwr;\n    vec3 qq=q-vec3(0,xtr+.2,0);\n\n    mat2 htn = rot(-hs*PI2);\n    qq.yz*= htn;\n    qq.xz*= htn;\n\n    float df = gaz(qq,4.5*hs*hs);\n    if(df<res.x && hs>.5 && xtr>1.75) {\n        res=vec2(df,3.);\n        hit=p;\n        gnh=xtr;\n        gid=id;\n    }\n    \n    float zz = 1.25;\n    vec2 fid = floor(p.xz*zz) + .5;    \n    vec2 fr = p.xz - fid/zz;\n    vec3 fq = vec3(fr.x,p.y,fr.y);\n    \n    hs = hash21(fid);\n    qq=fq-vec3(0,ter+.001,0);\n\n    mpolar(qq.xz);      \n    float adjust = sin(qq.x*12.);\n    float flwr= box(qq,vec3(.3,smoothstep(.01,.35,.035*adjust),.035*adjust));\n    if(flwr<res.x && hs<.1 ) {\n        res=vec2(flwr,4.);\n        hit=qq;\n        gnh=ter;\n        gid=fid;\n    }\n\n    float cells = 8.;\n    vec3 qz = p-vec3(mvt,7.25,0);\n    qz.xz*=turn;\n    // Polar Repetion \n    // @Shane showed me this in one of my first\n    // shaders!\n    float a = atan(qz.z, qz.x);\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    qz.y +=cy;\n\n    qz.xz *= rot(ia);\n    qz.x -= 6.5;\n  \n    wts = rot(ws+T);\n    qz.zy*=wts;\n    qz.xz*=wts;\n\n    float dx = zag(qz,.25);\n    if(dx<res.x) {\n        res=vec2(dx,5.);\n        hit=qz;\n        gnh=ws;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tfloat tx = hash21(floor(p.xy));\n    float ty = hash21(floor(p.zx));\n    float tz = hash21(floor(p.yz));\n    return vec3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 glintz( vec3 lcol, vec3 pos, vec3 n, vec3 rd, vec3 lpos, float fresnel) {\n    vec3 mate = vec3(0);\n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    vec3 tcoord;\n    float pw,q,anisotropy;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n    return  mix(light*vec3(0.3), vec3(.05), fresnel) + glints + lcol * .3;\n}\n\n// compact sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.y+=.2;\n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n\n    vec3 Rayleigh = vec3(1), Mie = vec3(1); \n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    // dist clouds\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 uv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(1.,.475,  fbm(5.*uv/1e5,5.))*\n                                smoothstep(.15, .85, rd.y*.5 + .5)*.4);  \n    }\n\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec3 sky = vec3(0);\n\nvec3 hue(float a, float b, float c) {\n    return b+c*cos(PI2*a*(vec3(1.25,.5,.25)*vec3(.99,.97,.96))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32 ? ray.x*.25 : ray.x*.75; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    sid=gid;\n    snh=gnh;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n      \tvec3 n = normal(p, d);\n        \n        vec3 lpos = vec3(-11.,15,18.);\n        vec3 l = normalize(lpos-p);    \n        float diff = clamp(dot(n,l),0.,1.);\n        float shdw = 1., t = .01;\n\n        for(int i=0; i<24; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = 0.; break;}\n            shdw = min(shdw, 14.*h/t);\n            t += h * .8;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float fresnel = pow(1.0 + dot(n,rd), 2.0);\n        fresnel = mix( 0.0, 0.95, fresnel );\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.5 * pow(max(dot(view, ret), 0.), 24.);\n\n        ref=vec3(.0);\n        vec3 h = vec3(.5);\n        \n        if(m==2.) {\n            vec3 c = mix(vec3(0.647,0.573,0.192),vec3(0.082,0.459,0.145),clamp(.1+snh*.5,0.,1.));\n            h = glintz(c, hitPoint*.05, n, rd, l, fresnel);\n        }\n        if(m==3.) {\n            h = clamp(hue((snh+fresnel)*3.25,.80,.15)*.85,vec3(.1),vec3(1.));\n            ref = h-fresnel;\n        }\n        if(m==4.) {    \n            h = vec3(0.329,0.580,0.020);\n            ref = h-fresnel;\n        }\n        if(m==5.) {    \n            h = vec3(0.286+fresnel,0.576+fresnel,0.953);//hue((snh+fresnel)*3.25,.65,.35);\n            ref = h-fresnel;\n        }\n        C += h * diff+spec;\n        C = mix(vec3(0.392,0.502,0.565),C,  exp(-.000015*d*d*d));\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    \n    C=clamp(C,vec3(.03),vec3(1.));\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt= 280.;//+T*.733;\n    turn = rot(T*.2);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float sf = .5*sin(T*.1);\n    vec3 ro = vec3(0,1.65,13.+sf);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy == vec2(0) ? .0 : .07+(M.y/R.y * .0625 - .03125) * PI;\n    float y = M.xy == vec2(0) ? .0 : -(M.x/R.x * .5 - .25) * PI;\n    float sx = .3*cos(T*.1);\n    mat2 rx = rot(x), ry=rot(y+sx);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n    \n    // sky and vars\n    sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fill=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    float a =0.;\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d);\n        C += pass.rgb*fill;\n        fill*=ref;\n        if(i==0.)a=d;\n    }\n\n    C = mix(sky,C, exp(-.000015*a*a*a));\n    C = pow(C, vec3(.4545));\n    C = clamp(C,vec3(.03),vec3(1.));\n    O = vec4(C,1.0);\n}\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sK3DR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[567, 567, 586, 586, 631], [633, 633, 655, 933, 994], [996, 996, 1022, 1077, 1420], [1422, 1469, 1502, 1502, 1656], [1658, 1658, 1687, 1687, 1802], [1804, 1804, 1832, 1832, 1994], [1996, 1996, 2024, 2024, 2115], [2207, 2207, 2234, 2234, 2374], [2582, 2582, 2600, 2600, 4252], [4254, 4264, 4294, 4294, 4533], [4535, 4535, 4569, 4569, 4773], [4775, 4775, 4853, 4853, 6130], [6132, 6205, 6231, 6231, 6296], [6298, 6298, 6350, 6350, 7039], [7063, 7063, 7100, 7100, 7168], [7170, 7170, 7255, 7255, 9302], [9304, 9304, 9345, 9359, 10331]], "test": "untested"}
{"id": "fs3Gz4", "name": "timeline tutorial", "author": "jcyuan", "description": "timeline tutorial", "tags": ["tutorial", "timeline"], "likes": 7, "viewed": 175, "published": 3, "date": "1631611940", "time_retrieved": "2024-07-30T19:01:24.166228", "image_code": "#define PI 3.141592653589793\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x,d.y), 0.0);\n}\n\nfloat timeSpan(float t, float from, float to) {\n    return clamp((t - from) / (to - from), 0., 1.);\n}\n\nmat2 rot(float a) {\n    float cs = cos(a);\n    float ss = sin(a);\n    return mat2(cs, ss, -ss, cs);\n}\n\nmat2 scale(float sx, float sy) {\n    return mat2(sx, 0., 0., sy);\n}\n\nfloat curve(float v) {\n    float st = step(1., v *= 2.);\n    return mix(\n        .5 * pow(2., 10. * (v - 1.)),\n        .5 * (2. - pow(2., -10. * (v - 1.))),\n        st\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // 整体时间轴缩放\n    float timeScale = 6.;\n    // 规一化\n    float time = fract(iTime / timeScale);\n    \n    // 取得时间片段（返回0到1并使用曲线修改）\n    float t1 = curve(timeSpan(time, .0, .2));\n    float t2 = curve(timeSpan(time, .2, .4));\n    float t3 = curve(timeSpan(time, .4, .6));\n    float t4 = curve(timeSpan(time, .6, .8));\n    float t5 = curve(timeSpan(time, .8, 1.));\n    \n    // 使用各个时间片段做分动画\n    // anim1 从中心移动到左下角\n    vec2 p = mix(uv, uv - vec2(-1., -.3), t1);\n    \n    // anim2 原地旋转\n    p = rot(t2 * PI) * p;\n    \n    // anim3 移动至左上角\n    p = mix(p, p - vec2(0., -.7), t3);\n    \n    // anim4 反向旋转移动到右侧中间\n    p = mix(p, p + vec2(2., -.5), t4);\n    p = rot(-t4 * PI) * p;\n    \n    // anim5 边旋转缩放边回到中间\n    p = mix(p, p + vec2(1., -.1), t5);\n    float s = abs(sin(t5 * PI * .5) - .5) + .5;\n    p = rot(t5 * PI) * scale(s, s) * p;\n    \n    // 显示结果\n    float box = sdBox(p, vec2(.2));\n    float w = fwidth(box);\n    float d = 1. - smoothstep(-w, w, box);\n    \n    fragColor = vec4(vec3(1., 0., 0.) * d, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3Gz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 65, 65, 149], [151, 151, 198, 198, 252], [254, 254, 273, 273, 355], [357, 357, 389, 389, 424], [426, 426, 448, 448, 602], [604, 604, 659, 659, 1893]], "test": "untested"}
{"id": "7sV3WD", "name": "Rectagular Subdivisor", "author": "Tater", "description": "a", "tags": ["2d", "squares", "subdivide"], "likes": 36, "viewed": 718, "published": 3, "date": "1631610882", "time_retrieved": "2024-07-30T19:01:24.912233", "image_code": "//Inspired by the work of @okazz\n//https://twitter.com/okazz_/status/1436332410690441219\n\n//I didn't look at their code but the result is similar enough that I wonder if the\n//algorithm is the same. \n\n//I'm pretty sure there's also a famous painting that looks like this but I can't remember it\n\n#define pi 3.1415926535\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return max(d.x,d.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime*1.2,6000.);\n    float px = 1./iResolution.y;\n    \n    //You can remove the R.x/R.y to get a square\n    vec2 xRange = vec2(-0.5,0.5)*R.x/R.y;\n    vec2 yRange = vec2(-0.5,0.5);\n    float id = 0.;\n    float seed = floor(t/6.);\n    float a;\n    \n    \n    //PLAY WITH THESE VARIABLES :D\n    float minSize = 0.015;\n    //float breakSize = 0.04;\n    float iters = 10.;\n    float borderSize = 0.003;\n    float minIters = 1.;\n    \n    //minSize = min(minSize,breakSize);\n    for(float i = 0.;i<iters;i++){\n        float xLength = xRange.y-xRange.x;\n        float yLength = yRange.y-yRange.x;\n        float dividex = h21(vec2(i+id,seed))*(xLength)+xRange.x;\n        float dividey = h21(vec2(i+id,seed))*(yLength)+yRange.x;\n        \n        dividex= clamp(dividex,xRange.x+minSize,xRange.y-minSize);\n        dividey= clamp(dividey,yRange.x+minSize,yRange.y-minSize);\n        \n        float mn = min(length(xRange.x-dividex),length(xRange.y-dividex));\n        mn = min(mn,min(length(yRange.x-dividey),length(yRange.y-dividey)));\n        if(mn<minSize&&i-1.>minIters) break;\n        \n        ////////////////////////////////\n        ////////////////////////////////\n        vec2 diff = vec2(0);\n        if(uv.x<dividex){\n            xRange = vec2(xRange.x,dividex);\n            diff.x+=dividex;\n        }\n        else{\n            xRange = vec2(dividex,xRange.y);\n            diff.x-=dividey;\n        }\n        if(uv.y<dividey){\n            yRange = vec2(yRange.x,dividey);\n            diff.y-=dividex;\n        }\n        else{\n            yRange = vec2(dividey,yRange.y);\n            diff.y+=dividey;\n        }\n\n        id = length(diff+10.0);\n        \n        xLength = xRange.y-xRange.x;\n        yLength = yRange.y-yRange.x;\n        xLength*=1.0-abs(pow(abs(cos(t*pi/6.)),5.0));\n        yLength*=1.0-abs(pow(abs(cos(t*pi/6.)),5.0));\n        vec2 center = vec2((xRange.x+xRange.y)/2.,(yRange.x+yRange.y)/2.);\n        a = box(uv-center,vec2(xLength,yLength)*0.5);\n        //if(h11(id)<0.2)a=0.;\n    }\n    id = h11(id)*1000.0;\n    vec3 e = vec3(0.5);\n    vec3 al = pal(id*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n    col = clamp(al,0.,1.);\n    col-=smoothstep(-px,px,a+borderSize);\n   // col = vec3(-a*10.0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 340, 340, 411], [412, 412, 433, 433, 485], [486, 499, 566, 566, 605], [606, 606, 632, 632, 682], [683, 683, 740, 740, 3082]], "test": "untested"}
{"id": "7dK3WD", "name": "Kleinian limit set", "author": "neozhaoliang", "description": "Another Kleinian limit set. A mix of the work https://www.shadertoy.com/view/ttdXDl and  https://www.shadertoy.com/view/Wl3fzM", "tags": ["2d", "fractal", "kleinian", "limitset"], "likes": 34, "viewed": 848, "published": 3, "date": "1631608166", "time_retrieved": "2024-07-30T19:01:25.690153", "image_code": "#define L2(x)           dot(x, x)\n#define MAX_ITER        50\n\n\nbool doHalfPlane = true;\n\nconst vec2[] PARAMS = vec2[] (\n    vec2(1.8462756, 0.09627581),\n    vec2(1.958591, 0.011278),\n    vec2(1.857382, 0.076258),\n    vec2(1.64213876, 0.76658841),\n    vec2(1.658312, 0.5),\n    vec2(1.926434053, 0.027381792),\n    vec2(2, 0)\n);\n\nconst int NUM_PARAMS = PARAMS.length();\n\nfloat wrap(in float x, in float a, in float s) {\n    return mod(x - s, a) + s;\n}\n\nvec2 transA(in vec2 z, float a, float b, inout float scale) {\n    float k = 1. / dot(z, z);\n    z *= k;\n    scale *= k;\n    z.x -= b;\n    z.y = a - z.y;\n    return z;\n}\n\nbool separation(in vec2 z, in float a, in float b) {\n    float f = (z.x >= -b/2.0) ? 1.0 : -1.0;\n    float K = sign(b) * (2.0*a - 1.95) / 4.3;\n    float M = 7.2 - (1.95 - a) * 18.0;\n    return z.y >= 0.5*a + K*f*(1.0 - exp(-M*abs(z.x + b * 0.5)));\n}\n\nfloat kleinian(in vec2 z, vec2 pattern, float scale) {\n    float a = pattern.x, b = pattern.y;\n    float f = sign(b);\n    vec2 lz = z + vec2(1), llz = z - vec2(1);\n    for (int i = 0; i < MAX_ITER; i++) {\n        z.x = z.x + f * b / a * z.y;\n        z.x = wrap(z.x, 2.0, -1.0);\n        z.x = z.x - f * b / a * z.y;\n\n        if (separation(z, a, b)) {\n            z = vec2(-b, a) - z;\n        }\n\n        z = transA(z, a, b, scale);\n\t\t\n        // If the iterated points enters a 2-cycle, bail out.\n        if (dot(z-llz, z-llz) < 1e-6) {\n            return abs(z.y)  / scale;\n        }\n    \n       // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n        if (z.y < 0.0)\n            return -z.y/scale;\n        if (z.y > a)\n            return (z.y - a)/scale;\n\n        llz=lz; lz=z;\n    }\n    return 1e3;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    const float zoom = 3.;\n    \n    float time = mod(0.2*iTime, float(NUM_PARAMS));\n    int it = int(floor(time));\n    float ft = fract(time);\n    vec2 pattern = mix(PARAMS[it], PARAMS[(it+1) % NUM_PARAMS], smoothstep(0., 1., ft));\n    float scale = 1.2;\n    vec2 p = uv * 1.1;\n    \n    if (doHalfPlane) {\n        p.y += 1.0;\n        p *= 0.5*pattern.x;\n    }\n    else {\n        p -= vec2(0, -1);\n        float r2 = 2. / dot(p, p);\n        p *= r2;\n        scale *= r2;\n        p += vec2(0, -1);\n    }\n    float aa = 2. / iResolution.y;\n    \n    float d = zoom * kleinian(p, pattern, scale);\n    \n    float b = -0.125;\n    float t = 20.0;\n    const float lh = 1.25;\n    const vec3 lp1 = vec3(.5, .5, lh);\n    const vec3 lp2 = vec3(-0.5, .5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld1 = normalize(lp1 - pp);\n    vec3 ld2 = normalize(lp2 - pp);\n\n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd1 = normalize(lp1 - bp);\n    vec3  srd2 = normalize(lp2 - bp);\n    float bl21 = L2(lp1 - bp);\n    float bl22 = L2(lp2 - bp);\n\n    float st1 = (0.0-b)/srd1.z;\n    float st2 = (0.0-b)/srd2.z;\n    vec3  sp1 = bp + srd1*st1;\n    vec3  sp2 = bp + srd2*st1;\n\n    float bd = zoom * kleinian(bp.xy, pattern, scale);\n    float sd1= zoom * kleinian(sp1.xy, pattern, scale);\n    float sd2= zoom * kleinian(sp2.xy, pattern, scale);\n\n    vec3 col = vec3(0.0);\n    const float ss = 15.0;\n  \n    col       += vec3(1)  * (1.0 - exp(-ss*(max(sd1, 0.0)))) / bl21;\n    col       += vec3(.5) * (1.0 - exp(-ss*(max(sd2, 0.0)))) / bl22;\n    float l   = length(p);\n    float hue = fract(0.75*l-0.3*iTime) + .5;\n    float sat = tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    col       *= (1.0-tanh(0.25*l))*0.5;\n    col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = postprocess(col, fragCoord/iResolution.xy);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 416, 416, 448], [450, 450, 511, 511, 618], [620, 620, 672, 672, 869], [871, 871, 925, 925, 1689], [1692, 1692, 1714, 1714, 1885], [1887, 1887, 1923, 1923, 2162], [2165, 2165, 2222, 2222, 4337]], "test": "untested"}
{"id": "fdK3DD", "name": "Pixel Spirit Deck, Dynamic", "author": "chenglou", "description": "All 50 cards from [url=https://patriciogonzalezvivo.github.io/PixelSpiritDeck]Pixel Spirit[/url].\n[b]Mouse click a card to see the bigger version![/b]\nSlightly modified to add dynamism and anti-aliasing.", "tags": ["sdf", "symbol", "cards", "icon", "pixelspirit"], "likes": 68, "viewed": 1222, "published": 3, "date": "1631597686", "time_retrieved": "2024-07-30T19:01:26.626649", "image_code": "/* Original code from https://patriciogonzalezvivo.github.io/PixelSpiritDeck */\n\n// These 2 are the main tweaks we're gonna add to an icon\n// We can make bigger tweaks, but we don't wanna write the \n// icon differently; just small deltas.\n#define S (1. + sin(iTime) / 4.)\n#define C (1. + cos(iTime) / 4.)\n\n// Aliasing is apparent when things move. The original Pixel\n// Spirit cards use `step` everywhere. Change most of them to\n// smoothstep for anti-aliasing. Some later icons still need \n// regular `step` due to their idiosyncratic usages\nfloat sstep(float a, float b) {\n    return smoothstep(a - .005, a + .005, b);\n}\n\n// === Start!\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n// === All the utils, with their original card numbers\n\nfloat stroke(float x, float s, float w) { // 04\n    float d = sstep(s, x + w / 2.) - sstep(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\nfloat circleSDF(vec2 st) { // 08\n    return length(st - 0.5) * 2.;\n}\nfloat fill(float x, float size) { // 09\n    return 1. - sstep(size, x);\n}\nfloat rectSDF(vec2 st, vec2 s) { // 10\n    st = st * 2. - 1.;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\nfloat crossSDF(vec2 st, float s) { // 11\n    vec2 size = vec2(0.25, s);\n    return min(rectSDF(st, size.xy), rectSDF(st, size.yx));\n}\nfloat flip(float v, float pct) { // 12\n    return mix(v, 1. - v, pct);\n}\nfloat vesicaSDF(vec2 st, float w) { // 14\n    vec2 offset = vec2(w * .5, 0.);\n    return max(circleSDF(st - offset), circleSDF(st + offset));\n}\nfloat triSDF(vec2 st) { // 16\n    st = (2. * st - 1.) * 2.;\n    return max(abs(st.x) * 0.866025 + st.y * .5, -st.y * .5);\n}\nfloat rhombSDF(vec2 st) { // 17\n    return max(triSDF(st), triSDF(vec2(st.x, 1. - st.y)));\n}\nvec2 rotate(vec2 st, float a) { // 19\n    st = mat2(cos(a), -sin(a), sin(a), cos(a)) * (st - .5);\n    return st + .5;\n}\nfloat polySDF(vec2 st, int V) { // 26\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a) * r;\n}\nfloat hexSDF(vec2 st) { // 27\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y * .5);\n}\nfloat starSDF(vec2 st, int V, float s) { // 28\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)), st));\n}\nfloat raysSDF(vec2 st, int N) { // 30\n    st -= .5;\n    return fract(atan(st.y, st.x) / TAU * float(N));\n}\nfloat heartSDF(vec2 st) { // 34\n    st -= vec2(.5, .8);\n    float r = length(st) * 5.;\n    st = normalize(st);\n    return r -\n        ((st.y * pow(abs(st.x), 0.67)) /\n        (st.y + 1.5) - 2. * st.y + 1.26);\n}\nfloat bridge(float c, float d, float s, float w) { // 35\n    c *= 1. - stroke(d, s, w * 2.);\n    return c + stroke(d, s, w);\n}\nfloat spiralSDF(vec2 st, float t) { // 47\n    st -= .5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\nvec2 scale(vec2 st, vec2 s) {\n    return (st - .5) * s + .5;\n}\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2. - 1.;\n    float r = length(st) * 2.;\n    float a = atan(st.y, st.x);\n    float v = float(N) * .5;\n    return 1. - (abs(cos(a * v)) * .5 + .5) / r;\n}\n\n// === Cards\n\nfloat draw(vec2 st, vec2 tileXY, vec2 count) {\n    // y is bottom to top, but we want to show things from top to bottom. Convert\n    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    float color = 0.;\n    \n    switch (cardNumber) {\n    case 0: { // void\n        color = 0.;\n        break;\n    }\n    case 1: { // justice\n        color = sstep(0.5 * S, st.x);\n        break;\n    }\n    case 2: { // strength\n        color = sstep(0.5 + cos(st.y * PI + iTime/2.) * 0.25, st.x);\n        break;\n    }\n    case 3: { // death\n        color = sstep(0.5, (st.x * S + st.y * C) * 0.5);\n        break;\n    }\n    case 4: { // wall\n        color = stroke(st.x, 0.5, 0.15*S);  \n        break;\n    }\n    case 5: { // temperance\n        float offset = cos(st.y * PI + iTime) * 0.15;\n        color = stroke(st.x, .28 + offset, 0.1);\n        color += stroke(st.x, .5 + offset, 0.1);\n        color += stroke(st.x, .72 + offset, 0.1);\n        break;\n    }\n    case 6: { // branch\n        float offset = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(offset, 0.5, 0.1 * S);\n        break;\n    }\n    case 7: { // the hanged man\n        float sdf = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(sdf, 0.5, 0.1 * C);\n        float sdf_inv = (st.x + st.y) * 0.5;\n        color += stroke(sdf_inv, 0.5, 0.1 * C);\n        break;\n    }\n    case 8: { // the high priestess\n        color = stroke(circleSDF(st), 0.5 * S, 0.05 * C);\n        break;\n    }\n    case 9: { // the moon\n        color = fill(circleSDF(st), 0.65);\n        vec2 offset = vec2(0.1, 0.05);\n        color -= fill(circleSDF(st - offset * S), 0.5);\n        break;\n    }\n    case 10: { // the emperor\n        float sdf = rectSDF(st, vec2(1.));\n        color = stroke(sdf, .5 * C, .125);\n        color += fill(sdf, .1 * S);\n        break;\n    }\n    case 11: { // the hierophant\n        float rect = rectSDF(st, vec2(1));\n        color = fill(rect, .5);\n        float cross = crossSDF(st, 1.);\n        color *= sstep(.5, fract(cross * 3. + iTime));\n        color *= sstep(1., cross);\n        color += fill(cross, .5);\n        color += stroke(rect, .65, .05);\n        color += stroke(rect, .75, .025);\n        break;\n    }\n    case 12: { // the tower\n        float rect = rectSDF(st, vec2(.5, 1.));\n        float diag = (st.x * C + st.y * S) * .5;\n        color = flip(fill(rect, .6), stroke(diag, .5, .01));\n        break;\n    }\n    case 13: { // merge\n        vec2 offset = vec2(.15 * S, 0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = flip(stroke(left, .5, .05), fill(right, 0.525));\n        break;\n    }\n    case 14: { // hope\n        float sdf = vesicaSDF(st, .2 * S);\n        color = flip(fill(sdf, .5), sstep((st.x + st.y) * .5, .5));\n        break;\n    }\n    case 15: { // the temple\n        st.y = 1. - st.y;\n        vec2 ts = vec2(st.x, .82 - st.y);\n        color = fill(triSDF(st), .7);\n        color -= fill(triSDF(ts), .36);\n        break;\n    }\n    case 16: { // the summit\n        float circle = circleSDF(st - vec2(.0, .1));\n        float triangle = triSDF(st + vec2(.0, .1));\n        color = stroke(circle, .5 * C, .1);\n        color *= sstep(.55, triangle);\n        color += fill(triangle, .45);\n        break;\n    }\n    case 17: { // the diamond\n        float sdf = rhombSDF(st);\n        color = fill(sdf, .425 * S);\n        color += stroke(sdf, .5 * S, .05);\n        color += stroke(sdf, .6 * C, .03);\n        break;\n    }\n    case 18: { // the hermit\n        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    \n        break;\n    }\n    case 19: { // intuition\n        st = rotate(st, radians(-25.) * S);\n        float sdf = triSDF(st);\n        sdf /= triSDF(st + vec2(0., .2 * C));\n        color = fill(abs(sdf), .56);\n        break;\n    }\n    case 20: { // the stone\n        st = rotate(st, radians(45.));\n        color = fill(rectSDF(st, vec2(1.)), .4);\n        color *= 1. - stroke(st.x, .5 * S, .02);\n        color *= 1. - stroke(st.y, .5 * C, .02);\n        break;\n    }\n    case 21: { // the mountain\n        st = rotate(st, radians(-45.));\n        float off = .12 * S;\n        vec2 s = vec2(1.);\n        color = fill(rectSDF(st + off, s), .2 * C);\n        color += fill(rectSDF(st - off, s), .2 * C);\n        float r = rectSDF(st, s);\n        color *= sstep(.33, r);\n        color += fill(r, .3);\n        break;\n    }\n    case 22: { // the shadow\n        st = rotate(vec2(st.x, 1. - st.y), radians(45.));\n        vec2 s = vec2(1.);\n        color += fill(rectSDF(st - .025 * S, s), .4);\n        color += fill(rectSDF(st + .025, s), .4);\n        color *= sstep(0.38, rectSDF(st + .025, s));\n        break;\n    }\n    case 23: { // opposite\n        st = rotate(st, radians(-45.));\n        vec2 s = vec2(1.);\n        float o = .05 * S * 1.5;\n        color += flip(\n            fill(rectSDF(st - o, s), .4), \n            fill(rectSDF(st + o, s), .4)\n        );\n        break;\n    }\n    case 24: { // the oak\n        st = rotate(st, radians(45.));\n        float r1 = rectSDF(st, vec2(1.) * S);\n        float r2 = rectSDF(st + .15 * S, vec2(1.));\n        color += stroke(r1, .5, .05);\n        color *= sstep(.325, r2);\n        color += stroke(r2, .325, .05) * fill(r1, .525);\n        color += stroke(r2, .2, .05);\n        break;\n    }\n    case 25: { // ripples\n        st = rotate(st, radians(-45.)) - .08;\n        for (int i = 0; i < 4; i++) {\n            float r = rectSDF(st, vec2(1.) * S);\n            color += stroke(r, .19, .04);\n            st += .05;\n        }\n        break;\n    }\n    case 26: { // the empress\n        float d1 = polySDF(st, 5);\n        vec2 ts = vec2(st.x, 1. - st.y);\n        float d2 = polySDF(ts, 5);\n        color = fill(d1, .75) * fill(fract(d1 * 5. - iTime/2.), .5);\n        color -= fill(d1, .6) * fill(fract(d2 * 4.9 - iTime/2.), .45);\n        break;\n    }\n    case 27: { // bundle\n        st = st.yx;\n        color = stroke(hexSDF(st), .6 * C, .1);\n        color += fill(hexSDF(st - vec2(-.06, -.1) * S), .15);\n        color += fill(hexSDF(st - vec2(-.06, .1) * S), .15);\n        color += fill(hexSDF(st - vec2(.11, 0.) * S), .15);\n        break;\n    }\n    case 28: { // the devil\n        color += stroke(circleSDF(st), .8 * C, .05);\n        st.y = 1. - st.y;\n        float s = starSDF(st.yx, 5, .1);\n        color *= sstep(.7 * C, s);\n        color += stroke(s, .4 * S, .1);\n        break;\n    }\n    case 29: { // the sun\n        float bg = starSDF(st, 16, .1 * S);\n        color += fill(bg, 1.3);\n        float l = 0.;\n        for (float i = 0.; i < 8.; i++) {\n            vec2 xy = rotate(st, QTR_PI * i+iTime/4.);\n            xy.y -= .3;\n            float tri = polySDF(xy, 3);\n            color += fill(tri, .3);\n            l += stroke(tri, .3 * S, .03);\n        }\n        color *= 1. - l;\n        float c = polySDF(st, 8);\n        color -= stroke(c, .15, .04);\n        break;\n    }\n    case 30: { // the star\n        color = stroke(raysSDF(st, 8), .5, .15 * C * 2.);\n        float inner = starSDF(st.xy, 6, .09 * S);\n        float outer = starSDF(st.yx, 6, .09 * S);\n        color *= sstep(.7, outer);\n        color += fill(outer, .5);\n        color -= stroke(inner, .25, .06);\n        color += stroke(outer, .6, .05);\n        break;\n    }\n    case 31: { // judgement\n        color = flip(\n            stroke(raysSDF(rotate(st, -iTime/8.), 28), .5, .2), \n            fill(st.y, .5)\n        );\n        float rect = rectSDF(st, vec2(1) * S);\n        color *= sstep(.25, rect);\n        color += fill(rect, .2);\n        break;\n    }\n    case 32: { // wheel of fortune\n        float sdf = polySDF(rotate(st.yx, C), 8);\n        color = fill(sdf, .5);\n        color *= stroke(raysSDF(rotate(st, C), 8), .5, .2);\n        color *= sstep(.27, sdf);\n        color += stroke(sdf, .2, .05);\n        color += stroke(sdf, .6, .1);\n        break;\n    }\n    case 33: { // vision\n        float v1 = vesicaSDF(st, .5);\n        vec2 st2 = st.yx + vec2(.04, .0);\n        float v2 = vesicaSDF(st2, .7);\n        color = stroke(v2, 1., .05);\n        st = rotate(st, iTime/2.);\n        color += fill(v2, 1.) * stroke(circleSDF(st - vec2(.05)), .3 , .05);\n        color += fill(raysSDF(st, 50), .2) *\n            fill(v1, 1.25) *\n            sstep(1., v2);\n        break;\n    }\n    case 34: { // the lovers\n        color = fill(heartSDF(st), .5 * C * 1.2);\n        color -= stroke(polySDF(st, 3), .15 * S * 1.1, .05);\n        break;\n    }\n    case 35: { // the magician\n        st.x = flip(st.x, step(.5, st.y));\n        vec2 offset = vec2(.15 * S, .0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = stroke(left, .4 * S, .075);\n        color = bridge(color, right, .4 * S, .075);\n        break;\n    }\n    case 36: { // the link\n        st = st.yx;\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.1, .0);\n        vec2 s = vec2(1.) * C;\n        float a = radians(45.) + iTime/2.;\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .3, .1);\n        color = bridge(color, r, .3, .1);\n        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);\n        break;\n    }\n    case 37: { // holding together\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.05, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a * S), s);\n        float r = rectSDF(rotate(st - o, -a * S), s);\n        color = stroke(l, .145, .098);\n        color = bridge(color, r, .145, .098);\n        break;\n    }\n    case 38: { // the chariot\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));\n        float inv = step(.5, (st.x + st.y) * .5);\n        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));\n        float w = .075 * S * 1.2;\n        color = stroke(r1, .5, w) + stroke(r2, .5, w);\n        float bridges = mix(r1, r2, inv);\n        color = bridge(color, bridges, .5, w);\n        break;\n    }\n    case 39: { // the loop\n        float inv = sstep(.5, st.y);\n        st = rotate(st, radians(-45.)) - .2;\n        st = mix(st, .6 - st, sstep(.5, inv));\n        for (int i = 0; i < 5; i++) {\n            float r = rectSDF(st, vec2(1.));\n            float s = .25;\n            s -= abs(float(i) * .1 - .2);\n            color = bridge(color, r, s, .05 * S);\n            st += .1;\n        }\n        break;\n    }\n    case 40: { // turning point\n        st = rotate(st, radians(-60.) + iTime/4.);\n        st.y = flip(st.y, step(.5, st.x));\n        st.y += .25;\n        float down = polySDF(st, 3);\n        st.y = 1.5 - st.y;\n        float top = polySDF(st, 3);\n        color = stroke(top, .4, .15 * S);\n        color = bridge(color, down, .4, .15 * S);\n        break;\n    }\n    case 41: { // trinity\n        st.y = 1. - st.y;\n        float s = .25 * C*1.3;\n        float t1 = polySDF(st + vec2(.0, .175), 3);\n        float t2 = polySDF(st + vec2(.1, .0), 3);\n        float t3 = polySDF(st - vec2(.1, .0), 3);\n        color = stroke(t1, s, .08) +\n                stroke(t2, s, .08) +\n                stroke(t3, s, .08);\n        float bridges = mix(\n            mix(t1, t2, step(.5, st.y)),\n            mix(t3, t2, step(.5, st.y)),\n            step(.5, st.x)\n        );\n        color = bridge(color, bridges, s, .08);\n        break;\n    }\n    case 42: { // the cauldron\n        float n = 12.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .189;\n            float vsc = vesicaSDF(xy, .3);\n            color *= 1. - stroke(vsc, .45 * S, .1) * sstep(.5, xy.y);\n            color += stroke(vsc, .45 * S, .05);\n        }\n        break;\n    }\n    case 43: { // the elders\n        float n = 3.;\n        float a = TAU / n;\n        for (float i = 0.; i < n * 2.; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .09;\n            float vsc = vesicaSDF(xy, .3);\n            color = mix(\n                color + stroke(vsc, .5, .1*S),\n                mix(color, bridge(color, vsc, .5, .1*S), step(xy.x, .5) - step(xy.y, .4)),\n                step(3., i)\n            );\n            \n        }\n        break;\n    }\n    case 44: { // the core\n        float star = starSDF(st, 8, .063);\n        color += fill(star, 1.22);\n        float n = 8.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, 0.39 + a * i);\n            xy = scale(xy, vec2(1., .72) * S);\n            xy.y -= .125;\n            color *= sstep(.235, rhombSDF(xy));\n        }\n        break;\n    }\n    case 45: { // inner truth\n        st -= .5;\n        float r = dot(st, st);\n        float a = atan(st.y, st.x) / PI;\n        vec2 uv = vec2(a, r);\n        vec2 grid = vec2(5., log(r) * 20. * S);\n        vec2 uv_i = floor(uv * grid);\n        uv.x += .5 * mod(uv_i.y, 2.);\n        vec2 uv_f = fract(uv * grid);\n        float shape = rhombSDF(uv_f);\n        color += fill(shape, .9) * sstep(.75, 1. - r);\n        break;\n    }\n    case 46: { // the world\n        color = fill(flowerSDF(rotate(st, -iTime/4.), 5), .25*C);\n        color -= sstep(.95, starSDF(rotate(st, 0.628 - iTime/4.), 5, .1*S));\n        color = clamp(color, 0., 1.);\n        float circle = circleSDF(st);\n        color -= stroke(circle, .1, .05);\n        color += stroke(circle, .8, .07);\n        break;\n    }\n    case 47: { // the fool\n        color = sstep(.5, spiralSDF(rotate(st, iTime/2.), .13 * S));\n        break;\n    }\n    case 48: { // enlightenment\n        color = 1.;\n        break;\n    }\n    case 49: { // elements. Added by me. Approximated\n        st = rotate(st, -iTime/4.);\n        float d = .15;\n        float r = .3 * S;\n        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), r);\n        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), r);\n        color += fill(circleSDF(st - vec2(d, 0.)), r);\n        st = st.yx;\n        st.y = 1. - st.y;\n        color *= 1. - fill(triSDF(st-vec2(0, .02)), .13);\n        color += stroke(circleSDF(st), .8, .08);\n        break;\n    }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(10, 5);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    \n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.8, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y);\n    \n    float color = draw(st, tileXY, count);\n    color = clamp(color + grid, 0., 1.);\n    \n    if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        \n        color *= 0.15;\n        color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 543, 574, 574, 622], [779, 779, 820, 826, 916], [917, 917, 943, 949, 985], [986, 986, 1019, 1025, 1059], [1060, 1060, 1092, 1098, 1173], [1174, 1174, 1208, 1214, 1307], [1308, 1308, 1340, 1346, 1380], [1381, 1381, 1416, 1422, 1524], [1525, 1525, 1548, 1554, 1648], [1649, 1649, 1674, 1680, 1741], [1742, 1742, 1773, 1779, 1861], [1862, 1862, 1893, 1899, 2064], [2065, 2065, 2088, 2094, 2180], [2181, 2181, 2221, 2227, 2465], [2466, 2466, 2497, 2503, 2572], [2573, 2573, 2598, 2604, 2783], [2784, 2784, 2834, 2840, 2910], [2911, 2911, 2946, 2952, 3079], [3080, 3080, 3109, 3109, 3142], [3143, 3143, 3176, 3176, 3342], [3358, 3358, 3404, 3486, 17524], [17526, 17526, 17583, 17583, 18570]], "test": "untested"}
{"id": "Nsd3zn", "name": "Pixel Spirit Deck, Original", "author": "chenglou", "description": "All 50 cards from [url=https://patriciogonzalezvivo.github.io/PixelSpiritDeck]Pixel Spirit[/url].\n[b]Mouse click a card to see the bigger version![/b]\nDynamic version [url=https://www.shadertoy.com/view/fdK3DD]here![/url]", "tags": ["sdf", "symbol", "cards", "icon", "pixelspirit"], "likes": 18, "viewed": 863, "published": 3, "date": "1631597675", "time_retrieved": "2024-07-30T19:01:27.638942", "image_code": "/* Original code from https://patriciogonzalezvivo.github.io/PixelSpiritDeck */\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n// === All the utils, with their original card numbers\n\nfloat stroke(float x, float s, float w) { // 04\n    float d = step(s, x + w / 2.) - step(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\nfloat circleSDF(vec2 st) { // 08\n    return length(st - 0.5) * 2.;\n}\nfloat fill(float x, float size) { // 09\n    return 1. - step(size, x);\n}\nfloat rectSDF(vec2 st, vec2 s) { // 10\n    st = st * 2. - 1.;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\nfloat crossSDF(vec2 st, float s) { // 11\n    vec2 size = vec2(0.25, s);\n    return min(rectSDF(st, size.xy), rectSDF(st, size.yx));\n}\nfloat flip(float v, float pct) { // 12\n    return mix(v, 1. - v, pct);\n}\nfloat vesicaSDF(vec2 st, float w) { // 14\n    vec2 offset = vec2(w * .5, 0.);\n    return max(circleSDF(st - offset), circleSDF(st + offset));\n}\nfloat triSDF(vec2 st) { // 16\n    st = (2. * st - 1.) * 2.;\n    return max(abs(st.x) * 0.866025 + st.y * .5, -st.y * .5);\n}\nfloat rhombSDF(vec2 st) { // 17\n    return max(triSDF(st), triSDF(vec2(st.x, 1. - st.y)));\n}\nvec2 rotate(vec2 st, float a) { // 19\n    st = mat2(cos(a), -sin(a), sin(a), cos(a)) * (st - .5);\n    return st + .5;\n}\nfloat polySDF(vec2 st, int V) { // 26\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a) * r;\n}\nfloat hexSDF(vec2 st) { // 27\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y * .5);\n}\nfloat starSDF(vec2 st, int V, float s) { // 28\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)), st));\n}\nfloat raysSDF(vec2 st, int N) { // 30\n    st -= .5;\n    return fract(atan(st.y, st.x) / TAU * float(N));\n}\nfloat heartSDF(vec2 st) { // 34\n    st -= vec2(.5, .8);\n    float r = length(st) * 5.;\n    st = normalize(st);\n    return r -\n        ((st.y * pow(abs(st.x), 0.67)) /\n        (st.y + 1.5) - 2. * st.y + 1.26);\n}\nfloat bridge(float c, float d, float s, float w) { // 35\n    c *= 1. - stroke(d, s, w * 2.);\n    return c + stroke(d, s, w);\n}\nfloat spiralSDF(vec2 st, float t) { // 47\n    st -= .5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\nvec2 scale(vec2 st, vec2 s) {\n    return (st - .5) * s + .5;\n}\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2. - 1.;\n    float r = length(st) * 2.;\n    float a = atan(st.y, st.x);\n    float v = float(N) * .5;\n    return 1. - (abs(cos(a * v)) * .5 + .5) / r;\n}\n\n// === Cards\n\nfloat draw(vec2 st, vec2 tileXY, vec2 count) {\n    // y is bottom to top, but we want to show things from top to bottom. Convert\n    int showID = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    float color = 0.;\n    \n    switch (showID) {\n    case 0: { // void\n        color = 0.;\n        break;\n    }\n    case 1: { // justice\n        color = step(0.5, st.x);\n        break;\n    }\n    case 2: { // strength\n        color = step(0.5 + cos(st.y * PI) * 0.25, st.x);\n        break;\n    }\n    case 3: { // death\n        color = step(0.5, (st.x + st.y) * 0.5);\n        break;\n    }\n    case 4: { // wall\n        color = stroke(st.x, 0.5, 0.15);  \n        break;\n    }\n    case 5: { // temperance\n        float offset = cos(st.y * PI) * 0.15;\n        color = stroke(st.x, .28 + offset, 0.1);\n        color += stroke(st.x, .5 + offset, 0.1);\n        color += stroke(st.x, .72 + offset, 0.1);\n        break;\n    }\n    case 6: { // branch\n        float offset = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(offset, 0.5, 0.1);\n        break;\n    }\n    case 7: { // the hanged man\n        float sdf = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(sdf, 0.5, 0.1);\n        float sdf_inv = (st.x + st.y) * 0.5;\n        color += stroke(sdf_inv, 0.5, 0.1);\n        break;\n    }\n    case 8: { // the high priestess\n        color = stroke(circleSDF(st), 0.5, 0.05);\n        break;\n    }\n    case 9: { // the moon\n        color = fill(circleSDF(st), 0.65);\n        vec2 offset = vec2(0.1, 0.05);\n        color -= fill(circleSDF(st - offset), 0.5);\n        break;\n    }\n    case 10: { // the emperor\n        float sdf = rectSDF(st, vec2(1.));\n        color = stroke(sdf, .5, .125);\n        color += fill(sdf, .1);\n        break;\n    }\n    case 11: { // the hierophant\n        float rect = rectSDF(st, vec2(1));\n        color = fill(rect, .5);\n        float cross = crossSDF(st, 1.);\n        color *= step(.5, fract(cross * 4.));\n        color *= step(1., cross);\n        color += fill(cross, .5);\n        color += stroke(rect, .65, .05);\n        color += stroke(rect, .75, .025);\n        break;\n    }\n    case 12: { // the tower\n        float rect = rectSDF(st, vec2(.5, 1.));\n        float diag = (st.x + st.y) * .5;\n        color = flip(fill(rect, .6), stroke(diag, .5, .01));\n        break;\n    }\n    case 13: { // merge\n        vec2 offset = vec2(.15, 0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = flip(stroke(left, .5, .05), fill(right, 0.525));\n        break;\n    }\n    case 14: { // hope\n        float sdf = vesicaSDF(st, .2);\n        color = flip(fill(sdf, .5), step((st.x + st.y) * .5, .5));\n        break;\n    }\n    case 15: { // the temple\n        st.y = 1. - st.y;\n        vec2 ts = vec2(st.x, .82 - st.y);\n        color = fill(triSDF(st), .7);\n        color -= fill(triSDF(ts), .36);\n        break;\n    }\n    case 16: { // the summit\n        float circle = circleSDF(st - vec2(.0, .1));\n        float triangle = triSDF(st + vec2(.0, .1));\n        color = stroke(circle, .5, .1);\n        color *= step(.55, triangle);\n        color += fill(triangle, .45);\n        break;\n    }\n    case 17: { // the diamond\n        float sdf = rhombSDF(st);\n        color = fill(sdf, .425);\n        color += stroke(sdf, .5, .05);\n        color += stroke(sdf, .6, .03);\n        break;\n    }\n    case 18: { // the hermit\n        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    \n        break;\n    }\n    case 19: { // intuition\n        st = rotate(st, radians(-25.));\n        float sdf = triSDF(st);\n        sdf /= triSDF(st + vec2(0., .2));\n        color = fill(abs(sdf), .56);\n        break;\n    }\n    case 20: { // the stone\n        st = rotate(st, radians(45.));\n        color = fill(rectSDF(st, vec2(1.)), .4);\n        color *= 1. - stroke(st.x, .5, .02);\n        color *= 1. - stroke(st.y, .5, .02);\n        break;\n    }\n    case 21: { // the mountain\n        st = rotate(st, radians(-45.));\n        float off = .12;\n        vec2 s = vec2(1.);\n        color = fill(rectSDF(st + off, s), .2);\n        color += fill(rectSDF(st - off, s), .2);\n        float r = rectSDF(st, s);\n        color *= step(.33, r);\n        color += fill(r, .3);\n        break;\n    }\n    case 22: { // the shadow\n        st = rotate(vec2(st.x, 1. - st.y), radians(45.));\n        vec2 s = vec2(1.);\n        color += fill(rectSDF(st - .025, s), .4);\n        color += fill(rectSDF(st + .025, s), .4);\n        color *= step(0.38, rectSDF(st + .025, s));\n        break;\n    }\n    case 23: { // opposite\n        st = rotate(st, radians(-45.));\n        vec2 s = vec2(1.);\n        float o = .05;\n        color += flip(\n            fill(rectSDF(st - o, s), .4), \n            fill(rectSDF(st + o, s), .4)\n        );\n        break;\n    }\n    case 24: { // the oak\n        st = rotate(st, radians(45.));\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(st + .15, vec2(1.));\n        color += stroke(r1, .5, .05);\n        color *= step(.325, r2);\n        color += stroke(r2, .325, .05) * fill(r1, .525);\n        color += stroke(r2, .2, .05);\n        break;\n    }\n    case 25: { // ripples\n        st = rotate(st, radians(-45.)) - .08;\n        for (int i = 0; i < 4; i++) {\n            float r = rectSDF(st, vec2(1.));\n            color += stroke(r, .19, .04);\n            st += .05;\n        }\n        break;\n    }\n    case 26: { // the empress\n        float d1 = polySDF(st, 5);\n        vec2 ts = vec2(st.x, 1. - st.y);\n        float d2 = polySDF(ts, 5);\n        color = fill(d1, .75) * fill(fract(d1 * 5.), .5);\n        color -= fill(d1, .6) * fill(fract(d2 * 4.9), .45);\n        break;\n    }\n    case 27: { // bundle\n        st = st.yx;\n        color = stroke(hexSDF(st), .6, .1);\n        color += fill(hexSDF(st - vec2(-.06, -.1)), .15);\n        color += fill(hexSDF(st - vec2(-.06, .1)), .15);\n        color += fill(hexSDF(st - vec2(.11, 0.)), .15);\n        break;\n    }\n    case 28: { // the devil\n        color += stroke(circleSDF(st), .8, .05);\n        st.y = 1. - st.y;\n        float s = starSDF(st.yx, 5, .1);\n        color *= step(.7, s);\n        color += stroke(s, .4, .1);\n        break;\n    }\n    case 29: { // the sun\n        float bg = starSDF(st, 16, .1);\n        color += fill(bg, 1.3);\n        float l = 0.;\n        for (float i = 0.; i < 8.; i++) {\n            vec2 xy = rotate(st, QTR_PI * i);\n            xy.y -= .3;\n            float tri = polySDF(xy, 3);\n            color += fill(tri, .3);\n            l += stroke(tri, .3, .03);\n        }\n        color *= 1. - l;\n        float c = polySDF(st, 8);\n        color -= stroke(c, .15, .04);\n        break;\n    }\n    case 30: { // the star\n        color = stroke(raysSDF(st, 8), .5, .15);\n        float inner = starSDF(st.xy, 6, .09);\n        float outer = starSDF(st.yx, 6, .09);\n        color *= step(.7, outer);\n        color += fill(outer, .5);\n        color -= stroke(inner, .25, .06);\n        color += stroke(outer, .6, .05);\n        break;\n    }\n    case 31: { // judgement\n        color = flip(\n            stroke(raysSDF(st, 28), .5, .2), \n            fill(st.y, .5)\n        );\n        float rect = rectSDF(st, vec2(1));\n        color *= step(.25, rect);\n        color += fill(rect, .2);\n        break;\n    }\n    case 32: { // wheel of fortune\n        float sdf = polySDF(st.yx, 8);\n        color = fill(sdf, .5);\n        color *= stroke(raysSDF(st, 8), .5, .2);\n        color *= step(.27, sdf);\n        color += stroke(sdf, .2, .05);\n        color += stroke(sdf, .6, .1);\n        break;\n    }\n    case 33: { // vision\n        float v1 = vesicaSDF(st, .5);\n        vec2 st2 = st.yx + vec2(.04, .0);\n        float v2 = vesicaSDF(st2, .7);\n        color = stroke(v2, 1., .05);\n        color += fill(v2, 1.) * stroke(circleSDF(st), .3, .05);\n        color += fill(raysSDF(st, 50), .2) *\n            fill(v1, 1.25) *\n            step(1., v2);\n        break;\n    }\n    case 34: { // the lovers\n        color = fill(heartSDF(st), .5);\n        color -= stroke(polySDF(st, 3), .15, .05);\n        break;\n    }\n    case 35: { // the magician\n        st.x = flip(st.x, step(.5, st.y));\n        vec2 offset = vec2(.15, .0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = stroke(left, .4, .075);\n        color = bridge(color, right, .4, .075);\n        break;\n    }\n    case 36: { // the link\n        st = st.yx;\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.1, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .3, .1);\n        color = bridge(color, r, .3, .1);\n        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);\n        break;\n    }\n    case 37: { // holding together\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.05, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .145, .098);\n        color = bridge(color, r, .145, .098);\n        break;\n    }\n    case 38: { // the chariot\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));\n        float inv = step(.5, (st.x + st.y) * .5);\n        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));\n        float w = .075;\n        color = stroke(r1, .5, w) + stroke(r2, .5, w);\n        float bridges = mix(r1, r2, inv);\n        color = bridge(color, bridges, .5, w);\n        break;\n    }\n    case 39: { // the loop\n        float inv = step(.5, st.y);\n        st = rotate(st, radians(-45.)) - .2;\n        st = mix(st, .6 - st, step(.5, inv));\n        for (int i = 0; i < 5; i++) {\n            float r = rectSDF(st, vec2(1.));\n            float s = .25;\n            s -= abs(float(i) * .1 - .2);\n            color = bridge(color, r, s, .05);\n            st += .1;\n        }\n        break;\n    }\n    case 40: { // turning point\n        st = rotate(st, radians(-60.));\n        st.y = flip(st.y, step(.5, st.x));\n        st.y += .25;\n        float down = polySDF(st, 3);\n        st.y = 1.5 - st.y;\n        float top = polySDF(st, 3);\n        color = stroke(top, .4, .15);\n        color = bridge(color, down, .4, .15);\n        break;\n    }\n    case 41: { // trinity\n        st.y = 1. - st.y;\n        float s = .25;\n        float t1 = polySDF(st + vec2(.0, .175), 3);\n        float t2 = polySDF(st + vec2(.1, .0), 3);\n        float t3 = polySDF(st - vec2(.1, .0), 3);\n        color = stroke(t1, s, .08) +\n                stroke(t2, s, .08) +\n                stroke(t3, s, .08);\n        float bridges = mix(\n            mix(t1, t2, step(.5, st.y)),\n            mix(t3, t2, step(.5, st.y)),\n            step(.5, st.x)\n        );\n        color = bridge(color, bridges, s, .08);\n        break;\n    }\n    case 42: { // the cauldron\n        float n = 12.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .189;\n            float vsc = vesicaSDF(xy, .3);\n            color *= 1. - stroke(vsc, .45, .1) * step(.5, xy.y);\n            color += stroke(vsc, .45, .05);\n        }\n        break;\n    }\n    case 43: { // the elders\n        float n = 3.;\n        float a = TAU / n;\n        for (float i = 0.; i < n * 2.; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .09;\n            float vsc = vesicaSDF(xy, .3);\n            color = mix(\n                color + stroke(vsc, .5, .1),\n                mix(color, bridge(color, vsc, .5, .1), step(xy.x, .5) - step(xy.y, .4)),\n                step(3., i)\n            );\n            \n        }\n        break;\n    }\n    case 44: { // the core\n        float star = starSDF(st, 8, .063);\n        color += fill(star, 1.22);\n        float n = 8.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, 0.39 + a * i);\n            xy = scale(xy, vec2(1., .72));\n            xy.y -= .125;\n            color *= step(.235, rhombSDF(xy));\n        }\n        break;\n    }\n    case 45: { // inner truth\n        st -= .5;\n        float r = dot(st, st);\n        float a = atan(st.y, st.x) / PI;\n        vec2 uv = vec2(a, r);\n        vec2 grid = vec2(5., log(r) * 20.);\n        vec2 uv_i = floor(uv * grid);\n        uv.x += .5 * mod(uv_i.y, 2.);\n        vec2 uv_f = fract(uv * grid);\n        float shape = rhombSDF(uv_f);\n        color += fill(shape, .9) * step(.75, 1. - r);\n        break;\n    }\n    case 46: { // the world\n        color = fill(flowerSDF(st, 5), .25);\n        color -= step(.95, starSDF(rotate(st, 0.628), 5, .1));\n        color = clamp(color, 0., 1.);\n        float circle = circleSDF(st);\n        color -= stroke(circle, .1, .05);\n        color += stroke(circle, .8, .07);\n        break;\n    }\n    case 47: { // the fool\n        color = step(.5, spiralSDF(st, .13));\n        break;\n    }\n    case 48: { // enlightenment\n        color = 1.;\n        break;\n    }\n    case 49: { // elements. Added by me. Approximated\n        st = st.yx;\n        float d = .15;\n        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), .3);\n        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), .3);\n        color += fill(circleSDF(st - vec2(d, 0.)), .3);\n        st = st.yx;\n        st.y = 1. - st.y;\n        color = flip(color, fill(triSDF(st-vec2(0, .03)), .13));\n        color += stroke(circleSDF(st), .8, .08);\n        break;\n    }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(10, 5);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    \n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.8, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y);\n    \n    float color = draw(st, tileXY, count);\n    color = clamp(color + grid, 0., 1.);\n    \n    if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        \n        color *= 0.15;\n        color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 262, 268, 356], [357, 357, 383, 389, 425], [426, 426, 459, 465, 498], [499, 499, 531, 537, 612], [613, 613, 647, 653, 746], [747, 747, 779, 785, 819], [820, 820, 855, 861, 963], [964, 964, 987, 993, 1087], [1088, 1088, 1113, 1119, 1180], [1181, 1181, 1212, 1218, 1300], [1301, 1301, 1332, 1338, 1503], [1504, 1504, 1527, 1533, 1619], [1620, 1620, 1660, 1666, 1904], [1905, 1905, 1936, 1942, 2011], [2012, 2012, 2037, 2043, 2222], [2223, 2223, 2273, 2279, 2349], [2350, 2350, 2385, 2391, 2518], [2519, 2519, 2548, 2548, 2581], [2582, 2582, 2615, 2615, 2781], [2797, 2797, 2843, 2925, 16393], [16395, 16395, 16452, 16452, 17439]], "test": "untested"}
{"id": "ssVGDW", "name": "Circle Curve", "author": "oneshade", "description": "I finished early in my geometry class and was bored. One of the students' drawings on the wall looked something like this and I decided to try working out the area of the green shape. It turns out to have an area of 2sqrt(3)+4pi/3", "tags": ["circles", "curve", "area", "geometry", "integration"], "likes": 10, "viewed": 191, "published": 3, "date": "1631591755", "time_retrieved": "2024-07-30T19:01:28.643257", "image_code": "// Constants\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    float leftCircle = sdDisk(uv, vec2(-3.0, 0.0), 2.0);\n    drawSDF(leftCircle, vec4(1.0, 0.0, 0.0, 0.5));\n    drawSDF(abs(leftCircle), vec4(1.0, 0.0, 0.0, 1.0));\n\n    float rightCircle = sdDisk(uv, vec2(3.0, 0.0), 2.0);\n    drawSDF(rightCircle, vec4(0.0, 0.0, 1.0, 0.5));\n    drawSDF(abs(rightCircle), vec4(0.0, 0.0, 1.0, 1.0));\n\n    float middleCircle = sdDisk(uv, vec2(0.0), 1.0);\n    drawSDF(middleCircle, vec4(0.0, 0.0, 0.0, 0.5));\n    drawSDF(abs(middleCircle), vec4(0.0, 0.0, 0.0, 1.0));\n\n    float curveUpper = max(sdDisk(uv, vec2(-1.0, 0.0), 2.0), -min(leftCircle, uv.y));\n    drawSDF(curveUpper, vec4(0.0, 0.5, 0.0, 0.5));\n    drawSDF(abs(curveUpper), vec4(0.0, 0.5, 0.0, 1.0));\n\n    float curveLower = max(sdDisk(uv, vec2(1.0, 0.0), 2.0), -min(rightCircle, -uv.y));\n    drawSDF(curveLower, vec4(0.0, 0.5, 0.0, 0.5));\n    drawSDF(abs(curveLower), vec4(0.0, 0.5, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 179, 227, 227, 259], [261, 261, 320, 320, 432], [434, 434, 494, 494, 535], [537, 537, 592, 592, 1654]], "test": "untested"}
{"id": "7dVGDW", "name": "Badlands v2", "author": "jarble", "description": "Yet another terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "erosion", "badlands"], "likes": 5, "viewed": 222, "published": 3, "date": "1631591076", "time_retrieved": "2024-07-30T19:01:29.399236", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\n\n#define OCTAVES 4\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = .75;\n    float freq = 1.;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = (noise(uv * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-(n1) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.;\n        \n        uv = uv.yx;\n        float f1 = .1*noise(uv);\n        value *= .9+f1;\n        freq += f1;\n        \n        //value *= .9;\n\n}\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.5;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 85], [106, 106, 141, 190, 710], [712, 712, 734, 734, 764], [766, 766, 796, 796, 846], [848, 848, 868, 868, 922], [924, 924, 957, 957, 1151], [1153, 1153, 1220, 1220, 1438], [1440, 1440, 1492, 1492, 2037], [2039, 2039, 2090, 2090, 2291], [2293, 2293, 2319, 2319, 2395], [2464, 2464, 2521, 2521, 4478]], "test": "untested"}
{"id": "sdV3Wh", "name": "Euler Spiral", "author": "oneshade", "description": "Rotozooming euler spiral.", "tags": ["spiral", "eulerspiral", "fresnelintegral"], "likes": 16, "viewed": 198, "published": 3, "date": "1631589700", "time_retrieved": "2024-07-30T19:01:30.159204", "image_code": "#define ROTOZOOM\n#define dt 0.05\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    float time = 0.1 * iTime;\n    vec3 color = vec3(1.0);\n\n    // Point moving along the spiral\n    vec2 pPrev = vec2(0.0), pCur = vec2(0.0);\n    float pos = 10.0 * sin(time);\n    for (float t=0.0; t < abs(pos); t += dt) {\n        float t2 = t * t;\n        vec2 dp = vec2(cos(t2), sin(t2)) * sign(pos) * dt;\n        pPrev += dp;\n        if (t + dt < abs(pos)) pCur += dp;\n    }\n\n    float lerp = fract(pos / dt);\n    if (pos > 0.0) lerp = 1.0 - lerp;\n    vec2 p = mix(pPrev, pCur, lerp);\n\n    // Rotozoom\n    #ifdef ROTOZOOM\n    float pos2 = pos * pos;\n    float rot = -atan(sin(pos2), cos(pos2)) + 1.57;\n    uv *= Rotate2D(rot);\n    float zoom = abs(cos(time));\n    uv *= zoom;\n    unit *= zoom;\n    uv += p;\n    #endif\n\n    // Parametric plot\n    vec2 suv = uv * sign(uv.x);\n    vec2 prev = vec2(0.0);\n    for (float t=0.0; t < 10.0; t += dt) {\n        float t2 = t * t;\n        vec2 cur = prev + vec2(cos(t2), sin(t2)) * dt; // Integrate (cos(t^2), sin(t^2))\n        drawSDF(sdLine(suv, prev, cur), vec3(0.0));\n        prev = cur;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdV3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 155, 155, 221], [223, 231, 278, 278, 386], [388, 388, 436, 436, 468], [470, 470, 525, 544, 1731]], "test": "untested"}
{"id": "NsVGDD", "name": "Quad Tree Plus Circle", "author": "Yusef28", "description": "Mouse enabled\ncool harry potter themed functions\nInspired by https://www.shadertoy.com/view/lljSDy which I still don't understand completely", "tags": ["sdf", "tutorial", "comments", "quadtree", "harrypotter", "wellcommented"], "likes": 9, "viewed": 333, "published": 3, "date": "1631584168", "time_retrieved": "2024-07-30T19:01:30.915183", "image_code": "//yore a wizard harry\n\n//a rotating vector\n#define wingardium_leviosa vec2(cos(iTime),sin(iTime))\n\n//from Fabrice,now I just need to find a spell for frame\n#define frame(p) vec2((p.xy*2.-iResolution.xy)/iResolution.y)\n\n//kind of like the open sesame of shadertoy\n#define alohamora frame(fragCoord)\n\n//kind of like what everyone thought Snape was doing but it was actually Quirl\n#define mobiliarbus frame(iMouse)\n\n//max layers of the quad tree\n#define max_layers 6\n\n//static factor to use each round\n#define scale_factor 2.\n\n//we use this to get the diagonal length of a quad in each layer\n//diagonal length of a square is side_length*sqrt(2) \n#define sqrt_of_2 1.41421356\n\n#define eps 1./iResolution.y\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    \n    vec2 uv = alohamora; //uv from -1. to 1.\n    vec2 global_uv = alohamora; //do it again just for fun\n    float scale = 2.; //starting scale \n    float radius = 0.34; //circle radius\n    float dist = 100.; //starting distance to circle \n    vec2 circle_coords = wingardium_leviosa;//move the circle around\n    \n    //if mouse is pressed, then you control the circle\n    if(iMouse.z > 0.5) circle_coords = mobiliarbus;\n    \n    //starting color\n    O = vec4(0.0);\n    O.r = .25;\n    \n    //find distance estimation to circle \n    float circle_dist = length(uv-circle_coords) - radius;\n    \n    //the plan is simple\n    \n    for(int i = 0; i < max_layers; i++){\n    \n        //we get a scaling variable of 2^n where n is layer number\n        scale = pow(scale_factor,float(i));\n        //we scale the global uv by it so from -1 -> 1\n        //we go to -2 -> 2 and then -4 -> 4 and so on\n        vec2 local_uv = global_uv*scale;\n        //we get the floor coordinates of this system for an id\n        //each QUAD then is a cell from one integer to the next (in 2d)\n        \n        // x: 1 -> 2 and y: 1 -> 2 is one quad\n        vec2 id = floor(local_uv);\n        //we use that id to get the centers for each quad local space\n        //and then immediately convert to global space by dividing again\n        //by our scale\n        //now we have a center coordinate, in global space, for \n        //every quad created in this layer\n        vec2 global_quad_center = (id + 0.5)/scale;\n        //we then find the lenght of one side in global space\n        //which is 1./scale (for example, if scale is 1, we have\n        //only 1 quad, so length is one\n        //if scale is 2, we have 4 quads with these dimentions\n        //\n        // x:0->0.5, y:0.5->1.  x:0.5->0.5, y:0.5->1.\n        //\n        // x:0->0.5, y:0->0.5   x:0.5->1., y:0.->0.5\n        //\n        //and you can see the math works because 1./2. gives a length\n        //of 0.5 which each quad has\n        \n        float quad_length = 1./scale;\n        \n        //we get the diagonal the cool way\n        float diagonal = quad_length*sqrt_of_2;\n        \n        //half it\n        float half_diagonal = diagonal/2.;\n        \n        //we want to find if our circle intersects the quad \n        //based on our quad's id (used to get center, blah blah blah)\n        //and that is approximated by this:\n        //if the distance between the quad center and the circle center\n        //is less than the sum of half the quad's diangona and\n        //the circle's radius, then the circle intersects the quad\n        float max_dist = half_diagonal + radius;\n        \n        //distance between circle center and quad center\n        float dist_between = length(circle_coords - global_quad_center);\n       \n       \n       //adding a sort of white vignette from one\n       //of iq's tileing shaders based on xo\n        vec2 u01 = fract(local_uv);\n        float vig = pow((1.-u01.x*u01.y*(1.-u01.x)*(1.-u01.y)\n        *1.*(float(max_layers-i)/float(max_layers))),300.3);\n        \n       \n       //the check, if true, we stop at this layer for this quad\n       //not more subdivisions\n        if(dist_between > max_dist) \n        {\n        \n        O.rgb += vig;\n        break;\n        \n        \n        }\n        //here I create borders for each quad and the math\n        //could be prettier but I transform the coords in every \n        //quad to be from 0 to 1. It's just the quads local coords\n        //minus the id. (or fract could work too)\n        vec2 local_0_to_1 = local_uv - id;\n        //then I translate left 0.5 so it's -0.5 -> 0.5\n        //and then abs so it's 0.5 <- 0 -> 0.5\n        vec2 abs_local = abs(local_0_to_1-0.5);\n        //I get the max like in a square sdf and if \n        //the value for that coord is more than 0.49 I say it's a border\n        //so make it white and break\n        //I try to subtracta small fraction of layer num over max layers\n        //but it doesn't really add anythin\n        if(max(abs_local.x,abs_local.y) > 0.49 \n        - float(i)/(20.*float(max_layers))) {\n            O ++; //stolen from fabrice\n            O.rgb += vig;\n            break;\n        }\n        //at the end of each round increase the color value by some standard\n        //amount\n        O.rbg += vec3(0.05, 0.1,0.08);\n\n    }\n   \n   //I through another circle on top like it fabrice's version to hind \n   //how the borders become a problem later on.\n   float circle_mask = 1.00-smoothstep(radius -eps, radius +eps,  length(uv-circle_coords) - radius*0.01);\n   vec3 circle_color =vec3(0.9);\n   O.rgb += circle_color*circle_mask/1.;\n   \n   \n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdVGWW", "name": "SDF_Death_Star", "author": "Urnguk", "description": "Something like a death star.. or not.", "tags": ["sdf"], "likes": 4, "viewed": 204, "published": 3, "date": "1631583899", "time_retrieved": "2024-07-30T19:01:31.665177", "image_code": "const vec3  eye      = vec3 ( 0, 0, 6 );\nconst vec3  light    = vec3  ( 0.0, 1.0, 5.0 );\nconst int   maxSteps = 100;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, float r, in vec3 c )\n{\n\treturn length ( p - c ) - r;\n}\n\nfloat dMoon ( vec3 p, in vec3 c )\n{\n    float rad = length(c.xz);\n    vec3 pos = vec3(rad*sin(0.2*iTime), c.y, rad*cos(0.2*iTime));\n\treturn length ( p - pos ) - 0.2 + 0.005*sin(p.x*50.0 + 3.0*iTime) + 0.007*sin(p.y*20.0) +  0.005*sin(p.z*50.0);\n}\n\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\n    return length ( p.xz - c.xy ) - c.z;\n}\n\nfloat dPlane ( vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length ( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dBox ( vec3 p, vec3 b, vec3 c )\n{\nreturn length ( max ( abs ( p - c ) - b, 0.0 ) );\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    return \n        min(\n            max(\n                max(\n                    dSphere(q, 1.0, vec3(0,0,0)), -dTorus(q, vec2(1.0, 0.05))\n                ), \n                -dSphere(q, 0.4 + 0.005*sin((0.6*q.y + q.z)*100.0), vec3(0, 0.6, 1))\n            ), dMoon(q, vec3(1.5, 1.5, 2.2)) \n        );\n  \n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 1, 1 );\n\t} \n    // output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 185, 212, 212, 359], [361, 399, 426, 426, 573], [575, 575, 621, 621, 653], [655, 655, 690, 690, 901], [904, 904, 933, 933, 1001], [1003, 1003, 1032, 1032, 1119], [1122, 1122, 1155, 1155, 1235], [1237, 1237, 1268, 1268, 1311], [1313, 1313, 1346, 1346, 1383], [1385, 1385, 1417, 1417, 1489], [1491, 1491, 1530, 1530, 1582], [1584, 1584, 1626, 1626, 1696], [1699, 1699, 1735, 1735, 2063], [2065, 2065, 2132, 2132, 2447], [2449, 2449, 2501, 2501, 2870], [2872, 2872, 2929, 2984, 3849]], "test": "untested"}
{"id": "7sKGWW", "name": "star street", "author": "jorge2017a2", "description": "star street", "tags": ["starstreet"], "likes": 6, "viewed": 260, "published": 3, "date": "1631583808", "time_retrieved": "2024-07-30T19:01:32.619625", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//tips and cooperation by ocb and spalmer\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 GetColorYMaterialv1(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 GetColorYMaterialv2(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\n\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 estrella(vec3 p, float idcol1, float idcol2)\n{\t\n    vec3 res= vec3(9999.0, -1.0,-1.0);  \n    float sdb1= sdBox(p, vec3(12.0,12.0,10.0) );\n    \n    float r1=3.0;\n    float rf1=3.0;\n    \n    float r2=2.5;\n    float rf2=3.0;\n    \n    vec3 p1=p;\n    p1= rotate_y(p1, radians(90.0));\n    p1= rotate_z(p1, radians(90.0));\n    p1= rotate_y(p1, radians(54.0));\n    \n    float sds1= sdStar5(p1.xz,r1, rf1);\n    float sds2= sdStar5(p1.xz,r2, rf2);\n    \n    float sinte= intersectSDF(sdb1, sds1);\n    float sinte2= intersectSDF(sdb1, sds2);\n    res =opU3(res, vec3(sinte,idcol1,-1.0));\n    res =opU3(res, vec3(sinte2,idcol2,-1.0));\n\n    return res;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.x= opRep1D(p.x, 65.0 );\n    \n    float sdb1= sdBox(p-vec3(0.0,12.0,0.0), vec3(50.0,25.0,1.0) );\n    float sdb2= sdBox(p-vec3(0.0,-5.0,0.0), vec3(50.0,1.0,25.0) );\n    float sdb3= sdBox(p-vec3(0.0,-4.0,0.0), vec3(50.0,6.0,20.0) );\n    p.y=p.y-10.0;\n    \n    vec3 es1= estrella( p-vec3( 20.0,5.0,3.0), 2.0, 3.0);\n    vec3 es2= estrella( p-vec3(  0.0,10.0,-1.0), 5.0, 4.0);\n    vec3 es3= estrella( p-vec3(-20.0,5.0,3.0), 6.0, 7.0);\n    res =opU3(res, es1);\n    res =opU3(res, es2);\n    res =opU3(res, es3);\n    res =opU3(res, vec3(sdb1,101.0,-1.0));\n    res =opU3(res, vec3(sdb2,101.0,-1.0));\n    res =opU3(res, vec3(sdb3,100.0,-1.0));\n   \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return color;\n    \n    \n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\t\n    float es=65.0; //32.0\n    if (i==100 )\n    { vec3 col=tex3D(iChannel0, p/es, nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/es, nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/es, nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/es, nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    float t1=mod(iTime+1.5,4.0);\n    float t2=mod(iTime+3.0,5.0);\n    \n    if (t1<t2)\n    colobj= GetColorYMaterialv1(p, n, ro, rd,id_color,  id_material);\n    else\n    colobj= GetColorYMaterialv2(p, n, ro, rd, id_color, id_material);\n    \n    return colobj;\n}\n\n\n\nvec3 GetColorYMaterialv1(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    if (id_color<100)\n\t\t//{ colobj=getColor(int( id_color)); }\n        { colobj=getColor(id_color+int(mod(iTime,31.)));}\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex*clamp(  0.8+0.5*sin(iTime*0.5),  0.,1.0);\n\t}\n\n    return colobj;\n}\n\nvec3 GetColorYMaterialv2(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj;\n\n    int colswitch = int(mod(iTime,31.));    // preset because it is used many time\n    \n    if (id_color<100)\n        { colobj=getColor(id_color+colswitch);}\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=.3*coltex*clamp(  0.8+0.3*sin(iTime*0.5),  0.,1.0);   // .3* = darken wall to increase light effect\n        \n        \n        p.x= opRep1D(p.x, 65.0 );\n        float d1 = length(vec2(p.x-20., p.y-14.));    // calculating distance from each star center\n        float d2 = length(vec2(p.x    , p.y-19.));\n        float d3 = length(vec2(p.x+20., p.y-14.));\n        \n        float d4 = length(vec2(p.x-45., p.y-14.));    // tricky: used to mix color with the previous and next three stars group\n        float d5 = length(vec2(p.x+45., p.y-14.));\n        \n        float amount=20.0;//10.0\n        colobj += amount/(d1*d1)*getColor(2+colswitch)   // affecting each coresponding color related to the star and to the distance 1/(d*d)\n                 +min(20./(d2*d2)*getColor(5+colswitch),.4)\n                 +amount/(d3*d3)*getColor(6+colswitch)\n                 \n                 +amount/(d4*d4)*getColor(6+colswitch)   // mixing with the next group of three stars\n                 +amount/(d5*d5)*getColor(2+colswitch);  // comment this two lines to see the difference\n\t}\n\n    return colobj;\n}\n\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,520.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(50.0, 260.0, -30.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -100.0, -940.0,30.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0-t,35.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(45.0));\n   rd= rotate_y(rd, radians(-20.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[733, 733, 765, 765, 849], [850, 850, 897, 897, 924], [925, 925, 968, 968, 995], [996, 996, 1044, 1044, 1072], [1073, 1073, 1109, 1109, 1154], [1155, 1155, 1189, 1189, 1285], [1286, 1286, 1320, 1320, 1411], [1412, 1412, 1446, 1446, 1537], [1579, 1579, 1630, 1630, 2008], [2010, 2010, 2061, 2061, 2654], [2657, 2657, 2682, 2682, 3431], [3433, 3484, 3508, 3508, 3670], [3672, 3672, 3721, 3721, 4352], [4355, 4355, 4392, 4392, 4668], [4670, 4670, 4753, 4753, 5362], [5363, 5418, 5467, 5467, 5733], [5734, 5768, 5861, 5861, 5991], [5993, 5993, 6086, 6086, 6368], [6372, 6372, 6467, 6467, 6818], [6820, 6820, 6915, 6915, 8320], [8324, 8324, 8355, 8355, 8903], [8905, 8954, 8980, 8980, 9090], [9092, 9092, 9150, 9150, 9202], [9204, 9253, 9310, 9310, 9976]], "test": "untested"}
{"id": "ssKGWW", "name": "Spongy Holes", "author": "Bedragaren", "description": "SDF test", "tags": ["raymarching", "sdf", "shadows", "menger"], "likes": 2, "viewed": 220, "published": 3, "date": "1631583377", "time_retrieved": "2024-07-30T19:01:33.367626", "image_code": "#define LIGHT_BRIGHTNESS 2.\n#define SPHERE_RADIUS 3. \n// Radiuses 2. and 4. are also worth a look \n\nconst vec3  eye      = vec3 ( 0, 0, 0.5);\n vec3  light    = vec3  ( 0.0, 0.1, 5 );\nconst int   maxSteps = 700;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c, float r )\n{\n\treturn length ( p - c ) - r;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2 q = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat menger ( in vec3 p )\n{\n   float d = dBox(p,vec3(1.0));\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return d;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p + vec3(0,0,-5)*iTime;\n    q.xyz -= 2.5;\n    q = mod(q, 5.0) - 2.5;\n    \n    //return dSphere ( p, vec3 ( 2, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn max (menger(q/2.5), -dSphere ( q, vec3 ( 0, 0, 0 ), SPHERE_RADIUS ));\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, in float maxDist, out float softShadow)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n    softShadow = 1.0;\n    float prevDist = 1e20;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat dist = sdf ( p, m );\n        \n\t\tif ( dist < 0.001 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n        \n        float y = dist*dist/(2.0*prevDist);\n        float d = sqrt(dist*dist-y*y);\n\t\tsoftShadow = min(softShadow, 200. * d / max(0.0, max(totalDist, 0.) - y));\n        prevDist = dist;\n        \n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > maxDist )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n    \n    if (hit) {\n        softShadow = 0.;\n    }\n\t\n\treturn p;\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m) {\n    const float defaultMaxDist = 100.;\n    float softShadow = 0.;\n    return trace ( from, dir, hit, m, defaultMaxDist, softShadow);\n}\n\nfloat traceLightBulb ( in vec3 from, in vec3 dir, out bool hit, in vec3 lightPos, in mat3 m)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat dist = dSphere ( m * p, lightPos, 0.1 );\n        \n\t\tif ( dist < 0.001 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n        \n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 20. )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn totalDist;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateY ( 6.0*mouse.x) *  rotateX ( -6.0*mouse.y );\n    vec2 scale = 3.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec3 color = vec3 ( 0 );\n    vec3 p     = trace ( eye, dir, hit, m );\n    vec3 solidColor = vec3(228, 155, 15) / 255.;\n    vec3 lightColor = vec3(255, (sin(iTime)+0.5)/2.*255., 255) / 255.;\n    \n    light = vec3(5. * -cos(iTime / 2.), 1.5 * sin(iTime + 1.) + 0.1, 5. * sin(iTime / 2.));\n    float hitDist = length( eye - p );\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light*m - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  r  = reflect(l, n);\n        float hn = max ( 0.0, dot ( r, v ) );\n        float sp = pow ( hn, 4.0 );\n        \n        if (dot(l, n) <= 0.) {\n            sp = 0.;\n        }\n\t\t\n\t\tcolor = 1. * solidColor * nl  + solidColor * sp * 0.2;\n        color *= lightColor ;\n        \n        float dist = length(light*m - p);\n        float shadow = 1.;\n        \n        trace(p + l * 0.1, l, hit, m, dist, shadow);\n        \n        color *= LIGHT_BRIGHTNESS / pow(dist, 2.) * shadow;\n        color += 0.001 * solidColor * lightColor / pow(dist, 2.);\n\t}\n    \n    float bulbDist = traceLightBulb(eye, dir, hit, light, m);\n    \n    if (hit && bulbDist < hitDist) {\n        float alpha = clamp(0., 1., pow(abs(bulbDist - length(light*m - eye))*10., 2.));\n        color = (1.-alpha)*color + alpha * (lightColor * 0.5 + vec3(1) * alpha*alpha);\n    }\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 279, 306, 306, 453], [455, 493, 520, 520, 667], [669, 669, 715, 715, 747], [749, 749, 779, 779, 866], [869, 869, 902, 902, 981], [983, 983, 1025, 1025, 1095], [1097, 1097, 1125, 1125, 1479], [1481, 1481, 1517, 1517, 1783], [1785, 1785, 1891, 1891, 2510], [2512, 2512, 2578, 2578, 2713], [2715, 2715, 2809, 2809, 3158], [3160, 3160, 3212, 3212, 3581], [3583, 3583, 3616, 3616, 3784], [3786, 3786, 3843, 3898, 5690]], "test": "untested"}
{"id": "fsV3WD", "name": "Sea of Pearls", "author": "Tater", "description": "I used all the domain repetition tricks I know for this one. ", "tags": ["3d", "raymarching", "underwater"], "likes": 29, "viewed": 551, "published": 3, "date": "1631578385", "time_retrieved": "2024-07-30T19:01:34.135572", "image_code": "#define pi 3.1415926535\n#define STEPS 500.0\n#define MDIST 200.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(453.2734,255.4363)))*994.3434);\n}\nvec3 rdg;\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nvec3 map(vec3 p){\n    vec3 po = p;\n    vec2 a = vec2(1);\n    //vec2 b = vec2(2);\n    float t =iTime;\n    p.x+=t;\n    \n    float m = 2.; //Adjust the sphere size here :)\n    \n    vec2 id3 = floor(p.xz/m)+0.5;\n    p.x+=id3.y;\n    vec2 id2 = floor(p.xz/m)+0.5;\n    float hash =h21(mod(id2,100.0));\n    p.y+=(hash-0.5);\n    id2*=rot(-pi/6.0);\n    p.y+=sin(id2.x+t)*0.7;\n    p.y+=sin(id2.x*0.6+t)*0.4;\n    p.y+=sin(id2.x*0.3+t)*0.2;\n    id2*=rot(pi/6.0)*0.3;\n    p.y+=sin(id2.y+t)*0.7;\n    po = p;\n    float dc = 0.;\n    {\n        vec3 p2=p/vec3(m);\n        vec3 id = floor(p2);\n        vec3 dir = sign(rdg)*.5;\n        vec3 q = fract(p2)-.5;\n        vec3 rc = (dir-q)/rdg;\n        rc*=m;\n        dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    }\n    p.xz = pmod(p.xz,m);\n    t+=hash*200.;\n    //t*=-1.;\n    //////////////////////////////////\n    //////////////////////////////////\n    float spd = .025;\n    t*=spd;\n    float lscl = m;\n    float le = -mod(t * lscl,lscl); \n    float tscl = 650.; \n    float te = tscl - mod(t * tscl,tscl); \n    float scl = 0.; \n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            mid = true;\n            id = floor(t);\n        }\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n            //mid = true;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    //////////////////////////////////\n    //////////////////////////////////\n    \n    a.x = length(p)-m*0.98*0.5;\n    \n    a.x = max(-po.z-16.,a.x);\n    float c = a.x;\n    a.x = min(a.x,dc);\n    \n    if(mid)a.x = min(a.x,max(-(-po.y+le),0.1));\n    a.y = id;\n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvec3 light(vec3 p, vec3 rd){\n    vec3 col = vec3(0);\n    vec3 ld = normalize(vec3(1,1,-1));\n    vec3 n = norm(p);\n    float fres = 1.-abs(dot(rd,n))*.6;\n    col = vec3(clamp(fres,0.,1.));\n    \n    float sss = 0.6;\n        for(float i=1.; i<40.; ++i){\n        float dist = i*0.1;\n        sss += 0.04*smoothstep(0.,1.,map(p+ld*dist).z/dist);\n    }\n    col*=sss;\n    \n    vec3 p2 = p;\n    p2.xz*=rot(0.1+cos(iTime*0.2)*0.3);\n    col*=mix(vec3(0.310,0.471,0.953),vec3(0.106,0.137,0.553),sin(p2.z+p2.x)*0.5+0.5);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(1,10,-25);\n    vec3 lk = vec3(1.01,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));\n    rdg=rd;\n    vec3 p = vec3(0);\n    vec3 d = vec3(0);\n    float dO = 0.;\n    bool hit = false;\n    for(float i =0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO += d.x*1.25;\n        if(abs(d.x)<0.005){\n            hit =true;\n            break;\n        }\n        if(dO>MDIST){\n            dO=MDIST;\n            p = ro+rd*dO;\n            break;\n        }   \n    }\n    if(hit){\n        col = light(p,rd);\n    }\n\n    //Fog\n    col*=clamp(p.y*0.15+1.0,-1.,1.);\n    col = pow(col,vec3(0.6));;\n    vec3 bg = mix(vec3(0.000,0.12,0.400),vec3(0.439,0.784,1.000),max(rd.y+0.6,0.));\n    col = mix(col,bg,clamp(length(p-ro*0.5)/60.,0.,1.));\n\n    fragColor = vec4(col,0.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 169, 169, 235], [246, 246, 272, 272, 330], [331, 331, 348, 348, 2271], [2272, 2272, 2290, 2290, 2418], [2419, 2419, 2447, 2447, 2944], [2945, 2945, 3001, 3001, 3970]], "test": "untested"}
{"id": "fdKGDD", "name": "- sobel fire -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["music", "fire", "detection", "edge"], "likes": 28, "viewed": 1007, "published": 3, "date": "1631574119", "time_retrieved": "2024-07-30T19:01:34.924463", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = col * col.a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define STEP 4.\n\nfloat lookup(vec2 p) {\n    vec4 c = texture(iChannel1, p);\n\treturn dot(c, c);\n}\n\nfloat sobel(vec2 p) {\n    vec3 offset = vec3(STEP / iResolution.x, 0, STEP / iResolution.y); \n    float tl = lookup(p + vec2(-1,  1) * offset.xz);\n    float cl = lookup(p + vec2(-1,  0) * offset.xy);\n    float bl = lookup(p + vec2(-1, -1) * offset.xz);\n    float ct = lookup(p + vec2( 0,  1) * offset.yz);\n    float cb = lookup(p + vec2( 0, -1) * offset.yz);\n    float tr = lookup(p + vec2( 1,  1) * offset.xz);\n    float cr = lookup(p + vec2( 1,  0) * offset.xy);\n    float br = lookup(p + vec2( 1, -1) * offset.xz);\n    vec2 g = vec2(tl + 2. * cl + bl - tr - 2. * cr - br,\n                 -tl - 2. * ct - tr + bl + 2. * cb + br);\n    return dot(g, g);\n }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float s = texture(iChannel2, vec2(0)).r;\n    vec2 uv = (1. - s * 0.015) * (fragCoord.xy / iResolution.xy - 0.5) + 0.5;\n    vec3 col = vec3(0.8, 0.2, 0.1) * sobel(uv); \n    \n    uv += sin(30. * length(uv - 0.5) + iTime * 5.) * (uv.yx - 0.5) * 0.01 / (15. * length(uv - 0.5) + 1.);\n    vec3 fire = vec3(mix(texture(iChannel0, uv).rgb, col, 0.05));\n    fragColor = vec4(fire, s);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 152]], "test": "untested"}
{"id": "NdV3WD", "name": "Black flower thing", "author": "SnoopethDuckDuck", "description": "messy code as always", "tags": ["cool"], "likes": 2, "viewed": 203, "published": 3, "date": "1631572308", "time_retrieved": "2024-07-30T19:01:35.730309", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.5 * iTime;\n\n    vec2 uv = (1.1 + 0.3 * cos(0.31 * t)) * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float theta = atan(uv.y, uv.x);\n    \n    float x = uv.x + 0.3 * cos(2. * theta + 1.1 * t);\n    float y = uv.y + 0.3 * sin(2. * theta + 1.1 * t);\n    \n    float d = max(abs(x) / abs(1.5 + y), abs(y) / abs(1.5 + x));\n    float d2 = max(abs(x), abs(y));\n    \n    float e = step(d, 0.2);\n    e *= (1.-5. * d);\n    e *= cos(t + 3. * theta) * sin(theta + 2. * t);\n    e = 4. * e * (1.-e);\n    e *= e;\n    \n    float e2 = step(d2, 0.2);\n    e2 *= (1.-5. * d2);\n    e2 *= cos(t + 3. * theta) * sin(theta + 2. * t);\n    e2 = 4. * e2 * (1.-e2);\n    e2 *= e2;\n    \n    fragColor = vec4(0.5* (1. + cos(uv.x + t)), 0.5 * (1. + sin(uv.y + t)), 1., 1.) * (1. - 4. * abs(e-e2));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 859]], "test": "untested"}
{"id": "7dyGDW", "name": "cloudyStuff", "author": "stephenl7797", "description": "cloudy stuff.\nLooks drastically different on different platforms :/", "tags": ["abstract"], "likes": 12, "viewed": 453, "published": 3, "date": "1631570883", "time_retrieved": "2024-07-30T19:01:36.570063", "image_code": "\nfloat hash31(vec3 p) {\n    float q = dot(p,vec3(170.1,110.7,100.6));\n\treturn fract(sin(q)*480.5453);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += hash31(floor(p*2.5+100.)) * .1;\n    f += hash31(floor(p*2.+200.)) * .5;\n    f += hash31(floor(p*1.+200.)) * 1.;\n    f += hash31(floor(p/2.+200.)) * .5;\n    f += hash31(floor(p/4.+400.)) * .25;\n    f += hash31(floor(p/8.+400.)) * .25;\n    f += hash31(floor(p/16.+400.)) * .25;\n    return f / 3.65;\n}\nvec3 calcNormal(vec3 p) {\n    float d = .4;\n    return normalize(vec3(\n        fbm(p+vec3(d,0.,0.)) - fbm(p-vec3(d,0.,0.)),\n        fbm(p+vec3(0.,d,0.)) - fbm(p-vec3(0.,d,0.)),\n        fbm(p+vec3(0.,0.,d)) - fbm(p-vec3(0.,0.,d))));\n}\n\n// The ray is rotated along z axis while marching, which gives a slight spiral.\nvec3 rot(vec3 x, float t) {\n    return normalize(vec3(x.x-x.y*t, x.y+x.x*t, x.z));\n}\nvec3 map(vec3 ro, vec3 rd) {\n    float t = 0.9, d = 10.;\n    for (int it=0; it<53; it++) {\n        vec3 rp = ro + t*rd;\n        rd = rot(rd, .023);\n        d = fbm(rp);\n        t += d * .992;\n    }\n    return ro + t * rd;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x += fract(sin(uv.x*250.3+uv.y*400.)*280.24) * .00051;\n\n    vec3 col = vec3(0.);\n    \n    \n    \n    //vec3 ro = vec3(cos(iTime), sin(iTime) ,-2.5 + iTime * .71);\n    vec3 ro = vec3(0.,0. ,-2.5 + iTime);\n    //vec3 ro = vec3(iTime,iTime ,-2.5 + iTime);\n    \n    vec3 rd = normalize(vec3((uv-.5)*vec2(1.0,iResolution.y/iResolution.x),.075));\n    \n    if (iMouse.z > .5) {\n        float pitch = (iMouse.y/iResolution.y-.5)*3., yaw = (iMouse.x/iResolution.x-.5)*3.;\n        rd = mat3(1., 0., 0.,   0., cos(pitch), -sin(pitch),   0., sin(pitch), cos(pitch)) *\n             mat3(cos(yaw), 0., -sin(yaw),   0.,1.,0.,  sin(yaw),0.,cos(yaw)) * rd;\n    }\n    \n    vec3 rp = map(ro,rd);\n    float d = length(rp-ro);\n    \n    float v = clamp(d * .034, 0.,1.);\n\n    col.rgb = clamp(pow(v,9.)*(10.*pal(v*v, vec3(0.0,0.0,0.0),vec3(0.5,0.50,0.98),vec3(-1.,.50,.0),vec3(0.10,0.72,0.1))),0.,1.);\n    col.rgb += .8 * clamp(v*pal(v, vec3(0.01,0.0,0.07),vec3(0.9,0.0,0.999),vec3(.85,.0,.65),vec3(0.4,0.0,0.5) ),0.,1.);\n    \n    vec3 n = calcNormal(rp);\n    col.rgb += clamp(v*v*pow(abs(n.z),3.) * vec3(.05,.716,.91) * 1.2, 0.,1.);\n    col.rgb += clamp(v*pow((n.y-.1),5.) * vec3(.75,.7216,.01) * .97, 0.,1.);\n    col.r = pow(col.r,1.25);\n    //col.g = pow(col.g,2.5);\n    //col.b = pow(col.b,2.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 103], [105, 105, 124, 124, 450], [451, 451, 476, 476, 684], [686, 766, 793, 793, 850], [851, 851, 879, 879, 1074], [1076, 1076, 1144, 1144, 1187], [1189, 1189, 1246, 1246, 2603]], "test": "untested"}
{"id": "fdG3DW", "name": "Caleidoscopic voronoi circles", "author": "kristoflovas", "description": "...", "tags": ["circles"], "likes": 7, "viewed": 289, "published": 3, "date": "1631560977", "time_retrieved": "2024-07-30T19:01:37.456693", "image_code": "#define saturate(x) clamp(x,0.,1.);\n\nfloat Circle01(vec2 coord,vec2 offset,float minsize, float maxsize, float sizealpha,float linewidth)\n{\nfloat circle = 1.-saturate(ceil(abs(distance(fract(coord)+offset,vec2(.5))-mix(minsize,maxsize,sizealpha))-linewidth/2.));\nreturn circle;\n}\n\nfloat circularsine(vec2 coord,vec2 offset,float cells,float wavefreq,float speed)\n{\nreturn (sin(distance((floor(coord)-cells/2.)-offset,vec2(0.))/wavefreq-iTime*speed)+1.)/2.;\n}\n\n\nconst float cells = 12.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat ar = iResolution.x/iResolution.y;\nvec2 uv = fragCoord/iResolution.xy;\nuv = vec2(uv.x,1.-uv.y)*vec2(ar,1.)-vec2((ar-1.)/2.,0.);\n\nfloat circles = 0.;\nfloat minsize = -0.1;\nfloat maxsize = 1.5;\nvec2 curpos = vec2(0.);\n\nvec2 biguv = uv*cells;\n\nfor(int x=-1;2>x;x++)\n{\ncurpos.x=float(x);\n\nfor(int y=-1;2>y;y++)\n{\ncurpos.y=float(y);\n\nfloat sine =circularsine(biguv,curpos,cells,2.,.5);\nfloat c =Circle01(biguv,curpos,minsize, maxsize, sine,.05);\n\ncircles =max(circles,c);\n}}\n    // Output to screen\n    fragColor = vec4(circles);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdG3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 139, 139, 279], [281, 281, 364, 364, 458], [487, 487, 544, 544, 1077]], "test": "untested"}
{"id": "fdVGWW", "name": "Ed Balls", "author": "SnoopethDuckDuck", "description": "more messing around", "tags": ["cool"], "likes": 5, "viewed": 206, "published": 3, "date": "1631560661", "time_retrieved": "2024-07-30T19:01:38.429093", "image_code": "float myLength(vec2 uv, float t) {\n    return abs(uv.x * (1. + 0.5 * cos(t))) + abs(uv.y * (1. + 0.5 * sin(t)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.3 * iTime;\n    float s = 0.5 * (1. + cos(t));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (12. + 2. * cos(0.45 * t)) *(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n     float theta = atan(uv.y, uv.x);\n    uv = vec2(cos(uv.x + theta + 0.9 * t), sin(uv.y + theta + 0.9 * t));\n    //float theta =  atan(uv.y, uv.x);\n    // Time varying pixel color\n    float d = smoothstep(myLength(uv + 0.1 * vec2(cos(t),sin(t)), 4. * t),\n                         0.2 * sin(1. * theta + t) * cos(1. * theta +  t), \n                         0.1);\n    float r = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    r *= 10. * d * (1.-d);\n    \n    d += 0.005 * cos(theta + t);\n    \n    float g = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    g *= 10. * d * (1.-d);\n    \n    d -= 0.01 * cos(theta + t);\n    \n    float b = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    b *= 10. * d * (1.-d);\n    \n    \n    // Output to screen\n    fragColor = vec4(g,r,b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 114], [116, 116, 173, 173, 1143]], "test": "untested"}
{"id": "7syGWW", "name": "More swirly stuff", "author": "SnoopethDuckDuck", "description": "very sloppy code, avert your eyes", "tags": ["cool"], "likes": 3, "viewed": 229, "published": 3, "date": "1631543843", "time_retrieved": "2024-07-30T19:01:39.185071", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 0.1;\n\n    float t = iTime;//mod(iTime, 2. * 3.14159);\n    float b = 0.5 * (1. + cos(0.2 * t));   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.5 * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float theta = atan(uv.y, uv.x);\n    \n    uv = vec2(1.6 * uv.x - 1.2 * uv.y * cos(4. * theta + t), 1.2 * uv.x * sin(3. * theta + t) + 1.6 * uv.y);\n\n    //float theta = atan(uv.y, uv.x);\n    \n    float d = b * ( abs(uv.x) + abs(uv.y))\n            + (1.-b) * ( max(abs(uv.x), abs(uv.y)));\n            \n    float r = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    r = 4. * r * (1.-r);\n    \n    t += a;\n    \n     float g = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    g = 4. * g * (1.-g);\n    \n    t -= 2. * a;\n    \n     float b2 = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    b2 = 4. * b2 * (1.-b2);\n    \n    \n    \n    fragColor = vec4(r,g,b2,1.) * 1.4 * (1.-d * d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1160]], "test": "untested"}
{"id": "Nsy3DD", "name": "Okhsl lightness animation", "author": "bjornornorn", "description": "Animation of Okhsl, based on https://bottosson.github.io/posts/colorpicker/\n\nDesigned to be more uniform than regular HSL", "tags": ["hsl", "colorspace", "oklab", "okhsl"], "likes": 8, "viewed": 784, "published": 3, "date": "1631542348", "time_retrieved": "2024-07-30T19:01:40.340981", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-iResolution.xy*0.5)/min(iResolution.x,iResolution.y);\n    \n    float h = atan(uv.y, uv.x)/(2.0*M_PI);\n    float s = length(uv);\n    \n    vec3 col = okhsl_to_srgb(vec3(h, s, (0.5f+0.5f*cos(iTime))));\n    \n    col = s > 1.0 ? vec3(0.0) : col;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Copyright(c) 2021 Björn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\t\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f- S_0 / S_max;\n\n\t// first we compute L and V as if the gamut is a perfect triangle:\n\n\t// L, C when v==1:\n\tfloat L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);\n\tfloat C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n\tfloat L = v * L_v;\n\tfloat C = v * C_v;\n\n\t// then we compensate for both toe and the curved top part of the triangle:\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\tfloat L_new = toe_inv(L);\n\tC = C * L_new / L;\n\tL = L_new;\n\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L * scale_L;\n\tC = C * scale_L;\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsv(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f - S_0 / S_max;\n\n\t// first we find L_v, C_v, L_vt and C_vt\n\n\tfloat t = T_max / (C + L * T_max);\n\tfloat L_v = t * L;\n\tfloat C_v = t * C;\n\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\t// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L / scale_L;\n\tC = C / scale_L;\n\n\tC = C * toe(L) / L;\n\tL = toe(L);\n\n\t// we can now compute v and s:\n\n\tfloat v = L / L_v;\n\tfloat s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n\treturn vec3 (h, s, v );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsy3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 365]], "test": "untested"}
{"id": "NsyGDD", "name": "Overlaying Waves", "author": "Arrangemonk", "description": "tried to make waves for an ocean shader, ended up making a very inefficient noise function", "tags": ["wavesnoise"], "likes": 2, "viewed": 291, "published": 3, "date": "1631540739", "time_retrieved": "2024-07-30T19:01:41.201680", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 4.;\nfloat octaves = 128.;\n\nfloat wave(float x,float time)\n{\n   //return 1.-abs(sin(x * PI - time));\n   return sin(x * PI - time) *.5 + .5;\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\nfloat rotfbm(vec3 pos)\n{\nfloat result = 0.;\nfloat m = 0.;\nfor(float i = 1.; i < octaves;i++)\n    {\n    float tmp = 1./i;\n    m += tmp;\n    result += wave(rot(pos.xy*i,PI * E * i).x * iters,pos.z)* tmp;\n    }\nreturn result /m;\n}\n\nvec3 NormalMap(in vec2 uv)\n{ \n    float p  = rotfbm(vec3(uv,iTime));\n    float h1 = rotfbm(vec3(uv + vec2(.1,0),iTime));\n    float v1 = rotfbm(vec3(uv + vec2(0,.1),iTime));      \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1));\n    return normalize(vec3(normal, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    float val = rotfbm(vec3(uv,iTime));\n    vec3 col = NormalMap(uv);\n\n    // display as normals\n    //fragColor = vec4( col,1.0);\n    \n    // display as height\n    fragColor = vec4( val,val,val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 264, 304, 345], [347, 347, 377, 377, 457], [459, 459, 483, 483, 686], [688, 688, 716, 716, 952], [954, 954, 1011, 1011, 1254]], "test": "untested"}
{"id": "fsG3WD", "name": " Macbeth Chart", "author": "mosan_hoshi", "description": "My first GLSL", "tags": ["2d", "static"], "likes": 7, "viewed": 290, "published": 3, "date": "1631538272", "time_retrieved": "2024-07-30T19:01:42.080331", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // color values for color chart \n  // https://www.nationalphoto.co.jp/2Fspot/tips_colorchart.htm\n  float[24] rs =\n    float[](0.450980392,0.760784314,0.384313725,0.341176471,0.521568627,0.403921569,\n            0.839215686,0.31372549,0.756862745,0.368627451,0.615686275,0.878431373,\n            0.219607843,0.274509804,0.68627451,0.905882353,0.733333333,0.031372549,\n            0.952941176,0.784313725,0.62745098,0.478431373,0.333333333,0.203921569);\n\n  float[24] gs =\n    float[](0.321568627,0.588235294,0.478431373,0.423529412,0.501960784,0.741176471,\n            0.494117647,0.356862745,0.352941176,0.235294118,0.737254902,0.639215686,\n            0.239215686,0.580392157,0.211764706,0.780392157,0.337254902,0.521568627,\n            0.952941176,0.784313725,0.62745098,0.478431373,0.333333333,0.203921569);\n\n  float[24] bs =\n    float[](0.266666667,0.509803922,0.615686275,0.262745098,0.694117647,0.666666667,\n            0.17254902,0.650980392,0.388235294,0.423529412,0.250980392,0.180392157,\n            0.588235294,0.28627451,0.235294118,0.121568627,0.584313725,0.631372549,\n            0.949019608,0.784313725,0.62745098,0.474509804,0.333333333,0.203921569);\n\n  //consts \n  int x_tile_num = 6;\n  int y_tile_num = 4;\n  float w = iResolution.x / min(iResolution.x, iResolution.y);\n  float h = iResolution.y / min(iResolution.x, iResolution.y);\n  float margin = 0.05;\n  float padding = 0.02;\n  float tile_length = min((w - 2. * margin - float(x_tile_num - 1) * padding) / float(x_tile_num), // x tile length\n                          (h - 2. * margin - float(y_tile_num - 1) * padding) / float(y_tile_num));// y tile length \n  float y_margin = (h - float(y_tile_num) * tile_length  - float(y_tile_num - 1) * padding) /  2.0;\n  float x_margin = (w - float(x_tile_num) * tile_length  - float(x_tile_num - 1) * padding) /  2.0;\n\n\n  // normalize position(y:.0~1.0)\n  vec2 uv=fragCoord.xy / min(iResolution.x, iResolution.y);\n  // flip y-axis (left-top is (x,y)=(0,0))\n  uv.y = h - uv.y;\n\n  // draw color tiles\n  for(int y=0;y<4;y=y+1){\n    for(int x=0;x<6;x=x+1){\n      float left_x = x_margin + float(x) * (tile_length + padding);\n      float top_y = y_margin + float(y) * (tile_length + padding);\n      int tile_idx = y * 6 + x;\n      if((uv.x >= left_x) && (uv.x < (left_x + tile_length))){\n        if((uv.y >= top_y) && (uv.y < (top_y + tile_length))){\n          fragColor=vec4(rs[tile_idx],gs[tile_idx],bs[tile_idx],0.);\n        }\n        }\n    }\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsyGWD", "name": "Satisfying diamond", "author": "SnoopethDuckDuck", "description": "Sloppy code, dont know how it works, looks okay I think", "tags": ["cool"], "likes": 8, "viewed": 308, "published": 3, "date": "1631536700", "time_retrieved": "2024-07-30T19:01:42.837306", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 0.04;\n\n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5* iResolution.xy) / iResolution.y;\n    float theta = atan(uv.y,uv.x);\n\n    float d = 2. * cos(t) * 0.75 * (abs(uv.x * uv.y) * (1. + 0.1 * cos(2. * theta + t)) + abs(uv.x) + abs(uv.y));\n    \n\n    float r = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    r += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    r *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    t += a;\n    \n    float g = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    g += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    g *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    t -= 2. * a;\n    \n    float b = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    b += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    b *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    \n    \n    //e *= cos(t); //e *= 16. * d * d * (1. - d) * (1.-d);\n    //e = 0.9 * cos(e);\n    // Output to screen\n    fragColor = vec4(g,r,b,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1854]], "test": "untested"}
{"id": "fdy3DW", "name": "Spruce Goose", "author": "dr2", "description": "Possibly the undesigned Mk.II version; flies about as well", "tags": ["airplane", "wake", "hughes", "seaplane"], "likes": 23, "viewed": 442, "published": 3, "date": "1631534996", "time_retrieved": "2024-07-30T19:01:43.778789", "image_code": "// \"Spruce Goose\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 17 in \"Aeroplane\" series\n    \"River Flight\"              (4sSXDG)\n    \"Spitfire Pursuit\"          (4dSSWV)\n    \"Alpine Jets\"               (Xll3Rr)\n    \"Canyon Roller\"             (4tlGDM)\n    \"Biplanes in the Badlands\"  (MlX3Rf)\n    \"Albert's Canyon\"           (4lXGRl)\n    \"Yellow Moth\"               (MtXGzs)\n    \"Shootout in Red Canyon\"    (XsVXWG)\n    \"Aerobatics\"                (XltGRM)\n    \"Pack Ice\"                  (ldScDt)\n    \"Red Canyon 2\"              (ldlBRM)\n    \"Cockpit View\"              (MsffWn)\n    \"Arctic Patrol\"             (lsBfzy)\n    \"River Flight 2\"            (4l3cz8)\n    \"Ekranoplan\"                (Wd3fDH)\n    \"Suborbital Flight\"         (stXSDs)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, flyPos, flyVel;\nfloat tCur, dstFar, flyRol, wkFac;\nint idObj;\nconst int idFus = 1, idCkp = 2, idEng = 3, idHul = 4, idWngM = 5, idWngT = 6, idTail = 7,\n   idFlt = 8, idLeg = 9, idAnt = 10;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wsp, wcr, s, w, t, dy;\n  dMin = dstFar;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  w = 1.;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    dy = 0.02 * s;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.04 * s;\n    dy = -0.02 * s;\n  }\n  d = PrCapsDf (q - vec3 (0., dy, 0.), w, 7.);\n  DMINQ (idFus);\n  q = p;\n  q.yz -= vec2 (0.4, 3.7);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  wsp = 5.;\n  wcr = 1.4;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (wsp, 0.8, 1.);\n  s = (q.z - 0.3) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (abs (q.x - 0.45) - 2.15, q.z - 0.065 * q.x + 1.),\n     vec2 (2., 0.2))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngM);\n  wsp = 2.4;\n  wcr = 0.65;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (0., 1.4, -6.2);\n  s = (q.z - 0.1) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (q.x - 1.4, q.z - 0.03 * q.x + 0.35),\n     vec2 (0.8, 0.15))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngT);\n  wsp = 1.3;\n  wcr = 1.;\n  q = p;\n  t = wcr * (1. - 0.25 * q.y / wsp);\n  q.yz -= vec2 (1.6, -6.3);\n  s = (q.z + 0.2 * q.y / wsp - 0.1) / wcr;\n  d = min (wsp - abs (q.y), abs (PrBox2Df (vec2 (q.y - 0.25, q.z + (0.2 / wsp - 0.19) * q.y + 0.57),\n     vec2 (0.75, 0.17))));\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.2 * q.y / wsp), 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.1);\n  w = 0.2 * (1. - 0.5 * q.z * q.z);\n  d = min (max (PrCapsDf (q, w, 0.9), q.z - 0.5), PrCapsDf (q, 0.13, 0.55));\n  DMINQ (idEng);\n  q = p;\n  q.yz -= vec2 (-0.8, 4.);\n  w = 0.55;\n  t = 0.3;\n  s = q.z * q.z;\n  if (q.z > 0.) {\n    w *= 1. - 0.1 * s;\n    q.y -= 0.025 * s;\n    t -= 0.05 * s;\n  } else {\n    w *= 1. - 0.01 * s;\n  }\n  w *= 1. + q.y;\n  d = PrRoundBoxDf (q, vec3 (w, t, 5.5 + 0.1 * q.y), 0.1);\n  DMINQ (idHul);\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= vec2 (6.5, 1.1);\n  q.z = dot (vec2 (abs (q.z) - 0.3, q.y), sin (0.03 * pi * sign (q.z) + vec2 (0.5 * pi, 0.)));\n  d = max (PrCaps2Df (q.xz, 0.03, 0.12), abs (q.y) - 0.75);\n  DMINQ (idLeg);\n  q.yz -= vec2 (-0.83, 0.1);\n  d = max (PrCapsDf (q, 0.25, 0.5), q.y - 0.13);\n  DMINQ (idFlt);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 1.1, 3.);\n  d = PrCapsDf (q.xzy, 0.03, 0.15);\n  DMINQ (idAnt);\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.65);\n  d = PrCylDf (q, 0.55, 0.02);\n  qHit = q;\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, gCol4;\n  float s;\n  col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n  gCol4 = vec4 (0.9, 0.5, 0.2, 0.2);\n  if (idObj == idFus) {\n    col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (PrRoundBox2Df (vec2 (qHit.y - 0.2,\n       abs (qHit.z - 1.) - 2.5), vec2 (0.35, 0.12), 0.05)));\n    if (PrRoundBox2Df (vec2 (qHit.y - 0.3, mod (qHit.z + 0.5, 1.) - 0.5),\n       vec2 (0.15, 0.08), 0.05) < 0. && abs (qHit.z) < 4.5) col4 = vec4 (0., 0., 0., -2.);\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (abs (qHit.y + 0.4) - 0.04)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.5 && qHit.y < 0.53 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.25) - 0.25) > 0.03) col4 = vec4 (0., 0., 0., -2.);\n  } else if (idObj == idWngM) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.x - 2., qHit.z - 0.1)) - 0.4) - 0.1) - 0.02));\n    if (length (vec2 (abs (qHit.x - 5.), qHit.z - 0.8)) < 0.1) col4 = vec4 (0.8, 0., 0., -1.);\n  } else if (idObj == idTail) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.y - 0.5, qHit.z - 0.05)) - 0.2) - 0.05) - 0.02));\n    if (length (vec2 (qHit.y - 1.3, qHit.z + 0.65)) < 0.12) col4 = vec4 (0.9, 0.9, 0.3, -1.);       \n  } else if (idObj == idEng) {\n     col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (qHit.z - 0.35) - 0.03);\n     col4 = mix (col4, gCol4, step (0.52, qHit.z));\n  } else if (idObj == idHul || idObj == idFlt) {\n    col4 *= 0.93 + 0.07 * sin (128. * sin (qHit.y));\n  } else if (idObj == idLeg) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (qHit.z) - 0.01));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, t, tw, cs;\n  float wFreq, wAmp, h;\n  h = 0.;\n  if (d < 0.3 * dstFar) {\n    qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n    wFreq = 0.4;\n    wAmp = 0.1;\n    tw = 0.5 * tCur * vec2 (1., -1.);\n    q = p;\n    q += flyVel.xz * tCur;\n    for (int j = 0; j < 5; j ++) {\n      q *= qRot;\n      t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n      v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n      t = 1. - sqrt (v4.xz * v4.yw);\n      t *= t;\n      t *= t;\n      h += wAmp * (t.x + t.y);\n      wFreq *= 2.;\n      wAmp *= 0.5;\n    }\n    h += 0.3 * wkFac * (1. - smoothstep (0.3, 1.5, length (vec2 (abs (p.x) - 1.3, 0.1 * p.y + 1.1))));\n    h *= 1. - smoothstep (0.1, 0.3, d / dstFar);\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz, s)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz, d);\n  return vec4 (normalize (vec3 (h - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy, h);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.4, 1.) + 0.2 * pow (1. - rd.y, 5.),\n     vec3 (0.9), clamp (Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz +\n     0.5 * tCur)) * rd.y + 0.2, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vh4;\n  vec3 col, vn, rw, vnw, row, rdw, roo, rdo, watCol, c;\n  float dstObj, dstWat, f, sh, hw, wkFacF, nDotL;\n  bool waterRefl;\n  flyVel = vec3 (0., 0., 7.);\n  flyRol = 0.005 * pi * sin (0.1 * pi * tCur);\n  wkFac = 1. - smoothstep (0., 0.5, flyPos.y - 1.2);\n  wkFacF = 0.7 * (1. - smoothstep (0., 0.5, flyPos.y - 0.95));\n  roo = ro;\n  rdo = rd;\n  if (rd.y < 0.) {\n    dstWat = - ro.y / rd.y;\n    if (dstWat < 0.3 * dstFar) dstWat = WaveRay (ro, rd);\n  } else dstWat = dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || waterRefl) dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      waterRefl = (dstWat < min (dstFar, dstObj));\n      if (waterRefl) {\n        ro += dstWat * rd;\n        vh4 = WaveNf (ro, dstWat);\n        vnw = vh4.xyz;\n        hw = vh4.w;\n        row = ro;\n        rdw = rd;\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n      }\n    }\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    if (col4.a >= 0.) {\n      sh = waterRefl ? 1. : ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n         0.8 * sh * nDotL * nDotL) + col4.a * step (0.95, sh) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.7 + 0.3 * max (- dot (rd, vn), 0.));\n    }\n    if (col4.a == -2. || col4.a >= 0.) {\n      rd = reflect (rd, vn);\n      c = SkyCol (ro, rd);\n      if (col4.a == -2.) col = 0.4 * (c * c + 0.5);\n      else if (rd.y > 0.) col = mix (col, c, 0.05);\n    }\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    f = (1. - smoothstep (0.1, 1.5, length (vec2 (0.3 * row.x, 0.06 * row.z + 1.)))) * wkFac;\n    f = max (f, (1. - smoothstep (0.1, 1., length (vec2 (0.8 * (abs (row.x) - 6.5),\n       0.1 * row.z + 0.5)))) * wkFacF);\n    rw = row + flyVel * tCur;\n    vnw = VaryNf (rw, vnw, (1. + 5. * f) * (1. - smoothstep (0.1, 0.4, dstWat / dstFar)));\n    watCol = mix (vec3 (0.1, 0.35, 0.4), vec3 (0.1, 0.3, 0.25),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * rw.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.8 * col, 0.2 + 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (1.), 0.5 * (1. - smoothstep (0., 0.1, f)) * pow (clamp (0.1 * hw +\n         Fbm2 (0.5 * rw.xz), 0., 1.), 8.));\n    col = mix (col, vec3 (1.) * (0.7 + 0.3 * Fbm2 (64. * rw.xz)), f);\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.6, 0.95, dstWat / dstFar));\n  }\n  if (TrObjRay (roo, rdo) < min (min (dstObj, dstWat), dstFar)) col = mix (col,\n     mix (vec3 (1., 0.6, 0.3), vec3 (1.), step (0.05, abs (length (qHit.xy) - 0.45))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  } else {\n    az -= 0.025 * pi * tCur;\n    el -= 0.05 * pi * sin (0.04 * pi * tCur);\n  }\n  el = clamp (el, 0.07 * pi, 0.3 * pi);\n  flyPos = vec3 (0., 1.2 + 4. * SmoothBump (0.25, 0.75, 0.15, mod (0.02 * tCur, 1.)), 0.);\n  ro = 35. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.).xzy;\n  vuMat = DirVuMat (normalize (flyPos - ro));\n  zmFac = 5.5;\n  dstFar = 250.;\n  sunDir = normalize (vec3 (1., 1.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3DW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1818, 1818, 1840, 1840, 4360], [4362, 4362, 4395, 4395, 4578], [4580, 4580, 4601, 4601, 4856], [4858, 4858, 4882, 4882, 5088], [5090, 5090, 5125, 5125, 5309], [5311, 5311, 5329, 5329, 6966], [6968, 6968, 7005, 7005, 7234], [7236, 7236, 7268, 7268, 8021], [8023, 8023, 8057, 8057, 8560], [8562, 8562, 8593, 8593, 8795], [8797, 8797, 8829, 8829, 9034], [9036, 9036, 9071, 9071, 11933], [11935, 11935, 11991, 11991, 13245], [13247, 13247, 13293, 13293, 13340], [13342, 13342, 13375, 13375, 13464], [13466, 13466, 13513, 13513, 13560], [13562, 13562, 13604, 13604, 13655], [13657, 13657, 13700, 13700, 13764], [13766, 13766, 13810, 13810, 13870], [13872, 13872, 13917, 13917, 14009], [14011, 14011, 14056, 14056, 14094], [14096, 14096, 14153, 14153, 14236], [14238, 14238, 14263, 14263, 14432], [14434, 14434, 14464, 14464, 14577], [14579, 14579, 14610, 14610, 14674], [14708, 14708, 14732, 14732, 14844], [14846, 14846, 14870, 14870, 14933], [14935, 14935, 14960, 14960, 15146], [15148, 15148, 15173, 15173, 15510], [15512, 15512, 15533, 15533, 15688], [15690, 15690, 15719, 15719, 15931], [15933, 15933, 15972, 15972, 16224]], "test": "untested"}
{"id": "fsGGWW", "name": "Colorful Chaos", "author": "fihade", "description": "Colorful Chaos.", "tags": ["2dcolor"], "likes": 1, "viewed": 202, "published": 3, "date": "1631522755", "time_retrieved": "2024-07-30T19:01:44.642480", "image_code": "#define V vec3\n#define m(p) (length(mod(p,4.)-2.)-2.)\n\n\nvoid mainImage(out vec4 O, vec2 I){\n   \n    V a = iResolution, b=iMouse.xyz,\n    c = 10.*(b/a-.5)*sign(b),\n    d = V(a.y/.5,I+I-a.xy),\n    p = d-d; p.x=iTime;\n    d.xy *= mat2(sin(vec4(0,100,55,0)+c.x)); \n    d /= length(d);\n   \n    c = p;\n    float e = I.x/a.x*4.,\n    L = float(16),\n    z = L;\n    \n    for( int i = 1; i < 20; i++ ){\n        a = sign(d);\n        b = fract(-c*z*a);\n        b += step(b,-b);\n        a *= b/d;\n        b = min(a.xxx,min(a.y,a.z));\n        c += d*b/z;\n        z *= m(ceil(c*z+d*step(a,b))/z-.5/z)*z<.8?2.:1.;\n    }\n\n    O.rgb = (mod(ceil(c*z/2.),3.)+.1)/V(9.+dot(p-c,p-c))*(m(c)*z);\n    O *= 1.2-.8 * pow(abs(mod(e+e,2.)-1.),3.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 91, 91, 719]], "test": "untested"}
{"id": "7sK3D1", "name": "Okhsl saturation animation", "author": "bjornornorn", "description": "Animation of Okhsl, based on https://bottosson.github.io/posts/colorpicker/\n\nDesigned to be more uniform than regular HSL", "tags": ["hsl", "colorspace", "oklab", "okhsl"], "likes": 15, "viewed": 1374, "published": 3, "date": "1631520994", "time_retrieved": "2024-07-30T19:01:45.580971", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = okhsl_to_srgb(vec3(uv.x, 0.5f+0.5f*sin(iTime), uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Copyright(c) 2021 Björn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\t\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f- S_0 / S_max;\n\n\t// first we compute L and V as if the gamut is a perfect triangle:\n\n\t// L, C when v==1:\n\tfloat L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);\n\tfloat C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n\tfloat L = v * L_v;\n\tfloat C = v * C_v;\n\n\t// then we compensate for both toe and the curved top part of the triangle:\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\tfloat L_new = toe_inv(L);\n\tC = C * L_new / L;\n\tL = L_new;\n\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L * scale_L;\n\tC = C * scale_L;\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsv(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f - S_0 / S_max;\n\n\t// first we find L_v, C_v, L_vt and C_vt\n\n\tfloat t = T_max / (C + L * T_max);\n\tfloat L_v = t * L;\n\tfloat C_v = t * C;\n\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\t// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L / scale_L;\n\tC = C / scale_L;\n\n\tC = C * toe(L) / L;\n\tL = toe(L);\n\n\t// we can now compute v and s:\n\n\tfloat v = L / L_v;\n\tfloat s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n\treturn vec3 (h, s, v );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sK3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 202]], "test": "untested"}
{"id": "sdK3D1", "name": "Okhsv hue animation", "author": "bjornornorn", "description": "Animation of Okhsv, based on https://bottosson.github.io/posts/colorpicker/\n\nDesigned to be more uniform than regular HSV", "tags": ["hsv", "colorspace", "oklab", "okhsv"], "likes": 7, "viewed": 744, "published": 3, "date": "1631520811", "time_retrieved": "2024-07-30T19:01:46.554368", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = okhsv_to_srgb(vec3(0.1*iTime, uv.x, uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Copyright(c) 2021 Björn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\t\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f- S_0 / S_max;\n\n\t// first we compute L and V as if the gamut is a perfect triangle:\n\n\t// L, C when v==1:\n\tfloat L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);\n\tfloat C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n\tfloat L = v * L_v;\n\tfloat C = v * C_v;\n\n\t// then we compensate for both toe and the curved top part of the triangle:\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\tfloat L_new = toe_inv(L);\n\tC = C * L_new / L;\n\tL = L_new;\n\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L * scale_L;\n\tC = C * scale_L;\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsv(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f - S_0 / S_max;\n\n\t// first we find L_v, C_v, L_vt and C_vt\n\n\tfloat t = T_max / (C + L * T_max);\n\tfloat L_v = t * L;\n\tfloat C_v = t * C;\n\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\t// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L / scale_L;\n\tC = C / scale_L;\n\n\tC = C * toe(L) / L;\n\tL = toe(L);\n\n\t// we can now compute v and s:\n\n\tfloat v = L / L_v;\n\tfloat s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n\treturn vec3 (h, s, v );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 191]], "test": "untested"}
{"id": "7sVGD1", "name": "Okhsl hue animation", "author": "bjornornorn", "description": "Animation of Okhsl, based on https://bottosson.github.io/posts/colorpicker/\n\nDesigned to be more uniform than regular HSL", "tags": ["hsl", "colorspace", "oklab", "okhsl"], "likes": 4, "viewed": 451, "published": 3, "date": "1631520542", "time_retrieved": "2024-07-30T19:01:47.488869", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = okhsl_to_srgb(vec3(0.1*iTime, uv.x, uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Copyright(c) 2021 Björn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv)\n{\n\tfloat h = hsv.x;\n\tfloat s = hsv.y;\n\tfloat v = hsv.z;\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\t\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f- S_0 / S_max;\n\n\t// first we compute L and V as if the gamut is a perfect triangle:\n\n\t// L, C when v==1:\n\tfloat L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);\n\tfloat C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n\tfloat L = v * L_v;\n\tfloat C = v * C_v;\n\n\t// then we compensate for both toe and the curved top part of the triangle:\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\tfloat L_new = toe_inv(L);\n\tC = C * L_new / L;\n\tL = L_new;\n\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L * scale_L;\n\tC = C * scale_L;\n\n\tvec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n\treturn vec3(\n\t\tsrgb_transfer_function(rgb.r),\n\t\tsrgb_transfer_function(rgb.g),\n\t\tsrgb_transfer_function(rgb.b)\n\t);\n}\n\nvec3 srgb_to_okhsv(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(vec3(\n\t\tsrgb_transfer_function_inv(rgb.r),\n\t\tsrgb_transfer_function_inv(rgb.g),\n\t\tsrgb_transfer_function_inv(rgb.b)\n\t\t));\n\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec2 cusp = find_cusp(a_, b_);\n\tvec2 ST_max = to_ST(cusp);\n\tfloat S_max = ST_max.x;\n\tfloat T_max = ST_max.y;\n\tfloat S_0 = 0.5f;\n\tfloat k = 1.f - S_0 / S_max;\n\n\t// first we find L_v, C_v, L_vt and C_vt\n\n\tfloat t = T_max / (C + L * T_max);\n\tfloat L_v = t * L;\n\tfloat C_v = t * C;\n\n\tfloat L_vt = toe_inv(L_v);\n\tfloat C_vt = C_v * L_vt / L_v;\n\n\t// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n\tvec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n\tfloat scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));\n\n\tL = L / scale_L;\n\tC = C / scale_L;\n\n\tC = C * toe(L) / L;\n\tL = toe(L);\n\n\t// we can now compute v and s:\n\n\tfloat v = L / L_v;\n\tfloat s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n\treturn vec3 (h, s, v );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 191]], "test": "untested"}
{"id": "NdKGRz", "name": "No Basis In Reality", "author": "prishainabox", "description": "References to learn:\nInigo Quilez's website and videos.\nhttps://learnopengl.com/\nThe Book of Shaders: https://thebookofshaders.com/", "tags": ["raymarching"], "likes": 3, "viewed": 168, "published": 3, "date": "1631498340", "time_retrieved": "2024-07-30T19:01:48.303691", "image_code": "const float EPSILON = 0.001;\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfEllipsoid(in vec3 pt, in vec3 rad) {\n    float k0 = length(pt/rad);\n    float k1 = length(pt/(rad*rad));\n    return k0 * (k0-1.0)/k1;\n}\n\nfloat sdfCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\n\n// SDF SCENE\n// materials\n// -1.0 -> sky\n// 0.0 -> grass\n\nvec4 sdfScene(in vec3 pt) {\n\n    float time = iTime;\n    \n    vec4 res = vec4(1000.0, -1.0, 0.0, 1.0);\n    \n    // water?\n    {\n        float water = sdfSphere(pt, 1.12) + 0.01 * (\n            sin(pt.x * 20.0 + sin(pt.y * 30.0) * 0.8) * \n            sin(pt.y * 20.0 + sin(pt.x * 10.0)) * \n            sin(pt.z * 20.0 + sin(pt.x * 10.0))\n        ) - 0.05 * fractalNoise(pt);\n        if(water > 2.0) return res;\n        if (water < res.x) {\n            res.y = 0.0;\n        }\n        res.x = min(res.x, water);\n    }\n    \n    // planet\n    {\n        float ground = 0.5 * sdfSphere(pt, 0.9) - 0.3 * fractalNoise(pt * 0.7);// - 0.05 * noise(pt);\n        ground -= 0.05 * sin(pt.x * 10.0) * sin(pt.y * 10.0) * sin(pt.z * 10.0);\n        if (ground < res.x) {\n            res.y = 1.0;\n        }\n        res.x = min(res.x, ground);\n    }\n    \n    return res;\n    \n}\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy).x - sdfScene(pt - h.xyy).x,\n       sdfScene(pt + h.yxy).x - sdfScene(pt - h.yxy).x,\n       sdfScene(pt + h.yyx).x - sdfScene(pt - h.yyx).x\n    ));\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd) {\n    \n    // result\n    // res.x = closest distance\n    // res.y = material\n    // res.z\n    // res.w\n    vec4 res = vec4(-1.0, -1.0, 0.0, 1.0);\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        vec4 h = sdfScene(ro + td*rd);\n        // if distance is really close, break\n        if (abs(h.x) < (0.0001*td)) {\n           res = vec4(td, h.yzw);\n           break;\n        }\n        // add to total distance\n        td += h.x;\n    }\n       \n    return res;\n    \n}\n\nfloat smoothShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        float d = sdfScene(ro + td*rd).x;\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in vec3 lightDir, in vec3 clr, in float shininess, in float shadowK) {\n    float dif = uclamp(dot(nor, lightDir));\n    float shadow = smoothShadow(pt, lightDir, shadowK);\n    vec3 ref = reflect(lightDir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), shininess);\n    // return  dif * clr * shadow * spec + dif * clr * shadow; \n    return  dif * clr * shadow * (spec + 1.0);\n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd) {\n\n    // cast ray, return dist to closest object and material\n    // obj.x = distance, obj.y = material index\n    // obj.z = , obj.w = \n    vec4 res = castRay(ro, rd);\n    vec3 pt = ro + res.x*rd;\n    \n    float time = iTime;\n    \n    // COLORS\n    vec3 planetClr = vec3(0.08, 0.01, 0.13);\n    vec3 skyClr = vec3(0.05, 0.18, 0.45) * 0.01;\n    vec3 waterClr = vec3(0.335, 0.214, 0.147);\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (res.x < 0.0) return clr;\n    \n    float mat = res.y; // material\n    float shininess = 5.0;\n    vec3 nor = calcNormal(pt);\n    \n    if (mat == 0.0) {\n        clr = waterClr;\n        shininess = 200.0;\n    } else if (mat == 1.0) {\n        shininess = 100.0;//(pow(random(pt), 2.0) * 2.0 - 1.0) * 50.0 + 100.0;\n        clr = planetClr - 0.1*fractalNoise(pt);// -  sin(pt.x * 7.0) * sin(pt.x * 5.0) * sin(pt.y * 10.0) * vec3(0.1, 0.02, 0.04) * fractalNoise(pt) * vec3(0.4, 0.2, 0.9);\n    }\n    \n    if (mat == 0.0 || mat == 1.0) {\n        float k = uclamp( \n            sin(pt.y * (40.0 + 10.0*(1.0 + sin(pt.y * 20.0))) + \n            sin(pt.z * 30.0 + sin(pt.x * 10.0))) \n        );\n        vec3 c = vec3(\n            0.1 + 0.31 * sin(pt.y * 10.0), \n            0.1 + 0.05 * sin(pt.z * 10.0), \n            0.08 + 0.02 * sin(pt.z * 20.0)\n        );\n        clr += k * c * (0.8 - 0.6*mat);\n        clr *= 0.3;\n    }\n    \n    // LIGHTS\n    \n    vec3 sunClr = 0.4 * vec3(9.8, 6.0, 5.5);\n    vec3 moonClr = vec3(2.13, 2.40, 3.46) * 0.5;\n    \n    vec3 sunDir = normalize(vec3(0.6, 0.55, 0.5) * 2.0 - pt); // directional\n    vec3 moonDir = normalize(vec3(-0.6, 0.0, -0.5) * 3.0 - pt);\n   \n    // CALCULATE COLOR\n    vec3 light = vec3(0.01);\n    light += calcLighting(pt, rd, nor, sunDir, sunClr, shininess, 10.0);\n    light += calcLighting(pt, rd, nor, moonDir, moonClr, shininess, 4.0);\n    // misc lights\n    light += 0.5 * calcLighting(\n        pt, rd, nor, \n        normalize(vec3(0.5, -0.2, 0.1) * 2.5 - pt), 0.5 * vec3(5, 2, 1),\n        shininess, 6.0\n    ); // orangey\n    light += 0.5 * calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.2, 0.5) * 2.3 - pt),\n        0.5 * vec3(8, 2, 4), shininess, 3.0\n    ); // red\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(1.9, 0.6, -0.9) * 0.62 - pt),\n        0.5 * vec3(4, 5, 2), shininess, 9.0\n    ); // yellow\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(-0.5, -0.2, 0.1) * 2.5 - pt),\n        vec3(1, 5, 3), shininess, 10.0\n    ); // blue green\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.0, -0.5) * 3.0 - pt),\n        0.5 * vec3(6, 5, 4.5), shininess, 8.0\n    ); // pinkish\n    // misc moving lights\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.2 + 0.4*sin(time * 5.0), -0.2 + 0.4*sin(time * 2.0), 0.5 - cos(time)) * 1.2 - pt),\n        vec3(2, 2, 5), shininess, 8.0\n    ); // blue\n    \n    clr *= light;\n    \n    clr = pow(clr, vec3(0.4545));\n    return clr;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime;\n    vec2 mouse = iMouse.xy;\n    vec2 res = iResolution.xy;\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, 0.0, 0);\n    // ray origin\n    float r = 2.5;\n    vec3 ro = target + vec3(cos(time * 0.5) * r,  0.0, -sin(time * 0.5) * r);\n    \n    vec3 forward = normalize(target - ro); // cam w\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0))); // cam u\n    vec3 up = normalize(cross(right, forward)); // cam v\n    \n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    \n    // calculate color based on distance, etc\n    vec3 clr = calcClr(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 57, 82, 82, 117], [119, 151, 204, 204, 293], [316, 316, 342, 342, 395], [397, 397, 422, 422, 498], [500, 500, 525, 525, 610], [612, 612, 638, 638, 1322], [1324, 1324, 1357, 1357, 1560], [1571, 1571, 1614, 1614, 1645], [1647, 1647, 1692, 1692, 1791], [1793, 1793, 1857, 1857, 2001], [2062, 2062, 2089, 2089, 2919], [2921, 2921, 2950, 2950, 3253], [3255, 3255, 3293, 3394, 3816], [3818, 3818, 3874, 3874, 4266], [4268, 4268, 4393, 4393, 4700], [4702, 4702, 4740, 4875, 7763], [7765, 7765, 7822, 7822, 8591]], "test": "untested"}
{"id": "sdK3Wh", "name": "doors-nnn", "author": "jorge2017a2", "description": "doors-nnn", "tags": ["doorsnnn"], "likes": 21, "viewed": 462, "published": 3, "date": "1631494288", "time_retrieved": "2024-07-30T19:01:49.503484", "image_code": "//----------image\n//por jorge2017a1==jorge2017a2\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 trapecioFig(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n float r1=10.0;\n    float r2=2.0;\n    float he=12.0;\n    \n    vec3 p1=p;\n     p1= rotate_y( p1, radians(90.0));\n    float sdt1= sdTrapezoid(p1.xy, r1, r2, he );\n    float sdb2= sdBox( p1, vec3(10.0,14.,4.0) );\n    \n    float sdba1= sdBox( p-vec3(.0,-2.0,.0), vec3(3.0,2.,8.0) );\n    float sdba2= sdBox( p-vec3(.0,3.,.0), vec3(3.0,2.,8.0) );\n    float sdba3= sdBox( p-vec3(.0,8.0,.0), vec3(3.0,2.,8.0) );\n    \n    float dif= intersectSDF(sdt1, sdb2);\n    dif= differenceSDF(dif,sdba1);\n    dif= differenceSDF(dif,sdba2);\n    dif= differenceSDF(dif,sdba3);\n    res =opU3(res, vec3(dif,24.0,-1.0));\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n   \n    p.z= opRep1D( p.z, 25.0);\n    res =opU3(res, vec3(planeDist1,-1.0,5.0));\n   \n    p.y=p.y-5.0;\n    float sdb1= sdBox( p-vec3(.0,.0,2.0), vec3(20.0,15.,3.0) );\n    float sdb2= sdBox( p-vec3(.0,.0,2.0), vec3(5.0,10.,3.5) );\n    float sdb3= sdBoxFrame( p, vec3(5.0,10.0,2.5), 0.5 );\n    float difPared= differenceSDF(sdb1, sdb2);\n    \n    res =opU3(res, vec3(difPared,15.0,-1.0));\n    res =opU3(res, vec3(sdb3,2.0,-1.0));\n    \n    \n    p.x=abs(p.x)-12.0;\n    vec3 tf1= trapecioFig(p-vec3(.0));\n    res =opU3(res, tf1);\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n    \n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return color;\n    \n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n        \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   col = mix(render_sky_color(rd), col, exp2(-.2*max(0., d-60.)));   \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 40.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 40.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 542, 542, 626], [627, 671, 718, 718, 745], [746, 746, 789, 789, 816], [817, 817, 865, 865, 893], [894, 932, 968, 968, 1013], [1014, 1079, 1113, 1113, 1209], [1210, 1210, 1244, 1244, 1335], [1336, 1336, 1370, 1370, 1461], [1462, 1502, 1536, 1536, 1631], [1632, 1672, 1697, 1697, 1716], [1717, 1717, 1742, 1742, 1761], [1762, 1762, 1798, 1798, 1826], [1828, 1828, 1873, 1873, 2155], [2157, 2157, 2222, 2222, 2532], [2534, 2534, 2560, 2560, 3211], [3213, 3213, 3238, 3238, 3876], [3878, 3929, 3953, 3953, 4115], [4117, 4117, 4166, 4166, 4833], [4835, 4835, 4871, 4871, 5116], [5118, 5118, 5145, 5145, 5162], [5164, 5164, 5200, 5200, 5292], [5293, 5293, 5339, 5339, 5464], [5467, 5467, 5504, 5504, 5780], [5782, 5782, 5865, 5865, 6469], [6471, 6471, 6564, 6564, 6694], [6737, 6737, 6769, 6769, 6966], [6968, 6968, 7015, 7015, 7228], [7230, 7282, 7375, 7375, 7717], [7720, 7720, 7751, 7751, 8438], [8440, 8489, 8515, 8515, 8625], [8627, 8627, 8685, 8685, 8737], [8739, 8788, 8845, 8845, 9392]], "test": "untested"}
{"id": "sdVGWh", "name": "Nautilus Shell", "author": "harry7557558", "description": "My first attempt to model a sea snail with a spiral. Should note that a nautilus is classified as a cephalopod so it's technically not a snail.\n\nThanks this visualizer for helping me debug the SDF: https://www.shadertoy.com/view/ssKGWR", "tags": ["spiral", "logarithmic", "interior", "beach", "nautilus", "seashell", "conch"], "likes": 59, "viewed": 845, "published": 3, "date": "1631492623", "time_retrieved": "2024-07-30T19:01:50.550683", "image_code": "// I have always been facinated with seashells.\n\n// Nautilus is probably the most mathematical one \n// to get my seashell shader journey started.\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\nvec2 cut;  // when modeling the nautilus, cut z<cut.x and z>cut.y to show its interior\n\n\n// calculate the signed distance and color of the nautilus shell\n// this function calculates color only when @req_color is true\nfloat mapShell(in vec3 p, out vec3 col, bool req_color) {\n    p -= vec3(0.7, 0, 0);\n\n    // r=exp(b*θ)\n    const float b = 0.17;\n\n    // Catesian to cylindrical\n    float r = length(p.xy);  // r\n    float a = mix(0.0, 0.45, smoothstep(0.0, 1.0, 0.5*(r-0.6)));  // rotate by this angle\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;  // rotation\n    float t = atan(p.y, p.x);  // θ\n\n    // shell opening, kill discontinuities of the spiral\n    float ro = exp(b*PI);  // center of the \"ring\"\n    float d = length(vec2(length(p.xz-vec2(-ro,0))-ro,p.y));  // distance to the \"ring\"\n    float u = t, dx = r-ro, dy = p.z;  // longitude and two numbers to determine latitude\n\n    // spiral\n    // r(n) = exp(b*(2.*PI*n+t)), (x-r)^2+y^2=r^2, solve for n\n    float n = (log((r*r+p.z*p.z)/(2.*r))/b-t)/(2.0*PI);  // decimal n\n    n = min(n, 0.0);  // clamp to opening\n    float n0 = floor(n), n1 = ceil(n);  // test two boundaries\n    float r0 = exp(b*(2.*PI*n0+t)), r1 = exp(b*(2.*PI*n1+t));  // two r\n    float d0 = abs(length(vec2(r-r0,p.z))-r0);  // distance to inner\n    float d1 = abs(length(vec2(r-r1,p.z))-r1);  // distance to outer\n    if (d0 < d) d = d0, u = 2.*PI*n0+t, dx = r-r0, dy = p.z;  // update distance\n    if (d1 < d) d = d1, u = 2.*PI*n1+t, dx = r-r1, dy = p.z;  // update distance\n\n    // septa/chambers\n    const float f = 2.4;  // \"frequency\" of chambers\n    float s0 = t + 2.0*PI*(n0+0.5);  // longitude parameter\n    float v = fract(n);  // 0-1, distance from inner circle\n    float s = f*s0 + 1.0*pow(0.25-(v-0.5)*(v-0.5), 0.5)+0.5*v;  // curve of septa\n    s += pow(min(1.0/(40.0*length(vec2(v-0.5,p.z))+1.0), 0.5), 2.0);  // hole on septa\n    float sf = fract(s);  // periodic\n    sf = s0>-1.8 ? abs(s+3.25) :  // outer-most septa, possibly cause discontinuities\n         min(sf, 1.0-sf);  // inner septa\n    float w = sf/f*exp(b*(s0+PI));  // adjust distance field\n    if (length(p*vec3(1,1,1.5))<3.0)  // prevent outer discontinuity\n        d = min(d, 0.5*w+0.012);  // union chambers\n\n    d += 0.00012*r*sin(200.*u);  // geometric texture\n    d = abs(d)-0.8*max(0.02*pow(r,0.4),0.02);  // thickness of shell\n    d = max(d, max(cut.x-p.z,p.z-cut.y));  // cut it open\n    if (!req_color) return d;  // distance calculation finished\n\n    // color\n    v = atan(dy, dx);  // latitude parameter\n    w = length(vec2(dx,dy)) / exp(b*u);  // section radius parameter\n    for (float i=0.;i<6.;i+=1.) {  // distort the parameters\n        float f = pow(2., i);\n        float du = 0.15/f*sin(f*u)*cos(f*v);\n        float dv = 0.15/f*cos(f*u)*sin(f*v);\n        u+=du, v+=dv;\n    }\n    float f1 = cos(50.*u);  // middle stripes\n    float f2 = cos(21.3*u)+0.1;  // side stripes\n    float tex = mix(f1, f2, 0.5-0.5*tanh(1.0-3.0*sin(v)*sin(v)))  // blend stripes\n         + 0.5-0.6*cos(v);  // fading at sides\n    tex += 0.5+0.5*tanh(4.0*(u-2.0));  // fading near opening\n    col = n==0.0 ? vec3(0.9,0.85,0.8) : vec3(0.95,0.85,0.7);  // base color, outer and inner\n    if (w>1.0 && w<1.1)  // on the surface of the shell\n        col = (u-0.3*cos(v)<-2.6 ? 1.0-0.6*min(exp(2.+0.5*u),1.0) : 1.0)  // black inside the opening\n            * mix(vec3(0.6,0.3,0.2), col, clamp(8.0*tex+0.5,0.,1.));  // apply stripes\n\n    return d;\n}\n\n// calculate the signed distance and color of the scene\nfloat map(in vec3 p, out vec3 col, bool req_color) {\n    vec3 shell_col;\n    float shell_d = mapShell(p.yzx, shell_col, req_color);  // call mapShell\n    float beach_d = p.z+1.5;  // beach surface: z=-1.5\n    beach_d += 0.001*sin(20.0*p.x)*sin(20.0*p.y) + 0.0005*(sin(51.0*p.x)+sin(50.0*p.y));  // deform the surface of the beach\n    vec3 beach_col = vec3(0.95,0.8,0.5);  // color of the beach\n    float d = min(shell_d, beach_d);  // final signed distance\n    if (d==shell_d) col = shell_col;  // closer to nautilus shell\n    else col = beach_col;  // closer to beach\n    return d;\n}\n\n// calculate signed distance only\nfloat mapDist(vec3 p) {\n    vec3 col;\n    return map(p, col, false);\n}\n\n// numerical gradient of the SDF\nvec3 mapGrad(vec3 p) {\n    const float e = 0.001;\n\tfloat a = mapDist(p+vec3(e,e,e));\n\tfloat b = mapDist(p+vec3(e,-e,-e));\n\tfloat c = mapDist(p+vec3(-e,e,-e));\n\tfloat d = mapDist(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n// \"standard\" raymarching\nbool raymarch(vec3 ro, vec3 rd, inout float t, float t1, float step_size, float eps) {\n    for (int i=int(ZERO); i<100; i++) {\n        float dt = step_size*mapDist(ro+rd*t);\n        t += dt;\n        if (abs(dt) < eps) break;\n        if (t > t1) return false;\n    }\n    return true;\n}\n\n// soft shadow - https://iquilezles.org/articles/rmshadows\nfloat calcShadow(vec3 ro, vec3 rd) {\n    float sh = 1.;\n    float t = 0.1;\n    for (int i = int(ZERO); i<20; i++){\n        float h = mapDist(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 4.0*h/t));\n        t += clamp(h, 0.1, 0.3);\n        if (h<0. || t>8.0) break; \n    }\n    return max(sh, 0.);\n}\n\n// AO - from Shane's https://www.shadertoy.com/view/wslcDS\nfloat calcAO(vec3 p, vec3 n){\n\tfloat sca = 1.5;\n    float occ = 0.;\n    for(float i=ZERO+1.; i<=5.; i+=1.){\n        float t = 0.07*i;\n        float d = mapDist(p+n*t);\n        occ += (t-d)*sca;\n        sca *= .5;\n    }\n    return 1.0 - clamp(occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set cut to view interior\n    float at = mod(iTime, 8.0);  // animation time\n    cut = vec2(-1.8, 1.8);  // show all\n    cut = mix(cut, vec2(-1.8, 0.0), clamp(at-1.0, 0., 1.));  // half\n    cut = mix(cut, vec2(-0.1, 0.1), clamp(at-3.0, 0., 1.));  // slice in the middle\n    cut = mix(cut, vec2(-1.0, -0.8), clamp(at-5.0, 0., 1.));  // slice at the side\n    cut = mix(cut, vec2(-1.8, 1.8), clamp(at-7.0, 0., 1.));  // show all\n\n    // set camera\n    float rx = iMouse.z!=0.0 ? 1.8*(iMouse.y/iResolution.y)-0.2 : 0.3;\n    float rz = iMouse.z!=0.0 ? -iMouse.x/iResolution.x*4.0*3.14 : -0.3;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  // far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  // left to right\n    vec3 v = cross(w,u);  // down to up\n\n    vec3 ro = 12.0*w;  // ray origin\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  // ray direction\n\n    // ray intersection\n    float t0 = 0.01;  // start at t=t0\n    float t1 = 3.0*length(ro);  // end distance\n    float t = t0;\n    if (!raymarch(ro, rd, t, t1, 0.8, 1e-3)) {  // raymarch\n        t = 100.;  // miss, set t to a large number so it fades\n    }\n    vec3 p = ro+rd*t;  // current position\n\n    const vec3 sundir = normalize(vec3(0.5, -0.5, 0.5));  // direction of the sun\n    vec3 n = normalize(mapGrad(p));  // get normal\n    vec3 col; map(p, col, true);  // get color\n    float shadow = calcShadow(p, sundir);  // soft shadow\n    float ao = calcAO(p, n);  // ao\n    vec3 sunlight = shadow * max(dot(n, sundir), 0.0) * vec3(0.9, 0.8, 0.6);  // sunlight, yellowish\n    vec3 skylight = ao * max(n.z, 0.0) * vec3(0.6, 0.7, 0.8);  // skylight, blueish\n    vec3 backlit = ao * (vec3(0.2)  // background lighting\n        + vec3(0.3)*max(-dot(n,sundir),0.0)  // opposite of sunlight\n        + vec3(0.4,0.3,0.2)*max(-n.z,0.0));  // opposite of skylight, warm\n    col *= sunlight + skylight + backlit;  // sum three lights\n    float fresnel = 0.2+1.4*pow(1.0+dot(rd,n),2.0);  // faked Fresnel reflectance\n    vec3 refl = 0.8*col+vec3(0.4,0.3,0.2)*pow(max(dot(rd-2.0*dot(rd,n)*n,sundir),0.0),100.);  // reflection, blend with col\n    if (!raymarch(p+0.2*reflect(rd, n), reflect(rd, n), t0, 8.0, 1.0, 0.02))  // not occluded\n        col = mix(col, refl, fresnel);  // add reflection\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.15*max(t-0.4*t1,0.)));  // sky/fog\n    col += 0.6*vec3(0.3,0.2,0.25) * max(dot(rd, sundir), 0.);  // sun haze\n    col = 0.9*pow(col, vec3(0.75));  // brightness/gamma\n    fragColor = vec4(vec3(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 415, 472, 472, 3652], [3654, 3710, 3762, 3762, 4294], [4296, 4330, 4353, 4353, 4400], [4402, 4435, 4457, 4457, 4679], [4682, 4708, 4794, 4794, 4991], [4993, 5052, 5088, 5088, 5355], [5357, 5416, 5445, 5445, 5673], [5675, 5675, 5730, 5763, 8377]], "test": "untested"}
{"id": "NdVGW1", "name": "testbsp6", "author": "BSPCo", "description": "test", "tags": ["test"], "likes": 2, "viewed": 226, "published": 3, "date": "1631480580", "time_retrieved": "2024-07-30T19:01:51.517099", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n   float value, fft, wave;\n    value = abs(uv.x-0.5);\n    \n    // first texture row is frequency data\n\tfft  = texture( iChannel0, vec2(value,0.75) ).x; \n\t\n  \t// second texture row is the sound wave\n\twave = texture( iChannel0, vec2(value,0.95) ).x;\n\n    // Time varying pixel color\n    vec3 col = vec3( 4.0*fft*(1.0-fft)*(1.2+0.4*sin(iTime))\n                    , fft+1.3*sin(0.22*iTime)\n                    , 1.5-fft-0.4*sin(0.33*iTime) ) * fft;\n\n    // Output to screen\n    fragColor = vec4(col,5.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 117, 662]], "test": "untested"}
{"id": "NdKGW1", "name": "Oscilloscope B&W", "author": "TimArt", "description": "Source code: https://github.com/TimArt/3DAudioVisualizers", "tags": ["music", "audio", "visualizer"], "likes": 3, "viewed": 323, "published": 3, "date": "1631478777", "time_retrieved": "2024-07-30T19:01:52.450604", "image_code": "#define THICKNESS 0.015\n#define BUFFER_SIZE 512.0\n\nvoid getAmplitudeForXPos (in float xPos, out float audioAmplitude)\n{\n   // Buffer size - 1\n   float perfectSamplePosition = (BUFFER_SIZE - 1.0) * xPos / iResolution.x;\n   int leftSampleIndex = int (floor (perfectSamplePosition));\n   int rightSampleIndex = int (ceil (perfectSamplePosition));\n   \n   float audioSampleDataLeft = texelFetch(iChannel0, ivec2(leftSampleIndex,1), 0).x;\n   float audioSampleDataRight = texelFetch(iChannel0, ivec2(rightSampleIndex,1), 0).x;\n   \n   audioAmplitude = mix (audioSampleDataLeft, audioSampleDataRight, fract (perfectSamplePosition));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float y = fragCoord.y / iResolution.y;\n    float amplitude = 0.0;\n    getAmplitudeForXPos (fragCoord.x, amplitude);\n\n    float r = abs (THICKNESS / (amplitude-y));\n    float wavePower = r - abs (r * 0.2);\n    \n    //vec3 colorHue = vec3(0.2, 1.0, 1.0);\n    vec3 colorHue = vec3(1.0, 1.0, 1.0);\n\n    fragColor = vec4 (colorHue * wavePower, 1.0);\n    //fragColor.xyz += 0.1 * colorHue;\n}", "image_inputs": [{"id": 28081, "src": "https://soundcloud.com/sandybandnyc/holy-one-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 119, 141, 624], [627, 627, 682, 682, 1072]], "test": "untested"}
{"id": "NdV3Dh", "name": "peaks-ref dr2", "author": "jorge2017a2", "description": "peaks-ref dr2", "tags": ["peaksrefdr2"], "likes": 4, "viewed": 245, "published": 3, "date": "1631476937", "time_retrieved": "2024-07-30T19:01:53.329254", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\nconst float pi = 3.14159;\n\n//referencia dr2\n///https://www.shadertoy.com/view/lsVyz3\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));}\n \n \nvec3 DodecSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 5.;\n  \n  float dihedDodec = 0.5 * atan (2.);\n  vec2 csD = vec2 (cos (dihedDodec), - sin (dihedDodec));\n  vec2 csD2 = vec2 (cos (2. * dihedDodec), - sin (2. * dihedDodec));\n  \n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), vec2 (csD.x, - csD.y));\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 esferaPicos(vec3 p)\n{\t\n   vec3 res= vec3(9999.0, -1.0,-1.0);\n   \n    float d=9999.9;\n    vec3 q = DodecSym (p);\n    //q.z += 0.48;\n    q.z += 0.7;\n    \n     d = 0.9 * SmoothMin (d, PrCylDf (q, 0.05 * (0.55 + 1.5 * q.z), 0.3), 0.01);\n     \n    float sds1= sdSphere( p, 0.5 );\n    \n    res =opU3(res, vec3(d,2.0,-1.0));\n    res =opU3(res, vec3(sds1,4.0,-1.0));\n    return res;\n}    \n\n\nvec3 opScalePicos( vec3 p )\n{\n    float s=4.5; \n     vec3 res=esferaPicos(p/s);\n    res.x*=s;\n    return res;\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.y=p.y-10.0;\n    \n     p=opRep3D(p,vec3(10.0,10.,20.0));\n    vec3 esp3= opScalePicos(p );\n    res =opU3(res, esp3);\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n\n    \n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return color;\n    \n    \n}\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(5.0,10.0,-5.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   float t1=mod(iTime,2.5);\n   float t2=mod(iTime,3.5);\n   if(t1<t2)\n   rd= rotate_y(rd,  10.0*sin(iTime*0.125));\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 601, 601, 622], [623, 667, 714, 714, 741], [742, 742, 785, 785, 812], [813, 813, 861, 861, 889], [890, 928, 967, 967, 1011], [1012, 1077, 1111, 1111, 1207], [1208, 1208, 1242, 1242, 1333], [1334, 1334, 1368, 1368, 1459], [1460, 1500, 1534, 1534, 1629], [1671, 1671, 1716, 1716, 1819], [1821, 1821, 1851, 1851, 1907], [1909, 1909, 1940, 1940, 2002], [2007, 2007, 2031, 2031, 2721], [2723, 2723, 2765, 2765, 2816], [2818, 2818, 2844, 2844, 3199], [3206, 3206, 3235, 3235, 3317], [3319, 3319, 3344, 3344, 3571], [3573, 3624, 3648, 3648, 3810], [3812, 3812, 3861, 3861, 4492], [4494, 4494, 4530, 4530, 4775], [4777, 4777, 4804, 4804, 4821], [4823, 4823, 4859, 4859, 4951], [4952, 4952, 4998, 4998, 5123], [5125, 5125, 5162, 5162, 5438], [5440, 5440, 5523, 5523, 6133], [6134, 6134, 6227, 6227, 6357], [6359, 6359, 6391, 6391, 6588], [6590, 6590, 6683, 6683, 6854], [6857, 6857, 6888, 6888, 7496], [7498, 7547, 7573, 7573, 7683], [7685, 7685, 7743, 7743, 7795], [7797, 7846, 7903, 7903, 8522]], "test": "untested"}
{"id": "fsV3Dh", "name": "ufo-boxed-v2", "author": "jorge2017a2", "description": "ufo-boxed-v2", "tags": ["ufoboxedv2"], "likes": 2, "viewed": 249, "published": 3, "date": "1631476931", "time_retrieved": "2024-07-30T19:01:54.390417", "image_code": "//-----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 140.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n// fork....https://www.shadertoy.com/view/7dKGzw\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 moverObj(vec3 p, vec3 p1, vec3 p2,float tInc, float tA ,float tB)\n{   vec3 pres=p1;\n    if (tInc<tA) pres=p;\n        \n    if (tInc>=tA && tInc<tB)\n    { pres.x=mix(p1.x, p2.x, smoothstep(tA, tB,tInc));\n      pres.y=mix(p1.y, p2.y, smoothstep(tA, tB,tInc));\n      pres.z=mix(p1.z, p2.z, smoothstep(tA, tB,tInc));\n      pres=p-pres;\n    }\n    \n    if (tInc>tB)  pres=p-p2;\n    \n    return pres;\n}\n\nvec3 Nave(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXZ( p, vec2(5.0,0.25) );\n    float sdcy2= sdCylinderXZ( p-vec3(0.0,0.25,.0), vec2(5.0,0.15) );\n    float sds1= sdSphere(p-vec3(0.0,1.0,0.0), 1.0 );\n    res =opU3(res, vec3(sdcy1,3.0,-1.0));\n    res =opU3(res, vec3(sdcy2,1.0,-1.0));\n    res =opU3(res, vec3(sds1,1.0,-1.0));   \n    return res;\n}\n\nvec3 MoverNave(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n    float sds1= sdSphere(p, 1.0 );\n    float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        sdres= Nave(pnew1);\n    else if(timeMov<10.0)\n        sdres= Nave(pnew2);\n    else if(timeMov<20.0)\n        sdres= Nave(pnew3);\n    else if(timeMov<30.0)\n        sdres= Nave(pnew4);\n    res =opU3(res, sdres);\n    return res;    \n}   \n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,1.0,-1.0)); //inf\n    p.y=p.y-25.0;\n    \n    vec3 mn1= MoverNave(p);\n    res =opU3(res, mn1); \n    \n    float alto=25.0;\n    float sb1= sdBox( p-vec3(0.0,0.0,90.0), vec3(100.0,alto,100.0) );\n    float sb2= sdBox( p-vec3(0.0,1.0,-1.0), vec3(25.0,alto,10.0) );\n    float sb3= sdBox( p-vec3(20.0,1.0,0.0), vec3(15.0,alto,45.0) );\n    \n    p=rotate_y( p-vec3(43.0,1.0,70.0), radians(135.0));\n    float sb4= sdBox( p, vec3(10.0,alto,45.0) );\n    \n    \n    float dif=differenceSDF(sb1, sb2);\n    dif=differenceSDF(dif, sb3);\n    dif=differenceSDF(dif, sb4);\n    \n    res =opU3(res, vec3(dif,100.0,-1.0)); //inf\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   \n    vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm =normal; //GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    float fshadow;\n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.75;}\n        \n    \n     vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return color*fshadow;\n    \n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*1.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n    \n     \n   mObj.blnShadow=false;\n   //mObj.blnShadow=true;\n \tlight_pos1= vec3(5.0, 20.0, 10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(5.0, 30.0, -20.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,10.0,-15.0);\n   \n   ///-----------------------\n   vec3 p=-ro;\n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n     float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        ro= pnew1;\n    else if(timeMov<10.0)\n        ro= pnew2;\n    else if(timeMov<20.0)\n        ro= pnew3;\n    else if(timeMov<30.0)\n        ro=pnew4;\n   \n   ///-----------------------\n   ro= rotate_x(ro, radians(180.0));\n   ro.x=-ro.x;\n   ro.y+=15.0;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------comon\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 584, 584, 605], [606, 606, 638, 638, 722], [723, 723, 762, 762, 857], [859, 903, 950, 950, 977], [978, 978, 1021, 1021, 1048], [1049, 1049, 1097, 1097, 1125], [1127, 1152, 1186, 1186, 1282], [1283, 1283, 1317, 1317, 1408], [1409, 1409, 1443, 1443, 1534], [1535, 1575, 1609, 1609, 1704], [1705, 1745, 1817, 1817, 2144], [2146, 2146, 2165, 2165, 2521], [2523, 2523, 2547, 2547, 3352], [3357, 3357, 3382, 3382, 4132], [4134, 4185, 4209, 4209, 4371], [4373, 4373, 4422, 4422, 5089], [5092, 5146, 5182, 5182, 5427], [5428, 5483, 5510, 5510, 5527], [5529, 5529, 5565, 5565, 5657], [5658, 5658, 5704, 5704, 5829], [5831, 5831, 5868, 5868, 6144], [6146, 6146, 6229, 6229, 6982], [6983, 7038, 7087, 7087, 7330], [7331, 7365, 7458, 7458, 7588], [7589, 7630, 7662, 7662, 7859], [7861, 7913, 8006, 8006, 8324], [8327, 8327, 8358, 8358, 8966], [8968, 9017, 9043, 9043, 9153], [9155, 9155, 9213, 9213, 9265], [9267, 9267, 9324, 9324, 10660]], "test": "untested"}
{"id": "NdKGWh", "name": "XOR ripples (245 chars)", "author": "hnh", "description": "Drag the mouse to vary wavelength (x) and twist (y).\nMost reasonable settings are at bottom/center.", "tags": ["ripples", "interactive", "xor", "monochrome", "short", "golf"], "likes": 13, "viewed": 466, "published": 3, "date": "1631476327", "time_retrieved": "2024-07-30T19:01:55.152380", "image_code": "/* \nThis little shader is the result of messing around with https://www.shadertoy.com/view/NsKGRh \nand its shortened version by FabriceNeyret2.\nIt's some twist and rippling applied to a pattern generated from simple integer logic. \nIn FabriceNeyret2's https://www.shadertoy.com/view/MdlfRM you can see that the \"&\" operation\nresults in the typical XOR-pattern. \n*/\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n//*   // switch: \"//*\" -> \"/*\"\n// Shrinked, antialiased version by Xor\n\n    O-=O;\n    vec2 r,u,R = iResolution.xy,\n    m = iMouse.xy/R;\n    m = m==-m? vec2(.6,.07):m;\n    \n    for(int i = 0;i<9;)\n        u = U+vec2(i%3,i++/3)/3.,\n        r = length(u-= .5*R)+R-R,\n        u = u*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r,\n        O += sqrt(vec4(int(u) & int(u.y))/r.x)/9.;\n\n/*/\n// Minimal version (128 chars)\n// no mouse, antialiasing, gamma correction\n//  float r= length(U-= .5*iResolution.xy);\n//  U= U*sin(.05*r - 4.*iTime) + .3*r;\n//  O= vec4(int(U) & int(U.y))/r;\n\n\n// Original version\n  float r= length(U-= .5*iResolution.xy);\n  vec2 m= iMouse.xy/iResolution.xy;\n  if(m==vec2(0.)){m= vec2(.6,.07);}  // default parameters - better way?  \n  U= U*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r;\n  \n  // Variants\n  O= sqrt(vec4(int(U.x) & int(U.y))/r);\n  //O= vec4(int(U.x) & int(U.y))/r;  \n  //O= 6.*sqrt(vec4(int(U.x) & int(U.y)))/r;\n  //O= .5+log(vec4(int(U.x+r) & int(U.y+r))/r);  \n//*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 402, 473, 1391]], "test": "untested"}
{"id": "NsVGWh", "name": "vertical ribbon - Loie Fuller", "author": "morisil", "description": "Inspired by Loie Fuller \n\nhttps://en.wikipedia.org/wiki/Loie_Fuller\n", "tags": ["ribbon"], "likes": 10, "viewed": 478, "published": 3, "date": "1631469491", "time_retrieved": "2024-07-30T19:01:55.954236", "image_code": "const int   RIBBON_COUNT = 13;\nconst float RIBBON_WIDTH = .005;\nconst float RIBBON_EDGE_WIDTH = .003;\nconst float RIBBON_EDGE_START = RIBBON_WIDTH - RIBBON_EDGE_WIDTH;\nconst float SCALE_CHANGE = .9;\nconst float SCALE_CHANGE_VARIATION = .02;\nconst float SCALE_CHANGE_SPEED = 1.7;\nconst float WAVE1_PERIOD = 10.;\nconst float WAVE1_SPEED  = 3.;\nconst float WAVE1_IMPACT = .05;\nconst float WAVE2_PERIOD = 8.;\nconst float WAVE2_SPEED  = 2.5;\nconst float WAVE2_IMPACT = .2;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0);\n    for (int i = 0; i < RIBBON_COUNT; i++) {\n        st *= (\n            SCALE_CHANGE\n            + (\n                sin(iTime * SCALE_CHANGE_SPEED)\n                * SCALE_CHANGE_VARIATION\n            )\n        );\n        float dist = length(st);\n        float shapeSpace = abs(\n            st.x\n            + sin(st.y * WAVE1_PERIOD + iTime * WAVE1_SPEED) * WAVE1_IMPACT * (1.2 - uv.y)\n            + sin(st.y * WAVE2_PERIOD + iTime * WAVE2_SPEED) * WAVE2_IMPACT * (1.4 - uv.y)\n        );\n        float ribbon = smoothstep(\n            RIBBON_WIDTH,\n            RIBBON_EDGE_START,\n            shapeSpace\n        );\n        color += vec3(ribbon);\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[470, 470, 525, 525, 1382]], "test": "untested"}
{"id": "7sy3D1", "name": "custom texture test", "author": "kristoflovas", "description": "test and example of bringing in a custom texture using an array.", "tags": ["texture"], "likes": 5, "viewed": 434, "published": 3, "date": "1631466586", "time_retrieved": "2024-07-30T19:01:57.099175", "image_code": "//Based on Sébastien Hillaire's way of bringing in a custom texture, seen in this shader (buffer c):https://www.shadertoy.com/view/7dVGWR\n//This is a workaround for not having an option to upload a custom texture, and its not an ideal way by any means.\n//The arrays were generated using a script I made for it, and the output of that is simply copy-pasted into here (buffer a).\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n//make square \nfloat ratio = iResolution.x/iResolution.y;\nuv.x*=ratio;\n\n\nvec3 tex =pow(texture(iChannel0,uv).xyz,vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(tex,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Based on Sébastien Hillaire's way of bringing in a custom texture, seen in this shader (buffer c):https://www.shadertoy.com/view/7dVGWR\n//This is a workaround for not having an option to upload a custom texture, and its not an ideal way by any means.\n//The arrays were generated using a script I made for it, and the output of that is simply copy-pasted into here.\n//test texture 2 and 3 are from here:\n//https://opengameart.org/content/death-soldier-32x32\n//https://opengameart.org/content/32x32-scimitar\n//uncomment the one you want to see and comment out the other ones to change the texture\n\n\n\nconst int texres = 32;\n\n\n//test texture 1 \n//const vec3 image[1024] = vec3[1024](vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.002441,1.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.034424,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0));\n\n//test texture 2\n//const vec3 image[1024] = vec3[1024](vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.992188,0.992676,0.992676),vec3(0.969238,0.970215,0.97168),vec3(0.969238,0.970215,0.97168),vec3(0.980957,0.981445,0.981934),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.790039,0.800293),vec3(0.02121,0.049591,0.101013),vec3(0.041382,0.084595,0.144897),vec3(0.399658,0.429443,0.464355),vec3(0.907715,0.910156,0.914551),vec3(0.95752,0.958496,0.960938),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.790039,0.800293),vec3(0.073059,0.147339,0.240845),vec3(0.292725,0.527832,0.717285),vec3(0.290771,0.494141,0.602539),vec3(0.118713,0.161743,0.208618),vec3(0.524414,0.533691,0.55127),vec3(0.846191,0.850098,0.857422),vec3(0.948242,0.949219,0.95166),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.790039,0.800293),vec3(0.073059,0.147339,0.240845),vec3(0.292725,0.527832,0.717285),vec3(0.433594,0.730469,0.871094),vec3(0.678711,0.825684,0.871094),vec3(0.567871,0.563965,0.544434),vec3(0.098694,0.118042,0.154907),vec3(0.661621,0.669922,0.686035),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.790039,0.800293),vec3(0.073059,0.147339,0.240845),vec3(0.292725,0.527832,0.717285),vec3(0.433594,0.730469,0.871094),vec3(0.678711,0.825684,0.871094),vec3(0.960938,0.9375,0.871094),vec3(0.399658,0.404053,0.405029),vec3(0.661621,0.669922,0.686035),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.790039,0.800293),vec3(0.073059,0.147339,0.240845),vec3(0.292725,0.527832,0.717285),vec3(0.433594,0.730469,0.871094),vec3(0.678711,0.825684,0.871094),vec3(0.960938,0.9375,0.871094),vec3(0.399658,0.404053,0.405029),vec3(0.661621,0.669922,0.686035),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.873047,0.875977,0.882324),vec3(0.338135,0.38501,0.445557),vec3(0.208496,0.382813,0.538086),vec3(0.381592,0.655762,0.814453),vec3(0.577148,0.785156,0.871094),vec3(0.859375,0.896973,0.871094),vec3(0.628418,0.621582,0.595215),vec3(0.533203,0.541016,0.552734),vec3(0.888672,0.891113,0.896484),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.723145,0.72998,0.743164),vec3(0.085815,0.171387,0.275391),vec3(0.306152,0.547363,0.731934),vec3(0.433594,0.730469,0.871094),vec3(0.711914,0.838867,0.871094),vec3(0.960938,0.9375,0.871094),vec3(0.340576,0.3479,0.355957),vec3(0.723145,0.72998,0.743164),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.723145,0.72998,0.743164),vec3(0.085815,0.171387,0.275391),vec3(0.259766,0.480957,0.681641),vec3(0.373291,0.643555,0.805176),vec3(0.711914,0.838867,0.871094),vec3(0.960938,0.9375,0.871094),vec3(0.340576,0.3479,0.355957),vec3(0.723145,0.72998,0.743164),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.888672,0.891113,0.896484),vec3(0.428711,0.468262,0.52002),vec3(0.147949,0.288574,0.443115),vec3(0.31958,0.566406,0.746582),vec3(0.543945,0.771973,0.871094),vec3(0.83252,0.88623,0.871094),vec3(0.709961,0.69873,0.662598),vec3(0.462891,0.471436,0.484863),vec3(0.873047,0.875977,0.882324),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.661621,0.669922,0.686035),vec3(0.098572,0.195435,0.309814),vec3(0.31958,0.566406,0.746582),vec3(0.433594,0.730469,0.871094),vec3(0.745117,0.852051,0.871094),vec3(0.960938,0.9375,0.871094),vec3(0.281494,0.291748,0.306885),vec3(0.784668,0.790039,0.800293),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.905762,0.908203,0.912598),vec3(0.460205,0.494141,0.540039),vec3(0.169556,0.316406,0.45752),vec3(0.361084,0.625977,0.791992),vec3(0.518066,0.761719,0.871094),vec3(0.829102,0.885254,0.871094),vec3(0.770996,0.756836,0.713379),vec3(0.382324,0.393311,0.411377),vec3(0.890625,0.893066,0.898438),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.600098,0.609863,0.628906),vec3(0.111328,0.219482,0.344238),vec3(0.333008,0.585938,0.76123),vec3(0.433594,0.730469,0.871094),vec3(0.505371,0.756836,0.871094),vec3(0.84375,0.891113,0.871094),vec3(0.222412,0.235596,0.257813),vec3(0.846191,0.850098,0.857422),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.936523,0.937988,0.940918),vec3(0.470703,0.496582,0.53418),vec3(0.15625,0.295898,0.437988),vec3(0.360107,0.625,0.791016),vec3(0.433594,0.730469,0.871094),vec3(0.48877,0.75,0.871094),vec3(0.746094,0.787598,0.774414),vec3(0.268066,0.282471,0.307861),vec3(0.921387,0.922852,0.926758),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.95752,0.958496,0.960938),vec3(0.445068,0.467773,0.50293),vec3(0.155884,0.298096,0.447266),vec3(0.366455,0.634277,0.797852),vec3(0.433594,0.730469,0.871094),vec3(0.469238,0.742188,0.871094),vec3(0.8125,0.837891,0.80957),vec3(0.181519,0.198853,0.231689),vec3(0.973145,0.973633,0.975098),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.953613,0.624023,0.587402),vec3(0.953613,0.624023,0.587402),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.984863,0.984863,0.98584),vec3(0.407959,0.425781,0.457275),vec3(0.155518,0.300781,0.458496),vec3(0.374756,0.645996,0.807129),vec3(0.433594,0.730469,0.871094),vec3(0.444336,0.732422,0.871094),vec3(0.887207,0.894043,0.849609),vec3(0.075928,0.097168,0.138916),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.682617,0.611816,0.605469),vec3(0.533691,0.078613,0.030273),vec3(0.892578,0.130981,0.046387),vec3(0.957031,0.651855,0.617676),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.373291,0.388184,0.417969),vec3(0.164551,0.312744,0.473389),vec3(0.379883,0.652832,0.810059),vec3(0.432861,0.729492,0.870117),vec3(0.433594,0.730469,0.871094),vec3(0.927734,0.924316,0.871094),vec3(0.075928,0.097168,0.138916),vec3(0.973145,0.973633,0.975098),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.990723,0.988281,0.988281),vec3(0.666992,0.583008,0.574707),vec3(0.533691,0.069397,0.01944),vec3(0.894531,0.119141,0.034424),vec3(0.955566,0.641602,0.606445),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.35791,0.373047,0.403809),vec3(0.178467,0.328613,0.490479),vec3(0.380127,0.652344,0.807617),vec3(0.431885,0.728027,0.869141),vec3(0.433594,0.730469,0.871094),vec3(0.887207,0.894043,0.849609),vec3(0.181519,0.198853,0.231689),vec3(0.92334,0.924805,0.928711),vec3(1.0,1.0,1.0),vec3(0.986816,0.974121,0.972656),vec3(0.718262,0.607422,0.596191),vec3(0.566406,0.099304,0.02919),vec3(0.94873,0.157593,0.046631),vec3(0.875488,0.115601,0.033142),vec3(0.940918,0.638672,0.605469),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.352051,0.367432,0.398438),vec3(0.185425,0.336426,0.499023),vec3(0.380127,0.652344,0.808105),vec3(0.432373,0.728516,0.869629),vec3(0.443115,0.731934,0.871094),vec3(0.80957,0.835449,0.808105),vec3(0.268066,0.282471,0.307861),vec3(0.878906,0.881836,0.887695),vec3(0.880859,0.734863,0.722168),vec3(0.715332,0.101868,0.026962),vec3(0.98291,0.180176,0.053955),vec3(0.912598,0.146484,0.042816),vec3(0.705078,0.154785,0.100464),vec3(0.834473,0.674316,0.660645),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.352051,0.367432,0.398438),vec3(0.180786,0.331055,0.493408),vec3(0.379883,0.652832,0.810547),vec3(0.433594,0.730469,0.871094),vec3(0.468018,0.741699,0.871094),vec3(0.746094,0.787598,0.774414),vec3(0.38623,0.358887,0.371338),vec3(0.952148,0.611816,0.574219),vec3(0.894531,0.119141,0.034424),vec3(0.861816,0.113037,0.032196),vec3(0.675781,0.078674,0.019592),vec3(0.772949,0.553223,0.535156),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.359863,0.375,0.405518),vec3(0.16687,0.31543,0.476074),vec3(0.375244,0.646484,0.807617),vec3(0.433594,0.730469,0.871094),vec3(0.509766,0.722656,0.833496),vec3(0.930176,0.577148,0.501953),vec3(0.864746,0.113586,0.032379),vec3(0.789063,0.09967,0.027283),vec3(0.680176,0.079468,0.019897),vec3(0.579102,0.171631,0.137695),vec3(0.836426,0.677734,0.664551),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.375244,0.390137,0.419678),vec3(0.155518,0.300537,0.457764),vec3(0.38208,0.614258,0.770508),vec3(0.639648,0.456055,0.495361),vec3(0.866211,0.113831,0.032501),vec3(0.696289,0.082458,0.020981),vec3(0.519531,0.049805,0.009155),vec3(0.583008,0.179077,0.145386),vec3(0.830566,0.666992,0.65332),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.413818,0.425781,0.456299),vec3(0.392578,0.257568,0.349121),vec3(0.871094,0.114807,0.032837),vec3(0.693848,0.082031,0.020844),vec3(0.519531,0.049805,0.009155),vec3(0.474609,0.045776,0.008598),vec3(0.634766,0.426514,0.408936),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.765625,0.538574,0.519531),vec3(0.538574,0.053314,0.010323),vec3(0.687988,0.080933,0.020447),vec3(0.519531,0.049805,0.009155),vec3(0.477051,0.046021,0.008629),vec3(0.421875,0.046478,0.011177),vec3(0.561035,0.255371,0.223511),vec3(0.798828,0.753906,0.75),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.750488,0.508789,0.488525),vec3(0.71875,0.08667,0.022522),vec3(0.71875,0.08667,0.022522),vec3(0.687988,0.080933,0.020447),vec3(0.572266,0.158569,0.124084),vec3(0.730469,0.549316,0.533691),vec3(0.586426,0.374023,0.352783),vec3(0.561035,0.084595,0.024338),vec3(0.597656,0.279297,0.234131),vec3(0.798828,0.753906,0.75),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.73877,0.486328,0.465088),vec3(0.736816,0.09845,0.032898),vec3(0.955566,0.162109,0.048096),vec3(0.929199,0.154297,0.045441),vec3(0.689941,0.1604,0.108887),vec3(0.84668,0.698242,0.686035),vec3(1.0,1.0,1.0),vec3(0.886719,0.861816,0.859375),vec3(0.610352,0.389893,0.360596),vec3(0.591309,0.104614,0.030838),vec3(0.591309,0.274902,0.22998),vec3(0.805176,0.761719,0.757813),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.784668,0.178101,0.114807),vec3(0.891113,0.118469,0.03418),vec3(0.98291,0.187744,0.056488),vec3(0.504395,0.129639,0.07782),vec3(0.858887,0.722656,0.711426),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.888184,0.863281,0.861328),vec3(0.606934,0.387695,0.358398),vec3(0.385742,0.050934,0.012749),vec3(0.40625,0.219604,0.205078),vec3(0.471924,0.354004,0.34375),vec3(0.850586,0.817383,0.814453),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.900879,0.199951,0.12207),vec3(0.894531,0.119141,0.034424),vec3(0.431152,0.083435,0.036346),vec3(0.793945,0.748047,0.744141),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.894531,0.871094,0.869141),vec3(0.493164,0.349365,0.337891),vec3(0.559082,0.094482,0.027222),vec3(0.722168,0.109314,0.031769),vec3(0.49707,0.234131,0.20752),vec3(0.872559,0.844238,0.841797),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.900879,0.199951,0.12207),vec3(0.894531,0.119141,0.034424),vec3(0.220459,0.046387,0.03125),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.572754,0.477051,0.46875),vec3(0.622559,0.088501,0.025345),vec3(0.898926,0.124634,0.03598),vec3(0.394775,0.048248,0.013367),vec3(0.824219,0.784668,0.78125),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.984375,0.874023,0.861816),vec3(0.893555,0.139648,0.055847),vec3(0.878906,0.852051,0.849609),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.572754,0.477051,0.46875),vec3(0.262939,0.029556,0.00782),vec3(0.307861,0.035919,0.009705),vec3(0.715332,0.618164,0.608887),vec3(0.973145,0.967285,0.966797),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.990234,0.920898,0.913086),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.958984,0.950195,0.949219),vec3(0.924805,0.907715,0.90625),vec3(0.924805,0.907715,0.90625),vec3(0.978027,0.973145,0.972656),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\n\n//test texture 3\nconst vec3 image[1024] = vec3[1024](vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.095215,0.095215,0.095215),vec3(0.095215,0.095215,0.095215),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.057617,0.057617,0.057617),vec3(0.057617,0.057617,0.057617),vec3(0.095215,0.095215,0.095215),vec3(0.095215,0.095215,0.095215),vec3(0.095215,0.095215,0.095215),vec3(0.095215,0.095215,0.095215),vec3(0.095215,0.095215,0.095215),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.052734,0.038086,0.039551),vec3(0.057617,0.057617,0.057617),vec3(0.052734,0.038086,0.039551),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.095215,0.095215,0.095215),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.052734,0.038086,0.039551),vec3(0.052734,0.038086,0.039551),vec3(0.052734,0.038086,0.039551),vec3(0.0,0.0,0.0),vec3(0.546875,0.003357,0.003357),vec3(0.05957,0.05957,0.05957),vec3(0.05957,0.05957,0.05957),vec3(0.546875,0.003357,0.003357),vec3(0.05957,0.05957,0.05957),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.18457,0.078125,0.039551),vec3(0.18457,0.078125,0.039551),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.074219,0.074219,0.074219),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.141602,0.061035,0.033203),vec3(0.141602,0.061035,0.033203),vec3(0.086426,0.046631,0.039551),vec3(0.086426,0.046631,0.039551),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.074219,0.074219,0.074219),vec3(0.074219,0.074219,0.074219),vec3(0.0,0.0,0.0),vec3(0.09082,0.09082,0.09082),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.086426,0.046631,0.039551),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.057617,0.057617,0.057617),vec3(0.074219,0.074219,0.074219),vec3(0.074219,0.074219,0.074219),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.18457,0.078125,0.039551),vec3(0.141602,0.061035,0.033203),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.177734,0.177734,0.177734),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.074219,0.074219,0.074219),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.558594,0.539063,0.546875),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.18457,0.078125,0.039551),vec3(0.141602,0.061035,0.033203),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.132813,0.132813,0.132813),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.09082,0.269531,0.078125),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.141602,0.061035,0.033203),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.046631,0.150391,0.054688),vec3(0.070313,0.174805,0.070313),vec3(0.09082,0.269531,0.078125),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.18457,0.078125,0.039551),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.046631,0.150391,0.054688),vec3(0.070313,0.174805,0.070313),vec3(0.070313,0.174805,0.070313),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.141602,0.061035,0.033203),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.125,0.086426,0.088867),vec3(0.177734,0.177734,0.177734),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.628906,0.417969,0.034424),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.086426,0.046631,0.039551),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.953125,0.019409,0.006531),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.445313,0.322266,0.038086),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.097656,0.05957,0.068359),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.068359,0.036865,0.031982),vec3(0.0,0.0,0.0),vec3(0.337891,0.337891,0.337891),vec3(0.433594,0.347656,0.341797),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.226563,0.048096,0.064941),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.097656,0.05957,0.068359),vec3(0.0,0.0,0.0),vec3(0.068359,0.036865,0.031982),vec3(0.068359,0.036865,0.031982),vec3(0.0,0.0,0.0),vec3(0.337891,0.337891,0.337891),vec3(0.337891,0.337891,0.337891),vec3(0.337891,0.337891,0.337891),vec3(0.433594,0.347656,0.341797),vec3(0.433594,0.347656,0.341797),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,0.402344,0.054688),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.660156,0.061035,0.02417),vec3(0.451172,0.05127,0.033203),vec3(0.226563,0.048096,0.064941),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.304688,0.223633,0.230469),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.433594,0.033203,0.048096),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.337891,0.337891,0.337891),vec3(0.337891,0.337891,0.337891),vec3(0.337891,0.337891,0.337891),vec3(0.337891,0.337891,0.337891),vec3(0.433594,0.347656,0.341797),vec3(0.433594,0.347656,0.341797),vec3(0.433594,0.347656,0.341797),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,0.871094,0.287109),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.660156,0.061035,0.02417),vec3(0.304688,0.223633,0.230469),vec3(0.226563,0.048096,0.064941),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.433594,0.033203,0.048096),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.068359,0.036865,0.031982),vec3(0.068359,0.036865,0.031982),vec3(0.0,0.0,0.0),vec3(0.433594,0.347656,0.341797),vec3(0.242188,0.144531,0.171875),vec3(0.043701,0.035645,0.054688),vec3(1.0,0.929688,0.597656),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.111816,0.008545,0.031982),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.287109,0.019409,0.043701),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.111816,0.008545,0.031982),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.012268,0.010315,0.014404),vec3(0.0,0.0,0.0),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.111816,0.008545,0.031982),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.014404,0.011597,0.0177),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.433594,0.033203,0.048096),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.111816,0.008545,0.031982),vec3(0.162109,0.009705,0.034424),vec3(0.132813,0.132813,0.132813),vec3(0.177734,0.177734,0.177734),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.014404,0.011597,0.0177),vec3(0.014404,0.011597,0.0177),vec3(0.0,0.0,0.0),vec3(0.433594,0.033203,0.048096),vec3(0.074219,0.074219,0.074219),vec3(0.114258,0.114258,0.114258),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.162109,0.009705,0.034424),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.337891,0.337891,0.337891),vec3(0.386719,0.386719,0.386719),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.014404,0.011597,0.0177),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.386719,0.386719,0.386719),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.111816,0.008545,0.031982),vec3(0.162109,0.009705,0.034424),vec3(0.0,0.0,0.0),vec3(0.304688,0.223633,0.230469),vec3(0.304688,0.223633,0.230469),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.066406,0.041016,0.048096),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.304688,0.223633,0.230469),vec3(0.337891,0.337891,0.337891),vec3(0.386719,0.386719,0.386719),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.097656,0.05957,0.068359),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.162109,0.009705,0.034424),vec3(0.114258,0.114258,0.114258),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.433594,0.033203,0.048096),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.304688,0.223633,0.230469),vec3(0.0,0.0,0.0),vec3(0.014404,0.011597,0.0177),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.111816,0.008545,0.031982),vec3(0.111816,0.008545,0.031982),vec3(0.162109,0.009705,0.034424),vec3(0.114258,0.114258,0.114258),vec3(0.433594,0.033203,0.048096),vec3(0.433594,0.033203,0.048096),vec3(0.287109,0.019409,0.043701),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.114258,0.114258,0.114258),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.097656,0.05957,0.068359),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.014404,0.011597,0.0177),vec3(0.0,0.0,0.0),vec3(0.162109,0.009705,0.034424),vec3(0.287109,0.019409,0.043701),vec3(0.287109,0.019409,0.043701),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.0,0.0,0.0),vec3(0.074219,0.074219,0.074219),vec3(0.074219,0.074219,0.074219),vec3(0.114258,0.114258,0.114258),vec3(0.0,0.0,0.0),vec3(0.084473,0.05957,0.061035),vec3(0.066406,0.041016,0.048096),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.097656,0.05957,0.068359),vec3(0.125,0.086426,0.088867),vec3(0.125,0.086426,0.088867),vec3(0.132813,0.132813,0.132813),vec3(0.132813,0.132813,0.132813),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.0,0.0,0.0),vec3(0.068359,0.048096,0.049805),vec3(0.0,0.0,0.0),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.0,0.0,0.0),vec3(0.068359,0.048096,0.049805),vec3(0.074219,0.074219,0.074219),vec3(0.0,0.0,0.0),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.066406,0.041016,0.048096),vec3(0.0,0.0,0.0),vec3(0.054688,0.034424,0.039551),vec3(0.0,0.0,0.0),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.0,0.0,0.0),vec3(0.054688,0.034424,0.039551),vec3(0.0,0.0,0.0),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.084473,0.05957,0.061035),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\n\n//This can be used to look up the whole array at once, with the values laid out the same as they were in the original texture\nint TwoDtoOneD(vec2 index, float res)\n{\nvec2 fi = floor(index*res);\nfloat lookupids= fi.x+fi.y*res;\nreturn int(lookupids);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//0-1 uv\nvec2 uv = fragCoord/iResolution.xy;\n\n//flip v\nuv.y=1.-uv.y;\n\n//construct the lookup indices\nint indices =TwoDtoOneD(uv,float(texres));\n\n//sample the array\nvec3 mytexture = image[indices];\n\n    fragColor = vec4(mytexture,0.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sy3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 380, 437, 487, 713]], "test": "untested"}
{"id": "7dy3Wh", "name": "star sdf", "author": "mdb", "description": "a star sdf", "tags": ["sdf", "star"], "likes": 5, "viewed": 402, "published": 3, "date": "1631458754", "time_retrieved": "2024-07-30T19:01:57.925964", "image_code": "#define PI 3.14159\n\n\nfloat star(vec2 p, float radius, float inset, float n){\n    float teta = 2.0 * PI / n;\n    mat2x2 rot1 = mat2x2(cos(teta), sin(teta), -sin(teta), cos(teta));\n    \n    vec2 p1 = vec2(0.0, radius);\n    vec2 p2 = vec2(sin(teta*0.5), cos(teta*0.5))*radius*inset;\n    \n    float tetaP = PI + atan(-p.x, -p.y);\n    tetaP = mod(tetaP + PI / n, 2.0 * PI);\n    \n    for(float i = teta; i < tetaP; i+= teta)\n         p = rot1 *p;\n    \n    p.x = abs(p.x);\n    \n    // sdf segment\n    vec2 ba = p2-p1;\n    vec2 pa = p - p1;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length(pa-h*ba);\n    d *= sign(dot(p - p1, -vec2(ba.y, -ba.x)));\n    return d;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime*0.4;\n    \n    float radius = 0.7;\n    float innerRadiusScale = 0.5 + 0.4 * cos(2.0 * PI * t);\n    float sides = 2.0 + floor(8.0 * fract(t/8.0));\n    \n    float d = star(uv, radius, innerRadiusScale, sides);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    d = star(m, radius, innerRadiusScale, sides);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(uv-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(uv-m)-0.015));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 76, 76, 683], [686, 686, 742, 792, 1702]], "test": "untested"}
{"id": "7dG3Wh", "name": "Triangle sampler", "author": "Masterchef365", "description": "Samples an image using trianlges. Hi avali!", "tags": ["triangle", "sampler"], "likes": 1, "viewed": 263, "published": 3, "date": "1631430357", "time_retrieved": "2024-07-30T19:01:58.776690", "image_code": "vec2 tri_quantize(vec2 p, float divs) {\n    const float pi = 3.141592;\n    const float a = 0.;\n    const float b = 2.*pi/3.;\n    const float c = 4.*pi/3.;\n    \n    // 3 vectors placed such that drawing lines \n    // between their tips would form an equilateral triangle\n    vec3 g = vec3(\n        p.x * cos(a) + p.y * sin(a),\n        p.x * cos(b) + p.y * sin(b),\n        p.x * cos(c) + p.y * sin(c)\n    );\n    \n    // Each component of one_if_neg is one if the corresponding component of g is negative\n    ivec3 one_if_neg = ivec3(lessThan(g, vec3(0.))); \n    \n    // Quantize each of these components, and avoid repeating zero \n    // since abs(-.5) = 0 and abs(.5).\n    g = vec3(ivec3(g * divs) - one_if_neg) / divs;\n    \n    // Now imagine we pick two of the vectors; the difference \n    // between them will be perpendicular to the remaining vector.\n    vec2 q = vec2(g.x, (g.y - g.z) / 2.);\n    \n    return q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float anim = fract(iTime / 10.);\n    float divs = anim * anim * 0.1 + 0.001;\n    vec2 t = tri_quantize(fragCoord, divs);\n    t /= iResolution.xy;\n    \n    vec3 color = texture(iChannel0, t).rgb;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dG3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 916], [919, 919, 976, 976, 1235]], "test": "untested"}
{"id": "fsG3Wh", "name": "random + truchet tiles", "author": "prishainabox", "description": "Learning about how to create pseudo-random numbers from https://thebookofshaders.com/10/", "tags": ["random"], "likes": 1, "viewed": 39, "published": 3, "date": "1631411677", "time_retrieved": "2024-07-30T19:01:59.667308", "image_code": "float random(in vec2 v) {\n    return fract(65465.1327854 * sin(dot(v, vec2(73.93422, 12.5165))));\n}\n\nvec3 tile(in vec2 pt) {\n\n    vec2 f = fract(pt);\n    float n = random(floor(pt));\n    if (n > 0.75) {\n        f = 1.0 - f;\n    } else if (n > 0.5) {\n        f = 1.0 - vec2(1.0 - f.x, f.y);\n    } else if (n > 0.25) {\n        f = vec2(1.0 - f.x, f.y);\n    }\n    \n    // circles\n    float l1 = length(f);\n    float l2 = length(1.0-f);\n    vec3 clr = vec3(step(l1, 0.6) - step(l1, 0.4) + step(l2, 0.6) - step(l2, 0.4));\n    \n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 pt = 15.0 * uv;\n    \n    vec3 clr = tile(pt);\n    clr += 2.0 * vec3(0.03, 0.02, 0.1) * tile(pt + 0.3);\n    clr += 0.5 * vec3(0.5, 0.05, 0.04) * tile(vec2(pt.x - 0.2, pt.y - 0.5));\n    clr.y -= 0.9 * tile(pt - 0.05).y;\n    clr.x += 0.7 * tile(pt + 0.15).x;\n    \n    vec2 shape = abs(uv) - vec2(0.5, 0.5);\n    shape = shape + 0.05 * sin(20.0 * atan(shape.y, shape.x));\n    if (length(shape) < 0.3 && length(shape) > 0.15) {\n        clr += 10.0 * (tile(uv * pt) + 0.1) * vec3(0.1, 0.3, 5.5);\n    }\n    \n    clr = pow(clr, vec3(0.4545)); \n    \n    // Output to screen\n    fragColor = vec4(clr, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 99], [101, 101, 124, 124, 539], [541, 541, 598, 635, 1330]], "test": "untested"}
{"id": "Ndt3Dl", "name": "simple truchet pattern #1", "author": "pugbyte", "description": "Truchet tiling with a simple pattern.", "tags": ["2d", "truchet", "tiles"], "likes": 6, "viewed": 282, "published": 3, "date": "1631409530", "time_retrieved": "2024-07-30T19:02:00.528007", "image_code": "#define PI 3.14159\n#define TAU (2.*PI)\n\nvec3 blue = vec3(0.000,0.631,0.616);\nvec3 white = vec3(1.000,0.973,0.898);\nvec3 yellow = vec3(1.000,0.702,0.267);\nvec3 red = vec3(0.878,0.365,0.365);\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat circle(vec2 st, vec2 center, float radius) {\n    return 1.0 - step(radius, length(st - center));\n}\n\nfloat circleOutline(vec2 st, vec2 center, float radius, float thickness) {\n    float distToEdge = abs(radius - length(st - center));\n    return 1.0 - step(thickness, distToEdge);\n}\n\nfloat cornerCircle(vec2 st, float radius) {\n    float corner = 0.;\n    corner += circle(st, vec2(-.5,.5), radius);\n    corner += circle(st, vec2(.5,.5), radius);\n    corner += circle(st, vec2(-.5,-.5), radius);\n    corner += circle(st, vec2(.5,-.5), radius);\n    return corner;\n}\n\nfloat line(float p, float mi, float mx) {\n    return step(mi, p) * (1.0-step(mx, p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xx;\n    \n    // rotate\n    //uv *= rot(-iTime*0.05);\n    uv *= rot(PI*0.12);\n    // zoom\n    //uv *= mix(0.7, 1.3, 0.5 * 0.5 * sin((iTime+PI)*5.));\n    uv *= 1.4;\n    // pan\n    uv += vec2(iTime*0.07);\n    \n    // Repitition\n    uv *= 5.0;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    \n    vec3 col = red;\n    \n    float stripe_str = 0.8;\n    float stripes = ceil(sin(gv.x*PI*60.));\n    col = mix(col, stripe_str*red, stripes);\n    \n    // Randomly rotate by some multiple of PI/2\n    //float n = hash12(id+iTime*0.00001);\n    float n = hash12(id);\n    \n    n *= TAU;\n    n = floor(n / (PI/2.)) * (PI/2.);\n    \n    gv -= 0.5;\n    gv *= rot(n);\n    \n    float off = 0.5 - 0.5 * sin(iTime);\n    off *= 0.4;\n    off = 0.287;\n    \n    col = mix(col, white, line(gv.x - gv.y, off + -1., off + -.9));\n    col = mix(col, yellow, line(gv.x - gv.y, off + -.87, off + -.7));\n    col = mix(col, blue, line(gv.x - gv.y, off + -.67, off + -.6));\n    \n    col = mix(col, blue, line(gv.x - gv.y, .9 - off, 1. - off));\n    col = mix(col, white, line(gv.x - gv.y, .7 - off, .87 - off));\n    col = mix(col, blue, line(gv.x - gv.y, .6 - off, .67 - off));\n    \n    float osc = 0.5 + 0.5 * sin(iTime*5.0);\n    \n    // center circle\n    col = mix(col, white, circle(gv, vec2(0), osc*0.1));\n    vec3 yellowstripes = mix(yellow, stripe_str*yellow, stripes);\n    col = mix(col, yellowstripes, circle(gv, vec2(0), osc*0.05));\n    \n    // corner circles\n    col = mix(col, white, cornerCircle(gv, (1.-osc)*0.1));\n    vec3 bluestripes = mix(blue, stripe_str*blue, stripes);\n    col = mix(col, bluestripes, cornerCircle(gv, (1.-osc)*0.05));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 210, 210, 286], [288, 288, 338, 338, 392], [394, 394, 468, 468, 574], [576, 576, 619, 619, 855], [857, 857, 898, 898, 944], [946, 946, 1003, 1003, 2710]], "test": "untested"}
{"id": "ssV3Dz", "name": "simple truchet pattern #2", "author": "pugbyte", "description": "Truchet tiling with a simple pattern.", "tags": ["2d", "truchet", "tiles"], "likes": 6, "viewed": 315, "published": 3, "date": "1631409271", "time_retrieved": "2024-07-30T19:02:01.394689", "image_code": "#define PI 3.14159\n#define TAU (2.*PI)\n\nvec3 white = vec3(0.867,0.867,0.867);\nvec3 black = vec3(0.133,0.157,0.192);\nvec3 blue = vec3(0.188,0.278,0.369);\nvec3 red = vec3(0.941,0.329,0.329);\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n/*\nfloat square(vec2 st, vec2 center, float halfWidth) {\n    vec2 p = st - center;\n    return step(p.x, halfWidth)\n        * step(-halfWidth, p.x)\n        * step(p.y, halfWidth)\n        * step(-halfWidth,p.y);\n}\n*/\n\n// distance field... sooo much easier to work with omg...\nfloat square(vec2 st, vec2 center, float halfWidth) {\n    vec2 p = st - center;\n    vec2 q = abs(p) - vec2(halfWidth);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 circlePolarCoords(vec2 st, vec2 center, float radius) {\n    st = st - center;\n    float angle = atan(st.x, st.y);\n    return vec2(angle/TAU, length(st));\n}\n\nfloat circleOutline(vec2 st, vec2 center, float radius, float thickness) {\n    float distToEdge = abs(radius - length(st - center));\n    //return 1.0 - step(thickness, distToEdge);\n    return 1.0 - smoothstep(thickness, thickness+0.002, distToEdge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ma = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / vec2(ma, ma);\n    \n    // rotate\n    //uv *= rot(-iTime*0.05);\n    // zoom\n    //uv *= mix(0.7, 1.3, 0.5 * 0.5 * sin((iTime+PI)*0.1));\n    uv *= .7;\n    // pan\n    uv += vec2(iTime*0.02,-iTime*0.02);\n    \n    // Repitition\n    uv *= 5.0;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    vec3 col = blue;\n    \n    /*\n     * Stripes used to give a bit more texture.\n     */\n    float stripe_str = 0.6;\n    float stripesX = ceil(sin(gv.x*PI*60.));\n    float stripesY = ceil(sin(gv.y*PI*60.));\n    col = mix(col, stripe_str*blue, stripesX);\n    \n    // Recessed vignette\n    vec2 uv0 = fragCoord / iResolution.xy;\n    float d = square(uv0-.5, vec2(0), .5);\n    col = mix(col*0.8, col, smoothstep(0., .07, abs(d)) );\n    \n    /*\n     * Truchet tiles\n     */\n    float n = hash12(id);\n    // Randomly rotate by some multiple of PI/2\n    //float n = hash12(id+iTime*0.00001);\n    \n    n *= TAU;\n    n = floor(n / (PI/2.)) * (PI/2.);\n    \n    gv -= 0.5;\n    gv *= rot(n);\n     \n    vec3 redstripes = mix(red, 0.6*red, stripesY);\n    //col = mix(col, redstripes, circle(gv, vec2(-.5,.5), 0.5));\n    \n    // Shading\n    col = mix(col, col*0.8, circleOutline(gv, vec2(-.5,.5), 0.5, 0.13));\n    col = mix(col, col*0.8, circleOutline(gv, vec2(.5,-.5), 0.5, 0.13));\n    \n    col = mix(col, white, circleOutline(gv, vec2(-.5,.5), 0.5, 0.1));\n    col = mix(col, white, circleOutline(gv, vec2(.5,-.5), 0.5, 0.1));\n    \n    vec3 balackstripes = mix(black, stripe_str*black, stripesY);\n    col = mix(col, balackstripes, circleOutline(gv, vec2(-.5,.5), 0.5, 0.05));\n    col = mix(col, balackstripes, circleOutline(gv, vec2(.5,-.5), 0.5, 0.05));\n    \n    /*\n     * Spinning things\n     */\n    vec2 cid = floor(uv+vec2(.5));\n    vec2 cv = fract(uv+vec2(.5));\n    float cn = hash12(cid);\n    float dir = sign(cn-0.5);\n    \n    if (cn > 0.2 && cn < 0.8) {\n        /*\n         * Spinny circle\n         */\n        vec2 pv = circlePolarCoords(cv, vec2(.5), 0.2);\n        float discAngle = fract(pv.x + dir*iTime * 0.15);\n        float concentric = ceil(sin(pv.y*200.));\n        concentric = mix(1.5, 1.6, step(0., sin(pv.y*200.)));\n        //concentric = 1.3;\n        vec3 disc = white * concentric;\n        disc = mix(disc, red * concentric, smoothstep(discAngle, discAngle+.002, .75));\n        disc = mix(disc, blue * concentric, smoothstep(discAngle, discAngle+.002, .5));\n        disc = mix(disc, black * concentric, smoothstep(discAngle, discAngle+.002, .25));\n\n        // wheel rim\n        col = mix(col, col*0.8, smoothstep(pv.y, pv.y+.002, 0.27));\n        col = mix(col, white, smoothstep(pv.y, pv.y+.002, 0.24));\n        // wheel shading\n        disc = mix(disc, disc*.2, pv.y*4.);\n        // wheel\n        col = mix(col, disc, smoothstep(pv.y, pv.y+.002, 0.2));\n    } else {\n        /*\n         * Spinny square\n         */\n        vec2 center = vec2(.5);\n        vec2 bv = cv - center;\n        bv *= rot(dir*iTime*5.8);\n        \n        float d = square(bv, vec2(0), 0.14);\n        \n        float lines = mix(1.1, 1.2, step(0., sin(abs(d)*TAU * 30.)));\n        vec3 box = white;\n        box = mix(box, black * lines, smoothstep(bv.x, bv.x+.002, abs(bv.y)));\n        box = mix(box, red * lines, smoothstep(abs(bv.x), abs(bv.x)+.002, bv.y));\n        box = mix(box, blue * lines, smoothstep(abs(bv.y), abs(bv.y)+.002, abs(bv.x)));\n        box = mix(box, white * lines, smoothstep(abs(bv.y), abs(bv.y)+.002, bv.x));\n        \n        \n        // square rim\n        col = mix(col, col*0.8, 1.0 - smoothstep(.0, .002, square(bv, vec2(0), 0.21)));\n        col = mix(col, white, 1.0 - smoothstep(0., .002, square(bv, vec2(0), 0.18)));\n        // square shading\n        box = mix(box*.5, box, abs(d*10.));\n        // square\n        col = mix(col, box, smoothstep(d, d+.002, 0.));\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define blur_strength 0.\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 209, 209, 285], [503, 561, 614, 614, 736], [738, 738, 798, 798, 898], [900, 900, 974, 974, 1151], [1153, 1153, 1210, 1210, 5098]], "test": "untested"}
{"id": "7dVGWR", "name": "Volume Path Tracing on Bunny", "author": "SebH", "description": "Show case volumetric path tracing with ratio and spectral tracking. Simpler version of https://www.shadertoy.com/view/NdcGzl\n\nhttps://twitter.com/SebHillaire\nhttps://sebh.github.io/", "tags": ["volume", "cloud", "pathtracing", "bunny"], "likes": 113, "viewed": 7719, "published": 3, "date": "1631374061", "time_retrieved": "2024-07-30T19:02:02.549602", "image_code": "/*\nWelcome to this volumetric path tracing demo!\n\nIt presents volumetric path tracing with ratio and spectral tracking to respectively estimate transmittance and scattering for multiple wavelength at the same time.\n\nThe cloud data comes from Disney https://www.disneyanimation.com/data-sets/?drawer=/resources/clouds/. See BufferA for more details as to how it is achieved.\n\n!!!\n==> I am so SORRY the cloud data generateion shader in BufferA takes so long to compile. It would be smarter to do some block compression for instance to improve that situation.\nTo change that you can set USE_CLOUD to 0.\n\n==> By default, you should expect 5fp on a 1080. To improve framerate, you can reduce the scattering or path depth available at the top of BufferC code.\n!!!\n\nBufferB: the states of the scene+camera\nBufferC: current frame tracing result\nBufferD: accumulated result\n\nKeys:\n- click+mouse to look around\n- press left arrow + mouse to move the sun around\n- press up to reset accumulation history\n\nThanks to https://www.shadertoy.com/user/morimea for the many fixes for the OpenGL backend.\n\nhttps://twitter.com/SebHillaire\nhttps://sebh.github.io/\n*/\n\n\n\n\n\n\n\n\n\n\n// Final image output through sRGB\n\nfloat sRGB(float x)\n{\n\tif (x <= 0.00031308)\n\t\treturn 12.92 * x;\n\telse\n\t\treturn 1.055*pow(x, (1.0 / 2.4)) - 0.055;\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{    \n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    \n    float4 RGBSampleCount = texture(iChannel0, uv);\n    fragColor = float4(sRGB(RGBSampleCount.r / RGBSampleCount.a), sRGB(RGBSampleCount.g / RGBSampleCount.a), sRGB(RGBSampleCount.b / RGBSampleCount.a), 1.0);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// GLSL to HLSL\n\n#define float1 float\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define int2   ivec2\n#define int3   ivec3\n#define int4   ivec4\n#define uint2  uvec2\n#define uint3  uvec3\n#define uint4  uvec4\n\n#define lerp mix\n#define frac fract\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define PI 3.1415926535897932384626433832795f\n\n/*vec3 my_normalize(vec3 v){\n    float len = length(v);\n    if(len==0.0)return vec3(0.,1.,0.);\n    return v/len;\n}\n#define normalize(a) my_normalize(a)*/\n\n#define pow(a,b) pow(abs(a),b)\n#define sqrt(a) sqrt(abs(a))\n\n\n// Bunny data properties\n\n#define SRC_SIZE_X 32\n#define SRC_SIZE_Y 32\n#define SRC_SIZE_Z 32\n\n\n\n\n// States stored in BufferB\n\n#define PIX_MOUSEPOS         float2(0.5, 0.5)\n#define PIX_RESETACCUM       float2(1.5, 0.5)\n\n#define PIX_CAMPOS           float2(2.5, 0.5)\n#define PIX_CAMUP            float2(3.5, 0.5)\n#define PIX_CAMLEFT          float2(4.5, 0.5)\n#define PIX_CAMFORWARD       float2(5.5, 0.5)\n\n#define PIX_SUNDIRPOW        float2(6.5, 0.5)\n\n#define PIX_CAMYP            float2(7.5, 0.5)\n\n\n// Keyboard keys\n\n#define KEY_LEFT             37\n#define KEY_UP               38\n#define KEY_RIGHT            39\n#define KEY_DOWN             40\n\n\nbool FullResetImpl(int iFrame)\n{\n    return iFrame < 4; \n}\n#define FullReset FullResetImpl(iFrame)\n\n\n\n\n////////////////////////////////////////////////////////////\n// Sky (single scattering)\n////////////////////////////////////////////////////////////\n\n// Translated to HLSL From https://github.com/wwwtyro/glsl-atmosphere/blob/master/index.glsl. Not perfect but does a good job.\n// Also modified to return transmittance.\n\n#define iSteps 16\n#define jSteps 8\n\nfloat2 rsi(float3 r0, float3 rd, float sr) \n{\n\t// ray-sphere intersection that assumes\n\t// the sphere is centered at the origin.\n\t// No intersection when result.x > result.y\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rd, r0);\n\tfloat c = dot(r0, r0) - (sr * sr);\n\tfloat d = (b*b) - 4.0*a*c;\n\tif (d < 0.0) return float2(1e5,-1e5);\n\treturn float2(\n\t\t(-b - sqrt(d))/(2.0*a),\n\t\t(-b + sqrt(d))/(2.0*a)\n\t);\n}\n\nfloat3 atmosphere(\n\tfloat3 r, float3 r0, float3 pSun, float iSun, float rPlanet, float rAtmos, float3 kRlh, float kMie, float shRlh, float shMie, float g,\n\tout float3 transmittance\n) \n{\n#if 0\n\ttransmittance = float3(1.0)\n    ; return float3(0.03, 0.07, 0.23);\n#endif\n\n\t// Normalize the sun and view directions.\n\tpSun = normalize(pSun);\n\tr = normalize(r);\n\n\t// Calculate the step size of the primary ray.\n\tfloat2 p = rsi(r0, r, rAtmos);\n\tif (p.x > p.y) return float3(0,0,0);\n\tp.y = min(p.y, rsi(r0, r, rPlanet).x);\n\tfloat iStepSize = (p.y - p.x) / float(iSteps);\n\n\t// Initialize the primary ray time.\n\tfloat iTime = 0.0;\n\n\t// Initialize accumulators for Rayleigh and Mie scattering.\n\tfloat3 totalRlh = float3(0,0,0);\n\tfloat3 totalMie = float3(0,0,0);\n\n\t// Initialize optical depth accumulators for the primary ray.\n\tfloat iOdRlh = 0.0;\n\tfloat iOdMie = 0.0;\n\n\t// Calculate the Rayleigh and Mie phases.\n\tfloat mu = dot(r, pSun);\n\tfloat mumu = mu * mu;\n\tfloat gg = g * g;\n\tfloat pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\n\tfloat pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(max(0.0, 1.0 + gg - 2.0 * mu * g), 1.5) * (2.0 + gg));\n\n\t// Sample the primary ray.\n\tfor (int i = 0; i < iSteps; i++) {\n\n\t\t// Calculate the primary ray sample position.\n\t\tfloat3 iPos = r0 + r * (iTime + iStepSize * 0.5);\n\n\t\t// Calculate the height of the sample.\n\t\tfloat iHeight = length(iPos) - rPlanet;\n\n\t\t// Calculate the optical depth of the Rayleigh and Mie scattering for this step.\n\t\tfloat odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n\t\tfloat odStepMie = exp(-iHeight / shMie) * iStepSize;\n\n\t\t// Accumulate optical depth.\n\t\tiOdRlh += odStepRlh;\n\t\tiOdMie += odStepMie;\n\n\t\t// Calculate the step size of the secondary ray.\n\t\tfloat jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\n\n\t\t// Initialize the secondary ray time.\n\t\tfloat jTime = 0.0;\n\n\t\t// Initialize optical depth accumulators for the secondary ray.\n\t\tfloat jOdRlh = 0.0;\n\t\tfloat jOdMie = 0.0;\n\n\t\t// Sample the secondary ray.\n\t\tfor (int j = 0; j < jSteps; j++) {\n\n\t\t\t// Calculate the secondary ray sample position.\n\t\t\tfloat3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);\n\n\t\t\t// Calculate the height of the sample.\n\t\t\tfloat jHeight = length(jPos) - rPlanet;\n\n\t\t\t// Accumulate the optical depth.\n\t\t\tjOdRlh += exp(-jHeight / shRlh) * jStepSize;\n\t\t\tjOdMie += exp(-jHeight / shMie) * jStepSize;\n\n\t\t\t// Increment the secondary ray time.\n\t\t\tjTime += jStepSize;\n\t\t}\n\n\t\t// Calculate attenuation.\n\t\tfloat3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));\n\n\t\t// Accumulate scattering.\n\t\ttotalRlh += odStepRlh * attn;\n\t\ttotalMie += odStepMie * attn;\n\n\t\t// Increment the primary ray time.\n\t\tiTime += iStepSize;\n\n\t}\n\n\t// transmittance within atmosphere\n\ttransmittance = exp(-(kMie*iOdMie + kRlh*iOdRlh));\n\n\t// Calculate and return the final color.\n\treturn iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);\n}\n\nfloat3 getAtmosphereInScattering(\n\tfloat3 rayDir, float3 sunDir, float sunIntensity,\n\tout float3 transmittance1\n)\n{\n    float3 transmittance;\n    float3 ret = atmosphere(\n\t\trayDir,\t\t\t\t\t\t\t\t// normalized ray direction\n\t\tfloat3(0,6371e3 + 5e3,0),\t\t\t// ray origin (in meters)\n\t\tsunDir,\t\t\t\t\t\t\t\t// position of the sun\n\t\tsunIntensity,\t\t\t\t\t\t// intensity of the sun\n\t\t6371e3,\t\t\t\t\t\t\t\t// radius of the planet in meters\n\t\t6471e3,\t\t\t\t\t\t\t\t// radius of the atmosphere in meters\n\t\tfloat3(5.5e-6, 13.0e-6, 22.4e-6),\t// Rayleigh scattering coefficient\n\t\t21e-6,\t\t\t\t\t\t\t\t// Mie scattering coefficient\n\t\t8e3,\t\t\t\t\t\t\t\t// Rayleigh scale height\n\t\t1.2e3,\t\t\t\t\t\t\t\t// Mie scale height\n\t\t0.758,\t\t\t\t\t\t\t\t// Mie preferred scattering direction\n\n\t\ttransmittance\n\t);\n    transmittance1=transmittance;\n    return ret;\n}\n\n\n\n", "buffer_b_code": "\n// Manage keyboard and mouse input for setting up the scene and camera\n// the state data are stored into BufferB.\n\n#define PIX_ARE_EQUAL(a, b)  (int(a.x)==int(b.x) && int(a.y)==int(b.y) ? true : false)\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{\n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n\tfloat2 MouseUV = iMouse.xy / iResolution.xy;\n\tfloat2 MouseClickUV = iMouse.zw / iResolution.xy;\n    \n    float3 PrevCamPos = texelFetch(iChannel0, ivec2(PIX_CAMPOS), 0).xyz;\n    float2 PrevMousePos = texelFetch(iChannel0, ivec2(PIX_MOUSEPOS), 0).xy;\n\tfloat2 PrevMouseUV = PrevMousePos / iResolution.xy;\n    \n    float2 CamYawPitch = texelFetch(iChannel0, ivec2(PIX_CAMYP), 0).xy;\n    \n    bool bFullReset = FullReset;\n    \n    // View diretion in camera space\n    float3 viewDir = normalize(float3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    \n    // Reset accumulation by default\n    bool ResetAccum = bFullReset || (int(iMouse.x)!=int(PrevMousePos.x) && int(iMouse.y)!=int(PrevMousePos.y)) || texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x > 0.0;\n    \n    // Sun light control\n    float SunPower = 4.0f;\n    float4 SunDirPow = bFullReset ? float4(normalize(float3(0,0.1,1)), SunPower) : texelFetch(iChannel0, ivec2(PIX_SUNDIRPOW), 0).xyzw;\n    bool bControlSun = texelFetch(iChannel1, ivec2(KEY_LEFT,0), 0).x > 0.0;\n    if(bControlSun)\n    {\n        ResetAccum = true;\n        float HorizonAngle = MouseUV.x*2.0*PI;\n        float VerticalAngle = (MouseUV.y-0.05)*PI;\n        SunDirPow = float4(normalize(float3(cos(HorizonAngle)*cos(VerticalAngle), sin(VerticalAngle), sin(HorizonAngle)*cos(VerticalAngle))), SunPower);\n    }\n    \n    \n    \n    // Compute camera properties\n    float  camDist = 3.3;\n    float  CamHeight= 0.0;\n    float3 camUp = float3(0, 1.0, 0);\n    if(bFullReset)\n    {\n        CamYawPitch.x = 0.0;\n        CamYawPitch.y = 0.5;\n    }\n    if(!bControlSun)\n    {\n        CamYawPitch.x += (MouseUV.x - PrevMouseUV.x) * 10.0;\n        CamYawPitch.y += (MouseUV.y - PrevMouseUV.y) * 5.0;\n        \n        CamYawPitch.y = clamp(CamYawPitch.y, -PI*0.45, PI*0.45);\n    }\n    float HorizonAngle = CamYawPitch.x; //MouseUV.x*2.0*PI;\n    float VerticalAngle = CamYawPitch.y;//-(MouseUV.y-0.5)*PI;\n    float3 camPos = float3(camDist*cos(HorizonAngle)*cos(VerticalAngle), CamHeight+camDist*sin(VerticalAngle), camDist*sin(HorizonAngle)*cos(VerticalAngle));\n    float3 camTarget = float3(0, -0.0, 0);\n    \n    // And from them evaluated ray direction in world space\n    float3 forward = normalize(camTarget - camPos);\n    float3 left = normalize(cross(forward, camUp));\n    float3 up = cross(left, forward);\n    \n    fragColor = float4(0.0);\n    \n    if(PIX_ARE_EQUAL(PIX_MOUSEPOS, fragCoord.xy))\n    {\n        fragColor = float4(iMouse.xy, 0.0, 0.0);\n    }\n    if(PIX_ARE_EQUAL(PIX_RESETACCUM, fragCoord.xy))\n    {\n        fragColor = float4(ResetAccum ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    }\n    \n    if(PIX_ARE_EQUAL(PIX_CAMPOS, fragCoord.xy))\n    {\n        fragColor = float4(camPos, 0.0);\n    }\n    if(PIX_ARE_EQUAL(PIX_CAMUP, fragCoord.xy))\n    {\n        fragColor = float4(up, 0.0);\n    }\n    if(PIX_ARE_EQUAL(PIX_CAMLEFT, fragCoord.xy))\n    {\n        fragColor = float4(left, 0.0);\n    }\n    if(PIX_ARE_EQUAL(PIX_CAMFORWARD, fragCoord.xy))\n    {\n        fragColor = float4(forward, 0.0);\n    }\n\n    if(PIX_ARE_EQUAL(PIX_SUNDIRPOW, fragCoord.xy))\n    {\n        fragColor = SunDirPow;\n    }\n\n    if(PIX_ARE_EQUAL(PIX_CAMYP, fragCoord.xy))\n    {\n        fragColor = float4(CamYawPitch, 0.0, 0.0);\n    }\n\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// State of the art\n//  - https://graphics.pixar.com/\n//  - https://cs.dartmouth.edu/wjarosz/publications/no\n\n// This demo relised particularly on:\n// Ratio tracking,    see https://cs.dartmouth.edu/wjarosz/publications/novak14residual.html\n// Spectral tracking, see https://jannovak.info/publications/SDTracking/index.html\n// Both are important for tracing multiple waveleght along a path at the same time when evaluating tranmsittance and scattered radiance.\n\n#define gAmbientLightEnable 1.0\n#define gSunLightEnable 1.0\n\n#define gScattering (vec3(1.0, 1.0, 1.0)*200.0)\n#define gAbsorption vec3(0.0, 0.0, 0.0)\n\n#define gMaxPathDepth 20\n\n\n//////////////////////////////////////////////////\n// Volume data\n//////////////////////////////////////////////////\n\n#define HIGHBOUND (float3(SRC_SIZE_X, SRC_SIZE_Y, SRC_SIZE_Z) / float3(SRC_SIZE_Z))\n#define LOWBOUND  (-HIGHBOUND)\n\n// A low res volume version of the Stanford bunny https://en.wikipedia.org/wiki/Stanford_bunny \n#define BUNNY_VOLUME_SIZE 32\nconst uint packedBunny[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\nfloat SampleVolume(float3 P)\n{\n    // Normalize uvs to 0-1\n    float3 uvs = (P - LOWBOUND) / (HIGHBOUND - LOWBOUND);\n    \n    float3 voxelUvs = max(float3(0.0),min(uvs*float3(BUNNY_VOLUME_SIZE), float3(BUNNY_VOLUME_SIZE)-1.0));\n    uint3 intCoord = uint3(voxelUvs);\n    uint arrayCoord = intCoord.x + intCoord.z*uint(BUNNY_VOLUME_SIZE);\n\t\n    // Very simple clamp to edge. It would be better to do it for each texture sample\n    // before the filtering but that would be more expenssive...\n    // Also adding small offset to catch cube intersection floating point error\n    if(uvs.x<-0.001 || uvs.y<-0.001 || uvs.z<-0.001 ||\n      uvs.x>1.001 || uvs.y>1.001 || uvs.z>1.001)\n    \treturn 0.0;\n   \n    uint3 intCoord2 = min(intCoord+uint3(1), uint3(BUNNY_VOLUME_SIZE-1));\n    \n    uint arrayCoord00 = intCoord.x  + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord01 = intCoord.x  + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord10 = intCoord2.x + intCoord.z *uint(BUNNY_VOLUME_SIZE);\n    uint arrayCoord11 = intCoord2.x + intCoord2.z*uint(BUNNY_VOLUME_SIZE);\n    \n    uint bunnyDepthData00 = packedBunny[arrayCoord00];\n    uint bunnyDepthData01 = packedBunny[arrayCoord01];\n    uint bunnyDepthData10 = packedBunny[arrayCoord10];\n    uint bunnyDepthData11 = packedBunny[arrayCoord11];\n        \n    float voxel000 = (bunnyDepthData00 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel001 = (bunnyDepthData01 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel010 = (bunnyDepthData10 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel011 = (bunnyDepthData11 & (1u<<intCoord.y)) > 0u ? 1.0 : 0.0;\n    float voxel100 = (bunnyDepthData00 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel101 = (bunnyDepthData01 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel110 = (bunnyDepthData10 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    float voxel111 = (bunnyDepthData11 & (1u<<intCoord2.y)) > 0u ? 1.0 : 0.0;\n    \n    float3 d = voxelUvs - float3(intCoord);\n    \n    voxel000 = mix(voxel000,voxel100, d.y);\n    voxel001 = mix(voxel001,voxel101, d.y);\n    voxel010 = mix(voxel010,voxel110, d.y);\n    voxel011 = mix(voxel011,voxel111, d.y);\n    \n    voxel000 = mix(voxel000,voxel010, d.x);\n    voxel001 = mix(voxel001,voxel011, d.x);\n    \n    float voxel = mix(voxel000,voxel001, d.z);\n    \n    return voxel;\n}\n\n\n\n//////////////////////////////////////////////////\n// Cube intersection\n//////////////////////////////////////////////////\n\nbool slabs(float3 p0, float3 p1, float3 rayOrigin, float3 invRaydir, out float outTMin, out float outTMax) \n{\n\tfloat3 t0 = (p0 - rayOrigin) * invRaydir;\n\tfloat3 t1 = (p1 - rayOrigin) * invRaydir;\n\tfloat3 tmin = min(t0,t1), tmax = max(t0,t1);\n\tfloat maxtmin = max(max(tmin.x, tmin.y), tmin.z);\n\tfloat mintmax = min(min(tmax.x, tmax.y), tmax.z);\n\toutTMin = maxtmin;\n\toutTMax = mintmax;\n\treturn maxtmin <= mintmax;\n}\n\n\n\n//////////////////////////////////////////////////\n// Dual lobe phase function as in https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf, page 39\n//////////////////////////////////////////////////\n\nfloat hgPhase(float g, float cosTheta)\n{\n\t// Reference implementation (i.e. not schlick approximation). \n\t// See http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html\n\tfloat numer = 1.0f - g*g;\n\tfloat denom = 1.0f + g*g + 2.0f * g * cosTheta;\n\treturn numer / (4.0f * PI * denom * sqrt(denom) );\n}\nfloat dualLobPhase(float g0, float g1, float w, float cosTheta)\n{\n\treturn lerp(hgPhase(g0, cosTheta), hgPhase(g1, cosTheta), w);\n}\n\nfloat uniformPhase()\n{\n\treturn 1.0f / (4.0f * PI);\n}\n\n\n\n//////////////////////////////////////////////////\n// Some noise\n//////////////////////////////////////////////////\n\nfloat whangHashNoise(uint u, uint v, uint s)\n{\n    // https://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n    // https://www.shadertoy.com/view/ldjczd\n\tuint seed = (u*1664525u + v) + s;\n\tseed  = (seed ^ 61u) ^(seed >> 16u);\n\tseed *= 9u;\n\tseed  = seed ^(seed >> 4u);\n\tseed *= uint(0x27d4eb2d);\n\tseed  = seed ^(seed >> 15u);\n\tfloat value = float(seed) / (4294967296.0);\n\treturn value;\n}\n\nfloat badNoise(float2 uv)\n{\n\treturn frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n////////////////////////////////////////////////////////////\n// Ray related tools\n////////////////////////////////////////////////////////////\n\n#define RAYDPOS      0.00001f\n#define VOL_SAF_DIST 0.00000001f\n\nstruct Ray\n{\n\tfloat3 o;\n\tfloat3 d;\n};\n\nRay createRay(in float3 p, in float3 d)\n{\n\tRay r;\n\tr.o = p;\n\tr.d = d;\n\treturn r;\n}\n\n\n////////////////////////////////////////////////////////////\n// Path tracing context used by the integrator\n////////////////////////////////////////////////////////////\n\nstruct PathTracingContext\n{\n\tRay ray;\n\tfloat3 P;\n\tfloat3 V;\t// not always the view: sometimes it is the opposite of ray.d when one bounce has happened.\n\n\tfloat scatteringMajorant;\n\tfloat absorptionMajorant;\n\tfloat extinctionMajorant;\n\tfloat albedo;\t\t\t// name ScatteringAlbedo in Pixar's course note\n\n\tfloat3 wavelengthMask;\t// This is ok while we deal with only RGB. It will become a problem when doing real wavelength rendering...\n\n\t//\tThis is used to say \"ray did not terminated/interact in a volume and we are going out of it without any mateiral interaction\". \n\t// For instance if a media is used in a glass layer then the Bxdf should be evaluated on output (for reflection, refraction, etc.).\n\t// This is enough for the simple volume use case we have today.\n\t// It is only used in the multi scattering light integrator.\n\t//\tIn a real path tracer, one would set the Bxdf on the ouput to use as next event.\n\tbool nullMaterial;\n\n\tuint2 screenPixelPos;\n\tfloat randomState;\n};\n\nfloat random01(inout PathTracingContext ptc)\n{\n\t// Trying to do the best noise here with simple function.\n\t// See https://www.shadertoy.com/view/ldjczd.\n\t// TODO: have a look at the best noise solution for this case\n\tfloat rnd = whangHashNoise(uint(ptc.randomState), uint(ptc.screenPixelPos.x), uint(ptc.screenPixelPos.y));\n\n\t//ptc.randomState++; return rnd;\n\n#if 1\n\tptc.randomState += float(iFrame) + iTime;\n#else\n\tuint animation = uint(gTime*123456.0);\n\tptc.randomState += float((animation*12345u)%256u);\n#endif\n\n\treturn rnd;\n}\n\n\n\n\n\n////////////////////////////////////////////////////////////\n// Forward declaration of function used at different places\n////////////////////////////////////////////////////////////\n\n//float Transmittance( inout PathTracingContext ptc, in float3 P0, in float3 P1);\n\n\n\n////////////////////////////////////////////////////////////\n// Intersection & tests functions\n////////////////////////////////////////////////////////////\n\nbool insideAnyVolume(in Ray ray)\n{\n#if 0\n\tfloat3 p = ray.o;\n\n\tfloat3 halfSize = float3(0.5) / gVolumeSamplingScale;\n\tif (all(p<(halfSize + VOL_SAF_DIST) && p>(-halfSize - VOL_SAF_DIST)))\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n#else\n    const float3 LowB  = LOWBOUND - VOL_SAF_DIST;\n    const float3 HighB = HIGHBOUND+ VOL_SAF_DIST;\n\tfloat3 P = ray.o;\n    return P.x>=LowB.x && P.y>=LowB.y && P.z>=LowB.z && P.x<=HighB.x && P.y<=HighB.y && P.z<=HighB.z;\n#endif\n}\n\nbool intersectVolume(in Ray ray, inout float2 ts)\n{\n#if 0\n\tconst float3 volumeP0 = -0.5 * 1.0 / gVolumeSamplingScale;\n\tconst float3 volumeP1 = 0.5 * 1.0 / gVolumeSamplingScale;\n\treturn slabs(volumeP0, volumeP1, ray.o, 1.0 / ray.d, ts.x, ts.y);\n#else\n    float3 D = normalize(ray.d);\n    D += 0.0001 * (1.0 - abs(sign(D)));\n    return slabs(LOWBOUND, HIGHBOUND, ray.o, 1.0/D, ts.x, ts.y);\n#endif\n}\n\n// This is to intersect the entire media volume (6 planes only).\n// It would be good to get rid of it as it is a special case (assuming a single volume, but ok if it aggregates all volumes otherwise)\nbool getNearestIntersectionFullVolume(in Ray ray, inout float3 P)\n{\n\t// No triangles in this scene so only intersect with the volume.\n\tfloat2 ts=vec2(0.);\n\tif (intersectVolume(ray, ts))\n\t{\n\t\tif (ts.x <= 0.0f && ts.y <= 0.0f)\n\t\t\treturn false;\n\n\t\t// Now handle single point behind ray origin, otherwise take the minimum. Can be float t = ts.x<0.0 ? ts.y : (ts.y<0.0 ? ts.x : min(ts.x, ts.y));\n\t\tfloat t = ts.x < 0.0 ? ts.y : ts.x; // Optimised since we always have ts.x<=ts.y\n\t\tP = ray.o + t * ray.d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n////////////////////////////////////////////////////////////\n// Sampling functions\n////////////////////////////////////////////////////////////\n\nbool importanceSampleLightning_Warping(inout PathTracingContext ptc, inout float sx, inout float sy);\nbool importanceSampleLightning_Texel(inout PathTracingContext ptc, inout float sx, inout float sy);\n\n// Generates a uniform distribution of directions over a sphere.\n// Random zetaX and zetaY values must be in [0, 1].\n// Top and bottom sphere pole (+-zenith) are along the Y axis.\nfloat3 getUniformSphereSample(float zetaX, float zetaY)\n{\n\tfloat phi = 2.0f * PI * zetaX;\n\tfloat theta = 2.0f * acos(sqrt(1.0f - zetaY));\n\tfloat3 dir = float3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi)); \n\treturn dir;\n}\n\n// Generate a sample (using importance sampling) along an infinitely long path with a given constant extinction.\n// Zeta is a random number in [0,1]\nfloat infiniteTransmittanceIS(float extinction, float zeta)\n{\n\treturn - log(1.0f - zeta) / extinction;\n}\n\nstruct DistantLightSample\n{\n\tfloat3 transmittance;\n\tfloat3 radiance;\n};\n\n\n\n////////////////////////////////////////////////////////////\n// [Jendersie and d'Eon 2023] Sampling functions\n////////////////////////////////////////////////////////////\n\n/*\n * SPDX-FileCopyrightText: Copyright (c) <2023> NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// [Jendersie and d'Eon 2023]\n//   SIGGRAPH 2023 Talks\n//   https://doi.org/10.1145/3587421.3595409\n\n// EVAL and SAMPLE for the Draine (and therefore Cornette-Shanks) phase function\n//   g = HG shape parameter\n//   a = \"alpha\" shape parameter\n\n// Warning: these functions don't special case isotropic scattering and can numerically fail for certain inputs\n\n// eval:\n//   u = dot(prev_dir, next_dir)\nfloat evalDraine(in float u, in float g, in float a)\n{\n    return ((1.0 - g*g)*(1.0 + a*u*u))/(4.0*(1.0 + (a*(1.0 + 2.0*g*g))/3.) * PI * pow(1.0 + g*g - 2.0*g*u,1.5));\n}\n\n// sample: (sample an exact deflection cosine)\n//   xi = a uniform random real in [0,1]\nfloat sampleDraineCos(in float xi, in float g, in float a)\n{\n    float g2 = g * g;\n\tfloat g3 = g * g2;\n\tfloat g4 = g2 * g2;\n\tfloat g6 = g2 * g4;\n\tfloat pgp1_2 = (1.0 + g2) * (1.0 + g2);\n\tfloat T1 = (-1.0 + g2) * (4.0 * g2 + a * pgp1_2);\n\tfloat T1a = -a + a * g4;\n\tfloat T1a3 = T1a * T1a * T1a;\n\tfloat T2 = -1296.0 * (-1.0 + g2) * (a - a * g2) * (T1a) * (4.0 * g2 + a * pgp1_2);\n\tfloat T3 = 3.0 * g2 * (1.0 + g * (-1.0 + 2.0 * xi)) + a * (2.0 + g2 + g3 * (1.0 + 2.0 * g2) * (-1.0 + 2.0 * xi));\n\tfloat T4a = 432.0 * T1a3 + T2 + 432.0 * (a - a * g2) * T3 * T3;\n\tfloat T4b = -144.0 * a * g2 + 288.0 * a * g4 - 144.0 * a * g6;\n\tfloat T4b3 = T4b * T4b * T4b;\n\tfloat T4 = T4a + sqrt(-4.0 * T4b3 + T4a * T4a);\n\tfloat T4p3 = pow(T4, 1.0 / 3.0);\n\tfloat T6 = (2.0 * T1a + (48.0 * pow(2.0, 1.0 / 3.0) *\n\t\t(-(a * g2) + 2.0 * a * g4 - a * g6)) / T4p3 + T4p3 / (3.0 * pow(2.0, 1.0 / 3.0))) / (a - a * g2);\n\tfloat T5 = 6.0 * (1.0 + g2) + T6;\n\treturn (1.0 + g2 - pow(-0.5 * sqrt(T5) + sqrt(6.0 * (1.0 + g2) - (8.0 * T3) / (a * (-1.0 + g2) * sqrt(T5)) - T6) / 2.0, 2.0)) / (2.0 * g);\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Spectral tracking\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////////////////////\n// Path tracing context used by the integrator\n////////////////////////////////////////////////////////////\n\nstruct SpectralPathTracingContext\n{\n\tRay ray;\n\tfloat3 P;\n\tfloat3 V;\t// not always the view direction: sometimes it is the opposite of ray.d when one bounce has happened.\n\n    float4 SunDirPow;\n\n\t\n\t// Extinction majorant accross all wavelength\n\tfloat extinctionMajorant;\n\n\tfloat3 pathWeight;\n\n\t//\tThis is used to say \"ray did not terminated/interact in a volume and we are going out of it without any mateiral interaction\". \n\t// For instance if a media is used in a glass layer then the Bxdf should be evaluated on output (for reflection, refraction, etc.).\n\t// This is enough for the simple volume use case we have today.\n\t// It is only used in the multi scattering light integrator.\n\t//\tIn a real path tracer, one would set the Bxdf on the ouput to use as next event.\n\tbool nullMaterial;\n\n\tuint2 screenPixelPos;\n\tfloat randomState;\n};\n\n\n\n////////////////////////////////////////////////////////////\n// Re implemnted function for SpectralPathTracingContext and RGB spectral content\n////////////////////////////////////////////////////////////\n\nfloat random01(inout SpectralPathTracingContext ptc)\n{\n\t// Trying to do the best noise here with simple function.\n    // This is ok for the first step but has dimentionality increase further down the path, something smarter should be done to better explore the space. But surprisingly fine for this demo.\n\tfloat rnd = whangHashNoise(uint(ptc.randomState), uint(ptc.screenPixelPos.x), uint(ptc.screenPixelPos.y));\n\n\t//ptc.randomState++; return rnd;\n\n#if 1\n\tptc.randomState += float(iFrame) + iTime;\n#else\n\tuint animation = uint(iTime*123456.0);\n\tptc.randomState += float((animation * 12345u) % 256u);\n#endif\n\n\treturn rnd;\n}\n\nfloat3 getAlbedo(float3 scattering, float3 extinction)\n{\n\treturn scattering / max(float3(0.001), extinction);\n}\n\n// Sample the volume material at ptc.P\nstruct MediumSample3\n{\n\tfloat3 scattering;\n\tfloat3 absorption;\n\tfloat3 extinction;\n\tfloat3 albedo;\n};\nMediumSample3 sampleMedium(in SpectralPathTracingContext ptc)\n{\n\tfloat3 P = ptc.P;\n\n    float3 noiseRGB= (textureLod(iChannel1, P*30.0/32.0, 0.).rgb-0.5)*4.0f\n                   + (textureLod(iChannel1, P*60.0/32.0, 0.).rgb-0.5)*2.0f\n                   + (textureLod(iChannel1, P*120.0/32.0, 0.).rgb-0.5)*1.0f;\n\n    float3 Puv = P + 1.0*noiseRGB*0.02f;\n\n    float Density = SampleVolume(Puv);\n    \n\tfloat3 scatteringCoef = gScattering;\n\tfloat3 absorptionCoef = gAbsorption;\n\tfloat3 extinctionCoef = scatteringCoef + absorptionCoef;\n    \n\tMediumSample3 s;\n\ts.scattering = Density * scatteringCoef;\n\ts.absorption = Density * absorptionCoef;\n\ts.extinction = Density * extinctionCoef;\n\ts.albedo = getAlbedo(s.scattering, s.extinction);\n\treturn s;\n}\n\n#if 1\n\n// Use uniform phase function\n\nvoid phaseEvaluateSample(in SpectralPathTracingContext ptc, in float3 direction, in float3 lightL, out float value, out float pdf)\n{\n\tpdf = uniformPhase();\n\tvalue = pdf;\n}\nvoid phaseGenerateSample(inout SpectralPathTracingContext ptc, out float3 direction, out float value, out float pdf)\n{\n\t// Evaluate a random direction\n\tdirection = getUniformSphereSample(random01(ptc), random01(ptc));\n\t// From direction, evaluate the phase value and pdf\n\tphaseEvaluateSample(ptc, direction, direction, value, pdf);\n}\n\n#else\n\n// Use [Jendersie and d'Eon 2023]\n// TODO select HG or Draine based on weight, update pdf, then lerp evaluation.\n\n#define A 1.0\n#define G 0.0\n\nvoid branchlessONB(in float3 n, out float3 b1, out float3 b2)\n{\n    // See https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float signZ = n.z >= 0.0f ? 1.0f : -1.0f; // float sign = copysignf(1.0f, n.z);\n    float a = -1.0f / (signZ + n.z);\n    float b = n.x * n.y * a;\n    b1 = float3(1.0f + signZ * n.x * n.x * a, signZ * b, -signZ * n.x);\n    b2 = float3(b, signZ + n.y * n.y * a, -n.y);\n}\n\n\nvoid phaseEvaluateSample(in SpectralPathTracingContext ptc, in float3 direction, in float3 lightL, out float value, out float pdf)\n{\n    pdf = evalDraine(dot(direction, lightL), G, A);\n    value = pdf;\n}\nvoid phaseGenerateSample(inout SpectralPathTracingContext ptc, inout float3 direction, inout float value, inout float pdf)\n{\n#if 1\n    float3 b0 = direction;\n    float3 b1 = float3(0.0f, 0.0f, 0.0f);\n    float3 b2 = float3(0.0f, 0.0f, 0.0f);\n    branchlessONB(b0, b1, b2);\n    \n    float u = sampleDraineCos(random01(ptc), G, A);\n    \n\t// Evaluate a random direction\n\tfloat phi = 2.0f * PI * random01(ptc);  \n\tfloat theta = 2.0f * acos(sqrt(1.0f - u));\n\tfloat3 dir = float3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi)); \n\n    \n    // Project it out of the local basis\n    direction = b0 * dir.y + b1 * dir.x + b2 * dir.z;\n#else\n\tfloat3 NewDirection = getUniformSphereSample(random01(ptc), random01(ptc));\n    float u = dot(direction, NewDirection);\n    direction = NewDirection;\n#endif\n    \n\t// From direction, evaluate the phase value and pdf\n\tevalDraine(u, value, pdf);\n}\n\n#endif\n\n\n\n////////////////////////////////////////////////////////////\n// Transmittance estimation based on Residual Ratio Tracking for Estimating Attenuation in Participating Media\n// http://drz.disneyresearch.com/~jnovak/publications/RRTracking/index.html\n// Converted to RGB from vpt_transintegrator_ratiotracking.hlsl.\n////////////////////////////////////////////////////////////\n\nfloat3 Transmittance(\n\tinout SpectralPathTracingContext ptc,\n\tin float3 P0,\n\tin float3 P1)\n{\n\tfloat distance = length(P0 - P1);\n\tfloat3 dir = float3(P1 - P0) / distance;\n    \n\tfloat3 transmittance = float3(1.0f);\n    \n#if 1\n    // Ray marching\n    float StepCount = 70.0f;// This requires quite some stteps to not look too biased. But even with that, it is faster than unbiased ratio tracking.\n    float Step = 1.0f / StepCount;\n    float DistancePerStep = distance / StepCount;\n    for(float t = Step*0.5; t<1.0; t+=Step)\n    {\n\t\tfloat3 P = P0 + t * dir * distance;\n\t\tptc.P = P;\n\t\tfloat3 extinction = sampleMedium(ptc).extinction;\n\t\ttransmittance *= exp(- extinction * DistancePerStep);\n    }\n    \n#else\n\n\tbool terminated = false;\n\tfloat t = 0.0f;\n\n\n\t// Implements ratio tracking (non residual).\n    // See https://cs.dartmouth.edu/wjarosz/publications/novak14residual.html\n\tconst float globalMaxDensity = 1.0f;\n\tfloat globalExtinctionMajorant = globalMaxDensity * ptc.extinctionMajorant;\n\tdo\n\t{\n\t\tfloat zeta = random01(ptc);\n\t\tt = t + infiniteTransmittanceIS(globalExtinctionMajorant, zeta);\n\n\t\t// Update the shading context\n\t\tfloat3 P = P0 + t * dir;\n\t\tptc.P = P;\n\n\t\tif (t > distance)\n\t\t\tbreak; // Did not terminate in the volume\n\n\t\tfloat3 extinction = sampleMedium(ptc).extinction;\n\t\ttransmittance *= float3(1.0f) - max(float3(0.0f), extinction / globalExtinctionMajorant);\n\n\t\t// Russian roulette PBRT style, but not nice really...\n\t\t/*float rrThreshold = 0.1f;\n\t\tif (transmittance.x < rrThreshold && transmittance.y < rrThreshold && transmittance.z < rrThreshold)\n\t\t{\n\t\t\tfloat3 q = max(float3(0.05f), float3(1.0f) - transmittance);\n\t\t\tif (random01(ptc) < max(q.x, max(q.y, q.z))) return float3(0.0f);\n\t\t\ttransmittance /= float3(1.0) - q;\n\t\t}*/\n\t} while (true);\n    \n#endif\n\n\treturn transmittance;\n}\n\n\n\nfloat3 getSkyRadiance(float4 SunDirPow, float3 Direction)\n{\n\tDistantLightSample result;\n\tresult.transmittance = float3(1.0f);\n\tresult.radiance = float3(0.0f);\n\tif (gAmbientLightEnable > 0.0)\n\t{\n        float4 SunDirPow = texelFetch(iChannel3, ivec2(PIX_SUNDIRPOW), 0).xyzw;\n        result.radiance = getAtmosphereInScattering(Direction, SunDirPow.xyz, SunDirPow.w, result.transmittance);\n\t}\n\treturn result.radiance;\n}\nfloat3 getSkyTransmittance(float4 SunDirPow, float3 Direction)\n{\n\tDistantLightSample result;\n\tresult.transmittance = float3(1.0f);\n\tresult.radiance = float3(0.0f);\n\tif (gAmbientLightEnable > 0.0)\n\t{\n        float4 SunDirPow = texelFetch(iChannel3, ivec2(PIX_SUNDIRPOW), 0).xyzw;\n        result.radiance = getAtmosphereInScattering(Direction, SunDirPow.xyz, SunDirPow.w, result.transmittance);\n\t}\n\treturn result.transmittance;\n}\n\nfloat3 TransmittanceEstimation(in SpectralPathTracingContext ptc, in float3 direction)\n{\n\tfloat3 beamTransmittance = float3(1.0f);\n\tfloat3 P0 = ptc.P + direction * RAYDPOS;\n\tfloat3 P1 = float3(0.);\n\tif (getNearestIntersectionFullVolume(createRay(P0, direction), P1))\n\t\tbeamTransmittance = Transmittance(ptc, P0, P1);\n\treturn beamTransmittance;\n}\n\n\n\nvoid lightGenerateSample(inout SpectralPathTracingContext ptc, out float3 direction, out float3 value, out float pdf, out float3 beamTransmittance, out bool isDeltaLight)\n{\n\tbeamTransmittance = float3(1.0f);\n\tfloat sourceCount = gSunLightEnable + gAmbientLightEnable;\n\tif (sourceCount == 0.0f)\n\t{\n\t\tisDeltaLight = true;\n\t\tpdf = 0.0f;\n\t\tvalue = float3(0.0f);\n\t\tdirection = float3(1.0, 0.0, 0.0);\n\t\treturn;\n\t}\n\n\tfloat zeta = random01(ptc);\n\tif (zeta <= (gAmbientLightEnable / sourceCount))\n\t{\n\t\t// Evaluate a random direction\n\t\tdirection = getUniformSphereSample(random01(ptc), random01(ptc));\n\n\t\t// Evaluate the value and pdf\n\t\tpdf = (gAmbientLightEnable / sourceCount) * 1.0f / (4.0f * PI);\n\t\tvalue = getSkyRadiance(ptc.SunDirPow, direction);\n\n\t\t// Evaluate the transmittance\n\t\tbeamTransmittance = TransmittanceEstimation(ptc, direction);\n\n\t\tisDeltaLight = false;\n\t}\n\telse // if (zeta <= ((gAmbientLightEnable + gSunLightEnable) / sourceCount))\n\t{\n\t\t// Transmittance throught the sky\n\t\tfloat3 sunSkyTransmittance = getSkyTransmittance(ptc.SunDirPow, ptc.SunDirPow.xyz);\n\n\t\t// From direction, evaluate the beamTransmittance, value and pdf\n\t\tdirection = ptc.SunDirPow.xyz;\n\t\tvalue = ptc.SunDirPow.www * sunSkyTransmittance;\n\t\tpdf = gSunLightEnable / sourceCount;\n\n\t\t// Evaluate the transmittance\n\t\tbeamTransmittance = TransmittanceEstimation(ptc, direction);\n\n\t\tisDeltaLight = true;\n\t}\n}\n\n\n\n////////////////////////////////////////////////////////////\n// Misc functions\n////////////////////////////////////////////////////////////\n\n// From http://jcgt.org/published/0006/01/01/\nvoid CreateOrthonormalBasis(in float3 n, out float3 b1, out float3 b2)\n{\n\tfloat sign = n.z >= 0.0f ? 1.0f : -1.0f; // copysignf(1.0f, n.z);\n\tfloat a = -1.0f / (sign + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = float3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);\n\tb2 = float3(b, sign + n.y * n.y * a, -n.y);\n}\n\nfloat mean(float3 v)\n{\n\treturn dot(v, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));\n}\n\n// Multiple importance sampling\nfloat mis(int nsample1, float pdf1, int nsample2, float pdf2)\n{\n#if 1\n\treturn (float(nsample1) * pdf1) / (float(nsample1) * pdf1 + float(nsample2) * pdf2);\n#else\n\tfloat factor1 = nsample1 * pdf1;\n\tfloat factor2 = nsample2 * pdf2;\n\treturn (factor1 * factor2) / (factor1 * factor1 + factor2 * factor2);\n#endif\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Volume integrator relying on spectral tracking\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// http://drz.disneyresearch.com/~jnovak/publications/SDTracking/index.html\n// https://twitter.com/yiningkarlli\n// https://twitter.com/_jannovak\n\n\nbool Integrate(\n\tinout SpectralPathTracingContext ptc,\n\tin Ray wi,\n\tinout float3 P, // closestHit\n\tout float3 transmittance,\n\tout float3 weight,\n\tinout Ray wo) \n{\n    transmittance = float3(0.);\n    weight = float3(0.);\n\tfloat3 P0 = ptc.P;\n\tif (!getNearestIntersectionFullVolume(createRay(P0, wi.d), P))\n\t\treturn false;\n\n\tfloat tMax = length(P - P0);\n\n\tbool eventScatter = false;\n\tbool eventAbsorb = false;\n\n\tconst float3 oneThird = float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f);\n\n\tfloat t = 0.0f;\n\tMediumSample3 medium;\n\tmedium.scattering = float3(0.0f);\n\tmedium.absorption = float3(0.0f);\n\tmedium.extinction = float3(0.0f);\n\tmedium.albedo = float3(0.0f);\n\tfloat3 pathVertexWeight = float3(0.0f);\n\tdo \n\t{\n\t\tif (ptc.extinctionMajorant == 0.0) break; // cannot importance sample, so stop right away\n\n\n\t\tfloat zeta = random01(ptc);\n\t\tt = t + infiniteTransmittanceIS(ptc.extinctionMajorant, zeta); // unbounded domain proportional with PDF to the transmittance\n\t\tif (t > tMax)\n\t\t\tbreak; // Did not terminate in the volume\n\n\t\t// Update the shading context\n\t\tfloat3 P1 = P0 + t * wi.d;\n\t\tptc.P = P1;\n\n\t\t// Recompute the local extinction after updating the shading context\n\t\tmedium = sampleMedium(ptc);\n\n        // Implements spectral tracking\n        // See https://jannovak.info/publications/SDTracking/index.html\n\n\t\t// Spectral tracking weights\n\t\tfloat3 Un = max(float3(0.0), ptc.extinctionMajorant - medium.absorption - medium.scattering);\n\t\tfloat avgUaW = dot(oneThird, medium.absorption * ptc.pathWeight);\n\t\tfloat avgUsW = dot(oneThird, medium.scattering * ptc.pathWeight);\n\t\tfloat avgUnW = dot(oneThird, Un                * ptc.pathWeight);\n\t\tfloat cInv = 1.0 / (avgUaW + avgUsW + avgUnW);\n\t\tfloat Pa = avgUaW * cInv;\n\t\tfloat Ps = avgUsW * cInv;\n\t\tfloat Pn = avgUnW * cInv;\n\n\n\t\tfloat xi = random01(ptc);\n\t\tif (xi <= Ps && Ps > 0.0) // Also check that probability>0.0 to avoid false positive test due to float accuracy and resulting Nan\n\t\t{\n\t\t\teventScatter = true;\n\t\t\tpathVertexWeight = medium.scattering / (ptc.extinctionMajorant * Ps);\n\t\t}\n\t\telse if (xi < (1.0 - Pn) && Pa>0.0)\n\t\t{\n\t\t\teventAbsorb = true;\n\t\t\tpathVertexWeight = medium.absorption / (ptc.extinctionMajorant * Pa);\t// TODOSTVPT apply that total path weight on emissive.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpathVertexWeight = Un / (ptc.extinctionMajorant * Pn);\n\t\t\tptc.pathWeight *= pathVertexWeight; // always accumulate\n\t\t}\n\t\t\n\t} while (!(eventScatter || eventAbsorb));\n\n\t//if (eventScatter && all(medium.extinction > 0.0))\n\tif (eventScatter && medium.extinction.x > 0.0 && medium.extinction.y > 0.0 && medium.extinction.z > 0.0)\n\t{\n\t\tP = ptc.P;\n\n\t\ttransmittance = float3(1.0f);\n\t\tweight = float3(1.0f);\n\n\t\tptc.pathWeight *= pathVertexWeight;\n\t}\n\telse if (eventAbsorb)\n\t{\n\t\tP = ptc.P;\n\n\t\ttransmittance = float3(0.0f);\t// will set throughput to 0 and stop processing loop\n\t\tweight = float3(0.0f);\t\t\t// will remove lighting\n\n\t\tptc.pathWeight *= pathVertexWeight;\n\t}\n\telse\n\t{\n\t\tP = P0 + tMax * wi.d; // out of the volume range\n\n\t\ttransmittance = float3(1.0f);\n\t\tweight = float3(1.0f);\n\n\t\tptc.nullMaterial = true; // notify out of the volume\n\t\t//ptc.pathWeight *= pathVertexWeight;\tNot needed as this is already handled in the loop above each time a null event happen\n\t}\n\n\two = createRay( P + wi.d*RAYDPOS, wi.d );\n\n\treturn true;\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Lighting integrator relying on spectral tracking\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n#define V_DEBUG_PHASE\t 0\n#define V_DEBUG_ONLYPATH 0\n\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{    \n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    \n    fragColor = float4(0,0,0,0);\n    if(iFrame < 5)\n    {\n        return;\n    }\n    \n    \n\tvec2 mouseControl = iMouse.xy / iResolution.xy;\n    \n    // Load camera state\n    float3 camPos  = texelFetch(iChannel3, ivec2(PIX_CAMPOS), 0).xyz;\n    float3 up      = texelFetch(iChannel3, ivec2(PIX_CAMUP), 0).xyz;\n    float3 left    = texelFetch(iChannel3, ivec2(PIX_CAMLEFT), 0).xyz;\n    float3 forward = texelFetch(iChannel3, ivec2(PIX_CAMFORWARD), 0).xyz;\n    \n    // View diretion in camera space\n    float3 viewDir = normalize(float3((fragCoord.xy - iResolution.xy*0.5) / iResolution.y, 1.0));\n    viewDir.xy *= 0.7f;\n    viewDir = normalize(viewDir);\n    float3 worldDir = viewDir.x*left + viewDir.y*up + viewDir.z*forward;\n    \n\t// Global uniform participating media properties\n\tfloat3 scatteringCoef = gScattering;\n\tfloat3 absorptionCoef = gAbsorption;\n\tfloat3 extinctionCoef = scatteringCoef + absorptionCoef;\n\tfloat3 albedo         = getAlbedo(scatteringCoef, extinctionCoef);\n\n\n\n\t//\n\t// Initialise the tracing context\n\t//\n\tSpectralPathTracingContext ptc;\n\tptc.nullMaterial = false;\n\n\tptc.P = float3(0.0);\t\t// TODOSTVPT remove ptc.P and float3 P below? but carefullm used by sampleMedium for instance\n\tptc.V = float3(0.0);\n\tptc.ray = createRay(float3(0.0), float3(0.0));\n    \n    ptc.SunDirPow = texelFetch(iChannel3, ivec2(PIX_SUNDIRPOW), 0);\n\n\tptc.extinctionMajorant = max(extinctionCoef.r, max(extinctionCoef.g, extinctionCoef.b));\n\tptc.pathWeight = float3(1.0f);\n\n\tptc.screenPixelPos = uint2(fragCoord.xy);\n\tptc.randomState = (fragCoord.x + fragCoord.y*iResolution.x) + float(uint(uint(iFrame)*123u)%32768u);\n\n\t//\n\t// Trace the scene\n\t//\n\tfloat3 L = float3(0.0f);\n\t{\n\t\tfloat3 throughput = float3(1.0f);\n\t\tRay ray = createRay(camPos, worldDir); // ray from camera to pixel\n\n\t\tfloat3 P = camPos;\t\t\t\t\t\t\t// Default start point when the camera is inside a volume\n\t\tfloat3 prevDebugPos = P;\n\n\n\t\tint step = 0;\n\t\tbool hasScattered = false;\n\t\twhile (step < gMaxPathDepth && throughput.x>0.0 && throughput.y>0.0 && throughput.z>0.0)\n\t\t{\n\t\t\t// store current context: ray, intersection point P, etc.\n\t\t\tptc.ray = ray;\n\t\t\tptc.P = P + ray.d * RAYDPOS;\n\t\t\tptc.V = -ray.d;\n\n\t\t\t// Skipping all the solid surface BRDF code in our case...\n\t\t\tfloat3 sampleDirection = ray.d;\n\n\t\t\t// Compute next ray from last intersection.\n\t\t\t// From there, next ray is the reference ray for volumetric interactions.\n\t\t\tRay nextRay = createRay(P + sampleDirection * RAYDPOS, sampleDirection);\n\n\t\t\tif (insideAnyVolume(nextRay))\n\t\t\t{\n\t\t\t\tfloat3 transmittance = float3(0.0);\n\t\t\t\tfloat3 weight = float3(0.0);\n                \n                Ray nextRay_tmp;\n                nextRay_tmp.o = nextRay.o;\n                nextRay_tmp.d = nextRay.d;\n\t\t\t\tbool hasCollision = Integrate(ptc, nextRay_tmp, P, transmittance, weight, nextRay);\n\n\t\t\t\tif (hasCollision && !ptc.nullMaterial)\n\t\t\t\t{\n\t\t\t\t\tfloat3 lightL;\n\t\t\t\t\tfloat bsdfL;\n\t\t\t\t\tfloat3 beamTransmittance;\n\t\t\t\t\tfloat lightPdf, bsdfPdf;\n\t\t\t\t\tfloat misWeight;\n\t\t\t\t\tfloat3 sampleDirection;\n\t\t\t\t\tbool isDeltaLight;\n\n\t\t\t\t\t// The shading context has already been advanced to the scatter location. \n\t\t\t\t\t// Now compute direct lighting after evaluating the local scattering albedo and extinction.\n\n\t\t\t\t\t// There is not multiple importance sampling here. Either a sun or sky sample is taken during an event. The result matches PBRT perfectly.\n                    // TODO implement MIS as in my other non spectral volume path tracer\n\t\t\t\t\tlightGenerateSample(ptc, sampleDirection, lightL, lightPdf, beamTransmittance, isDeltaLight);\n\t\t\t\t\tphaseEvaluateSample(ptc, sampleDirection, lightL, bsdfL, bsdfPdf);\n\t\t\t\t\tfloat3 Lv = lightL * bsdfL * beamTransmittance / (lightPdf);\n\n\t\t\t\t\tL += weight * throughput * Lv * transmittance * ptc.pathWeight;\n\t\t\t\t\tthroughput *= transmittance;\n\n\t\t\t\t\tif (insideAnyVolume(nextRay))\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat phaseValue;\n\t\t\t\t\t\tfloat phasePdf;\n\t\t\t\t\t\tphaseGenerateSample(ptc, nextRay.d, phaseValue, phasePdf);\n\t\t\t\t\t\thasScattered = true;\n\t\t\t\t\t\tthroughput *= phaseValue / phasePdf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (insideAnyVolume(nextRay))\n\t\t\t\t{\n\t\t\t\t\t//step--;\t// to not have internal subdivision affect path depth\n\t\t\t\t\tptc.nullMaterial = false;\n\t\t\t\t}\n\t\t\t\telse // out of any volume\n\t\t\t\t{\n\t\t\t\t\t// In this case we are getting out of a volume in case of a nullmaterial. If the ray has not scattered we want to sample distance lighting.\n\t\t\t\t\t// Otherwise, if the ray has been scattered or absorbed, we should not sample the distance lighting (it is already correctly sampled on the path vertex)\n\t\t\t\t\t// This is tested with hasScattered and is mandatory to succesfully pass the furnace test correctly with multi scattering.\n\t\t\t\t\tif (!hasScattered)\n\t\t\t\t\t{\n\t\t\t\t\t\tL += getSkyRadiance(ptc.SunDirPow, ray.d) * ptc.pathWeight;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Exit if no more intersections are found (opaque or volume) then accumulate distant lighting. (outside of the medium bounding volume)\n\t\t\t\tif (!getNearestIntersectionFullVolume(nextRay, P))\n\t\t\t\t{\n\t\t\t\t\tL += getSkyRadiance(ptc.SunDirPow, ray.d) * ptc.pathWeight;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n                \n\t\t\t}\n\n\t\t\tray = nextRay;\n\t\t\tstep++;\n\t\t}\n    \n\t}\n\n    \n    fragColor = float4(L, 1.0f);\n}\n\n\n\n", "buffer_c_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Combine the just traced BufferC with history BufferD\n// Reset accumulation if needed according to input\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n    \n    bool bFullReset = FullReset;  \n    bFullReset = bFullReset || texelFetch(iChannel2, ivec2(PIX_RESETACCUM), 0).x > 0.0f;\n    \n    fragColor = texture(iChannel0, uv) + (bFullReset ? float4(0.0f) : texture(iChannel1, uv));\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1191, 1191, 1212, 1212, 1306], [1308, 1308, 1369, 1369, 1658]], "test": "untested"}
{"id": "NdKGDz", "name": "The Abyss", "author": "dean_the_coder", "description": "The Abyss movie from 1989, where a friendly 'visitor' has a look around the underwater habitat.\n(It's deliberately a bit dark.)\nYouTube: https://youtu.be/SZqlIZMQU6U\nYouTube (360°): https://youtu.be/-ayBRXhEDoU", "tags": ["3d", "raymarching", "reflection", "refraction", "water", "caustics", "movie", "tentacle", "cineshader"], "likes": 47, "viewed": 7628, "published": 3, "date": "1631364085", "time_retrieved": "2024-07-30T19:02:03.511031", "image_code": "// 'The Abyss' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NdKGDz (YouTube: https://youtu.be/SZqlIZMQU6U)\n//\n// YouTube: https://youtu.be/SZqlIZMQU6U\n// YouTube (360°): https://youtu.be/-ayBRXhEDoU\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Abyss movie from 1989, where a friendly 'visitor'\n// has a look around an underwater habitat.\n//\n// Quote: \"Keep your pantyhose on...\"\n//\n// Tricks to get the performance:\n// - The water and scene are raymarched separately, as only\n//   the water is reflective. When reflecting only the background\n//   needs to be processed.\n//   This also allows different max marching steps for each.\n// - Similarly I have two normal functions.\n//   One for the water, one for everything else.\n// - Textures applied during the lighting calculations, as far\n//   as possible.\n// - Fake shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define minH(a, b)\t{ float h_ = a; if (h_ < h.x) h = vec2(h_, b); }\n\nfloat t, g = 0., g2 = 0.;\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max2(v.yz)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, vec2 hr) {\n\tp.x -= clamp(p.x, 0., hr.x);\n\treturn L(p) - hr.y;\n}\n\nfloat honk(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xy *= rot;\n\tfloat d = cap(p, vec2(h * .88, r));\n\tp.x -= h;\n\treturn d;\n}\n\n// Find most dominant uv coords.\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.yz : n.y == m ? p.xz : p.xy;\n}\n\nfloat surf(vec2 p1, vec2 p2) {\n\tfloat d = t * .4;\n\treturn n31(vec3(p1.x + d, p1.y, d)) * .3 + n31(vec3(p2, d) * 2.) * .1 + n31(vec3(p2 + d * .5, d) * 3.6) * .05;\n}\n\nfloat face(vec3 p, float o) {\n\tfloat f, d,\n\t      ox = p.x;\n\tp.x = abs(p.x) - .15;\n\tp.y += .05;\n\tp.z += .15 - .3 + .3 * S(27., 30., t);\n\tf = S(29.5, 31., t);\n\td = L(p) - .08;\n\tp.x = ox;\n\tp.y -= .3 - 1. + cos(ox * 1.5 * (.3 + f * .8));\n\to = max(o, -box(p, vec3(.15 + f * .1, .02 + f * .015, .09)));\n\treturn -smin(-o, d, .03);\n}\n\nfloat wat(vec3 p) {\n\tvec3 h1, h2, h3, h4,\n\t     op = p;\n\tp.z -= 3.;\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Pool.\n\tfloat d, s = surf(p.xz, op.xz);\n\n\t// Clip pool to pool walls.\n\td = max(p.y + 6., box(p, vec3(8, 66, 8)));\n\n\t// Tentacle.\n\tp -= vec3(3, -7, 3);\n\tvec3 phNow = vec3(.3, .1, 0) * S(6., 10., t);\n\tphNow = mix(mix(mix(mix(mix(phNow, vec3(.37, -.12, 0), S(11., 13., t)), vec3(.3, .1, 0), S(14., 16., t)), vec3(1.09, .23, 0), S(16., 20., t)), vec3(.3, .1, 0), S(22., 24., t)), vec3(.31, .02, 1), S(24., 27., t));\n\tphNow *= S(35.5, 34., t);\n\tphNow.x += .01;\n\tp.y -= .2 * sin(t);\n\tmat2 bf = rot(phNow.z * .9);\n\tp.xz *= rot(.8 - phNow.y * 2.);\n\th1 = vec3(1.4, phNow.x * 4.5, 1.3 * (.5 + .5 * phNow.x));\n\td = smin(d, honk(p, rot(h1.x), h1.y, mix(1.5, h1.z, sat(p.y / h1.y))), 2.5); // angle, length, radius\n\tp.xy *= bf;\n\th2 = vec3(-.7 * phNow.x, h1.yz * vec2(.8, .9));\n\td = smin(d, honk(p, rot(h2.x), h2.y, mix(h1.z, h2.z, sat(p.x / h2.y))), .2);\n\tp.xz *= rot(-phNow.y);\n\th3 = vec3(-.4 * phNow.x, h2.yz * vec2(2.5, .7));\n\td = smin(d, honk(p, rot(h3.x), h3.y, mix(h2.z, h3.z, sat(p.x / h3.y))), .1);\n\tp.xz *= rot(phNow.y * -3.);\n\tp.xy *= bf;\n\th4 = vec3(-.2 * phNow.x, h3.yz * vec2(.4 + dot(phNow.xz, vec2(.15, 1)), .7));\n\td = smin(d, honk(p, rot(h4.x), h4.y, mix(h3.z, h4.z, sat(p.x / h4.y))), .2);\n\td -= s * S01(L(p) - .5 * (S(26.5, 27.5, t) - S(34., 34.5, t)));\n\td = face(p.zyx, d);\n\tg2 += .01 / (4. + d * d);\n\treturn d;\n}\n\nfloat pipe(vec3 p, float r) { return L(p.yz) - r - min(step(.96, fract(p.x * .2)) * r * .2, .1); }\n\nvec2 env(vec3 p) {\n\tp.z -= 3.;\n\tfloat d = max(abs(p.z - 30.), 20. - p.x);\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Left wall.\n\td = min(min(d, max(abs(20. - abs(p.z)) - 1.5, p.x - 24.)), 34. - p.z);\n\n\t// Right walls.\n\td = min(min(d, max(abs(25. - abs(p.x)) - 1.5, p.z - 7.7 - step(p.x, 0.) * 12.)), max(abs(5.2 - p.z) - .1, 24. - p.x));\n\n\t// Ceiling.\n\td = smin(d, 10. - p.y, 1.);\n\n\t// Right corner box.\n\td = min(d, max(box(p - vec3(21, 0, 12.6), vec3(2.5, 66, 6)), -box(p - vec3(32, 0, 12.6), vec3(10, 66, 5))));\n\n\t// Left door.\n\td = max(d, .5 - box(p - vec3(4, 0, 20), vec3(4, 4, 2)));\n\n\t// Right doors.\n\tvec3 q = p;\n\tq.y -= .8;\n\tq.z = abs(q.z - 7.) - 5.;\n\tif (p.x > 0.) d = max(max(d, 3. - box(q, vec3(26, 2, 0))), 4. - box(q, vec3(15.4, 2.8, 1)));\n\tvec2 h = vec2(d, 3);\n\n\t// Lamp.\n\td = cap(p.yxz - vec3(5, 23, -3), vec2(1.2, .6));\n\tg += .02 / (1. + d * d);\n\tminH(d, 5.);\n\n\t// Ground/pool hole.\n\tminH(max(p.y + 5., -box(p, vec3(8, 66, 8))), 2.);\n\n\t// Wall pipes.\n\tq = p.yxz - vec3(1, 20.5, 6.4);\n\tq.y = abs(abs(q.y) - .5) - .5;\n\td = pipe(q, .2);\n\n\t// LHS big jobs.\n\tq = p - vec3(0, 9, 18.5);\n\tq.y = abs(q.y) - .6;\n\td = min(d, pipe(q, .5));\n\n\t// Light wires.\n\tq = p.yzx - vec3(0, -11, 23.5);\n\tq.y = abs(abs(q.y) - 6.) - .3;\n\td = min(d, pipe(q, .2));\n\n\t// Roof big jobs.\n\tq = p - vec3(0, 9, 10);\n\tq.z = abs(abs(q.z + 3.5) - 3.) - 1.;\n\td = min(d, pipe(q, .7));\n\n\t// Corridor pipe.\n\td = min(d, pipe(p - vec3(0, -3, 32), 1.));\n\n\t// Floor pipe.\n\tq = p.zxy - vec3(1, 23, -4);\n\td = min(d, max(pipe(q, .8), p.z + 3.));\n\tq.x += 4.;\n\tminH(min(d, L(q) - .8), 4.);\n\treturn h;\n}\n\n// Environment normal.\nvec3 Ne(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * env(p + e * h).x;\n\t}\n\n\treturn U(n);\n}\n\n// Water normal.\nvec3 Nw(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * wat(p + e * h);\n\t}\n\n\treturn U(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float d) {\n\tp += d * n;\n\treturn min(wat(p) * .4, env(p).x) / d;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -4e-4); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, vec2 h) {\n\tif (h.y == 5.) return vec3(1.8 * L(n.xz) + .2);\n\tvec3 c, ld2,\n\t     ld = U(vec3(0, -5, 0) - p);\n\tfloat l1, l2, fre,\n\t      ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      sha = 1.,\n\t      l2c = 1.;\n\tvec2 spe = vec2(1.22, .1);\n\tif (h.y == 1.) {\n        // Tentacle.\n\t\tc = vec3(.35, .71, .53) * 1.6 * S(1., -5., p.y);\n\t\tspe = vec2(100, 8);\n\t}\n\telse {\n\t\tfloat n10 = n31(p * 10.);\n\t\tif (h.y == 3.) {\n            // Walls.\n\t\t\tc = vec3(1, .8, .6) - n10 * .06 - n31(p * .5) * .1;\n\t\t\tl2c = .05;\n\t\t}\n\t\telse if (h.y == 4.) {\n            // Pipes.\n\t\t\tc = vec3(1.85, .4, .235);\n\t\t\tspe = vec2(4, .3);\n\t\t}\n\t\telse if (h.y == 2.) {\n            // Chevrons.\n\t\t\tfloat f = step(-6., p.y) * step(max2(abs(p.xz * mat2(.7, .7, -.7, .7) - 2.)), 10.);\n\t\t\tc = mix(vec3(.2), f * (.01 + step(.5, fract(p.x + .75))) * vec3(16, 6, 1), f) * (.4 + .6 * n10);\n\t\t}\n\n\t\tsha = .3 + .7 * sat(S(-3.5, -2., p.y) + step(p.y, -5.));\n\n\t\t// Caustics.\n\t\tvec2 uv = proj(p, n) * .3 + t * .1,\n\t\t     dd = vec2(.1, 0);\n\t\tdd = vec2(surf(uv + dd, uv.yx + dd), surf(uv + dd.yx, uv.yx + dd.yx));\n\t\tc += pow(S01(abs(L((surf(uv, uv.yx) - dd) / .05) - .5)), 3.) * 4.;\n\t}\n\n\t// Primary and secondary lights.\n\tld2 = U(vec3(10, 15, 10) - p);\n\tl1 = sat(.1 + .9 * dot(ld, n)) * (.4 + .6 * ao);\n\tl2 = sat(dot(ld2, n)) * .01 + pow(sat(dot(rd, reflect(ld2, n))), spe.x) * spe.y;\n\tfre = S(.7, .8, 1. + dot(rd, n)) * .1;\n\n\t// Light falloff.\n\tl1 *= S(25., 1., L(vec3(0, -5, 0) - p)) * .8 + .025;\n\tl2 *= (.5 * S(30., 45., L(p)) + S(30., 5., L(vec3(10, 15, 10) - p))) * l2c * ao;\n\tl1 += S01(g2);\n\n\t// Combine into final color.\n\treturn mix(l1 * sha * vec3(.12, 1, 2.5) * c + l2, vec3(.012, .1, .25), fre * sha) + g;\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0),\n\t     col = vec3(0);\n\tfloat i, d;\n\n\t// March the water.\n\tfor (i = Z0; i < 70.; i++) {\n\t\td = wat(p);\n\t\tif (abs(d) < .0015) break;\n\t\tp += d * rd;\n\t}\n\n\tvec2 h;\n\tif (abs(d) < .0015) {\n\t\tvec3 ord,\n\t\t     n = Nw(p);\n\t\tcol = lights(p, rd, n, vec2(d, 1));\n\t\tvec3 watP = p;\n\t\tord = rd;\n\n\t\t// Hit the water - Get reflection.\n\t\trd = U(reflect(p, n));\n\t\tfor (i = Z0; i < 120.; i++) {\n\t\t\th = env(p);\n\t\t\tif (abs(h.x) < .0015) break;\n\t\t\tp += h.x * rd;\n\t\t}\n\n\t\tif (abs(h.x) < .0015) col = mix(col, lights(p, rd, Ne(p), h) * fog(watP - p), .5);\n\n\t\t// ...and now the refraction.\n\t\tp = watP;\n\t\trd = refract(ord, n, .75);\n\t}\n\telse p = vec3(0);\n\n\t// March the environment.\n\tfor (i = Z0; i < 70.; i++) {\n\t\th = env(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\tp += h.x * rd;\n\t}\n\n\treturn col + lights(p, rd, Ne(p), h) * fog(p);\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(40., 39., t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 m = mix(vec2(.744, .175), vec2(-.138, .138), S(0., 3.5, t)),\n\t\t uv = (fc - .5 * R.xy) / R.y,\n\t\t q = fc.xy / R.xy;\n\tm = mix(mix(mix(mix(mix(m, vec2(.031, -.208), S(2.5, 7., t)), vec2(.031, .042), S(8.5, 12., t)), vec2(.313, .208), S(16.5, 21., t)), vec2(.069, -.142), S(23., 28.5, t)), vec2(0, -.554), S(34., 37., t));\n\tvec3 lookAt = vec3(0, -.2, 1);\n\tlookAt.yz *= rot(m.y);\n\tlookAt.xz *= rot(m.x);\n\tvec3 r = U(cross(vec3(0, 1, 0), lookAt)),\n         col = scene(U(lookAt + r * uv.x + cross(lookAt, r) * uv.y));\n\tcol *= .1 + .9 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1471, 1471, 1490, 1490, 1831], [1833, 1833, 1872, 1872, 1954], [1956, 1956, 1976, 1976, 2000], [2002, 2002, 2022, 2022, 2053], [2055, 2055, 2074, 2074, 2141], [2143, 2143, 2170, 2170, 2236], [2238, 2238, 2266, 2266, 2319], [2321, 2321, 2375, 2375, 2450], [2452, 2485, 2512, 2512, 2597], [2599, 2599, 2629, 2629, 2762], [2764, 2764, 2793, 2793, 3090], [3092, 3092, 3111, 3111, 4539], [4541, 4541, 4570, 4570, 4639], [4641, 4641, 4659, 4659, 6227], [6229, 6252, 6269, 6269, 6483], [6485, 6502, 6519, 6519, 6731], [6733, 6761, 6796, 6796, 6851], [6853, 6853, 6872, 6872, 6905], [6907, 6907, 6953, 6953, 8603], [8605, 8605, 8626, 8626, 9442], [9532, 9532, 9592, 9592, 9675], [9677, 9677, 9722, 9722, 10357]], "test": "untested"}
{"id": "NsV3Wz", "name": "sUBLIMATING tONES & hUES", "author": "xenn", "description": " ~ like onion skin layers of smokey glass marbles , sort of, but maybe not ~\n\n. Try going full screen then Alt-1 (to refresh/force 100% pixel canvas extents\nmouse click influences general direction ", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 9, "viewed": 524, "published": 3, "date": "1631363224", "time_retrieved": "2024-07-30T19:02:04.684893", "image_code": "// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                   //   col = max(col,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                  //   col2 = min(col,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),(550.0 * abs(sin(iTime / 13.0)))+100.);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(-1,1,2));\n    float diff=clamp(dot(n,light),0.05,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.05\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 32;\nfloat blur = 1.0; \nfloat falloff = 4.0; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = -0.00051;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .95;\nconst float iBlobEdgeSmoothing        = .08;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .69;\nconst float iBlob2PowFactor           = 30.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 3.0;\nconst float iColorShiftOfRadius       = -.5;\nconst float iFeedbackMouseShiftFactor = .0013;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 3.1))), dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * (iFeedbackMouseShiftFactor * (2.0 * sin(iTime / 2.0)))\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * ( iFeedbackColorShiftZoom * (1.5 * sin(iTime / 2.81))) * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.br - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n    \n    vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n    prevColor2 *= iFeedbackFadeRate;\n    \n    prevColor2 *= mix(prevColor , prevColor2,(0.75 + ( 0.5 * cos(iTime))));\n\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    \n//         vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel2,uv);\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col,col2,0.025);\n  \n // fragColor=blend;\n  \n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.0125);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 242, 242, 321], [323, 323, 346, 346, 501], [503, 503, 560, 560, 1914]], "test": "untested"}
{"id": "NdVGWz", "name": "Slowtember10-12: Cafe/Date", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 12, "viewed": 284, "published": 3, "date": "1631355126", "time_retrieved": "2024-07-30T19:02:05.685218", "image_code": "#define PI 3.1416\n#define FAR 10.0\n#define MAX_RAY 92\n#define MAX_REF 16\n#define FOV 1.57\n#define OBJ_MIN_D 0.01\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nfloat smin( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\nfloat smod(float x, float m) {\n    return (1. - step(m * .95, mod(x, m))) * min(m, mod(x, m) * 1.05) + step(m * .95, mod(x, m)) * min(m, mod(-x, m) * 40.); \n}\n\nvec3 rot(vec3 v, vec3 c, vec3 a) {\n    return (v - c)\n    * mat3(1, 0, 0,\n         0, cos(a.x * 2. * PI), sin(a.x * 2. * PI),\n         0, -sin(a.x * 2. * PI), cos(a.x * 2. * PI))\n    * mat3(cos(a.y * 2. * PI), 0, sin(a.y * 2. * PI),\n         0, 1, 0,\n         -sin(a.y * 2. * PI), 0, cos(a.y * 2. * PI))\n    * mat3(cos(a.z * 2. * PI), sin(a.z * 2. * PI), 0,\n         -sin(a.z * 2. * PI), cos(a.z * 2. * PI), 0,\n         0, 0, 1) + c;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere(vec3 q, vec3 p, float r) {\n    return length(q - p) - r;\n}\n\nfloat plane(vec3 q, vec3 d, float offset) {\n    return dot(d, q) + offset;\n}\n\nfloat capsule(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab1 = p2 - p1;\n    vec3 ap1 = q - p1;\n    float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n    t1 = clamp(t1, 0., 1.);\n    vec3 c1 = p1 + t1 * ab1;\n    return length(q - c1) - r;\n}\n\nfloat torus(vec3 q, vec3 p, float r1, float r2) {\n    q -= p;\n    float x = length(q.xz) - r1;\n    return length(vec2(x, q.y)) - r2;\n}\n\nfloat box(vec3 q, vec3 p, vec3 s, float r) {\n    return length(max(abs(q - p) - s + r, 0.)) - r;\n}\n\nfloat cyl(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab2 = p2 - p1;\n    vec3 ap2 = q - p1;\n    float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n    vec3 c2 = p1 + t2 * ab2;\n    float d = length(q - c2) - r;\n    float y = (abs(t2 - .5) - .5) * length(ab2);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    return e + i;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define OBJ_COUNT 6\n\nfloat objects[OBJ_COUNT] = float[](FAR, FAR, FAR, FAR, FAR, FAR);\nvec3 objectsColor[OBJ_COUNT] = vec3[](vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.));\nconst float objectsRef[OBJ_COUNT] = float[](.4,.0,.0,.0,.3,.1);\n\nvoid setObjects(vec3 q) {\n    objects[0] = FAR;\n    objects[0] = min(objects[0], plane(q, vec3(.0, 1., .0), 0.));\n    \n    vec3 q2 = q;\n    q2.x = mod(q.x, 2.);\n    q2.z = mod(q.z, 1.);\n    \n    float chair_seed = abs(floor(q.x)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    float table_seed = abs(floor(q.x * .5)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    \n    vec3 q3 = q2;\n    if(q2.x < 1.) {\n        q3.x = 1. - q2.x + .1 * rand(chair_seed++);\n    } else if (q2.x < 2.) {\n        q3.x -= 1. + .1 * rand(chair_seed++);\n    }\n    \n    vec3 q4 = rot(q3, vec3(.5), vec3(.0, .04 * (rand(chair_seed++) - .5),.0));\n    \n    objects[1] = FAR;\n    objects[1] = min(objects[1], box(q4, vec3(.5, .3, .5), vec3(.2, .02, .2), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .69), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .31), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .31), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .69), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .59, .5), vec3(.01, .05, .2), .005));\n    \n    objects[2] = FAR;\n    objects[2] = min(objects[2], box(q4, vec3(.49, .33, .5), vec3(.24, .02 + .0005 * sin(q2.x * 200.) * sin(q2.z * 200.), .25), .1));\n    objects[2] = min(objects[2], box(q4, vec3(.65, .59, .5), vec3(.03 + .0005 * sin(q2.y * 200.) * sin(q2.z * 200.), .1, .22), .05));\n    \n    q2 = rot(q2, vec3(.5), vec3(.0, .01 * (rand(table_seed++) - .5),.0));\n    \n    objects[3] = FAR;\n    objects[3] = min(objects[3], box(q2, vec3(1., .5, .5), vec3(.3, .02, .3), .0));\n    \n    objects[4] = FAR;\n    objects[4] = min(objects[4], cyl(q2, vec3(1., .0, .5), vec3(1., .5, .5), .05));\n    \n    vec3 cup_center = vec3(.2 - .1 * rand(chair_seed++), .0, .5 + .2 * (rand(chair_seed++) - .5));\n    \n    vec3 q5 = rot(q3, cup_center, vec3(.0, rand(chair_seed++),.0));\n    \n    objects[5] = FAR;\n    objects[5] = min(objects[5], cyl(q5, cup_center + vec3(.0, .51 + length(q3.xz - cup_center.xz)* .3, .0), cup_center + vec3(.0, .52  + length(q3.xz - cup_center.xz)* .3, .0), .04));\n    objects[5] = min(objects[5], torus(q5, cup_center + vec3(.0, clamp(q3.y, .54, .56), .0), .02 + (q3.y - .54) * .6, .004));\n    \n    objects[5] = min(objects[5], torus(rot(q5, cup_center + vec3(.0, .55, .04), vec3(.0, .0, .25)), cup_center + vec3(.0, .55, .04), .01, .004));\n}\n\n#define TILING .3\n\nvoid setObjectColors(vec3 q) {\n\n    bool tile = (mod(q.x, 2. * TILING) < TILING) ^^ (mod(q.z, 2. * TILING) < TILING);\n\n    objectsColor[0] = tile ? vec3(.9) : vec3(.4, .0, .0);\n    objectsColor[1] = vec3(.8, .3, .1);\n    objectsColor[2] = vec3(.9);\n    objectsColor[3] = vec3(.8, .3, .1);\n    objectsColor[4] = vec3(.3);\n}\n\nfloat map(vec3 q) {\n    float d = FAR;\n    \n    setObjects(q);\n    \n    for(int i = 0; i < OBJ_COUNT; i++)\n        d = min(d, objects[i]);\n    \n    return d;\n}\n\nvec3 mapColor(vec3 q, float t) {\n    setObjects(q);\n    setObjectColors(q);\n    \n    vec3 c = vec3(.0);\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             c = objectsColor[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return c;\n}\n\nfloat mapRef(vec3 q, float t) {\n    setObjects(q);\n    \n    float ref = .0;\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             ref = objectsRef[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return ref;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, int max_d) {\n    float t = 0., d;\n    for(int i = 0; i < max_d; i++){\n        d = map(ro + rd * t);\n        if(abs(d) < .001 * (t * .25 + 1.) || t > FAR)  break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    //Tetrahedral normal\n    const vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 getHitColor(vec3 ro, vec3 rd, float t, vec3 lightPos) {\n    vec3 hit = ro + rd * t;\n    vec3 norm = normal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = mapColor(hit, t) * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return vec4(color, atten * occ);\n}\n\nvec3 getColor(vec2 uv, vec3 ro, vec3 dir, vec3 lightPos) {\n    vec3 fwd = normalize(dir);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    float t = rayMarch(ro, rd, MAX_RAY);\n    \n    vec3 outColor = vec3(.0);\n    \n    if(t < FAR) {\n        vec3 hit = ro + rd * t;\n        vec3 norm = normal(hit);\n        vec4 color = getHitColor(ro, rd, t, lightPos);\n        \n        vec3 ref = reflect(rd, norm);\n        float refQ = mapRef(hit, t);\n        float t2 = refQ <= .001 ? .0 : rayMarch(hit + ref * .1, ref, MAX_REF);\n        vec4 color2 = refQ <= .001 ? vec4(.0) : getHitColor(hit + ref * .1, ref, t2, lightPos);\n    \n        outColor = (color.xyz * (1. - refQ) + refQ * color2.xyz * color2.w) * color.w;\n    }\n    \n    outColor = mix(min(outColor, 1.), vec3(.0), 1. - exp(-t*t/FAR/FAR*10.));\n    \n    return outColor;\n}\n\n#define CAMERA_SPEED .5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pos = vec3(1. + 3. * cos(iTime * CAMERA_SPEED), 1. + sin(iTime * CAMERA_SPEED) * .2, 3. * sin(iTime * CAMERA_SPEED));\n    vec3 dir = vec3(3. * cos(iTime * CAMERA_SPEED + PI), -1.5, 3. * sin(iTime * CAMERA_SPEED + PI));\n    vec3 light = vec3(.0, 4., .0);\n    \n    vec3 c = getColor(uv, pos, dir, light);\n    \n    fragColor = vec4(sqrt(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 301, 301, 386], [388, 388, 407, 407, 576], [578, 578, 618, 618, 712], [714, 714, 744, 744, 872], [874, 874, 908, 908, 1309], [1474, 1474, 1513, 1513, 1545], [1547, 1547, 1590, 1590, 1623], [1625, 1625, 1675, 1675, 1858], [1860, 1860, 1909, 1909, 1994], [1996, 1996, 2040, 2040, 2094], [2096, 2096, 2142, 2142, 2444], [2861, 2861, 2886, 2886, 5299], [5644, 5644, 5663, 5663, 5803], [5805, 5805, 5837, 5837, 6159], [6161, 6161, 6192, 6192, 6489], [6492, 6492, 6537, 6537, 6724], [6726, 6726, 6747, 6772, 6938], [6940, 6940, 6977, 6977, 7247], [7413, 7413, 7473, 7473, 8071], [8073, 8073, 8131, 8131, 8998], [9025, 9025, 9080, 9080, 9535]], "test": "untested"}
{"id": "fdV3Rm", "name": "Candy Stacks", "author": "byt3_m3chanic", "description": "Some work on timing / animation / stacking stuff. Probably have more around this theme - I like the mechanics / taking vec - time + traveled to change animation", "tags": ["raymarching", "animation", "truchet", "motion", "timing"], "likes": 19, "viewed": 428, "published": 3, "date": "1631333802", "time_retrieved": "2024-07-30T19:02:06.694519", "image_code": "/**\n    \n    Candy Stacks \n    @byt3_m3chanic | 09/10/21\n\n    work on some timing/motion stuff.\n    built mechanics first\n    \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    150.\n#define MIN_DIST    .001\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0., 1.); }\n\n//@iq shapes and extrude\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat cyl( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat opx( in vec3 p, float d, in float h ) {\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n// gear\nfloat gear(vec3 p, float radius, float thick, float hl) {\n    float hole = (radius*.25);\n    float sp = floor(radius*PI);\n    float gs = length(p.xy)-radius;\n    float gw = abs(sin(atan(p.y,p.x)*sp)*.2);\n    gs +=smoothstep(.05,.45,gw);\n    float cog= hl<1. ? max(opx(p,gs,thick),-(length(p.xy)-hole)) : opx(p,gs,thick);\n    return cog;\n}\n// consts\nconst float size = 4.;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n// globals\nfloat floorspeed;\nfloat ga1,ga2,ga3,ga4;\n\nvec3 hit=vec3(0),hitPoint,gid,sid;\nvec3 speed = vec3(0);\nmat2 r45,turn,spin;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id;\n    vec3 p2, q;\n    for(int i = 0; i<2; i++)\n    {\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n\n        float ff = qf-size;\n        float lent= ff<floorspeed-3. ? 7. : clamp(ga4,0.,1.)*7. ;\n        float fent= ff<floorspeed-3. ? 5. : clamp(ga4,0.,1.)*5. ;\n        vec3 r = q;\n        p2=q;\n        q.z=abs(q.z)-19.;\n        \n        float pole = (ff<floorspeed+1.&& i==0) ? min(cyl(q-vec3(0,lent+1.5,0),.25,lent+.5),\n        length(q-vec3(0,(lent+1.5)*2.,0))-(.75)) : 1e5;\n        \n        float pcap = max(cyl(q,.85,1.), -cyl(q,.45,2.) );\n        pcap = min(box(q,vec3(1.9,.1,1.5)),pcap);\n        pole=min(pcap,pole);\n        if(pole<res.x){\n            res = vec2(pole,5.);\n            hit=q;\n            gid = vec3(qf,0,0);\n        }  \n        \n        float qw=q.z - 2.;     \n        float wave = .5*sin(qw*1.5-T*4.+ff);\n        wave = mix(wave,0.,clamp(1.-((qw-1.5)*.5),0.,.8));\n        q.x-= wave*2.;\n        q.y-= wave;\n        \n        vec3 fq = q-vec3(0,(lent*2.),fent);\n        float flag=(ff<floorspeed+1.&& i==0) ? box(fq,vec3(.05,2.5,fent)) : 1e5;\n        if(flag<res.x){\n            res = vec2(flag,1.);\n            hit=fq;\n            gid = vec3(qf,0,0);\n        }\n\n        lent= ff<floorspeed+5. ? 0. : ff>floorspeed+6. ? 3.25 : clamp(1.-ga3,0.,1.)*3.25;\n        float ent= ff<floorspeed+35. ? 0. : ff>floorspeed+38. ? 38. : clamp(1.-ga3,0.,1.)*38.;\n        \n        if(i==0) ent = -ent;\n        float d3=box(r-vec3(0,(lent*3.)-2.,ent),vec3(2,2,14.));\n        if(d3<res.x){\n            res = vec2(d3,3.);\n            hit= r-vec3(0,(lent*3.)-2.,ent);\n            gid = vec3(qf,0,0);\n        }\n        \n    }\n\n    vec3 pb = vec3(p.x-speed.x-25.,p.y-19.,p.z-11.);\n    pb.xy*=spin;\n    float bls = gear(pb, 9.,1.5,1.);\n    vec3 pp = vec3(p.x-speed.x-29.,p.y-3.,p.z);\n    vec3 pq = vec3(p.x-speed.x-16.,p.y-3.,p.z);\n    \n    float beam = min(length(pp.xy)-.45,length(pq.xy)-.45);\n    beam = min(cyl(pb.yzx-vec3(0,22,0),1.25,25.25),beam);\n    beam = min(cyl(pb+vec3(0,0,2.4),.5,1.85),beam);\n    pp.xy*=turn; pq.xy*=turn;\n    bls = min(gear(pp, 3.,14.75,0.),bls);\n    bls = min(gear(pq, 3.,14.75,0.),bls);\n   \n    if(bls<res.x){\n        res=vec2(bls,4.);\n        hit=p2;\n    }\n    if(beam<res.x){\n        res=vec2(beam,5.);\n        hit=pb;\n    }\n    float fl=max(p.y,-box(p2,vec3(8.,4.,16.)) );\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 hue(float t){ \n    const vec3 c = vec3(.122,.467,.918);\n    return .45 + .35*cos(PI2*t*(c+vec3(.878,.969,.851))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,128);\n    hitPoint=hit;  \n    sid=gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(25.,125.,-75.);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint+vec3(size,5,size);\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.;\n        for( float t=.0; t < 38.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += t<12.? h*.5 : h;\n            if( shdw<MIN_DIST || t>38. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.3 * pow(max(dot(view, ret), 0.), 20.);\n        float clr;\n        \n        // materials\n        if(m==1.){\n            h=vec3(.745,.933,.929);\n            vec2 f = fract(hp.zy)-.5;\n            if(f.x*f.y>0.||hp.y<0.) h*=.25;    \n            ref = h-fresnel;     \n        }\n        if(m==2.){\n            h=vec3(.192,.306,.302);\n            vec2 f = fract(hp.xz/(dbl*2.))-.5;\n            if(f.x*f.y>0.) h=vec3(.220,.698,.682);\n            if( hp.y<1.1 ) h=vec3(.133,.247,.243);\n            ref =(f.x*f.y>0. && hp.y>1.1) ? vec3(.35)-fresnel:vec3(0.); \n        }\n        if(m==3.){\n            h = hue((50.+sid.x)*.0025);\n            float px = .05;\n            vec2 grid = fract(hp.xz/hlf)-.5;\n            vec2 id = floor(hp.xz/hlf);\n            float hs = hash21(id+sid.x);\n            if(hs>.5) grid.x*=-1.;\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n            float circle = length(gx)-.5;\n            circle=(chk>.5 ^^ hs<.5) ? smoothstep(-px,px,circle) : smoothstep(px,-px,circle);\n            h = mix(h, vec3(.08),circle);\n            if(hp.y<6.99) h=vec3(.8); \n            if(hp.y<6.99&&hp.y>6.) h=vec3(.2);\n            ref = (h*.4)-fresnel;\n        }\n        if(m==4.) {\n            ref = vec3(.1)-fresnel;\n            h=vec3(.2);\n        }\n        if(m==5.) {\n            ref = vec3(.2)-fresnel;\n            h=vec3(.4);\n        }\n        C = (diff*h)+spec;\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {   \n    // precal\n    r45=rot(-0.78539816339); \n    float time = (T+40.)*12.;\n    float tmod = mod(time, 10.);\n    float t3 = lsp(5., 10., tmod);\n    \n    float fmod = mod(time, 20.);\n    float t2 = lsp(10., 20., fmod);\n    \n    ga1 = (time*.1);\n    ga3 = (tmod<5.?t3+1. :t3);\n    ga4 = (fmod<10.?t2+1. :t2);\n    \n    speed = vec3(abs(ga1*size),0,0);\n    floorspeed=floor(speed.x);\n    turn=rot(ga1);\n    spin=rot(-ga1*.38);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*45.,-45.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    ro.yz*=r45;ro.xz*=r45;\n    rd.yz*=r45;rd.xz*=r45;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fill=vec3(1);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fill;\n        fill*=ref;\n    }\n    // mixdown \n    float vin = length((2.*F.xy-R.xy)/R.x)-.175;\n    C = mix(C,C*.5,smoothstep(.0,.8,vin));\n    C = clamp(C,vec3(.015),vec3(1));\n    // gamma\n    C = pow(C, vec3(.4545));\n    // output\n    O = vec4(C,1.);\n}\n//end\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 314, 314, 359], [360, 360, 381, 381, 436], [437, 437, 481, 481, 534], [536, 561, 588, 588, 677], [678, 678, 717, 717, 822], [823, 823, 868, 868, 961], [962, 970, 1027, 1027, 1308], [1527, 1527, 1548, 1548, 4114], [4116, 4116, 4146, 4146, 4385], [4387, 4387, 4432, 4432, 4662], [4664, 4664, 4682, 4682, 4785], [7447, 7447, 7488, 7505, 8549]], "test": "untested"}
{"id": "sdGGDR", "name": "waynoka oklahoma tornado, 1898", "author": "mxsage", "description": "Rough sketch (code not polished!).\nGood stuff is in BufferA, rest is just a bloom.\n\nattrib: \"clouds\" by Inigo Quilez\nhttps://www.shadertoy.com/view/XslGRr\n\nand \"6-Point Star Filter + Bloom\" by granito\n", "tags": ["volume", "clouds", "iq", "tornado"], "likes": 37, "viewed": 1160, "published": 3, "date": "1631307685", "time_retrieved": "2024-07-30T19:02:07.715789", "image_code": "vec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 0.01;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 0.02;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 0.08;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 0.16;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 0.32;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 0.64;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.28;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 2.56;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    color += GetBloom(uv) * 0.3;\n    color = vec3(color.x + color.y + color.z);\n    color /= 3.;\n        \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define NOISE_METHOD 2\n\n\n\nfloat rand(vec2 coord)\n{\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel1,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n\n   \n}\nfloat ground(in vec3 p, int oct)\n{\n    float n = noise(p*vec3(1., 0., 1.)*.1+vec3(34., 24., 0.));\n    float edge = p.y+n - 2.3;\n    float density = 0.;\n    if (edge > 0. && p.z < 9. && p.z > 8.)\n    {\n        float interpAmount = 0.3;\n        float scale = 2.;\n        if (edge > -interpAmount)\n        {\n            scale = mix(0., scale, pow(edge / -interpAmount, .8));\n        }\n        density = clamp(scale, 0., 1.)+density;\n    }\n    return density;\n}\n\nfloat groundClouds(in vec3 p, int oct)\n{\n    if (p.y < 1.)\n    {\n        return 0.;\n    }\n    float n = noise(p*vec3(1., 0., 1.)*.1+vec3(34., 24., 0.));\n    float edge = p.y+n - 3.4;\n    \n    float moveSpeed = 0.4;\n\n    float f = 0.;\n    p.y += edge;\n    p.y -= 3.;\n    vec3 q = p - vec3(-1.0,0.4,0.3)*(iTime*-moveSpeed);\n    \n    float g = 0.5+0.5*noise( q*.75);\n\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.23;\n    f += 0.12500*noise( q ); q = q*2.41;\n    f += 0.06250*noise( q ); q = q*2.62;\n    f += 0.03125*noise( q ); \n    f = pow(f, .5);\n    f *= .9;\n     \n    return max(1.0*f + 0.23 + p.y, 0.);\n}\n\nfloat tornado(in vec3 p, int oct)\n{\n    float density = 0.;\n        // tornado density\n    vec3 center = vec3(3.4, -0.5, 8.);\n    float verticalT = clamp((-p.y + 4.)*.16, 0.0, 1.);\n    float distCone = distance(p.xz, center.xz)-.1;\n    if (distCone > 2.2)\n    {\n        return 0.;\n    }\n    float dist = distCone\n        - noise(p - vec3(0.1,1.0, 0.1) * (iTime*-0.2))*.15*clamp(verticalT, .4, 1.)\n        - noise(p*vec3(.3, .7, .3)*10.5 - vec3(0.3,1.2,0.5) * (iTime*-.7))*.05*clamp(verticalT, .8, 1.);\n    \n    float edge = dist - pow(verticalT, 2.3)*3.5;\n    if (edge < 0.)\n    {\n        float interpAmount = 0.4;\n        float scale = 4.;\n        if (edge > -interpAmount)\n        {\n            scale = mix(0., scale, pow(edge / -interpAmount, .8));\n        }\n        density = scale+density;\n        \n    }\n    \n    return density;\n}\n\nfloat cloudsSky( in vec3 p, int oct )\n{\n\n    float moveSpeed = .04;\n    p.y -= 1.3;\n\tvec3 q = p - vec3(0.0,1.0,1.1)*((339.+iTime)*-moveSpeed);\n    float g = 0.5+0.5*noise(q*.2);\n    \n    float f;\n    if (p.y < .6)\n    {\n        f  = 0.50000*noise( q ); q = q*2.02;\n        f += 0.25000*noise( q ); q = q*2.23;\n        f += 0.12500*noise( q ); q = q*2.41;\n        f += 0.06250*noise( q ); q = q*2.62;\n        f += 0.03125*noise( q ); \n\n        f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    }\n    \n    vec3 center = vec3(3.4, -0.5, 8.);\n    float dist = distance(p.xz, center.xz);\n    dist = pow(dist, .5);\n    float final= max(1.5*f - 0.5 - p.y + clamp(2.0 - dist, 0., 1.0), 0.);\n\n    float pastNado = clamp((12. - p.z)+p.x*.4, 0., 2.)*.5;\n    final = final*pastNado;\n\n    return final;\n}\n\nconst vec3 sundir = normalize( vec3(-.6,-.4,0.5) );\n\nconst int kDiv = 1; // make bigger for higher quality\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\n    // bounding planes\t\n    const float yb = -3.0;\n    const float yt =  4.0;\n    float tb = (yb-ro.y)/rd.y;\n    float tt = (yt-ro.y)/rd.t;\n\n    // find tigtest possible raymarching segment\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        // above top plane\n        if( tt<0.0 ) return vec4(0.0); // early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        // inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    \n    vec2 uv = vec2(px) / iResolution.xy;\n    float dither = rand(uv + sin(iTime * 1.0) );\n    // dithered near distance\n    float t = tmin + 0.1*dither;\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    \n    for( int i=0; i<190*kDiv; i++ )\n    {\n       // step size\n       float dt = max(0.05,0.02*t/float(kDiv));\n\n       int oct = 5 - int( log2(1.0+t*0.5) );\n       \n       // sample cloud\n       vec3 pos = ro + t*rd;\n       float den = cloudsSky(pos,oct);\n       float gc = groundClouds(pos, oct) + tornado(pos, oct);\n       if( den>0.01 || gc>0.01) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - cloudsSky(pos+0.3*sundir,oct))/0.3, 0.0, 1.0 );\n           vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(1.0,0.6,0.3)*dif;\n           vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n           col.xyz *= lin;\n           // fog\n           col.xyz = mix(col.xyz,bgcol, 1.0-exp2(-0.075*t));\n           // composite front to back\n           col.xyz = mix(col.xyz, vec3(0.), gc);\n           col.w    = min(col.w*8.0*dt,1.0);\n           col.w += gc*.1;\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       // advance ray\n       t += dt;\n       // until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\n    vec3 col = vec3(.9);\n    // background sky\n    //col = vec3(0.76,0.75,0.86);\n    //col -= 0.6*vec3(0.90,0.75,0.95)*rd.y;\n\tcol += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n    \n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n\n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    // tonemap\n    col = smoothstep(0.5,1.1,col);\n \n    return vec4( col, 1.0 );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m =                iMouse.xy      /iResolution.xy;\n\n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 3.*(m.y-.5), cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tro = vec3(3., 3., 3.);\n    vec3 ta = ro + vec3(0., -.7, 1.);\n    mat3 ca = setCamera( ro, ta, 3.11);\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.1));\n    \n    vec4 c = render( ro, rd, ivec2(fragCoord-0.5) );\n    float v = (c.x+c.y+c.z)/3.;\n    \n    vec3 previous = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\n    fragColor = vec4(mix(vec3(v), previous, .5), 1.);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            vec3 tmpcol = vec3(0);\n            tmpcol += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            tmpcol += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            color += hsv2rgb( rgb2hsv(tmpcol) + vec3(0.,0.25,0.) ); //boost saturation\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            vec3 tmpcol = vec3(0);\n            tmpcol += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            tmpcol += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            color += hsv2rgb( rgb2hsv(tmpcol) + vec3(0.,0.25,0.) ); //boost saturation\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, k.wz), vec4(c.gb, k.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n    return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0.,1.);\n}\n\nvec2 hash21(float p) //1 in 2 out hash function\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy) * 2. - 1.;\n\n}\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    return vec2(\n        cos(rotation) * uv.x + sin(rotation) * uv.y,\n        cos(rotation) * uv.y - sin(rotation) * uv.x\n    );\n}\n\nfloat dist(vec3 a, vec3 b) { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 237], [239, 239, 293, 293, 1230], [1232, 1232, 1261, 1261, 1306], [1308, 1308, 1337, 1337, 1389], [1391, 1391, 1453, 1453, 1562], [1564, 1564, 1595, 1595, 1901], [1903, 1903, 1930, 1930, 2517], [2519, 2519, 2576, 2576, 2811]], "test": "untested"}
{"id": "fsGGWR", "name": "Voronoi Tracking Experiment 1", "author": "aiekick", "description": "based on the shader [url=https://www.shadertoy.com/view/tlKGDh]Physarum Polycephalum Simulation\n[/url] of [url=https://www.shadertoy.com/user/michael0884]michael0884[/url]\n\nuse mouse for add particles\nuse spacebar for clear the screen", "tags": ["voronoi", "experiment", "tracking"], "likes": 39, "viewed": 670, "published": 3, "date": "1631297536", "time_retrieved": "2024-07-30T19:02:08.626354", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Voronoi Tracking Experiment 1\n\n// based on the shader https://www.shadertoy.com/view/tlKGDh of michael0884\n\n// use mouse for add particles\n// use spacebar for clear the screen\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromoneInv(vec2 p)\n{\n\treturn getPheromone(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 100.0 / min(iResolution.x, iResolution.y);\n\tfloat f = getPheromoneInv(fragCoord).x;\n\tfloat fx = (f-getPheromoneInv(fragCoord + vec2(1,0)).x)/e;\n\tfloat fy = (f-getPheromoneInv(fragCoord + vec2(0,1)).x)/e;\n\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\t\n\tfloat diff = max(dot(vec3(0,0,1), n), 0.0);\n\tfloat spec = pow(max(dot(normalize(lightDirection), reflect(vec3(0,0,1),n)), 0.0), specularPower);\n\t\t\n    fragColor.rgb = lightDiffuse * diff + lightSpecular * spec; \n\tfragColor.rgb *= 1.5;\n\t\n    //fragColor = getPheromone(fragCoord);\n    \n\tfragColor.a = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle\n// x,y => pos [0 > iResolution.xy]\n// z   => angle [0 > 2pi]\n// abs(w) => sensor angle [0 > pi]\n// if (w > 0.0) => activation\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid SelectIfNearestNeighbor(inout vec4 pnb, vec2 p, vec2 dx)\n{\n    vec4 p_nb = getParticle(p + dx);\n    \n\tif(length(loop_d(p_nb.xy - p, iResolution.xy)) < length(loop_d(pnb.xy - p, iResolution.xy)))\n    {\n        pnb = p_nb;\n    }\n}\n\nvoid SearchForNearestNeighbor(inout vec4 pnb, vec2 p, float ring)\n{\n\t// sides\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,ring));\n\t\n\t// corners\n\tSelectIfNearestNeighbor(pnb, p, vec2(-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring));\n}\n\nvoid EmitParticle(vec2 g, inout vec4 p)\n{\n\tfloat rand = Random(g + p.xy).x;\n\t\n\tp.xy = g; // pos\n\tp.z = rand * 6.28318; // angle\n\n    // sensor angle and activation\n    p.w = mix(sensor_angle_rad_inf, sensor_angle_rad_sup, rand);\n}\n\nvoid MoveParticle(inout vec4 p)\n{\n    // left sensor\n\tfloat an = p.z + p.w;\n    vec2 sleft = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    // right sensor\n\tan = p.z - p.w;\n    vec2 sright = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    float diff_angle = \n        getPheromone(sleft).x - \n        getPheromone(sright).x;\n\t\n    p.z += dt * sensor_strenght * tanh(0.3 * diff_angle);\n\tp.xy += dt * particle_speed * vec2(cos(p.z), sin(p.z));\n    \n\tp.xy = loop(p.xy, iResolution.xy);\n}\n\nvoid PaintByMouse(vec2 g, inout vec4 p)\n{\n\tif (iMouse.z > 0.0)\n\t{\n\t\tif (length(g - iMouse.xy) < uMouseRadius)\n\t\t{\n\t\t\tEmitParticle(g, p);\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragParticles, in vec2 fragCoord )\n{\n\tfragParticles = getParticle(fragCoord);\n\t\n\tSearchForNearestNeighbor(fragParticles, fragCoord, 1.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 2.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 3.0);\n\t\n\tMoveParticle(fragParticles);\n\tPaintByMouse(fragCoord, fragParticles);\n\n\tif (iFrame < 1) // reset \n\t{\n\t\tfragParticles = vec4(0);\n        \n        // start shape\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        uv.y += sin(uv.x * 5.0) * 0.3;\n        uv.x = mod(uv.x, 0.1);\n        float st = 5.0 / iResolution.y;\n        if (length(uv) < st)\n            EmitParticle(fragCoord, fragParticles);\n\t}\n    \n    if (reset(iChannel3))\n        fragParticles = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define dt 0.25\n\n// mouse\nconst float uMouseRadius = 1.0;\n\n// particle\nconst float particle_speed = 5.0;\n\n// pheromones\nconst float gauss_coef = 1.4;\nconst float decay = 0.15;\n\n// sensor\nconst float sensor_strenght = 20.0;\nconst float sensor_distance = 20.0;\nconst float sensor_angle_rad_inf = 1.0;\nconst float sensor_angle_rad_sup = 1.8;\n\n// shading\nconst vec3 lightDiffuse = vec3(0.191553,0.267195,0.373984);\nconst vec3 lightSpecular = vec3(0.243903,1,0);\nconst vec3 lightDirection = vec3(0.08232,-0.24085,-0.58841);\nconst float specularPower = 20.0;\n\n// borderless \nvec2 loop_d(vec2 p, vec2 s){\n\treturn mod(p + s * 0.5, s) - s * 0.5;\n}\n\nvec2 loop(vec2 p, vec2 s){\n\treturn mod(p, s);\n}\n\nvec2 Random(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(123.34,234.35,345.65));\n\ta += dot(a, a + 34.45);\n\treturn fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nbool reset(sampler2D sam) {\n    return texture(sam, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}", "buffer_b_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// pheromone\n// x   => pheromone quantity\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid DiffusePheromones(vec2 g, inout vec4 fragPheromone)\n{\n    // laplacian\n\tfloat v = 0.0;\n    v += getPheromone(g + vec2(-1, 0)).x; // l\n\tv += getPheromone(g + vec2( 0, 1)).x; // t\n\tv += getPheromone(g + vec2( 1, 0)).x; // r\n\tv += getPheromone(g + vec2( 0,-1)).x; // b\n\tv -= 4.0 * fragPheromone.x;\n    \n\tfragPheromone += dt * v;\n}\n\nvoid mainImage( out vec4 fragPheromone, in vec2 fragCoord )\n{\n    fragPheromone = getPheromone(fragCoord);\n    \n    DiffusePheromones(fragCoord, fragPheromone);\n\t\n\t// write pheromones for each particles\n\tvec4 p = getParticle(fragCoord);\n\tif (p.w > 0.0)\n\t{\n\t\tfloat gauss = exp(-pow(length(fragCoord - p.xy)/gauss_coef,2.));\n\t\tfragPheromone += dt * gauss;\n\t}\n\t\n\t// dissipation  \n\tfragPheromone -= dt * decay * fragPheromone;\n    \n    if (iFrame < 1 || reset(iChannel3)) // reset \n\t\tfragPheromone = vec4(0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[318, 318, 345, 345, 413], [415, 415, 445, 445, 472], [474, 474, 531, 531, 1111]], "test": "untested"}
{"id": "tttSDn", "name": "Time is up", "author": "Gegell", "description": "Based on a youtube video i cant find anymore, where a cellular automata was simulated, but the iterations were stacked ontop one another.\n\nMouse dragging can be used to \"brush\" on alive cells onto the state buffer.", "tags": ["voxel", "buffer", "cellularautomata"], "likes": 21, "viewed": 544, "published": 3, "date": "1631292406", "time_retrieved": "2024-07-30T19:02:09.806200", "image_code": "/*\n * ToDo:\n * [x] Better shading\n * [x] Better Better shading\n * [x] Shadows\n * [x] Project ro onto top plane before voxelMarch, if not inside the area of automata.\n * [ ] AO\n * [x] Better fog\n *\n */\n\n#define _Voxelsize .3\n#define _Maxdist 64.\n#define _Maxstepcount 512\n\n#define shadows\n\nstruct marchRes {\n\tint iter;\n    float totalDist;\n    int mat;\n    vec3 lastPos;\n    ivec3 lastCellPos;\n    ivec3 lastWall;\n};\n\nuint contained(ivec3 cellIndex) {\n    if (cellIndex == ivec3(0)) return 1u;\n    uvec4 buffer = floatBitsToUint(texelFetch(iChannel0, cellIndex.xz, 0));\n    if (cellIndex.y < 0) return 0u;\n    else if (cellIndex.y <  28) return 1u & (buffer.r >> cellIndex.y);\n    else if (cellIndex.y <  56) return 1u & (buffer.g >> (cellIndex.y - 28));\n    else if (cellIndex.y <  84) return 1u & (buffer.b >> (cellIndex.y - 56));\n    else if (cellIndex.y < 112) return 1u & (buffer.a >> (cellIndex.y - 84));\n    return 0u;\n}\n\nmarchRes voxelMarch(vec3 ro, vec3 rd) {\n    marchRes res;\n    res.lastCellPos = ivec3(floor(ro / _Voxelsize));\n    res.lastPos = ro;\n    res.mat = -1;\n    res.totalDist = 0.;\n    vec3 recRay = 1. / rd;\n    for (res.iter = 0; res.iter < _Maxstepcount && res.totalDist < _Maxdist; res.iter++) {\n    \tuint dist = contained(ivec3(iChannelResolution[0].x, 0, iChannelResolution[0].y)/2 - res.lastCellPos);\n        if (dist != 0u) {\n            res.mat = 0;\n            break;\n        }\n        \n\t\tvec3 nextBorders = (vec3(res.lastCellPos) + vec3(greaterThan(rd, vec3(0.)))) * _Voxelsize;\n        vec3 scalars = (nextBorders - res.lastPos) * recRay;\n        float m = min(scalars.x, min(scalars.y, scalars.z));\n        res.lastPos += m * rd;\n        res.totalDist += m;\n        res.lastWall = ivec3(equal(scalars, vec3(m))) * (ivec3(greaterThan(rd, vec3(0.))) * 2 - 1);\n        res.lastCellPos += res.lastWall;\n    }\n    return res;\n}\n\n/**\n * From https://www.shadertoy.com/view/lt33z7\n *\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * From https://www.shadertoy.com/view/Xtd3z7\n *\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 colorLookup(float val) {\n    vec3 p = vec3(1., 1., 1.);\n    vec3 o = vec3(0., .3, .6);\n    vec3 a = vec3(1.5);\n    vec3 as = vec3(0.);\n\treturn (sin((p * val + o) * 6.283)*.5 + .5) * a + as;\n}\n\nvec3 getSkyColor(vec3 rd) {\n\treturn mix(vec3(.7, .7, .9), vec3(.2, .2, .7), smoothstep(-.2, .3, rd.y));\n}\n\nvec3 getColor(marchRes res, vec3 rd) {\n\tvec3 col = vec3(0.);\n    if (res.mat < 0) {\n    \tcol = getSkyColor(rd);\n    } else {\n        \n        vec3 normal = vec3(res.lastWall);\n        \n        vec3 material = colorLookup(float(res.lastCellPos.y + iFrame / Frames_per_step) * 3. / 112.);\n        material *= .2;\n        \n        vec3 sun_dir = normalize(-vec3(.8, .4, .2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0.0, 1.0);\n        float sky_dif = clamp(.5 - .5 * normal.y, 0.0, 1.0);\n        #ifdef shadows\n        marchRes shadowRes = voxelMarch(res.lastPos - .01 * _Voxelsize * sun_dir, -sun_dir);\n        if (shadowRes.mat >= 0) sun_dif = 0.;\n        #endif\n        \n    \tcol  = material * vec3(8.0, 4.0, 2.0) * sun_dif;\n        col += material * vec3(0.5, 1.0, 2.0) * sky_dif;\n        //Better fog, get skyColor function, based on angle of rd.y\n        col = mix(col, getSkyColor(rd), smoothstep(_Maxdist *.95, _Maxdist*1.2, res.totalDist));\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = .25;\n    vec3 offset = vec3(0., fract(float(iFrame) / float(Frames_per_step)), 0.) * _Voxelsize;\n    \n    vec3 eye = vec3(sin(iTime*.7 * speed)*15.,\n                    4.,\n                    cos(iTime * .7  * speed)*15.);\n    vec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, -.5, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float param = (_Voxelsize * 2. - eye.y) / worldDir.y;\n    vec3 ro = eye + offset + param * worldDir;\n    \n    marchRes res = voxelMarch(ro, worldDir);\n    res.totalDist += param;\n    \n    vec3 col = getColor(res, worldDir);\n    \n    col = pow(col, vec3(.45));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#if Life_ruleset == 1\n    // Standard GOL rules\n    #define Rule_Begin 0x008\n    #define Rule_Stay  0x00C\n#elif Life_ruleset == 2\n\t// Copying Rules\n    #define Rule_Begin 0x0AA\n    #define Rule_Stay  0x0AA\n#elif Life_ruleset == 3\n\t// Mazelike\n    #define Rule_Begin 0x008\n    #define Rule_Stay  0x03C\n#elif Life_ruleset == 4\n\t// Walls\n    #define Rule_Begin 0x1F0\n    #define Rule_Stay  0x1FA\n#elif Life_ruleset == 5\n\t// Lively City Walls\n    #define Rule_Begin 0x1F0\n    #define Rule_Stay  0x1DA\n#endif\n\n\nbool getInitialState(in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1 on y)\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Randomish initial condition\n    return (floatBitsToInt(cos(3.*p.x+p.y) + sin(p.y)) & 7) < 1;\n    \n\t// Circle in Center\n    //return length(p) < .01; \n}\n\nbool mouseBrush( in vec2 pos ) {\n    // Only brush if mouse is pressed\n    if (iMouse.z <= 0.)\n        return false;\n    // Small perturbation to the circle to achieve more diverse patterns\n    float perturbation = cos(.02*(pos.x+pos.y)) + sin(pos.y*.05+iTime*.2);\n    return length(iMouse.xy - pos) < 15. + perturbation * 5.;\n}\n\nint getBlockState( in ivec2 pos ) {\n    uint state = 0u;\n    int index = 0;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++, index++) {\n    \t\tuvec4 cell = floatBitsToUint(texelFetch(iChannel0, pos + ivec2(x, y), 0));\n           \tstate |= (cell.x & 1u) << index;\n        }\t\n    }\n    return int(state);\n}\n\nint bitsSet( in int bits ) {\n\tint a = (bits & 0x5555) + ( (bits >> 1) & 0x5555 );\n    int b = (a & 0x3333) + ( (a >> 2) & 0x3333 );\n    int c = (b & 0x0f0f) + ( (b >> 4) & 0x0f0f );\n    int d = (c & 0x00ff) + ( (c >> 8) & 0x00ff );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 initVal = vec4(intBitsToFloat(0));\n    initVal.r = intBitsToFloat(getInitialState(fragCoord) ? 0xF0000003 : 0xF0000002);\n    \n    ivec2 ipos = ivec2(fragCoord.x, fragCoord.y);\n    \n    uvec4 currentBufferValue = floatBitsToUint(texelFetch(iChannel0, ipos, 0));\n    \n    int currentBlockState = getBlockState(ipos);\n    bool currentState = ((currentBlockState & 0x10) != 0);\n    \n    int neighbourCount = bitsSet(currentBlockState);\n    \n    bool newState = currentState;\n    if (iFrame % Frames_per_step == 0) {\n        if (!currentState) {\n            newState = ((Rule_Begin >> neighbourCount) & 1) == 1;\n        } else {\n            newState = ((Rule_Stay  >> (neighbourCount - 1)) & 1) == 1;\n        }\n        \n        #ifdef Life_use_mouse_brush\n            newState = newState || mouseBrush(fragCoord);\n        #endif\n    \n        currentBufferValue = ((currentBufferValue << 1) & (0x0FFFFFFFu)) | uvec4(uint(newState), (currentBufferValue.xyz >> 27) & 1u);\n    }\n    \n    vec4 newVal = uintBitsToFloat(currentBufferValue);\n    \n    fragColor = iFrame == 0 ? initVal : newVal;\n    \n    if (fragColor.r > .5) fragColor.g += .01;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Frames_per_step 20\n#define Life_use_mouse_brush\n#define Life_ruleset 1", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 450, 450, 926], [928, 928, 967, 967, 1856], [1858, 2161, 2226, 2226, 2358], [2360, 2736, 2785, 2820, 3046], [3048, 3048, 3077, 3077, 3244], [3246, 3246, 3273, 3273, 3351], [3353, 3353, 3391, 3391, 4340], [4343, 4343, 4400, 4400, 5167]], "test": "untested"}
{"id": "wl2SzV", "name": "Parametrized Hilbert Curve SDF", "author": "Gegell", "description": "My attempt at creating the hilbert curve fractal. Hacked the function of the Hilbertcurve together, until it worked.", "tags": ["fractal", "spacefillingcurve"], "likes": 15, "viewed": 361, "published": 3, "date": "1631290190", "time_retrieved": "2024-07-30T19:02:10.827469", "image_code": "#define ITERATIONS 3\n#define LINE_THICKNESS .5\n\nvec3 hue(float h)\t{\n    h = fract(h);\n    float r = abs(h * 6. - 3.) - 1.;\n    float g = 2. - abs(h * 6. - 2.);\n    float b = 2. - abs(h * 6. - 4.);\n    return clamp(vec3(r, g, b), 0., 1.);\n}\n\nvec2 sdParamMin( vec2 a, vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nvec2 sdParamLine( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2(length( pa - ba*h ), h);\n}\n\nvec2 sdParamU( vec2 uv ) {\n    vec2 mirUv = vec2(abs(.5 - uv.x), uv.y);\n    vec2 l1 = sdParamLine(mirUv, vec2(.25, .25), vec2( .25, .75));\n    vec2 l2 = sdParamLine(mirUv, vec2(.25, .75), vec2(-.25, .75));\n    \n    l1.y /= 3.;\n    l2.y = (l2.y + 1.) / 3.;\n    \n    vec2 res = sdParamMin(l1, l2);\n    if (uv.x > .5) {\n        res.y = 1. - res.y;\n    }\n\treturn res;\n}\n\n/*\n * Generate the distance to and parameter along a pseudo-hilbert curve \n * created with ITERATIONS many iterations.\n */\nvec2 sdParamHilbert( vec2 uv ) {\n    \n    vec2 pos = fract(uv);\n\n    float s = pow(2., float(ITERATIONS));\n    float o = .25 * pow(0.5, float(ITERATIONS));\n    \n    vec2 d = vec2(1e10, 0);\n    float totalSegments = pow(4., float(ITERATIONS+1)) - 1.;\n    float segmentsBefore = 0.;\n    float betweenOffset = pow(4., float(ITERATIONS));\n    \n    // Distort space so that only 1 U shape has to be calculated.\n    for (int i = 0; i < ITERATIONS; i++) {\n        ivec2 region = ivec2(floor(pos * 2.));\n        \n        // Add the connecting lines of the 4 parts.\n        vec2 scale = vec2(s, 1./totalSegments);\n        d = sdParamMin(d, (sdParamLine(pos, vec2(   o, .5-o), vec2(   o, .5+o)) + vec2(0., betweenOffset * 1. + segmentsBefore * 4. - 1.)) * scale);\n        d = sdParamMin(d, (sdParamLine(pos, vec2(.5-o, .5+o), vec2(.5+o, .5+o)) + vec2(0., betweenOffset * 2. + segmentsBefore * 4. - 1.)) * scale);\n        d = sdParamMin(d, (sdParamLine(pos, vec2(1.-o, .5+o), vec2(1.-o, .5-o)) + vec2(0., betweenOffset * 3. + segmentsBefore * 4. - 1.)) * scale);\n        \n        betweenOffset *= .25;\n        o *= 2.;\n        s *= .5;\n        \n        if (region.x < 1) {\n            if (region.y < 1) {\n                segmentsBefore += 0. * betweenOffset;\n            } else {\n                segmentsBefore += 1. * betweenOffset;\n            }\n        } else {\n            if (region.y < 1) {\n                segmentsBefore += 3. * betweenOffset;\n            } else {\n                segmentsBefore += 2. * betweenOffset;\n            }\n        }\n        \n        // Create sub tiles\n        pos = fract(pos * 2.);\n\n        // Rotate the lower 2 U shapes.\n        if (region.y < 1)  {\n            pos = pos.yx;\n            if (region.x >= 1) {\n                pos = 1. - pos;\n            }\n        }\n        \n    }\n    float paramOffset = segmentsBefore * 4. / totalSegments;\n    \n    // Evaluate the 1 U shape on the transformed position. \n    // Use its parameter for the connecting lines as well.\n    vec2 u = sdParamU(pos);\n    u.y = u.y / totalSegments * 3. + paramOffset;\n    return sdParamMin(d, u);\n}\n\n/*\n * Better tiling for the sdParamHilbert function. It aligns the multiple\n * pseudo-hilbert curves to better match the colors between them.\n */\nvec2 sdParamTiledHilbert( vec2 uv ) {\n\n    ivec2 tp = ivec2(floor(uv));\n    vec2 pos = fract(uv);\n    \n    // Rotate every curve on every second line by 180 degrees.\n    if ((tp.y & 1) == 1) {\n        // Dont use 1. here for inversion due to it being off by 1 pixel sometimes.\n        pos = 1. - 1e-7 - pos;\n    }\n    \n    vec2 res = sdParamHilbert(pos);\n    \n    // Reverse every second curve parameter. Like a checker board pattern. \n    if ((tp.x + tp.y & 1) == 1) {\n        res.y = 1. - res.y;\n    }\n    \n    return res;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centered normalized pixel coordinates (from 0 to 1 on y)\n    vec2 uv = ((2.*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y) + 1.)/2.;\n    \n    // Get distance and parameter to the hilbert curve.\n    vec2 d = sdParamTiledHilbert(uv);\n    \n    // Use the distance returned by the hilbert curve sdf to create the shape mask.\n    float smoothing = 2./length(iResolution.xy) * pow(2., float(ITERATIONS));\n    float mask = 1.-smoothstep(-smoothing, smoothing, d.x - LINE_THICKNESS/4.);\n    \n    // Cut out every tile other than the one in the center.\n    if (max(abs(uv.x-.5), abs(uv.y-.5)) > .5) mask = 0.;\n    \n    // Add ripples.\n    // mask *= .5+.5*cos(d.y * 6.2831 * 16. * pow(4., float(ITERATIONS)) - iTime *10.);\n    \n    // Use the parameter returned by the paramtrized hilbert curve to determine a color.\n    vec3 col = vec3(0.);\n    \n    // Black to white gradient. \n    // col = mix(vec3(.25), vec3(1.), d.y);\n    // Hue gradient.\n    col = hue(d.y);\n    \n    \n    // Apply the final mask.\n    col *= mask;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 67, 67, 239], [241, 241, 275, 275, 336], [338, 338, 382, 382, 510], [512, 512, 538, 538, 877], [879, 1002, 1034, 1034, 3102], [3104, 3250, 3287, 3287, 3776], [3779, 3779, 3836, 3900, 4931]], "test": "untested"}
{"id": "7dKGzw", "name": "ufo-boxed", "author": "jorge2017a1", "description": "ufo-boxed", "tags": ["ufoboxed"], "likes": 5, "viewed": 280, "published": 3, "date": "1631283073", "time_retrieved": "2024-07-30T19:02:11.897608", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 moverObj(vec3 p, vec3 p1, vec3 p2,float tInc, float tA ,float tB)\n{   vec3 pres=p1;\n    if (tInc<tA) pres=p;\n        \n    if (tInc>=tA && tInc<tB)\n    { pres.x=mix(p1.x, p2.x, smoothstep(tA, tB,tInc));\n      pres.y=mix(p1.y, p2.y, smoothstep(tA, tB,tInc));\n      pres.z=mix(p1.z, p2.z, smoothstep(tA, tB,tInc));\n      pres=p-pres;\n    }\n    \n    if (tInc>tB)  pres=p-p2;\n    \n    return pres;\n}\n\nvec3 Nave(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXZ( p, vec2(5.0,0.25) );\n    float sdcy2= sdCylinderXZ( p-vec3(0.0,0.25,.0), vec2(5.0,0.15) );\n    float sds1= sdSphere(p-vec3(0.0,1.0,0.0), 1.0 );\n    res =opU3(res, vec3(sdcy1,3.0,-1.0));\n    res =opU3(res, vec3(sdcy2,1.0,-1.0));\n    res =opU3(res, vec3(sds1,1.0,-1.0));   \n    return res;\n}\n\nvec3 MoverNave(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n    float sds1= sdSphere(p, 1.0 );\n    float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        sdres= Nave(pnew1);\n    else if(timeMov<10.0)\n        sdres= Nave(pnew2);\n    else if(timeMov<20.0)\n        sdres= Nave(pnew3);\n    else if(timeMov<30.0)\n        sdres= Nave(pnew4);\n    res =opU3(res, sdres);\n    return res;    \n}   \n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    p.y=p.y-25.0;\n    \n    vec3 mn1= MoverNave(p);\n    res =opU3(res, mn1); \n    \n    float alto=25.0;\n    float sb1= sdBox( p-vec3(0.0,0.0,90.0), vec3(100.0,alto,100.0) );\n    float sb2= sdBox( p-vec3(0.0,1.0,-1.0), vec3(25.0,alto,10.0) );\n    float sb3= sdBox( p-vec3(20.0,1.0,0.0), vec3(15.0,alto,45.0) );\n    \n    p=rotate_y( p-vec3(43.0,1.0,70.0), radians(135.0));\n    float sb4= sdBox( p, vec3(10.0,alto,45.0) );\n    \n    \n    float dif=differenceSDF(sb1, sb2);\n    dif=differenceSDF(dif, sb3);\n    dif=differenceSDF(dif, sb4);\n    \n    res =opU3(res, vec3(dif,100.0,-1.0)); //inf\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n    \n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*1.5; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n     \n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(5.0, 30.0, -20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-15.0);\n   \n   ///-----------------------\n   vec3 p=-ro;\n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n     float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        ro= pnew1;\n    else if(timeMov<10.0)\n        ro= pnew2;\n    else if(timeMov<20.0)\n        ro= pnew3;\n    else if(timeMov<30.0)\n        ro=pnew4;\n    \n   \n   ///-----------------------\n   ro= rotate_x(ro, radians(180.0));\n   ro.x=-ro.x;\n   ro.y+=15.0;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 478, 514, 514, 535], [536, 536, 568, 568, 652], [653, 653, 692, 692, 787], [789, 789, 837, 837, 865], [867, 867, 903, 903, 948], [950, 950, 984, 984, 1080], [1081, 1081, 1115, 1115, 1206], [1207, 1207, 1241, 1241, 1332], [1334, 1334, 1368, 1368, 1463], [1465, 1465, 1537, 1537, 1864], [1866, 1866, 1885, 1885, 2241], [2243, 2243, 2267, 2267, 3072], [3077, 3077, 3102, 3102, 3852], [3854, 3854, 3878, 3878, 4040], [4042, 4042, 4091, 4091, 4722], [4724, 4724, 4760, 4760, 5005], [5007, 5007, 5034, 5034, 5051], [5053, 5053, 5089, 5089, 5181], [5182, 5182, 5228, 5228, 5353], [5355, 5355, 5429, 5429, 6994], [6996, 6996, 7045, 7045, 7288], [7290, 7290, 7370, 7370, 7493], [7495, 7495, 7527, 7527, 7724], [7726, 7726, 7773, 7773, 7997], [7999, 8051, 8144, 8144, 8632], [8635, 8635, 8666, 8666, 9270], [9272, 9321, 9347, 9347, 9457], [9459, 9459, 9517, 9517, 9569], [9571, 9620, 9677, 9677, 11022]], "test": "untested"}
{"id": "sdK3Rw", "name": "RayMarching : colors", "author": "klemek", "description": "Based on some of Shane's functions", "tags": ["raymarching"], "likes": 10, "viewed": 419, "published": 3, "date": "1631280439", "time_retrieved": "2024-07-30T19:02:12.917880", "image_code": "#define PI 3.1416\n#define FAR 50.0\n#define MAX_RAY 92\n#define MAX_REF 16\n#define FOV 1.57\n#define OBJ_MIN_D 0.01\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere(vec3 q, vec3 p, float r) {\n    return length(q - p) - r;\n}\n\nfloat plane(vec3 q, vec3 d, float offset) {\n    return dot(d, q) + offset;\n}\n\nfloat capsule(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab1 = p2 - p1;\n    vec3 ap1 = q - p1;\n    float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n    t1 = clamp(t1, 0., 1.);\n    vec3 c1 = p1 + t1 * ab1;\n    return length(q - c1) - r;\n}\n\nfloat torus(vec3 q, vec3 p, float r1, float r2) {\n    q -= p;\n    float x = length(q.xz) - r1;\n    return length(vec2(x, q.y)) - r2;\n}\n\nfloat box(vec3 q, vec3 p, vec3 s) {\n    return length(max(abs(q - p) - s, 0.));\n}\n\nfloat cyl(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab2 = p2 - p1;\n    vec3 ap2 = q - p1;\n    float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n    vec3 c2 = p1 + t2 * ab2;\n    float d = length(q - c2) - r;\n    float y = (abs(t2 - .5) - .5) * length(ab2);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    return e + i;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define OBJ_COUNT 6\n\nfloat objects[OBJ_COUNT] = float[](FAR, FAR, FAR, FAR, FAR, FAR);\nvec3 objectsColor[OBJ_COUNT] = vec3[](vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.));\nconst float objectsRef[OBJ_COUNT] = float[](.1,.1,.1,.1,.1,.1);\n\nvoid setObjects(vec3 q) {\n\n    vec3 pos = vec3(.0, .0, -iTime * 2.);\n    \n    q -= pos;\n\n    float seed = abs(floor(q.x)) + abs(floor(q.y)) * 100. + abs(floor(q.z)) * 1000.;\n    float diff = rand(seed) * 2. * PI;\n\n    objects[0] = sphere(mod(q, 1.), .5 + vec3(cos(iTime + diff + PI) * .1, .1, sin(iTime + diff + PI) * .1), .1);\n    objects[1] = box(mod(q - vec3(cos(iTime + diff) * .1, -.1, sin(iTime + diff) * .1), 1.), vec3(.5), vec3(.15));\n    objects[2] = plane(q, vec3(.0, 1., .0), 1.5);\n    objects[3] = plane(q, vec3(.0, -1., .0), 1.5);\n    objects[4] = plane(q, vec3(1., .0, .0), 1.5);\n    objects[5] = plane(q, vec3(-1., .0, .0), 1.5);\n}\n\nvoid setObjectColors(vec3 q) {\n\n    vec3 pos = vec3(.0, .0, -iTime * 2.);\n    \n    q -= pos;\n    \n    float seed = abs(floor(q.x)) + abs(floor(q.y)) * 100. + abs(floor(q.z)) * 1000.;\n\n    objectsColor[0] =  col(rand(seed++));\n    objectsColor[1] =  col(rand(seed++));\n    objectsColor[2] =  col(rand(seed++));\n    objectsColor[3] =  col(rand(seed++));\n    objectsColor[4] =  col(rand(seed++));\n    objectsColor[5] =  col(rand(seed++));\n}\n\nfloat map(vec3 q) {\n    float d = FAR;\n    \n    setObjects(q);\n    \n    for(int i = 0; i < OBJ_COUNT; i++)\n        d = min(d, objects[i]);\n    \n    return d;\n}\n\nvec3 mapColor(vec3 q) {\n    setObjects(q);\n    setObjectColors(q);\n    \n    vec3 c = vec3(.0);\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(objects[i] < OBJ_MIN_D && objects[i] < mind){\n             c = objectsColor[i];\n             mind = objects[i];\n        }\n    }\n\n    return c;\n}\n\nfloat mapRef(vec3 q) {\n    setObjects(q);\n    \n    float ref = .0;\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(objects[i] < OBJ_MIN_D && objects[i] < mind){\n             ref = objectsRef[i];\n             mind = objects[i];\n        }\n    }\n\n    return ref;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, int max_d) {\n    float t = 0., h;\n    for(int i = 0; i < max_d; i++){\n        h = map(ro + rd * t);\n        if(abs(h) < .001 * (t * .25 + 1.) || t > FAR)  break;\n        t += h * .8;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    const vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 5; i++) {\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 getHitColor(vec3 ro, vec3 rd, float t, vec3 lightPos) {\n    vec3 hit = ro + rd * t;\n    vec3 norm = normal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1./(1.0 + lightDist*0.125 + lightDist*lightDist*.05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.)*2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = mapColor(hit + rd * OBJ_MIN_D) * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return vec4(color, atten * occ);\n}\n\nvec3 getColor(vec2 uv, vec3 ro, vec3 dir, vec3 lightPos) {\n    vec3 fwd = normalize(dir - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    float t = rayMarch(ro, rd, MAX_RAY);\n    \n    vec3 outColor = vec3(.0);\n    \n    if(t < FAR) {\n        vec3 hit = ro + rd * t;\n        vec3 norm = normal(hit);\n        vec4 color = getHitColor(ro, rd, t, lightPos);\n        \n        vec3 ref = reflect(rd, norm);\n        float refQ = mapRef(hit + rd * OBJ_MIN_D);\n        float t2 = rayMarch(hit + ref * .1, ref, MAX_REF);\n        vec4 color2 = getHitColor(hit + ref * .1, ref, t2, lightPos);\n    \n        outColor = (color.xyz * (1. - refQ) + refQ * color2.xyz * color2.w) * color.w;\n    }\n    \n    outColor = mix(min(outColor, 1.), vec3(0), 1.-exp(-t*t/FAR/FAR*20.));\n    \n    return outColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pos = vec3(.0, .0, .0);\n    vec3 dir = vec3(.0, .0, 1.);\n    vec3 light = pos + vec3(.0, .0, 1.);\n    \n    vec3 c = getColor(uv, pos, dir, light);\n    \n    fragColor = vec4(sqrt(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 301, 301, 386], [388, 388, 407, 407, 576], [741, 741, 780, 780, 812], [814, 814, 857, 857, 890], [892, 892, 942, 942, 1125], [1127, 1127, 1176, 1176, 1261], [1263, 1263, 1298, 1298, 1344], [1346, 1346, 1392, 1392, 1694], [2111, 2111, 2136, 2136, 2757], [2759, 2759, 2789, 2789, 3196], [3198, 3198, 3217, 3217, 3357], [3359, 3359, 3382, 3382, 3677], [3679, 3679, 3701, 3701, 3971], [3974, 3974, 4019, 4019, 4211], [4213, 4213, 4234, 4234, 4400], [4402, 4402, 4439, 4439, 4704], [4870, 4870, 4930, 4930, 5532], [5534, 5534, 5592, 5592, 6429], [6431, 6431, 6486, 6486, 6785]], "test": "untested"}
{"id": "fsK3zw", "name": "- spider verse -", "author": "anahit_movsesyan", "description": "Spider-Verse inspired dots", "tags": ["music", "ghost", "dots", "spiderman"], "likes": 13, "viewed": 875, "published": 3, "date": "1631270392", "time_retrieved": "2024-07-30T19:02:13.692808", "image_code": "vec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 color = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    color *= 1. + vec4(hsv2rgb(vec3(sin(iTime / 3.) * 0.5 + 0.5, 1., 0.2)) + color.a / 10., 1.);\n\n    int offset = 8 * (int(fragCoord.x) / 3 % 2 + int(fragCoord.y) / 3 % 2 - 1);\n\n    fragColor = color * texelFetch(iChannel0, ivec2(fragCoord.xy) + offset, 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float s = texture(iChannel2, vec2(0)).r;\n    vec2 uv = (1. - s * 0.015) * (fragCoord.xy / iResolution.xy - 0.5) + 0.5;\n    fragColor = vec4(mix(texture(iChannel0, uv).rgb, texture(iChannel1, uv).rgb, 0.05), s);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 146]], "test": "untested"}
{"id": "Ndt3Ws", "name": "Badlands", "author": "jarble", "description": "A jagged rocky landscape based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "erosion", "badlands"], "likes": 8, "viewed": 317, "published": 3, "date": "1631248183", "time_retrieved": "2024-07-30T19:02:14.567469", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x/1.5),cos(uv.y*1.5));\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 1.;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        vec2 n2 = noise(uv * freq-n1);\n        n1 = abs(n2.x+n2.y-n1)-value;\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n1-.5) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.1;\n        \n        uv = uv.yx;\n        //value *= .9;\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,4)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 135], [156, 156, 191, 240, 721], [723, 723, 745, 745, 775], [777, 777, 807, 807, 857], [859, 859, 879, 879, 926], [928, 928, 961, 961, 1155], [1157, 1157, 1224, 1224, 1442], [1444, 1444, 1496, 1496, 2041], [2043, 2043, 2094, 2094, 2295], [2297, 2297, 2323, 2323, 2399], [2468, 2468, 2525, 2525, 4476]], "test": "untested"}
{"id": "ssy3Rw", "name": "Newton Raphson Simple Example", "author": "Yusef28", "description": "Newton Raphson Test.\n", "tags": ["intersection", "newton", "log", "raphson"], "likes": 9, "viewed": 279, "published": 3, "date": "1631239068", "time_retrieved": "2024-07-30T19:02:15.350376", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 09-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Newton-Raphson Test                              //\n// Sources: Rudimentary Concept (Google/Wikipedia/Youtube) //\n// Listening to:                                           //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n#define e 2.71828\n#define m cos(iTime)*0.9 + 2.\n#define newton_steps 5\n#define b1 -sin(iTime)-3.\n#define starting_x 3.39+cos(iTime)\n#define off sin(iTime)\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nfloat newton(vec2 uv, inout vec3 col){\n    float found_x = 0.;\n\n    \n    \n    float fx_prime;\n    float xn = starting_x;\n    float xn_plus1,x_next;\n    float f;\n    vec2 A1, B1, A2, B2;\n    \n    float fx;\n    /*\n        B1 = vec2(xn, 0.);\n        A1 = vec2(xn, log(xn));\n        f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n        col = mix(col, vec3(.3,.3,1.), f);\n        */\n    for(int i = 0; i < 5; i++){\n        \n        float x0 = xn;\n        //fx when it's 0 is set to the difference between\n        //log(xn) and the line equation\n        fx = xn*xn + off;\n        //fxPrime is just the derivative of these \n        //and it's the same as the slope at point xn\n        fx_prime = 2.*xn;\n        //our new x is approximated by a line through the tangent\n        //at the pooint it hits the x axis\n        //y = mx + b where y = 0 -> x = -b/m = (-fx/fx_prime)\n\n        //I'll come back to this...\n        \n        //... the true x intersect is xi\n        //xi ~= xguess + xfromtangentlineoffx\n        //xi ~= xguess + (-b/m)\n        //so for example, x^2 with init guess x = 2\n        // fx = 2^2 = 4, fx' = 2*2 = 4, fx/fx' = 1\n        // next x = 2 + (-1) = 1\n        \n        //I think thats the idea\n        \n        xn = xn - fx/fx_prime;\n\n        A1 = vec2(x0, x0*x0+off);\n        B1 = vec2(xn, 0.);\n        \n        f = 1.0-smoothstep(0.02,0.03,abs(distToLine(A1, B1, uv)));\n        col = mix(col, (vec3(1.,.3,.3))*0.5+0.5, f);\n    \n        A2 = vec2(xn, xn*xn+off);\n        B2 = vec2(xn, 0.);\n\n        f = 1.0-smoothstep(0.02,0.03,abs(distToLine(A2, B2, uv)));\n        col = mix(col, (vec3(.99,.3,.2))*0.5+0.5, f);\n        \n        f = 1.-smoothstep(0.03,0.05,length(uv-A1)-0.05);\n        col = mix(col, vec3(.2,0.75,1.), f);\n    }\n    \n    return xn;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    \n    uv*=8.;\n    uv.y+=3.;\n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    uv.x/=2.;\n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n\n    //y based on sin\n    float y = uv.x*uv.x + off;\n    \n    \n    //line \n    float m1 = sin(m);\n    //float b1 = cos(iTime+0.4)*2.;\n    \n    float log_plus_line = log(uv.x) - (uv.x*m1 + b1);\n    //newton-raphson\n    float found_x = newton(uv, col);\n    \n\n    //calculate the intersection points\n    vec2 intersectionPoint1 = vec2(found_x, y);\n   // vec2 intersectionPoint2 = vec2(root2, 0.);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //Drawing the quadratic line\n    //float f = 1.0-smoothstep(0.02,0.06,abs(y-uv.y)); //old way\n    //new way using derivatives\n    //it's y - uv.y where \"y\" is some quadratic of x\n    float f = 1.0-smoothstep(0.02,0.15,abs(y-uv.y)/fwidth(y-uv.y)/20.);\n    col = mix(col, vec3(1.,.2,0.5), f);\n    \n    //sum of the line and the log funciton\n    //f = 1.0-smoothstep(0.02,0.15,abs(log_plus_line-uv.y)/fwidth(log_plus_line-uv.y)/20.);\n    //col = mix(col, vec3(0.2,.6,0.9), f);\n    \n    //line 1\n    //float f;// = 1.0-smoothstep(0.02,0.06,abs(uv.x*m1 + b1 - uv.y));\n    //f = 1.0-smoothstep(0.05,0.1,abs(uv.x*m1 + b1 - uv.y)/fwidth(uv.x*m1 + b1 - uv.y)/20.);\n    //col = mix(col, vec3(1.,.5,0.2), f);\n   \n    /*\n    //intersection point\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint1)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint1)-0.05);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    */\n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    col = clamp(col,0.,1.);\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n    col = clamp(col,0.,1.);\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssy3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[777, 777, 818, 818, 1020], [1022, 1022, 1060, 1060, 2803], [2804, 2804, 2861, 2913, 6783]], "test": "untested"}
{"id": "7dy3Rw", "name": "tunnel tests", "author": "jorge2017a1", "description": "tunnel tests", "tags": ["tunneltests"], "likes": 3, "viewed": 242, "published": 3, "date": "1631236403", "time_retrieved": "2024-07-30T19:02:16.256952", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1;\nvec3 light_pos2;  vec3 light_color2;\nvec3 light_pos3;  vec3 light_color3;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n     res =opU3(res, vec3(planeDist1,-1.0,10.0)); //inf\n   \n    p.y=p.y-10.0;\n     p.z= opRep1D(p.z, 10.0 );\n      float sdcy1=sdCylinderXY(p,vec2(10.0,3.0));\n    float sdcy2=sdCylinderXY(p,vec2(8.0,4));\n    \n    float dif=differenceSDF(sdcy1, sdcy2);\n       mObj.uvP= vec2(atan(p.y, p.x), p.z * 0.4);\n    \n    float tt=iTime;\n    float sds1= sdSphere( pp-vec3(0.0+5.0*sin(tt)*cos(tt),10.+5.0*sin(tt+3.0*cos(tt)),0.0+iTime*5.0+10.0*sin(tt)),1.2 );\n    res =opU3(res, vec3(sds1,3.0,-1.0));\n   \n    res =opU3(res, vec3(dif,-1.0,10.0));\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    \n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    /*lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    */\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n     return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/7sSXDz\nvec3 amigaTexture(vec2 pos, float n)\n{\n    float l = clamp(sin(pos.x*n)*sin(pos.y*n)*10000.0, 0.0, 1.0);\n    return vec3(1.0, 0.0, 0.0)*l+(vec3(1.0, 1.0, 1.0)*(1.0-l));\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n   if (id_material==10.0)\n    {\n    return amigaTexture(mObj.uvP, 6.0);\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos3);\n        //col= result/1.5;\n        col= result;\n  \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, -5.0, 35.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(0.0, 10.0, 20.0 ); light_color2 =vec3(1.0); \n    light_pos3= vec3(0.0, 10.0, 0.0 ); light_color3 =vec3(1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-25.0+t);\n\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    light_pos3+=ro;\n    vec3 col= Render( ro,  rd);\n    col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec2 uvP;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 551, 551, 572], [573, 573, 612, 612, 707], [709, 753, 800, 800, 827], [828, 828, 871, 871, 898], [899, 899, 947, 947, 975], [976, 1014, 1050, 1050, 1095], [1138, 1138, 1163, 1163, 1807], [1809, 1860, 1884, 1884, 2046], [2048, 2048, 2097, 2097, 2764], [2766, 2820, 2856, 2856, 3101], [3102, 3157, 3184, 3184, 3201], [3203, 3203, 3239, 3239, 3331], [3332, 3332, 3378, 3378, 3503], [3505, 3505, 3579, 3579, 5193], [5194, 5228, 5308, 5308, 5431], [5474, 5474, 5506, 5506, 5703], [5705, 5745, 5783, 5783, 5915], [5916, 5967, 6014, 6014, 6148], [6150, 6202, 6295, 6295, 6636], [6639, 6639, 6670, 6670, 7360], [7362, 7411, 7437, 7437, 7547], [7549, 7549, 7607, 7607, 7659], [7661, 7710, 7767, 7767, 8442]], "test": "untested"}
{"id": "sdy3R1", "name": "Newton-Raphson log-Line", "author": "Yusef28", "description": "Newton Raphson Test.\n", "tags": ["intersection", "newton", "log", "raphson"], "likes": 7, "viewed": 259, "published": 3, "date": "1631232630", "time_retrieved": "2024-07-30T19:02:17.021907", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 07-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Newton-Raphson Test                              //\n// Sources: Rudimentary Concept (Google/Wikipedia/Youtube) //\n// Listening to:                                           //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n#define e 2.71828\n#define m cos(iTime)*0.9 + 2.\n#define newton_steps 5\n#define b1 -sin(iTime)-3.\n#define starting_x 10.39;\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nfloat newton(vec2 uv, inout vec3 col){\n    float found_x = 0.;\n\n    //y based on sin\n    float y = sin(uv.x);\n    \n    //line \n    float m1 = sin(m)*2.;\n   // float b1 = cos(iTime+0.4)*2.;\n    \n    \n    float fx_prime;\n    float xn = starting_x;\n    float xn_plus1,x_next;\n    float f;\n    vec2 A1, B1;\n    \n    float fx;\n    /*\n        B1 = vec2(xn, 0.);\n        A1 = vec2(xn, log(xn));\n        f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n        col = mix(col, vec3(.3,.3,1.), f);\n        */\n    for(int i = 0; i < 5; i++){\n        \n        float x0 = xn;\n        //fx when it's 0 is set to the difference between\n        //log(xn) and the line equation\n        fx = log(xn) - (xn*m1 + b1);\n        //fxPrime is just the derivative of these \n        //and it's the same as the slope at point xn\n        fx_prime = log(e)/(xn) - m1;\n        //our new x is approximated by a line through the tangent\n        //at the pooint it hits the x axis\n        //y = mx + b where y = 0 -> x = -b/m = fx/fx_prime\n        // xn - fx/fx_prime then is x - (-b/m)...\n        //I'll come back to this\n        xn = xn - fx/fx_prime;\n\n        A1 = vec2(x0, log(x0));\n        B1 = vec2(xn, 0.);\n        \n        f = 1.0-smoothstep(0.02,0.04,abs(distToLine(A1, B1, uv)));\n        col = mix(col, (vec3(1.,.3,.3))*0.5+0.5, f);\n        \n        A1 = vec2(x0, log(x0));\n        B1 = vec2(x0, 0.);\n        \n        f = 1.0-smoothstep(0.02,0.04,abs(distToLine(A1, B1, uv)));\n        col = mix(col, (vec3(1.,.3,.3))*0.5+0.5, f);\n        \n    }\n    \n    return xn;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    \n    //graph background\n    vec3 col = vec3(0.1);\n    \n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    \n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    uv.x += 7.14;\n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n\n    //y based on sin\n    float y = log(uv.x);//uv.x*uv.x;//sin(uv.x);\n    \n    \n    //line \n    float m1 = sin(m)*2.;\n    //float b1 = cos(iTime+0.4)*2.;\n    \n    float log_plus_line = log(uv.x) - (uv.x*m1 + b1);\n    //newton-raphson\n    float found_x = newton(uv, col);\n    \n\n    //calculate the intersection points\n    vec2 intersectionPoint1 = vec2(found_x, y);\n   // vec2 intersectionPoint2 = vec2(root2, 0.);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //Drawing the quadratic line\n    //float f = 1.0-smoothstep(0.02,0.06,abs(y-uv.y)); //old way\n    //new way using derivatives\n    //it's y - uv.y where \"y\" is some quadratic of x\n    float f = 1.0-smoothstep(0.02,0.15,abs(y-uv.y)/fwidth(y-uv.y)/20.);\n    col = mix(col, vec3(1.,.2,0.5), f);\n    \n    //sum of the line and the log funciton\n    f = 1.0-smoothstep(0.02,0.15,abs(log_plus_line-uv.y)/fwidth(log_plus_line-uv.y)/20.);\n    col = mix(col, vec3(0.2,.6,0.9), f);\n    \n    //line 1\n   // float f;// = 1.0-smoothstep(0.02,0.06,abs(uv.x*m1 + b1 - uv.y));\n    f = 1.0-smoothstep(0.05,0.1,abs(uv.x*m1 + b1 - uv.y)/fwidth(uv.x*m1 + b1 - uv.y)/20.);\n    col = mix(col, vec3(1.,.5,0.2), f);\n   \n    \n    //intersection point\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint1)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint1)-0.05);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    col = clamp(col,0.,1.);\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n    col = clamp(col,0.,1.);\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[746, 746, 787, 787, 989], [991, 991, 1029, 1029, 2544], [2545, 2545, 2602, 2654, 6523]], "test": "untested"}
{"id": "ssKGRW", "name": "- first audio experiment -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sound", "experiment"], "likes": 3, "viewed": 272, "published": 3, "date": "1631215296", "time_retrieved": "2024-07-30T19:02:17.781875", "image_code": "vec3 pattern(vec2 p) {\n    vec4 s = texture(iChannel0, vec2(0));\n    float p1 = mix(sin(sin(p.x * (sin(p.y) - cos(p.x)))), \n                   sin(sin(p.x)) * (sin(p.y) - cos(p.x)), \n                   -0.5 + tan(s).x);\n    float p2 = mix(cos(cos(p.y * (cos(p.x) - sin(p.y)))), \n                   cos(cos(p.y)) * (cos(p.x) - sin(p.y)), \n                   -0.5 + sin(s).x);\n       \n    if (p1 > p2) {\n        return vec3(0.3);\n    }\n    return vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 24. * uv - 12.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = pattern(p);\n    uv *= 1.0 - uv;\n    color *=  vec3(pow(uv.x * uv.y * 15., 0.25)); \n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 455], [457, 457, 512, 512, 773]], "test": "untested"}
{"id": "7sV3RD", "name": "testbsp4", "author": "BSPCo", "description": "test", "tags": ["test"], "likes": 3, "viewed": 275, "published": 3, "date": "1631209149", "time_retrieved": "2024-07-30T19:02:18.574755", "image_code": "//-----------------------------------------------------\n// Radial Sound Visualizer                     5/2015\n// Based on 'Input-Sound' by IQ\n// now switch between 2 views\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\n    // for radial view click to left side, \n    // for xy view click to right side\n    if (iMouse.x / iResolution.x < 0.5)\n      uv = vec2( .75*length(uv-0.5), atan(abs(uv.y-0.5), abs(uv.x-0.5)) );\n\n    float value, fft, wave;\n    value = abs(uv.x-0.5);\n    \n    // first texture row is frequency data\n\tfft  = texture( iChannel0, vec2(value,.37) ).x; \n\t\n  \t// second texture row is the sound wave\n\twave = texture( iChannel0, vec2(value,-.48) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( 25.0*fft*(1.0-fft)*(0.2+01.24*sin(iTime))\n                    , fft+1.3*sin(0.22*iTime)\n                    , 1.5-fft-1.4*sin(0.33*iTime) ) * fft;\n    \n    // add wave form on top\t\n\tvalue = (uv.y < 1.0) ? uv.y : uv.y - 1.0;\n\tcol += 0.8 -  smoothstep( 0.0, 0.15, abs(wave - value) );\n\t\n\t// output final color\n\tfragColor = vec4(col,50.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sV3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 286, 318, 1201]], "test": "untested"}
{"id": "sdVGRD", "name": "testbsp3", "author": "BSPCo", "description": "test", "tags": ["test3"], "likes": 1, "viewed": 235, "published": 3, "date": "1631208187", "time_retrieved": "2024-07-30T19:02:19.342702", "image_code": "//-----------------------------------------------------\n// Radial Sound Visualizer                     5/2015\n// Based on 'Input-Sound' by IQ\n// now switch between 2 views\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\n    // for radial view click to left side, \n    // for xy view click to right side\n    if (iMouse.x / iResolution.x < 0.5)\n      uv = vec2( .75*length(uv-0.5), atan(abs(uv.y-0.5), abs(uv.x-0.5)) );\n\n    float value, fft, wave;\n    value = abs(uv.x-0.5);\n    \n    // first texture row is frequency data\n\tfft  = texture( iChannel0, vec2(value,.07) ).x; \n\t\n  \t// second texture row is the sound wave\n\twave = texture( iChannel0, vec2(value,.38) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( 25.0*fft*(1.0-fft)*(0.2+0.4*sin(iTime))\n                    , fft+1.3*sin(0.22*iTime)\n                    , 0.5-fft-1.4*sin(0.33*iTime) ) * fft;\n    \n    // add wave form on top\t\n\tvalue = (uv.y < 1.0) ? uv.y : uv.y - 1.0;\n\tcol += 0.8 -  smoothstep( 0.0, 0.15, abs(wave - value) );\n\t\n\t// output final color\n\tfragColor = vec4(col,5.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 286, 318, 1197]], "test": "untested"}
{"id": "sdKGRD", "name": "testBSP 2 ", "author": "BSPCo", "description": "test2", "tags": ["test2"], "likes": 4, "viewed": 272, "published": 3, "date": "1631207738", "time_retrieved": "2024-07-30T19:02:20.174478", "image_code": "//-----------------------------------------------------\n// Radial Sound Visualizer                     5/2015\n// Based on 'Input-Sound' by IQ\n// now switch between 2 views\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\n    // for radial view click to left side, \n    // for xy view click to right side\n    if (iMouse.x / iResolution.x < 0.5)\n      uv = vec2( 2.0*length(uv-0.5), atan(abs(uv.y-0.5), abs(uv.x-0.5)) );\n\n    float value, fft, wave;\n    value = abs(uv.x-0.5);\n    \n    // first texture row is frequency data\n\tfft  = texture( iChannel0, vec2(value,0.15) ).x; \n\t\n  \t// second texture row is the sound wave\n\twave = texture( iChannel0, vec2(value,.1) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( 4.0*fft*(1.0-fft)*(0.2+0.4*sin(iTime))\n                    , fft+0.3*sin(0.22*iTime)\n                    , 0.5-fft-0.4*sin(0.33*iTime) ) * fft;\n    \n    // add wave form on top\t\n\tvalue = (uv.y < 1.0) ? uv.y : uv.y - 1.0;\n\tcol += 0.8 -  smoothstep( 0.0, 0.15, abs(wave - value) );\n\t\n\t// output final color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 286, 318, 1196]], "test": "untested"}
{"id": "ssV3zh", "name": "Volumetric Light Fog", "author": "NoxWings", "description": "Fog Volumetric pass\nInspired by both killzone shadow fall and \"inside\" games\n(small steps + dithering + low res + linear upscaling + bilateral blur + temporal accumulation)\n\nValues to play with are on the common tab.", "tags": ["noise", "blur", "volumetric", "fog", "blue", "bilateral", "temporal"], "likes": 21, "viewed": 2527, "published": 3, "date": "1631201395", "time_retrieved": "2024-07-30T19:02:21.239630", "image_code": "// Volumetric fog shader\n// \n// I made this shader because I have always been amazed by volumetric light effect\n// This shader is inspired by the awesome article on GPU Pro 5,\n// \"Volumetric Light Eﬀects in Killzone: Shadow Fall\"\n// and also by the fantastic gdc talk on \n// \"Low Complexity, High Fidelity: The Rendering of INSIDE\"\n// https://www.youtube.com/watch?v=RdN06E6Xn9E\n// \n// The main insights here are:\n// - Buffer A:\n//     - Render scene as usual, usual raymarching in this case\n// - Buffer B:\n//     - Render the volumetric pass into another buffer to control res independently of the main render (for perf)\n//     - Raytrace fixed steps per pixel and sample light visibility from each point\n//     - Use noise to offset the ray start (blue noise preferably)\n//     - Here I'm storing raw % of samples reaching light but ideally you should \n//       use some kind of scattering factor like Henyey-Greenstein phase function\n// - Buffer C\n//     - Upsample (ideally bilateral but linear works just fine for this)\n//     - Also I'm using previous frame data here to accumulate more samples if the depth from prev frame \n//       does not differ too much\n// - Buffer D\n//     - Bilateral blur. Same as gausian but using depth to discard samples.\n// - Image\n//     - Main image & volumetric compositing\n//     - Tone mapping\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Main scene\n    vec4 mainScene = texture(iChannel0, uv);\n    vec4 volumetric = texture(iChannel1, uv);\n    \n    vec3 col = mainScene.rgb;\n    col += volumetric.rgb;\n    \n    col = ACESFilm(col);\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Main Scene Pass\n//\n// Outputs scene color and Depth on alpha channel\n\nfloat checkerboard(vec3 p) {\n    return mod(floor(p.x) + floor(p.y) + floor(p.z), 2.0);\n}\n\nfloat sampleCheckerboard(vec3 uv) {\n    float detail = 15.;\n    int maxSamples = 4;\n    \n    vec3 uvX = dFdx(uv);\n    vec3 uvY = dFdy(uv);\n    \n    int sx = 1 + int( clamp(detail * length(uvX), 0.0, float(maxSamples - 1)) );\n    int sy = 1 + int( clamp(detail * length(uvY), 0.0, float(maxSamples - 1)) );\n    \n    float value = 0.0;\n    for(int i=0; i<sx; i++)\n    for(int j=0; j<sy; j++) {\n        vec2 offset = vec2(float(i), float(j)) / vec2(float(sx), float(sy));       \n        value += checkerboard(uv + offset.x * uvX + offset.y * uvY);\n    }\n    \n    #ifdef DEBUG_TEXTURE_FILTERING\n    return float(sx*sy) / float(maxSamples * maxSamples);\n    #endif\n    \n    return value / float(sx*sy);\n}\n\nMaterial matFromId(vec3 ro, vec3 rd, Hit hit) {\n    vec3 p = ro + rd * hit.dist;\n\n    if (hit.id == 1) {\n        return Material(\n            vec3(0.5),\n            250.0,\n            vec3(0.0)\n        );     \n    }\n\n    // triangular tiling\n    // float a = (mod(p.x, 3.0) - mod(p.z, 3.0)) > 0.0 ? 0.9 : 0.5;\n    float a = sampleCheckerboard(p * 0.5) * .5 + 0.25; \n\n    return Material(\n        vec3(a),\n        250.0,\n        vec3(0.0)\n    );\n}\n\nstruct RenderInfo {\n    vec3 color;\n    float d;\n};\n\nRenderInfo render(vec3 ro, vec3 rd) {\n    Hit hit = trace(ro, rd, 512, FAR_PLANE, SURF_HIT);\n    \n    // Sky\n    vec3 skyColorTop = vec3(0.1, 0.5, 1.0);\n    vec3 skyColorBottom = vec3(1.0);\n    vec3 skyColor = mix(skyColorBottom, skyColorTop, clamp(pow(rd.y +.2, 0.18), 0.0, 1.0));\n    vec3 sunColor = vec3(1);\n\n    if (hit.dist >= FAR_PLANE) { \n        float sunPercent = clamp(dot(rd, lightDir), 0.0, 1.0);\n        return RenderInfo(\n            mix(skyColor, sunColor, pow(sunPercent, 100.))\n        , \n        FAR_PLANE); \n    }\n\n    // Common terms\n    vec3 P = ro + rd * hit.dist;\n    vec3 V = -rd;\n    vec3 N = mapNormal(P);\n    vec3 L = lightDir;\n    vec3 H = normalize(V + L);\n    vec3 R = normalize(reflect(L, N));\n    Material m = matFromId(ro, rd, hit);\n    \n    // Shadow\n    vec3 shadowOrigin = P + N * SURF_HIT * 2.0;\n    float shadow = traceShadow(shadowOrigin, L, 28.0, 32, FAR_PLANE, SURF_HIT);\n    \n    // Regular surface shading\n    float ao = calcAO(P, N);\n    \n    float lambert = max(0.0, dot(N, L));\n    float blinnPhong = max(0.0, dot(N, H));\n    \n    vec3 ambient = skyColorTop * 0.2 * ao * m.albedo;\n    vec3 diffuse = lambert * lightColor * m.albedo * shadow;  \n    vec3 specular = vec3(pow(blinnPhong, m.specular)) * shadow;\n    \n    return RenderInfo(ambient + diffuse + specular, hit.dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n    \n    Camera cam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy, \n        iResolution.xy, \n        60.0 * DEG2RAD, \n        vec3(5,0,0), \n        1.0, \n        50.0 - 45.0 * iMouse.y/iResolution.y,\n        iTime\n    );\n    \n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n    \n    RenderInfo info = render(ro, rd);\n    \n    fragColor = vec4(info.color, info.d);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Volumetric fog pass (low res)\n//\n// Outputs fog color and sampled used depth on alpha channel\n\nvec3 traceFog(vec3 ro, vec3 rd, float hitDistance, vec3 l, vec2 pixel) {\n    float startOffset = 0.0;\n\n    #if VOLUME_USE_NOISE == 1\n    int frame = 0;\n        #if VOLUME_ANIMATE_NOISE == 1\n            frame = iFrame % 64;\n        #endif\n    \n    float goldenRatio = 1.61803398875;\n    float invGoldenRatio = 1.0/goldenRatio;\n    \n    float blue = texture(iChannel1, pixel / 1024.0f).r;\n    startOffset = blue * 1.0;\n    startOffset = fract(blue + float(frame) * invGoldenRatio);\n    #endif\n\n    float fogLitPercent = 0.0;\n    for (int i = 0; i < VOLUME_MAX_STEPS; ++i) {\n        float rayPercent = (startOffset + float(i)) / float(VOLUME_MAX_STEPS);\n        float rayStep = rayPercent * hitDistance;\n        \n        vec3 o = ro + rd * rayStep;\n        Hit h = trace(o, l, 64, FAR_PLANE, SURF_HIT);\n        \n        fogLitPercent = mix(fogLitPercent, (h.dist >= FAR_PLANE) ? 1.0 : 0.0, 1.0f / float(i+1));\n    }\n    \n    vec3 fogColor = mix(vec3(0, 0, 0), lightColor, fogLitPercent);\n    float absorb = exp(-hitDistance * VOLUME_FOG_DENSITY);\n    \n    // return mix(fogColor, vec3(0, 0, 0), absorb);\n    return clamp(1.-absorb, 0.0, VOLUME_BRIGHTNESS_CLAMP) * fogColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    res *= VOLUME_RES;\n    if( fragCoord.x > res.x || fragCoord.y > res.y )\n        return;\n\n    vec2 uv = fragCoord / res.xy;\n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= res.x / res.y;\n    \n    Camera cam = createOrbitCamera(\n        fakeScreen, \n        iMouse.xy, \n        iResolution.xy, \n        60.0 * DEG2RAD, \n        vec3(5,0,0), \n        1.0, \n        50.0 - 45.0 * iMouse.y/iResolution.y,\n        iTime\n    );\n    \n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n        \n    float dist = texture(iChannel0, uv).w;\n    vec3 fog = traceFog(ro, rd, dist, lightDir, fragCoord);\n    \n    fragColor = vec4(fog, dist);\n}", "buffer_b_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define YES 1\n#define NO  0\n\n#define SHOT_CAMERA                NO\n#define LOCKED_CAMERA              YES\n\n#define VOLUME_FOG_DENSITY         0.02\n#define VOLUME_BRIGHTNESS_CLAMP    0.3\n\n#define VOLUME_RES                 0.5\n#define VOLUME_MAX_STEPS           16\n\n#define VOLUME_USE_NOISE           YES\n#define VOLUME_ANIMATE_NOISE       YES\n\n#define VOLUME_USE_BILATERAL_BLUR  YES\n#define VOLUME_BLUR_SIZE           0.0025\n#define VOLUME_BLUR_QUALITY        2.0\n#define VOLUME_BLUR_DIRECTIONS     8.0\n\n#define VOLUME_USE_TAA             YES\n#define VOLUME_DEBUG_TAA           NO\n#define VOLUME_TAA_MAX_REUSE       0.9\n#define VOLUME_TAA_MAX_DIST        0.5\n\n\n// #define DEBUG_TEXTURE_FILTERING\n\n// Bilateral common stuff\n\nstruct BilateralSample {\n    vec2 pixel;\n    float importance;\n    vec4 result;\n};\n\nfloat bilateralImportance(vec2 samplePixel, float sampleDepth, vec2 pixel, float pixelDepth) {\n    float xImportance = 1.0 - abs(samplePixel.x - pixel.x);\n    float yImportance = 1.0 - abs(samplePixel.y - pixel.y);\n    float spatialImportance = xImportance * yImportance;\n    \n    float depthImportance = clamp(1.0 / abs(sampleDepth - pixelDepth), 0.0, 1.0);\n    return spatialImportance * depthImportance;\n}\n\n// COMMON THINGS\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.;\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget, float iTime)\n{\n    #if SHOT_CAMERA == 1 \n    mouse = resolution * vec2(0.4);\n    distanceToTarget = 12.0;\n    #else\n    #if LOCKED_CAMERA == 1\n    // Used for fixed camera screenshots\n    float aStart = 0.0;\n    float aEnd = 0.0;\n    iTime = mod(iTime, 35.0);\n\n    aStart = aEnd;\n    aEnd += 8.0;\n    mouse = resolution * A(vec2(.35), vec2(0.37), aStart + 2.0, aEnd);\n    distanceToTarget = A(35.0, 16.0, aStart, aEnd);\n\n    aStart = aEnd;\n    aEnd += 12.0;\n    mouse = A(mouse, resolution * vec2(.65), aStart - 2.0, aEnd);\n    distanceToTarget = A(distanceToTarget, 12.0, aStart - 2.0, aEnd);\n\n    aStart = aEnd;\n    aEnd += 0.0;\n    mouse = A(mouse, resolution * vec2(0.65), aStart - 7.0, aEnd);\n    distanceToTarget = A(distanceToTarget, 35.0, aStart - 5.0, aEnd);\n\n    aStart = aEnd;\n    aEnd += 15.0;\n    mouse = A(mouse, resolution * vec2(0.35), aStart - 3.0, aEnd);\n    distanceToTarget = A(distanceToTarget, 35.0, aStart - 3.0, aEnd);\n    #endif\n    #endif\n\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n    \n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n       \n    return Camera(position, direction);\n}\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 100000.5453);\n}\n\n// Dist functions\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Hit\n\nstruct Hit {\n    int id;\n    float dist;\n};\n\nHit hmin(Hit a, Hit b) { if (a.dist < b.dist) return a; return b; }\nHit hmax(Hit a, Hit b) { if (a.dist < b.dist) return b; return a; }\nHit hnegate(Hit a) { return Hit(a.id, -a.dist); }\nHit opUnion(Hit a, Hit b) { return hmin(a, b); }\nHit opSubtraction(Hit a, Hit b) { return hmax(hnegate(a), b); }\nHit opIntersection(Hit a, Hit b) { return hmax(a, b); }\n\n// Material\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    vec3 emissive;\n};\n\n// Map\n\nconst float FAR_PLANE = 100.0;\nconst float SURF_HIT = 0.01;\n\nvec3 lightDir = normalize(vec3(1, 0.4, .5));\nvec3 lightColor = vec3(0.7, 0.55, 0.45) * 2.0;\n\nHit map(vec3 p) {\n    Hit floorPlane = Hit(0, sdPlane(p, -2.0));\n    \n    vec3 wallP = p;\n    wallP.x = abs(wallP.x);\n    wallP -= vec3(10, 0, 0);\n    \n    vec3 wallP2 = p;\n    wallP2.z = abs(wallP.z);\n    wallP2 -= vec3(0, 0, 18);\n    \n    vec3 ventP = wallP;\n    \n    float wall = sdBox(wallP, vec3(0.1,5,18));\n    float wall2 = sdBox(wallP2, vec3(10.0,5,0));\n    \n    float roof = sdBox(wallP - vec3(0, 5, 0), vec3(5, 0.1, 18));\n    float roof2 = sdBox(wallP2 - vec3(0, 5, 0), vec3(10, 0.1, 6));\n    \n    // Vents\n    float rep = 5.0;\n    if (abs(ventP.z) < 18.0) {\n        ventP.z = mod(ventP.z + (rep*.5), rep) - rep*.5;\n    }\n    float vent = sdBox(ventP, vec3(1, 1, 1));\n    vent = min(vent, length(ventP.zy - vec2(0,1.5)) - 1.0);\n    \n    // door\n    vec3 doorP2 = wallP2;\n    float door = sdBox(doorP2, vec3(2, 2, 2));\n    door = min(door, length(doorP2.xy - vec2(0, 2.)) - 2.0);\n    \n    float d = min(wall, wall2);\n    d = min(d, roof);\n    d = min(d, roof2);\n    d = max(-door, d);\n    d = max(-vent, d);\n    \n    Hit s = Hit(1, d - 0.05);\n\n    return hmin(s, floorPlane);\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    float d = map(p).dist;\n    \n    return normalize(vec3(\n        d - map(p - e.xyy).dist,\n        d - map(p - e.yxy).dist,\n        d - map(p - e.yyx).dist\n    ));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nHit trace(vec3 ro, vec3 rd, int maxIter, float farPlane, float surfHit) {\n    Hit d = Hit(0, 0.0);\n    for (int i = 0; i < maxIter && d.dist <= farPlane; i++) {\n        vec3 p = ro + rd * d.dist;\n        Hit s = map(p);\n        d.id = s.id;\n        d.dist += s.dist;\n        if (s.dist < surfHit) break;\n    }\n    return d;\n}\n\nfloat traceShadow(vec3 ro, vec3 rd, float hardness, int maxIter, float farPlane, float surfHit)\n{\n    float d = surfHit * 2.0;\n    float k = hardness;\n    float res = 1.0;\n    \n    for (int i=0; i < 128 && d <= farPlane; i++) {\n        vec3 p = ro + rd * d;\n        float stepDistance = map(p).dist;\n        \n        if (stepDistance < surfHit) return 0.0;\n        \n        res = min(res, k * stepDistance / d);\n        d += stepDistance;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}", "buffer_c_code": "// Upscale volumetric pass\n// \n// Simple linear upsample (todo: update to bilateral)\n// Also some kind of very basic temporal accumulation (without reprojection)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 fakeScreen = uv * 2.0 - 1.0;\n    fakeScreen.x *= iResolution.x / iResolution.y;\n    \n    Camera prevCam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy, \n        iResolution.xy, \n        60.0 * DEG2RAD,\n        vec3(5,0,0), \n        1.0, \n        50.0 - 45.0 * iMouse.y/iResolution.y,\n        iTime - iTimeDelta\n    );\n    \n    Camera currentCam = createOrbitCamera(\n        fakeScreen,\n        iMouse.xy, \n        iResolution.xy, \n        60.0 * DEG2RAD, \n        vec3(5,0,0), \n        1.0, \n        50.0 - 45.0 * iMouse.y/iResolution.y,\n        iTime\n    );\n    \n    vec4 scene = texture(iChannel0, uv);\n    vec4 volumetric = texture(iChannel1, uv * VOLUME_RES);\n    vec4 prevSample = texture(iChannel2, uv);\n    \n    vec3 prevPoint = prevCam.position + prevCam.direction * prevSample.w;\n    vec3 currentPoint = currentCam.position + currentCam.direction * volumetric.w;\n    \n    float diff = distance(prevPoint, currentPoint);\n    float diffPercent = clamp(1.0 - diff / VOLUME_TAA_MAX_DIST, 0.0, 1.0);\n    float success = clamp(diffPercent * diffPercent, 0.0, VOLUME_TAA_MAX_REUSE);\n    float failure = 1.0 - success;\n    \n    vec3 taa = success * prevSample.rgb + failure * volumetric.rgb;\n    \n    #if VOLUME_USE_TAA == 1 \n        #if VOLUME_DEBUG_TAA == 1\n        fragColor = vec4(vec3(failure, success, 0), volumetric.w);\n        return;\n        #endif\n    \n        fragColor = vec4(taa, volumetric.w);\n    #else \n        fragColor = volumetric;\n    #endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Main image\n//\n// Applies Bilateral blur to the upscaled volumetric light\n\nvec4 sampleBlur(\n    sampler2D tex, \n    vec2 res, \n    vec2 pos, \n    float sceneDepth,\n    float directions, \n    float quality, \n    float size\n) {\n    vec2 radius = size / res.xy;\n    vec2 uv = pos / res.xy;\n    \n    vec4 color = texture(tex, uv);\n    \n    float directionStep = TAU/directions;\n    float qualityStep = 1.0/quality;\n    \n    float importance = 1.0;\n    \n    for(float arc = 0.0; arc < TAU; arc += directionStep)\n    for(float q = 1.0; q > 0.0; q -= qualityStep) {\n        vec2 offset = vec2(cos(arc),sin(arc)) * q * radius * res.y;\n        vec2 cuv = uv + offset;\n        \n        // Avoid sampling outside the edges\n        if (\n            cuv.x < 0.0 ||\n            cuv.y < 0.0 ||\n            cuv.x > res.x ||\n            cuv.y > res.y\n        ) {\n            continue;\n        }\n        \n        vec4 fog = texture(tex, cuv);\n        float spatialImportance = 1.0 + (1.0 - q); // linear fallof\n        float depthImportance = clamp(1.0 / abs(sceneDepth - fog.w), 0.0, 1.0);\n        #if VOLUME_USE_BILATERAL_BLUR == 0\n            depthImportance = 1.0;\n        #endif\n        float sampleImportance = spatialImportance * depthImportance;\n        importance += sampleImportance;\n        color += texture(tex, cuv) * sampleImportance;\n    }\n    \n    return color / importance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Main scene\n    vec4 mainScene = texture(iChannel0, uv);\n    fragColor = sampleBlur(\n        iChannel1, \n        iResolution.xy, \n        fragCoord, \n        mainScene.w,\n        VOLUME_BLUR_DIRECTIONS, \n        VOLUME_BLUR_QUALITY, \n        VOLUME_BLUR_SIZE / VOLUME_RES\n    );\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1337, 1468, 1491, 1491, 1663], [1665, 1665, 1722, 1722, 2039]], "test": "untested"}
{"id": "fsK3RD", "name": "Halo Music Visualizer", "author": "Peace", "description": "Visualizing something meant to be heard", "tags": ["sound", "music", "visualizer", "halo"], "likes": 7, "viewed": 511, "published": 3, "date": "1631200117", "time_retrieved": "2024-07-30T19:02:22.122270", "image_code": "//Math constants\n#define PI 3.14159\n#define TWO_PI 6.28318\n\n//Frequency range to which the halo reacts currently set to 0-520hz\n#define FREQ 512.0\n\n//Grabs frequency from the music texture\nfloat frequency(float x)\n{\n    return texture(iChannel0, vec2(x, 0)).r;\n}\n\n//Grabs smooth frequency from the music texture by averaging multiple neighboring frequency texels\nfloat smoothFrequency(float x, float smoothness)\n{\n    float f = frequency(x);\n    int accumulated = 1;\n    for(float i = 1.0 / FREQ; i <= smoothness; i += 1.0 / FREQ)\n    {\n        f += frequency(x + i);\n        f += frequency(x - i);\n        accumulated += 2;\n    }\n    return f / float(accumulated);\n}\n \n//Converts HSV to RGB (values of both goes from 0 to 1)\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Converts RGB to Grayscale (using the NTSC formula)\nfloat luma(vec3 color) \n{\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Calculate normalized uv coordinates (normalized meaning going from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = uv * 2.0 - 1.0;\n    uvn.x *= iResolution.x / iResolution.y;\n    \n    //Calculating angle from normalized uv coordinate using atan\n    float angle = atan(normalize(uvn).x, normalize(uvn).y);\n    float angleNormalized = angle / PI; //Angle from 0 to 1 instead of 0 to two pi\n\n    //Using multiple techniques to draw shapes using normalized uv coordinates (halo shape in this case)\n    float inner_halo = max(pow(1.0 - abs(length(uvn) - 0.6), 8.0), 0.0) * 2.0;\n    inner_halo *= inner_halo;\n    \n    //Adding outer halo to the original middle one\n\tfloat outer_halo = max(pow(abs(length(uvn)), 4.0), 0.0) * 0.25;\n    float halo = inner_halo + outer_halo;\n    \n    //Grabs smooth frequnecy from texture using normalized angle as a texture coordinate\n    float freq = smoothFrequency(abs(angleNormalized), 0.05);\n    \n    //Getting final color by multiplying two halos by their colors \n    //which we grab as RGB using angle + time as hue parameter and other SV parameters set to 1\n    //Then we multiply result by frequency to get dynamicly changing brightness depending on frequency\n    vec3 col = halo * hsv2rgb(vec3(angleNormalized * 0.5 + 0.5 - iTime * 0.1, 1.0, 1.0)) * freq;\n    \n    //Some color tweaking for more vibrant colors\n    col = pow(col, vec3(2)); //This makes colors more contrasty\n    col += max(length(col) / sqrt(3.0) - 1.0, 0.0); //This increases brightness\n    //col = sqrt(col); //Slightly brighter and blended colors, uncomment if you prefer this\n    \n    fragColor = vec4(col,1.0); //Final result\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 189, 215, 215, 262], [264, 363, 413, 413, 667], [670, 726, 748, 748, 917], [919, 972, 997, 997, 1047], [1049, 1049, 1106, 1188, 2763]], "test": "untested"}
{"id": "NsKGzD", "name": "livecoding_2021_09_09", "author": "butadiene", "description": "shader", "tags": ["raymarching"], "likes": 7, "viewed": 306, "published": 3, "date": "1631198802", "time_retrieved": "2024-07-30T19:02:23.004910", "image_code": "#define time mod(iTime,30.)\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n  \n  vec2 pmod(vec2 p,float n){\n    float np = 2.0*PI/n;\n    float r = atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n    }\n  \n  \n  vec3 modfunc(vec3 p,float ss){\n    p.xz = pmod(p.xz,6.);\n    p.x -= ss;\n    return p;\n    }\n\nvec4 dist(vec3 p){\n  if(time>24.&&time<30.) p.z += 6.,p.y += 20.*time;\n  float kz = 30.;\n  if(time>18.&&time<24.)p = modfunc(p,22.);\n  if(time>24.&&time<30.)p = modfunc(p,22.),p.y = mod(p.y,kz)-0.5*kz;\n \n  float slllt = time;\n  if(time>24.&&time<30.)slllt = 23.9;\n  float sct = floor(mod(slllt*0.5,3.))+clamp(mod(slllt*1.5,3.),0.0,1.0);\n  if(time>24.&&time<30.)slllt =time;\n  float ksst = slllt+0.1;\n    \n  float sca = floor(ksst*0.5)+clamp(mod(ksst*1.5,3.),0.0,1.0);\n  float spt = 0.56+sct;\n    float d = box(p+vec3(0.,-0.3,-1.),vec3(spt*4.));\n  \n  float dc = 0.1;\n  for(int i = 0;i<1;i++){    \n    p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    }\n    d = max(d,box(p-vec3(0.3,0.6,0.3),vec3(0.2,0.5,0.2)));\n    \n        \n    p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    vec3 sssp = p;\n    \n        p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    \n    vec3 sc = vec3(0.02)+0.04*sin(PI*clamp(mod(time*1.5,3.),0.0,1.0));\n    sc += p.zxy*0.1+0.1*sssp;\n    sc *= 0.5;\n  vec3 col =sc;\n  return vec4(col,d);\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p =uv- 0.5;\n\tp /= vec2(iResolution.y / iResolution.x, 1);\n  float ra = 20.0;\n  if(time<6.) {ra = 20.0;}\n  else if(time<12.){ra = 10.0;}\n  if(time>18.&&time<24.) ra = 40.;\n  if(time>24.&&time<30.) ra = 1.3;\n  float rh =5.5;\n  if(time>12.&&time<18.)rh = 10.;\n  if(time>18.&&time<24.)rh = 14.;\n  if(time>24.&&time<30.)rh = 5.3;\n  float kt = time*0.3;\n  vec3 ro = vec3(ra*cos(kt),rh,ra*sin(kt));\n  vec3 ta = vec3(0);\n  \n  \n  \n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0,1,0));\n  vec3 up = cross(side,cdir);\n  float fov = 0.6;\n  vec3 rd = normalize(side*p.x+up*p.y+fov*cdir);\n  float d,t = 0.0;\n  float esp = 0.00001;\n  vec3 col = vec3(0.0);\n  vec3 ac = vec3(0.0);\n  for(int i = 0;i<127;i++){\n    vec4 rsd = dist(ro+rd*t);\n    d = rsd.w;\n    t += d;\n    if(d<esp) break;\n    ac += exp(-3.0*d)*rsd.xyz;\n    }\n  \n  col = 0.6*vec3(ac);\n  \n  col = pow(clamp(col,0.,1.),vec3(1.3));\n    \n  vec3 fincol =col;// vec3(p,0.);\n  \n   fragColor = vec4(fincol,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 120], [122, 122, 147, 147, 246], [252, 252, 278, 278, 413], [422, 422, 452, 452, 513], [515, 515, 533, 533, 1785], [1787, 1787, 1844, 1894, 2908]], "test": "untested"}
{"id": "fdK3RD", "name": "Rouché - winding number theorem", "author": "neozhaoliang", "description": "Rouché's theorem in complex analysis", "tags": ["2d", "complexanalysis"], "likes": 22, "viewed": 646, "published": 3, "date": "1631196606", "time_retrieved": "2024-07-30T19:02:23.769865", "image_code": "/*\n\nWinding number theorem:\n\nA man is walking his dog along closed paths represented by f(z) and g(z),\nrespectively. If the man holds the leash tight enough to prevent the dog\nfrom touching the tree throughout their walk, they will circle the tree the\nsame number of times when they return to their initial positions.\n\nRouché's theorem:\n\nWhen f and g are analytic functions in a region that encloses the unit circle S\nand |f(z)| > |f(z) - g(z)| whenever z in S (here |f-g| is the length of the leash),\nthen f(S) and g(S) will circle the origin the same number of times, and this number\nequals the number of their zeros inside S.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 p = uv * 9.;\n    p -= vec2(1.5, .5); // adjust the postion of the curves\n    vec2 O = vec2(0.5);\n\n    // Smoothing factor.\n    float sf = 8./iResolution.y;\n\n    // background color\n    vec3 col = vec3(1, .92, .75);\n    float hatch = doHatch(uv, iResolution.y);\n    col *= hatch*.2 + .8;\n    \n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n\n    // curve width\n    float lw = .02;\n\n    float dc1 = dcurve(p, 0);\n    float dc2 = dcurve(p, 1);\n\n    float tA = mod(iTime*.2, 2.*PI);\n    float tB = max(0., tA + sin(iTime) * .1 - .1);\n    vec2 A0 = map1(0.), B0 = map2(0.);\n   \n    vec2 A = map1(tA);\n    vec2 B = map2(tB);\n    float dA = length(p - A) ;\n    float dB = length(p - B) ;\n\n    // dash grid lines\n    vec2 p1 = uv * 6.;\n    p1 -= floor(p1) + 0.5;\n    float bord = max(abs(p1.x), abs(p1.y))-0.49;\n    vec2 q1 = abs(mod(p1, 1./8.) - .5/8.);\n    float lines = (min(q1.x, q1.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    float dlink = dSegment(p, A, B);\n    // noisy background pattern\n    col *= fbm(p*48.)*.4 + .6;\n    // draw the grid lines\n    col = mix(col, vec3(0), bord*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc2 - lw*2.4));\n    col = mix(col, colorB, (1. - smoothstep(0., sf*4., dc2 - lw*1.6))*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc1))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc1 - lw*2.4));\n    col = mix(col, colorA, 1. - smoothstep(0., sf*4., dc1 - lw*1.6));\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*.7, dlink - 0.005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*.7, dlink - .008));\n    col = mix(col, vec3(1, 1, .3), 1. - smoothstep(0., sf*.7, dlink));\n\n    lw *= 12.;\n\n    dA -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA));\n    dA += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dA)); \n    dA += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dA))); \n\n    dB -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB));\n    dB += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dB)); \n    dB += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dB)));\n    \n    float dA0 = length(p - A0);\n    dA0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0 - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA0));\n    dA0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0));\n    \n    float dB0 = length(p - B0);\n    dB0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0 - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB0));\n    dB0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0));\n \n    vec2 q = p - O;\n    float ci = length(q) - .7;\n    float sh = max(.75 - ci*4., 0.);\n    col = mix(col, vec3(0), (ss(sf*6., ci - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, ci));\n    col = mix(col, vec3(1, .7, .4)*(ci + sh*sh*.1 + .5), ss(sf, ci + .03));\n    col = mix(col, col*1.6, ss(sf*4., ci + .15));\n   \tcol = mix(col, vec3(0), ss(sf, abs(ci + .1) - .01));   \n    col = mix(col, vec3(0), (ss(sf, length(q) - .18))*.5);\n    col = mix(col, vec3(0), ss(sf, abs(length(q) - .12) - .01));\n    col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n    A -= O;\n    B -= O;\n    vec2 qA = rot2(atan(A.y, A.x-.5) -PI/2.) * q;\n    vec2 qB = rot2(atan(B.y, B.x)-PI/2.) * q;\n    float indA = distLine(qA - vec2(0, -.005), qA - vec2(0, .46)) - .01;\n    float indB = distLine(qB - vec2(0, -.005), qB - vec2(0, .3)) - .01;\n    \n    const float rad = .45;\n    const float aNum = 12.;\n    q = rot2(3.14159/aNum)*q;\n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n    ia = ia*6.283/aNum;\n    q = rot2(ia)*q;\n    q.x -= rad;\n        \n    // Markings.\n    float mark = sBox(q, vec2(.04, .022), 0.);\n    col = mix(col, vec3(.5), ss(sf, mark - .015));\n    col = mix(col, vec3(0), ss(sf, mark));\n        \n    // Indicator.        \n    col = mix(col, vec3(0), ss(sf, indA - .025));\n    col = mix(col, colorA, ss(sf, indA));\n    col = mix(col, vec3(0), ss(sf, indB - .025));\n    col = mix(col, colorB, ss(sf, indB));\n    \n    p -= vec2(-7.5, -3.);\n    p *= .8;\n    float ds1 = min(abs(length(p) - 1.), sqrt(dSegment(p, vec2(0), vec2(1, 0))));\n    col = mix(col, vec3(0.2), ss(sf, ds1 - 0.025));\n    float dr = distRoots(p);\n    col = mix(col, vec3(0.5, 0, 0), ss(sf, dr - .05));\n    col = mix(col, vec3(0.2), ss(sf, length(p - vec2(1, 0)) - .1));\n    \n    vec2 P = vec2(cos(tA), sin(tA));\n    float dP = length(p - P);\n    \n    dP -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dP - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dP - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dP));\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "#define NUM_SEGMENTS  100\n#define PI            3.141592653\n#define ss(a, b)      (1. - smoothstep(0., a, b))\n#define colorA   vec3(1, 0.2, 0.2)\n#define colorB   vec3(0.3, 1., .6)\n\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 transform(vec2 z, vec2 a) {\n    return cdiv(z - a, vec2(1, 0) - cmul(vec2(a.x, -a.y), z));\n}\n\nfloat n2D(vec2 p) {\n    const vec2 s = vec2(1, 113);\n    vec2 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = fract(sin(h)*43758.5453);\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x);\n}\n\nfloat fbm(vec2 p) {\n    return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\nfloat distLine(vec2 a, vec2 b) {\n    b = a - b;\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\nfloat sBox(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\n\nfloat dSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n}\n\nvec2 map1(float t) {\n    const float s = 2.;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 z = transform(p, vec2(.5, .7));\n    z = cmul(z, transform(p, vec2(-.6, 0.5)));\n    z = cmul(z, transform(p, vec2(-0.4)));\n    z = cmul(z, p - vec2(s, s));\n    return z;\n}\n\nfloat distRoots(vec2 p) {\n    float d = length(p - vec2(.5, .7));\n    d = min(d, length(p - vec2(-0.6, 0.5)));\n    d = min(d, length(p - vec2(-0.4)));\n    return d;\n}\n\nvec2 map2(float t) {\n    return map1(t) + vec2(cos(t) * 1.6, sin(t) * 1.2);\n}\n\nfloat dcurve(vec2 p, int index) {\n    float h = 0.05;\n    float t = 0.0;\n\n    vec2  a = index == 0 ? map1(t) : map2(t);\n    float d = dot2(p - a);\n\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        vec2  b = index == 0 ? map1(t) : map2(t);\n        d = min(d, dSegment(p, a, b));\n        t += clamp(0.01*length(a-p)/length(a-b), 0.01, 0.15);\n        a = b;\n    }\n    return sqrt(d);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453);\n}\n\nfloat doHatch(vec2 p, float res) {\n    p *= res/16.;\n    float hatch;\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;\n    else if (hRnd > 0.33) hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    else hatch = clamp(sin((p.x + p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    return hatch;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[634, 634, 689, 689, 6332]], "test": "untested"}
{"id": "NsKGRD", "name": "Fork Islands in Arrangemon 275", "author": "Arrangemonk", "description": "this is just a fork, i keep destorying the other shader, and i should keep it as backup", "tags": ["terrain", "water", "islands"], "likes": 9, "viewed": 722, "published": 3, "date": "1631195450", "time_retrieved": "2024-07-30T19:02:24.721321", "image_code": "\n// Created by Arrangemonk 2021, arrangemonk@gmail.com\n// where i have a clear source i added shadertoy link\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(-0.5,-0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}\n\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29281, "src": "https://soundcloud.com/extandnb/meteor?in=royaltyfreemusic-nocopyrightmusic/sets/creative-commons-music", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//https://www.shadertoy.com/view/XttyRX\n#define tau 6.28318530718\n#define pi 3.141592653589\n\n#define tile_factor .25\n#define noise_factor 0.03\n#define textureGammaOffset 2.\n#define heightMapResolution iChannelResolution[0]\n#define normalStrength 10.0\n//#define steadycam\n\nfloat DrawDistance = 100.0;\nfloat DrawDistanceFract = 0.01;\nfloat angle = 0.0;\nfloat time;\nfloat waterline = 2.9;\nfloat raymarchIterations =120.;\n\n \n\nvec3 skytop= vec3(0.459,0.749,1.05);\nvec3 skybottom = vec3(1.1,0.533,0.000);\n\nvec4 textureGamma(in sampler2D tex,in vec2 uv)\n{\n    return pow(texture(tex,uv),vec4(2.2));\n}\n\nvec4 textureGamma(in sampler3D tex,in vec3 uvw)\n{\n    return pow(texture(tex,uvw),vec4(2.2));\n}\n\n\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)*.5;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)*.5;\n}\n\n\nfloat Mask(float x){\n    x= x -.5;\n    return .5+sign(.5*(.25 -x*x))*.5;\n}\n\nvec3 rampBiome(float inx)\n{   \n    inx = clamp(inx,.0001,.9999);\n    float x = 2.* inx * inx;\n     vec3 col = (.4 + .4*cos((1.-x)*vec3(4,2,1)))*Mask(x) \n     + (.4 + .4*cos((x-1.)*vec3(2,1.25,2)))*Mask(x-1.);\n     col = mix(vec3(.4,.7,.6),mix(col, col*col,.5)*2.,.5);\n     return col;\n}\n \n vec3 rampSky(float x){\n     vec3 col = mix(skybottom,skytop,x*1.2);\n     col *= col * 1.1+ .4;\n    return col;\n}\n\nvec3 target(in vec3 origin,in vec3 direction,in float distance)\n    {\n        return origin + (direction * distance);\n    }\n\n\n//foam from https://www.shadertoy.com/view/ldj3Dm\nvec3 foam (vec2 uv,sampler2D iChannel2,sampler2D iChannel3,vec3 col,float proximity)\n{\n\tfloat sur = texture( iChannel3,  0.05 * uv ).x;\n\tsur = smoothstep( 0.4, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture( iChannel2, uv * 0.25 ).x);\n    sur = sur * sur * 5.;\n\n    return mix( col, vec3(1.0),  sur);\n}\n\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat circ(vec2 uv, vec2 pos, float r) {\n    return smoothstep(r, 0., length(uv - pos));\n}\n\nfloat smoothFract(float x, float blurLevel) {\n\treturn pow(cos01(x), 1./blurLevel);\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\n\nfloat distFn(vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, 4.);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\n\nvec3 fbm8(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult -= texture(tex,uv* 32.).rgb / 32.;\nresult += texture(tex,uv* 64.).rgb / 64.;\nresult -= texture(tex,uv*128.).rgb /128.;\nreturn result;\n}\n\nvec3 fbm6(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nresult += texture(tex,uv* 16.).rgb / 16.;\nresult -= texture(tex,uv* 32.).rgb / 32.;\nreturn result;\n}\n\nvec3 fbm4(in vec2 uv,sampler2D tex)\n{    \nvec3 result = texture(tex,uv).rgb;\nresult -= texture(tex,uv*  2.).rgb /  2.;\nresult += texture(tex,uv*  4.).rgb /  4.;\nresult -= texture(tex,uv*  8.).rgb /  8.;\nreturn result;\n}\n\nvec3 color( in vec2 uv,float height,sampler2D tex)\n{ \n    vec3 biome =rampBiome(height*0.25 + textureGamma(tex,uv *3.).x *.2)+vec3(.1,.15,.1);\n    vec3 stuff = .2 +texture(tex,uv * .125).rgb;\n    return mix(biome,stuff,.40);\n\n}\n\n\n    //https://www.shadertoy.com/view/4sXXRj\nvec3 waterripple(vec2 uv, sampler2D tex,float iTime)\n    {\n\tvec2 p = uv * vec2(-1.0, -2.0);\n    \n    \tfloat t = iTime/300.0;\n\t\n\t\tvec2 waterCoord = vec2(p.x, 1.0-uv.y);\n\t\tvec2 texCoordNormal0 = waterCoord * tile_factor;\n\t\ttexCoordNormal0 += t ;\n\t\t\n\t\tvec2 texCoordNormal1 = waterCoord * tile_factor;\n\t\ttexCoordNormal1.s -= t ;\n\t\ttexCoordNormal1.t += t ;\n\t\t\n\t\tvec3 normal0 = texture(tex, texCoordNormal0).rgb * 2.0 - 1.0;\n\t\tvec3 normal1 = texture(tex, texCoordNormal1).rgb * 2.0 - 1.0;\n\t\treturn normalize(normal0 + normal1);\n    }\n    \n    \nfloat height(in vec2 uv,sampler2D heightmap,float time)\n    {\n        float result = (1.-fbm6(uv*0.005,heightmap).x)*5. -1.6;\n        result = (result - waterline);\n        result = mix(result,result * abs(result),.2);\n        return result + waterline;\n    }\n    \nfloat wheight(in vec2 uv,sampler2D heightmap,float time)\n    {\n        return waterline -waterripple(uv*0.03,heightmap,time).x;\n    }\n    \n   \n    \n//lost link, most likely iqs doing\nfloat RayMarch(vec3 origin,vec3 direction,sampler2D hmap,float time, out bool result)\n{\n    float t = 0.;\n    for (float i = 0.; i < raymarchIterations; i+=1.)\n    {\n        vec3 rp = target(origin,direction,t);\n        float h = rp.y - (height(rp.xz,hmap,time));\n        if (abs(h) < (.00001 * t) || t > DrawDistance) break;\n        t += h;\n    }\n    result = t < DrawDistance;\n    return t;\n}\n\nfloat wRayMarch(vec3 origin,vec3 direction,sampler2D hmap,float time, out bool result)\n{\n    float t = 0.;\n    for (float i = 0.; i < raymarchIterations; i+=1.)\n    {\n        vec3 rp = target(origin,direction,t);\n        float h = rp.y - (wheight(rp.xz,hmap,time));\n        if (abs(h) < (.0015 * t) || t > DrawDistance) break;\n        t += h;\n    }\n    result = t < DrawDistance;\n    return t;\n}\n    \n//https://www.shadertoy.com/view/3sSSW1\nvec3 texNormalMap(in vec2 uv,float scale,sampler2D h,float time)\n{ \n    float p  = height(uv,h,time);\n    float h1 = height(uv + vec2(scale,0),h,time);\n    float v1 = height(uv +  vec2(0,scale),h,time);\n       \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1)) * normalStrength;\n    \n    return normalize(vec3(normal, 1.));\n}\n\n//https://www.shadertoy.com/view/3sSSW1\nvec3 wtexNormalMap(in vec2 uv,float scale,sampler2D wh,float time)\n{ \n    float p  = wheight(uv,wh,time);\n    float h1 = wheight(uv + vec2(scale,0),wh,time);\n    float v1 = wheight(uv +  vec2(0,scale),wh,time);\n       \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1))*0.5;\n    \n    return normalize(vec3(normal, 1.));\n}\n\n    \nmat2 rotationMatrix(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\nfloat caustics(vec2 uv,float time)\n{\n    float t = time * .35;\n    \n    float amplitude = .12;\n    float turbulence = .5;\n    vec2 uva = uv.xy + sin01(uv.x*turbulence + t) * amplitude;\n    uva.xy -= cos01(uv.y*turbulence + t) * amplitude;\n    vec2 uvb = uv.xy + sin01(uv.x*turbulence + t*1.3-2.) * amplitude * 0.7;\n    uvb.xy -= cos01(uv.y*turbulence + t*1.-2.3) * amplitude * 0.7;\n    uvb = uvb * rotationMatrix(1.04);\n    vec2 uvc = uv.xy + sin01(uv.x*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc.xy -= cos01(uv.y*turbulence + t*1.4 + 3.) * amplitude * 0.3;\n    uvc = uvc * rotationMatrix(2.08);\n    \n    float v;\n    v += voronoi(uva, t * 2., 0.5, 2.5)/2.;\n    v += voronoi(uvb, t * 3., 0., 3.) / 2.;\n    v += voronoi(uvc, t * 4., 0., 4.) / 2.;\n    \n    return v;\n}\n\nfloat caustics3D( in vec3 p, in vec3 n ,float time){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n    \treturn (caustics(p.yz,time)*n.x + caustics( p.zx,time)*n.y + caustics(p.xy,time)*n.z);\n}", "buffer_a_code": "\n// Created by Arrangemonk 2021, arrangemonk@gmail.com\n// where i have a clear source i added shadertoy link\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sunDir =      normalize(vec3(0.,0.6, -1.));\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uvx= vec2((1.- 2. * uv.x) * aspect + sin(time * 0.1)*0.2+sin(time *3.)*.01,-1. + 2. * uv.y-0.6+sin(time *3.)*.01);\n    \n    vec3 rd = normalize(vec3(uvx, -3.0));\n    vec3 ro = vec3(sin(time * 0.1)*3.+sin(time *3.)*.01,5.+sin(time *5.)*.009, -time+sin(time *4.)*.011);\n    #ifdef steadycam\n    ro = vec3(0.,5.+sin(time *5.)*.009,10.8 +sin(time *4.)*.011);\n    #endif\n\n    bool result;\n    float distance = RayMarch(ro,rd,iChannel0,time,result);\n    float distfract = clamp(distance*DrawDistanceFract,0.,1.);\n    \n     vec3 c = rampSky((uv.y-0.4)*1.1);\n     \n \n     if(result)\n     {\n         vec3 point = target(ro,rd,distance);\n         float h = height(point.xz,iChannel0,time);\n         float waterheight = wheight(point.xz,iChannel0,time);\n         if(h < waterheight)\n         {\n            distance = wRayMarch(ro,rd,iChannel0,time,result);\n            distfract = clamp(distance*DrawDistanceFract,0.,1.);\n            vec3 point = target(ro,rd,distance);\n            h = wheight(point.xz,iChannel0,time);\n            \n            vec3 waternormal = wtexNormalMap(point.xz,1.,iChannel3,time);\n            //vec3 waternormal = normalize(waterripple(point.xz * 0.02 + distance * 0.002,iChannel3,iTime) + vec3(0,0,2.+ (distfract * distfract) * 10.));\n            vec3 wd = refract(rd,waternormal, .97);\n            vec3 wr = normalize(reflect(rd,waternormal));\n             float wdistance = RayMarch(point,wd,iChannel0,time,result);\n             float wdistfract = clamp(wdistance*DrawDistanceFract,0.,1.);\n             vec3 wp = target(point,wd,wdistance);\n             float wheight =  height(wp.xz,iChannel0,time)-0.1;\n             \n             float reflectdist = RayMarch(point,reflect(rd,mix(wr,vec3(0.,1.,0.),0.99)),iChannel0,time,result);\n             \n             float hilight = 0.;\n             if(!result){\n                 hilight = clamp((dot(wr,waternormal)/(abs(uvx.x)+.2) * 0.5 + 0.5)* distance *0.02,0.,1.);\n                 }\n             vec3 skyreflect = rampSky(1.1 - texture(iChannel2,-wr).x* 0.6);\n             skyreflect = mix(skyreflect,texture(iChannel2,wr).xyz,.5);\n             \n             float wsun = dot( texNormalMap(wp.xz,1.,iChannel0,time), sunDir);\n             wsun += dot( texNormalMap(wp.xz,0.25,iChannel0,time), sunDir )*2.;\n             wsun += dot( texNormalMap(wp.xz,0.02,iChannel0,time), sunDir )*4.,\n             wsun *= 0.143;\n             wsun = clamp( wsun, 0.0, 1.0 )-0.6;\n             float absorbtion = mix(2.9-(wdistfract*25.),wheight,.5);\n             \n             float cst = caustics3D(wp ,texNormalMap(wp.xz,1.,iChannel0,time),time*3.5)*0.1* absorbtion; // * clamp(wdistance,0.,1.)*clamp(wp.y/3.,0.,1.);\n             \n             vec3 c1 = mix(color(wp.xz,absorbtion,iChannel1) + wsun,skyreflect,hilight) +cst;\n       \n             c = mix(c1,c,distfract);\n             c = foam(point.xz + waternormal.xy *0.15,iChannel3,iChannel1,c,h-wheight);\n         }\n         else{\n         vec3 normal =texNormalMap(point.xz,1.,iChannel0,time);\n         vec3 normal2 =texNormalMap(point.xz,0.25,iChannel0,time);\n          vec3 normal3 = texNormalMap(point.xz,0.02,iChannel0,time);\n        \n         \n             float sun = dot( normal, sunDir);\n             sun += dot( normal2, sunDir )*2.;\n             sun += dot( normal3, sunDir )*4.,\n             sun *= 0.143;\n             sun = clamp( sun, 0.0, 1.0 )-0.6;\n             c = mix(color(point.xz,h,iChannel1) + sun,c,distfract);\n             c = mix(c+ vec3(0.08,0.06,0.04),c,distfract);\n         }\n     }else\n     {\n     c += vec3(1.2,1.1,1.)*0.5 * (1.0-smoothstep(length( uvx* vec2(.5,1.) +vec2(0.,0.05)),0.0,0.01)/ 0.9);\n     }\n    fragColor = vec4(c,distfract);\n\n}\n\n", "buffer_a_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0.5,0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0.5,-0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(-0.5,0.5);\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 278]], "test": "untested"}
{"id": "NsV3zW", "name": "mirror or eyes", "author": "jorge2017a1", "description": "mirror or eyes", "tags": ["mirrororeyes"], "likes": 2, "viewed": 216, "published": 3, "date": "1631194806", "time_retrieved": "2024-07-30T19:02:25.497246", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n//mirror or eyes---9-sep-2021\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nvec3 EspejoFalso(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\nfloat la=2.0;\n   float lb=3.0;\n   float h=1.0;\n   float ra=2.0;\n   \n    vec3 p2=p;\n    vec3 p1=p;\n    \n    p1= rotate_x(p1, radians(90.0));\n    p2= rotate_x(p2, radians(90.0));\n    \n    float sdr1=sdRhombus(p1, la,  lb,  h,  ra);\n    \n    la=1.5;lb=2.0;h=1.0;ra=2.0;\n    float sdr2=sdRhombus(p2, la,  lb,  h,  ra);\n    res =opU3(res, vec3(sdr1,4.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdr2,201.0,MATERIAL_NO));\n    return res; \n}    \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tp.y=p.y-7.0;\n   vec3 e1= EspejoFalso( p);\n   vec3 e2= EspejoFalso( p-vec3(8.0,0.0,.0));\n   \n   res =opU3(res, e1);\n   res =opU3(res, e2);\n   \n   float  sb1=sdBox( p-vec3(0.0,0.0,-30.), vec3(10.0,10.0,1.0) );\n   res =opU3(res, vec3(sb1,1.0,MATERIAL_NO));\n   \n   float sds1= sdSphere( p-vec3(13.0,0.0,-35.0), 6.0 );\n   float sds2= sdSphere( p-vec3(-10.0,0.0,-28.0), 5.0 );\n   \n   res =opU3(res, vec3(sds1,2.0,MATERIAL_NO)); \n   res =opU3(res, vec3(sds2,3.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {mObj.hitbln = true; minDist = abs(t); break;}\n        \n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        \n        t += dS.x;\n        marchCount++;\n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n     float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     \n     \n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj;    \n    if (id_color<100) { colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{  vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n \n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    { vec3 colref;\n      for(int i=0; i<2; ++i)\n      {  t=RayMarch(ro,rd, MAX_STEPS);\n         Obj=mObj;\n         \n           if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        n=GetNormal(p);\n       rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        if (t<MAX_DIST)\n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        \n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n        \n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 5.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0+7.0*sin(t),7.0+2.0*sin(t*0.5),-23.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    vec3 col= Render( ro,  rd);\n    col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n///--------------------------------------------FIN\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 545, 545, 566], [567, 567, 599, 599, 683], [685, 729, 776, 776, 803], [804, 804, 847, 847, 874], [875, 875, 923, 923, 951], [952, 990, 1026, 1026, 1071], [1073, 1138, 1172, 1172, 1268], [1269, 1269, 1303, 1303, 1394], [1395, 1395, 1429, 1429, 1520], [1521, 1561, 1586, 1586, 1605], [1606, 1606, 1631, 1631, 1650], [1651, 1651, 1687, 1687, 1715], [1717, 1717, 1781, 1781, 2032], [2034, 2034, 2060, 2060, 2527], [2533, 2573, 2598, 2598, 3190], [3192, 3243, 3267, 3267, 3429], [3431, 3431, 3480, 3480, 4131], [4134, 4188, 4224, 4224, 4469], [4470, 4525, 4552, 4552, 4569], [4571, 4571, 4607, 4607, 4699], [4700, 4700, 4746, 4746, 4871], [4873, 4873, 4947, 4947, 6546], [6547, 6581, 6661, 6661, 6784], [6785, 6837, 6930, 6930, 7029], [7802, 7802, 7833, 7833, 8418], [8420, 8469, 8495, 8495, 8605], [8607, 8607, 8665, 8665, 8717], [8719, 8768, 8825, 8825, 9392]], "test": "untested"}
{"id": "7dVGR1", "name": "Contours of Complex Polynomials", "author": "pyBlob", "description": "Consider every line/if/comment as a potential toggle/radio-button.\n\nTop: Complex Plane, value = eval(R * O.x + I * O.y)\nBottom: Plot, value = eval(R * O.x) - (R + I) * O.y\n\nContours at integers:\n  - Red: Re(value)\n  - Green: Im(value)\n  - Blue: Abs(value)", "tags": ["complex", "polynomial"], "likes": 7, "viewed": 346, "published": 3, "date": "1631189745", "time_retrieved": "2024-07-30T19:02:26.261204", "image_code": "float T_AA = 5.;\nfloat S_AA = 5.;\n\nmat2 S, R0, R1, R2;\nmat2 eval(vec2 O, float iTime)\n{\n    mat2 o = O.x * R + O.y * I;\n    mat2 v = mat2(0);\n    \n    // polynomial\n    v += (o - R0) * (o - R1) * (o - R2);\n    \n    // parts of 1st derivative\n    if (false)\n    {\n        v += (o - R0) * (o - R1);\n        v += (o - R0) * (o - R2);\n        v += (o - R1) * (o - R2);\n    }\n    \n    // parts of 2nd derivative\n    if (false)\n    {\n        v += (o - R0);\n        v += (o - R1);\n        v += (o - R2);\n    }\n\n    // parts of 3rd derivative\n    v *= S;\n\n    // use inverse(...) to turn root into pole\n    //v *= inverse(o - -R0) * inverse(o - -R1) * inverse(o - -R2); // -Rn, so that they are distinct to roots\n    \n    // use transpose(...) to turn a node into an anti-node\n    //v = (o - R1) * transpose(o - -R1);\n\n    // Warp along green contours of Im(v), Re(v) stays not changed, Roots move, Poles stay put\n    //v += R * iTime;\n    //v += R * iTime * -0.1;\n    //if (demo) v += R * tzig(iTime, 2.);\n    //v += R * tzig(iTime, 2.);\n    //v += R * -M.x;\n\n    // Warp along red contours of Re(v), Im(v) stays constant, Roots move, Poles stay put\n    //v += I * iTime;\n    //v += I * iTime * 0.1;\n    //v += I * zig(iTime * .1) * 10.;\n    //v += I * -M.y;\n\n    // warp Im + Re\n    if (demo) v += loop(iTime, 2.);\n\n    // Rotate around blue contours of Abs(v), Roots stay put, Poles stay put\n    // Roots rotate counter-cockwise, Poles rotate clockwise, Anti-Roots rotate clockwise\n    float a = iTime * +0.0 + 0.0;\n    float b = iTime * +0.0 + 0.0;\n    //b += 2. * atan(M.y, M.x);\n    //v += cos(a) * R + sin(a) * I;\n    //v += -2. * R;\n    //v *= cos(-a / 2.) * R + sin(-a / 2.) * I;\n    v *= cos(-b) * R + sin(-b) * I;\n\n    // Note, that the count of points on a blue contour where a red (or green) contour\n    // crosses at right angles (or touches) is equal to \"2 * abs(#roots - #poles)\" that\n    // are enclosed by the blue contour. As a consequence, blue contours have a rotation\n    // speed of \"1 / (#roots - #poles)\".\n    if (false)\n    {\n        float b = iTime * +0.1;\n        mat2 T = cos(-b) * R + sin(-b) * I;\n        //v = T * o;\n        //v = T * o * (o - R1);\n        v = T * inverse(o - R0) * inverse(o - R1) * inverse(o - R2) * o * o;\n        //v = T * inverse(o - R0) * inverse(o - R1) * inverse(o - R2) * o * o * o;\n    }\n\n    return v;\n}\n\nvec4 image(vec2 O, float iTime)\n{\n    float f = 4. / iResolution.y;\n    O = (O - iResolution.xy / 2.) * f;\n    \n    vec2 M = (iMouse.xy - iResolution.xy / 2. + .5) * f;\n    M = mix(M, vec2(1, 0), float(demo));\n    \n    S = R;\n    //R0 = - 0. * R +  0.  * I;\n    R0 = -2. * M.x * R +  0.  * I;\n    //R1 =   0. * R +  0.  * I;\n    R1 =  M.x * R +  M.y * I;\n    //R2 =   0. * R +  0.  * I;\n    //R2 = -M.x * R + -M.y * I;\n    R2 = M.x * R + -M.y * I;\n\n    mat2 v = eval(O, iTime);\n    vec3 c = vec3(Re(v), Im(v), Abs(v));\n    vec3 wc = fwidth(c);\n    vec4 C = vec4(0);\n\n    // Top\n    //C.xy = step(fract(pow(abs(c.xy), vec2(1. / 2.)) + .05), vec2(.1)); // preview stroke, exponent varies slope spacing\n    //C.z = step(fract(pow(c.z, 1. / 2.) * 1. + .05), .1);\n    //C.xyz = .7 - abs(c - round(c)) / fwidth(c); // gleboneloner: anti-aliased 1px stroke, can be used with S_AA = 1\n    C.xyz = step(abs(edge(c)), .25 * wc); // 1px stroke, integer spacing\n    //C.xy += c.xy * .05; // continous\n    //C.xy += .000 + .2 * step(vec2(0), c.xy); // fill Re(v)>0 and Im(v)>0\n    \n    if (c.z < 2.25 * wc.z) C.xyz = vec3(1, 1, 0);\n    \n    // Bottom\n    if (!toggled(key_B))\n    {\n        vec4 CB = C;\n        if (abs(0. - O.y) < .5 * f) CB.xyz = vec3(1.); // Separator\n        if (O.y < 0.)\n        {\n            //if (abs(Re(eval(vec2(O.x, 0), iTime)) * x - O.y) < .5 * f)\n            //if (abs(fract(Re(eval(vec2(O.x, 0), iTime))) * x - O.y) < .5 * f)\n            //if (abs(edge(Re(eval(vec2(O.x, 0), iTime)) - O.y / x)) * x < .5 * f)\n            if (false)\n                C.xyz = vec3(1.);\n            {\n                mat2 v = eval(vec2(O.x, 0), iTime);\n                vec3 c = vec3(Re(v), Im(v), Abs(v)) - O.y;\n                vec3 wc = fwidth(c);\n                CB.xyz = step(abs(edge(c)), .25 * wc);\n                CB.z = 0.;\n            }\n        }\n        C = mix(C, CB, max(float(!demo), smoothstep(0., .5, tzig(iTime, 3.))));\n        //C = CB;\n    }\n    \n    //if (length(O - 1. * vec2(-sin(a), cos(a))) < .1) C.xyz = vec3(1.);\n\n    return C;\n}\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    demo = iMouse.z == 0.;\n    C = vec4(0);\n    for (vec3 d=vec3(.5) ; d.z<T_AA ; ++d.z)\n    for (d.y=.5 ; d.y<S_AA ; ++d.y)\n    for (d.x=.5 ; d.x<S_AA ; ++d.x)\n    {\n        float t = 0.;\n        t = iTime + d.z / T_AA * iTimeDelta;\n        //t = (float(iFrame) + d.z / T_AA) / 60.;\n        //t = iTime + d.z / T_AA / 60.;\n        C += image(d.xy / S_AA - 0.5 + O, t);\n    }\n    C /= S_AA * S_AA * T_AA;\n    //C.xyz *= vec3(.7, .5, 1);\n    C.xyz = pow(C.xyz, vec3(1. / 2.2));\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool demo;\n\nmat2 R = mat2(1,  0, 0, 1);\nmat2 I = mat2(0, -1, 1, 0);\n\nfloat Re(mat2 v)\n{\n    return v[0].x;\n}\n\nfloat Im(mat2 v)\n{\n    return v[1].x;\n}\n\nfloat Abs(mat2 v)\n{\n    return length(vec2(Re(v), Im(v)));\n}\n\n#define zig(x) \\\n    (abs(mod((x) + 1., 4.) - 2.) - 1.)\n\n#define tzig(x, t) \\\n    (zig((x) / (t)) * (t))\n\n#define edge(x) \\\n    ((x) - round(x))\n\n#define loop(x, t) \\\n    ( R * clamp(tzig((x)           , 2. * (t)), -(t), (t)) \\\n    + I * clamp(tzig((x) + 2. * (t), 2. * (t)), -(t), (t)) \\\n    )\n\nconst ivec2 key_B = ivec2(0x42, 2);\n\n#define toggled(key) \\\n    (texelFetch(iChannel3, (key), 0).r > .5)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 87, 87, 2355], [2357, 2357, 2390, 2390, 4406], [4408, 4408, 4444, 4444, 4923]], "test": "untested"}
{"id": "fdV3RW", "name": "Nebulous Nonformanifest", "author": "xenn", "description": "An impression of an alien eye can occur more apparently under higher resolutions\n\n ~ Kaiju [eye of] Sauron ~\n\n. Try going full screen then Alt-1 (to refresh/force 100% pixel canvas extents\nmouse click influences general direction ", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 28, "viewed": 760, "published": 3, "date": "1631188233", "time_retrieved": "2024-07-30T19:02:27.322366", "image_code": "// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 3.51;\n    float b = 01.03;\n    float c = 1.43;\n    float d = 1.59;\n    float e = 02.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = max(col,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                     col2 = max(col,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (max(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),(250.0 * abs(sin(iTime / 13.0))));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.05,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.05\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 50;\nfloat blur = 0.5; \nfloat falloff = 2.50; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .9999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.00051;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .12;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .69;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 3.0;\nconst float iColorShiftOfRadius       = -.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 5.1))), dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * ( iFeedbackColorShiftZoom * (1.5 * sin(iTime / 2.81))) * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.br - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.025);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 138, 138, 217], [219, 219, 242, 242, 384], [386, 386, 443, 443, 1793]], "test": "untested"}
{"id": "fsKGRR", "name": "Stacked Slices of Noise", "author": "byt3_m3chanic", "description": "Do you like noise? Well slice it thick and rotate it on an isometric angle and call me happy! ( mouseable and stuff )", "tags": ["raymarching", "noise", "text", "transparent", "data"], "likes": 30, "viewed": 543, "published": 3, "date": "1631186390", "time_retrieved": "2024-07-30T19:02:28.086324", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Stacked Slices of Noise\n    @byt3_m3chanic | 09/08/21\n\n    Saw something on twitter and went - how would I build that.\n    Not toally happy with the noise \"slices\" doing a max of a\n    squre sdf + noise value.. Not as clean as I'd like...\n    \n    doing some concept shaders as background art in webpages.\n    scroll bar controls the noise - drag to spin.\n    https://longscroll-shader.surge.sh/\n\n*/\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .001\n#define MAX_DIST 90.\n\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\n////////////////////////////////////////////////////////\n// text and font stuff\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\n\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\nvec4 pInt(vec2 p, float n) {  \n// webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n////////////////////////////////////////////////////////\n// end text and font stuff\n\n//linear step timing function - book of shaders\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n//utils\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n// @morgan3d https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f * f * (3.-2.*f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//@iq 2Dbox functions and extrude\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n//globals\nvec3 hit,hitPoint;\nvec2 mtack;\nmat2 r21,rx,ry;\nfloat tmod=0.,time=0.,ga1=0.,ga2=0.,ga4=0.;\nfloat sns,gns;\n\nconst float size = .525;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    vec3 o=p;\n    p+=vec3(-7,0,0);\n    p.xz*=r21;\n    \n    float id;\n    vec3 q;\n    p.y+= ga1;\n    for(int i = 0; i<2; i++)\n    {\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x,p.y-cnt,p.z);\n        \n        id = floor(q.y/dbl) + .5;\n        q.y -= id*dbl;\n        float ns = 0.;\n        if(length(q.xz)<8.) {\n            ns = noise((q.xz*.35)+abs(id*.20)+mtack);\n            ns+= noise((q.zx*.85)-abs(id*.24)+mtack)*.45;\n        }\n        \n        ns=smoothstep(.55,.85,clamp(ns,0.,1.))*.45;\n        if(ns<.0125)ns=0.;\n        \n        float nz = box(q.xz,vec2(6.5,4.5));\n        float d = opx(max(ns,nz), q.y, .1+.09*sin(p.y*.5));\n        if(d<res.x){\n            res = vec2(d,3.);\n            hit = q;\n            gns=id;\n        }\n        \n        vec3 r = vec3(abs(q.x),q.y,abs(q.z))-vec3(5,0,6);\n        float pl = box(r.xz,vec2(1.75,.25));\n        float d9 = opx(pl, r.y, 1.);\n        if(d9<res.x) {\n            res = vec2(d9,1.);\n            hit=r;\n        }\n    }\n    return res;\n}\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist){\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.808,0.318,0.051);\n    return .75 + .425*cos(PI2*t*(vec3(0.839,0.961,0.929)+d)); \n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n){\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(-9,8,9);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),.03,1.);\n    diff += clamp(dot(n,vec3(-1,1,-1)),.0,1.)*.15;\n    float riff = diff;\n    float shadow = 0.;\n    for(int i=0;i<20;i++)\n    {\n        vec3 q = (p + n * .1) + l * shadow;\n        float h = map(q).x;\n        if(h<MIN_DIST*d||shadow>MAX_DIST)break;\n        shadow += h;\n    } \n    if(shadow < length(p -  lpos)) riff *= .15;\n    diff = mix(diff,riff,.65);\n\n    vec3 h = vec3(0);\n    if(m==3.) h = hue(sns*.03);\n    if(m==1.) h = vec3(0.514,0.725,0.702);\n    \n    return vec3(h*diff);\n}\n\nvoid overLay(inout vec3 C, vec2 p) {\n\n    float dsz = 4.;\n    float dhf = 2.;\n    vec2 uv = p*5.;\n    float px = fwidth(p.x);\n    p.y+=ga1*.06;\n    p*=140.;\n    float id = floor((p.y+dhf)/dsz);\n    vec2 grid=p+vec2(53.5,0);\n    \n    grid.y=mod(grid.y+dhf,dsz)-dhf;\n\n    vec2 mvt = floor((mtack*50.)+.5);\n    float hs = noise((vec2(id,mvt))*.25);\n\n    float b = box(grid-vec2(2.5+hs*5.5,0),vec2(hs*5.5,1.75));\n    b=smoothstep(.02+px,-px,b);\n\n    C =mix(C,C+(hue(hs)*.3),b);\n \n    float mpt = length(uv+vec2(2.75,mtack.x-2.5))-.425;\n      mpt = min(length(uv+vec2(4.  ,mtack.y-2.5))-.425, mpt);\n    mpt=abs(mpt)-.025;\n    mpt=smoothstep(.02+px,-px,mpt);\n    C =mix(C,C+.2,mpt);\n    \n    vec2 fgd = grid;\n    vec4 O = vec4(0);\n    float FontSize = 5.25;\n    fgd.xy/=FontSize;\n\n    O = pInt(fgd.xy+vec2(.625,.5), floor(hs*10.)+1.);\n    float ck=smoothstep(-px,.05+px,O.x);\n    C =mix(C,C+.2,ck);\n    \n    O = pInt((uv)+vec2(3.225 ,mtack.x-1.995), floor(mtack.x)+2.);\n    ck= smoothstep(-px,.05+px,O.x);\n    C =mix(C,C+.2,ck);\n    \n    O = pInt((uv)+vec2(4.48 ,mtack.y-1.995), floor(mtack.y)+2.);\n    ck= smoothstep(-px,.05+px,O.x);\n    C =mix(C,C+.2,ck);\n}\n\nfloat zoom = 18.;\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // precal all your vars\n    time = T;\n    tmod = mod(time, 10.);\n    mtack = M.xy==vec2(0)? vec2(1.,4.) : (M.xy/R.xy)*5.;\n    \n    float t1 = lsp(0.0, 4.0, tmod);\n    float t2 = lsp(4.0, 10.0, tmod);\n    ga4 = (t2)+floor(time*.1);\n    ga1 = (t1+floor(time*.1))*10.;\n    r21 = rot(ga4*PI);\n    // \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    rx = rot(-0.5259);\n    ry = rot(0.78539);\n                \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = .9;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<164;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<12||i>132 ? ray.x*.3 : ray.x;\n        p += rd * d * k;\n        float tg=0.;\n        if (d*d < 1e-6) {\n            hitPoint = hit;\n            sns=gns;\n            tg=1.;\n            \n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            if(m==3.)break;\n            \n            atten *= .8;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n            fresnel = mix(.0, .9, fresnel);\n\n            if(int(F.x)%4 != int(F.y)%4) {\n                vec3 rr = refract(rd,n,.55);\n                rd=mix(rr,rd,fresnel);\n            }else{\n                rd=reflect(-rd,n);\n                p+=n*.01;\n            }\n        } \n\n        \n        if(distance(p,rd)>55.) {         \n            if(tg==0.) C=mix(vec3(0.400,0.576,0.541),C,clamp(uv.x+1.,0.,1.));\n            break; \n       }\n    }\n\n\n    C = mix(C,C+.055,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(1));\n    \n    overLay(C,uv);\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n//end\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGRR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[908, 908, 934, 934, 1104], [1105, 1105, 1133, 1171, 1291], [1377, 1425, 1469, 1469, 1524], [1525, 1533, 1553, 1553, 1598], [1599, 1599, 1623, 1623, 1681], [1683, 1734, 1761, 1761, 2066], [2068, 2102, 2136, 2136, 2216], [2218, 2218, 2267, 2267, 2363], [2562, 2562, 2580, 2580, 3612], [3613, 3688, 3732, 3732, 3947], [3948, 3995, 4013, 4013, 4117], [4119, 4119, 4189, 4189, 4806], [4808, 4808, 4844, 4844, 5961], [5981, 5981, 6022, 6051, 7819]], "test": "untested"}
{"id": "7sG3zD", "name": "Dynamic 3D Mondrian", "author": "dr2", "description": "Pseudo-Mondrian in 3D (generalization of 2D \"Mondrian in Motion\")", "tags": ["dynamics", "art", "mondrian"], "likes": 13, "viewed": 281, "published": 3, "date": "1631182254", "time_retrieved": "2024-07-30T19:02:29.058724", "image_code": "// \"Dynamic 3D Mondrian\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nbEdge = 5;\nconst int nBall = nbEdge * nbEdge * nbEdge;\n\nvec3 ltDir, hbSize, boxAng, vnBlk, vnBox;\nvec2 qBlk;\nfloat tCur, dstFar, hbMarg, bCylRad, bCylHt, baseRad, baseUp, szBlk;\nint idObj, idBlk;\nconst float pi = 3.1415927;\nconst int txOff = 4;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  p.y -= baseUp;\n  q = abs (OrAng (p));\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.05),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.05)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.05));\n  DMIN (1);\n  b = length (hbSize.xy - hbMarg);\n  f = 0.5 * (baseUp - 0.05);\n  tr = 0.25;\n  sLen.xyz = vec3 (b + 6. * tr, f - tr, hbSize.z - hbMarg + 2. * tr);\n  d = PrCylDf (vec3 (q.xy, abs (q.z) - sLen.z + tr), 0.8 * tr, tr);\n  DMIN (3);\n  q = p;\n  q.xz = Rot2D (q.xz, boxAng.y);\n  q.yz = Rot2D (q.yz, boxAng.x);\n  d = min (PrRoundBoxDf (vec3 (q.xy, abs (q.z) - sLen.z),\n     vec3 (b + 4. * tr, tr, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (abs (q.x) - b - 3. * tr, q.yz),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  DMIN (2);\n  d = PrCylDf (vec3 (abs (q.x) - b - 4.5 * tr, q.yz).yzx, 0.8 * tr, tr);\n  DMIN (3);\n  q = p;\n  q.xz = Rot2D (q.xz, boxAng.y);\n  d = PrRoundBoxDf (vec3 (abs (q.xz) - sLen.xz, q.y + sLen.y).xzy,\n     vec3 (tr, f, tr) - 0.1, 0.1);\n  d = min (d, PrRoundBoxDf (vec3 (abs (q.x) - sLen.x, abs (q.y + sLen.y) - sLen.y, q.z),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y + 2. * sLen.y).xzy,\n     vec3 (sLen.x, tr, tr) - 0.1, 0.1));\n  DMIN (2);\n  d = PrCylDf (vec3 (q.xz, q.y + 2. * sLen.y), 2. * tr, 1.4 * tr);\n  DMIN (3);\n  q = p;\n  q.y -= - 2. * f - 0.05;\n  d = PrRoundCylDf (q.xzy, baseRad, 0.1, 0.15);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 v, tm, tp, u;\n  float dMin, dn, df, sz;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 2 * n);\n    v = (ro - p.xyz) / rd;\n    sz = 0.5 * p.w - 0.15;\n    tp = sz / abs (rd) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      idBlk = n;\n      szBlk = sz;\n      u = (v + dn) * rd;\n    }\n  }\n  if (dMin < dstFar) qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n  return dMin;\n}\n\nfloat BoxHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBox = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, rob, rdb, vn;\n  float dstBlk, dstObj, db, nDotL, reflFac;\n  reflFac = 1.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || reflFac < 1.) {\n      rob = OrAng (ro - vec3 (0., baseUp, 0.));\n      rdb = OrAng (rd);\n      db = BoxHit (rob, rdb);\n      dstBlk = (db < dstFar) ? BlkHit (rob, rdb) : dstFar;\n      dstObj = ObjRay (ro, rd);\n    }\n    if (k == 0) {\n      if (dstObj < min (dstBlk, dstFar) && idObj == 4 && length (ro.xz + dstObj * rd.xz) < \n         baseRad - 0.3) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        rd = reflect (rd, vn);\n        ro += 0.01 * rd;\n        reflFac = 0.8;\n      }\n    }\n  }\n  if (dstObj < min (dstBlk, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.85, 0.8, 0.8);\n    else if (idObj == 2) col = vec3 (0.9, 0.9, 0.8);\n    else if (idObj == 3) col = vec3 (0.8, 0.7, 0.7);\n    else if (idObj == 4) col = vec3 (0.9, 0.9, 0.95);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.2 * max (dot (vn, - ltDir), 0.) + 0.8 * nDotL * nDotL +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else if (dstBlk < dstFar) {\n    ro += dstBlk * rd;\n    vn = OrAngT (vnBlk);\n    col = HsvToRgb (vec3 (mod (33. * float (idBlk) / float (nBall), 1.), 0.7, 1.)) *\n       (0.2 + 0.8 * smoothstep (0.06, 0.1, szBlk - Maxv2 (abs (qBlk))));\n    col = col * (0.2 + 0.2 * max (dot (vn, - ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else {\n    col = vec3 (0., 0., 0.1) * (0.85 + 0.15 * SmoothBump (0.3, 0.7, 0.15,\n       mod (32. * atan (rd.z, rd.x) / pi, 1.))) + 80. * pow (1. - 0.6 * abs (dot (rd,\n       VaryNf (512. * vec3 (rd.xz, rd.y / length (rd.xz) + 0.005 * tCur).xzy, rd, 2.))), 8.);\n  }\n  if (db < min (dstObj, dstFar)) {\n    ro = rob + db * rdb;\n    col *= 0.95;\n    vn = OrAngT (vnBox);\n    col = mix (col, vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.), pow (1. - abs (dot (rd, vn)), 5.));\n  }\n  col *= reflFac;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float slVal, float msMode)\n{\n  vec4 wgBx[2];\n  vec3 c;\n  vec2 ut, ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n  wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n  c = vec3 (0.3, 1., 0.3);\n  ut = 0.5 * uv - wgBx[0].xy;\n  ust = abs (ut) - wgBx[0].zw * vec2 (0.7, 1.);\n  if (Maxv2 (ust) < 0.) col = (Minv2 (abs (ust)) * canvas.y < 2.) ? 0.8 * c : col;\n  ut.y -= (slVal - 0.5) * 2. * wgBx[0].w;\n  if (abs (length (ut * vec2 (1., 2.)) - 0.02) * canvas.y < 2.) col = c;\n  ut = 0.5 * uv - wgBx[1].xy;\n  if (length (ut) < wgBx[1].z) col = mix (((msMode > 0.) ? c.grb : c),\n     col, smoothstep (2., 4., abs (length (ut) - 0.02) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr, slVal, msMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  baseRad = 2.8 * hbSize.x;\n  msMode = stDat.w;\n  stDat = Loadv4 (1);\n  boxAng = stDat.xyz;\n  slVal = boxAng.z / (2. * pi);\n  stDat = Loadv4 (3);\n  el = stDat.x;\n  az = stDat.y;\n  vuMat = StdVuMat (el, az);\n  bCylRad = 56.;\n  bCylHt = 14.;\n  ro = vuMat * vec3 (0., -0.2 * bCylHt, -0.95 * bCylRad);\n  hbMarg = 0.4;\n  baseUp = 1.2 * length (hbSize - hbMarg) + 0.05;\n  ro.y += 0.5 * bCylHt;\n  zmFac = 5.5;\n  dstFar = 20. * length (hbSize);\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col, slVal, msMode);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.xz = Rot2D (p.xz, boxAng.y);\n  p.yz = Rot2D (p.yz, boxAng.x);\n  p.xy = Rot2D (p.xy, boxAng.z);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.xy = Rot2D (p.xy, - boxAng.z);\n  p.yz = Rot2D (p.yz, - boxAng.x);\n  p.xz = Rot2D (p.xz, - boxAng.y);\n  return p;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Dynamic 3D Mondrian\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nbEdge = 5;\nconst int nBall = nbEdge * nbEdge * nbEdge;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\nconst int txOff = 4;\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, inout vec3 am)\n{\n  vec4 p;\n  vec3 rmN, vmN, dr, dv;\n  float rSep, h, fc;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 2 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (txOff + 2 * n + 1).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, float diam, inout vec3 am)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out float diam)\n{\n  vec4 p;\n  vec3 am;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 0.1;\n  fricT = 0.1;\n  fricS = 0.5;\n  fDamp = 0.0001;\n  grav = 0.1;\n  p = Loadv4 (txOff + 2 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 2 * mId + 1);\n  vm = p.xyz;\n  ms = diam * diam;\n  am = vec3 (0.);\n  PairInt (mId, rm, vm, am);\n  BdyInt (rm, vm, diam, am);\n  am -= grav * gVec + fDamp * vm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out float diam)\n{\n  float mIdf, nbE;\n  mIdf = float (mId);\n  nbE = float (nbEdge);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, nbE), mod (mIdf, nbE * nbE) / nbE,\n     mIdf / (nbE * nbE))) - 0.5 * (nbE - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  diam = 1. + Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p;\n  vec3 rm, vm, boxAng;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 2;\n  else mId = -1;\n  wgReg = -2;\n  doInit = (iFrame <= 5);\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    wgSel = -1;\n    el = -0.12 * pi;\n    az = 0.;\n    slVal = 0.75;\n    boxAng = vec3 (0., -0.5 * pi, 2. * pi * slVal);\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    msMode = stDat.w;\n    stDat = Loadv4 (1);\n    boxAng = stDat.xyz;\n    slVal = boxAng.z / (2. * pi);\n    stDat = Loadv4 (2);\n    mPtrP.xyz = stDat.xyz;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    wgSel = int (stDat.z);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        boxAng.y = -0.5 * pi - 2. * pi * mPtr.x;\n        boxAng.x = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.1 * pi + 0.8 * pi * mPtr.y, -0.35 * pi, -0.05 * pi);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    boxAng = mod (boxAng + pi * vec3 (0.0003, 0.00031, 0.00032), 2. * pi);\n    slVal = boxAng.z / (2. * pi);\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    boxAng.z = 2. * pi * slVal;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), boxAng.x));\n  gVec.xy = Rot2D (gVec.xy, boxAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, diam);\n    else Step (mId, rm, vm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, msMode);\n  else if (pxId == 1) stDat = vec4 (boxAng, 0.);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (el, az, float (wgSel), nStep);\n  else {\n    mId = pxId - (txOff + 2 * mId);\n    p = (mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.);\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3zD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1097, 1097, 1119, 1119, 2663], [2665, 2665, 2698, 2698, 2882], [2884, 2884, 2905, 2905, 3162], [3164, 3164, 3197, 3197, 3783], [3785, 3785, 3818, 3818, 4130], [4132, 4132, 4167, 4167, 6298], [6300, 6300, 6373, 6373, 7047], [7049, 7049, 7102, 7102, 8455], [8457, 8457, 8503, 8503, 8550], [8552, 8552, 8594, 8594, 8645], [8647, 8647, 8704, 8704, 8780], [8782, 8782, 8803, 8803, 8916], [8918, 8918, 8940, 8940, 9059], [9061, 9061, 9083, 9083, 9110], [9112, 9112, 9134, 9134, 9161], [9163, 9163, 9185, 9185, 9223], [9225, 9225, 9247, 9247, 9285], [9287, 9287, 9332, 9332, 9424], [9426, 9426, 9483, 9483, 9566], [9568, 9568, 9604, 9604, 9810], [9812, 9812, 9842, 9842, 9955], [9957, 9957, 9981, 9981, 10103], [10137, 10137, 10161, 10161, 10273], [10275, 10275, 10300, 10300, 10486], [10488, 10488, 10517, 10517, 10729], [10731, 10731, 10770, 10770, 11027], [11121, 11121, 11146, 11146, 11269]], "test": "untested"}
{"id": "sst3Ws", "name": "Double Helix Assembly Kit", "author": "Tater", "description": "Really pleased I was able to figure out the math for the stacking effect, in the end it wasn't that complicated but I tried a lot of things that didn't work. Part of me still feels it can be massively simplified but idk", "tags": ["3d", "raymarching", "stack", "helix", "stacking"], "likes": 16, "viewed": 409, "published": 3, "date": "1631181006", "time_retrieved": "2024-07-30T19:02:29.857589", "image_code": "#define STEPS 140.\n#define MDIST 100.\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x)) \n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//#define elon(p,h) (p-clamp(p,-h,h))\n\n//iq palette \nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//iq segment\nfloat seg(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n//iq extrude\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat layers(vec2 p, float t){\n    p.xy*=rot(t*0.1);\n    float off = (sin(t*0.1)*0.5+0.5)*4.0+6.0;\n    vec2 p2 = p;\n    p2.x = abs(p.x)-off;\n    float c = length(p2.xy)-1.5;\n    if(mod(t,7.0)<1.0){\n        //if(mod(id,2.0)<1.0) p.xz*=rot(pi/2.);\n        c = min(c,seg(p.xy,vec2(off,0),vec2(-off,0))-1.5);\n    }\n    return c;\n\n}\n\nvec2 map(vec3 p){\n    float t = iTime;\n    //p.y-=t*8.-20.;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    float spd = 8.0;\n    t*=spd;\n    float dh = 0.28; //Disk Height\n\n    float lscl = 1.0; //Leading Edge Scale\n    float le = -mod(t * lscl,lscl); //Lead Edge\n    float tscl = 5.; //Trailing Edge Scale\n    float te = tscl - mod(t * tscl,tscl); //Trailing Edge\n    float scl = 0.; //Final Scale for later\n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n    \n        //Transitional domain\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            //Alternative where the transitional domain slows down before stopping on the stack\n            //npy = mod(p.y-le,te-le);\n            //scl = te-le;\n            \n            mid = true;\n            id = floor(t);\n        }\n        //The stacked tower\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        //The falling part\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    \n    //Get Layer\n    float c = layers(p.xz,id);\n    \n    a.x = ext(p, c, dh);\n    a.x-=0.15;\n    \n    //The most annoying domain artifact fixing\n    if(!mid) a.x = min(a.x,max(-(abs(p.y)-scl*0.65),0.01));\n    else {\n        a.x = min(a.x,max(-(-po.y+le),0.1));\n    }\n    \n    a.y = id;\n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,15,-35);\n    ro.xz*=rot(iTime*pi/3.0*0.3);\n    vec3 lk = vec3(0,-3,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.9+uv.x*r+uv.y*cross(f,r));\n    float dO = 0.;\n    vec2 d = vec2(0);\n    vec3 p = vec3(0);\n    bool hit = false;\n    \n    for(float i = 0.; i<STEPS; i++){\n         p = ro+rd*dO;\n         d = map(p);\n         dO+=d.x*1.3; //Idk why this doesn't cause artifacts but whatever\n         if(abs(d.x)<0.005){\n             hit = true;\n             break;\n         }\n         if(dO>MDIST){\n             dO=MDIST;\n             break;\n         }\n    }\n    vec3 al = vec3(0);\n    if(hit){\n        vec3 e = vec3(0.5);\n        al = pal(d.y*0.5+iTime*0.1,e,e,e*2.0,vec3(0,0.33,0.66));\n        //Atlernative coloring by @Gaktan\n        //al = pal(p.y*0.005+d.y*0.5+iTime*0.05,e,e,e*2.0,vec3(0,0.33,0.66));\n        al*=1.5;\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.,0.1,1));\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),5.0);\n        float fres = 1.-abs(dot(rd,n))*.98;\n        float diff = dot(n, ld)*0.4+0.6;\n        col=al*diff+pow(spec,2.0)*0.3*vec3(0.008,0.133,0.078);\n        col*=1.2-fres;\n    }\n    col = sqrt(col);\n    col = mix(col,vec3(0.016,0.102,0.204)*(0.7-dot(uv,uv)),pow(min(dO/68.,1.0),3.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 203, 270, 270, 313], [314, 327, 361, 361, 476], [477, 490, 526, 526, 608], [610, 610, 640, 640, 937], [939, 939, 956, 956, 2497], [2498, 2498, 2516, 2516, 2644], [2645, 2645, 2702, 2702, 4161]], "test": "untested"}
{"id": "7sGGRD", "name": "kind of viscous, like honey", "author": "xenn", "description": "Quite relaxing, if you want to blob out and stare at something not unpleasant", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 14, "viewed": 531, "published": 3, "date": "1631170401", "time_retrieved": "2024-07-30T19:02:30.883844", "image_code": "\n// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 1.50\n\n// chromatic dispersion samples\n#define SAMPLES 64\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\n// Fork of \"Barbarella's Lava Lamp 3\" by xenn. https://shadertoy.com/view/sstGWl\n// 2021-09-06 05:11:27\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = .51;\n    float b = 0.03;\n    float c = 3.43;\n    float d = 0.59;\n    float e = 03.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 dd   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * dd + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n//    fragColor = vec4(contrast(col), 1.0);\n\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n//    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.0 * d).r,\n                      texture(iChannel0, uv - .0 * d).g,\n                      texture(iChannel0, uv - -.0 * d).b);\n                                  \n    vec3 colz = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - -.0 * d).g,\n                      texture(iChannel1, uv - .0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - .0 * d).g,\n                      texture(iChannel2, uv - -.0 * d).b);\n                      \n                      colz = max(colz,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                     col2 = max(colz,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n//  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,color)))*noise), 1.0);\n    \n     colz = vec3(contrast(col)+ vec3(ACESFilm(((color * 0.5)+ (min(col,color)))*noise))) ;\n     fragColor=vec4(colz,1.0);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,(0.25) );\n  \n  fragColor=blend;\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = 0.015;\nconst float iFeedbackColorShiftImpact = 0.002;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 100.5;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .69;\nconst float iBlob1PowFactor           = 30.;\nconst float iBlob1ColorPulseSpeed     = .024;\nconst float iBlob2Radius              = .7;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = 0.15;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = .225;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6 (\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.rb - .5) * iFeedbackColorShiftImpact  * (0.1*abs(cos(iTime*0.1231))) ;\n    stShift += iFeedbackShiftVector ;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   vec3 extraColor = repeatedTexture(iChannel3, uv - stShift).rgb;\n    extraColor *= iFeedbackFadeRate;\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob1Radius ) , iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob2Radius ), iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n    color *  (extraColor * extraColor);\n    \n //    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel2, uv);\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col,col2,(0.8 * abs(sin(iTime / 6.9))));\n\n    color -   clamp(color, 0., 2.5 );\n    fragColor = blend;\n//    fragColor = vec4(color, 1.);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n#define Margins .0\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 422, 422, 486], [488, 488, 508, 508, 557], [559, 1208, 1237, 1237, 1311], [1313, 1313, 1366, 1366, 1805], [1983, 1983, 2003, 2003, 2082], [2084, 2084, 2107, 2107, 2247], [2252, 2252, 2308, 2308, 4568]], "test": "untested"}
{"id": "wtVyDz", "name": "Triange Incircle", "author": "iq", "description": "The three bisectors of a triangle meet at a single point which is also the point that is equidistant to the three sides. And so, it's also the center of the incircle of the triangle.", "tags": ["2d", "incircle", "bisectors"], "likes": 22, "viewed": 688, "published": 3, "date": "1631153560", "time_retrieved": "2024-07-30T19:02:31.797402", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The three bisectors of a triangle meet at a single point\n// which is also the point that is equidistant to the three\n// sides. And so, it's also the center of the incircle of\n// the triangle.\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1-p0; vec2 v0 = p-p0;\n\tvec2 e1 = p2-p1; vec2 v1 = p-p1;\n\tvec2 e2 = p0-p2; vec2 v2 = p-p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot2(e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot2(e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot2(e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot2( pq0 ), cro(v0,e0) ),\n                       vec2( dot2( pq1 ), cro(v1,e1) )),\n                       vec2( dot2( pq2 ), cro(v2,e2) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v0, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v1, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v2, ce )));\n    \n    // draw equicenter in yellow\n    col = mix(col,vec3(1.0,1.0,0.0),smoothstep(0.005,0.001,sdDisk(p,ce,0.02)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyDz.jpg", "access": "api", "license": "mit", "functions": [[1275, 1275, 1336, 1336, 1472], [1531, 1560, 1610, 1610, 1638], [1640, 1670, 1722, 1722, 1842], [1844, 1880, 1914, 1914, 1940], [1941, 1941, 1966, 1966, 1985], [1986, 1986, 2053, 2053, 2544], [2603, 2603, 2660, 2660, 3731]], "test": "untested"}
{"id": "fdG3zD", "name": "God? that you smoking?", "author": "xenn", "description": "yeah\nmouse click influences general direction", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 16, "viewed": 416, "published": 3, "date": "1631149172", "time_retrieved": "2024-07-30T19:02:32.762820", "image_code": "// Fork of \"Barbarella's Lava Lamp 3\" by xenn. https://shadertoy.com/view/sstGWl\n// 2021-09-06 05:11:27\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 01.03;\n    float c = 2.43;\n    float d = 1.59;\n    float e = 02.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = max(col,col2);\n                  //    color = max(col2,col);\n                      col2 = mix(col2,color,0.5);\n                     col2 = max(col,color);\n                      \n                       \n    //  color = min(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,color)))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),100);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.05,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.01\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed 0.03456\n#define iBlob2ColorPulseSpeed -0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// Fork of \"not a fluid simulation\" by pali6. https://shadertoy.com/view/sdd3zj\n// 2021-09-01 08:39:43\n\n/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 50;\nfloat blur = 0.5; \nfloat falloff = 2.50; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.00051;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .25;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .69;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = .075;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.rb - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.02);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdG3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 196, 196, 275], [277, 277, 300, 300, 442], [444, 444, 501, 501, 1843]], "test": "untested"}
{"id": "7stGzs", "name": "Sine Movement tool", "author": "hzhou17", "description": "Sine Movement", "tags": ["sinemovement"], "likes": 2, "viewed": 90, "published": 3, "date": "1631146066", "time_retrieved": "2024-07-30T19:02:33.535754", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float w = fwidth(uv.x);\n\n\n    uv.y += sin(uv.x*5. + iTime)*0.3-0.5;\n        \n    \n    float top = smoothstep(0.5*sin(uv.x*30.), 0., sin(uv.y));\n\n    \n    vec3 col = vec3(top);\n    \n    col*= smoothstep(0.5*sin(uv.x*60.), 0., vec3(0., 1., 1.));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 459]], "test": "untested"}
{"id": "7dt3Rs", "name": "Simple Swedish Flag", "author": "hzhou17", "description": "Swedish Flag", "tags": ["swedishflag"], "likes": 0, "viewed": 73, "published": 3, "date": "1631145754", "time_retrieved": "2024-07-30T19:02:34.310682", "image_code": "vec3 BLUE = vec3(12, 85, 150)/255.;\nvec3 YELLOW = vec3(253, 195, 11)/255.;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n\n\n    float w = fwidth(uv.x);\n    \n    float left = smoothstep(0.3, 0.3+w, uv.x);\n    float right = smoothstep(0.45, 0.45-w, uv.x);\n\n\n    float top = smoothstep(0.4, 0.4+w, uv.y);\n    float bottom = smoothstep(0.6, 0.6-w, uv.y);\n\n\n\n    float color = clamp(left*right + top*bottom, 0., 1.);\n    \n\n\n    vec3 col = mix(BLUE, YELLOW, color);\n\n\n    vec3 c = vec3(color);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 135, 135, 581]], "test": "untested"}
{"id": "fdyGRD", "name": "Slowtember 07-09: Garden/Texting", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 10, "viewed": 225, "published": 3, "date": "1631143271", "time_retrieved": "2024-07-30T19:02:35.361871", "image_code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * 2. * PI) * uv.x - sin(angle * 2. * PI) * uv.y,\n        sin(angle * 2. * PI) * uv.x + cos(angle * 2. * PI) * uv.y\n    );\n}\n\nfloat h(vec2 uv, float y0, float height, float e) {\n    return estep(y0 - height * .5, uv.y, -e) * estep(y0 + height * .5, uv.y, e);\n}\n\nfloat v(vec2 uv, float x0, float width, float e) {\n    return estep(x0 - width * .5, uv.x, -e) * estep(x0 + width * .5, uv.x, e);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circle(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return estep(min(size.x, size.y) * .5, length(uv), e * 2.);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return \n        estep(size.x * .5, uv.x, e) *\n        estep(-size.x * .5, uv.x, -e) *\n        estep(size.y * .5, uv.y, e) *\n        estep(-size.y * .5, uv.y, -e);\n}\n\nfloat tri(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        estep(-size.x * .5, uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(-size.x * .5, - uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(.0, uv.y, -e);\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = pow(pow(size.x * .5, 2.) - pow(size.y * .5, 2.), .5);\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = pow(pow(size.y * .5, 2.) - pow(size.x * .5, 2.), .5);\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circleh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return n(\n        circle(uv, vec2(.0), size, .0, .0, e) - \n        circle(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\nfloat recth(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rect(uv, vec2(.0), size, .0, .0, e) - \n        rect(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n// WIP\nfloat trih(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        tri(uv, vec2(.0), size, .0, .0, e) - \n        tri(uv, vec2(.0, -r * .2), size - vec2(r * pow(2., .5)), .0, .0, e)\n    );\n}\n\nfloat ellh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        ell(uv, vec2(.0), size, .0, .0, e) - \n        ell(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / (2. * PI);\n    return n(\n        circle(uv, p1, vec2(size), .0, .0, e) +\n        circle(uv, p2, vec2(size), .0, .0, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), .0, -angle, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectr(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, vec2(r), .0, .0, e) +\n        circle(uv, - v1, vec2(r), .0, .0, e) +\n        circle(uv, + v2, vec2(r), .0, .0, e) +\n        circle(uv, - v2, vec2(r), .0, .0, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, .0, e)\n    );\n}\n\nfloat rectr2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, .0, E)\n    );\n}\n\nfloat trir(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    vec2 v3 = (v1 + v2) * .5;\n    return n(\n        line(uv, -v1, v3, r, e) +\n        line(uv, -v1, -v2, r, e) +\n        line(uv, v3, -v2, r, e) +\n        tri(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectrh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, e) -\n        rectr(uv, vec2(.0), size - vec2(r), r, .0, e)\n    );\n}\n\n// WIP\nfloat trirh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        trir(uv, vec2(.0), size, r, .0, e) -\n        trir(uv, vec2(.0, -r * .2), size - vec2(r), r, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define SHADOW vec2(-.03, .03)\n#define SHADOW_V .3\n\nfloat bubble_bg(vec2 uv) {\n    return n(\n        line(uv, vec2(-.12, .0), vec2(.12, .0), .3, E) +\n        circle(uv, vec2(-.22, -.1), vec2(.13), .0, .0, E) +\n        circle(uv, vec2(-.32, -.18), vec2(.07), .0, .0, E)\n    );\n}\n\n#define DOT_TIME .3\n\n#define BG vec3(.8)\n#define DOT_DARK vec3(.4)\n#define DOT_LIGHT vec3(.6)\n\nvec3 bubble(vec3 c, vec2 uv, float t0, bool last_dot) {\n    c = mask(c, vec3(.0), SHADOW_V * bubble_bg(uv + SHADOW));\n    c = mask(c, BG, bubble_bg(uv));\n    \n    float t1 = mod(t0, DOT_TIME * 3.);\n    \n    c = mask(c, t1 < DOT_TIME ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(-.12, .0), vec2(.1), .0, .0, E));\n    c = mask(c, t1 > DOT_TIME && t1 < DOT_TIME * 2. ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(.0), vec2(.1), .0, .0, E));\n    if (last_dot)\n        c = mask(c, t1 > DOT_TIME * 2. ? DOT_DARK : DOT_LIGHT, circle(uv, vec2(.12, .0), vec2(.1), .0, .0, E));\n    \n    return c;\n}\n\nfloat letter_open_mask(vec2 uv, float he) {\n    return n(trir(uv, vec2(.0, .14 + .1 * he), vec2(.53, max(.05, .2 * he)), .05, .0, E) * h(uv, .29, .2, E));\n}\n\n#define LETTER_TIME 1.\n\nvec3 letter(vec3 c, vec2 uv, float t0) {\n    float letter_bg = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E);\n    float letter_inside = letter_bg * trir(uv, vec2(.0, .1), vec2(.53, .2), .05, .5, E);\n    float letter_closed = .0;\n    float letter_open = .0;\n    float letter_shadow = rectr(uv + SHADOW, vec2(.0), vec2(.54, .4), .1, .0, E);\n    \n    float he;\n    \n    if (t0 < LETTER_TIME * .5) {\n        he = min(1., 4. * (LETTER_TIME * .5 - t0));\n        letter_closed = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E) * trir(uv, vec2(.0, .23 - .1 * he), vec2(.53, max(.05, .2 * he)), .05, .5, E);\n    } else {\n        he = min(1., 4. * (t0 - LETTER_TIME * .5));\n        letter_open = letter_open_mask(uv, he);\n        letter_shadow = n(letter_shadow + letter_open_mask(uv + SHADOW, he));\n    }\n    \n    c = mask(c, vec3(.0), SHADOW_V * letter_shadow);\n    c = mask(c, vec3(.9), letter_bg);\n    c = mask(c, vec3(.7), letter_inside);\n    c = mask(c, vec3(.9), letter_closed);\n    c = mask(c, vec3(.7), letter_open);\n    \n    return c;\n}\n\nvec3 letter_front(vec3 c, vec2 uv, float t0) {\n    float letter_bg = rectr(uv, vec2(.0), vec2(.54, .4), .1, .0, E);\n    float letter_inside = letter_bg * trir(uv, vec2(.0, .1), vec2(.53, .2), .05, .5, E);\n\n    return mask(c, vec3(.9), n(letter_bg - letter_inside));\n}\n\n#define DOT_AFTER vec3(.9, .8, .1)\n\nvec3 free_dot(vec3 c, vec2 uv, float t0) {\n\n    uv -= vec2(.12, .0) * (2.0 - t0) * .5;\n\n    for (float v = .0; v < 1.; v += .11)\n        c = mask(c, vec3(1.), line(uv, vec2(.0), rot(vec2(n(t0 - .5) * .06), v), .05, E));\n\n    c = mask(c, mask(DOT_DARK, DOT_AFTER, n(t0 * 2.)), circle(uv, vec2(.0), vec2(.1), .0, .0, E));\n    \n    return c;\n}\n\nvec3 stamp(vec3 c, vec2 uv, float t0) {\n    \n    uv *= min(1., t0 * .9);\n    \n    float heart = n(\n        circle(uv, vec2(.02, .03), vec2(.07), .0, .0, E) +\n        circle(uv, vec2(-.02, .03), vec2(.07), .0, .0, E) +\n        trir(uv, vec2(0, -.01), vec2(.09, .06), .02, .5, E)\n    );\n\n    c = mask(c, vec3(.9, .0, .0), n(t0) * heart);\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t0) {\n    vec3 c = vec3(.1, .6, .3);\n    \n    float t1 = mod(t0, 8.);\n\n    c = bubble(c, uv + vec2(t1 < 2. ? .0 : (t1 < 4. ? t1 - 2. : t1 - 8.), .0), t1 + .5, t1 < 2. || t1 > 6.);\n    \n    float letter_x = t1 < 4. ? t1 - 4. : (t1 < 6. ? .0 : t1 - 6.);\n    \n    c = letter(c, uv + vec2(letter_x, .0), 4.5 - t1);\n    \n    if (t1 > 2. && t1 < 4.1)\n        c = free_dot(c, uv - vec2(.0, sin((t1 - 2.) * .5 * PI) * .6), (t1 - 2.));\n    \n    c = letter_front(c, uv + vec2(letter_x, .0), 4.5 - t1);\n    \n    c = stamp(c, uv + vec2(letter_x, .0), t1 - 4.5);\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 c = image(uv, iTime * .8);\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 55, 55, 89], [91, 91, 139, 139, 197], [199, 199, 216, 216, 260], [262, 262, 300, 300, 342], [344, 344, 368, 368, 453], [455, 455, 474, 474, 643], [645, 645, 677, 677, 836], [838, 838, 889, 889, 972], [974, 974, 1024, 1024, 1105], [1270, 1270, 1348, 1348, 1432], [1434, 1434, 1510, 1510, 1722], [1724, 1724, 1799, 1799, 2068], [2070, 2070, 2145, 2145, 2559], [2724, 2724, 2803, 2803, 2949], [2951, 2951, 3028, 3028, 3195], [3197, 3204, 3280, 3280, 3468], [3470, 3470, 3546, 3546, 3711], [3876, 3876, 3936, 3936, 4207], [4372, 4372, 4449, 4449, 4919], [4921, 4921, 4999, 4999, 5190], [5192, 5192, 5268, 5268, 5611], [5776, 5776, 5854, 5854, 6020], [6022, 6029, 6106, 6106, 6279], [6496, 6496, 6522, 6522, 6721], [6818, 6818, 6873, 6873, 7395], [7397, 7397, 7440, 7440, 7553], [7579, 7579, 7619, 7619, 8613], [8615, 8615, 8661, 8661, 8882], [8920, 8920, 8962, 8962, 9260], [9262, 9262, 9301, 9301, 9618], [9620, 9620, 9651, 9651, 10216], [10218, 10218, 10273, 10273, 10451]], "test": "untested"}
{"id": "sdK3z1", "name": "Aesthetic Palm Tree (VHS)", "author": "axx0009", "description": "my previous shader with a simple perspective applied to grid scaling and FMS_Cat's VHS filter overlayed\ngreat for synthwave or nightwave retro AMV backgrounds\nuses Palm Tree tutorial by IQ; Grid by World of Zero; VHS filter by FMS_Cat", "tags": ["80s", "retro", "vhs", "synthetic", "miami"], "likes": 7, "viewed": 1011, "published": 3, "date": "1631133517", "time_retrieved": "2024-07-30T19:02:36.229551", "image_code": "#define VHSRES vec2(320.0,240.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy / iResolution.xy * VHSRES;\n  fragColor = texture( iChannel0, uv );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define VHSRES vec2(320.0,240.0)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n#define validuv(v) (abs(v.x-0.5)<0.5&&abs(v.y-0.5)<0.5)\n\nfloat v2random( vec2 uv ) {\n  return texture( iChannel1, mod( uv, vec2( 1.0 ) ) ).x;\n}\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\nvec3 rgb2yiq( vec3 rgb ) {\n  return mat3( 0.299, 0.596, 0.211, 0.587, -0.274, -0.523, 0.114, -0.322, 0.312 ) * rgb;\n}\n\nvec3 yiq2rgb( vec3 yiq ) {\n  return mat3( 1.000, 1.000, 1.000, 0.956, -0.272, -1.106, 0.621, -0.647, 1.703 ) * yiq;\n}\n\n#define SAMPLES 6\n\nvec3 vhsTex2D( vec2 uv, float rot ) {\n  if ( validuv( uv ) ) {\n    vec3 yiq = vec3( 0.0 );\n    for ( int i = 0; i < SAMPLES; i ++ ) {\n      yiq += (\n        rgb2yiq( texture( iChannel0, uv - vec2( float( i ), 0.0 ) / VHSRES ).xyz ) *\n        vec2( float( i ), float( SAMPLES - 1 - i ) ).yxx / float( SAMPLES - 1 )\n      ) / float( SAMPLES ) * 2.0;\n    }\n    if ( rot != 0.0 ) { yiq.yz = rotate2D( rot ) * yiq.yz; }\n    return yiq2rgb( yiq );\n  }\n  return vec3( 0.1, 0.1, 0.1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / VHSRES;\n  float time = iTime;\n\n  vec2 uvn = uv;\n  vec3 col = vec3( 0.0, 0.0, 0.0 );\n\n  // tape wave\n  uvn.x += ( v2random( vec2( uvn.y / 10.0, time / 10.0 ) / 1.0 ) - 0.5 ) / VHSRES.x * 1.0;\n  uvn.x += ( v2random( vec2( uvn.y, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 1.0;\n\n  // tape crease\n  float tcPhase = smoothstep( 0.9, 0.96, sin( uvn.y * 8.0 - ( time + 0.14 * v2random( time * vec2( 0.67, 0.59 ) ) ) * PI * 1.2 ) );\n  float tcNoise = smoothstep( 0.3, 1.0, v2random( vec2( uvn.y * 4.77, time ) ) );\n  float tc = tcPhase * tcNoise;\n // uvn.x = uvn.x - tc / VHSRES.x * 8.0;\n\n  // switching noise\n  float snPhase = smoothstep( 6.0 / VHSRES.y, 0.0, uvn.y );\n  uvn.y += snPhase * 0.3;\n  uvn.x += snPhase * ( ( v2random( vec2( uv.y * 100.0, time * 10.0 ) ) - 0.5 ) / VHSRES.x * 24.0 );\n\n  // fetch\n  col = vhsTex2D( uvn, tcPhase * 0.2 + snPhase * 2.0 );\n\n  // crease noise\n  float cn = tcNoise * ( 0.3 + 0.7 * tcPhase );\n  if ( 0.29 < cn ) {\n    vec2 uvt = ( uvn + V.yx * v2random( vec2( uvn.y, time ) ) ) * vec2( 0.1, 1.0 );\n    float n0 = v2random( uvt );\n    float n1 = v2random( uvt + V.yx / VHSRES.x );\n    if ( n1 < n0 ) {\n      col = mix( col, 2.0 * V.yyy, pow( n0, 10.0 ) );\n    }\n  }\n\n  // ac beat\n  col *= 1.0 + 0.1 * smoothstep( 0.4, 0.6, v2random( vec2( 0.0, 0.1 * ( uv.y + time * 0.2 ) ) / 10.0 ) );\n\n  // color noise\n  col *= 0.9 + 0.1 * texture( iChannel1, mod( uvn * vec2( 1.0, 1.0 ) + time * vec2( 5.97, 4.45 ), vec2( 1.0 ) ) ).xyz;\n  col = saturate( col );\n\n  // yiq\n  col = rgb2yiq( col );\n  col = vec3( 0.1, -0.1, 0.0 ) + vec3( 0.9, 1.1, 1.5 ) * col;\n  col = yiq2rgb( col );\n\n  fragColor = vec4( col, 1.0 );\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//built from palm tree tutorial by Inigo Quilez, with grid shader by World of Zero, animation by me\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //time variable bounce\n    float b = 0.5*cos(iTime);    \n    \n    //Center of origin\n    vec2 q = uv - vec2(0.3,0.7);\n\n    // Time varying background color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //variable radius\n    float r = 0.2;\n    \n    //float scale = 15.0 + 5.0*cos(iTime); \n    float scale=15.0;\n    float gridPointX = step(float(mod((0.5-uv.x)*scale, 1.0-uv.y*1.0)), 0.1);\n    float gridPointY = step(float(mod((0.5-uv.y)*scale, 1.0-uv.y*1.0)), 0.1);\n    float gridPoint = min(1.0, gridPointX + gridPointY);\n\n    // Output to screen\n//    fragColor = vec4(gridPoint, gridPoint, gridPoint, 1.0);\n    \n    //modulated wave on radius r\n    r +=0.1*cos(atan(q.y,q.x-0.025*b)*10.0 + 20.0*(q.x+0.01*b) + 1.0 + 0.05*b);\n    \n    //render canopy\n    col *= smoothstep(r,r+0.005,length(q+.01*b));\n    \n    //trunk width\n    float w = 0.02;\n    //trunk texture\n    w += 0.002*cos(120.0*q.y);\n    //trunk taper\n    w -= 0.005*cos(2.0*q.y);\n    //ground union\n    w+= exp(-40.0*uv.y);    \n    //trunk curve\n    float c = 0.2 * sin(2.0 * (q.y+0.05*b));\n    \n    //render trunk\n    col *= 1.0 -(1.0-smoothstep(w,w+0.001,abs(q.x - c)))*(1.0-smoothstep(0.0,0.001,q.y));\n    \n    //superimpose black grid\n    col -= (gridPoint,gridPoint,gridPoint);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 202]], "test": "untested"}
{"id": "7dVGz1", "name": "golfing starfield + dark dust 3", "author": "FabriceNeyret2", "description": "golfing https://shadertoy.com/view/WstBWn ( low anim, no mouse control )", "tags": ["raymarching", "volume", "spectrum", "galaxy", "nebula", "starfield", "astrophysics", "dust", "astronomy", "psf", "bokglobules"], "likes": 24, "viewed": 720, "published": 3, "date": "1631125509", "time_retrieved": "2024-07-30T19:02:37.075290", "image_code": "// golfing https://shadertoy.com/view/WstBWn ( low anim, no mouse control )\n// more readable version at bottom :-)\n\n// -7 by Coyote\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    O-=O;\n    for(\n        vec3 R = iResolution, \n             D = normalize( vec3( U+U, -3.5*R.y ) - R ),\n             p = iTime*(2./R-2.)-.7,\n             T = vec3(.4,.6,1),\n             i = R-R, l;\n        i.x < 2e2;\n        T /= exp( max(0., texture(iChannel1,p/128.).a -.67) * vec3(1.5,3,6) )\n    )\n        l = .01* ++i / length( dot(R = fract(p+=D) - texture(iChannel0,p/32.).rgb,D)*D - R ),  \n        O.rgb += T * min( l*l*l,1e3 )/i/i;\n    O = sqrt(O); \n}\n\n\n\n\n\n\n/* // 329: -19 by Xor\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  R = iResolution, \n          D = normalize( vec3( U+U, -3.5*R.y ) - R ),\n          p = iTime*(2./R-2.)-.7,\n          T = vec3(.4,.6,1);\n    O-=O;\n    for ( float l,i=0.; i++ < 2e2; p += D )\n        R = fract(p) - texture(iChannel0,p/32.).rgb,\n        l = .01* i / length( R - dot(R,D)*D ),  \n        O.rgb += T * min( 1e3, l*l*l )/i/i,\n        T /= exp( max(0., texture(iChannel1,p/128.).a -.67) * vec3(1.5,3,6) );\n    O = sqrt(O); \n}\n/**/\n\n\n\n\n\n\n/* // 348 chars   ( use only channel1 )\n\n#define G texture(iChannel1\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  R = iResolution, \n          D = normalize( vec3( U+U, -3.5*R.y ) - R ),\n          p = 2./R; \n    p.xy -= 2.*iTime;\n    O-=O; vec4 T = O+1.;\n    for ( float l,i=0.; i++ < 2e2; p += D )\n        R = fract(p) - G,(ceil(p)-.5)/32.).rgb,\n        l = .01* i / length( R - dot(R,D)*D ),  \n        O += T *  vec4(.4,.6,1,0) * min( 1e3, l*l*l )/i/i,\n        T /= exp( max(0., 3.* G,p/128.).a -2.) * vec4(.5,1,2,0) );\n    O = sqrt(O); \n}\n/**/", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 169, 169, 636]], "test": "untested"}
{"id": "7dK3R1", "name": "Fork Phantom St Dazbme 759", "author": "Dazbme", "description": "https://cineshader.com/view/ttKGDt", "tags": ["raymarching", "ifs", "phantommode"], "likes": 9, "viewed": 5479, "published": 3, "date": "1631117802", "time_retrieved": "2024-07-30T19:02:37.837253", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    //vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(1.0, 1.4, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos), 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        float radius = distance(fragCoord.xy, vec2(iResolution.x/2.0, iResolution.y/2.0));\n        acc += pow(radius, 5.0) * 0.000000000004;\n        t += dist * 0.5;\n    }\n    \n    float color = round(pow(acc * 0.01, 2.0));\n    \n    fragColor = vec4(color, color, color, color);\n    //vec3 col = vec3(acc * 0.01, acc * 0.011+ acc2*0.002, acc * 0.012+ acc2*0.005);\n    //fragColor = vec4(col, 1.0 - t * 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 299], [301, 301, 330, 330, 421], [423, 423, 445, 445, 635], [637, 637, 667, 667, 839], [841, 841, 898, 898, 2128]], "test": "untested"}
{"id": "sdK3R1", "name": "Animated Aesthetic Palm Tree", "author": "axx0009", "description": "simple first animated shader built from demos by IQ and World of Zero", "tags": ["procedural", "80s", "animated", "neon", "synthetic", "miami"], "likes": 3, "viewed": 262, "published": 3, "date": "1631116853", "time_retrieved": "2024-07-30T19:02:38.804666", "image_code": "//built from palm tree tutorial by Inigo Quilez, with grid shader by World of Zero, animation by me\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //time variable bounce\n    float b = 0.5*cos(iTime);    \n    \n    //Center of origin\n    vec2 q = uv - vec2(0.3,0.7);\n\n    // Time varying background color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //variable radius\n    float r = 0.2;\n    \n    //float scale = 15.0 + 5.0*cos(iTime); \n    float scale=15.0;\n    float gridPointX = step(float(mod(uv.x * scale, 0.75)), 0.1);\n    float gridPointY = step(float(mod(uv.y * scale, 1.0)), 0.1);\n    float gridPoint = min(1.0, gridPointX + gridPointY);\n\n    // Output to screen\n//    fragColor = vec4(gridPoint, gridPoint, gridPoint, 1.0);\n    \n    //modulated wave on radius r\n    r +=0.1*cos(atan(q.y,q.x-0.025*b)*10.0 + 20.0*(q.x+0.01*b) + 1.0 + 0.05*b);\n    \n    //render canopy\n    col *= smoothstep(r,r+0.005,length(q+.01*b));\n    \n    //trunk width\n    float w = 0.02;\n    //trunk texture\n    w += 0.002*cos(120.0*q.y);\n    //trunk taper\n    w -= 0.005*cos(2.0*q.y);\n    //ground union\n    w+= exp(-40.0*uv.y);    \n    //trunk curve\n    float c = 0.2 * sin(2.0 * (q.y+0.05*b));\n    \n    //render trunk\n    col *= 1.0 -(1.0-smoothstep(w,w+0.001,abs(q.x - c)))*(1.0-smoothstep(0.0,0.001,q.y));\n    \n    //superimpose black grid\n    col -= (gridPoint,gridPoint,gridPoint);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 208, 1556]], "test": "untested"}
{"id": "sdVGR1", "name": "poster-ize", "author": "pali6", "description": "Quick and dirty posterization effect applied to a static image taken from your webcam. Click to take a new picture.\nDone using blur which only blurs pixels if their colors are close enough.\nTweak THRESHOLD in Buffer A to get more/less colours.", "tags": ["filter", "webcam", "posterization"], "likes": 2, "viewed": 405, "published": 3, "date": "1631115735", "time_retrieved": "2024-07-30T19:02:39.628464", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DIST 3\n#define THRESHOLD 0.045\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    if(iFrame <= 60 || iMouse.w > 0.)\n    {\n        fragColor = texture(iChannel1, uv);\n        return;\n    }\n    int count = 0;\n    vec4 sum;\n    for(int dx = -DIST; dx <= DIST; dx++)\n    {\n        for(int dy = -DIST; dy <= DIST; dy++)\n        {\n            vec4 pcol = texture(iChannel0, uv + vec2(dx, dy) / iResolution.xy);\n            if(length(pcol - fragColor) <= THRESHOLD)\n            {\n                sum += pcol;\n                count++;\n            }\n        }\n    }\n    fragColor = sum / float(count);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "NlSSzW", "name": "Borderz", "author": "Serhii", "description": "rendering custom-size rectangle border", "tags": ["geometry"], "likes": 1, "viewed": 236, "published": 3, "date": "1631104420", "time_retrieved": "2024-07-30T19:02:40.483178", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 localPixelCoord = fragCoord.xy / iResolution.xy;\n    vec2 size = vec2(9.0) / iResolution.xy;\n\n    // bottom-left\n    vec2 bl = step(size, localPixelCoord);\n    float interpolation = bl.x * bl.y;\n\n    // top-right\n    vec2 tr = step(size, 1.0 - localPixelCoord);\n    interpolation *= tr.x * tr.y;\n\n    interpolation = 1.0 - interpolation;\n    \n    float stop = 0.25;\n    float borderAlpha = 1.0 - (1.0 - localPixelCoord.y) * (1.0 / stop);\n    borderAlpha = borderAlpha * 1.0 - (localPixelCoord.x) * (1.0 / stop);\n    \n    // borderAlpha = 1.0 - step(stop, localPixelCoord.x);\n    // borderAlpha *= 1.0 - step(stop, 1.0 - localPixelCoord.y);\n    \n    vec4 borderColor = vec4(vec3(227.0, 103.0, .0) / 255.0, 1.0);\n    vec4 backgroundColor = vec4(vec3(15.0, 26.0, 46.0) / 255.0, 1.0);\n\n    fragColor = mix(backgroundColor, borderColor, max(borderAlpha, 0.0) * interpolation);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 938]], "test": "untested"}
{"id": "NsVGz1", "name": "Fractal 74_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 9, "viewed": 444, "published": 3, "date": "1631090628", "time_retrieved": "2024-07-30T19:02:41.659035", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define MX(a,b,c)mix(a,a+b,c)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    float t=iTime*0.8;\n    float A=MX(2.5, 0.5, sin(1.5*t + 2.2*sin(0.4*t) + 0.2)*.5+.5);\n    float B=MX(2.6, 0.6, sin(2.0*t + 1.5*sin(1.4*t) + 1.4)*.5+.5);\n    float D=MX(1.2, 1.0, sin(1.5*t + 0.6*sin(0.8*t) + 0.6)*.5+.5);\n    float E=MX(0.1, 0.3, sin(0.6*t + 0.3*sin(0.4*t) + 3.8)*.5+.5);\n    float F=MX(7.0, 3.0, sin(1.7*t + 1.5*sin(1.7*t) + 1.0)*.5+.5);\n    float G=MX(0.2, 0.3, sin(1.3*t + 1.1*sin(0.4*t) + 1.2)*.5+.5);\n    float H=MX(0.6, 0.4, sin(1.2*t + 2.2*sin(1.4*t) + 1.4)*.5+.5);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<99.;\n        e<.001?O.rgb+=mix(vec3(1),H(log(s)*.2),.8)*.015*exp(-5.*i*i*e):r\n    )\n    {\n        p=g*d;\n        p.z-=7.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        q=p*.6;\n        s=2.;\n        for(int j;j++<8;)\n            p=asin(sin(clamp(-p,-A,A)*D)/(1.+E))/D-clamp(p,-B,B)+p,\n            e=F*clamp(G/min(dot(p,p),H),0.,1.),\n            p=p*e+q,\n            s*=e;\n        g+=e=length(p)/s-.0005;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 172, 172, 1213]], "test": "untested"}
{"id": "NsV3Rh", "name": "relief texture v3", "author": "jorge2017a1", "description": "relief texture v3", "tags": ["relieftexturev3"], "likes": 11, "viewed": 331, "published": 3, "date": "1631063504", "time_retrieved": "2024-07-30T19:02:42.530704", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//referencia\n//https://www.shadertoy.com/view/MsjXzV..by capitanminero in 2014-10-23\n//https://www.shadertoy.com/user/pjkarlik\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// path functions ....pjkarlik\nvec2 path(in float z)\n{   vec2 p1 =vec2(2.13*sin(z * .15), 1.74*cos(z * .085));\n    vec2 p2 =vec2(2.97*sin(z * .079), 1.23*sin(z * .127));\n    return p1 - p2;\n}\n// Repeat space along one axis.\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p; \n   p.y=p.y-5.0;\n   vec2 qath = p.xy - path(p.z);\n   vec3 q = vec3(qath,p.z);\n   vec3 dq = q;\n   \n    vec3 r = dq;\n    pMod(r.z,3.);\n    vec3 r2=r;  vec3 r3=r;\n    r = vec3(abs(r.x)-10.0,r.y-3.5,r.z);\n    r2 = vec3(abs(r2.x)-10.0,r2.y-0.9,r2.z);\n    r3 = vec3(r3.x,r3.y+0.8,r.z);\n    \n   float pared1= sdBox( r-vec3(.0,1.0,0.0), vec3(1.0,1.0,10.0) );//inferior\n   float pared2= sdBox( r-vec3(0.5,0.0,0.0), vec3(1.0,2.5,10.0) ); //superior\n   float banqueta= sdBox(r2, vec3(3.0,0.6,10.0) );\n   float calle= sdBox(r3, vec3(10.0,1.0,10.0) );\n   \n   dq.x=abs(dq.x)- 11.0;\n   dq.y-=5.0;\n   dq.z= opRep1D( dq.z, 10.0 );\n   float poste= sdBox( dq, vec3(1.0,7.0,2.0) );\n   float posteSup= sdBox( dq-vec3(.0,6.0,0.0), vec3(1.5,0.5,2.5) );\n       res =opU3(res, vec3(poste,-1.0,11.0));\n       res =opU3(res, vec3(pared1,-1.0,11.0));\n       res =opU3(res, vec3(pared2,-1.0,11.0));\n       res =opU3(res, vec3(banqueta,-1.0,11.0));\n       res =opU3(res, vec3(posteSup,-1.0,11.0));\n       res =opU3(res, vec3(calle,-1.0,11.0));\n    return res;\n}\n//------------------------------------------------\n//https://www.shadertoy.com/view/MsjXzV\n// texture\nfloat fbm( vec3 p, vec3 n )\n{ return texture( iChannel0, (p.xy + p.zy) / 4.0).x; }\n    \n// bump mapping\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{   float e = 0.0015;\n    float b = 0.1;      \n    float ref = fbm( pos, nor );\n    vec3 gra = b*vec3( fbm( vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                       fbm( vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                       fbm( vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n    vec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 nor = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    nor= normalize(nor);\n    \n    if (mObj.id_material == 11.0) \n    { return doBumpMap(p,nor);}\n    return nor;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; }      \n        t += dS.x;\n        marchCount++;\n    }  \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n     float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n     float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n   \n}\n//----------------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n   \n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 getSkyColA(vec3 rd) \n{ float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 p, float id_material)\n{ vec3 col=vec3(1.0);\n    if (id_material==11.0)\n    {return  getColorTextura( p,mObj.normal,100); }\n}\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj;   \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n     \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;}\n\n    if (id_material>-1.0 && id_color==-1)\n        {   colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj; }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd; mObj.ro=ro;\n   vec3 p;\n\n    float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n           col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n     return col;\n}\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*8.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;    \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 10.0, 10.0 ); light_color2 =vec3( 1.0 ); \n      vec3 ro=vec3(0.0,12.0,-25.0+t);\n      ro.xy += path(ro.z);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[606, 606, 638, 638, 722], [723, 761, 797, 797, 842], [844, 875, 898, 898, 1035], [1036, 1068, 1107, 1107, 1240], [1241, 1281, 1306, 1306, 2388], [2389, 2491, 2520, 2520, 2573], [2579, 2595, 2639, 2639, 3007], [3008, 3059, 3083, 3083, 3335], [3337, 3337, 3386, 3386, 4019], [4020, 4074, 4110, 4110, 4355], [4356, 4411, 4438, 4438, 4455], [4457, 4457, 4493, 4493, 4585], [4586, 4586, 4632, 4632, 4757], [4759, 4759, 4833, 4833, 6399], [6456, 6456, 6505, 6505, 6748], [6749, 6783, 6863, 6863, 6986], [6987, 7028, 7055, 7055, 7161], [7162, 7162, 7194, 7194, 7391], [7392, 7443, 7489, 7489, 7590], [7591, 7643, 7736, 7736, 8135], [8137, 8137, 8168, 8168, 8759], [8760, 8809, 8835, 8835, 8936], [8937, 8937, 8995, 8995, 9047], [9049, 9098, 9155, 9155, 9709]], "test": "untested"}
{"id": "NdVGRh", "name": "Area of a Squircle", "author": "oneshade", "description": "[url=https://www.youtube.com/watch?v=gjtTcyWL0NA]https://www.youtube.com/watch?v=gjtTcyWL0NA[/url]", "tags": ["math", "area", "squircle"], "likes": 21, "viewed": 228, "published": 3, "date": "1631058676", "time_retrieved": "2024-07-30T19:02:43.363477", "image_code": "// Desmos graph: https://www.desmos.com/calculator/627ebn1ycs\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\n\n// https://www.shadertoy.com/view/3lfGD7\nfloat Gamma(in float x) {\n    const float pi = 3.14159265359;\n    float xx = x > 1.0 ? x : 1.0 - x;\n    float sum = 2.506628275635 + 225.525584619175 / (xx + 1.0) - 268.295973841305 / (xx + 2.0) + 80.9030806934622 / (xx + 3.0) - 5.007578639705 / (xx + 4.0) + 0.0114684895435 / (xx + 5.0);\n    float xh = xx + 5.65;\n    float y = exp((xx + 0.5) * log(xh) - xh) * sum / xx;\n    return x > 1.0 ? y : pi / (y * sin(pi * x));\n}\n\n// For general r, multiply by r^2\nfloat squircleArea(in float n) {\n    float a = Gamma(1.0 + 1.0 / n);\n    return 4.0 * a * a / Gamma(1.0 + 2.0 / n);\n}\n\nfloat dfSquircle(in vec2 p, in float r, in float n) {\n    return pow(pow(abs(p.x), n) + pow(abs(p.y), n), 1.0 / n) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(0.0, 0.169, 0.212);\n\n    // Shift the graph down and to the left side of the screen\n    vec2 shift = vec2(4.0 * iResolution.x / iResolution.y, 4.0);\n    uv += shift;\n\n    // Grid\n    drawSDF(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec4(0.0, 0.25, 0.5, 1.0));\n    drawSDF(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec4(0.0, 0.25, 0.5, 1.0));\n\n    // Draw the function\n    vec2 y = vec2(squircleArea(uv.x), 0.0);\n    y.y = (squircleArea(uv.x + 0.001) - y.x) / 0.001;\n    drawSDF(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.01, vec4(1.0, 0.0, 0.8, 1.0));\n\n    uv -= shift;\n\n    float n = mix(0.5, 10.0, 0.5 + 0.5 * sin(0.5 * iTime));\n    float r = 2.0;\n\n    float eps = 0.001;\n    float squircle = dfSquircle(uv, r, n);\n    squircle /= length((vec2(dfSquircle(uv + vec2(eps, 0.0), r, n), dfSquircle(uv + vec2(0.0, eps), r, n)) - squircle)) / eps;\n\n    uv += shift;\n    drawSDF(abs(uv.x - n), vec4(1.0, 0.0, 0.0, 1.0));\n    drawSDF(length(uv - vec2(n, squircleArea(n))) - 0.1, vec4(1.0, 0.8, 0.0, 1.0));\n\n    drawSDF(squircle, vec4(0.0, 1.0, 0.0, 0.25));\n    drawSDF(abs(squircle), vec4(0.0, 1.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 196, 221, 221, 618], [620, 654, 686, 686, 771], [773, 773, 826, 826, 894], [896, 896, 951, 951, 2232]], "test": "untested"}
{"id": "NdG3zh", "name": "color/texture performance test", "author": "morisil", "description": "Computing spectral color vs acquiring precomputed value. I know it might vary among GPUs, so for this reason I created a tool to check what's faster - calculating color on a texture and using it multiple times, or calculating it again and again.", "tags": ["test", "noise", "performance"], "likes": 3, "viewed": 266, "published": 3, "date": "1631046580", "time_retrieved": "2024-07-30T19:02:44.173312", "image_code": "// go to Common tab to start testing!\n\nvec3 spectralColor(in vec2 uv) {\n#ifdef CACHE_SPECTRAL_COLOR\n    return texture(iChannel0, uv).rgb;\n#else\n    return spectral_zucconi6(uv.x);\n#endif\n}\n\nvec3 colorTest(in vec2 uv) {\n    vec3 sum = vec3(0);\n    for (float i = 0.; i < ITERATIONS ;i++) {\n        sum += spectralColor(uv * (1. - i * .003)) / ITERATIONS;\n    }\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = colorTest(uv);\n    fragColor = vec4(color, 1.0);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define CACHE_SPECTRAL_COLOR\n// tune number of iterations\n#define ITERATIONS 100.\n\n// libs:\n\n\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef CACHE_SPECTRAL_COLOR\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(spectral_zucconi6(uv.x), 1.);\n#else\n    discard;\n#endif\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 71, 71, 189], [191, 191, 219, 219, 378], [380, 380, 435, 435, 549]], "test": "untested"}
{"id": "NsG3zh", "name": "大龙猫 - Canyon Flight", "author": "totetmatt", "description": "Simple terrain, some reflection and trying to play with camera. Is it optimized ? OF COURSE NOT :D ", "tags": ["terrain", "camera", "clipping"], "likes": 5, "viewed": 279, "published": 3, "date": "1631034119", "time_retrieved": "2024-07-30T19:02:44.949237", "image_code": "float box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  p.z +=mod(iTime,100.);\n      vec2 id = floor(p.xz);\n      p.xz = asin(sin(p.xz)*.8);\n  vec2 h;\n\n    \n    vec4 pp = vec4(p,1.);\n    float mm = 10000.;\n    for(float i =0.;i<=16.;i++){\n            pp.xyz = abs(pp.xyz)-1.1;\n            pp.xz *=rot(.785*i+i);\n            \n            pp.yz *=rot((.29)*i);\n            float m =  min(pp.x,min(pp.y,pp.z));\n            mm = min(mm,m); // This was on nusan video I recently saw. Quite nice\n            pp*=1.11;\n            pp.xy = pp.x < pp.y ? pp.yx:pp.xy;\n            pp.x -=3.1;\n    }\n    h.x =     (length(pp.xyz)-1.5-mm*.01)/pp.a;\n    h.x = max(abs(length(p)-2.)-1.1,-h.x);\n    h.x = mix(box(p,vec3(1.)),h.x*.7,.5);\n    h.y = 1.;\n    h.x = max(-(length(pp.xz)-3.6)/pp.a,h.x);\n    \n    vec2 t;\n    t.x = dot(p,vec3(0.,1.,.0))-sin(pp.x*.1+pp.z*.1)*.1;\n    t.y = 2.;\n    h = t.x < h.x  ? t:h;\n    return h;\n}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7))\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1);\n    vec3 ro = vec3(0.,2.+sin(iTime*.33+3.0)*1.4,-5.);\n    vec3 rt = vec3(cos(iTime*.33)*2.,sin(iTime*.5),0.);\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rp = ro;\n    uv *=rot(cos(iTime*.3));\n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n    float dd =0.;\n    vec2 d;\n    d.y =-1.;\n    vec3 light = vec3(1.,2.,-3.);\n    for(float i=0.;i<=128.;i++){\n        d = sdf(rp);\n        dd +=d.x;\n        if(dd > 10.) {d.y= -1.; break;}\n        if(d.x<.001){\n            vec3 n = norm(rp,.0003);\n            if(d.y == 2.){\n                rd = normalize(reflect(rd,n));\n                rp +=rd*.01;\n                col +=vec3(.1,.1,.4);\n                continue;\n            }\n            float diff = max(0.,dot(normalize(light-rp),n));\n            col += vec3(1.)*diff;\n            col = mix(vec3(.1,.1,.2),vec3(1.,.9,.7),AO(rp,n)/1.7);\n            break;\n        }\n    rp+=rd*d.x;\n    }\n    if(d.y==-1.) col += mix(vec3(.2,.4,.8),vec3(.5,.6,.9),uv.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsG3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 116], [117, 117, 135, 135, 182], [183, 183, 200, 200, 1058], [1177, 1177, 1204, 1204, 1280], [1281, 1281, 1338, 1338, 2496]], "test": "untested"}
{"id": "ssV3zR", "name": "Fractal 73_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 20, "viewed": 544, "published": 3, "date": "1631004412", "time_retrieved": "2024-07-30T19:02:45.723168", "image_code": "#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<99.;\n        e<.003?O.rgb+=mix(vec3(1),H(log(s)*.1+iTime*.05),.36)*.017*exp(-.005*i*i*e):r\n    )\n    {\n        p=g*d;\n        p.z-=.45;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.1);\n        s=1.;\n        vec4 q=vec4(p,.2*iTime);\n        for(int i;i++<6;q*=e)\n            q=sin(q+.01),\n            s*=e=3./dot(q,q);\n        g+=e=length(q)/s;\n    }\n    O*=O*O*O*O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 635]], "test": "untested"}
{"id": "7dVGRR", "name": "Refraction Cube [ Playable ]", "author": "Yusef28", "description": "Oneshade suggested I make my refraction box (cube lol?) shader controllable so I've done that here. \nControls [ q,w,e,a,s,d] and mouse for movement\nComment out #define \"ANIMATED\" to play with it yourself.", "tags": ["game", "refraction", "cube", "glass", "refract", "bigwings", "rubiks"], "likes": 21, "viewed": 518, "published": 3, "date": "1630989787", "time_retrieved": "2024-07-30T19:02:46.882070", "image_code": "/*\nComment out #define \"ANIMATED\" in common tab \nto play with it yourself.\n\nControls [ q,w,e,a,s,d] and mouse for movement\n\nI made a slightly more interesting design\nwith just one gem per square and a faint glow.\nThe solid color could be a lot better.\n\nand this is a far cry from the actual rubiks cube shader:\nhttps://www.shadertoy.com/view/XtG3D1\n\nBut you can play with it!\n\n*/\n\n//for AA set AA_ON to 1 and then set aa to more than 1\nfloat id = 0.;\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}   \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.);\n}\nfloat bar(vec3 p, float r, float le){\n     return max(length(p.yz) - r, abs(p.x)-le);\n     \n}\nfloat gem(vec3 p){\n\n    float c = cos(pi/5.), s = sqrt(0.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    float d = p.z-1.;\n    return d;   \n}\n\n//luna's rubiks cube tutorial\n//https://www.twitch.tv/videos/317211752?collection=_d31TQedWRW60w\nfloat tick(float time){\n    \n    float t = smoothstep(0.,1.,easeOutBounce(time));\n    t = smoothstep(0.,1.,t);\n    //t = smoothstep(0.,1.,t);\n    return t;\n}\nfloat choose_face(float t){\n    return fract(123.645234*t);\n}\n\nfloat glow = 0.;\nfloat map(vec3 p){\n    \n    float time = T*1.;\n    \n    //the animation lasts one second\n    float t = fract(time);\n    //float tick = tick(1.-TX(iChannel2, vec2(0.)).x);\n    \n    //for that second, we can have one of 6 faces\n    \n    #ifdef ANIMATED \n    float face = floor(choose_face(floor(time))*6.)+1.;\n    float tick = tick(t);\n    #else\n    float tick = tick(1.-TX(iChannel2, vec2(0.)).x);\n    float face = TX(iChannel2, vec2(0.)).z;\n    #endif\n    //choose_face(floor(time))*6.;\n    \n    //luna's rubiks cube tutorial\n    //https://www.twitch.tv/videos/317211752?collection=_d31TQedWRW60w\n    \n    /*\n    if(face == 1.)\n    p.xz *= rot(tick*pi*0.5*step(6.9,p.y));\n    else if(face == 2.)\n    p.xz *= rot(tick*pi*0.5*step(6.9,-p.y));\n    else if(face == 3.)\n    p.yz *= rot(tick*pi*0.5*step(6.9,p.x));\n    else if(face == 4.)\n    p.yz *= rot(tick*pi*0.5*step(6.9,-p.x));\n    else if(face == 5.)\n    p.xy *= rot(tick*pi*0.5*step(6.9,p.z));\n    else if(face == 6.)\n    p.xy *= rot(tick*pi*0.5*step(6.9,-p.z));\n    */\n    \n    p.xz = face == 1. ? p.xz*rot(tick*pi*0.5*step(6.9,p.y)) : p.xz;\n    p.xz = face == 2. ? p.xz*rot(tick*pi*0.5*step(6.9,-p.y)) : p.xz;\n    p.yz = face == 3. ? p.yz*rot(tick*pi*0.5*step(6.9,p.x)) : p.yz;\n    p.yz = face == 4. ? p.yz*rot(tick*pi*0.5*step(6.9,-p.x)) : p.yz;\n    p.xy = face == 5. ? p.xy*rot(tick*pi*0.5*step(6.9,p.z)) : p.xy;\n    p.xy = face == 6. ? p.xy*rot(tick*pi*0.5*step(6.9,-p.z)) : p.xy;\n    \n    vec3 sp = p ;\n   \n    p = mod(p+7., 14.) - 7.;\n    float scene = 1000.;   \n    float bb = sdBox(p, vec3(5.5));\n    \n    vec3 q = p;\n    //q = mod(q, 2.2) - 1.1;\n    float more_gems = gem(q);\n    //more_gems = max(bb, more_gems);\n    scene = min(scene, more_gems);\n    \n    \n    q = p;\n    float hole_size = 4.85;\n    float boxe_size = 6.;\n    float hole, boxe,wooden_frames;\n    \n    for(float i = 0.; i < 3.; i++){\n        hole = max(abs(q.y),abs(q.x)) - hole_size;\n        hole = min(hole, max(abs(q.y),abs(q.z)) - hole_size);\n        hole = min(hole, max(abs(q.z),abs(q.x)) - hole_size);\n\n        boxe = sdBox(p, vec3(boxe_size)\n                     //+ vec3(sin(p.y), 0., sin(p.y/5.))/10.)\n                     )- 0.4;\n        //boxe = max(-bb, boxe);\n        wooden_frames =  smax(-hole, boxe, 0.3);\n        scene = min(scene, wooden_frames);\n        boxe_size --;\n        hole_size --;\n    }\n    \n   // wooden_frames = min(dots, wooden_frames);\n    \n    //sp.xz *= rot(iTime);\n    bb = sdBox(sp, vec3(21.));\n    scene = max(bb, scene);\n    more_gems = max(bb, more_gems);\n    id = more_gems < wooden_frames ? 0. : 1.;\n    \n    if(id == 0.)glow += 0.014;//max(0.01,(0.001/(0.005*pow((more_gems),1.4))));;\n    \n    id = abs(sp.x) > 6.9 && \n             abs(sp.y) > 6.9 && \n             abs(sp.z) > 6.9 && \n             id == 1. ?\n             0. : id;\n             \n    return scene;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = abs(map(ro + rd*t));\n        if(d < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\n\nvec3 cube_map(vec3 p, vec3 n){\n\n    vec3 tex_X = TX(iChannel1,p.zy*0.5+0.5).rgb;\n    vec3 tex_Y = TX(iChannel1,p.xz*0.5+0.5).rgb;\n    vec3 tex_Z = TX(iChannel1,p.xy*0.5+0.5).rgb;\n    \n    n = abs(n);\n    return vec3(tex_X*n.x + tex_Y*n.y + tex_Z*n.z);\n    \n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zm){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zm;\n    return normalize(rd);\n\n}\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd){\n    vec3 color;\n    \n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.001);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + ldist*ldist*0.02);\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.), 5.);\n    vec3 refl_col = TX(iChannel0,reflect(rd, sn)).rgb;\n    color = diff*cube_map(sp/20.,sn)*vec3(0.3,0.3,0.3)/1.5\n            + refl_col*0.1\n            + spec;\n return clamp(color, 0., 1.);   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 10., -80.);\n    ro.yz *= rot(-m.y*pi+1.);\n    ro.xz *= rot(-m.x*pi*2.);\n  \n    vec3 rd = camRay(uv, ro, vec3(0., 0.,0.), zoom);\n    \n    vec3 col = TX(iChannel0, rd).rgb*0.5;\n    //col += hexTexture(uv+vec2(iTime/50.,0.), TX(iChannel1, vec2(3.)).rgb, col, vec2(1.))*0.13;\n\n    \n    float t = trace(ro, rd);\n    \n    \n    // Time varying pixel color\n    \n    \n    vec3 tex;\n    if(t < MAX_DIST && id == 0.){\n        \n        //tpnre\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        vec3 rIn = refract(rd,n,1./glass);\n        vec3 enter = p - n*0.01;\n        \n        vec3 obligatory_reflection = reflect(rd, n);\n        vec3 obligatory_outside = TX(iChannel0, obligatory_reflection).rgb;\n        \n        //tpnre\n        float tOut = trace(enter, rIn);\n        p = enter + rIn*tOut;\n        vec3 nExit = -normal(p);\n        \n        \n        vec3 rOut = refract(rIn, nExit, glass - 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.r = TX(iChannel0,rOut).r;\n        \n        rOut = refract(rIn, nExit, glass);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.g = TX(iChannel0,rOut).g;\n        \n        rOut = refract(rIn, nExit, glass + 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.b = TX(iChannel0,rOut).b;\n        \n        //vec3 exit = p + rOut*t;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        float dens = 0.8;\n        float optDist = exp(-t*dens);\n        \n\n        col = mix(tex, obligatory_outside, fresnel);\n\n    }\n    \n    else if(t < MAX_DIST && id == 1.){\n        vec3 p = ro + rd*t;\n        vec3 n = abs(normal(p));\n        col = clamp(lighting(p,n,vec3(30.), rd), 0., 1.);\n    }\n    \n    col += glow;\n    col = pow(col, vec3(.545));\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define ANIMATED 1\n\n#define TX texture\n\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 145.\n#define pi 3.14159265\n#define air 1.\n#define glass 1.45\n#define zoom 1.\n\n\n\n#define AA 1\n//from david hoskins hash without sine\n// 3 in 1 out\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvec3 hexTexture(vec2 uv, vec3 color, vec3 tex, vec2 firstXY)\n{\n\tvec2 u = 6.*uv;;\n    vec2 s = vec2(1.,1.732);\n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB*1000.;\n    float id = rnd(idSeed+firstXY.x*firstXY.y/800.);\n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float radius = pow(id*0.2,4.);\n    float f = smoothstep(radius + 0., radius + 0.05, 1.0-q);\n    //+firstXY.y/16.\n    vec3 col = mix(tex,color-fract(8.*id)*0.5,f*step(0.2,id));\n    return col;\n}\n\n//skaplun\n//https://www.shadertoy.com/view/7tf3Ws \nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\n//poljere \n//https://www.shadertoy.com/view/Xst3zX\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\n\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_W     = 87.5/256.0;\n\n", "buffer_a_code": "//https://www.shadertoy.com/view/Xst3zX\nfloat isKeyPressed(float key)\n{\n    return step(0.1, texture( iChannel1, vec2(key, 0.0) ).x);\n\t//return texture( iChannel1, vec2(key,  2.) ).x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float animation_on = TX(iChannel0,uv).x;\n    float key = TX(iChannel0,uv).z;\n    \n    //if(animation_on == 0.){\n    \n        key = isKeyPressed(KEY_Q) > 0.5 ? 4. : key;\n        key = isKeyPressed(KEY_W) > 0.5 ? 1. : key;\n        key = isKeyPressed(KEY_E) > 0.5 ? 3. : key;\n\n        key = isKeyPressed(KEY_A) > 0.5 ? 6. : key;\n        key = isKeyPressed(KEY_S) > 0.5 ? 2. : key;\n        key = isKeyPressed(KEY_D) > 0.5 ? 5. : key;\n    //}\n\n    float t = 0.;\n    \n    if(key > 0. && animation_on == 0.)animation_on = 1.;\n    \n    if(animation_on > 0.)\n    {\n        animation_on -= 1./30.;\n    }\n    else\n    {\n        animation_on = 0.;\n        key = 0.;\n    }\n    \n    fragColor = vec4(vec3(animation_on,key,key),1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 470, 470, 533], [537, 537, 565, 565, 653], [654, 654, 691, 691, 747], [748, 748, 766, 766, 1068], [1070, 1167, 1190, 1190, 1324], [1325, 1325, 1352, 1352, 1386], [1405, 1405, 1423, 1423, 4241], [4243, 4243, 4273, 4273, 4469], [4471, 4471, 4491, 4491, 4692], [4694, 4694, 4724, 4724, 4952], [4953, 4953, 5005, 5005, 5248], [5249, 5249, 5299, 5299, 5761], [5762, 5762, 5818, 5868, 7827]], "test": "untested"}
{"id": "7dK3RR", "name": "Frozen sea", "author": "jarble", "description": "This frozen sea is full of icebergs. Based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["fractal", "noise", "terrain", "sea", "fbm", "ice", "snow"], "likes": 8, "viewed": 368, "published": 3, "date": "1630987806", "time_retrieved": "2024-07-30T19:02:47.691904", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    //uv /= 1.25;\n    uv /= 2.;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    float n1 = 0.0;\n    for (int i = 0; i < octaves; i++)\n    {\n        float n2 = n1/freq;\n        n1 -= abs(noise(uv * freq)-n2);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n1-.5) * amplitude);\n        \n        amplitude *= .4;\n        \n        freq *= 2.1;\n        \n        uv = uv.yx + vec2(freq+n2,amplitude);\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,5)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 79], [100, 100, 135, 202, 692], [694, 694, 716, 716, 746], [748, 748, 778, 778, 828], [830, 830, 850, 850, 897], [899, 899, 932, 932, 1126], [1128, 1128, 1195, 1195, 1413], [1415, 1415, 1467, 1467, 2012], [2014, 2014, 2065, 2065, 2266], [2334, 2334, 2391, 2391, 4340]], "test": "untested"}
{"id": "NsK3zR", "name": "Fork Sum Zero Hypno", "author": "deerfeeder", "description": " ", "tags": ["basic"], "likes": 5, "viewed": 260, "published": 3, "date": "1630967425", "time_retrieved": "2024-07-30T19:02:48.566566", "image_code": "// Fork of \"Fork Sum Zero Inverted\" by deerfeeder. https://shadertoy.com/view/NdVGzR\n// 2021-09-06 22:28:41\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  \n    float s = 80.0*sin(iTime*uv.x*uv.y);\n    uv.x=abs(uv.x);\n    // Time varying pixel color\n    vec3 col = cos(iTime+uv.xyx*vec3(s*sin(iTime*0.01),s*cos(iTime*0.02),s*cos(uv.x+iTime*0.06)));\n    col = abs(col);\n    // Output to screen\n    fragColor = vec4(vec3(col.x*col.y*col.z),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 166, 216, 571]], "test": "untested"}
{"id": "fdK3RR", "name": "Walking Rainbow", "author": "oneshade", "description": "Animating [url=https://www.shadertoy.com/view/fddGDs]https://www.shadertoy.com/view/fddGDs[/url].", "tags": ["bezier", "animation", "rainbow", "walk"], "likes": 14, "viewed": 197, "published": 3, "date": "1630962359", "time_retrieved": "2024-07-30T19:02:49.401334", "image_code": "// Length between a starting (t1) and ending (t2) position\nfloat bezierArclength(in float t1, in float t2, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    vec2 t = (u * vec2(t1, t2) + v) / sqrt(dis);\n    vec2 y = asinh(t) + t * sqrt(t * t + 1.0);\n    return (y.y - y.x) * dis / pow(u, 1.5);\n}\n\n// Newton-Raphson solver for inverse arclength\nfloat bezierInvArclength(in float d, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    float sdis = sqrt(dis);\n    float disu = dis / u;\n    float k = dis / pow(u, 1.5);\n\n    float y = v / sdis;\n    d += (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n\n    float t = ((sqrt(disu + u * abs(d)) - sqrt(disu)) * sign(d) - v) / u;\n    for (int n=0; n < 5; n++) {\n        float y = (u * t + v) / sdis;\n        float arclen = (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n        float arcint = 2.0 * sqrt((u * t + 2.0 * v) * t + w);\n        t -= (arclen - d) / arcint;\n    }\n\n    return t;\n}\n\n// ---------- Helper functions ----------\nvec3 hue2rgb(in float hue) {\n    return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n}\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 c = floor(p);\n    vec2 f = fract(p);//smoothstep(0.0, 1.0, fract(p));\n\n    float bl = Hash21(c);\n    float br = Hash21(c + vec2(1.0, 0.0));\n    float tl = Hash21(c + vec2(0.0, 1.0));\n    float tr = Hash21(c + 1.0);\n\n    return mix(mix(bl, br, f.x), mix(tl, tr, f.x), f.y);\n}\n\n// ---------- SDFs ----------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Returns vec2(shortest distance to the curve, parameter of the nearest position on the curve)\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec2 sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return vec2(length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        float d1 = dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x));\n        float d2 = dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y));\n        return d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Color bands in the background\n    color = vec3(floor(snoise(vec2(uv.y * 4.0, 0.1 * iTime)) * 5.0) * 0.25);\n    color *= step(0.0, 0.2 - snoise(vec2(uv.y * 10.0, iTime)));\n    color *= fragCoord.y / iResolution.y;\n\n    // Control points\n    vec2 a = vec2(-1.0, -0.5);\n    vec2 b = vec2(-0.5, 0.25);\n    vec2 c = vec2(0.0, -0.5);\n\n    float time = mod(iTime, 6.28);\n    uv.x += time / 6.28 * 2.0 - 0.5;\n    float transition = 0.5 - 0.5 * cos(min(time, 3.14));\n\n    // Rotate back segment forward\n    a -= c;\n    a *= Rotate2D(3.14 * transition);\n    a += c;\n\n    b.x = mix(-0.5, 0.5, transition);\n\n    // Repeat, but this time with the forward (now back) segment\n    if (time > 3.14) {\n        float transition = 0.5 + 0.5 * cos(time);\n\n        c -= a;\n        c *= Rotate2D(3.14 * transition);\n        c += a;\n\n        b.x = mix(0.5, 1.5, transition);\n    }\n\n    // Poles or whatever its walking on\n    drawSDF(sdBox(vec2(fract(uv.x + 0.5) - 0.5, uv.y + 10.55), vec2(0.05, 9.95)) - 0.05, vec3(0.0, 0.8, 0.6));\n\n    // Bezier curve\n    vec2 bezClosest = sdBezier(uv, a, b, c);\n    float bezLength = bezierArclength(0.0, 1.0, a, b, c);\n    bezClosest.y = bezierArclength(0.0, bezClosest.y, a, b, c) / bezLength;\n    drawSDF(bezClosest.x - 0.05, hue2rgb(bezClosest.y));\n\n    // Plot rotating stars at regular intervals\n    mat2 rot = Rotate2D(iTime);\n\n    float du = bezLength / 5.0;\n    for (float u=0.0; u < 6.0; u++) {\n        float t = bezierInvArclength(u * du, a, b, c);\n        vec2 pos = mix(mix(a, b, t), mix(b, c, t), t);\n\n        mat2 starRot = rot;\n        if (int(u) % 2 == 0) starRot = transpose(starRot); // Alternate rotation direction\n\n        drawSDF(sdStar5((uv - pos) * starRot, 0.05, 0.5), vec3(0.25, 0.0, 0.5));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 141, 141, 453], [455, 502, 573, 573, 1233], [1235, 1277, 1305, 1305, 1409], [1411, 1411, 1438, 1438, 1504], [1506, 1547, 1573, 1573, 1659], [1661, 1702, 1727, 1727, 1838], [1840, 1840, 1865, 1865, 2149], [2151, 2232, 2283, 2283, 2694], [2696, 2792, 2815, 2815, 2835], [2836, 2836, 2898, 2898, 4161], [4163, 4163, 4198, 4198, 4278], [4280, 4280, 4327, 4327, 4435], [4517, 4517, 4572, 4572, 6578]], "test": "untested"}
{"id": "ssGGRR", "name": "CIELab D65 roundtrip", "author": "miyaokamarina", "description": "sRGB to CIELab D65 and CIELab D65 to sRGB conversions.", "tags": ["color", "cielab", "ciexyz"], "likes": 3, "viewed": 252, "published": 3, "date": "1630956615", "time_retrieved": "2024-07-30T19:02:50.178257", "image_code": "void mainImage(out vec4 col, in vec2 pos) {\n    col = texture(in0, pos / res);\n\n    vec3 tmp = col.rgb;\n\n    tmp = srgb_to_lrgb(tmp);\n    tmp = rgb_to_xyz(tmp);\n    tmp = xyz_to_lab(tmp);\n    tmp = lab_to_xyz(tmp);\n    tmp = xyz_to_rgb(tmp);\n    tmp = lrgb_to_srgb(tmp);\n\n    col.rgb = tmp;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI2  6.283185307179586\n\n#define D    0.206896558 // δ\n#define D23  0.128418549 // 3δ²\n#define ID23 7.7870368   // 1 / 3δ²\n#define D3   0.008856452 // δ³\n#define C    0.13793103  // 4 / 29\n\n#define cbrt(x) pow(x, vec3(0.33333333))\n#define cube(x) (x * x * x)\n\nconst mat3 RGB_TO_XYZ = mat3(\n    0.4124, 0.3576, 0.1805,\n    0.2126, 0.7152, 0.0722,\n    0.0193, 0.1192, 0.95050\n);\n\nconst mat3 XYZ_TO_RGB = mat3(\n    +3.2406, -1.5372, -0.4986,\n    -0.9689, +1.8758, +0.0415,\n    +0.0557, -0.2040, +1.0570\n);\n\nvec2 ratio_fix(vec2 res) {\n    float rmax  = max(res.x, res.y);\n    float rmin  = min(res.x, res.y);\n    float ratio = rmax / rmin;\n    float fx    = mix(1.0, ratio, res.x > res.y);\n    float fy    = mix(1.0, ratio, res.y > res.x);\n\n    return vec2(fx, fy);\n}\n\n//=============================================//\n//=  RGB → XYZ                                =//\n//=  XYZ → RGB                                =//\n//=                                           =//\n//=  Ref: https://en.wikipedia.org/wiki/SRGB  =//\n//=============================================//\n\n// srgb to linear rgb\nvec3 srgb_to_lrgb(vec3 c) {\n    return mix(\n        pow((c + 0.055) * 0.94786727, vec3(2.4)),\n        c * 0.07739938,\n        lessThanEqual(c, vec3(0.04045))\n    );\n}\n\n// linear rgb to srgb\nvec3 lrgb_to_srgb(vec3 c) {\n    return mix(\n        1.055 * pow(c, vec3(0.41666666)) - 0.055,\n        12.29 * c,\n        lessThanEqual(c, vec3(0.0031308))\n    );\n}\n\nvec3 rgb_to_xyz(vec3 rgb) {\n    return srgb_to_lrgb(rgb) * RGB_TO_XYZ;\n}\n\nvec3 xyz_to_rgb(vec3 xyz) {\n    return lrgb_to_srgb(xyz * XYZ_TO_RGB);\n}\n\n//===========================================================//\n//=  XYZ → LAB                                              =//\n//=  LAB → XYZ                                              =//\n//=                                                         =//\n//=  Ref: https://en.wikipedia.org/wiki/CIELAB_color_space  =//\n//===========================================================//\n\n// f(t)\nvec3 lab_f(vec3 t) {\n    return mix(\n        t * ID23 + C,\n        cbrt(t),\n        greaterThan(t, vec3(D3))\n    );\n}\n\n// f⁻¹(t)\nvec3 lab_g(vec3 t) {\n    return mix(\n        D23 * (t - C),\n        cube(t),\n        greaterThan(t, vec3(D))\n    );\n}\n\nvec3 xyz_to_lab(vec3 xyz) {\n    xyz *= vec3(1.05207785, 1.0, 0.9182736);\n    xyz  = lab_f(xyz);\n\n    return vec3(\n        116.0 * xyz.y - 16.0,\n        500.0 * (xyz.x - xyz.y),\n        200.0 * (xyz.y - xyz.z)\n    );\n}\n\nvec3 lab_to_xyz(vec3 lab) {\n    lab.x += 16.0;\n    lab   *= vec3(0.0086206896, 0.002, 0.005);\n    lab    = vec3(lab.x + lab.y, lab.x, lab.x - lab.z);\n    lab    = lab_g(lab);\n    lab   *= vec3(0.9505, 1.0000, 1.0890);\n\n    return lab;\n}\n\nvec4 rgb_to_lab(vec4 rgb) {\n    rgb.xyz  = rgb_to_xyz(rgb.rgb);\n    rgb.xyz  = xyz_to_lab(rgb.xyz);\n    rgb.xyz *= vec3(0.01, 0.0078125, 0.0078125);\n\n    return rgb;\n}\n\nvec4 lab_to_rgb(vec4 lab) {\n    lab.xyz *= vec3(100, 128, 128);\n    lab.xyz  = lab_to_xyz(lab.xyz);\n    lab.xyz  = xyz_to_rgb(lab.xyz);\n\n    return lab;\n}\n\nvec3 hsluv(float h, float s, float l) {\n    const float[6] N = float[6](\n        /* [1, 1] :: 632260 * M[2] - 126452 * M[1] */ -120846.0,\n        /* [1, 2] :: 284517 * M[0] -  94839 * M[2] */ 969398.0,\n        /* [2, 1] :: 632260 * M[5] - 126452 * M[4] */ -210946.0,\n        /* [2, 2] :: 284517 * M[3] -  94839 * M[5] */ -279707.0,\n        /* [3, 1] :: 632260 * M[8] - 126452 * M[7] */ 694074.0,\n        /* [3, 2] :: 284517 * M[6] -  94839 * M[8] */ -84414.0\n    );\n\n    float hsin = sin(h);\n    float hcos = cos(h);\n\n    float a = l + 16.0;\n    float r;\n    float g;\n    float b = a * 0.0086206896;\n\n    float c;\n    float d;\n    float e = 769860.0 * l;\n\n    int i;\n\n    a = cube(a) / 1560896.0;  //                            a is sub1\n    a = mix(l / 903.0, a, a > 0.01); //                     a is sub2\n\n    h = 3.402823466e+38;          //                        h is cmax\n\n    for (; i < 6; ) {\n        r = N[i++] * a;\n        g = N[i++] * a * hcos;\n\n        c = e * a / (r * hsin - g); //                      c is length\n        h = mix(h, min(h, c), c >= 0.0); //                 h is cmax\n\n        c = e * (a - 1.0) / ((r + 126452.0) * hsin - g); // c is length\n        h = mix(h, min(h, c), c >= 0.0); //                 h is cmax\n    }\n\n    h = h * 0.01 * s / (13.0 * l); //                       h is c / (13 * l)\n\n    s = hcos * h + 0.19783; //                              s is varU\n    h = 1.0 / (hsin * h + 0.4683); //                       h is 1 / varV\n\n    l = mix(cube(b), l / 903.0, l <= 8.0); //               l is y\n    s = 9.0 * l * h * s * 0.25; //                          s is x\n    h = 3.0 * l * h - s * 0.33333333 - 5.0 * l; //          h is z\n\n    return xyz_to_rgb(vec3(s, l, h));\n}\n\n#define res iResolution.xy\n#define in0 iChannel0\n", "buffer_a_code": "//==============//\n//= Test image =//\n//==============//\n\n#define MANDELBROT_ITERATIONS 180\n\n//= Mandelbrot escape time function =//\nfloat escape_time(vec2 xy) {\n    vec2 t;\n    vec2 u;\n\n    for(int i; i < MANDELBROT_ITERATIONS; i++) {\n        t.y = 2.0 * t.x * t.y + xy.y;\n        t.x = u.x - u.y + xy.x;\n        u = t * t;\n\n        if (u.x + u.y > 4.0) return float(i) * 0.01;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec2 fix = ratio_fix(res); // Calculate aspect ratio fix.\n\n    vec2 xy = pos;\n    vec2 uv = pos / res;\n\n    xy /= res;       //          Normalize ccordinates.\n    xy *= fix;       //          Fix aspect ratio.\n    xy -= fix * 0.5; //          Center origin.\n\n    xy -= vec2(+3.0, -0.3); //   Move origin.\n    xy *= 0.5; //                Scale origin (less is deeper).\n\n    float t = escape_time(xy);\n\n    col  = vec4(hsluv(uv.y * 0.74 * PI2, 100.0, pow(t, 0.5) * 100.0), 1);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 292]], "test": "untested"}
{"id": "sddGWf", "name": "Simple and robust debanding", "author": "miyaokamarina", "description": "• Doesn’t require a large number of iterations.\n• Doesn’t damage areas without banding.\n• Robust on both large and small bands.", "tags": ["dithering", "debanding"], "likes": 3, "viewed": 322, "published": 3, "date": "1630955742", "time_retrieved": "2024-07-30T19:02:51.055910", "image_code": "//=======================================================================//\n//=  # Simple and robust debanding shader                               =//\n//=                                                                     =//\n//=   -  Doesn’t require a large number of iterations.                  =//\n//=   -  Doesn’t damage areas without banding.                          =//\n//=   -  Robust on both large and small bands.                          =//\n//=                                                                     =//\n//=  TO SEE THE ORIGINAL IMAGE — click/drag the image.                  =//\n//=                                                                     =//\n//=  TO INCREASE CONTRAST — uncomment the `DEBUG` macro.                =//\n//=                                                                     =//\n//=  Sources:                                                           =//\n//=                                                                     =//\n//=   -  gh:mpv-player/mpv/blob/master/video/out/gpu/video_shaders.c    =//\n//=   -  gh:ahjolinna/mpv-conf/blob/master/mpv/etc/shaders/deband.glsl  =//\n//=======================================================================//\n\n//=======================================================================//\n//=  ## Debanding radius                                                =//\n//=                                                                     =//\n//=  Sorta kinda sampling radius. Actual values may vary, though.       =//\n//=                                                                     =//\n//=  Try changing this value and comment some of the `average`  calls   =//\n//=  in the `deband` function.                                          =//\n//=                                                                     =//\n//=  ≈60 seems to be a reasonable default.                              =//\n//=======================================================================//\n#define R 64.0\n\n//=======================================================================//\n//=  ## Debanding threshold                                             =//\n//=                                                                     =//\n//=  Only apply debanding when a local contrast (per channel) is under  =//\n//=  this threshold.                                                    =//\n//=                                                                     =//\n//=  Defaults to $\\frac{1}{256} (targeting 8 bit per channel outputs).  =//\n//=======================================================================//\n#define T 1.0 / 256.0\n\n// Instead of sampling multiple times at increasing distances,\n// we may sample once, but using the normal distribution to calculate a random offset.\n//\n// In this case, actual samples may be at distances greater than required,\n// but with less probability.\n//\n// This allows us to achieve near-perfect quality at just three interations.\n//\n// Possible PDF types:\n//\n//  -  `NORMAL`  — the default, use the normal distribution.\n//  -  `UNIFORM` — use the uniform distrubution within a circle.\n//  -  `SIMPLE`  — use the triangular distrubution within a circle.\n//\n// See the `random2` function for details.\n#define DEBAND_PDF SIMPLE\n\n// Comment this to see original colors:\n#define DEBUG\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2  uv = fragCoord / iResolution.xy;\n\n    float px = fragCoord.x;\n    float py = fragCoord.y;\n    float mx = iMouse.x;\n    float my = iMouse.y;\n\n    bool l = px + 1.0 < mx; bool r = px - 1.0 > mx;\n    bool t = py - 1.0 > my; bool b = py + 1.0 < my;\n\n    fragColor = vec4(vec3(0), 1);                                                // slider\n    fragColor = mix(fragColor, deband(fragCoord),      bvec4(l && b || r && t)); // debanded quarters\n    fragColor = mix(fragColor, texture(iChannel0, uv), bvec4(r && b || l && t)); // original quarters\n\n    #ifdef DEBUG\n        fragColor *= 8.0;\n        fragColor -= 0.5;\n    #endif\n}\n\nvec4 deband(vec2 fragCoord) {\n    vec4 src  = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 tmp  = src;\n    vec4 rand = random4(fragCoord);\n\n    average(fragCoord, tmp, 8.0, rand.yz); // Dither small bands\n    average(fragCoord, tmp, R,   rand.zw); // Dither large bands\n\n    vec4 noise = rand;\n\n    noise *= T;         // Scale the noise.\n    noise *= src - tmp; // Scale it further and discard unwanted noise in non-banded areas.\n\n    return tmp + noise;\n}\n\n// Local contrast calculation interation.\nvoid average(vec2 fragCoord, inout vec4 tmp, float radius, vec2 rand) {\n    // Compute a random point:\n    vec2 o = random2(rand) * radius;\n\n    // Sample at quarter-turn intervals around the source pixel:\n    vec4 avg = texture(iChannel0, (fragCoord + o * vec2(-1, -1)) / iResolution.xy)\n             + texture(iChannel0, (fragCoord + o * vec2(-1, +1)) / iResolution.xy)\n             + texture(iChannel0, (fragCoord + o * vec2(+1, -1)) / iResolution.xy)\n             + texture(iChannel0, (fragCoord + o * vec2(+1, +1)) / iResolution.xy);\n\n    avg *= 0.25;\n    vec4 diff = abs(tmp - avg);\n\n    // Replace the current value, if a local contrast is below threshold:\n    tmp = mix(avg, tmp, greaterThan(diff, vec4(T)));\n}\n\nvec4 random4(vec2 pos) {\n    return texture(iChannel1, pos / iChannelResolution[1].xy);\n}\n\n// Picks a random point in the ≈ (-1, +1) range.\nvec2 random2(vec2 rand) {\n    #if defined(DEBAND_PDF) && DEBAND_PDF == SIMPLE\n        float a = rand.x * PI2; // Angle\n        float r = rand.y;       // Radius\n\n        return vec2(cos(a), sin(a)) * r;\n    #elif defined(DEBAND_PDF) && DEBAND_PDF == UNIFORM\n        float a = rand.x * PI2; // Angle\n        float r = sqrt(rand.y); // Kinda radius\n\n        return vec2(cos(a), sin(a)) * sqrt(r);\n    #else\n        // https://en.wikipedia.org/wiki/Box–Muller_transform\n        float r = sqrt(-2.0 * log(rand.x));\n        float t = PI2 * rand.y;\n\n        return vec2(r * cos(t), r * sin(t));\n    #endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NORMAL  1\n#define UNIFORM 2\n#define SIMPLE  3\n\n#define PI   3.141592653589793\n#define PI2  6.283185307179586\n\nfloat escape_time(vec2 pos);\nvec2  ratio_fix(vec2 res);\n\nvec4  random4(vec2 pos);\nvec2  random2(vec2 rand);\nvoid  average(vec2 pos, inout vec4 tmp, float radius, vec2 rand);\nvec4  deband(vec2 pos);\n", "buffer_a_code": "// Test image\n\n#define MANDELBROT_ITERATIONS 128\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec2 fix = ratio_fix(iResolution.xy); // Calculate aspect ratio fix.\n\n    pos /= iResolution.xy;                // Normalize ccordinates.\n    pos *= fix;                           // Fix aspect ratio.\n    pos -= fix * 0.5;                     // Center origin.\n\n    pos -= vec2(+3.0, -0.3);              // Move origin.\n    pos *= 0.5;                           // Scale origin (less is deeper).\n\n    float t = escape_time(pos) + 0.08;\n\n    // Green makes the most significant perceptual difference with minimal value changes:\n    col = vec4(t, t, t, 1);\n}\n\nconst float COLOR_SCALE = 0.00390625; // 1/256\n\n//= Mandelbrot escape time function =//\nfloat escape_time(vec2 pos) {\n    vec2 t;\n    vec2 u;\n\n    for(int i; i < MANDELBROT_ITERATIONS; i++) {\n        t.y = 2.0 * t.x * t.y + pos.y;\n        t.x = u.x - u.y + pos.x;\n        u = t * t;\n\n        if (u.x + u.y > 4.0) return float(i) / 256.0;\n    }\n\n    return 0.0;\n}\n\n\nvec2 ratio_fix(vec2 res) {\n    float rmax  = max(res.x, res.y);\n    float rmin  = min(res.x, res.y);\n    float ratio = rmax / rmin;\n    float fx    = mix(1.0, ratio, res.x > res.y);\n    float fy    = mix(1.0, ratio, res.y > res.x);\n\n    return vec2(fx, fy);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3329, 3329, 3384, 3384, 4018], [4020, 4020, 4049, 4049, 4489], [4491, 4533, 4604, 4635, 5251], [5253, 5253, 5277, 5277, 5342], [5344, 5395, 5420, 5420, 5998]], "test": "untested"}
{"id": "NdG3Rz", "name": "大龙猫 - Close enc 3rd kind Panel", "author": "totetmatt", "description": "Not perfect, but close enough :D ", "tags": ["closeencounterthirdkind"], "likes": 6, "viewed": 288, "published": 3, "date": "1630946983", "time_retrieved": "2024-07-30T19:02:51.962487", "image_code": "vec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.3,.7)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n    vec2 f = vec2(8.,12.);\n    vec2 uuv  = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\n\n  float coord = (floor(uuv.x*f.x )/(f.x*f.y) +floor(uuv.y*f.y )/f.y )/2.;\n\n  coord = 259.*log(1.+ (coord)/700.); // sort of Mel scale\n  float t = (texture(iChannel0,fract(vec2(coord))).r);\n  vec3 col  = sqrt(vec3(smoothstep(.50,.6,t))*pal(uuv.x));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28044, "src": "https://soundcloud.com/user928292366/close-encounters-of-the-third", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 64], [65, 65, 122, 122, 574]], "test": "untested"}
{"id": "NdyGRz", "name": "Smoothed Line Segment but jank", "author": "TimArt", "description": "Modified https://www.shadertoy.com/view/3tdSDj by IQ\n\nTrying to get a smoothed line segment SDF. Used smoothstep, but this approach suffers from artifacts when the line is vertical.", "tags": ["2d", "distancefield", "sdf", "line", "distance", "segment"], "likes": 2, "viewed": 227, "published": 3, "date": "1630946263", "time_retrieved": "2024-07-30T19:02:52.822188", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and line segment\n\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// and many more here:   https://iquilezles.org/articles/distfunctions2d\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat normalizedX = (p.x - a.x) / (b.x - a.x);\n    float lineCenterY = mix (a.y, b.y, smoothstep(0.0f, 1.0f, normalizedX));\n    return lineCenterY - p.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tfloat zoom = 2.5;\n\tpos *= zoom;\n\n\tvec2 v1 = cos(iTime + vec2(0.,5.));\n\tvec2 v2 = cos(iTime + vec2(0.,5.) + 3.1);\n\tfloat thickness = .2 * (.5 + .5 * sin(iTime * 1.));\n\n\tfloat d = line_segment(pos, v1, v2) - thickness;\n\n\tvec3 color = vec3(1.) - sign(d) * vec3(0., 0., 0.);\n\tcolor *= 1.5 - exp(.5 * abs(d));\n\tcolor *= .5 + .3 * cos(120. * d);\n\tcolor = mix(color, vec3(1.), 1. - smoothstep(.0, .015, abs(d)));\n\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyGRz.jpg", "access": "api", "license": "mit", "functions": [[1252, 1252, 1305, 1305, 1498], [1500, 1500, 1555, 1555, 2058]], "test": "untested"}
{"id": "7dt3Dl", "name": "Twisty Marching", "author": "oneshade", "description": "Testing an idea I had while trying to understand [url=https://www.shadertoy.com/view/fdd3Ws]this[/url] shader.\nLeft click with the mouse to restart it.", "tags": ["raymarching", "twisty", "bisection"], "likes": 5, "viewed": 153, "published": 3, "date": "1630940324", "time_retrieved": "2024-07-30T19:02:53.971116", "image_code": "#define hue2rgb(t) abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(t, t - 1.0 / 3.0, t + 1.0 / 3.0))) - 1.0)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    vec3 rd = normalize(vec3(uv, -FOCAL_LEN));\n    vec4 buf = texture(iChannel0, fragCoord / iResolution.xy);\n    float t = buf.x, hit = buf.y;\n    if (hit > 0.5) {\n        // Refine with bisection\n        float tmin = t - dt, tmax = t;\n        for (int i=0; i < REFINEMENT; i++) {\n            float tmid = (tmin + tmax) * 0.5;\n            if (map(CAM_POS + rd * tmid) < 0.0) tmax = tmid;\n            else tmin = tmid;\n        }\n\n        t = (tmin + tmax) * 0.5;\n        vec3 hit = CAM_POS + rd * t;\n        vec3 nor = getNormal(hit);\n\n        vec3 color = hue2rgb((nor.x - 0.5 * nor.y) * nor.z);\n        float shade = max(0.0, dot(nor, normalize(vec3(-1.0, 1.0, 1.0))));\n        fragColor.rgb = color * shade;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define CAM_POS vec3(0.0, 0.0, 8.0)\n#define FOCAL_LEN 1.0\n\n#define START 3.0\n#define REFINEMENT 10\n#define dt 0.01 //0.001\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat map(in vec3 p) {\n    p.xz *= Rotate2D(0.4);\n    p.yz *= Rotate2D(-0.78);\n    p.xz *= Rotate2D(p.y);\n    p.x += p.y;\n    p.yz *= Rotate2D(-p.z);\n    p.y += p.x;\n    p.xz *= Rotate2D(-p.z);\n    p.xz *= Rotate2D(p.y);\n    return length(abs(p.xz) - 1.5) - 0.5;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 0) {\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        fragColor = vec4(0.0);\n\n        vec3 rd = normalize(vec3(uv, -FOCAL_LEN));\n        float t = texture(iChannel0, fragCoord / iResolution.xy).x;\n        if (map(CAM_POS + rd * t) > 0.0) t += dt; // If not inside, step forward\n        else fragColor.y = 1.0; // Else, flag a hit\n\n        fragColor.x = t;\n    }\n\n    if (iFrame == 0 || iMouse.z > 0.0) {\n        fragColor = vec4(START, 0.0, 0.0, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 158, 158, 971]], "test": "untested"}
{"id": "fsG3zR", "name": "Slowtember 04-06: Shop", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 25, "viewed": 320, "published": 3, "date": "1630939829", "time_retrieved": "2024-07-30T19:02:55.250695", "image_code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.1415927\n#define E .002\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nfloat h(vec2 uv, float y0, float height, float e) {\n    return estep(y0 - height * .5, uv.y, -e) * estep(y0 + height * .5, uv.y, e);\n}\n\nfloat v(vec2 uv, float x0, float width, float e) {\n    return estep(x0 - width * .5, uv.x, -e) * estep(x0 + width * .5, uv.x, e);\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    if (seed < .0)\n        seed *= -1.;\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * 2. * PI) * uv.x - sin(angle * 2. * PI) * uv.y,\n        sin(angle * 2. * PI) * uv.x + cos(angle * 2. * PI) * uv.y\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circle(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return estep(min(size.x, size.y) * .5, length(uv), e * 2.);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return \n        estep(size.x * .5, uv.x, e) *\n        estep(-size.x * .5, uv.x, -e) *\n        estep(size.y * .5, uv.y, e) *\n        estep(-size.y * .5, uv.y, -e);\n}\n\nfloat tri(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        estep(-size.x * .5, uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(-size.x * .5, - uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(.0, uv.y, -e);\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = pow(pow(size.x * .5, 2.) - pow(size.y * .5, 2.), .5);\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = pow(pow(size.y * .5, 2.) - pow(size.x * .5, 2.), .5);\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circleh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return n(\n        circle(uv, vec2(.0), size, .0, .0, e) - \n        circle(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\nfloat recth(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rect(uv, vec2(.0), size, .0, .0, e) - \n        rect(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n// WIP\nfloat trih(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        tri(uv, vec2(.0), size, .0, .0, e) - \n        tri(uv, vec2(.0, -r * .2), size - vec2(r * pow(2., .5)), .0, .0, e)\n    );\n}\n\nfloat ellh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        ell(uv, vec2(.0), size, .0, .0, e) - \n        ell(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / (2. * PI);\n    return n(\n        circle(uv, p1, vec2(size), .0, .0, e) +\n        circle(uv, p2, vec2(size), .0, .0, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), .0, -angle, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectr(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, vec2(r), .0, .0, e) +\n        circle(uv, - v1, vec2(r), .0, .0, e) +\n        circle(uv, + v2, vec2(r), .0, .0, e) +\n        circle(uv, - v2, vec2(r), .0, .0, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, .0, e)\n    );\n}\n\nfloat rectr2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, .0, E)\n    );\n}\n\nfloat trir(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    vec2 v3 = (v1 + v2) * .5;\n    return n(\n        line(uv, -v1, v3, r, e) +\n        line(uv, -v1, -v2, r, e) +\n        line(uv, v3, -v2, r, e) +\n        tri(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectrh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, e) -\n        rectr(uv, vec2(.0), size - vec2(r), r, .0, e)\n    );\n}\n\n// WIP\nfloat trirh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        trir(uv, vec2(.0), size, r, .0, e) -\n        trir(uv, vec2(.0, -r * .2), size - vec2(r), r, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define BG_PLANK_W .6\n#define BG_PLANK_H .15\n#define PLANK_LIGHT vec3(.48, .36, .23)\n#define PLANK_DARK vec3(.28, .20, .14)\n\n#define CORK vec3(.66, .44, .23)\n\nfloat plank_text(vec2 uv, vec2 size, float plank_seed, float range) {\n    if (rand(plank_seed++) > .5)\n        uv.x = (size.x - uv.x);\n        return h(\n                uv + vec2(.0, sin(uv.x * (15. + 15. * rand(plank_seed++))) * .002),\n                size.y * (.05 + .9 * rand(plank_seed++)),\n                cos(uv.x * (10. + range * (rand(plank_seed++) - .5))) * .01\n                , E);\n}\n\nfloat plank_dark(vec2 uv, vec2 size, float plank_seed) {\n    float m = .0;\n    \n    m += plank_text(uv, size, plank_seed++, 3.);\n    m += plank_text(uv, size, plank_seed++, 3.);\n    \n    m += v(uv, -.005, .02, E);\n    m += h(uv, -.005, .02, E);\n    m += v(uv, size.x + .005, .02, E);\n    m += h(uv, size.y + .005, .02, E);\n    \n    return n(m);\n}\n\nvec3 plank(vec3 c, vec2 uv, vec2 center, vec2 size, float plank_seed, float color_shift) {\n    uv += size * .5 - center;\n    \n    vec3 c0 = PLANK_LIGHT - rand(plank_seed++) * .02 + color_shift;\n    vec3 c1 = PLANK_DARK;\n    \n    float pmask = rect(uv, size * .5, size, .0, .0, E);\n    float pmask2 = rect(uv, size * .5, size - .005, .0, .0, E);\n    \n    c = mask(c, c0, pmask2);\n    \n    for(int i = 0; i < 50; i++)\n        c = mask(c, c1, pmask2 * rand(plank_seed++) * .2 * plank_text(uv, size, plank_seed++, 20.));\n    \n    plank_seed++;\n    \n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(.005), size, plank_seed));\n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(-.005), size, plank_seed));\n    c = mask(c, c1, pmask * plank_dark(uv, size, plank_seed));\n\n    return c;\n}\n\nvec3 background(vec2 uv0) {\n    vec2 size = vec2(BG_PLANK_W, BG_PLANK_H);\n\n    uv0.x += mod(uv0.y, 2. * size.y) < size.y ? size.x * .5 : .0;\n    vec2 uv = vec2(mod(uv0.x, size.x), mod(uv0.y, size.y));\n    \n    float plank_seed = floor(uv0.x / size.x) * 938. + floor(uv0.y / size.y) * 324. + 100.;\n\n    return plank(PLANK_DARK, uv, size * .5, size, plank_seed, .0);\n}\n\nfloat writing(vec2 uv, vec2 center, vec2 size, float ampl, float angle, float seed, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return  h(\n        vec2(uv.x, uv.y + sin((uv.x + rand(seed++)) * 123.) * sin((uv.x + rand(seed++)) * 256.) * sin((uv.x + rand(seed++)) * 89.) * sin((uv.x + rand(seed++)) * 111.) * ampl), \n        .0, size.y * .25, E) * rect(uv, vec2((rand(seed++) - .5) * size.x * .1, (rand(seed++) - .5) * size.y * .5), vec2(size.x * .9 - rand(seed++) * size.x * .6, size.y), .0, .0, e);\n}\n\nvec3 shelf(vec3 c, vec2 uv, float seed) {\n    float shadow = n(\n        rect(uv, vec2(.03, -.18), vec2(.35, .1), .0, .0, E) +\n        tri(uv, vec2(.175, -.115), vec2(.06, .03), .0, .0, E) +\n        tri(uv, vec2(-.16, -.20), vec2(.06, .03), .0, .75, E)\n    );\n\n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    float label_x = (rand(seed++) - .5) * .2;\n    \n    float shadow2 = n (\n        rect(uv + vec2(-.02, .02), vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv + vec2(-.02, .02), vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow2);\n    \n    c = mask(c, vec3(.9, .9, .85), n(\n        rect(uv, vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv, vec2(label_x - .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    ));\n    c = mask(c, vec3(.9, .9, .85) * .9, tri(uv, vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E));\n\n    float price = 1. + floor(rand(seed++) * 4.);\n    \n    float x;\n    \n    for(float i = 0.; i < price; i++) {\n        x = label_x - .015 - (i - price * .5) * .021 + (uv.y + .08) * .10;\n        c = mask(c, vec3(.2), v(uv, x + sin(uv.y * 600.) * .008, .005, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .02) ,.0, .0, E));\n        c = mask(c, vec3(.2), v(uv, x, .003, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .025) ,.0, .0, E));\n    }\n\n    c = plank(c, uv, vec2(.0, -.15), vec2(.35, .1), seed, -.04);\n    \n    return c;\n}\n\nvec3 potion(vec3 c, vec2 uv, float seed) {\n\n    float bg, outside, shadow, liquid_mask;\n    \n    float form = rand(seed++);\n    \n    vec2 label_pos = vec2((rand(seed++) - .5) * .02, -.01 + (rand(seed++) - .5) * .02);\n    \n    if(form < .333) {\n        bg = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        outside = n(\n            ellh(uv, vec2(.0, -.01), vec2(.2, .18), .03, .0, E) +\n            ellh(uv, vec2(.01, -.03), vec2(.2, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = ell(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        \n        liquid_mask = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n    } else if(form < .66) {\n        bg = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        outside = n(\n            recth(uv, vec2(.0, -.01), vec2(.15, .18), .03, .0, E) +\n            recth(uv, vec2(.02, -.03), vec2(.15, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = rect(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        \n        liquid_mask = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n    } else {\n        bg = n (\n            tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E) -\n            rect(uv, vec2(.0, .15), vec2(.1, .1), .0, .0, E)\n        );\n        outside = n(\n            trih(uv, vec2(.0, .01), vec2(.23, .23), .04, .0, E) +\n            trih(uv, vec2(.01, -.02), vec2(.23, .23), .03, .0, E) *\n            rect(uv, vec2(-.03, .0), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = tri(uv + vec2(-.03, .03), vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        liquid_mask = tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        label_pos += vec2(.0, -.03);\n    }       \n\n    bg = n(bg + rect(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E));\n\n    outside = n(\n        outside +\n        recth(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E) -\n        rect(uv, vec2(.0, .10), vec2(.03, .08), .0, .0, E) * 2.\n    );\n    \n    float cork = n (\n        tri(uv, vec2(.0, .105), vec2(.05, .1), .0, .5, E) -\n        rect(uv, vec2(.0, .08), vec2(.033, .06), .0, .0, E)\n    );\n    \n    shadow = n (\n        shadow +\n        rect(uv + vec2(-.03, .03), vec2(.0, .10), vec2(.06, .07), .03, .0, E) +\n        tri(uv + vec2(-.03, .03), vec2(.0, .105), vec2(.05, .1), .0, .5, E)\n    );\n    \n    float liquid_h = .1 + rand(seed++) * .2;\n    \n    float liquid = n (\n        liquid_mask * h(uv, -.1 + liquid_h * .5 * .5, liquid_h * .5, E)\n        - outside\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    c = mask(c, mask(col(rand(seed++)), col(rand(seed++ + 20.)), (uv.y + .18 - liquid_h * .5) * 13.), liquid);\n    c = mask(c, CORK + .05 * rand(seed++), cork);\n    c = mask(c, vec3(1.), .3 * bg);\n    c = mask(c, vec3(1.), .7 * outside);\n    \n    float label_angle = (rand(seed++) - .5) * .05;\n    float label_width = .07 + rand(seed++) * .04;\n    \n    c = mask(c, vec3(.9, .9, .8 + rand(seed++) * .1), rect(uv, label_pos, vec2(label_width, .04), .0, label_angle, E));\n    \n    c = mask(c, vec3(.2 + (rand(seed++) - .5) * .1), writing(uv, label_pos, vec2(label_width, .04), .01, label_angle, seed++, E));\n    \n    c = shelf(c, uv, seed++);\n    \n    return c;\n}\n\nvec3 image(vec2 uv0, float t) {\n    vec3 c = vec3(.0);\n    \n    vec2 uv = uv0 - vec2(t * .1);\n    \n    c = background(uv);\n\n    float seed = floor(uv.x * 2.) * 493. + floor(uv.y * 2.) * 482.;\n    \n    c = potion(c, mod(uv, .5) - .25, seed);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    if (size < .00001)\n        return image(uv, t0);\n\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 c = colorShiftImage(uv, iTime, iTime * 5., .0);\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 218, 218, 252], [254, 254, 302, 302, 360], [362, 362, 413, 413, 496], [498, 498, 548, 548, 629], [631, 631, 648, 648, 692], [694, 694, 732, 732, 774], [776, 776, 800, 800, 925], [927, 927, 946, 946, 1115], [1117, 1117, 1149, 1149, 1308], [1473, 1473, 1551, 1551, 1635], [1637, 1637, 1713, 1713, 1925], [1927, 1927, 2002, 2002, 2271], [2273, 2273, 2348, 2348, 2762], [2927, 2927, 3006, 3006, 3152], [3154, 3154, 3231, 3231, 3398], [3400, 3407, 3483, 3483, 3671], [3673, 3673, 3749, 3749, 3914], [4079, 4079, 4139, 4139, 4410], [4575, 4575, 4652, 4652, 5122], [5124, 5124, 5202, 5202, 5393], [5395, 5395, 5471, 5471, 5814], [5979, 5979, 6057, 6057, 6223], [6225, 6232, 6309, 6309, 6482], [6806, 6806, 6875, 6875, 7200], [7202, 7202, 7258, 7258, 7548], [7550, 7550, 7640, 7640, 8351], [8353, 8353, 8380, 8380, 8719], [8721, 8721, 8815, 8815, 9236], [9238, 9238, 9279, 9279, 10664], [10666, 10666, 10708, 10708, 14033], [14035, 14035, 14066, 14066, 14296], [14298, 14298, 14361, 14361, 14676], [14678, 14678, 14733, 14733, 14927]], "test": "untested"}
{"id": "NsyGzR", "name": "move ufo camera", "author": "jorge2017a1", "description": "move ufo camera", "tags": ["moveufocamera"], "likes": 1, "viewed": 225, "published": 3, "date": "1630939076", "time_retrieved": "2024-07-30T19:02:56.327814", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n\n //fork programmed ufo--2-sep-2021\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec3 moverObj(vec3 p, vec3 p1, vec3 p2,float tInc, float tA ,float tB)\n{   vec3 pres=p1;\n    if (tInc<tA) pres=p;\n        \n    if (tInc>=tA && tInc<tB)\n    { pres.x=mix(p1.x, p2.x, smoothstep(tA, tB,tInc));\n      pres.y=mix(p1.y, p2.y, smoothstep(tA, tB,tInc));\n      pres.z=mix(p1.z, p2.z, smoothstep(tA, tB,tInc));\n      pres=p-pres;\n    }\n    \n    if (tInc>tB)  pres=p-p2;\n    \n    return pres;\n}\n\n\nvec3 Nave(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXZ( p, vec2(5.0,0.25) );\n    float sdcy2= sdCylinderXZ( p-vec3(0.0,0.25,.0), vec2(5.0,0.15) );\n    float sds1= sdSphere(p-vec3(0.0,1.0,0.0), 1.0 );\n    res =opU3(res, vec3(sdcy1,3.0,-1.0));\n    res =opU3(res, vec3(sdcy2,1.0,-1.0));\n    res =opU3(res, vec3(sds1,1.0,-1.0));\n    \n    return res;\n}\n\n\nvec3 Arbol(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    p.z-=5.0;\n    p.y+=2.0;\n    float sdTronco=sdCylinderXZ(p-vec3(0.0,4.0,0.0), vec2(0.7,8.0) );\n    float sdcy1=sdCylinderXZ(p-vec3(0.0,4.0,0.0), vec2(5.0,0.5) );\n    float sdcy2=sdCylinderXZ(p-vec3(0.0,6.0,0.0), vec2(4.0,0.5) );\n    float sdcy3=sdCylinderXZ(p-vec3(0.0,8.0,0.0), vec2(3.0,0.5) );\n    float sdcy4=sdCylinderXZ(p-vec3(0.0,10.0,0.0), vec2(2.0,0.5) );\n    float sdcy5=sdCylinderXZ(p-vec3(0.0,12.0,0.0), vec2(1.0,0.5) );\n    \n    res =opU3(res, vec3(sdTronco,1.0,-1.0));\n    res =opU3(res, vec3(sdcy1,3.0,-1.0));\n    res =opU3(res, vec3(sdcy2,3.0,-1.0));\n    res =opU3(res, vec3(sdcy3,3.0,-1.0));\n    res =opU3(res, vec3(sdcy4,3.0,-1.0));\n    res =opU3(res, vec3(sdcy5,3.0,-1.0));\n    \n    \n    return res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,100.0,-1.0)); //inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n    p.y=p.y-5.0;\n    \n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n    \n    float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        sdres= Nave(pnew1);\n    else if(timeMov<10.0)\n        sdres= Nave(pnew2);\n    else if(timeMov<20.0)\n        sdres= Nave(pnew3);\n    else if(timeMov<30.0)\n        sdres= Nave(pnew4);\n     \n   \n    res =opU3(res, sdres);\n    \n    vec3 ar1= Arbol(p-vec3(.0,.0,.0));\n    vec3 ar2= Arbol(p-vec3(30.0,.0,.0));\n    vec3 ar3= Arbol(p-vec3(40.0,.0,40.0));\n    vec3 ar4= Arbol(p-vec3(60.0,.0,80.0));\n    \n    res =opU3(res, ar1);\n    res =opU3(res, ar2);\n    res =opU3(res, ar3);\n    res =opU3(res, ar4);\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n  \n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n        \n        \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(8.0,7.0,-20.0);\n   \n   ///-----------------------\n   \n   vec3 p=-ro;\n   \n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n     float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        ro= pnew1;\n    else if(timeMov<10.0)\n        ro= pnew2;\n    else if(timeMov<20.0)\n        ro= pnew3;\n    else if(timeMov<30.0)\n        ro=pnew4;\n    \n   \n   ///-----------------------\n   //ro= rotate_y(ro, radians(180.0));\n   ro= rotate_x(ro, radians(180.0));\n   ro.x=-ro.x;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 553, 553, 574], [575, 575, 614, 614, 709], [710, 710, 749, 749, 844], [845, 845, 884, 884, 979], [1022, 1047, 1081, 1081, 1177], [1178, 1178, 1212, 1212, 1303], [1304, 1304, 1338, 1338, 1429], [1431, 1431, 1465, 1465, 1560], [1563, 1563, 1635, 1635, 1962], [1965, 1965, 1984, 1984, 2342], [2345, 2345, 2365, 2365, 3123], [3125, 3165, 3190, 3190, 4439], [4441, 4492, 4516, 4516, 4678], [4680, 4680, 4729, 4729, 5365], [5367, 5454, 5490, 5490, 5735], [5736, 5791, 5818, 5818, 5835], [5837, 5837, 5873, 5873, 5965], [5966, 5966, 6012, 6012, 6137], [6139, 6139, 6213, 6213, 7814], [7815, 7870, 7919, 7919, 8158], [8159, 8193, 8273, 8273, 8396], [8439, 8439, 8471, 8471, 8668], [8670, 8718, 8746, 8746, 8934], [8936, 8987, 9034, 9034, 9281], [9283, 9335, 9428, 9428, 9916], [9919, 9919, 9950, 9950, 10572], [10574, 10623, 10649, 10649, 10759], [10761, 10761, 10819, 10819, 10871], [10873, 10922, 10979, 10979, 12358]], "test": "untested"}
{"id": "sdt3Dl", "name": "diamond in tetrahedron in cube", "author": "FabriceNeyret2", "description": "tribute to https://iquilezles.org/articles/normalsSDF/normalsSDF.htm\nvariant of variant\n( Funny: the fork link above is wrong. seems to be shader#0000 :-p )", "tags": ["raymarching", "short"], "likes": 14, "viewed": 413, "published": 3, "date": "1630915638", "time_retrieved": "2024-07-30T19:02:57.370028", "image_code": "// Fork of spalmer's https://shadertoy.com/view/Ndt3WX\n// minor modification of Fabrice's https://shadertoy.com/view/7s33Df\n\n#define rot(a)     mat2(cos(a+vec4(0,11,33,0)))               // rotation                  \n#define tri(D)     min( D(x,y,z), min( D(y,z,x), D(z,x,y) ) ) // apply D in 3 orientation xyz, yzx, zxy\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s,c,e,l; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n        a = abs(q),\n        c = max(a.x,max(a.y,a.z))-1.,                         // cube\n#define A(x,y,z) vec3(x,y,z)/sqrt(3.)\n#define D(x,y,z) dot(q,A(x,y,z))\n#define C(x,y,z) length( abs(vec2(q.x,q.y)) - 1.)\n        t = min(t, e = max(tri(C)-.01, c)),                   // cube edges\n#define P(x,y,z) length(q - max(0.,D(x,y,z))*A(x,y,z))\n       // t = min(t, l = max(min(min(P(1,1,-1),P(1,-1,1)),min(P(-1,1,1),P(-1,-1,-1))) -.1 , c ) ), // tetra axes\n#define C0(x,y,z) length(vec2(q.x,q.y))\n       t = min(t, l = max(tri(C0)-.01, c-.5)),                // green cross\n#define T(x,y,z) length(vec2( (q.x-q.z)*.7, q.y-1.) )\n#define Te(x,y,z) min( T(x,y,z), T(x,y*-1.,z*-1.) )\n        t = min(t, max( tri(Te) -.05, c)),                    // tetrahedron\n#define T0(x,y,z) length( vec2( (abs(q.x-q.z)-1.)*.7, q.y ))\n#define T0e(x,y,z) min( T0(x,y,z), T0(x,y,z*-1.) )\n        t = min(t, s = max(  tri(T0e) -.025 , c)),            // red diamond\n       // t = min(t, -sqrt(1./3.) + max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1)))), // tetrahedron\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t==e) O.rg *=.7;                                      // coloring\n    if (t==s) O.gb *= 0.;\n    if (t==l) O.rb *= 0.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssdGWl", "name": "Descending Space Balls", "author": "Plento", "description": "Quicky sketch. ", "tags": ["2d", "space", "sketch", "stairs"], "likes": 15, "viewed": 304, "published": 3, "date": "1630913433", "time_retrieved": "2024-07-30T19:02:58.268625", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define stairLength 4.0\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 stairpos(float x){\n    return vec2(x, -x*.75 + .1);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u - .5*R) / R.y;\n    uv.y += .2;\n    vec2 uv2 = uv;\n    uv.y *= 1.3;\n    \n    vec3 col = vec3(.0);\n    \n    float scl = 0.2;\n    \n    // Barycentric stuff\n    vec2 A = vec2(0.2, .25)*scl;\n    vec2 B = vec2(-0.25, -0.25)*scl;\n    vec2 C = vec2(0.25, -0.25)*scl;\n    \n    vec3 M = vec3(uv.x, uv.y, 1.);\n    mat3 mat = mat3(vec3(A, 1.), vec3(B, 1.), vec3(C, 1.));\n    \n    vec3 bc = inverse(mat) * M;\n    vec3 bid = floor(bc);\n    \n    vec3 rbc = fract(bc)-.5;\n    bid = floor(bc);\n    \n    vec3 nc = vec3(0);\n    float a = 0.;\n    \n    vec3 nse = vec3(hsh(u));\n    col = ss(.998, 1.0, nse);\n    \n    // Stairz\n    if(bid.x >= bid.y && bid.x < stairLength + bid.y){\n        nc = .5*mix(vec3(.6), vec3(.05), mod(bid.z, 2.)) + nse*.02;\n        nc *= ss(.86, .0, abs(rbc.z));\n        a = 1.;\n    }\n    if(bid.x < bid.y){\n        nc = nse * .02 * (uv.y+.5);\n        a = 1.;\n    }\n    \n    col = mix(col, nc, a);\n    \n    // Ballz\n    for(float i = 0.; i < 8.; i++){\n        float x = (-i*.13 + iTime*.1743 - 1.54);\n        x = mod(x, 2.);\n        vec2 cb = stairpos(x - 1.);\n        cb.y += .116*abs(cos(iTime*5.0 + i*8.5));\n        float bb = ss(.0, .001, length(uv2 - cb) - .04);\n        vec3 ball = (.4+.3*cos(vec3(2., 5., 2.5)*i*160.)) * ss(.065, .0, length(uv2 - cb) + .01);\n        float shdw = ss(.0, .1, length(uv2 - cb + vec2(0., .04)));\n        col *= max(shdw, .05);\n        col = mix(ball, col, bb);\n    }\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 135, 135, 252], [254, 254, 277, 277, 312], [314, 314, 354, 354, 1837]], "test": "untested"}
{"id": "fdd3Ws", "name": "Tangled Dreams", "author": "leon", "description": "Result of experimentation with a new way to render highly distorted geometry", "tags": ["colorful", "weird", "dream"], "likes": 55, "viewed": 1410, "published": 3, "date": "1630891507", "time_retrieved": "2024-07-30T19:02:59.036572", "image_code": "\n// main code is in Buffer A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render result of Buffer A\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// tangled dreams by leon denise 2021/09/06\n// using code from Inigo Quilez, Dave Hoskins, Nusan\n\n// result of experimentation with a new way to render highly distorted geometry\n// it is about temporal frame blending with ray shooting at random distance each frame\n// the shape is a repetition of folded and randomly twisted cylinders\n// frame buffer keeps the brightest color\n\n// geometry look\nconst float size = 0.01;\nconst float range = 0.2;\nconst float twist = 2.;\nconst float falloff = 1.6;\nconst float blend = 0.2;\n\n// how much we should distord space time\nconst float stretch = 1.9;\n\n// geometry count\nconst int count = 8;\n\n// delay between transition\nconst float delay = 10.0;\n\n// frame decay\nconst float decay = 0.001;\n\n// colors\nconst float colorMaterial = 0.1;\nconst float colorDistance = 1.5;\nconst float colorDot = -1.5;\nconst float colorOffset = -0.5;\nconst float saturation = .5;\n\n// distances\nconst float distanceFade = 5.0;\nconst float rayRange = 10.0;\n\n// camera\nconst float cameraDistance = 4.0;\nconst float fieldOfView = 8.5;\n\n// constant\nconst float pi = 3.14;\nconst float epsilon = 0.001;\n\n// globals\nfloat rng;\nfloat material;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    // init distance field\n    float scene = 1000.0;\n    float shape = 1000.0;\n    \n    // init amplitude of transform falloff\n    float a = 1.0;\n    \n    // thickness\n    float w = pow(sin(rng*pi), .2);\n    \n    // offset rotation every seconds\n    float change = floor(iTime/delay);\n    \n    // reset material\n    material = 0.0;\n    for (int index = 0; index < count; ++index)\n    {\n        // rotate\n        p.xy *= rot(rng * stretch / a + (twist + change) / a);\n        \n        // fold\n        p.x = abs(p.x) - range*a;\n        \n        // shape\n        shape = length(p.xy)-size*a*w;\n        \n        // material blending\n        float k = smoothing(scene, shape, blend*a);\n        material = mix(float(index), material, k);\n        \n        // geometry blending\n        scene = smin(scene, shape, blend*a);\n        \n        // transform falloff\n        a /= falloff;\n    }\n\n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0);\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,cameraDistance);\n    vec3 ray = normalize(vec3(uv, -fieldOfView));\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n\n    // ray shooting\n    vec3 pos = eye + ray * rayRange * rng;\n\n    // volume estimation\n    float dist = map(pos);\n    if (dist < epsilon)\n    {\n        // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n        vec2 off=vec2(epsilon,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n        // distance from origin\n        float d = length(pos);\n\n        // color palette by Inigo Quilez (https://iquilezles.org/articles/palettes)\n        float c = material*colorMaterial + d*colorDistance + colorOffset + colorDot*dot(normal, vec3(1,0,0));\n        vec3 tint = vec3(0.5)+vec3(0.5)*cos(vec3(1,2,3)+c);\n\n        // fade colors\n        color = mix(vec3(1), tint, saturation);\n\n        // distance shading\n        color *= smoothstep(distanceFade, 0., d);\n    }\n    \n    // frame buffer\n    vec4 frame = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    // fade in fade out animation\n    frame *= pow(sin(fract(iTime/delay)*pi), 0.005);\n    \n    // temporal frame blending\n    fragColor = max(frame-decay, vec4(color, 1));\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 29, 86, 119, 183]], "test": "untested"}
{"id": "NstGDs", "name": "programmed ufo", "author": "jorge2017a1", "description": "programmed ufo", "tags": ["programmedufo"], "likes": 4, "viewed": 217, "published": 3, "date": "1630889762", "time_retrieved": "2024-07-30T19:03:00.314156", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n\n //programmed ufo--2-sep-2021\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec3 moverObj(vec3 p, vec3 p1, vec3 p2,float tInc, float tA ,float tB)\n{   vec3 pres=p1;\n    if (tInc<tA) pres=p;\n        \n    if (tInc>=tA && tInc<tB)\n    { pres.x=mix(p1.x, p2.x, smoothstep(tA, tB,tInc));\n      pres.y=mix(p1.y, p2.y, smoothstep(tA, tB,tInc));\n      pres.z=mix(p1.z, p2.z, smoothstep(tA, tB,tInc));\n      pres=p-pres;\n    }\n    \n    if (tInc>tB)  pres=p-p2;\n    \n    return pres;\n}\n\n\nvec3 Nave(vec3 p)\n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdcy1= sdCylinderXZ( p, vec2(5.0,0.25) );\n    float sdcy2= sdCylinderXZ( p-vec3(0.0,0.25,.0), vec2(5.0,0.15) );\n    float sds1= sdSphere(p-vec3(0.0,1.0,0.0), 1.0 );\n    res =opU3(res, vec3(sdcy1,3.0,-1.0));\n    res =opU3(res, vec3(sdcy2,1.0,-1.0));\n    res =opU3(res, vec3(sds1,1.0,-1.0));\n    \n    return res;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,100.0,-1.0)); //inf\n   \n    p.y=p.y-5.0;\n    \n    vec3 p1=vec3(0.0,.0,.0);\n    vec3 p2=vec3(15.0,0.0,.0);\n    vec3 p3=vec3(15.0,10.0,.0);\n    vec3 p4=vec3(15.0,10.0,30.0);\n    vec3 p5=vec3(30.0,10.0,60.0);\n    \n    float sds1= sdSphere(p, 1.0 );\n    \n    //float vel=2.5+abs(sin(iTime*0.25));\n    float vel=5.0;\n    float timeMov=mod(iTime*vel,30.0);\n    \n    vec3 pnew1=moverObj( p, p1, p2,timeMov,1.0, 5.0);\n    vec3 pnew2=moverObj( p, p2, p3,timeMov,5.0, 10.0);\n    vec3 pnew3=moverObj( p, p3, p4,timeMov,10.0, 20.0);\n    vec3 pnew4=moverObj( p, p4, p5,timeMov,20.0, 30.0);\n    \n    vec3 sdres;\n     if (timeMov<5.0)\n        sdres= Nave(pnew1);\n    else if(timeMov<10.0)\n        sdres= Nave(pnew2);\n    else if(timeMov<20.0)\n        sdres= Nave(pnew3);\n    else if(timeMov<30.0)\n        sdres= Nave(pnew4);\n     \n        \n \n    res =opU3(res, sdres);\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n  \n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(8.0,7.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 548, 548, 569], [570, 570, 609, 609, 704], [705, 705, 744, 744, 839], [840, 840, 879, 879, 974], [976, 1016, 1050, 1050, 1145], [1148, 1148, 1220, 1220, 1547], [1550, 1550, 1569, 1569, 1927], [1928, 1968, 1993, 1993, 2997], [2999, 3050, 3074, 3074, 3236], [3238, 3238, 3287, 3287, 3923], [3925, 4012, 4048, 4048, 4293], [4294, 4349, 4376, 4376, 4393], [4395, 4395, 4431, 4431, 4523], [4524, 4524, 4570, 4570, 4695], [4697, 4697, 4771, 4771, 6372], [6373, 6428, 6477, 6477, 6716], [6717, 6751, 6831, 6831, 6954], [6997, 6997, 7029, 7029, 7226], [7228, 7276, 7304, 7304, 7492], [7494, 7545, 7592, 7592, 7839], [7841, 7893, 7986, 7986, 8474], [8477, 8477, 8508, 8508, 9112], [9114, 9163, 9189, 9189, 9299], [9301, 9301, 9359, 9359, 9411], [9413, 9462, 9519, 9519, 10065]], "test": "untested"}
{"id": "fddGDs", "name": "Evenly Spaced Points on QBezier", "author": "oneshade", "description": "Neater arclength calculation than [url=https://www.shadertoy.com/view/NdfSDl]https://www.shadertoy.com/view/NdfSDl[/url] plus a solver for the inverse to allow getting positions at specific distances on the curve.", "tags": ["points", "quadraticbezier", "evenspacing"], "likes": 12, "viewed": 284, "published": 3, "date": "1630889701", "time_retrieved": "2024-07-30T19:03:01.432167", "image_code": "// Desmos graph: https://www.desmos.com/calculator/ley84rd52d\n\n// Comment this out and you will understand why this is useful :D\n#define REPARAMETRIZE\n\n// Computes the length between a starting (t1) and ending (t2) position on the curve\nfloat bezierArclength(in float t1, in float t2, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v; // -discriminant\n    vec2 t = (u * vec2(t1, t2) + v) / sqrt(dis);\n    vec2 y = asinh(t) + t * sqrt(t * t + 1.0);\n    return (y.y - y.x) * dis / pow(u, 1.5);\n}\n\n// Newton-Raphson solver for inverse arclength\n// Allows position things at precise distances along the curve\n// I attempted to optimize it but I might have missed something\n// I also might try approximating it differently, this is pretty expensive\nfloat bezierInvArclength(in float d, in vec2 a, in vec2 b, in vec2 c) {\n    // Precomputation\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    float sdis = sqrt(dis);\n    float disu = dis / u;\n    float k = dis / pow(u, 1.5);\n\n    // Subtract constant of integration\n    float y = v / sdis;\n    d += (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n\n    // Five iterations of Newton-Rapshon, might not need that many\n    float t = ((sqrt(disu + u * abs(d)) - sqrt(disu)) * sign(d) - v) / u; // Initial approximation\n    for (int n=0; n < 5; n++) {\n        float y = (u * t + v) / sdis;\n        float arclen = (asinh(y) + y * sqrt(y * y + 1.0)) * k; // Arclength\n        float arcint = 2.0 * sqrt((u * t + 2.0 * v) * t + w); // Arclength integrand\n        t -= (arclen - d) / arcint;\n    }\n\n    return t;\n}\n\n// ---------- Helper functions ----------\nvec3 hue2rgb(in float hue) {\n    return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    //return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// ---------- SDFs ----------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Returns vec2(shortest distance to the curve, parameter of the nearest position on the curve)\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec2 sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return vec2(length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        float d1 = dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x));\n        float d2 = dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y));\n        return d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 a = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 b = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 c = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n\n    // Draw the hull\n    drawSDF(sdLine(uv, a, b), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdLine(uv, b, c), vec3(1.0, 0.0, 0.0));\n\n    // Draw the bezier curve\n    vec2 bezClosest = sdBezier(uv, a, b, c);\n    float bezLength = bezierArclength(0.0, 1.0, a, b, c);\n    #ifdef REPARAMETRIZE\n    bezClosest.y = bezierArclength(0.0, bezClosest.y, a, b, c) / bezLength;\n    #endif\n    drawSDF(bezClosest.x - 0.05, hue2rgb(bezClosest.y));\n\n    // Draw the control points\n    drawSDF(length(uv - a) - 0.02, vec3(1.0, 0.0, 0.0));\n    drawSDF(length(uv - b) - 0.02, vec3(1.0, 0.0, 0.0));\n    drawSDF(length(uv - c) - 0.02, vec3(1.0, 0.0, 0.0));\n\n    // Plot rotating stars at regular intervals\n    float co = cos(iTime), si = sin(iTime);\n    mat2 rot = mat2(co, si, -si, co);\n\n    float du = 1.0 / 5.0;\n    #ifdef REPARAMETRIZE\n    du *= bezLength;\n    #endif\n\n    for (float u=0.0; u < 6.0; u++) {\n        float t = u * du;\n        #ifdef REPARAMETRIZE\n        t = bezierInvArclength(t, a, b, c);\n        #endif\n        vec2 pos = mix(mix(a, b, t), mix(b, c, t), t);\n\n        mat2 starRot = rot;\n        if (int(u) % 2 == 0) starRot = transpose(starRot); // Alternate rotation direction\n\n        drawSDF(sdStar5((uv - pos) * starRot, 0.05, 0.5), vec3(0.25, 0.0, 0.5));\n    }\n\n    // Display coordinates of A on the left\n    drawChar(color, vec3(0.0, 0.0, 1.0), uv, vec2(-1.1, -0.58), vec2(0.15), 65);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(1.2, 0.6), 100.0, a.x);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(1.2, 0.75), 100.0, a.y);\n\n    // Display coordinates of B in the middle\n    drawChar(color, vec3(0.0, 0.0, 1.0), uv, vec2(0.0, -0.58), vec2(0.15), 66);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(0.3, 0.6), 100.0, b.x);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(0.3, 0.75), 100.0, b.y);\n\n    // Display coordinates of C on the right\n    drawChar(color, vec3(0.0, 0.0, 1.0), uv, vec2(1.1, -0.58), vec2(0.15), 67);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(-0.6, 0.6), 100.0, c.x);\n    color = digitIn(color, vec3(1.0), uv * 0.8 + vec2(-0.6, 0.75), 100.0, c.y);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Handy debugging font by @valalalalala (with my nitpicky formatting :D)\n// Thanks!\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "// UI handling\n// https://www.shadertoy.com/view/fsGGRR (thanks @dysangel!)\n#define SELECTION_RADIUS 0.1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 otherFragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor.xy = vec2(-0.5, 0.25);\n        if (iFragCoord == ivec2(1, 0)) fragColor.xy = vec2(0.6, 0.5);\n        if (iFragCoord == ivec2(2, 0)) fragColor.xy = vec2(0.5, -0.3);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < 3 && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            \n            if (iMouse.w > 0.0) {\n                fragColor.z = 0.0;\n            }\n\n            if (fragColor.z > 0.0 || length(mouse - fragColor.xy) < SELECTION_RADIUS * (fragColor.z + 1.0)) {\n                bool tooClose = false;\n\n                for (int i = 0; i < 3; i++) {\n                    otherFragColor = texelFetch(iChannel0, ivec2(i, 0), 0);\n                    if ((iFragCoord != ivec2(i,0)) && length(mouse - otherFragColor.xy) < SELECTION_RADIUS) {\n                        tooClose = true;\n                        fragColor.z = 0.;\n                    }\n                }\n\n                if (!tooClose) {\n                    fragColor.xy = mouse;\n                    fragColor.z = 1.0;\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 237, 319, 319, 648], [650, 899, 970, 992, 1820], [1822, 1864, 1892, 1892, 2228], [2230, 2308, 2411, 2411, 2676], [2678, 2759, 2810, 2810, 3221], [3223, 3319, 3342, 3342, 3362], [3363, 3363, 3425, 3425, 4688], [4690, 4690, 4737, 4737, 4845], [4927, 4927, 4982, 4982, 7524]], "test": "untested"}
{"id": "Ndt3Wl", "name": "Ray-Circle Refraction Experiment", "author": "Yusef28", "description": "Mouse Enabled\n", "tags": ["ad", "autodiff", "autodiff", "automaticdifferentiation", "dualnumbers", "autodifferentiation", "dn"], "likes": 6, "viewed": 299, "published": 3, "date": "1630872751", "time_retrieved": "2024-07-30T19:03:02.523250", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 05-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Ray-Circle Refractions                           //\n// Sources:                                                //\n// https://rootllama.wordpress.com/2014/06/20/ray-         //\n//                  line-segment-intersection-test-in-2d/  //\n// Listening to: Fallen Beats                              //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\n\nI don't follow the proper ray-segment intersection actually\nthe goal of this is to become more familiar with ray tracing\narchitecture so I've just taken an intersection model\nI had laying around and added a proper(and basic) ray-trace \narchitecture to it. \n\nWhat I really want eventually is:\nhttps://www.shadertoy.com/view/WsBGRz\nor\nhttps://www.shadertoy.com/view/ltXBz7\n\nThe main hiccups here ended up being such small things\nlike the normal being flipped the wrong way\nand well I was drawing some things I didn't need to be \nit's when it came to adding more bounces that things\nfell apart and I was forced to question my assumptions\nabout what I had written.\n\n\nArchitecturial features/functions:\n\n- time and animation \n- draw ray\n- draw intersection point\n- scene intersections\n- bounces\n- ray trace\n- segment structure\n\nAdjustables in Common Tab:\n\n- number of rays\n- number of bounces (good with more objects)\n- number of segments (if you wan to add more segments you need\n- index_of_refraction \nto increase this before adding them to segmentList)\n\nPossible expansions:\n\n- materials(refractions/diffuse/lambert/roughness)\n- more objects (triangle, AABB, circle, ellipse)\n- movement (I'd love to make the segments rotate for starters)\n\nI definitly feel like programming the architecture\nis a different mindset from doing the math (intersections \nfor example). I might want to work on only one of these\naspects in any given coding session. Not sure.\n\n*/\n//objects //global hit list, just two points for one line\n\nstruct Segment{\n    vec2 A;\n    vec2 B;\n    int id;\n};\n\nstruct Circle{\n    vec2 pos;\n    float r;\n    vec3 col;\n    int id;\n};\n\nSegment segmentList[] = Segment[Seg_N](\n    Segment(vec2(3., -3.),vec2(4., 3.), 0),\n    Segment(vec2(-5., -3.),vec2(-3., 3.), 1)\n);\n\nCircle CircleList[] = Circle[Circle_N](\n    Circle(vec2(0.,0.), 3., vec3(1.), 0),\n    Circle(vec2(0.), 1., vec3(1.,.3,.3), 1)\n);\n\nvec3 background_grid(vec2 st, vec2 uv){\n    vec3 col = vec3(0.1);;\n     col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    return col;\n\n}\n\nvec2 time_and_animation(){\n\n    float speed = 1.;\n    float time = 20.;//clamp(abs(fract(iTime*speed-0.5)-0.5)*2.,0.1,1.)*12.;\n\n    return vec2(time,0.);\n    }\n    \nvec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){\n\n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    return col;\n}\n\nvec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){\n\n    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    return col;\n}\n\nfloat inside_circle = 0.;\nfloat iSphere(vec2 ro, vec2 rd, vec2 cPos, float r){\n\n    vec2 O_C = ro-cPos;\n    \n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,O_C);\n    float c = dot(O_C,O_C) - r*r;\n    \n    float disc = b*b-4.*a*c;\n    \n    if(disc < 0.) return -1.;\n  \n\n    float t1 = (-b - sqrt(disc))/(2.*a); \n    float t2 = (-b + sqrt(disc))/(2.*a);\n    \n    inside_circle = t1 < 0. && t2 > 0. ? 1. : 0.; \n    \n    if(t1 >= 0.){return t1;}\n    else if(t2 >= 0.){return t2;}\n    else return -1.;\n}\n\nvec2 circle_intersections(vec2 ro, vec2 rd){\n\n    float min_t = 1000.;\n    float t;\n    float idf = -1.;\n    \n    for(int i = 0; i < 1; i++){\n        \n        t = iSphere(ro, rd, CircleList[i].pos, CircleList[i].r);\n        \n        if(t < min_t){\n        \n            min_t = t;\n            idf = float(i);\n            \n        } \n    }\n    \n    return vec2(t, idf);\n}\n\n\n\nvec3 bounces(vec2 bounce_ro, vec2 rd, float time, vec2 uv, vec3 col){\n\n    vec3 ray_color = line1Col + vec3(bounce_ro.y,0.,0.)/2.;\n    for(float j = 0.; j < float(BOUNCE_N); j++){\n        \n            //time instead of t_and_a.y!\n            \n            vec2 A1 = bounce_ro;\n            vec2 B1 = bounce_ro + rd*time;\n            \n            //check all objects (just one line here)\n            int id = -1;\n            \n            vec2 ct_and_id = circle_intersections(bounce_ro,rd);\n            float ct = ct_and_id.x;\n            id = int(ct_and_id.y);\n            \n\n            \n            if(ct > 0.){\n\n                \n                //new ro is hit point\n                bounce_ro = bounce_ro + rd*ct;//s_t_iPoint.zw;\n                \n                //normal is orthogonal to the line facing left\n                vec2 n = normalize(bounce_ro - CircleList[id].pos);//normalize(vec2( -(segB.y-segA.y), segB.x-segA.x ));\n                \n                //a good couple of hours spent here\n                //until I decided to just show the normals \n                //which I should have done from the start\n              //  if(dot(n, rd) <= 0.){\n                  ///  n = -n;\n                //}\n                \n                n = inside_circle == 1. ? -n : n;\n                //reflected rd is...\n                /*\n                rd = j == 1.             ? \n                    refract(rd, n, 1.45) :\n                    refract(rd, n, 1.45) ;\n                    */\n                \n                rd = inside_circle == 1. ? \n                    refract(rd, n, index_of_refraction) :\n                    refract(rd, n, 1./index_of_refraction);\n                \n                if(length(rd) == 0.)rd = reflect(rd,n);\n                //use the same \"time\" variable to go back along the reflected ray\n                //vec2 reflected_a = bounce_ro;\n                //vec2 reflected_b = bounce_ro + rd*time;\n                \n                //draw the ray to the hit point\n                //col = draw_ray(A1, bounce_ro, col, uv);\n                float f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(A1, bounce_ro, uv)));\n                \n                col = mix(col, ray_color, f);\n                \n                //draw normal\n                f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(bounce_ro,bounce_ro + n*0.5, uv)));\n                \n                col = mix(col, vec3(0.,1.,0.5), f);\n                \n                col = draw_iPoint(col, bounce_ro, uv);\n   \n                //this is so important!!!\n                bounce_ro -= n*0.01;\n                ray_color = 0.5+0.5*cos(vec3(bounce_ro.y,2.,1.)/1. + j*300.);\n            }\n            \n            else{\n            //draw the ray \n            //col = draw_ray(A1, B1, col, uv);\n            \n            float f = 1.0-smoothstep(0.02, 0.06,\n            abs(distToLine(A1, B1, uv)));\n            col = mix(col, ray_color, f);\n            \n            break;\n            }\n            \n    }\n    \n    return col;\n}\nvec3 ray_trace(vec2 uv, vec2 ro, vec3 col){\n    \n    vec2 t_and_a = time_and_animation();\n    //rays\n    for(float i = 0.; i<fov; i += fov/float(RAY_N)){\n    \n        vec2 rd = vec2(1.,0.);//*rot(i-pi*sin(iTime/6.));\n        vec2 bounce_ro = ro + vec2(0., i*5.);\n        //bounces\n        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);\n        }\n        \n    \n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = background_grid(st, uv);\n    \n    CircleList[0].pos = vec2(cos(iTime), sin(iTime));\n    \n    if(iMouse.z > 0.5) \n        CircleList[0].pos = vec2((iMouse.xy-iResolution.xy*0.5)/iResolution.y)*8.;\n    \n    \n    \n   float f;\n   \n   for(int i = 0; i < 1; i++){\n       f = clamp(1.0-abs(length(uv - CircleList[i].pos)-CircleList[i].r),0.,1.);\n       f = smoothstep(0.9,0.95,f);\n       col = mix(col, vec3(1.), f);\n   }\n   \n   vec2 ro = vec2(-13, -3.);\n       \n   \n   //\n   col = ray_trace(uv, ro, col);\n\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    //Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [], "common_code": "#define pi 3.14159265\n#define RAY_N 44\n#define BOUNCE_N  3\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n#define Seg_N 2\n#define Circle_N 2\n#define fov pi*0.37\n\n#define index_of_refraction 1.45\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\nmat2 rot(float a){\n\n    \n    float si = sin(a);\n    float cs = cos(a);\n    return mat2(cs,-si,si,cs);\n   }   \n    \nmat2 trigless_rot(vec2 v, vec2 vr){\n    float si = length(cross(vec3(v,0.),vec3(vr,0.)));\n    float cs = dot(v,vr);\n    return mat2(cs,-si,si,cs);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2655, 2655, 2694, 2694, 3542], [3544, 3544, 3570, 3570, 3703], [3709, 3709, 3760, 3774, 4141], [4143, 4143, 4197, 4197, 4432], [4460, 4460, 4512, 4512, 4935], [4937, 4937, 4981, 4981, 5306], [5310, 5310, 5379, 5379, 8341], [8342, 8342, 8385, 8385, 8727], [8728, 8728, 8784, 8836, 10386]], "test": "untested"}
{"id": "7sc3Ws", "name": "Swarm of Brushes", "author": "pali6", "description": "A swarm of brushes trying to replicate a picture.\nError in the reproduction is computed per pixel and blurred, brushes steer based on the gradient of this blurred error.\nbuf A = blurred error\nbuf B = painted image\nbuf C = brush data\nbuf D = original image", "tags": ["particles", "art", "swarm"], "likes": 2, "viewed": 342, "published": 3, "date": "1630861653", "time_retrieved": "2024-07-30T19:03:03.297181", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / RES;\n    fragColor = abs(texture(iChannel0, uv));\n    \n    // uncomment to see brushes more clearly as red dots\n    /*\n    vec4 col = texture(iChannel0, uv);\n    for(int i = 1; i <= N; i++)\n    {\n        vec2 bPos = texture(iChannel1, vec2(i, 0) / RES).xy;\n        if(length((uv - bPos) * RES) < BRUSH_SIZE)\n        {\n            col = vec4(1,0,0,1);\n        }\n    }\n    \n    fragColor = col;\n    */\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DIST 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / RES;\n    if(iFrame <= 30)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    float a = texture(iChannel0, uv).x;\n    float error = length(texture(iChannel1, uv) - texture(iChannel2, uv));\n    float p = 0.9;\n    a = a * p + error * (1. - p);\n    float nei = 0.;\n    float s = 0.;\n    for(int dx = -DIST; dx <= DIST; dx++)\n    {    \n        for(int dy = -DIST; dy <= DIST; dy++)\n        {\n            nei += 1. / (length(vec2(dx, dy)) + 1.) * texture(iChannel0, (fragCoord + vec2(dx, dy)) / RES).x;\n            s += 1. / (length(vec2(dx, dy)) + 1.);\n        }\n    }\n    float p2 = 0.005;\n    a = p2 * a + (1. - p2) * (nei / s);\n    fragColor = vec4(a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 S = vec2(iDate.w + iDate.y, iDate.w + iDate.z);\n    vec2 uv = fragCoord / RES;\n    if(iFrame <= 30)\n    {\n        if(fragCoord.x <= float(N) + 0.1 && fragCoord.y <= 1.1)\n        {\n            fragColor = vec4(rand(fragCoord + S), rand(fragCoord + vec2(0, 1) + S), 0, 0);\n        }\n        else if(fragCoord.x <= float(N) + 0.1 && fragCoord.y <= 2.1)\n        {\n            fragColor = vec4(rand(fragCoord + S) * 2. - 1., rand(fragCoord + vec2(0, 1) + S) * 2. - 1., 0, 0);\n            fragColor.xy = normalize(fragColor.xy);\n        }\n        else if(fragCoord.x <= float(N) + 0.1 && fragCoord.y <= 3.1)\n        {\n            fragColor = vec4(\n                rand(fragCoord + S),\n                rand(fragCoord + vec2(0, 1) + S),\n                rand(fragCoord + vec2(0, 2) + S),\n                0\n            );\n        }\n        else\n            fragColor = vec4(0);\n        return;\n    }\n    if(fragCoord.x > float(N))\n        return;\n    vec2 pos = texture(iChannel0, vec2(fragCoord.x, 1) / RES).xy;\n    vec2 vel = texture(iChannel0, vec2(fragCoord.x, 2) / RES).xy;\n    vec3 col = texture(iChannel0, vec2(fragCoord.x, 3) / RES).rgb;\n    if(fragCoord.y <= 1.1)\n    {\n        pos += vel * SPEED;\n        pos.x = clamp(pos.x, 0., 1.);\n        pos.y = clamp(pos.y, 0., 1.);\n        fragColor = vec4(pos, 0, 0);\n    }\n    else if(fragCoord.y <= 2.1)\n    {\n        if(pos.x >= 1.)\n            vel.x -= 0.5;\n        if(pos.x <= 0.)\n            vel.x += 0.5;\n        if(pos.y >= 1.)\n            vel.y -= 0.5;\n        if(pos.y <= 0.)\n            vel.y += 0.5;\n        float d = 1.;\n        vec2 gr = vec2(\n            texture(iChannel1, pos + vec2(d, 0) / RES).x - texture(iChannel1, pos - vec2(d, 0) / RES).x,\n            texture(iChannel1, pos + vec2(0, d) / RES).x - texture(iChannel1, pos - vec2(0, d) / RES).x\n        );\n        gr = normalize(gr);\n        vel = vel * (1. - TURNING) + gr * TURNING;\n        vel = normalize(vel);\n        fragColor = vec4(vel, 0, 0);\n    }\n    else if(fragCoord.y <= 3.1)\n    {\n        col = col * (1. - COLOR_CHANGING) + texture(iChannel2, pos).rgb * COLOR_CHANGING;\n        fragColor = vec4(col, 1);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// this is where the drawing process happens\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / RES;\n    if(iFrame <= 30)\n    {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    vec4 col = texture(iChannel0, uv);\n    for(int i = 1; i <= N; i++)\n    {\n        vec2 bPos = texture(iChannel1, vec2(i, 0) / RES).xy;\n        vec3 bCol = texture(iChannel1, vec2(i, 2.9) / RES).rgb;\n        if(length((uv - bPos) * RES)  < BRUSH_SIZE)\n        {\n            float mul = 0.02;\n            vec4 target = vec4(bCol, 1);\n            col = (col + target * mul) / (1. + mul); \n        }\n    }\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 30\n#define BRUSH_SIZE (1. + 19. * exp(-iTime / 200.))\n#define SPEED (0.001 + 0.004 * exp(-iTime / 200.))\n#define TURNING (0.07 + (1. - exp(-iTime / 200.)) * 0.08)\n#define COLOR_CHANGING (0.02 + (1. - exp(-iTime / 200.)) * 0.08)\n\n#define RES iResolution.xy", "buffer_d_code": "// buffer D is just for convenience and contains the image being reproduced\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / RES;\n    fragColor = texture(iChannel0, uv);\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 485]], "test": "untested"}
{"id": "7d3GWl", "name": "Barbarella's Lava Lamp", "author": "xenn", "description": "Wouldn't be out of place in her ship", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 20, "viewed": 780, "published": 3, "date": "1630844851", "time_retrieved": "2024-07-30T19:03:04.594712", "image_code": "\n// Fork of \"Cloud Mandala 2.0\" by xenn. https://shadertoy.com/view/Nsc3Wl\n// 2021-09-05 12:05:15\n\n\n\n#define lenSq(x) dot(x,x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    float colorScale = 6.0 / iResolution.y;\n    \n    vec2 pixelStep = 3.0 / iResolution.xy;\n    \n    vec3 center = texture( iChannel0, coord ).xyz;\n    vec3 top = texture( iChannel0, coord + vec2( .0, pixelStep.y ) ).xyz;\n    vec3 right = texture( iChannel0, coord + vec2( pixelStep.x, .0 ) ).xyz;\n    \n    float sobelThreshold = .25;\n    \n    float tvVignette = 1.0 - 1.5 * lenSq( coord - vec2( .5, .5 ) );\n    tvVignette *=  .9 + .1 * sin( 2.0 * fragCoord.y );\n    \n    fragColor = vec4(\n        tvVignette * texture( iChannel1, coord * ( 1.0 - colorScale )).r,\n        tvVignette * texture( iChannel1, coord ).g, \n        tvVignette * texture( iChannel1, coord * ( 1.0 + colorScale )).b,\n        1.0 );\n    if( lenSq( center - top ) > sobelThreshold || lenSq( center - right ) > sobelThreshold)\n    {\n        fragColor *= vec4( .25, .25, .25, 1.0 );\n\n    }\n    \n    \n    return;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"1. spacebaaals\" by julianlumia. https://shadertoy.com/view/WdByDG\n// 2021-07-24 15:02:41\n\n// Fork of \"lost in spacetime..\" by julianlumia. https://shadertoy.com/view/wlGSzm\n// 2020-04-18 14:32:19\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n//#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,1./.22);\n t *=2.;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = .2;\n float modd = 2.1;\n float sqD = max(abs(t.x), abs(t.y));\n sqD +=.5 + yid*0.4;\n float sqid = floor(sqD/modd);\n sqD = lmod(sqD, modd);  \n d = min(d, sqD);\n o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*10.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n float dp = dot(p,p)*.5;\n p /= dp;\n// p.xz*= Rot(cos(iTime*0.5));\n// p.xy *=  Rot(cos(iTime*1.-0.2));\n// p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((sin(iTime*.1)));\n vec3 q = (text(p.xz, p)).xyz;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d =vec2(0.);\n vec3 q = p;\n float dp = dot(p,p)*.1;\n p /= dp;\n //p.xz*= Rot(cos(iTime*0.5));\n //p.xy *=  Rot(cos(iTime*1.-0.2));\n //p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n d = vec2(sdBox(p,vec3(1.)) + sdBox(q,vec3(0.0)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/10.));\n g1 +=1./(.018+pow(abs(d.x),1.));\n d = condmin( d,d);\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<100; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<SURF_DIST||t.x>MAX_DIST) break;\n  t.x+=h.x;t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n// vec3 lightPos = vec3(sin(iTime)*2., cos(iTime)*2., 3);\n     vec3 lightPos = vec3(0.,0.,.0);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(0, 0, 1.1);\n// ro.xy *= Rot(sin(iTime*.1)*6.2831);\n// ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,.0,0), 1.2);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n  if(d.y==1.) col += tex3D(p,n)*5.;\n }\n col*=g1*vec3(.00005);  \n col+=g1*vec3(-.0001);  \n float fog = 4. / (1. + d.x * d.x *15.);\n col *= vec3(fog); \n col+=g1*vec3(.000003);  \n col*= 5.; \n fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .998;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = -0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .08;\nconst float iBlob1Radius              = .75;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .042;\nconst float iBlob2Radius              = .85;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .0234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = - .2;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = -.997;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact =0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .16;\nconst float iBlob1Radius              = .55;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .6;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 1.2;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.5);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 185, 185, 1114]], "test": "untested"}
{"id": "7sdGWj", "name": "Cube & Noise Experiment", "author": "byt3_m3chanic", "description": "Sometimes you step back from a shader and go - WHAT was I thinking? Some tricks in finite domain rep and noise. Bars are stationary and only move 1 rep - [mouse/able] - explore the noise!", "tags": ["cubicnoiseexperiment"], "likes": 11, "viewed": 362, "published": 3, "date": "1630822762", "time_retrieved": "2024-07-30T19:03:05.420503", "image_code": "/**\n\n    Cube & Noise Experiment / mouse-able\n    \n    Tricks in finite domain rep and noise. \n    Some motion tricks with the bars using fract(t) and the noise\n    vector jumping in time. Otherwise just starting to messa round.\n    \n    @byt3_m3chanic | 09/04/21\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .0001\n#define MAX_DIST 20.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n// @Shane - tightly compacted, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother alternative.\n    h = mix(fract(sin(h)*4378.5453), fract(sin(h + s.x)*4378.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n// @iq fbm generator\nfloat fbmd( in vec3 x, float oct ) {\n    const float scale  = .8;\n    float a = .0,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for( float i=0.; i<oct; i++ ) {      \n        float n = n3D(f*x*scale);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n// @iq sdf's\nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n// globals\nmat2 turn,pulse,ry;\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time,shs,ghs,mofs,mofx,ftm,otm;\n// consts\nconst float c = .4, c2=c/2.;\n\n// scene\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    vec3 f =p;\n    vec3 sf=f;\n    p+=vec3(0,ftm*c,0);\n    p.x=abs(p.x)-3.25;\n    p.xz*=ry;\n    f.x=abs(f.x)-3.25;\n    f.xz*=ry;\n    vec3 q = p;\n    vec3 id =floor((p-c2)/c);\n    float wd  = 11.;\n    float hgt = 15.;\n    q.x = q.x - c*clamp(round(q.x/c),-wd,wd);\n    q.y = q.y - c*clamp(round(q.y/c),-hgt,hgt);\n\n    float nz = fbmd((id*.055)+vec3(mofx,otm,mofs),4.);\n\n    // blocks\n    float sfct = c2*.75;\n    float d2 =  nz>.5 ? cap(q.yzx,c2*.7,sfct*.5) : box(q,vec3(sfct*1.28,sfct*.25,sfct*.5));\n    if(d2<res.x) {\n        res = vec2(d2,2.);\n    \thit=p;\n        ghs=nz;\n    }\n    \n    f.y=abs(f.y);\n    float d5 =  box(f-vec3(2.5,5.,2.5),vec3(7,.05,1.));\n    if(d5<res.x) {\n        res = vec2(d5,1.);\n    \thit=sf;\n    }  \n\n    sf.yz*=pulse;\n    sf.xz*=turn;\n    sf=abs(sf);\n    \n    float d8 =  octa(sf,3.5);\n    sf.xz*=ry;\n    d8 =  min(octa(sf,3.5),d8);\n    if(d8<res.x) {\n        res = vec2(d8,4.);\n    \thit=sf;\n    }  \n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    return .525 + .475*cos(PI2*t*(vec3(0.145,0.831,0.663)+vec3(0.847,0.667,0.933)) ); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    shs = ghs;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,3,9);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint+vec3(.0,0,.2);\n            hp.xz*=rot(.785312);\n            h = vec3(0.929,0.929,0.929);\n            vec2 f = fract(hp.xz*.74)-.5;\n            if(f.x*f.y>0.) h=vec3(0.090,0.090,0.090);\n            ref = vec3(.4)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=shs<.5?vec3(.05):hue(floor(shs*15.)*.05);\n            ref = vec3(0);\n        }\n        if(m==4.) {\n            h=vec3(.0);\n            ref = vec3(.25)-fresnel;\n        }\n        \n        C = diff*h+spec;\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    }else{\n        C = mix(vec3(0.059,0.059,0.059),hue(.34),(uv.y+.5)*.5);\n    } \n    \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nvoid overLay(inout vec3 C, vec2 uv, float d) {\n    float scl=40.;\n    float px = fwidth(uv.x);\n    vec2 id = floor(uv*scl);\n    vec2 grid=fract(uv*scl)-.5;\n    float hs = fbmd((id.xyx*.065)+vec3(mofx,T*.15,mofs),4.);\n    if((uv.x>0.7 && uv.x<.975 || uv.x<-.7 && uv.x>-.975 ) && (uv.y>-.4 &&uv.y<.4)) {\n        float b= (hs>.5) ? length(grid)-.35:box(grid,vec2(.35));\n        if(hs<.5)b=abs(b)-.05;\n        b=smoothstep(.05+px,-px,b);\n        C =mix(C,hs>.5? hue(.1-floor(hs*15.)*.05)+.2 :vec3(.035),b);\n    }\n    \n    float bs = length(uv)-.39;\n    bs=smoothstep(.3+px,-px,bs);\n    C=mix(C, C+.05,d*.05>1.?bs:0.);  \n    vec3 uclr = hue(23.);\n    \n    bs = length(uv)-.51;\n    bs=abs(abs(bs)-.015)-.005;\n    bs=smoothstep(px,-px,bs);\n    C=mix(C, uclr,d*.05>1.?bs*.75:0. );  \n\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) \n{\n    // precal / chew your vars!\n    mofx = (M.y/R.y)*2.;\n    mofs = (M.x/R.x)*2.;\n    \n    float my = M.xy==vec2(0) ? 0.2 : (2.*M.y-R.y)/R.y;\n    pulse = rot(my);\n    turn = rot(-T*30.*PI/180.);\n    ry =rot(.7851);\n    \n    ftm = fract(T);\n    otm = (((T*.35)-ftm/6.)*c);\n    //\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, 13.);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float alpha =1.;\n    for(float i=0.; i<2.; i++) {\n        d =0.;\n        C += render(ro, rd, ref, d, uv).rgb*fil;\n        fil*=ref;\n        if(i==0.) alpha+=d;\n    }\n\n    overLay(C,uv,alpha);\n    \n    C = mix(C,C+.035,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(.9));\n\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 423, 443, 443, 488], [489, 489, 513, 513, 571], [573, 660, 678, 678, 1023], [1024, 1045, 1081, 1081, 1315], [1316, 1329, 1367, 1367, 1474], [1475, 1475, 1509, 1509, 1589], [1590, 1590, 1618, 1618, 1705], [1706, 1706, 1735, 1735, 1788], [1939, 1948, 1966, 1966, 2942], [2944, 2944, 2974, 2974, 3213], [3215, 3262, 3280, 3280, 3370], [3372, 3372, 3455, 3455, 4987], [4989, 4989, 5035, 5035, 5766], [5768, 5768, 5810, 5842, 6645]], "test": "untested"}
{"id": "Nsc3Wl", "name": "Cloud Mandala 2.0", "author": "xenn", "description": "New and improved formula. now with a delicious smokey effect ", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 11, "viewed": 462, "published": 3, "date": "1630813026", "time_retrieved": "2024-07-30T19:03:06.558461", "image_code": "// Fork of \"cloud mandala\" by xenn. https://shadertoy.com/view/NdcGDM\n// 2021-09-05 03:32:09\n\n// Fork of \"photon mandala\" by xenn. https://shadertoy.com/view/fd3GDM\n// 2021-08-25 17:39:10\n\n// Fork of \"womandala blob\" by xenn. https://shadertoy.com/view/fs3GRM\n// 2021-08-25 16:46:55\n\n// Fork of \"womandala\" by xenn. https://shadertoy.com/view/fstGzN\n// 2021-08-18 21:37:44\n\n\n#define lenSq(x) dot(x,x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    float colorScale = 6.0 / iResolution.y;\n    \n    vec2 pixelStep = 3.0 / iResolution.xy;\n    \n    vec3 center = texture( iChannel0, coord ).xyz;\n    vec3 top = texture( iChannel0, coord + vec2( .0, pixelStep.y ) ).xyz;\n    vec3 right = texture( iChannel0, coord + vec2( pixelStep.x, .0 ) ).xyz;\n    \n    float sobelThreshold = .25;\n    \n    float tvVignette = 1.0 - 1.5 * lenSq( coord - vec2( .5, .5 ) );\n    tvVignette *=  .9 + .1 * sin( 2.0 * fragCoord.y );\n    \n    fragColor = vec4(\n        tvVignette * texture( iChannel1, coord * ( 1.0 - colorScale )).r,\n        tvVignette * texture( iChannel1, coord ).g, \n        tvVignette * texture( iChannel1, coord * ( 1.0 + colorScale )).b,\n        1.0 );\n    if( lenSq( center - top ) > sobelThreshold || lenSq( center - right ) > sobelThreshold)\n    {\n        fragColor *= vec4( .25, .25, .25, 1.0 );\n\n    }\n    \n    \n    return;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"1. spacebaaals\" by julianlumia. https://shadertoy.com/view/WdByDG\n// 2021-07-24 15:02:41\n\n// Fork of \"lost in spacetime..\" by julianlumia. https://shadertoy.com/view/wlGSzm\n// 2020-04-18 14:32:19\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n//#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,1./.22);\n t *=2.;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = .2;\n float modd = 2.1;\n float sqD = max(abs(t.x), abs(t.y));\n sqD +=.5 + yid*0.4;\n float sqid = floor(sqD/modd);\n sqD = lmod(sqD, modd);  \n d = min(d, sqD);\n o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*10.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n float dp = dot(p,p)*.5;\n p /= dp;\n// p.xz*= Rot(cos(iTime*0.5));\n// p.xy *=  Rot(cos(iTime*1.-0.2));\n// p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((sin(iTime*.1)));\n vec3 q = (text(p.xz, p)).xyz;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d =vec2(0.);\n vec3 q = p;\n float dp = dot(p,p)*.1;\n p /= dp;\n //p.xz*= Rot(cos(iTime*0.5));\n //p.xy *=  Rot(cos(iTime*1.-0.2));\n //p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n d = vec2(sdBox(p,vec3(1.)) + sdBox(q,vec3(0.0)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/10.));\n g1 +=1./(.018+pow(abs(d.x),1.));\n d = condmin( d,d);\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<100; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<SURF_DIST||t.x>MAX_DIST) break;\n  t.x+=h.x;t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n// vec3 lightPos = vec3(sin(iTime)*2., cos(iTime)*2., 3);\n     vec3 lightPos = vec3(0.,0.,.0);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(0, 0, 1.1);\n// ro.xy *= Rot(sin(iTime*.1)*6.2831);\n// ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,.0,0), 1.2);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n  if(d.y==1.) col += tex3D(p,n)*5.;\n }\n col*=g1*vec3(.00005);  \n col+=g1*vec3(-.0001);  \n float fog = 4. / (1. + d.x * d.x *15.);\n col *= vec3(fog); \n col+=g1*vec3(.000003);  \n col*= 5.; \n fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = -.998;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .08;\nconst float iBlob1Radius              = .5;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.04;\nconst float iBlob2Radius              = .25;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = -.0234;\nconst float iBlob2ColorPulseShift     = 0.5;\nconst float iColorShiftOfRadius       = .2;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = -.997;\nconst float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact =0.0015;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .16;\nconst float iBlob1Radius              = .95;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .75;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.5;\nconst float iColorShiftOfRadius       = .2;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col2,col,0.5);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 459, 459, 1388]], "test": "untested"}
{"id": "NscGWl", "name": "Glacial valleys", "author": "jarble", "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 20, "viewed": 750, "published": 3, "date": "1630808591", "time_retrieved": "2024-07-30T19:03:07.420157", "image_code": "#define SC (250.0)\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nvec2 fluid(vec2 uv){\n //add some turbulence\n //uv /=2.;\n //return vec2(sin(uv.x),cos(uv.y))/2.;\n \n \n //decrease this number to increase the turbulence of erosion\n float turbulence = 5.;\n //float t1 = turbulence*turbulence;\n \n //uv *= turbulence;\n //vec2 uv1 = uv/t1;\n \n vec2 result = uv;\n \n //more height variation\n //uv *= (1.+(sin(uv.x/128.)+cos(uv.y/128.))/128.);\n\n \n for (float i = 1.; i < 3.; i += 1.)\n  {\n    float s2 = (sin(uv.x*i))/turbulence;\n    uv.y += s2;\n    float s1 = cos(uv.y*i)/turbulence;\n    uv.x += s1;\n    uv=uv.yx;\n  }\n  return (uv-result).yx;\n}\n\n\n#define OCTAVES 8\nvec3 fbm0(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    //uv *= .75;\n    float value = 0.;\n    float amplitude = .75,n2=0.;\n    //amplitude /= 16.;\n    vec2 n1 = vec2(0.);\n    \n    //rotate 45 degrees\n    //mat2 r = rotate2D(0.785398);\n    \n    float terrain_scale = 1.;\n    uv *= terrain_scale;\n    vec2 uv1 = uv;\n    uv += uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        vec2 f1 = fluid(uv).yx;\n        //domain warping\n        uv += f1;\n        \n        n1 =\n            //vec2(sin(uv.x+cos(uv.y*.37)/.37),cos(uv.y+sin(uv.x*.37)/.37))\n            //vec2(sin(uv.x-n1.y*value),cos(uv.y-n1.x*value))\n            //vec2(sin(uv.x),cos(uv.y))\n            //vec2(sin(uv.x),cos(uv.y))*r //badlands\n            //(vec2(sin(uv.x),cos(uv.y))+n1)/2.\n            //(n1+abs(n1-vec2(sin(uv.x),cos(uv.y))))/2.\n            f1\n        ;\n        uv1 = uv;\n        n2 =\n            n1.x+n1.y\n            //((n1.x+n1.y)-n2)\n            //n1.x+n1.y+n2*.37\n        ;\n        value -=\n            abs(n2)*amplitude\n            //abs(n2-value) * amplitude\n        ;\n        \n        //waves\n        //value += sin(uv.x/1000.+iTime)/10.;\n        \n        //erosion\n        value = sqrt(value*value+.0001);\n        \n        amplitude *= .37;\n        \n        //This makes it somewhat more realistic\n        //amplitude *= (1.+sin(uv.x/4.)/4.);\n\n        //uv *= uv*2.05*r+vec2(0.,n2);\n        uv += uv;\n        \n        //r = rotate2D(12.+(n2)*value/8.);\n    }\n    \n    return vec3(value/terrain_scale,uv);\n}\n\nfloat fbm(vec2 uv,int octaves){\n    return fbm0(uv,octaves).x;\n}\n\n/*\nfloat fbm(in vec2 uv,int octaves){\nuv /= 32.;\n  vec3 col = vec3(0);\n  for(int k = 0; k < 12; k++){\n        //another interesting variant:\n        //if(uv.y>uv.x) uv = uv.yx;\n        vec2 offset =\n            vec2(uv.x,-uv.y)*1.5\n            //vec2(mod(uv.x*2.-.5,2.),mod(uv.y,2.)*2.)\n            //vec2(mod(uv.x*2.,2.),sign(uv.x-uv.y)*mod(uv.y,2.)*2.)\n        ;\n        uv = abs(fract(uv.yx-offset)-.5);\n        if(uv.y < uv.x) uv /= 1.5;\n        //else uv /= 2.;\n    }\n    return uv.x/8.;\n}\n*/\n\n\n//a more realistic terrain\nfloat fbm1(in vec2 uv,int octaves){\n    uv *= .8;\n    return fbm(uv*2.,octaves)/2.+fbm(uv,octaves);\n}\n\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n\n    //TODO: use the local minimum in the previous frame to accelerate raymarching in the next frame\n    //vec2 prev = vec2(0.);\n    \n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n        //if(prev.y<h && prev.y<prev.x) return t; //this is the local minimum\n\t\tif( abs(h) < (0.0015 * t) || t > tMax) \n            break;\n\t\t//prev = vec2(prev.y,h);\n        t += 0.4 * h;\n\t}\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime/2.+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    //rd.yx *= rot(0.785398/4.);\n    //rd.xz *= rot(1.5*0.785398);\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0-iTime/4.);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/flcBz7\n\nfloat fmod(float a, float b){\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n    }\n    return mod(floor(a+floor(a/8./8./2.)),b);\n}\n\nvec2 mainSound(int samp, float time){\n  float\n  m1 = fmod(time*8.,8.),\n  t = time*2.*(1.+fmod(time/4.,2.)),\n  a= (1.-log(1./8./8.+fract(t)/8./2.)/2.)*(1.-log(1./8./8.+fract(t/8.)/2.)/2.),\n  nb = time*pow(2.,floor(((fmod(m1,abs(16.-m1)+1.)-m1)+1. + fmod(t,8.))/2.)/5.+7.5);\n  return\n      log(1./8./8.+(a*abs(1./8.-.5*abs(.5-vec2(fract(nb/2.*.998),fract(nb))))))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 44, 96], [99, 99, 119, 260, 666], [687, 687, 722, 788, 2211], [2213, 2213, 2244, 2244, 2277], [2779, 2806, 2841, 2841, 2907], [2910, 2910, 2932, 2932, 2962], [2964, 2964, 2994, 2994, 3044], [3046, 3046, 3066, 3066, 3113], [3115, 3115, 3148, 3148, 3342], [3344, 3344, 3411, 3540, 3872], [4246, 4246, 4298, 4298, 4843], [4845, 4845, 4896, 4896, 5097], [5099, 5099, 5125, 5125, 5201], [5269, 5269, 5326, 5326, 7370]], "test": "untested"}
{"id": "7sdGWf", "name": "powerpuff heart", "author": "charstiles", "description": "made this really quickly for my friends birthday card, \nbasically all credited barrowed stuff, heart equation is from iq comment https://www.shadertoy.com/view/XdcyW8\ncould be better, but im just throwing this up ", "tags": ["sdf", "heart", "powerpuff"], "likes": 1, "viewed": 254, "published": 3, "date": "1630796764", "time_retrieved": "2024-07-30T19:03:08.183117", "image_code": "\n\n// https://iquilezles.org/articles/palettes \nvec3 cosPalette( float t , vec3 brightness, vec3 contrast, vec3 osc, vec3 phase)\n{\n\n    return brightness + contrast*cos( 6.28318*(osc*t+phase) );\n} \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    //vec2 uv = squareFrame(iResolution.xy, fragCoord);\n\n    vec2 uv = fragCoord/iResolution.xy * 2.0 -1.;\n    uv *=2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    // heart equation from a comment from iq https://www.shadertoy.com/view/XdcyW8\n    //https://www.wolframalpha.com/input/?i=%28x%5E2%2B%281.2*y-sqrt%28abs%28x%29%29%29%5E2%E2%88%921%29+%3D+0+for+-1.5+%3C+x+%3C+1.5%2C+-1.5+%3C+y+%3C+1.5\n    vec3 heart = vec3((pow(abs(uv.x),2.)+pow(abs(1.2*uv.y-sqrt(abs(uv.x))),2.)-1.) );\n    vec3 brightness = vec3(0.8);\n    vec3 contrast = vec3(0.15,0.1,0.3);\n    // the numbers that divide time are pretty arbitrary, as long as they are not the same and are somewhere between 10-100 id say it gives the desired effect\n    vec3 osc = vec3(0.1,cos(iTime/13.),cos(iTime/11.));\n    vec3 phase = vec3(0.2,0.5,0.1);\n    vec3 col = cosPalette(heart.x/3., brightness, contrast, osc, phase);\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 47, 129, 129, 195], [199, 199, 254, 312, 1192]], "test": "untested"}
{"id": "sdtGWf", "name": "Plane Fitting", "author": "oneshade", "description": "Fitting points with a plane.", "tags": ["plane", "optimization", "points", "fitting"], "likes": 7, "viewed": 254, "published": 3, "date": "1630794536", "time_retrieved": "2024-07-30T19:03:09.285170", "image_code": "#define iTime (0.25 * iTime)\n\n#define PI 3.14159265359\n#define AA 2\n\n// Convenience structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct TraceInfo {\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    int id;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 nor;\n};\n\n#define N 10\nPlane planeFitting(in vec3[N] points) {\n    float Jxx = 0.0, Jyy = 0.0;\n    float Jxy = 0.0, Jxz = 0.0, Jyz = 0.0;\n    float Jx = 0.0, Jy = 0.0, Jz = 0.0;\n    for (int n=0; n < N; n++) {\n        vec3 p = points[n];\n        Jxx += p.x * p.x, Jyy += p.y * p.y;\n        Jxy += p.x * p.y, Jxz += p.x * p.z, Jyz += p.y * p.z;\n        Jx += p.x, Jy += p.y, Jz += p.z;\n    }\n\n    // Precomputation\n    float P = float(N);\n    float c1 = Jx * Jyy - Jy * Jxy;\n    float c2 = Jx * Jy  - P  * Jxy;\n    float c3 = Jx * Jyz - Jy * Jxz;\n    float c4 = Jx * Jxy - Jy * Jxx;\n\n    // Solve for plane coefficients: z = ax + by + c\n    float a = (c1 * (Jx * Jz - P * Jxz) - c2 * c3) / (c1 * (Jx * Jx - P * Jxx) - c2 * c4);\n    float b = (c3 - c4 * a) / c1;\n    float c = (Jxz - Jxx * a - Jxy * b) / Jx;\n\n    // Compute position and normal\n    vec3 n = vec3(a, b, -1.0);\n    float l2 = a * a + b * b + 1.0;\n    return Plane(-n * c / l2, n / sqrt(l2));\n}\n\n// Double integral of mod(floor(x) + floor(y), 2) from a to b\nfloat integrateCheckers(in vec2 a, in vec2 b) {\n    vec2 u = b - a, v = abs(mod(b, 2.0) - 1.0) - abs(mod(a, 2.0) - 1.0);\n    return 0.5 * (u.x * u.y - v.x * v.y);\n}\n\n// 2D rotation matrix\nmat2 Rotate2D(in float theta) {\n    float c = cos(theta), s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n// Primitive intersectors\nvoid addPlane(in vec3 pos, in vec3 nor, in int id, in Ray ray, inout TraceInfo scene) {\n    float d = dot(ray.dir, nor);\n    if (d != 0.0) {\n        float t = dot(pos - ray.pos, nor) / d;\n        if (t > 0.0 && (scene.id != 0 ? t < scene.dist : true)) {\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = nor;\n            scene.id = id;\n        }\n    }\n}\n\nvoid addSphere(in vec3 pos, in float radius, in int id, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - radius * radius;\n\n    float discr = b * b - a * c;\n    if (discr > 0.0) {\n        float t = (-b - sign(c) * sqrt(discr)) / a;\n        if (t > 0.0 && (scene.id != 0 ? t < scene.dist : true)) {\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = scene.pos / radius;\n            scene.id = id;\n            scene.pos += pos;\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(-1.0, vec3(0.0), vec3(0.0), 0);\n\n    vec3 o = vec3(sin(iTime + 1.0), cos(2.0 * iTime - 1.0), sin(iTime - 1.0));\n    vec3 d = normalize(vec3(sin(2.0 * iTime), cos(iTime), sin(iTime) * cos(3.0 * iTime)));\n\n    vec3[N] points;\n    for (float n=0.0; n < float(N); n++) {\n        float s1 = 0.2 * n, s2 = cos(n), s3 = sin(n);\n        vec3 point = 5.0 * vec3(sin(s1 * iTime) * cos(s1 * iTime), cos(s2 * iTime), sin(s3 * iTime));\n        point -= d * dot(point - o, d);\n        point += d * sin(point.x) * cos(point.y);\n        addSphere(point, 0.2, 1, ray, scene);\n        points[int(n)] = point;\n    }\n\n    Plane fitting = planeFitting(points);\n    addPlane(fitting.pos, fitting.nor, 2, ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Mouse rotation\n    mat2 yaw = Rotate2D(-mouse.x);\n    mat2 pitch = Rotate2D(-mouse.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            vec3 color;\n\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -1.0)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Render\n            TraceInfo scene = traceScene(camRay);\n            if (scene.id != 0) {\n                vec3 mat = vec3(1.0, 0.0, 0.0);\n                if (scene.id == 2) {\n                    vec3 u = normalize(vec3(-scene.nor.z, 0.0, scene.nor.x));\n                    vec3 v = cross(u, scene.nor);\n                    vec2 texCoords = scene.pos * mat2x3(u, v);\n                    float filt = scene.dist * scene.dist / 2500.0; // Hack filter\n                    mat = vec3(integrateCheckers(texCoords - filt, texCoords + filt) / (4.0 * filt * filt));\n                }\n\n                float shade = max(0.1, dot(scene.nor, -camRay.dir));\n                if (scene.id == 2) shade = 1.0;\n                color = mat * shade;\n            }\n\n            else color = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * camRay.dir.y);\n            fragColor.rgb += pow(color, vec3(0.75));\n        }\n    }\n\n    // Average\n    fragColor.rgb /= float(AA * AA);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1211, 1273, 1320, 1320, 1437], [1439, 1461, 1492, 1492, 1566], [1568, 1594, 1681, 1681, 1996], [1998, 1998, 2090, 2090, 2609], [3409, 3409, 3464, 3464, 5283]], "test": "untested"}
{"id": "fsdGWf", "name": "thunderstorm", "author": "miloszmaki", "description": "thunderstorm in the mountains at night", "tags": ["clouds", "sky", "thunderstorm", "night", "mountains", "lightning"], "likes": 26, "viewed": 1534, "published": 3, "date": "1630792324", "time_retrieved": "2024-07-30T19:03:10.271533", "image_code": "float rand(float x)\n{\n    return fract(sin(x)*75154.32912);\n}\n\nfloat rand3d(vec3 x)\n{\n    return fract(375.10297 * sin(dot(x, vec3(103.0139,227.0595,31.05914))));\n}\n\nfloat noise(float x)\n{\n    float i = floor(x);\n    float a = rand(i), b = rand(i+1.);\n    float f = x - i;\n    return mix(a,b,f);\n}\n\nfloat perlin(float x)\n{\n    float r=0.,s=1.,w=1.;\n    for (int i=0; i<6; i++) {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s*x);\n    }\n    return r;\n}\n\nfloat noise3d(vec3 x)\n{\n    vec3 i = floor(x);\n    float i000 = rand3d(i+vec3(0.,0.,0.)), i001 = rand3d(i+vec3(0.,0.,1.));\n    float i010 = rand3d(i+vec3(0.,1.,0.)), i011 = rand3d(i+vec3(0.,1.,1.));\n    float i100 = rand3d(i+vec3(1.,0.,0.)), i101 = rand3d(i+vec3(1.,0.,1.));\n    float i110 = rand3d(i+vec3(1.,1.,0.)), i111 = rand3d(i+vec3(1.,1.,1.));\n    vec3 f = x - i;\n    return mix(mix(mix(i000,i001,f.z), mix(i010,i011,f.z), f.y),\n               mix(mix(i100,i101,f.z), mix(i110,i111,f.z), f.y), f.x);\n}\n\nfloat perlin3d(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise3d(s * x);\n    }\n    return r;\n}\n\nfloat f(float y)\n{\n    float w = 0.4; // width of strike\n    return w * (perlin(2. * y) - 0.5);\n}\n\nfloat plot(vec2 p, float d, bool thicker)\n{\n    if (thicker) d += 5. * abs(f(p.y + 0.001) - f(p.y));\n    return smoothstep(d, 0., abs(f(p.y) - p.x));\n}\n\nfloat cloud(vec2 uv, float speed, float scale, float cover)\n{\n    float c = perlin3d(vec3(uv * scale, iTime * speed * 2.));\n    return max(0., c - (1. - cover));\n}\n\nfloat mountain(vec2 uv, float scale, float offset, float h1, float h2)\n{\n    float h = h1 + perlin(scale*uv.x + offset) * (h2 - h1);\n    return smoothstep(h, h+0.01, uv.y);\n}\n\nvec3 render(vec2 uv)\n{\n    float x = iTime + 0.1;\n\n    float m = 0.25; // max duration of strike\n    float i = floor(x/m);\n    float f = x/m - i;\n    float k = 0.4; // frequency of strikes\n    float n = noise(i);\n    float t = ceil(n-k); // occurrence\n    float d = max(0., n-k) / (1.-k); // duration\n    float o = ceil(t - f - (1. - d)); // occurrence with duration\n    float gt = 0.1; // glare duration\n    float go = ceil(t - f - (1. - gt)); // glare occurrence\n    \n    float lightning = 0.;\n    float light = 0.;\n    float glare = 0.;\n    \n    if (o == 1.) {\n        vec2 uv2 = uv;\n        uv2.y += i * 2.; // select type of lightning\n        float p = (noise(i+10.) - 0.5) * 2.; // position of lightning\n        uv2.x -= p;\n        \n        float strike = plot(uv2, 0.01, true);\n        float glow = plot(uv2, 0.04, false);\n        float glow2 = plot(uv2, 1.5, false);\n\n        lightning = strike * 0.4 + glow * 0.15;\n\n        float h = noise(i+5.); // height\n        lightning *= smoothstep(h, h+0.05, uv.y + perlin(1.2*uv.x + 4.*h)*0.03);\n        lightning += glow2 * 0.3;\n        light = smoothstep(5., 0., abs(uv.x - p));\n        glare = go * light;\n    }\n    \n    vec3 clouds =\n        vec3(0.5,0.7,1.) * mix(0.6, 0.9, cloud(uv, 0.2, 0.1, 1.0)) +\n        vec3(0.7,0.8,1.) * 0.6 * cloud(uv*vec2(0.5,1.), 0.06, 0.8, 0.8) +\n        vec3(0.9,0.9,1.) * 0.3 * cloud(uv*vec2(0.1,1.), 0.08, 5.5, 0.6) +\n        vec3(1.,1.,1.) * 0.4 * cloud(uv*vec2(0.1,1.), 0.07, 10., 0.5);\n    \n    float horizon = mountain(uv, 0.8, 9., 0.3, 0.6);\n    vec3 terrain = mix(vec3(0.25,0.3,0.3)*0.5, 1.5*vec3(0.15,0.2,0.3),\n        1. - (1. - mountain(uv, 0.8, 3., 0.2, 0.4)) * 0.5 - \n        (1. - mountain(uv, 0.8, 17.5, 0.05, 0.25)) * 0.5);\n    \n    vec3 background = mix(terrain, clouds, horizon);\n    background *= (0.2 + light * 0.5);\n    \n    return vec3(background + lightning + glare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 2. * uv.x - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 61], [63, 63, 85, 85, 164], [166, 166, 188, 188, 297], [299, 299, 322, 322, 465], [467, 467, 490, 490, 975], [977, 977, 1001, 1001, 1169], [1171, 1171, 1189, 1189, 1268], [1270, 1270, 1313, 1313, 1421], [1423, 1423, 1484, 1484, 1586], [1588, 1588, 1660, 1660, 1762], [1764, 1764, 1786, 1786, 3642], [3644, 3644, 3701, 3701, 3855]], "test": "untested"}
{"id": "fdd3Wf", "name": "CA Progression", "author": "oneshade", "description": "Messing with cellular automata.", "tags": ["ca", "cellularautomata"], "likes": 5, "viewed": 133, "published": 3, "date": "1630773111", "time_retrieved": "2024-07-30T19:03:11.329705", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    if (iFrame == 0) {\n        fragColor.x = float(texture(iChannel1, fragCoord / iResolution.xy).x > 0.49);\n    }\n\n    if (iFrame > 0) {\n        ivec2 iFragCoord = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n\n        int neighbors = 0;\n        float total = 0.0;\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                if (i == 0 && j == 0) continue;\n                float state = texelFetch(iChannel0, iFragCoord + ivec2(i, j), 0).x;\n                neighbors += state > 0.5 ? 1 : 0;\n                total += state;\n            }\n        }\n\n        if (fragCoord.x > 0.5) {\n            fragColor.x += 0.1 * float(neighbors > 0 && neighbors < 6);\n            if (iTime > 5.0 && iTime < 8.0) fragColor.x -= total / 9.0;\n            if (iTime > 8.0 && iTime < 8.5) fragColor.x += total / 9.0;\n            if (iTime > 10.0) fragColor.x = clamp(fragColor.x, 0.0, 1.0);\n        }\n\n        else fragColor.x = float(neighbors == 3);\n    }\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "Nst3DX", "name": "Gold Desert", "author": "yasuo", "description": "Gold Desart", "tags": ["dust", "desart"], "likes": 3, "viewed": 259, "published": 3, "date": "1630765614", "time_retrieved": "2024-07-30T19:03:12.164472", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 6.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL_SAND 0\n\n#define ZERO (min(iFrame,0))\n\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n    p = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n    return sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z += iTime*2.0;\n    p+=noise3d(p*1000.0)*0.001;\n    p.y+=perlin_noise(p.xz*3.0)*0.15;\n    \n    return vec2(p.y*0.6,MATERIAL_SAND);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL_SAND){\n        vec3 np = p;\n        np.z += iTime*2.0;\n         float nn = noise3d(np*100.0)*0.2;\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.7,0.3)+nn);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float handShakeY = noise3d(vec3(iTime*2.0,iTime*2.1,iTime*2.2))*0.15;\n    float handShakeX = noise3d(vec3(iTime*2.1,iTime*2.2,iTime*2.1))*0.3;\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 1.3);\n    ro.yz *= Rot(radians(-5.0));\n    ro.xz *= Rot(radians(iTime*5.0));\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = mix(vec3(0.75,0.9,0.9)*0.5,vec3(0.8,0.9,0.9)*0.9,-uv.y+1.0);   \n    }\n    \n    // POST EFFECTS    \n    rd.z+=iTime*2.0;\n    \n    // dust effect\n    float c = noise3d(rd*1.5) * 0.05 + perlin_noise(rd.xz * 2.0) * 0.1 + noise3d(rd * 5.0) * 0.01;    \n    col+=vec3(0.8,0.8,0.5)*c*0.5;\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 346, 371, 371, 710], [712, 712, 733, 733, 851], [853, 853, 881, 881, 1479], [1481, 1481, 1503, 1503, 1662], [1664, 1664, 1722, 1722, 1993], [1995, 1995, 2019, 2019, 2220], [2222, 2222, 2264, 2264, 2459], [2461, 2502, 2551, 2551, 2842], [2844, 2844, 2901, 2901, 3520], [3522, 3522, 3581, 3581, 3786], [3788, 3788, 3845, 3845, 4929]], "test": "untested"}
{"id": "fdt3WX", "name": "tetrahedron in cube 2", "author": "FabriceNeyret2", "description": "tribute to https://iquilezles.org/articles/normalsSDF/normalsSDF.htm  ;-)\n( how to compute centered finite differences with only 4 fetches ).", "tags": ["raymarching", "short"], "likes": 4, "viewed": 284, "published": 3, "date": "1630752072", "time_retrieved": "2024-07-30T19:03:13.128893", "image_code": "// variant of https://shadertoy.com/view/7s33Df\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,c,m=t; \n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(1) ; O.x > 0. && t > .01 ; O-=.01 )\n        q = p,\n        q.yz *= rot( .5-6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        t = abs( c = max(a.x,max(a.y,a.z)) - 1.)-.01 ,        // cube\n        m = min(m,c),                                         // memo closest to cube\n#define A(x,y,z) dot(q,vec3(x,y,z))/sqrt(3.)\n#define D(x,y,z) min( abs(.9-A(x,y,z))-.15 , 1.3-A(x,y,z) ) \n        t = max(t, min(min(D(1,1,-1),D(1,-1,1)),min(D(-1,1,1),D(-1,-1,-1))) ), // tetrahedron strips\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t>c) O *= .7;\n    O.b += exp(-20.*m);  // transparent blue cube via ~glow\n}\n\n\n\n\n\n/* // smart AA https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n} */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7s33Df", "name": "tetrahedron in cube", "author": "FabriceNeyret2", "description": "tribute to https://iquilezles.org/articles/normalsSDF/normalsSDF.htm  ;-)\n( how to compute centered finite differences with only 4 fetches ).", "tags": ["raymarching", "short"], "likes": 10, "viewed": 328, "published": 3, "date": "1630749410", "time_retrieved": "2024-07-30T19:03:13.979619", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,c,e,l; \n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(1) ; O.x > 0. && t > .01 ; O-=.01 )\n        q = p,\n        q.yz *= rot( .5-6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        c = max(a.x,max(a.y,a.z))-1.,                         // cube\n#define A(x,y,z) vec3(x,y,z)/sqrt(3.)\n#define D(x,y,z) dot(q,A(x,y,z))\n        t = max(c, 1.3 - max(max(D(1,1,-1),D(1,-1,1)),max(D(-1,1,1),D(-1,-1,-1))) ), // tetrahedron corners\n        t = min(t, s = length(q)-.4),                         // central sphere\n#define C(s) length( abs(q.s) - 1. )\n        t = min(t, e = max(min(C(xy),min(C(yz),C(xz)))-.01, c) ), // cube edges\n#define P(x,y,z) length( q - max(0.,D(x,y,z))*A(x,y,z) )\n        t = min(t, l = max( min(min(P(1,1,-1),P(1,-1,1)),min(P(-1,1,1),P(-1,-1,-1))) -.1 , c ) ), // tetra axes\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t==e) O.rg *=.7;                                      // coloring\n    if (t==s) O.gb *= 0.; else if (t!=c) O *= .7;\n    if (t==l) O.gb *= 0.;\n}\n\n\n\n\n\n/* // smart AA https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n} */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s33Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7s3GDf", "name": "Gerd Muller 2021", "author": "yasuo", "description": "Robot modeling design. This one is not a reproduction. I designed this by myself. I know we can do this more detailed one using the 3D model software but it is what it is. I love to do this with all by the shader.", "tags": ["modeling", "robot"], "likes": 11, "viewed": 327, "published": 3, "date": "1630744595", "time_retrieved": "2024-07-30T19:03:14.968974", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define EDGE_WIDTH 0.003\n#define MATERIAL_BODY 0\n#define MATERIAL_SKELTON 1\n#define MATERIAL_EYE 2\n#define MATERIAL_BOX 3\n\n#define ZERO (min(iFrame,0))\n\nfloat edge;\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat dTaperBox(vec3 p, vec3 b, float angle, float bottomDist) {\n    vec3 prevP = p;\n    float d = B3D(p,b);\n    float a = radians(angle);\n    p.x = abs(p.x);\n    p.x-=bottomDist;    \n    d = max(Slice(p.xy,a),d);\n\n    p = prevP;\n    a = radians(angle);\n    p.z = abs(p.z);\n    p.z-=bottomDist;\n    d = max(Slice(p.zy,a),d);\n\n    return d;\n}\n\nfloat leg(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.06,0.09,0.07));\n    \n    float a = radians(45.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.065;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.055;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d);    \n    \n    return d;\n}\n\nvec2 drawLeg(vec3 p){\n    vec3 prevP = p;\n    \n    p.z*=0.7;\n    p.x=abs(p.x);\n    p.x-=0.028;\n    float d = dTaperBox(p,vec3(0.021,0.035,0.14),60.0,0.1);\n    p = prevP;\n    \n    p.zy = abs(p.zy);\n    p.zy-=0.2;    \n    float maskd = max(Slice(p.zy,radians(-42.0)),B3D(prevP-vec3(0.0,-0.03,0.0),vec3(0.1,0.02,0.2)));\n    \n    d = max(-maskd,d);\n    vec2 res = vec2(d, MATERIAL_SKELTON);\n    \n    p = prevP;\n    p.yz*=Rot(radians(10.0));\n    d = leg(p-vec3(0.0,0.12,0.01));\n    \n    p = prevP;\n    p.yz*=Rot(radians(-20.0));\n    p*=vec3(0.8,0.7,0.8);\n    \n    float d2 = leg(p-vec3(0.0,0.21,-0.07));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = sdCappedCylinder(p-vec3(0.0,0.21,-0.01),0.035,0.08);\n    d = min(d,d2);\n    \n    p.yz*=Rot(radians(20.0));\n    d2 = B3D(p-vec3(0.0,0.17,-0.04),vec3(0.015,0.08,0.01));\n    d = min(d,d2);\n    \n    vec2 res2 = vec2(d, MATERIAL_BODY);\n    return combine(res,res2);\n}\n\nfloat sholuder(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.13,0.1,0.07));\n    \n    float a = radians(50.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.075;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    p.xz = abs(p.xz);\n    p.xz-=0.085;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.x+=0.12;    \n    d = max(-Slice(p.xy,a),d);    \n    \n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.065;\n    d = max(-B3D(p-vec3(0.07,0.0,0.0),vec3(0.01,0.06,0.02)),d); \n    \n    return d;\n}\n\nfloat armWithSheild(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.07,0.06,0.09));\n    \n    float a = radians(45.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.065;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.06;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d);    \n    \n    p = prevP;\n    float d2 = B3D(p-vec3(-0.075,0.0,0.05),vec3(0.01,0.05,0.12));\n    \n    p.y = abs(p.y);\n    p.y-=0.03;\n    d2 = max(-B3D(p-vec3(-0.082,0.0,0.05),vec3(0.005,0.005,0.13)),d2);\n    \n    return min(d,d2);\n}\n\nfloat hand(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.02,0.04,0.04));\n    \n    float a = radians(-120.0);\n    p.xz+=0.01;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    d = max(-B3D(p-vec3(0.015,0.0,0.01),vec3(0.01,0.05,0.015)),d);\n    \n    return d;\n}\n\nvec2 drawArm(vec3 p){\n    vec3 prevP = p;\n    float d = sholuder(p);\n    \n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    float x = 0.01;\n    d = B3D(p-vec3(x,-0.15,0.0),vec3(0.04,0.1,0.035));\n    \n    float d2 = B3D(p-vec3(x,-0.25,-0.03),vec3(0.04,0.04,0.065));\n    d = min(d,d2);\n    d2 = sdCappedCylinder(p-vec3(x,-0.24,0.0),0.06,0.05);\n    d = min(d,d2);\n    \n    vec2 res2 = vec2(d, MATERIAL_SKELTON);\n    \n    d = armWithSheild(p-vec3(x,-0.25,-0.165));\n    vec2 res3 = vec2(d, MATERIAL_BODY);\n    \n    d = hand(p-vec3(x,-0.25,-0.298));\n    vec2 res4 = vec2(d, MATERIAL_SKELTON);\n    \n    return combine(res,combine(res2,combine(res3,res4)));\n}\n\nfloat bodyTop(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.15,0.15,0.2));\n    \n    float a = radians(50.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.12;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(-40.0);\n    p.xy = abs(p.xz);\n    p.xy-=0.26;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.02;\n    p.x = abs(p.x);\n    p.x-=0.02;\n    d = max(-B3D(p-vec3(0.0,0.0,-0.198),vec3(0.007,0.04,0.03)),d);\n    \n    return d;\n}\n\nfloat bodyBtm(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.06,0.1,0.16));\n    \n    float a = radians(35.0);\n    p.zy = abs(p.zy);\n    p.zy-=vec2(0.1,0.13);    \n    d = max(Slice(p.zy,a),d);\n    \n    return d;\n}\n\nvec2 drawBody(vec3 p){\n    vec3 prevP = p;\n    float d = bodyBtm(p-vec3(0.0,-0.1,0.0));\n    float d2 = bodyTop(p-vec3(0.0,0.1,0.0));\n    d = min(d,d2);\n    vec2 res = vec2(d, MATERIAL_BODY);\n    return res;\n}\n\nvec2 drawHead(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.05,0.04,0.1));\n    float a = radians(40.0);   \n    d = max(Slice(p.yz,a),d);\n    d = max(-B3D(p-vec3(0.0,0.0,-0.1),vec3(0.3,0.01,0.01)),d);\n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    d = B3D(p-vec3(sin(-iTime*2.5)*0.01,0.0,-0.1),vec3(0.025,0.005,0.01));\n    vec2 res2 = vec2(d, MATERIAL_EYE);\n    \n    return combine(res,res2);\n}\n\nvec2 drawBox(vec3 p){\n    vec3 prevP = p;\n    vec3 size = vec3(3.5,0.01,3.5);\n    p.z-=iTime*1.5;\n    p.y+=noise3d(p*80.0)*0.005;\n    p.z=mod(p.z,2.)-1.0;\n    \n    float d = B3D(p,size);\n    p = prevP;\n    float d2 = B3D(p,size);\n    d = max(B3D(p,size),d);\n    vec2 res = vec2(d, MATERIAL_BOX);\n    return res;\n}\n\nvec2 drawCannon(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.17,0.04,0.15));\n    \n    float a = radians(25.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.1;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(20.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.085;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d); \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.03; \n    float d2 = B3D(p-vec3(0.0,0.0,-0.13),vec3(0.03));    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.1;\n    d2 = B3D(p,vec3(0.18,0.05,0.005));\n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.065;  \n    d2 = max(Slice(p.xy,a),d2);\n    d = min(d,d2);\n    \n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.03; \n    d = B3D(p-vec3(0.0,0.0,-0.12),vec3(0.02));\n    vec2 res2 = vec2(d, MATERIAL_SKELTON);\n    \n    return combine(res,res2);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 originalP = p;\n    \n    p.x += sin(iTime*2.2)*0.12;\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n\n    p.x = abs(p.x);\n    p.x-=0.12;\n    vec2 dleg = drawLeg(p-vec3(0.0,-0.42,-0.05));\n    p = prevP;\n    \n    p.x = abs(p.x);\n    \n    p.x-=0.29;\n    p.x*=-1.0;\n    vec2 dCannon = drawCannon(p-vec3(0.0,0.42,0.03));\n    vec2 darm = drawArm(p-vec3(0.0,0.28,0.0));\n    p = prevP;\n    vec2 dBody = drawBody(p-vec3(0.0,0.1,0.0));\n    vec2 dhead = drawHead(p-vec3(0.0,0.39,0.015));\n    \n    p = originalP;\n    vec2 dBox = drawBox(p-vec3(0.0,-0.47,0.0));\n    \n    vec2 model = combine(combine(dleg,darm),combine(dBody,dhead));\n    return combine(combine(model,dCannon),dBox);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dist = dS.x;\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(stepnum == MAX_STEPS){\n            if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.0005) {\n                edge = 1.0;\n            }\n            if (dist < lastDistEval) lastDistEval = dist;\n        }\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat bodyPaint(vec2 p, float sc, float flip){\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float rand = hash12(id);\n    float lineW = 0.14;\n    \n    if(rand<0.5 || rand>=0.8){\n        float dir = (rand>=0.8)?1.0:-1.0;\n        uv*=Rot(radians(dir*45.0*flip));\n        uv.x = abs(uv.x);\n        uv.x-=0.355;\n        lineW = 0.1;\n    }\n    \n    lineW*=sc;\n    float d = max(-(uv.x+(lineW*0.5)),(uv.x-(lineW*0.5)));\n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 np = p;\n    float xanim = sin(iTime*2.2)*0.12;\n    if(mat == MATERIAL_BODY){\n        np.x += xanim;\n        float d = bodyPaint(np.xy*30.0,1.0,1.0);\n        float nn = noise3d(np*30.0)*0.2;\n        float sn = hash12(np.xy*100.0)*0.1;\n\n        vec3 bcol = mix(vec3(0.3,0.4,0.3)+nn-sn,vec3(0.1,0.2,0.1),S(p.xy,d,0.0));\n        col = diffuseMaterial(n,rd,p,bcol);\n    } else if(mat == MATERIAL_SKELTON) {\n        np.x += xanim;\n        float nn = noise3d(np*100.0)*0.1;\n        float sn = hash12(np.xy*100.0)*0.1;\n        col = diffuseMaterial(n,rd,p,vec3(0.2)+nn+sn);\n        col*=1.5;\n    } else if(mat == MATERIAL_BOX) {\n        np.z-=iTime*1.5;\n        vec3 prevNp = np;\n        float nn = noise3d(np*5.0)*0.08;\n        float sn = hash12(np.xz*100.0)*0.1;\n        vec3 bcol = vec3(0.6,0.65,0.7)+nn+sn;\n\n        np.z= mod(np.z,0.8)-0.4;\n        float d = B(np.xz,vec2(0.02,0.2));\n        bcol = mix(bcol,vec3(1.0),S(p.xy,d,0.0));\n        np.x = abs(np.x);\n        np.x-=1.5;\n        d = B(np.xz,vec2(0.02,0.4));\n        bcol = mix(bcol,vec3(1.0),S(p.xy,d,0.0));\n        \n        col = diffuseMaterial(n,rd,p,bcol);\n    } else if(mat == MATERIAL_EYE){\n        col = diffuseMaterial(n,rd,p,vec3(0.5,0.0,0.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float handShakeY = noise3d(vec3(iTime*2.0,iTime*2.1,iTime*2.2))*0.15;\n    float handShakeX = noise3d(vec3(iTime*2.1,iTime*2.2,iTime*2.1))*0.3;\n    #if USE_MOUSE == 1\n    handShakeY = 0.0;\n    handShakeX = 0.0;\n    #endif\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 1.3);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-10.0));\n    if(iMouse.z>0.){\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(180.0+iTime*20.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col = mix(col,vec3(0.6),edge);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        rd.z-=iTime*1.2;\n        // dust effect\n        float c = noise3d(rd) * 0.5 + noise3d(rd * 5.0) * 0.25 + noise3d(rd * 10.0) * 0.1;\n        uv.y-=0.07;\n        col = mix(vec3(0.3,0.3,0.1)+(c*0.2),vec3(0.0),-uv.y+1.0);   \n    }\n    \n    // POST EFFECTS\n    float cline = mod(fragCoord.y, 4.0) < 2.0 ? 0.5 : 1.0;\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0)*(cline*1.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3GDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 616, 641, 641, 980], [982, 1001, 1023, 1023, 1140], [1142, 1142, 1178, 1178, 1220], [1222, 1271, 1323, 1323, 1430], [1432, 1432, 1459, 1459, 1513], [1515, 1515, 1579, 1579, 1856], [1858, 1858, 1876, 1876, 2280], [2282, 2282, 2303, 2303, 3196], [3198, 3198, 3221, 3221, 3722], [3724, 3724, 3752, 3752, 4360], [4362, 4362, 4381, 4381, 4638], [4640, 4640, 4661, 4661, 5289], [5291, 5291, 5313, 5313, 5775], [5777, 5777, 5799, 5799, 5998], [6000, 6000, 6022, 6022, 6208], [6210, 6210, 6232, 6232, 6614], [6616, 6616, 6637, 6637, 6929], [6931, 6931, 6955, 6955, 7894], [7896, 7896, 7918, 7918, 8601], [8603, 8603, 8661, 8661, 9227], [9229, 9229, 9253, 9253, 9454], [9456, 9456, 9498, 9498, 9693], [9695, 9736, 9785, 9785, 10076], [10078, 10078, 10135, 10135, 10754], [10756, 10756, 10802, 10802, 11196], [11198, 11198, 11257, 11257, 12498], [12500, 12500, 12557, 12557, 14043]], "test": "untested"}
{"id": "ss3GWf", "name": "Ray-Circle-Relfection 03-sept-21", "author": "Yusef28", "description": "Mouse Enabled\n", "tags": ["ad", "autodiff", "autodiff", "automaticdifferentiation", "dualnumbers", "autodifferentiation", "dn"], "likes": 4, "viewed": 242, "published": 3, "date": "1630728942", "time_retrieved": "2024-07-30T19:03:15.804739", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 03-09-2021                                  //\n// Status: On Going                                        //\n// Topic: Ray-Circle Reflections                           //\n// Sources:                                                //\n// https://rootllama.wordpress.com/2014/06/20/ray-         //\n//                  line-segment-intersection-test-in-2d/  //\n// Listening to: UFO361 - so wie wir                       //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\n\nI don't follow the proper ray-segment intersection actually\nthe goal of this is to become more familiar with ray tracing\narchitecture so I've just taken an intersection model\nI had laying around and added a proper(and basic) ray-trace \narchitecture to it. \n\nWhat I really want eventually is:\nhttps://www.shadertoy.com/view/WsBGRz\nor\nhttps://www.shadertoy.com/view/ltXBz7\n\nThe main hiccups here ended up being such small things\nlike the normal being flipped the wrong way\nand well I was drawing some things I didn't need to be \nit's when it came to adding more bounces that things\nfell apart and I was forced to question my assumptions\nabout what I had written.\n\n\nArchitecturial features/functions:\n\n- time and animation \n- draw ray\n- draw intersection point\n- scene intersections\n- bounces\n- ray trace\n- segment structure\n\nAdjustables in Common Tab:\n\n- number of rays\n- number of bounces (good with more objects)\n- number of segments (if you wan to add more segments you need\nto increase this before adding them to segmentList)\n\nPossible expansions:\n\n- materials(refractions/diffuse/lambert/roughness)\n- more objects (triangle, AABB, circle, ellipse)\n- movement (I'd love to make the segments rotate for starters)\n\nI definitly feel like programming the architecture\nis a different mindset from doing the math (intersections \nfor example). I might want to work on only one of these\naspects in any given coding session. Not sure.\n\n*/\n//objects //global hit list, just two points for one line\n\nstruct Segment{\n    vec2 A;\n    vec2 B;\n    int id;\n};\n\nstruct Circle{\n    vec2 pos;\n    float r;\n    vec3 col;\n    int id;\n};\n\nSegment segmentList[] = Segment[Seg_N](\n    Segment(vec2(3., -3.),vec2(4., 3.), 0),\n    Segment(vec2(-5., -3.),vec2(-3., 3.), 1)\n);\n\nCircle CircleList[] = Circle[Circle_N](\n    Circle(vec2(0.,0.), 4., vec3(1.), 0),\n    Circle(vec2(-2.,-2.), 1., vec3(1.,.3,.3), 1)\n);\n\nvec3 background_grid(vec2 st, vec2 uv){\n    vec3 col = vec3(0.1);;\n     col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    return col;\n\n}\n\nvec2 time_and_animation(){\n\n    float speed = 1.;\n    float time = 12.;//clamp(abs(fract(iTime*speed-0.5)-0.5)*2.,0.1,1.)*12.;\n\n    return vec2(time,0.);\n    }\n    \nvec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){\n\n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    return col;\n}\n\nvec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){\n\n    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    return col;\n}\n\nfloat iSphere(vec2 ro, vec2 rd, vec2 cPos, float r){\n\n    vec2 O_C = ro-cPos;\n    \n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,O_C);\n    float c = dot(O_C,O_C) - r*r;\n    \n    float disc = b*b-4.*a*c;\n    \n    if(disc < 0.) return -1.;\n    \n    //I finally forgot brackets around the numerator\n    //it finally happened\n    //it's the things that I did yesterday that are hurting me today\n\n    float t1 = (-b - sqrt(disc))/(2.*a); \n    float t2 = (-b + sqrt(disc))/(2.*a);\n    \n    if(t1 >= 0.){return t1;}\n    else if(t2 >= 0.){return t2;}\n    else return -1.;\n}\n\nvec2 circle_intersections(vec2 ro, vec2 rd){\n\n    float min_t = 100.;\n    float t;\n    float idf = -1.;\n    \n    for(int i = 0; i < 1; i++){\n        \n        t = iSphere(ro, rd, CircleList[i].pos, CircleList[i].r);\n        \n        if(t < min_t){\n        \n            min_t = t;\n            idf = float(i);\n            \n        } \n    }\n    \n    return vec2(t, idf);\n}\n\n\nvec3 bounces(vec2 bounce_ro, vec2 rd, float time, vec2 uv, vec3 col){\n\n    vec3 ray_color = line1Col;\n    for(float j = 0.; j < float(BOUNCE_N); j++){\n        \n            //time instead of t_and_a.y!\n            \n            vec2 A1 = bounce_ro;\n            vec2 B1 = bounce_ro + rd*time;\n            \n            //check all objects (just one line here)\n            int id = -1;\n            \n            vec2 ct_and_id = circle_intersections(bounce_ro,rd);\n            float ct = ct_and_id.x;\n            id = int(ct_and_id.y);\n            \n\n            \n            if(ct > 0.){\n\n                \n                //new ro is hit point\n                bounce_ro = bounce_ro + rd*ct;//s_t_iPoint.zw;\n                \n                //normal is orthogonal to the line facing left\n                vec2 n = normalize(bounce_ro - CircleList[id].pos);//normalize(vec2( -(segB.y-segA.y), segB.x-segA.x ));\n                \n                //a good couple of hours spent here\n                //until I decided to just show the normals \n                //which I should have done from the start\n                if(dot(n, rd) <= 0.){\n                    n = -n;\n                }\n                \n                n = -n;\n                //reflected rd is...\n                rd = reflect(rd,n);\n                \n                //use the same \"time\" variable to go back along the reflected ray\n                //vec2 reflected_a = bounce_ro;\n                //vec2 reflected_b = bounce_ro + rd*time;\n                \n                //draw the ray to the hit point\n                //col = draw_ray(A1, bounce_ro, col, uv);\n                float f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(A1, bounce_ro, uv)));\n                \n                col = mix(col, ray_color, f);\n                \n                //draw normal\n                f = 1.0-smoothstep(0.02,0.06,\n                abs(distToLine(bounce_ro,bounce_ro + n*0.5, uv)));\n                \n                col = mix(col, vec3(0.,1.,0.5), f);\n                \n                col = draw_iPoint(col, bounce_ro, uv);\n   \n                //this is so important!!!\n                bounce_ro += n*0.01;\n                ray_color = 0.5+0.5*cos(vec3(1.,2.,4.)/1. + j*300.);\n            }\n            \n            else{\n            //draw the ray \n            //col = draw_ray(A1, B1, col, uv);\n            \n            float f = 1.0-smoothstep(0.02, 0.06,\n            abs(distToLine(A1, B1, uv)));\n            col = mix(col, ray_color, f);\n            \n            break;\n            }\n            \n    }\n    \n    return col;\n}\nvec3 ray_trace(vec2 uv, vec2 ro, vec3 col){\n    \n    vec2 t_and_a = time_and_animation();\n    //rays\n    for(float i = 0.; i<fov; i += fov/float(RAY_N)){\n    \n        vec2 rd = vec2(1.,0.)*rot(i-pi*sin(iTime/6.));\n        vec2 bounce_ro = ro;\n        //bounces\n        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);\n        }\n        \n    \n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = background_grid(st, uv);\n\n   float f;\n   \n   for(int i = 0; i < 1; i++){\n       f = clamp(1.0-abs(length(uv - CircleList[i].pos)-CircleList[i].r),0.,1.);\n       f = smoothstep(0.9,0.95,f);\n       col = mix(col, vec3(1.), f);\n   }\n   vec2 ro = vec2(2.);\n       if(iMouse.z > 0.5) ro = vec2((iMouse.xy-iResolution.xy*0.5)/iResolution.y)*8.;\n    \n   col = ray_trace(uv, ro, col);\n\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    //Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159265\n#define RAY_N 24\n#define BOUNCE_N  3\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n#define Seg_N 2\n#define Circle_N 2\n#define fov pi*0.37\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n}\n\nmat2 rot(float a){\n\n    \n    float si = sin(a);\n    float cs = cos(a);\n    return mat2(cs,-si,si,cs);\n   }   \n    \nmat2 trigless_rot(vec2 v, vec2 vr){\n    float si = length(cross(vec3(v,0.),vec3(vr,0.)));\n    float cs = dot(v,vr);\n    return mat2(cs,-si,si,cs);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3GWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2637, 2637, 2676, 2676, 3524], [3526, 3526, 3552, 3552, 3685], [3691, 3691, 3742, 3756, 4123], [4125, 4125, 4179, 4179, 4414], [4416, 4416, 4468, 4468, 4985], [4987, 4987, 5031, 5031, 5355], [5358, 5358, 5427, 5427, 7947], [7948, 7948, 7991, 7991, 8313], [8314, 8314, 8370, 8422, 9850]], "test": "untested"}
{"id": "7dcGWX", "name": "DNA Glass Refraction 03-sep-2021", "author": "Yusef28", "description": "Some experimenting based the bigwings refraction tutorial", "tags": ["refraction", "glass", "refract", "dna", "bigwings"], "likes": 41, "viewed": 4683, "published": 3, "date": "1630728701", "time_retrieved": "2024-07-30T19:03:16.717299", "image_code": "\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n#define TX texture\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 145.\n#define pi 3.14159265\n#define air 1.\n#define glass 1.45\n#define zoom 1.\n\n#define AA 1\n\n//for AA set AA_ON to 1 and then set aa to more than 1\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n    }   \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.);\n    \n}\nfloat bar(vec3 p, float r, float le){\n     return max(length(p.yz) - r, abs(p.x)-le);\n     \n}\nfloat gem(vec3 p){\n\n    float c = cos(pi/5.), s = sqrt(0.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    float d = p.z-1.;\n    return d;   \n}\n\nfloat dna(vec3 p){\np.z += iTime*8.;\n    float ySpacing = 2.4;\n    float xSpacing = 4.;\n    float xySpacing = 40.;\n    vec3 oldP = p;\n    \n    p.xz = mod(p.xz, xySpacing) -xySpacing/2.;\n    p.xz *= rot(floor(oldP.y/ySpacing)/4.);\n    \n    p.xz *= rot(iTime*.1);\n    p.y = mod(p.y, ySpacing)-1.2;\n    \n    \n    \n    float bar = bar(p, 0.5, xSpacing);\n    p.x = abs(p.x)-xSpacing;\n    float gems = gem(p);\n    \n    float dna = min(bar, gems);\n    \n    return dna;\n}\nfloat map(vec3 p){\n    float dna = dna(p);\n    vec3 gems_offset = vec3(12.+sin(iTime/4.),\n                            5.+sin(iTime/6.+9.),\n                            16.+sin(iTime/3.+34.)\n                            );\n                            \n    vec3 gems_mod = vec3(50.,77.,38.);    \n    float more_gems = gem((mod(p + gems_offset, \n                          gems_mod) - gems_mod/2.))/4.;\n                                            \n    float scene = min(more_gems, dna);\n    \n    more_gems = gem(mod((p + gems_offset+vec3(2.))/8., \n                          gems_mod) - gems_mod/2.);\n   \n    //scene = min(scene, more_gems);\n    return scene;\n}\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = abs(map(ro + rd*t));\n        if(d < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zm){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zm;\n    return normalize(rd);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 1., -1.);\n    ro.yz *= rot(-m.y*pi+1.);\n    ro.xz *= rot(-m.x*pi*2.);\n    \n    vec3 rd = camRay(uv, ro, vec3(0., 1.,0.), zoom);\n    vec3 col = TX(iChannel0, rd).rgb;\n    col += hexTexture(uv+vec2(iTime/50.,0.), TX(iChannel1, vec2(3.)).rgb, col, vec2(1.))*0.13;\n   //ro.z +=iTime*8.;\n    float aa_step = 1./float(AA);\n    \n    for(float i = 0.; i < 1.; i += aa_step){\n    for(float j = 0.; j < 1.; j += aa_step){\n    \n    #if AA > 1\n    vec2 o = vec2(float(i),float(j));\n    uv = ((fragCoord+o)-iResolution.xy/2.)/iResolution.y;\n    //uv = ((fragCoord+o)-iResolution.xy*0.5)/iResolution.y;\n    #endif\n    //rd = camRay(uv+vec2(i,j)*2./iResolution.xy, ro, vec3(0., 1.,0.), zoom);\n    rd = camRay(uv, ro, vec3(0., 1.,0.), zoom);\n    float t = trace(ro, rd);\n    \n    \n    // Time varying pixel color\n    \n    \n    vec3 tex;\n    if(t < MAX_DIST){\n        \n        //tpnre\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        vec3 rIn = refract(rd,n,1./glass);\n        vec3 enter = p - n*0.01;\n        \n        vec3 obligatory_reflection = reflect(rd, n);\n        vec3 obligatory_outside = TX(iChannel0, obligatory_reflection).rgb;\n        \n        //tpnre\n        t = trace(enter, rIn);\n        p = enter + rIn*t;\n        vec3 nExit = -normal(p);\n        \n        \n        vec3 rOut = refract(rIn, nExit, glass - 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.r = TX(iChannel0,rOut).r;\n        \n        rOut = refract(rIn, nExit, glass);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.g = TX(iChannel0,rOut).g;\n        \n        rOut = refract(rIn, nExit, glass + 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.b = TX(iChannel0,rOut).b;\n        \n        //vec3 exit = p + rOut*t;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        //col = n*0.5+0.5;\n        \n        col += mix(tex, obligatory_outside, fresnel);\n\n    }\n    \n    //end of aa\n    }}\n    #if AA > 1\n    col/=float(AA*AA);\n    #endif\n    col = pow(col, vec3(.545));\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//from david hoskins hash without sine\n// 3 in 1 out\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvec3 hexTexture(vec2 uv, vec3 color, vec3 tex, vec2 firstXY)\n{\n\tvec2 u = 6.*uv;;\n    vec2 s = vec2(1.,1.732);\n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB*1000.;\n    float id = rnd(idSeed+firstXY.x*firstXY.y/800.);\n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float radius = pow(id*0.2,4.);\n    float f = smoothstep(radius + 0., radius + 0.05, 1.0-q);\n    //+firstXY.y/16.\n    vec3 col = mix(tex,color-fract(8.*id)*0.5,f*step(0.2,id));\n    return col;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 278, 296, 296, 363], [367, 367, 395, 395, 488], [489, 489, 526, 526, 582], [583, 583, 601, 601, 903], [905, 905, 923, 923, 1367], [1368, 1368, 1386, 1386, 2022], [2023, 2023, 2053, 2053, 2249], [2250, 2250, 2270, 2270, 2471], [2472, 2472, 2524, 2524, 2767], [2768, 2768, 2824, 2874, 5106]], "test": "untested"}
{"id": "fsc3Df", "name": "Into the Dream", "author": "rackman", "description": "Reproduction of the album artwork of \"Into The Dream\" by Vanilla:\nhttps://vanillabeats.bandcamp.com/album/into-the-dream-3", "tags": ["2d", "text", "antialiasing", "reproduction", "vanilla"], "likes": 3, "viewed": 264, "published": 3, "date": "1630726906", "time_retrieved": "2024-07-30T19:03:17.580990", "image_code": "/**\n * Reproduction of the album artwork of \n * \"Into The Dream\" by Vanilla\n * https://vanillabeats.bandcamp.com/album/into-the-dream-3\n */\n\n#define PI 3.1415926\n#define RADIUS 0.791\n#define RINGS 10.0\n#define SECTIONS 8.0\n#define AA 2\n\nconst int[] SECTION_IDS = int[](\n     0,  1,  1,  1,  1,  0,  0,  0,\n     0,  1,  3,  3,  3,  2,  0,  0,\n     0,  1,  3,  5,  5,  5,  4,  0,\n     0,  1,  3,  5,  7,  7,  7,  6,\n     8,  1,  3,  5,  7,  9,  9,  9,\n    11, 10,  3,  5,  7,  9, 11, 11,\n    13, 13, 12,  5,  7,  9, 11, 13,\n    15, 15, 15, 14, 16, 17, 18, 19,\n    15, 15, 15, 14, 16, 17, 18, 19,\n    15, 15, 15, 14, 16, 17, 18, 19\n);\n\n// https://www.shadertoy.com/view/MsS3Wc by iq\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 color_for_section(int s) {\n    float hue = 0.25 + 0.25 * sin(iTime*0.25) + (float(s) / 45.0);\n    return hsb2rgb(vec3(hue, 0.65, 0.71));\n}\n\n// https://www.shadertoy.com/view/XtfyRS by knarkowicz\nfloat glyph_sdf(vec2 p, float char) {\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(iChannel0, p / 16. + fract(vec2(char, 15. - floor(char / 16.)) / 16.)).w - 127. / 255.);\n}\n\n// https://www.shadertoy.com/view/XtfyRS by knarkowicz\nvoid text(inout vec3 color, vec2 p) {\n\tfloat glyphRatio = 2.0;\n\tvec2 glyphScale = 6. * vec2(1., glyphRatio);\n    \n\tvec2 t = floor(p / glyphScale + 1e-6);\n\n\tuint v = 0u;\n\tv = t.y == 1. ? ( t.x < 4. ? 1229865302u : ( t.x < 8. ? 4279372u : 0u ) ) : v;\n    v = t.x >= 0. && t.x < 16. ? v : 0u;\n\tfloat char = float((v >> uint(8. * t.x)) & 255u);\n\n\tvec2 posInCell = (p - t * glyphScale) / glyphScale;\n\tposInCell.x = (posInCell.x - .5) / glyphRatio + .5;\n\n\tfloat sdf = glyph_sdf(posInCell, char);\n\tif (char != 0.) {\n\t\tcolor = mix(vec3(.2), color, smoothstep(-.04, +.04, sdf));\n\t}\n    \n    p.x += 41.0;\n    \n    t = floor(p / glyphScale + 1e-6);\n\n\tv = 0u;\n    v = t.y == 0. ? ( t.x < 4. ? 1330925129u : ( t.x < 8. ? 1162368032u : ( t.x < 12. ? 1163019296u : 19777u ) ) ) : v;\n    v = t.x >= 0. && t.x < 16. ? v : 0u;\n\tchar = float((v >> uint(8. * t.x)) & 255u);\n\n\tposInCell = (p - t * glyphScale) / glyphScale;\n\tposInCell.x = (posInCell.x - .5) / glyphRatio + .5;\n\n\tsdf = glyph_sdf(posInCell, char);\n\tif (char != 0.) {\n        float m = clamp((p.x - 25.0) * 0.2, 0.0, 1.0);\n        vec3 text_color = mix(color_for_section(14), color_for_section(19), m);\n\t\tcolor = mix(text_color, color, smoothstep(-.04, +.04, sdf));\n\t}\n}\n\nvec3 image(vec2 uv) {\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec2 st = vec2(a, r);\n    st.x = st.x * 0.5 / PI + 0.5;\n    st.y = st.y * 1.0 / RADIUS*2.0;\n\n    float s_id = SECTIONS-1.0 - floor(st.x * SECTIONS);\n    float r_id = RINGS-1.0 - floor(st.y * RINGS);\n\n    int id = SECTION_IDS[int(r_id*SECTIONS+s_id)];\n    \n    return id == 0 || st.y > 1.0 ? vec3(0.85) : color_for_section(id);\n}\n\nmat2 rot2d(float a) {\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 color = vec3(0.0);  \n    \n    for (int m = 0; m < AA; ++m) {\n    for (int n = 0; n < AA; ++n) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord + o) - 0.5 * iResolution.xy) / iResolution.y;\n        vec3 col = image(uv);\n        uv *= rot2d(PI/4.0);\n        uv += vec2(0.395, 0.073);\n        uv *= 320.0;\n        text(col, uv);\n        color += col;    \n    }\n    }\n    \n    color /= float(AA*AA);\n    color.rgb = pow(color.rgb, vec3(1.0/2.2));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[633, 680, 706, 706, 938], [1085, 1140, 1177, 1177, 1352], [2624, 2624, 2645, 2645, 3041], [3043, 3043, 3064, 3064, 3113], [3115, 3115, 3172, 3172, 3709]], "test": "untested"}
{"id": "fdcGz2", "name": "Simple little pt", "author": "MinimilisticBits", "description": "sdfg", "tags": ["srst"], "likes": 5, "viewed": 324, "published": 3, "date": "1630722847", "time_retrieved": "2024-07-30T19:03:18.685038", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n      float colw = texture(iChannel0, uv).w;\n\n   vec3 col = texture(iChannel0, uv).xyz/(colw+1.);\n   // d.yz = rot(d.yz, mouse.y*90.);\n  //  d.xy = rot(d.xy, -mouse.x*90.);\n    \n    // Time varying pixel color\n    \n    col = vec3(1.)-exp(-1.0*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n//dunno, not mine\n//bit operations that give you a number between 0 and the maximum uint size which is\n//4294967296, dividing by the maximum gives you a number between 0 and 1\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\n///////////////////////////\n\nvec2 rot(vec2 a, float t){\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*3.14159-acos(a.x):acos(a.x);\n    ang += t*3.14159/180.;\n    return vec2(cos(ang), sin(ang))*l;\n}\n\n\nfloat l = 0.;\nvec3 c = vec3(0.7);\n\n\nfloat box(vec3 p, vec3 s){\nvec3 a = abs(p)-s;\nreturn max(a.x,max(a.y,a.z));\n}\nfloat escape = 0.;\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\n\n\n\nvec3 pal(float t, vec3 p){\nreturn 0.5 + 0.5*cos(2.*3.14159*t*0.9 + p);\n}\n\nfloat dis(vec3 p){\n    l = 0.;\n    c = vec3(.7);\n    float a = length(vec3(0.,7.,0.)-p)-1.3;\n    a = fractal((vec3(0.,0.,-0.0)-p)/6.)*6.;\n    float b = box(vec3(0.,4., -7.)-p, vec3(10.,10.,0.3));\n    float b2 = box(vec3(0.,4., 4.)-p, vec3(10.,10.,0.3));\n    float b3 = box(vec3(7.,4., 0.)-p, vec3(0.4,10.,10.3));\n    float b4 = box(vec3(-7.,4., 0.)-p, vec3(0.4,10.,10.3));\n    float b5 = box(vec3(-0.,14., 0.)-p, vec3(10.4,0.5,10.3));\n    float lig = box(vec3(0.,4., 2.3)-p, vec3(4.,4.,.004));\n\n    float fin = min(min(min(min(a,b),b2),min(b3,min(b4,b5))),lig);\n    fin = min(a,lig);\n    if(fin == a){\n        c = pal(escape, vec3(0.9,0.6,0.2));\n    }\n    if(fin == b){\n        c = vec3(0.5,0.5,0.8);\n    }\n    if(fin == b3){\n        c = vec3(0.2,0.9,0.2);\n    }\n    if(fin == b4){\n        c = vec3(0.8,0.2,0.2);\n    }\n    if(fin == lig){\n        l = 0.;\n       // c = vec3(0.8,0.2,0.2);\n    }\n    \n    \n    return fin;\n}\n\nvec3 beckmann_s(vec3 n, inout uint r, float a){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\n//float theta = sqrt(atan((-a*a*log(1.-r2))));\nfloat theta = acos(sqrt(1./(1.0-a*a*log(1.0-r2))));\nfloat x = cos(phi)*sin(theta);\nfloat y = sin(phi)*sin(theta);\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nbool trace(inout vec3 p, vec3 d, inout uint r){\n\n    for(int i = 0; i < 80; i++){\n        float dist = dis(p);\n        if(dist < 0.01)return true;\n        if(rndf(r) < 0.04){\n        d = beckmann_s(d, r, 0.04);\n        }\n        p+=d*dist;\n    }\n\n    return false;\n}\n\n\nvec3 norm(vec3 p){\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.03,p.yz))-dis(vec3(p.x-0.03,p.yz)),\n            dis(vec3(p.x,p.y+0.03,p.z))-dis(vec3(p.x,p.y-0.03, p.z)),\n            dis(vec3(p.x,p.y, p.z+0.03))-dis(vec3(p.x,p.y,p.z-0.03))\n        )\n    );\n}\n\n\nvec3 angledircos(vec3 n, inout uint r){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\nfloat theta = acos(sqrt(r2));\n\nfloat x = cos(phi)*sin(theta);\nfloat y = sin(phi)*sin(theta);\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nfloat beckmann_d(float cost, float rough){\nfloat aa = rough*rough;\nfloat a = exp(-((tan(cost)*tan(cost))/aa));\nfloat b = 3.14159*aa*pow(cos(cost), 4.);\nreturn a/b;\n}\nfloat beckmann_pdf(float cost, float rough){\nfloat aa = rough*rough;\nfloat a = exp(-((tan(cost)*tan(cost))/aa));\nfloat b = 3.14159*aa*pow(cos(cost), 3.);\nreturn a/b;\n}\n\n\n\n\nvec3 sun_cap(vec3 n, inout uint r, in float theta){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\n//float theta = sqrt(atan((-a*a*log(1.-r2))));\nfloat x = cos(phi)*sqrt(1.-cos(theta)*cos(theta));\nfloat y = sin(phi)*sqrt(1.-cos(theta)*cos(theta));\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nfloat lum(vec3 c){\nreturn 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}\n\nfloat powerh(float pdf1, float pdf2){\nreturn pdf1*pdf1/(pdf1*pdf1 + pdf2*pdf2);\n}\n\nfloat G(vec3 n, vec3 h, vec3 v, vec3 l){\nfloat a = (2.*max(dot(n,h),0.01)*max(dot(n,v),0.01))/max(dot(v,h),0.01);\nfloat b = (2.*max(dot(n,h),0.01)*max(dot(n,l),0.01))/max(dot(v,h),0.01);\nreturn min(1., min(a,b));\n}\n\nvec3 F(vec3 f0, float cost){\nreturn f0 + (1.0-f0)*pow(1.0-cost,5.);\n}\nvec3 light = normalize(vec3(0., 2., 1.5));\n\nvec3 render(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 cc = vec3(0.);\n    float lig = 0.;\n    vec3 tt = vec3(1.);\n    vec3 cam = p;\n    const int bounces = 8;\n    for(int i = 0; i < bounces; i++){\n        if(trace(p,d,r)){\n            cc = c;\n            lig = l;\n            vec3 wi = d;\n            vec3 n = norm(p);\n            p+=n*0.04;\n            bool nee = (int(fragCoord.x)/64 % 2 == 0);\n            //nee = true;\n            \n            float theta = 0.1;\n            //vec3 sun_cap(vec3 n, inout uint r, in float theta){\n            light = sun_cap(light, r, theta);\n            if(lig > 0.01 && nee){\n                col+=tt*lig;\n                break;\n            }\n                float num = 0.1;\n                float rough = 0.01;\n            float prob = rndf(r);\n                        d = angledircos(n,r);\n                        \n            if(prob > num)\n            {\n                   d = beckmann_s(reflect(wi,n), r, rough);\n            }\n   // float lig = box(vec3(0.,7., 2.3)-p, vec3(2.,2.,.04));\n            vec3 lpos = vec3(0.,4., 2.3); \n            vec2 offset = vec2(rndf(r), rndf(r))*8.0-4.0;\n            lpos.xy += offset;\n            vec3 ldir = lpos - p;\n            float dist2 = dot(ldir,ldir);\n            ldir = normalize(light);\n            vec3 brdf = cc/3.14159;\n            vec3 brdf2 = cc/3.14159;\n\n            float pdf = max(dot(d, n),0.01)/3.14159;\n            float pdf2 = max(dot(d, n),0.01)/3.14159;\n\n//float beckmann_d(float cost, float rough){\n\n            if(prob > num){\n                                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                //d = beckmann_s(reflect(wi,n), r, rough);\n//                float G(vec3 n, vec3 h, vec3 v, vec3 l){\n\n                                \n                vec3 h = normalize(d + -wi);\n                float D = beckmann_d(acos(max(dot(reflect(wi, n), d),0.01)), rough);\n                float Gg = G(n, h, -wi, d);\n                vec3 Ff = F(cc, max(dot(h, d),0.01));\n                vec3 specular = (D*Gg*Ff)/max(4.*max(dot(-wi, n),0.)*max(dot(d,n),0.),0.01);\n                pdf = beckmann_pdf(acos(max(dot(reflect(wi, n), d),0.01)), rough);\n                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                brdf = specular;\n               // brdf = max(brdf, 0.0);\n                \n                vec3 h2 = normalize(ldir + -wi);\n                float D2 = beckmann_d(acos(max(dot(reflect(wi, n), ldir),0.01)), rough);\n                float Gg2 = G(n, h2, -wi, ldir);\n                vec3 Ff2 = F(cc, max(dot(ldir, h),0.01));\n                vec3 specular2 = (D2*Gg2*Ff2)/max(4.*max(dot(-wi, n),0.)*max(dot(ldir,n),0.),0.05);\n                pdf2 = beckmann_pdf(acos(max(dot(reflect(wi, n), ldir),0.0)), rough);\n                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                brdf2 = specular2;\n               // brdf2 = max(brdf, 0.0);\n            }\n            pdf = max(pdf, 0.01);\n            pdf2 = max(pdf2,0.01);\n            \n            float pdf3 = 2.*3.14159*(1.0-cos(theta));\n\n            \n            vec3 holdp = p;\n            if(!trace(holdp,ldir,r)){\n               col += vec3(10.)*brdf2*tt*powerh(pdf3, pdf)*max(dot(ldir, n),0.01)/pdf3;\n            }\n            \n            holdp = p;\n            if(!trace(holdp,d,r) && acos(max(dot(light, d),0.)) < theta){\n                    col += vec3(10.)*tt*brdf*powerh(pdf, pdf3)*max(dot(d, n),0.01)/pdf;\n                    break;\n            }\n            \n            /*\n            \n            if(!nee){\n                if(lig > 0.01 && i == 0){\n                    col+=lig*tt;\n                    break;\n                }else if(lig > 0.01){\n                    break;\n                }\n                float area = 8.*8.;\n                vec3 nlight = vec3(0., 0., -1.);\n                if(p.z > lpos.z){\n                    nlight = vec3(0.,0.,1.);\n                }\n                vec3 holdp = p;\n                if(trace(holdp,ldir)){\n                    cc = c;\n                    lig = l;\n                    if(lig > 0.01 && dot(ldir, n) > 0. && dot(-ldir, nlight)>0.01){\n                    vec3 lss = vec3(1.,0.,0.);\n                        float pdf3 = dist2/(max(dot(-ldir, nlight),0.01)*area);\n                        pdf3 = max(pdf3, 0.01);\n                        if(prob > num){\n                            pdf3 = pdf2;\n                        }\n                        col += lig*brdf2*tt*powerh(pdf3, pdf)*max(dot(ldir, n),0.01)/pdf3;\n                    }\n                }\n                \n                holdp = p;\n                if(trace(holdp,d) && dot(d, n) > 0. && dot(-d, nlight)>0.01){\n                    if(l > 0.01){\n                        dist2 = dot(holdp-p, holdp-p);\n                        float pdf3 = dist2/(max(dot(-d, nlight),0.01)*area);\n                        col += l*tt*brdf*powerh(pdf, pdf3)*max(dot(d, n),0.01)/pdf;\n                        break;\n                    }\n                }\n            }\n            */\n            if(i > 3){\n                float ma = lum(tt);\n                if(rndf(r)>ma)break;\n                tt/=ma;\n            }\n             \n            tt*=brdf*max(dot(d,n),0.01)/pdf;\n            \n            if(i == 0){\n                vec3 dd = p - cam;\n                dd /= 5.0;\n                float accum;\n                for(int i = 0; i < 5; i++){\n                    cam += dd*rndf(r);\n                    vec3 mm = cam;\n                    if(!trace(mm, light,r)){\n                        accum += 1.;\n                    }\n                }\n                accum/=5.;\n                col += vec3(0.9,0.6,0.2)*accum*0.1;\n            }\n            \n        }else{\n         if(i == 0){\n                vec3 dd = p - cam;\n                float l = clamp(length(dd),0.,20.);\n                dd = normalize(dd)*l;\n                dd /= 5.0;\n                float accum;\n                for(int i = 0; i < 5; i++){\n                    cam += dd*rndf(r);\n                    vec3 mm = cam;\n                    if(!trace(mm, light,r)){\n                        accum += 1.;\n                    }\n                }\n                accum/=5.;\n                col += vec3(0.9,0.6,0.2)*accum*0.1;\n            }\n            col += tt*texture(iChannel0, d.xzy).xyz;\n            break;\n        }\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //not my code///////////////////////////////////\n      uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////////\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 offset = vec2(rndf(r), rndf(r))*2.0-1.0;\n   // offset *= 1.0/iResolution.xy;\n    vec2 fC = fragCoord.xy + offset;\n    vec2 uv = fC/iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n   vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/int(samples))%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n    if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\nfloat jk = float(iFrame%int(samples));\n    vec3 p = vec3(0.,-6.,1.);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    d.yz = rot(d.yz,30.);\n    d.xy = rot(d.xy, 0.);\n    \n    // Time varying pixel color\n    vec3 col = render(p,d,r,fragCoord);\n    \n    col = clamp(col,0.,1.);\n        //col = tonemap_uchimura2(col);\n        col = pow(col, vec3(1.4))*1.8;\n        col = pow(col, vec3(1./2.2));\n    if(jk != 0.){\n        col += texture(iChannel1, fragCoord.xy/iResolution.xy).xyz;\n    }\n    // Output to screen\n    fragColor = vec4(col,jk);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int tiles = 2;\nfloat samples = 50.;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [215, 215, 247, 247, 991], [1029, 1029, 1086, 1136, 1821]], "test": "untested"}
{"id": "7sc3WX", "name": "tunnel ci", "author": "jorge2017a1", "description": "tunnel ci", "tags": ["tunnelci"], "likes": 3, "viewed": 223, "published": 3, "date": "1630722435", "time_retrieved": "2024-07-30T19:03:19.753182", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1;\nvec3 light_pos2;  vec3 light_color2;\nvec3 light_pos3;  vec3 light_color3;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   p.y=p.y-12.0;\n    \n    p.z= opRep1D(p.z,27.0 );\n    \n    float sdh1= sdHexPrism(p, vec2(10.0,12.0) );\n    float sdh2= sdHexPrism(p, vec2(9.0,13.0) );\n    float sdif= differenceSDF(sdh1, sdh2);\n    vec3 p2=p-vec3(3.0,0.0,-7.0);\n    vec3 p3=p-vec3(-3.0,0.0,7.0);\n    p2= rotate_z( p2, radians(60.0));\n    p3= rotate_z( p3, radians(120.0));\n    \n    float c2=sdCylinderYZ(p2 ,vec2(1.0,12.0) );\n    float c3=sdCylinderYZ(p3 ,vec2(1.0,12.0) );\n    float c4=sdCylinderYZ(p-vec3(0.0,-3.0,0.0) ,vec2(1.0,12.0) );\n    res =opU3(res, vec3(sdif,100.0,-1.0));\n    res =opU3(res, vec3(c2,3.0,-1.0));\n    res =opU3(res, vec3(c3,4.0,-1.0));\n    res =opU3(res, vec3(c4,5.0,-1.0));\n    \n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n//Overly complicated starfield effect.\nvec3 render_sky_color(vec3 rd)\n{   \n    return vec3(0.0);\n    \n}\n\n//------------------------------------------------\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos3);\n        result/=1.5;\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 7.0, 10.0 ); light_color2 =vec3( 1.0 );\n    light_pos3= vec3( 0.0, 7.0, 0.0 ); light_color3 =vec3( 1.0 ); \n    \n   \n   float t1=mod(iTime,3.0);\n   float t2=mod(iTime,4.0);\n   vec3 ro;\n   if (t1<t2)\n    ro=vec3(0.0,7.0,-25.0+t*2.0);\n   else\n    ro=vec3(0.0,12.0,-25.0+t+4.0*t);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    light_pos3+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    vec3 col= mat3(tx*tx, ty*ty, tz*tz)*n;\n    return  (hsv(col-0.25)+col)/2.0; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 551, 551, 572], [573, 573, 605, 605, 689], [690, 690, 729, 729, 824], [825, 825, 864, 864, 959], [960, 960, 999, 999, 1094], [1096, 1140, 1187, 1187, 1214], [1215, 1215, 1258, 1258, 1285], [1286, 1286, 1334, 1334, 1362], [1363, 1401, 1437, 1437, 1482], [1483, 1548, 1582, 1582, 1678], [1679, 1679, 1713, 1713, 1804], [1805, 1805, 1839, 1839, 1930], [1973, 1973, 2009, 2009, 2282], [2284, 2324, 2349, 2349, 3133], [3135, 3186, 3210, 3210, 3372], [3374, 3374, 3423, 3423, 4090], [4092, 4179, 4215, 4215, 4460], [4461, 4516, 4543, 4543, 4560], [4562, 4562, 4598, 4598, 4690], [4691, 4691, 4737, 4737, 4862], [4864, 4864, 4938, 4938, 6539], [6540, 6595, 6644, 6644, 6887], [6888, 6922, 7002, 7002, 7125], [7126, 7206, 7238, 7238, 7270], [7324, 7376, 7469, 7469, 7787], [7790, 7790, 7821, 7821, 8502], [8504, 8553, 8579, 8579, 8689], [8691, 8691, 8749, 8749, 8801], [8803, 8852, 8909, 8909, 9673]], "test": "untested"}
{"id": "Ndc3Wf", "name": "mandelbrot newton fractal", "author": "peabrainiac", "description": "Newton fractal of the nth mandelbrot polynomial. Controls: WASD to move, up/down arrows to zoom, and left/right arrows to change the number of iterations.", "tags": ["fractal", "interactive", "zoomable"], "likes": 4, "viewed": 283, "published": 3, "date": "1630714190", "time_retrieved": "2024-07-30T19:03:20.584958", "image_code": "/*\n * Newton fractal of the nth mandelbrot polynomial or whatever... you\n * know, c^2+c for n=2, (c^2+c)^2+c for n=3 and so on. What makes this\n * interesting to me is that this fractal naturally but almost secretly\n * arises in the background when trying to find minibrots by applying\n * newton's method, in the form of the pattern of where the algorithm is\n * able to find a minibrot of the given period and where not.\n *\n * Controls:\n *  - left/right arrow keys: number of iterations/which polynomial is used\n *  - up/down arrow keys: zoom\n *  - WASD: moving around\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-\n * related code, while Buffer B contains all of the controls, together\n * with a bunch of code that is currently unused and has just been copied\n * over from one of my previous shaders.\n * This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float BAILOUT = 4096.0;\nconst int STEPS = 50;\nconst float A = 1.0;\n\nfloat color(vec2 c);\n\nfloat fractal(in vec2 startC, in int iter);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (false&&texelFetch(iChannel0,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel1,ivec2(fragCoord),0);\n    }else{\n        vec4 cameraPosition = texelFetch(iChannel0,ivec2(2,0),0);\n        vec2 dc = vec2(10.0/(length(iResolution)*cameraPosition.z),0.0);\n        vec2 c = cameraPosition.xy+dc.x*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5);\n        fragColor = vec4(vec3(color(c)),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nfloat color(vec2 c){\n    vec3 config = texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    int iter = int(config.z);\n    return fractal(c,iter);\n}\n\nfloat fractal(in vec2 startC, in int iter){\n    vec2 c = startC;\n    for (int step=0;step<STEPS;step++){\n        vec2 z = c;\n        vec2 dz = vec2(1.0,0.0);\n        int i;\n        for (i=0;i<iter;i++){\n            dz = 2.0*cmul(z,dz)+vec2(1.0,0.0);\n            z = cmul(z,z)+c;\n            if (dot(z,z)>1e12){\n                i++;\n                break;\n            }\n        }\n        vec2 temp = A*cdiv(z,dz)*pow(0.5,float(iter-i));\n        c -= temp;\n        if (dot(temp,temp)<1e-11&&i==iter){\n            return float(step)/float(STEPS);\n        }\n    }\n    return 1.0;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * Control buffer. Don't ask, I've written this months ago and only forked and tweaked this again and again since then.\n *\n * Stored values in the first row of pixels, in order:\n *  - refresh flag, animation flag, reset flag (unused)\n *  - formula id (unused), formula param (unused), iterations\n *  - X, Y, zoom, minibrot index\n */\n\nvec3 defaultAnimation(float t);\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (!(p.y==0&&p.x<=2)){\n        return;\n    }\n    // set up default values in the first frame\n    if (iFrame==0){\n        if (p==ivec2(0,0)){\n            // flags\n            fragColor = vec4(1.0,1.0,0.0,0.0);\n        }else if(p==ivec2(1,0)){\n            // iterations\n            fragColor = vec4(0.0,0.0,16.0,0.0);\n        }else if(p==ivec2(2,0)){\n            // position\n            fragColor = vec4(defaultAnimation(iTime),0.0);\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0,p,0);\n    if (p==ivec2(0,0)){\n        // flag updates\n        float keys = keysDown();\n        if (fragColor.y==1.0){\n            if (keys>0.0){\n                // animation end because of user input\n                fragColor.xyz = vec3(1.0,0.0,1.0);\n            }\n        }else{\n            //refresh flag update\n            fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n            fragColor.z = 0.0;\n        }\n    }else if(p==ivec2(1,0)){\n        // formula & iteration changes\n        fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT)))-1.0));\n    }else if(p==ivec2(2,0)){\n        vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n        vec4 cameraPosition;\n        // get/update camera position\n        if (flags.y==1.0){\n            // animation\n            cameraPosition = vec4(defaultAnimation(iTime),0.0);\n        }else{\n            // normal controls\n            cameraPosition = texelFetch(iChannel0,ivec2(2,0),0);\n            cameraPosition.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/cameraPosition.z;\n            cameraPosition.z *= pow(2.0,iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN)));\n        }\n        fragColor = cameraPosition;\n    }\n}\n\n// animation that plays until the first user input is received\nvec3 defaultAnimation(float t){\n    float theta = 0.3*t*t/(t+2.0);\n    float a = 0.5*theta-0.25*PI;\n    a = cos(a-0.5*sin(a));\n    float b = 1.0-abs(a);\n    b = b*b;\n    a = sign(a)*(1.0-b*b*b*b*b);\n    a = 0.5+0.5*a;\n    vec3 pos;\n    pos.xy = (0.625+a*0.125)*vec2(-sin(theta),-cos(theta))+vec2((a-1.0)*0.125,0.0);\n    pos.z = (3.0-2.0*a)*(1.0+3.0*t*t/(t*t+5.0));\n    return pos;\n}\n\n// number of relevant keys that are currently pressed\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_DOWN,KEY_UP,KEY_DOWN)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvec2 clog(vec2 a){\n    return vec2(0.5*log(dot(a,a)),atan(a.y,a.x));\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3Wf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[0, 2266, 2320, 2320, 2380]], "test": "untested"}
{"id": "fdcGDf", "name": "Neon Candy smoke", "author": "xenn", "description": "Cool huh?", "tags": ["simulation"], "likes": 17, "viewed": 651, "published": 3, "date": "1630708516", "time_retrieved": "2024-07-30T19:03:21.607225", "image_code": "\n// Fork off \"Mind wax\" by xenn. https://shadertoy.com/view/stSXDh\n// 2021-08-01 12:46:02\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel2,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel2,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel2,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// transform_coords and vignette function from https://luka712.github.io/2018/07/21/CRT-effect-Shadertoy-Unity/\n\nvec2 transform_coords(vec2 uv, float bend)\n{\n\tuv -= 0.5;\n    uv *= 1.9;\n    uv.x *= 1. + pow(abs(uv.y)/bend, 2.);\n    uv.y *= 1. + pow(abs(uv.x)/bend, 2.);\n    \n    uv /= 2.;\n    return uv + .5;\n}\n\nfloat vignette(vec2 uv, float size, float smoothness, float edgeRounding)\n{\n\tuv = (uv-.5) * size;\n    return smoothstep(0., smoothness, 1. - sqrt(pow(abs(uv.x), edgeRounding) + pow(abs(uv.y), edgeRounding)));\n}\n\n\n// end\n\n\nfloat grain(vec2 uv) {\n    return 1.0-0.75+0.75*rand(uv * iTime);\n}\n\nvec3 scanline(vec2 uv) {\n    vec2 color = vec2(sin(uv.y * iResolution.y * 1.), cos(uv.y * iResolution.y * 1.));\n\treturn vec3(color.x, color.y, color.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 curved_uv = transform_coords(uv, 2.);\n\n\tvec4 final_output = vec4(1.) * texture( iChannel0, transform_coords(uv, 3.14)); \n\n\tfinal_output*=vignette(curved_uv, .2, .6, .8);\n\t\n\tfinal_output*=vec4(scanline(curved_uv), 1.);\n\t\n\tfinal_output*=grain(curved_uv);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = final_output;\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col2,col,0.5);\n  \n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// subtle feedback loop: blend the last frame with the current one\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    vec3 s = step(0.5,blend);\n    return s * (sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend)) + (1.-s)*(2.*base*blend+base*base*(1.0-2.0*blend));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = texture(iChannel0, uv).rgb;\n    vec3 overlay = texture(iChannel1, uv).rgb;\n    vec4 col = vec4(base +(blendSoftLight(base, overlay*2.)), 1.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0015;\nconst float iFeedbackFadeRate         = .996;\nconst float iFeedbackColorShiftZoom   = 0.2;\nconst float iFeedbackColorShiftImpact = 0.002;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 0.71;\nconst float iBlobEdgeSmoothing        = .05;\nconst float iBlob1Radius              = .69;\nconst float iBlob1PowFactor           = 30.;\nconst float iBlob1ColorPulseSpeed     = .08;\nconst float iBlob2Radius              = .71;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     = -0.15;\nconst float iBlob2ColorPulseShift     = 0.;\nconst float iColorShiftOfRadius       = .1;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6 (\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gb - .5) * iFeedbackColorShiftImpact  * (0.1*abs(cos(iTime*0.1231))) ;\n    stShift += iFeedbackShiftVector ;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   vec3 extraColor = repeatedTexture(iChannel3, uv - stShift).rgb;\n    extraColor *= iFeedbackFadeRate;\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob1Radius ) , iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob2Radius ), iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n    color *  (extraColor * extraColor);\n    \n \n\n  \n //   fragColor = vec4(color, 1.);\n     vec4 col = texture(iChannel2,uv);\n  //     col -   clamp(col, 0., 2.5 );\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col2,col,0.5);\n  \n//      col -   clamp(col, 0., 2.5 );\n  \n//  fragColor=blend;\n    color -   clamp(color, 0., 2.5 );\n   fragColor = mix(blend,vec4(color, 1.0),0.5);\n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI          3.1415926\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat sgn(float x) { return (x<0.)?-1.:1.; }\nvec2  sgn(vec2  v) { return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\t}\n\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\nfloat pMirror (inout float p, float dist) {\n    float s = sgn(p);\n    p = abs(p)-dist;\n    return s;\n}\nvec2 pMirrorOctant (inout vec2 p, vec2 dist, float r) {\n    vec2 s = sgn(p);\n    pMirror(p.x, dist.x);\n    pMirror(p.y, dist.y);\n    p*=rot(r);\n    if (p.y > p.x) p.xy = p.yx;\n    return s;\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n//@iq\nfloat sdCap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// path functions \nvec2 path(in float z){ \n    vec2 p1 =vec2(2.3*sin(z * .15), 2.0*cos(z * .075));\n    vec2 p2 =vec2(1.7*cos(z * .06), 1.5*sin(z * .105));\n    return p1 - p2;\n}\nvec2 fragtail(vec3 pos) {\n    float scale = 3.;\n    float xcale = scale-1.;\n \tvec3 cxz = vec3(4.,4.,4.);\n    float r = 1e5;\n    float ss=.75;\n    \n    for (int i = 0;i<3;i++) {\n        pos=abs(pos);\n        if ( pos.x- pos.y<0.) pos.yx = pos.xy;\n        if ( pos.x- pos.z<0.) pos.zx = pos.xz;\n        if ( pos.y- pos.z<0.) pos.zy = pos.yz;\n        pos.x=scale * pos.x-cxz.x*xcale;\n        pos.y=scale * pos.y-cxz.y*xcale;\n        pos.z=scale * pos.z;\n        if (pos.z>0.5*cxz.z*xcale) pos.z-=cxz.z*xcale;\n        r = fBox2(pos.xy,vec2(scale));\n        ss*=1./scale;\n    }\n\n    return vec2(r*ss,2.);\n}\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\nvec2 curvature = vec2(4.,3.75);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 217, 217, 405], [407, 407, 464, 464, 1782]], "test": "untested"}
{"id": "NssXD7", "name": "Clouds fractals 3", "author": "MinimilisticBits", "description": "asdas", "tags": ["asdas"], "likes": 10, "viewed": 419, "published": 3, "date": "1630708033", "time_retrieved": "2024-07-30T19:03:22.604559", "image_code": "\nvec3 blur(vec2 uv, float r){\nvec3 c = texture(iChannel0, uv).xyz;\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec3 col = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyz;\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \nvec3 bokeh2(vec2 uv, float r){\n//float dist = texture(iChannel0, uv).w;\n//dist = (sqrt(dist)/8.)*dist*0.8;\nvec3 c;\nuv *= iResolution.xy;\n//float r = clamp(dist*.9,0., 20.);\n//r = clamp(1.0-exp(-(dist-1.6)*3.),0.,12.);\n//r = 1.;\nfloat iter;\nvec3 bk;\nfor(int i = 0; i < 150; i++){\nvec2 dir = vec2(float(i+1)*0.01*cos((float(i+1)*1.61803)*2.0*3.14159), \nfloat(i+1)*0.01*sin((float(i+1)*1.61803)*2.0*3.14159));\n//dir += offset;\ndir *= r*8.;\n//if(offset < 0.01){\n   vec3 col = texture(iChannel0, (uv+dir)/iResolution.xy).xyz;\n   //if(luminance(col)>0.6)col *= 4.;\n  // col = col * col * 3.3;\n   vec3 bkk = pow(col, vec3(4));\n   \n   c += col*bkk;\n   bk+=bkk;\n   iter+=1.;\n//}\n}\nreturn c/bk;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c = texture(iChannel0, uv);\n    vec3 col = c.xyz;\n    float dist = length(vec2(-0.,-0.)-(uv*2.0-1.0));\n   // vec3 col = blur(uv, (exp(.3*(dist-3.))*dist*dist*dist)*3.);\n    //vec3 col = bokeh2(uv, (exp(.9*(dist-3.))*dist)*5.);\n       // if(dist < 0.1)col+=1.;\n\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n    float ds = c.w;\n    //vec3 col = blur(uv, min((sqrt(ds)/8.0)*ds*2., 10.), 0.4);\n     //col+=vec3(0.7,0.7,0.7)* (sqrt(ds)/8.0)*ds*0.5;\n       // col = max(col,0.);\n       vec3 a = vec3(0.6,0.7,0.7)-0.4;\n       //col = mix(col, smoothstep(0.,1.,col),a);\n       col = vec3(1.)-exp(-2.6*col);\n      // col = col/(col+1./2.);\n       //col = ACESFilm(col);\n       col = pow(col, vec3(1.0/2.2));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": " const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc *= pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.0)?2.*pi-acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n\nfloat noise(vec3 uv){\nreturn fract(sin(uv.x*23. + uv.y*345.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\nfloat noise2(vec3 uv){\nvec3 f = floor(uv);\nvec3 i = fract(uv);\ni = smoothstep(0.,1.,i);\nfloat a = noise(f);\nfloat b = noise(f+vec3(1.,0.,0.));\nfloat c = noise(f+vec3(0.,1.,0.));\nfloat d = noise(f+vec3(1.,1.,0.));\nfloat e = noise(f+vec3(0.,0.,1.));\nfloat f2 = noise(f+vec3(1.,0.,1.));\nfloat g = noise(f+vec3(0.,1.,1.));\nfloat h = noise(f+vec3(1.,1.,1.));\n\nfloat m1 =  mix(mix(a,b,i.x),mix(c,d,i.x),i.y);\nfloat m2 =  mix(mix(e,f2,i.x),mix(g,h,i.x),i.y);\nreturn mix(m1,m2,i.z);\n}\n\nfloat fbm(vec3 uv){\nreturn noise2(uv)*0.5+noise2(uv*2.0)*0.25+noise2(uv*4.)*0.125+noise2(uv*8.)*0.0625;\n}\n\n\nfloat Tr(float densityMultiplier, float collectedDensity){\nreturn exp(-collectedDensity*densityMultiplier);\n}\n\nfloat Powder(float densityMultiplier, float collectedDensity){\nreturn 1.0 - exp(-collectedDensity*densityMultiplier*2.0);\n}\n\n//r = particle radius\n//wave = light wavelength\n// x<<1 Rayleigh scattering\n// x==1 Mie scattering (x < 1.01 && x > 0.997)\n// x>>1 Geometric scattering\nfloat phase(float r, float wave){\nreturn (2.0*3.14159*r)/wave;\n}\n\n//theta = dot between light and view vector(i think)\nfloat RayleighPhase(float theta){\nfloat a = 0.0596831036595;\nfloat b = (1.+theta*theta);\nreturn a*b;\n}\n\n//g = [0,1]\nfloat HenyeyGreensteinPhase(float g, float theta){\nfloat a = 1.0 - g*g;\nfloat b = 12.5663706144*pow(1.0+g*g-2.*g*theta,1.5);\nreturn a/b;\n}\n\n//Maybe -(a/b) is needed as it seems to be inverted\nfloat SchlickApproximationPhase(float g, float theta){\nfloat k = 1.55*g-0.55*g*g*g;\nfloat a = 1.0 - k*k;\nfloat sub = 1.0 + k*theta;\nfloat b = 12.5663706144*sub*sub;\nreturn -(a/b);\n}\n\n\n\n \n        #define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\nvec3 cc = vec3(1.);\n\n// simply scale the dual vectors\n\nvoid sphereFold(inout vec3 z) {\n\tfloat minRadius2 = 0.25;\n    float fixedRadius2 = 2.;\n    float r2 = dot(z,z);\n\tif (r2 < minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t} else if (r2 < fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z) {\nfloat foldingLimit = 2.;\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nfloat escape;\nvec4 orb; \nfloat DE2( vec3 p )\n{ \n    float s = 1.7;\n\tfloat scale = 1.0;\n    escape = 0.;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t//p = -1.0 + 2.0*fract(0.5*p+0.5);\n        p = mod(p*0.5 + 0.5, 1.)*2.0-1.0;\n\t\tfloat r2 = dot(p,p);\n\t\tescape += exp(-0.2*r2);\n        orb = min( orb, vec4(abs(p.xyz),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat m = 0.25*length(p.xz)/scale;\n    return (m < 0.001)?0.5:0.05;\n}\n\nfloat DE3(vec3 p0){\n   vec4 p = vec4(p0, 1.);\n       escape = 0.;\n\n   for(int i = 0; i < 8; i++){\n       \n        \n       // p*=4.2;\n        p.xyz = mod(p.xyz - 1., 2.)-1.;\n       //p.xyz = mod(p.xyz*0.5 + 0.5, 1.)*2.-1.;\n        float m = length(p.xyz);\nfloat r2 = dot(p.xyz,p.xyz);\n\t\tescape += exp(-0.2*r2);\np*=(1.7/r2);\n   }\n   p/=p.w;\n   float d  = 0.25*length(p.xz)/1.0;\n   return (d < 0.001)?0.5:0.08;\n}\n\nfloat escape2;\nfloat DEmine2(vec3 p){   \n    float d = 10e5;\n   // p.xz = rot2(p.xz,(-1.2 +0.3)*360./3.14159);\n    vec4 q = vec4(p,1);\n    escape = 0.;\n    escape2 = 9999999.;\n    for(float i = 0.; i < 12.; i++){\n         \n        //q = abs(q);\n        float as = dot(q.xyz, q.xyz);\n        escape2 = min(escape2, as);\n        escape += exp(-.2*as);\n        if( i == 4.)q.xyz = pmod(q.xyz,5.);\n        if( i == 7.)q.xyz = pmod(q.xyz, 5.);\n        if(i == 10.)q.xz=q.zx;\n        //if( i == 5.)q =abs(q)/dot(q.xyz,q.xyz);\n        q = abs(q);\n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        boxFold(q.xyz);\n        sphereFold(q.xyz);\n        //q.xz *= rot2(q.xz,(1.5*pi)*360./3.14159);\n          q.y -= 0.2*sin(i*4.)+0.25;\n          q.x -= sin(i)*8.;\n          q *= 1.34;\n\n    }\n    q.xyz /= q.w;\n    float ds = max(abs(q.x),abs(q.z));\n    ds = min(ds, length(q.yz)-0.);\n    ds -= 0.02;\n    return (ds<0.01)?0.5:0.05;\n}\n\nfloat len(vec3 p){\nreturn length(vec3(0.,-6.,0.)-p)-4.3;\n}\n\nvec3 orbitTrap;\n\n\nfloat DE(vec3 p){\n\tvec3 w = p;\n\tfloat m = dot(w, w);\n    orbitTrap = vec3(1.);\n\n    for(int i = 0; i < 8; i++){\n\t\tif(m > 1.2) break;\n\n\t\tfloat m2 = m*m;\n\t\tfloat m4 = m2*m2;\n\t\tfloat x = w.x; float x2 = x*x; float x4 = x2*x2;\n\t\tfloat y = w.y; float y2 = y*y; float y4 = y2*y2;\n\t\tfloat z = w.z; float z2 = z*z; float z4 = z2*z2;\n\t\tfloat k3 = x2 + z2;\n\t\tfloat k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n\t\tfloat k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n\t\tfloat k4 = x2 - y2 + z2;\n\t\tw.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n\t\tw.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n\t\tw.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n\t\tm = dot(w, w);\n        orbitTrap = min(abs(w*1.2), orbitTrap);\n\n\t}\n    //orbitTrap = 1.0-exp(-orbitTrap*2.);\n\treturn m > 1.2 ? 0.08 : 0.3 ;\n}\n\nvec3 color(vec3 p) {\n    float a = DE(p);\n    return 1.-orbitTrap;\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat box(vec3 p, float s){\nvec3 a = abs(p)-s;\nreturn max(max(a.x,a.y),a.z);\n}\n\nvec4 clouds(vec3 p, vec3 d, vec3 lig, inout float dd){\nvec3 col = vec3(0.);\n    const int iter = 283;\n    float shadow_dist = 183.;\n    float ss = 1.0/float(shadow_dist);\n    float trans = 1.;\n   \n    float transmittance = 1.;\n    vec3 tryTr = vec3(0.);\n    //float shadowstepsize = 1. / float(iter);\n\n    float density = 1.0;\n    //density *= ss;\n    vec3 lightenergy = vec3(0.);\n    vec3 lightpowder = vec3(0.);\n    float ShadowDensity = 4.;\n    float PowderDensity = 3.0;\n   \n    float t1;\n    float t2;\n    \n         float minus = 0.04;\n         float mult = 1.;\n         float rep = 6.;\n         \n   p = vec3(0.);\n   bool hit_obj = false;\n   for(int i = 0; i < 60; i++){\n     // float a = DEmine((mod(vec3(0., 0.,0.)-p.xyz,12.)-6.)/2.)*5.;\n     // float dist = max(a, length(vec3(0.,-6.,0.)-p)-4.3);\n     float dist = length(mod(vec3(0.,-2.,0.)-p,rep)-rep*0.5)-3.3;\n      if(dist < 0.001){hit_obj = true; break;}\n      p+=d*dist;\n   }\n   //return vec3(0.,1.,0.);\n   \n   // vec2 i = intersect2(p, d, vec3(0.), 2.3);\n   if(hit_obj){\n         //vec3 end = p+d*i.y;\n         //p = vec3(0.);\n         //p.zx = rot(p.zx, iTime*4.);\n         //p.yz = rot(p.yz, iTime*4.);\n        // p.y-=iTime*0.1;\n         bool hit_volume = false;\n         for(int i = 0; i < iter; i++){\n             float nos = DE3((mod(vec3(0.,1.4,0.)+p*mult,rep)-rep*0.5))-minus+fbm(p*2.3)-0.6;\n             if(nos > 0.01){\n             \n               vec3 lpos = p;\n               float shadowdist = 0.;\n               vec3 lm;\n               for (int s = 0; s < 20; s++)\n               {\n                 // if(DE(mod(lpos,12.)-6.) < 0.01){\n                    float lsample = DE3((mod(vec3(0.,1.4,0.)+lpos*mult,rep)-rep*0.5))-minus+fbm(lpos*2.3)-0.6;\n                    //if(nos < 0.05 && lsample > 0.1)lsample*=8.;\n                    shadowdist += clamp(lsample, 0., 1.);\n                    lpos += lig*ss;\n                    if(length(mod(vec3(0.,-2.,0.)-lpos,rep)-rep*0.5)-3.3 > 0.01)break;\n                    if(s == 10)lm = lpos;\n                    \n               }\n               \n               transmittance += clamp(nos,0.,1.);\n               trans *= 1.0 - (clamp(nos,0.,1.));\n               lightenergy += vec3(Tr(0.5*ShadowDensity, shadowdist)\n               ,Tr(1.*ShadowDensity, shadowdist),\n               Tr(2.*ShadowDensity, shadowdist))*trans*clamp(nos,0.,1.)\n               *(palette(escape*2.2, vec3(0.5), vec3(0.5), vec3(1.,1.,1.), vec3(0.0,.1,0.2))+0.1)*0.5;\n               //*color((mod(vec3(0.,1.4,0.)+lm*mult,2.)-2.*0.5));\n               lightpowder += vec3(Powder(0.5*PowderDensity, shadowdist)\n               ,Powder(1.*PowderDensity, shadowdist),\n               Powder(2.*PowderDensity, shadowdist))*trans*max(nos,0.);\n             }\n             p+=d*ss;\n             if(length(mod(vec3(0.,-2.,0.)-p,rep)-rep*0.5)-3.3 > 0.01)break;\n         }\n         \n         if(transmittance != 1.){\n         col = col*trans + lightenergy*lightpowder*2.;\n         }\n    }\n    return vec4(col,trans);\n}\n\nfloat ds(vec3 p){\n    vec3 a = vec3(0.,12.,0.)-p;\n    a.yz = rot(a.yz, iTime*20.);\n    a.xy = rot(a.xy, iTime*20.);\n    a = abs(a)-2.3;\n    return max(max(a.x,a.y),a.z);\n}\n\nvec3 normal(vec3 p){\nreturn normalize(\nvec3(\nds(vec3(p.x+0.01, p.yz))-ds(vec3(p.x-0.01, p.yz)),\nds(vec3(p.x, p.y+0.01,p.z))-ds(vec3(p.x, p.y+0.01,p.z)),\nds(vec3(p.xy,p.z+0.01))-ds(vec3(p.xy,p.z-0.01))\n)\n);\n}\n\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(3.14159*a);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nvec3 sky(vec3 d, vec3 ld){\nfloat thetas = dot(ld, vec3(0.,0.,1.));\nfloat theta = dot(d, vec3(0.,0.,1.));\n//if(theta < 0.0)return vec3(0.);\nfloat thetay = dot(d,ld);\nfloat y = acos(thetay);\nfloat taa = dot(-d, vec3(0.,0.,1.));\nfloat tay = dot(-d,ld);\nfloat Fred = (1.0 -1.32004*exp(0.14318/taa))*(1.0+5.30694*exp(-2.48062*y)+0.3167*tay*tay);\nfloat F2 = 1.0-(-0.523242)*(1.0+5.30694*exp(-2.48062*y)+0.3167*thetas*thetas);\nfloat Fblue = (1.0 + -0.27416*exp(-0.0668/taa))*(1.0+0.20388*exp(-1.68898*y)+0.04418*tay*tay);\nif(theta<0.03)return F2*F2*vec3(0.05,0.02,(thetas)*0.1);\n\nreturn 0.2*vec3((1.0 - thetas)*Fred, Fblue*0.4*max(ld.z,0.), Fblue) + F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv*=0.6;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //uv *= 0.6;\n    // if(iFrame < 20)discard;\n     //float tiles=10.;\n    int tiles = 3;\n    int samples = 3;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n    if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n\n    //int jk = iFrame%200;\n    \n    //uv*=2.;\n    //vec3 lig = normalize(vec3(0.,-1.,0.));\n    vec3 lig = normalize(vec3(0., -1.2, 0.));\n    vec3 d = normalize(vec3(uv.x, -1.0, uv.y));\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    //-0.8,0.4\n    d.xz = rot(d.xz, 90.);\n    d.yz = rot(d.yz,-50.);\n    d.xy = rot(d.xy,60.);\n   \n    vec3 p = vec3(0.,0.,0.);\n    //vec3 col = sky(d, lig);\n    vec3 col = vec3(0.);\n    float dd;\n   vec4 c = clouds(p,d,lig,dd);\n\n    col = col*c.w + c.xyz;\n    p = vec3(0.);\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n\n   \n    // Output to screen\n    fragColor = vec4(col,dd);\n}\n", "buffer_a_inputs": [], "common_code": "const float pis = 3.14159265358;\n\nvec2 rot2(vec2 a, float c){\nfloat g = c*pis/180.0;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\nfloat c_twopi = 3.14159*2.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 493], [1184, 1184, 1207, 1207, 1365], [1367, 1367, 1424, 1474, 2595]], "test": "untested"}
{"id": "sdXXDM", "name": "Clouds fractals 2", "author": "MinimilisticBits", "description": "sd", "tags": ["ds"], "likes": 7, "viewed": 353, "published": 3, "date": "1630707883", "time_retrieved": "2024-07-30T19:03:23.717582", "image_code": "\nvec3 blur(vec2 uv, float r){\nvec3 c = texture(iChannel0, uv).xyz;\nuv *= iResolution.xy;\nfloat iter = 0.;\nfor(int i = 0; i < 10; i++){\n  for(int k = 0; k < 10; k++){\n     float x = float(k)-5.;\n     float y = float(i)-5.;\n     x*=r;\n     y*=r;\n     //float bok = texture(iChannel1, vec2(0.5)+((vec2(x,y)*6.)/iResolution.xy)).y;\n     vec3 col = texture(iChannel0, (uv+vec2(x,y))/iResolution.xy).xyz;\n     //if(length(col) > 0.6)col*=1.2;\n     c += col;\n     iter+=1.;\n  }\n}\nc/=iter;\nreturn c;\n} \nvec3 bokeh2(vec2 uv, float r){\n//float dist = texture(iChannel0, uv).w;\n//dist = (sqrt(dist)/8.)*dist*0.8;\nvec3 c;\nuv *= iResolution.xy;\n//float r = clamp(dist*.9,0., 20.);\n//r = clamp(1.0-exp(-(dist-1.6)*3.),0.,12.);\n//r = 1.;\nfloat iter;\nvec3 bk;\nfor(int i = 0; i < 150; i++){\nvec2 dir = vec2(float(i+1)*0.01*cos((float(i+1)*1.61803)*2.0*3.14159), \nfloat(i+1)*0.01*sin((float(i+1)*1.61803)*2.0*3.14159));\n//dir += offset;\ndir *= r*8.;\n//if(offset < 0.01){\n   vec3 col = texture(iChannel0, (uv+dir)/iResolution.xy).xyz;\n   //if(luminance(col)>0.6)col *= 4.;\n  // col = col * col * 3.3;\n   vec3 bkk = pow(col, vec3(4));\n   \n   c += col*bkk;\n   bk+=bkk;\n   iter+=1.;\n//}\n}\nreturn c/bk;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 c = texture(iChannel0, uv);\n    //vec3 col = c.xyz;\n    float dist = length(vec2(-0.1,-0.1)-(uv*2.0-1.0));\n   // vec3 col = blur(uv, (exp(.3*(dist-3.))*dist*dist*dist)*3.);\n    vec3 col = bokeh2(uv, (exp(.9*(dist-3.))*dist)*9.);\n       // if(dist < 0.1)col+=1.;\n\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n    float ds = c.w;\n    //vec3 col = blur(uv, min((sqrt(ds)/8.0)*ds*2., 10.), 0.4);\n     //col+=vec3(0.7,0.7,0.7)* (sqrt(ds)/8.0)*ds*0.5;\n       // col = max(col,0.);\n       vec3 a = vec3(0.8,0.5,0.6);\n       col = mix(col, smoothstep(0.,1.,col),a);\n\n       col = ACESFilm(col);\n       col = pow(col, vec3(1.0/2.2));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": " const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc *= pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.0)?2.*pi-acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n\nfloat Tr(float densityMultiplier, float collectedDensity){\nreturn exp(-collectedDensity*densityMultiplier);\n}\n\nfloat Powder(float densityMultiplier, float collectedDensity){\nreturn 1.0 - exp(-collectedDensity*densityMultiplier*2.0);\n}\n\n//r = particle radius\n//wave = light wavelength\n// x<<1 Rayleigh scattering\n// x==1 Mie scattering (x < 1.01 && x > 0.997)\n// x>>1 Geometric scattering\nfloat phase(float r, float wave){\nreturn (2.0*3.14159*r)/wave;\n}\n\n//theta = dot between light and view vector(i think)\nfloat RayleighPhase(float theta){\nfloat a = 0.0596831036595;\nfloat b = (1.+theta*theta);\nreturn a*b;\n}\n\n//g = [0,1]\nfloat HenyeyGreensteinPhase(float g, float theta){\nfloat a = 1.0 - g*g;\nfloat b = 12.5663706144*pow(1.0+g*g-2.*g*theta,1.5);\nreturn a/b;\n}\n\n//Maybe -(a/b) is needed as it seems to be inverted\nfloat SchlickApproximationPhase(float g, float theta){\nfloat k = 1.55*g-0.55*g*g*g;\nfloat a = 1.0 - k*k;\nfloat sub = 1.0 + k*theta;\nfloat b = 12.5663706144*sub*sub;\nreturn -(a/b);\n}\n\n\n \n        #define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\nvec3 cc = vec3(1.);\n\n// simply scale the dual vectors\n\nvoid sphereFold(inout vec3 z) {\n\tfloat minRadius2 = 0.25;\n    float fixedRadius2 = 2.;\n    float r2 = dot(z,z);\n\tif (r2 < minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t} else if (r2 < fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z) {\nfloat foldingLimit = 2.;\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nvec2 mulz(vec2 s){\nreturn vec2(s.x*s.x - s.y*s.y,\n2.0*s.x*s.y);\n}\n\nfloat escape;\nfloat DEmine(vec3 p){   \n    float d = 10e5;\n\n    //p.xz = rot2(p.xz,(-1.2 +0.3)*360./3.14159);\n    vec4 q = vec4(p,1);\n    mat3 lol;\n    escape = 0.;\n    for(float i = 0.; i < 12.; i++){\n        \n        \n        float as = dot(q.xyz, q.xyz);\n        escape += exp(-.2*as);\n        if( i == 5.)q.y = pmod(q.y,31.1);\n        if( i == 3.)q.y = pmod(q.y,31.1);\n        //if(i == 1.)q.yx /= dot(q.xyz,q.xyz);\n        \n        \n        \n        q = abs(q);\n        \n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        \n        if(q.x > q.y) q.yx = q.xy;\n        \n       boxFold(q.xyz);\n       //boxFold(q.xyz);\n        \n        sphereFold(q.xyz);\n       // q.xz *= rot2(q.xz,(1.5*pi)*360./3.14159);\n       // q.xyz -= vec3(.5,0.,2.5 )*0.05;\n        //q.xyz += dot(q.xyz, q.xyz)*0.1;\n        q.y -= 0.1*sin(i*4.) + 0.5;\n        q.x -= sin(i)*8.;\n        q *= 2.;\n    }\n    \n    \n    q.xyz /= q.w;\n    \n    d = max(abs(q.x),abs(q.z));\n    d = min(d, length(q.yz));\n    d -= 0.02;\n\n\n    return (d < 0.01)?0.3:0.08;\n\n}\n\n\nvec4 orb; \nfloat DE2( vec3 p )\n{ \n    float s = 1.7;\n\tfloat scale = 1.0;\n    escape = 0.;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\tescape += exp(-0.2*r2);\n        orb = min( orb, vec4(abs(p.xyz),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat m = 0.25*length(p.xz)/scale;\n    return (m < 0.001)?0.3:0.08;\n}\n\n\nfloat escape2;\nfloat DEmine2(vec3 p){   \n    float d = 10e5;\n   // p.xz = rot2(p.xz,(-1.2 +0.3)*360./3.14159);\n    vec4 q = vec4(p,1);\n    escape = 0.;\n    escape2 = 9999999.;\n    for(float i = 0.; i < 12.; i++){\n         \n        //q = abs(q);\n        float as = dot(q.xyz, q.xyz);\n        escape2 = min(escape2, as);\n        escape += exp(-.2*as);\n        if( i == 4.)q.xyz = pmod(q.xyz,5.);\n        if( i == 7.)q.xyz = pmod(q.xyz, 5.);\n        if(i == 10.)q.xz=q.zx;\n        //if( i == 5.)q =abs(q)/dot(q.xyz,q.xyz);\n        q = abs(q);\n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        boxFold(q.xyz);\n        sphereFold(q.xyz);\n        //q.xz *= rot2(q.xz,(1.5*pi)*360./3.14159);\n          q.y -= 0.2*sin(i*4.)+0.25;\n          q.x -= sin(i)*8.;\n          q *= 1.34;\n\n    }\n    q.xyz /= q.w;\n    float ds = max(abs(q.x),abs(q.z));\n    ds = min(ds, length(q.yz)-0.);\n    ds -= 0.02;\n    return (ds<0.01)?0.3:0.0;\n}\n\nfloat len(vec3 p){\nreturn length(vec3(0.,-6.,0.)-p)-4.3;\n}\n\nvec3 orbitTrap;\n\n\nfloat DE(vec3 p){\n\tvec3 w = p;\n\tfloat m = dot(w, w);\n    orbitTrap = vec3(1.);\n\n    for(int i = 0; i < 8; i++){\n\t\tif(m > 1.2) break;\n\n\t\tfloat m2 = m*m;\n\t\tfloat m4 = m2*m2;\n\t\tfloat x = w.x; float x2 = x*x; float x4 = x2*x2;\n\t\tfloat y = w.y; float y2 = y*y; float y4 = y2*y2;\n\t\tfloat z = w.z; float z2 = z*z; float z4 = z2*z2;\n\t\tfloat k3 = x2 + z2;\n\t\tfloat k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n\t\tfloat k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n\t\tfloat k4 = x2 - y2 + z2;\n\t\tw.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n\t\tw.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n\t\tw.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n\t\tm = dot(w, w);\n        orbitTrap = min(abs(w*1.2), orbitTrap);\n\n\t}\n    //orbitTrap = 1.0-exp(-orbitTrap*2.);\n\treturn m > 1.2 ? 0.08 : 0.3 ;\n}\n\nvec3 color(vec3 p) {\n    float a = DE(p);\n    return 1.-orbitTrap;\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec4 clouds(vec3 p, vec3 d, vec3 lig, inout float dd){\nvec3 col = vec3(0.);\n    const int iter = 183;\n    float shadow_dist = 40.;\n    float ss = 1.0/float(shadow_dist);\n    float trans = 1.;\n   \n    float transmittance = 1.;\n    vec3 tryTr = vec3(0.);\n    //float shadowstepsize = 1. / float(iter);\n\n    float density = 1.0;\n    //density *= ss;\n    vec3 lightenergy = vec3(0.);\n    vec3 lightpowder = vec3(0.);\n    float ShadowDensity = 1.3;\n    float PowderDensity = 3.0;\n   \n    float t1;\n    float t2;\n    \n         float minus = 0.04;\n         float mult = 1.;\n         float rep = 6.;\n         \n   p = vec3(0.);\n   bool hit_obj = false;\n   for(int i = 0; i < 60; i++){\n     // float a = DEmine((mod(vec3(0., 0.,0.)-p.xyz,12.)-6.)/2.)*5.;\n     // float dist = max(a, length(vec3(0.,-6.,0.)-p)-4.3);\n     float dist = length(mod(vec3(0.,-2.,0.)-p,rep)-rep*0.5)-3.3;\n      if(dist < 0.01){hit_obj = true; break;}\n      p+=d*dist;\n   }\n   //return vec3(0.,1.,0.);\n   \n   // vec2 i = intersect2(p, d, vec3(0.), 2.3);\n   if(hit_obj){\n         //vec3 end = p+d*i.y;\n         //p = vec3(0.);\n         //p.zx = rot(p.zx, iTime*4.);\n         //p.yz = rot(p.yz, iTime*4.);\n        // p.y-=iTime*0.1;\n         bool hit_volume = false;\n         for(int i = 0; i < iter; i++){\n             float nos = DE2((mod(vec3(0.,1.4,0.)+p*mult,rep)-rep*0.5))-minus;\n             if(nos > 0.01){\n             \n               vec3 lpos = p;\n               float shadowdist = 0.;\n               vec3 lm;\n               for (int s = 0; s < 20; s++)\n               {\n                 // if(DE(mod(lpos,12.)-6.) < 0.01){\n                    float lsample = DEmine((mod(vec3(0.,1.4,0.)+lpos*mult,rep)-rep*0.5))-minus;  \n                    shadowdist += clamp(lsample, 0., 1.);\n                    lpos += lig*ss;\n                    //if(length(mod(vec3(0.,-2.,0.)-lpos,rep)-rep*0.5)-3.3 > 0.01)break;\n                    if(s == 10)lm = lpos;\n                    \n               }\n               \n               transmittance += clamp(nos,0.,1.);\n               trans *= 1.0 - (clamp(nos,0.,1.));\n               lightenergy += vec3(Tr(0.5*ShadowDensity, shadowdist)\n               ,Tr(1.*ShadowDensity, shadowdist),\n               Tr(2.*ShadowDensity, shadowdist))*trans*clamp(nos,0.,1.)\n               *(palette(escape*2.2, vec3(0.5), vec3(0.5), vec3(1.,1.,1.), vec3(0.0,.1,0.2))+0.1);\n               //*color((mod(vec3(0.,1.4,0.)+lm*mult,2.)-2.*0.5));\n               lightpowder += vec3(Powder(0.5*PowderDensity, shadowdist)\n               ,Powder(1.*PowderDensity, shadowdist),\n               Powder(2.*PowderDensity, shadowdist))*trans*max(nos,0.);\n             }\n             p+=d*ss;\n             if(length(mod(vec3(0.,-2.,0.)-p,2.)-1.)-3.3 > 0.01)break;\n         }\n         \n         if(transmittance != 1.){\n         col = col*trans + lightenergy*lightpowder*2.;\n         }\n    }\n    return vec4(col,trans);\n}\n\nfloat ds(vec3 p){\n    vec3 a = vec3(0.,12.,0.)-p;\n    a.yz = rot(a.yz, iTime*20.);\n    a.xy = rot(a.xy, iTime*20.);\n    a = abs(a)-2.3;\n    return max(max(a.x,a.y),a.z);\n}\n\nvec3 normal(vec3 p){\nreturn normalize(\nvec3(\nds(vec3(p.x+0.01, p.yz))-ds(vec3(p.x-0.01, p.yz)),\nds(vec3(p.x, p.y+0.01,p.z))-ds(vec3(p.x, p.y+0.01,p.z)),\nds(vec3(p.xy,p.z+0.01))-ds(vec3(p.xy,p.z-0.01))\n)\n);\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(3.14159*a);\n}\n\n//NOT MY CODE//////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\n//////////////////////////////////\nvec3 sky(vec3 d, vec3 ld){\nfloat thetas = dot(ld, vec3(0.,0.,1.));\nfloat theta = dot(d, vec3(0.,0.,1.));\n//if(theta < 0.0)return vec3(0.);\nfloat thetay = dot(d,ld);\nfloat y = acos(thetay);\nfloat taa = dot(-d, vec3(0.,0.,1.));\nfloat tay = dot(-d,ld);\nfloat Fred = (1.0 -1.32004*exp(0.14318/taa))*(1.0+5.30694*exp(-2.48062*y)+0.3167*tay*tay);\nfloat F2 = 1.0-(-0.523242)*(1.0+5.30694*exp(-2.48062*y)+0.3167*thetas*thetas);\nfloat Fblue = (1.0 + -0.27416*exp(-0.0668/taa))*(1.0+0.20388*exp(-1.68898*y)+0.04418*tay*tay);\nif(theta<0.03)return F2*F2*vec3(0.05,0.02,(thetas)*0.1);\n\nreturn 0.2*vec3((1.0 - thetas)*Fred, Fblue*0.4*max(ld.z,0.), Fblue) + F2*F2*vec3(0.1,0.07,(thetas)*0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    uv *= 0.6;\n    // if(iFrame < 20)discard;\n    int tiles = 3;\n    int samples = 3;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n    if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    //int jk = iFrame%200;\n    \n    //uv*=2.;\n    //vec3 lig = normalize(vec3(0.,-1.,0.));\n    vec3 lig = normalize(vec3(1., 1.2, 0.));\n    vec3 d = normalize(vec3(uv.x, -1.0, uv.y));\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    //-0.8,0.4\n    d.yz = rot(d.yz,-30.);\n    d.xy = rot(d.xy,30.);\n   \n    vec3 p = vec3(0.,0.,0.);\n    //vec3 col = sky(d, lig);\n    vec3 col = vec3(0.);\n    float dd;\n   vec4 c = clouds(p,d,lig,dd);\n\n    col = col*c.w + c.xyz;\n    p = vec3(0.);\n    /*for(int i = 0; i < 20; i++){\n    float dist = ds(p);\n    if(dist < 0.01){\n    vec3 n = normal(p);\n    col = vec3(0.4,0.3,0.1)*max(dot(n, lig),0.3)+max(clouds(vec3(0.), reflect(d,n), lig),0.2)*0.2\n    +rough(0.1, dot(reflect(d,n), -lig))*0.1;\n    break;\n    }\n    p+=d*dist;\n    }*/\n    //col = ACESFilm(col);\n    //col = pow(col, vec3(1.0/2.2));\n\n   \n    // Output to screen\n    fragColor = vec4(col,dd);\n}\n", "buffer_a_inputs": [], "common_code": "const float pis = 3.14159265358;\n\nvec2 rot2(vec2 a, float c){\nfloat g = c*pis/180.0;\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y,a.x)+g; \nreturn vec2(l*cos(ang),l*sin(ang));\n}\nfloat c_twopi = 3.14159*2.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 493], [1184, 1184, 1207, 1207, 1365], [1367, 1367, 1424, 1474, 2521]], "test": "untested"}
{"id": "Ns33DX", "name": "Elastic cube", "author": "avin", "description": "visual experiment", "tags": ["cube", "elastic"], "likes": 12, "viewed": 392, "published": 3, "date": "1630704556", "time_retrieved": "2024-07-30T19:03:24.590249", "image_code": "\n#define DISPLAY_GAMMA 1.5\nconst float PI = 3.14159265359;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    float t = iTime*.5;   \n    float pm = floor(t);\n    \n    float sn = sin(fract(t) * PI);\n    \n    sn *= sn * .005;\n    \n    vec4 color = vec4(1.);\n    if(mod(pm, 2.) != 0.){        \n        vec4 c1 = texture(iChannel0, uv-vec2(0.,sn*1.5)).rgba;\n        vec4 c2 = texture(iChannel0, uv+vec2(0.,sn*1.5)).rgba;\n        vec4 c3 = texture(iChannel0, uv).rgba;\n        color = vec4(c1.r, c2.b, c3.g, 1.);\n    } else {\n        vec4 c1 = texture(iChannel0, uv+vec2(sn,0.)).rgba;\n        vec4 c2 = texture(iChannel0, uv-vec2(sn,0.)).rgba;\n        vec4 c3 = texture(iChannel0, uv).rgba;\n        color = vec4(c1.r, c2.b, c3.g, 1.);        \n    }\n         \n    vec3 col = color.rgb;              \n    \n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------    \n    \n    //tone mapping\n    col = vec3(1.7, 1.8, 1.9) * col / (1.0 + col);    \n\n    // Color control\n    col = 0.5 * col + 0.5 * col * col * (3.0 - 2.0 * col);\n\n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.3);\n\n    // Fade in\n    col *= smoothstep(0.0, 1.0, iTime);    \n    \n    color.rgb = col;\n    \n    // -----------------------------------------------------\n    \n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.14159265359;\nconst float fov = 40.0;\n\nconst float S = 0.0001;\n\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n// --------------------------------\n\nfloat deg2rad(float d) { return PI * d / 180.0; }\nfloat rad2deg(float r) { return 180.0 * r / PI; }\n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    float half_angle = angle*0.5;\n    return vec4(axis*sin(half_angle), cos(half_angle));\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 q, vec3 p)\n{\n    vec4 conj = quatConj(q);\n    vec4 q_tmp = quatMul(q, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\n// --------------------------------\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) { \n    vec3 q = abs(p) - b; \n    return length(max(q,0.1)) + min(max(q.x,max(q.y,q.z)),0.0) - r; \n}\n\n\nfloat distanceToNearestSurface(vec3 p){   \n    float t = iTime*.5;   \n    float pm = floor(t);\n    float dF = .5;\n    float pf = fract(t) * (1. + dF);\n    \n    float rs = .1;\n\n    if(mod(pm, 2.) != 0.){\n        float rpf = max(min(pf + (p.z*rs-.25), 1.), 0.);\n        float a = (cos(rpf * PI) * PI * 2.) / 2.;        \n        vec4 q = quatAxisAngle(vec3(0.,0.,1.), a);\n        \n        p = rotate(q, p);               \n    } else {\n        float rpf = max(min(pf + (p.y*rs-.25), 1.), 0.);\n        float a = (cos(rpf * PI) * PI * 2.) / 2.;        \n        vec4 q = quatAxisAngle(vec3(0.,1.,0.), a);\n        \n        p = rotate(q, p);               \n    }\n    \n\n    return sdRoundBox(p, vec3(1.), 0.);                        \n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec4 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 40; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        \n        vec3 hit = p+dir*dist;\n        vec3 light = vec3(100.0, 30.0, 50.0);\n        result = computeLambert(hit, computeSurfaceNormal(hit), light);\n        result += hit*.2;            \n        \n        dist += nearest;\n    }\n    return vec4(result, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 backCol = texture(iChannel0, uv).rgb;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0, 5.0, 10.0);\n\tvec3 cameraDirection = vec3(-1.0, -.50, -1.0);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n      \n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec4 ir = intersectWithWorld(cameraPosition, rayDirection);\n    vec3 tCol = ir.rgb;\n    float tDepth = ir.a*.25;\n    float fog = 1.0 / (1.0 + tDepth * tDepth * 0.01);  \n    vec3 col = mix(vec3(0.0), tCol, fog);\n    \n    col = clamp(col, vec3(0.0), vec3(1.));\n      \n    col = mix(col*col, backCol,0.75);    \n            \n\tfragColor = vec4(col, 1.);        \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns33DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 1530]], "test": "untested"}
{"id": "sls3Ds", "name": "basic pt direct light 27", "author": "MinimilisticBits", "description": "sdggs", "tags": ["sdfsg"], "likes": 13, "viewed": 445, "published": 3, "date": "1630703005", "time_retrieved": "2024-07-30T19:03:25.722223", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz/float(iFrame+1);\n    col = vec3(1.)-exp(-3.6*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.3,1.4,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    //pythagoras theorem\n    float l = length(a);\n    a/=l;\n  \n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n   \n    return vec2(cos(ang),sin(ang))*l;\n}\n\n\nfloat box(vec3 p, vec3 s){\n    vec3 a = abs(p)-s;\n    return max(max(a.x,a.y),a.z);\n}\nfloat escape;\nfloat DE(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n        p*=(1.2/dot(p.xyz,p.xyz));\n//the higher the dot product of p is, the less will be added to escape        \n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //normalization\n    p/=p.w;\n    return abs(p.x)*0.25;\n}\n\nfloat DE2(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n        \n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        p = abs(p);\n        //p.xy = rot(p.xy, 5.);\n        //p*=(1.1/dot(p.xyz,p.xyz));\n        //p*=0.4;\n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n        p*=1.2;\n    }\n    p/=p.w;\n    return abs(p.z)*0.25;\n}\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5+0.5*cos(2.*3.14159*t*a + b);\n}\n\n/////////////////////////////////\n\nvec3 fold(vec3 p0){\nvec3 p = p0;\n//if(abs(p.x) > 1.)p.x = 1.0-p.x;\n//if(abs(p.y) > 1.)p.y = 1.0-p.y;\n//if(abs(p.z) > 1.)p.z = 1.0-p.z;\nif(length(p) > 1.)return p;\np = mod(p,2.)-1.;\n\nreturn p;\n}\n\n\n\n\nfloat es2;\nfloat DE1(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    es2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.9,0.4);\n        //p*=1.4;\n\n        es2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEe(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat esp;\nfloat DEe2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat esp2;\nfloat DEe3(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat escape6;\nfloat DE45(vec3 p0){\n//p0 = mod(p0, 4.)-2.;\n    vec4 p = vec4(p0, 1.);\n    escape6 = 0.;\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        \n        p=abs(p);\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),-0.1,1.));\n        p.xyz-=vec3(.5,1.3,0.2);\n        escape6 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEbox(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        p.xyz = -abs(p.xzy);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.25/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.6,0.5);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEg(vec3 p0){\nescape = 999999.;\n    vec4 p = vec4(p0, 1.);\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n        escape = min(escape, dot(p.xyz,p.xyz));\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEgg(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(3.6,1.9,0.5);\n       //p*=1.1;\n\n        //escape = min(escape, dot(p.xyz,p.xyz));\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DEx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(1.5,2.2,0.6);\n       //p*=1.1;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\nfloat escape2;\nfloat DEex(vec3 p0){\np0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.5/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DExx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.15/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DExx2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat dis2(vec3 p){\nreturn DExx2((vec3(3.3,2.5,8.6)-p)/10.)*10.;\n}\n\nfloat DEeex(vec3 p0){\n//p0 = mod(p0, vec3(4.,4.,20.))-vec3(4.,4.,20.)*0.5;\n    vec4 p = vec4(p0, 1.);\n    escape = 999999.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xzy);\n\n        p*=(1.48/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.1;\n\n        escape = min(escape,dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEef(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xzy);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.zxy);\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.8,1.));\n        p.xyz-=vec3(0.8,.8,.4);\n        p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n//dunno, not mine\n//bit operations that give you a number between 0 and the maximum uint size which is\n//4294967296, dividing by the maximum gives you a number between 0 and 1\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n///////////////////////////\n\n\nfloat DEe22(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 99.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.6+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7+rndf(seed)*0.4,1.0,0.5);\n        p*=1.3-rndf(seed)*0.2;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\n        vec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe33(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 999.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),0.4,1.));\n        p.xyz-=vec3(2.3,3.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\nvec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\nfloat DEe44(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 14; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.24/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,2.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe55(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,1.8,1.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe66(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 22; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.15/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(.6,.8,.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\nescape = min(escape, dot(p.xyz,p.xyz));\n       // escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe77(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.3/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.+rndf(seed),1.0,2.2);\n        p.xyz = -abs(p.xyz+rndf(seed));\n        //p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n//NOT MY CODE////////\n \t\n\n \nfloat de(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.5,1.,0.5);\n    }\n    return length(p)/DEfactor-.0005;\n}\n\n\nfloat de2(vec3 p){\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2./min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\nfloat de3(vec3 p){\np = mod(p,2.)-1.;\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2.7/min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\n\nfloat dee(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    escape = 0.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.1,1.2,0.5);\n        escape += exp(-0.2*dot(p,p));\n    }\n    return length(p)/DEfactor-.0005;\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));    \n}\nvec4 formula(vec4 p) {\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n    p.xy*=rot(.5);\n    return p;\n}\nfloat screen(vec3 p) {\n    float d1=length(p.yz-vec2(.25,0.))-.5;    \n    float d2=length(p.yz-vec2(.25,2.))-.5;    \n    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));\n}\nfloat de23(vec3 pos) {\n    vec3 tpos=pos;\n    escape = 0.;\n    tpos.z=abs(2.-mod(tpos.z,4.));\n    vec4 p=vec4(tpos,1.5);\n    float y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n    for (int i=0; i<19; i++) {\n    p=formula(p);\n    escape += exp(-0.2*dot(p,p));\n    }\n    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n    float sc=screen(tpos);\n    return min(sc,fr);    \n}\n\n \t\n\nfloat de12(vec3 p){\n  float s=4.;\n  float l=0.;\n  p.z-=.9;\n  vec3 q=p;\n  s=2.;\n  for(int j=0;j++<12;)\n    p-=clamp(p,-1.,1.)*2.,\n    p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,\n    s*=l;\n  return length(p)/s;\n}\n\n////////////\nfloat de22(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n    p=abs(p);\n    if(p.x < p.z)p.xz = p.zx;\n    if(p.z < p.y)p.zy = p.yz;\n    if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        p = abs(p);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.1,1.));\n        p.xyz-=vec3(0.2,1.9,0.6);\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz)); \n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    return (length(p.xyz)/p.w);\n}\n\n\n\n\n//JB's Collection of fractals + code\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nfloat smin_op(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = 0.1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\nvoid box_fold(inout vec3 z, inout float dz) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat de222(vec3 z) {\n  vec3 offset = z;\n  float scale = -2.8;\n  float dr = 1.0;\n  escape = 0.;\n  for(int n = 0; n < 15; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    escape += exp(-0.2*dot(z.xyz,z.xyz));\n  }\n  float r = length(z);\n  return r / abs(dr);\n}\nvoid box_fold(inout vec3 z) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat DEer(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               // p.xyz = abs(p.xyz);\n\n        //box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.,1.0));\n        p.xyz=abs(p.xyz)-vec3(3.5,.5,3.3);\n       //p*=1.2;\np.yxz -= sin(float(i)*1.)*0.9;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n//===============================\nfloat rota = 83.;\nfloat rotb = 10.;\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n    c = vec3(0.9);\n    a2 = 0.01;\n    prob = 0.;\n    l = 0.;\n    //float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    //float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    //float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\n    //float b2 = box(vec3(-5.,-59.5,15.)-p, vec3(22.,0.00000000000004,22.));\n    //    vec3 p = vec3(11.9,12.5, 0.);\n\n    //float aa = DEe77((vec3(-0.,0.,4.0)-p)/10.)*10.;\n        float aa2 = DEer((vec3(-0.,28.,-0.0)-p)/10.)*10.;\n       \n    float plane = p.z + (5.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n    //float plane = length(vec3(15.,0.,0.)-p)-4.;\n\n    (sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n    //float final = min(min(min(min(min(aa,plane),aaa),aa5),aa4),aa44);\n   // float final = min(min(min(min(aa,aaaa),a22),aa44),plane);\n    float final = aa2;\n    vec3 color = vec3(0.5,0.5,0.8);\n   // if(final == aa){a2 = 0.1;prob=0.9;c=vec3(0.5);}\n       if(final == aa2){a2 = 0.1;prob=0.9;c=pal(escape, vec3(0.9), vec3(0.2,0.2,0.9));}\n    \n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float t = pow(r2, 2./(1.+a));\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n//same explanation as above:\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.03;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k){\n    for(int i = 0; i < 160; i++){\n        dd = dis(p,l,c,a,prob);\n        if(dd<0.01)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n//uv += 1000.;\n//numbers so large that looks like random noise\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n//nice trick, basically pick a random vector W, doesn't matter, as long as it's not equal to N\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n//Get the perpendicular of the T and N, which will give you the y axis    \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    //phi is an angle between 0 and 2pi, using the cos(phi),sin(phi), gives us the \n    //full rotation on the x and y axis, but we need to scale it down depending on z\n    //if z is pointing up, then sin(theta) will return 0, if theta is equal to pi/2, then it will\n    //return 1.. and finally to get z axis, simply return cos(theta), which will return 1 at angle 0\n    //this is because cos and sin simply return the coordinates of x and y depending on a certain angle\n    //you can see this if you construct a right angle triangle inside of the circle\n    //cos(x) would be equal to the horizontal length divided by the length of the diagonal side\n    //I need to learn mathematical jargon\n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n    //float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    //float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    //float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\n//Preetham sky model implemented by me, using the research paoer\nvec3 skyp2(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n//return vec3(0.1);\n//if(costheta<0.01)return vec3(0.);\n//simple cie sky\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\n//vec3 template = vec3(*T+,*T+,*T+);\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 lig = normalize(vec3(0.2,0.2,.9));\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 6;\n    float k = 0.;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.05;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\n            d = angledircos(n,r);\n        \n            float number = rndf(r);\n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*vec3(0.9,0.5,0.5);\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n            ldir = normalize(lig);\n          \n            vec3 brdf = c/3.14159 ;\n            \n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            vec3 lightdir = anglephong(100000., lig, r);\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2) && dot(lightdir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                col += tt*brdf2*vec3(0.9,0.7,0.5)*dot(lightdir,n);\n                //break;\n            }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                  \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                  \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/        \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            \n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n\n           /*if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }*/\n            if(i==0){\n                col = tt*skyp2(d, lig)*0.3;\n            }else{\n                col += tt*skyp2(d, lig)*0.7;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n\n    int tiles = 2;\n    int samples = 10;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    \n   // if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n   // if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n    uv *= 0.9;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //uv*=1.5;\n  //  uv*=0.7;\n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = vec3(0.,-0.0, -3.0);\n    \n    \n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    float focaldist = 6.4;\n    float radius = 0.02;\n\n    vec3 camdirection = vec3(0.,1.,0.);\n    camdirection.yz = rot(camdirection.yz, rota);\n    camdirection.xy = rot(camdirection.xy, rotb);\n    vec3 sidex = vec3(1.,0.,0.);\n    vec3 sidey = vec3(0.,0.,1.);\n   // sidex.yz = rot2(sidex.yz,rota);\n    //sidex.xz = rot(sidex.xz, -20.);\n   // sidex.yz = rot(sidex.yz,rota);\n    sidex.xy = rot(sidex.xy,rotb);\n    \n    //sidey.xz = rot(sidey.xz,-20.);\n    sidey.yz = rot(sidey.yz,rota);\n    //sidey.xy = rot(sidey.xy,rotb);\n    \n    float ang = rndf(r)*2.0*3.14159;\n    float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n    float scale = sqrt(rndf(r))*radius;\n   //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 offset = vec2(scale*cos(ang), scale*(sin(ang)));\n    //NOT MY CODE////////////////////////\n    vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n    /////////////////////////////////////\n    \n   // vec3 focuspoint = p+(d*focaldist);\n    //p.xz += offset;\n   p = p + sidex*offset.x;\n    p = p + sidey*offset.y;\n    d = normalize(focuspoint - p);\n    \n    \n    vec3 col = renderpixel(p,d, r, fragCoord);\n    col = clamp(col,0.,1.);\n   // if(jk != 0){\n    col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n   // }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [251, 251, 308, 308, 834]], "test": "untested"}
{"id": "NscGDX", "name": "mandel magnifier", "author": "elenzil", "description": "super quick experiment at zooming just a region of the MS.\nclick on an interesting spot and drag around.", "tags": ["mandelbrotzoom"], "likes": 8, "viewed": 345, "published": 3, "date": "1630697886", "time_retrieved": "2024-07-30T19:03:26.871151", "image_code": "vec2 complexMul(in vec2 A, in vec2 B) {\n  return vec2((A.x * B.x) - (A.y * B.y), (A.x * B.y) + (A.y * B.x));\n}\n\n// adapted from IQ. I may have messed this up.\n// https://iquilezles.org/articles/distancefractals\nfloat mandelDist(in vec2 c, float numIters)\n{\n  vec2  z = vec2(0.0, 0.0);\n  vec2 dz = vec2(0.0, 0.0);\n  \n  float m2;\n  for (float n = 0.0; n < numIters; ++n) {\n    dz = 2.0 * complexMul(z, dz) + vec2(1.0, 0.0);\n    z  = complexMul(z, z) + c;\n\n    m2 = dot(z, z);\n    if (m2 > 1.0e10) {\n      break;\n    }\n  }\n  \n  return sqrt(m2 / dot(dz, dz)) * 0.5 * log(m2);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float canvasZoom = 0.8;\n    float smoothEpsilon = 5.0 / RESMIN / canvasZoom;\n    \n    vec4 ioData = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 rawMouse = ioData.xy;\n\n    \n    vec2 p1 = (XY       - RES.xy / 2.0) / RESMIN * 2.0 / canvasZoom;\n    vec2 m  = (rawMouse - RES.xy / 2.0) / RESMIN * 2.0 / canvasZoom;\n    \n    if (length(iMouse.xy / RESMIN) <  0.2) {\n        // auto\n        float t = iTime * 0.1;\n        float r = 0.7;\n        m.x  = cos(t * 1.00) * r + 0.25;\n        m.y  = sin(t * 1.00) * r;\n        m.x += cos(t * 0.21) * r * 0.1;\n        m.x += sin(t * 0.21) * r * 0.1;\n    }\n    \n    float magnificationPower = 2000.0;\n    \n    m .x -= 0.5;\n    p1.x -= 0.5;\n    \n    // todo: use gradient of mandelbrot to nudge focus towards the set.\n\n    vec2 p2 = p1;\n    p2 -= m;\n    p2 /= magnificationPower;\n    p2 += m;\n    \n    float overallBulgeSize = 1.0;\n    float q = smoothstep(0.0, overallBulgeSize, length(p1 - m));\n    \n    // more iterations with higher zoom\n    const float minIters =   100.0;\n    const float maxIters = 10000.0;    \n    float iters = floor(mix(maxIters, minIters, pow(q, 0.5)) / 2.0) * 2.0;\n\n    float regionOfMaxZoom = 5.0;\n    q = pow(q, regionOfMaxZoom);\n    \n    vec2 p = mix(p2, p1, q);\n    \n    \n    float d = smoothstep(0.0, smoothEpsilon, abs(length(p) - 1.0));\n    \n    d = mandelDist(p, iters);\n    d = pow(d, 0.1);\n    d = sin(d) * 0.5 + 0.5;\n    \n    // grid\n    vec2 g = fract(p * 2.0 + 0.5) - 0.5;\n    d *= minComponent(0.8 + 0.2 * smoothstep(0.0, smoothEpsilon, abs(g)));\n    \n    RGBA = vec4(vec3(d), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RES    (iResolution)\n#define RESMIN (min(RES.x, RES.y))\n\nfloat minComponent(in vec2 v) {\n    return min(v.x, v.y);\n}", "buffer_a_code": "// mouse smoothing\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel0, IJ, 0);\n    vec4 mb = texelFetch(iChannel0, ivec2(1), 0);\n    \n    bool mouseIsDown  = iMouse.z > 1.0;\n    bool mouseWasDown = mb.x > 0.5;\n    \n    if (iFrame < 2) {\n        RGBA.xy = iMouse.xy;\n    }\n \n     if (IJ == ivec2(0)) {\n        // tuned for 60fps\n        \n        if (mouseIsDown) {\n            if (!mouseWasDown) {\n                RGBA.zw = iMouse.xy;\n            }\n            \n            vec2 d = iMouse.xy - RGBA.zw;\n            \n            if (!mouseWasDown && length(RGBA.xy - RGBA.zw) > RESMIN * 0.2) {\n                RGBA.xy = RGBA.zw;\n            }\n            else {            \n                RGBA.xy += d * 0.0001;\n            }\n        }\n     }\n     else if (IJ == ivec2(1)) {\n         RGBA.x = mouseIsDown ? 1.0 : 0.0;\n     }\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 110], [112, 211, 256, 256, 573], [575, 575, 620, 620, 2185]], "test": "untested"}
{"id": "fdcGDX", "name": "RayCubesOrtho", "author": "hjd3481", "description": " Ray-marching multiple cubes. Tiled to reduce cost. 4 cubes per tile.  set SYNCH_ROT to 0 for random rotations. Added some AO. Added an ENV map.\nThe tileRepeat can be set to anything ( i.e draw thousands of cubes) without increasing cost of the shader.", "tags": ["raymarching", "raymarching", "cube", "marching"], "likes": 14, "viewed": 428, "published": 3, "date": "1630697005", "time_retrieved": "2024-07-30T19:03:27.762767", "image_code": "#define MAX_DIST 6.0\n#define MAX_STEPS 22\n\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n\n//0 for a random rotation, 1 for a wave-like synchronised rotation\n#define SYNCH_ROT 1\n\n//1 for environment map\n#define ENV_MAP 1\n\n/////////////////////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/////////////////////////////////////////////////////////////////\n//https://iquilezles.org/articles/distfunctions\nfloat getDistanceBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationX(const float fRadians)\n{\n    mat4 m;\n     float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(1.0f,\t0.0f,\t0.0f, 0.0f);\n    m[1] = vec4(0.0f,\tfC,\t\tfS, 0.0f );\n    m[2] = vec4(0.0f,\t-fS,\tfC, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationY(const float fRadians)\n{       \n    mat4 m;\n    float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(fC,\t0.0f,\t-fS, 0.0f );\n    m[1] = vec4(0.0f,\t1.0f,\t0.0f, 0.0f );\n    m[2] = vec4(fS,\t0.0f,\tfC, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nmat4 getRotationZ(const float fRadians)\n{\nmat4 m;\n    float fC = cos(fRadians);\n    float fS = sin(fRadians);\n    m[0] = vec4(fC,\tfS,\t\t0.0f, 0.0f);\n    m[1] = vec4(-fS,\tfC,\t\t0.0f, 0.0f );\n    m[2] = vec4(0.0f,\t0.0f,\t1.0f, 0.0f);\n    m[3] = vec4(0.0f,0.0f,0.0f,1.0f);\n    return m;\n}\n/////////////////////////////////////////////////////////////////\nmat4 getBoxTransform( vec3 rot, vec3 loc )\n{\n    mat4 mx = getRotationX(rot.x);\n    mat4 my = getRotationY(rot.y);\n    mat4 mz = getRotationZ(rot.z);\n    \n    mat4 m = mx * my * mz;    \n    m[3] = vec4( loc, 1.0 );\n    \n    return m;\n}\n\n/////////////////////////////////////////////////////////////////\n\nfloat GetRotatedBoxDist(vec3 pos,int boxIndexX, int boxIndexY, vec2 tileIndex )\n{\n    const float roundingValue = 0.025;\n\n    vec3 boxIndex = vec3(boxIndexX,boxIndexY,0);      \n    vec3 boxRand = hash32( tileIndex+boxIndex.xy);\n#if !SYNCH_ROT  \n    //randomized rotations based on the global box-index\n    vec3 vecRot = vec3(iTime+1381.0) * boxRand * vec3(0.398121, 0.4011321, 0.39877874 ) + (boxRand.zyx * vec3(0.44654,0.6212,0.511112));\n#else\n    //rotate in unison plus some per-tile offset for some sweeping waves in the rotations\n    vec3 vecRot = vec3(0.235*iTime+6.0) + vec3((tileIndex + boxIndex.xy),0) * vec3(0.09105) + boxRand * 0.111;\n#endif\n    mat4 boxTransform = getBoxTransform( vecRot, vec3(0,0,0) );\n    vec3 boxOrigin = (pos - boxIndex*vec3(2.0))+vec3(1);\n    vec3 rotPos = vec3( vec4(boxOrigin,1) * boxTransform );            \n    vec3 boxScale = vec3( mix( 0.9, 1.33, sin((iTime+3.1)*boxRand.y*0.9867133)*0.5+0.5));\n    return getDistanceBox( rotPos, boxScale ) - roundingValue;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat GetD( vec3 pos, vec2 tileIndex )\n{\n   float d = MAX_DIST;\n  \n   //per box, get a rotation matrix for the box, transfom the position around the box and get the distance.\n   // add a small rounding value for a slight bevel and less noise.\n  \n   d = min( d, GetRotatedBoxDist(pos, 0,0,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 1,0,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 0,1,tileIndex) );\n   d = min( d, GetRotatedBoxDist(pos, 1,1,tileIndex) );\n   \n   return d;\n}\n\n/////////////////////////////////////////////////////////////////\n\nfloat DoRay( vec3 co, vec3 vd, vec2 tileIndex )\n{\n    vec3 p = co;\n    float dc = 0.0;\n        \n    for( int i=0; i < MAX_STEPS; i++)\n    {  \t\n\t\tfloat ds = GetD(p, tileIndex);\n        //move up ray\n        dc += ds;\n        p += vd * ds;\n        if( ds < 0.01 || dc >= MAX_DIST )\n        {         \n            break;\n        }        \n    }\n    \n    return min(dc,MAX_DIST);\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 GetN( vec3 surf_pos, vec2 tileIndex )\n{\n    float ds = GetD( surf_pos, tileIndex );\n    float du = GetD( surf_pos - vec3(0.01,0.00,0.00), tileIndex);  \n    float dv = GetD( surf_pos - vec3(0.00,0.01,0.00), tileIndex);\n    float dw = GetD( surf_pos - vec3(0.00,0.00,0.01), tileIndex);\n    \n    vec3 n = ds - vec3(du,dv,dw);\n    return normalize(n);\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 Light( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n            \n    return lightCol * I * Imag;\n}\n\n/////////////////////////////////////////////////////////////////\n\nvec3 LightShad( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol, vec2 tileIndex )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n    \n    float shad_surf_dist = DoRay( surf_pos + (world_normal * 0.02), surf_to_light, tileIndex );    \n    if( shad_surf_dist < MAX_DIST && shad_surf_dist < light_dist )\n    {\n\t\tI = 0.03;\n    }\n        \n    return lightCol * I * Imag;\n}\n\n/////////////////////////////////////////////////////////////////\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Light settings\n    const vec3  ambientLight   = vec3(0.05,0.075,0.1) * 1.3;\n    const vec3  lightCol       = vec3(0.96,0.85,0.691);\n    const float lightIntensity = 0.61;\n    \n    const float specularPower  = 190.0;\n    const vec3  specularCol    = lightCol * 0.33;\n    \n    const float envMapBrightness = 0.61;\n    \n    //zoom settings\n    const float zoomMin = 4.0; // number of tiles vertically\n    const float zoomMax = 12.0; //number of tiles vertically\n    const float zoomSpeed = 0.1137;\n    \n    \n    //centre the UVs around the middle of the texture so that the zoom-pivot is in the middle, rather than the bottom-left\n    vec2 uv = (fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec2 startUV = uv;\n    \n    //zooms in and out\n    float tileRepeat = mix( zoomMax, zoomMin, cos(iTime*zoomSpeed)*0.5+0.5 );  //start off zoomed in at zero time\n \n    //Chop up unit-UVs to get Tile Index and new UV\n    vec2 tileIndex = floor(uv * tileRepeat) + vec2(10); //the +10 helps the hashfunction (hash(0) returns 0)\n    uv = fract(uv * tileRepeat)*2.0-1.0; //want uv-origin in the middle of the tile\n    \n    //offset light to compensate for tile-offsets ( extra offset because we shifted the tileIndex origin to avoid hash(0) )\n    vec3 lightPos = vec3( 20.0, 26.0, 9.0 ) - vec3(tileIndex*2.0,0);\n       \n    //Camera - orthographic to prevent perspective projecton - keeps tiles seamless. \n    // You could add a viewport offset projection to have seamless tiled projective camera but \n    // ortho is cheaper and suits this implementation.\n\tvec3 raydir = normalize( vec3(0,0,-1) ); //look straight down z\n    vec3 rayPos = vec3(uv,5.0);  //Spread rays out based on tile-pixel-position, move camera back by 5\n     \n    //Position\n    float d = DoRay( rayPos, raydir, tileIndex );\n    vec3 surfPos = rayPos + (raydir * d);   \n    vec3 worldNormal = (d < MAX_DIST) ? GetN(surfPos, tileIndex ) : vec3(0,0,1);\n    \n    vec3 col = vec3(0);\n         \n    //Light\n    col += LightShad( surfPos, lightPos, worldNormal,  lightCol * lightIntensity, tileIndex );\n    \n    //Ambient\n    col += ambientLight;\n    \n    //AO\n    //Thanks to https://www.shadertoy.com/user/ENDESGA for the idea to add some AO based on the depth\n    col *= smoothstep( 1.1, 0.76, vec3(d/MAX_DIST) ); //set to col = smoothstep... to preview.\n       \n#if ENV_MAP\n    vec3 env = texture( iChannel0, worldNormal.xyz + vec3(startUV * 0.315, 0.0), 0.0 ).rgb;\n    env *= envMapBrightness;\n    col += (env * env);   \n#endif //ENV_MAP\n\n    //specular\n    vec3 surf_to_light = lightPos - surfPos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float spec = 0.0;\n    vec3 refl = reflect( -surf_to_light, worldNormal );\n    spec = clamp(dot( refl, -raydir ), 0.0, 1.0);\n    col += vec3( pow( spec, specularPower )) * specularCol;\n\t\n    \n    \n  \n   //depth visualize\n   //col = smoothstep( 1.0, 0.0, vec3(d/MAX_DIST) );\n   \n   //normal visualize\n   //col = worldNormal;\n   \n   //tile vizualize\n   //col *= hash32(tileIndex)+0.5;     \n   \n\n                 \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 535, 556, 556, 692], [694, 808, 848, 848, 935], [1004, 1004, 1045, 1045, 1290], [1359, 1359, 1400, 1400, 1651], [1720, 1720, 1761, 1761, 2002], [2003, 2069, 2113, 2113, 2304], [2373, 2373, 2454, 2454, 3373], [3441, 3441, 3481, 3481, 3929], [3998, 3998, 4047, 4047, 4375], [4444, 4444, 4488, 4488, 4798], [4867, 4867, 4946, 4946, 5256], [5325, 5325, 5424, 5424, 5926], [5999, 5999, 6056, 6077, 9185]], "test": "untested"}
{"id": "fstGD2", "name": "大龙猫 - Asleep From Day ", "author": "totetmatt", "description": "For once, a shader that doesn't try to kill you. Breath and enjoy.", "tags": ["cloud", "fly"], "likes": 5, "viewed": 322, "published": 3, "date": "1630692350", "time_retrieved": "2024-07-30T19:03:28.615487", "image_code": "/*\nMostly a rip off of https://iquilezles.org/articles/fbmsdf\n*/\nfloat box3(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n     return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.z,q.y)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat qqq(vec3 p){\n    vec3 id = floor(p);\n    p = fract(p)-.5;\n    float h = length(p)-(.25-.15*fract(10.*sin(100.*id.x*id.y-id.z*100.)) );\n  \n    return h;\n}\n\nvec3 op;\n// Iq sdFbm\nfloat sdFbm( vec3 p, float d )\n{\n   float s = 1.0;\n   for( int i=0; i<11; i++ )\n   {\n       // evaluate new octave\n       float n = s*qqq(p);\n      //p.xy*=rot(-.785*float(i)+float(i));\n       // add\n       n = smax(n,d-0.1*s,0.3*s);\n       d = smin(n,d      ,0.3*s);\n    \n       // prepare next octave\n       p = mat3( 0.00, 1.60, 1.20,\n                -1.80, 0.72,-0.96,\n                -1.20,-1.96, 1.28 )*p;\n       s = 0.5*s;\n   }\n   return d;\n}\nvec3 tp;\nvec2 sdf(vec3 p){\n   tp =p;\n   p.z +=iTime*.01;\n   op =p ;\n    vec2 h;\n    h.x = dot(p,vec3(0.,1.,0.))+.2;\n   \n    float q = sdFbm(p,h.x); \n    h.x = mix(q,abs(q)-.01,.5);\n    h.y = 1.;\n\n    vec2 t ;\n    \n    tp.y +=.05;\n    tp.z +=4.85;\n    \n    tp.xz*=rot(.6);\n    t.x = box3(tp,vec3(.25,.005,.05-abs(tp.x*tp.x)*0.3));\n    tp.x-=.15;\n    tp.y+=.015;\n    t.x = min(max(abs(tp.z)-.05,length(tp.xy)-.02),t.x);\n    t.y = 2.;\n    h = t.x <= h.x ? t:h;\n    return h;\n    \n}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro =  mod(iTime,30.) < 10. ? vec3(0.,0.0,-5.): vec3(0.,-.1,5.);\n        vec3 rt = mod(iTime,30.) < 10. ? vec3(45.,0.,.0): vec3(0.,-.15,100.);\n    vec3 rp = ro;\n        vec3 z = normalize(rt-ro);\n        vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n        vec3 y = normalize(cross(z,x));\n        \n    vec3 rd = normalize(mat3(x,y,z)*vec3(uv,1.));\n\n\n    vec3 light = vec3(1.,50.,-0.);\n    vec3 col = mix(vec3(.3,.5,.8),vec3(.1,.5,.9),clamp(uv.y,0.,1.));\n    vec3 acc = vec3(0.);\n    float dd = 0.;\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        dd +=abs(d.x);\n        if(dd > 25.) break;\n        if(d.y==1.){\n        acc += vec3(1.)*exp(128.*-abs(d.x))/(256.-sin(op.z*op.x+iTime)*50.);\n                d.x = max(.0011,abs(d.x));\n        }\n\n        if(length(rp) > 50.) break;\n        if(d.x <.001){\n            vec3 n = norm(rp,.003);\n            float dif = dot(normalize(light-rp),n);\n            col = vec3(.5)*dif;\n            \n            break;\n        }\n        rp +=rd*d.x;\n    \n    }\n    col +=acc;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28035, "src": "https://soundcloud.com/azuresunmusic/50-000-miles-high-chemical-bros-rmxd-by-points-g-azuresunrecords", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 91, 91, 183], [184, 184, 202, 202, 249], [251, 251, 290, 290, 375], [377, 377, 417, 417, 446], [448, 448, 466, 466, 607], [618, 630, 662, 662, 1079], [1089, 1089, 1106, 1106, 1558], [1585, 1585, 1611, 1611, 1689], [1690, 1690, 1745, 1745, 2877]], "test": "untested"}
{"id": "st2Gzh", "name": "basic pt direct light 28", "author": "MinimilisticBits", "description": "sdfsg", "tags": ["sdfsdg"], "likes": 28, "viewed": 880, "published": 3, "date": "1630683808", "time_retrieved": "2024-07-30T19:03:29.754442", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz/float(iFrame+1);\n    col = vec3(1.)-exp(-3.6*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.3,1.4,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    \n    c = c * pi/180.;\n    //pythagoras theorem\n    float l = length(a);\n    \n    a/=l;\n   \n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n   \n    return vec2(cos(ang),sin(ang))*l;\n}\n\n\nfloat box(vec3 p, vec3 s){\n\n    vec3 a = abs(p)-s;\n\n    return max(max(a.x,a.y),a.z);\n}\nfloat escape;\nfloat DE(vec3 p0){\n\n    vec4 p = vec4(p0, 1.);\n\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.2/dot(p.xyz,p.xyz));\n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //normalization\n    p/=p.w;\n    return abs(p.x)*0.25;\n}\n\nfloat DE2(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    for(int i = 0; i < 8; i++){\n        p.xyz = mod(p.xyz-1., 2.)-1.;\n        \n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        p = abs(p);\n       \n                escape += exp(-0.2*dot(p.xyz,p.xyz));\n        p*=1.2;\n    }\n    p/=p.w;\n    return abs(p.z)*0.25;\n}\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5+0.5*cos(2.*3.14159*t*a + b);\n}\n\n/////////////////////////////////\n\nvec3 fold(vec3 p0){\nvec3 p = p0;\n//if(abs(p.x) > 1.)p.x = 1.0-p.x;\n//if(abs(p.y) > 1.)p.y = 1.0-p.y;\n//if(abs(p.z) > 1.)p.z = 1.0-p.z;\nif(length(p) > 1.)return p;\np = mod(p,2.)-1.;\n\nreturn p;\n}\n\n\n\n\nfloat es2;\nfloat DE1(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    es2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.9,0.4);\n        //p*=1.4;\n\n        es2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEe(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat esp;\nfloat DEe2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat esp2;\nfloat DEe3(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    esp2 = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n      // p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.0,1.));\n        p.xyz-=vec3(0.3,4.5,0.7);\n        //p*=1.4;\n\n        esp2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\n\nfloat escape6;\nfloat DE45(vec3 p0){\n//p0 = mod(p0, 4.)-2.;\n    vec4 p = vec4(p0, 1.);\n    escape6 = 0.;\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        \n        p=abs(p);\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),-0.1,1.));\n        p.xyz-=vec3(.5,1.3,0.2);\n        escape6 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEbox(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        p.xyz = -abs(p.xzy);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.25/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n        p.xyz-=vec3(0.3,1.6,0.5);\n        //p*=1.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n  // return box(p.xyz, vec3(0.08));\n}\n\nfloat DEg(vec3 p0){\nescape = 999999.;\n    vec4 p = vec4(p0, 1.);\n        p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n        escape = min(escape, dot(p.xyz,p.xyz));\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEgg(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.8/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(3.6,1.9,0.5);\n       //p*=1.1;\n\n        //escape = min(escape, dot(p.xyz,p.xyz));\nescape += exp(-0.2*dot(p.xyz,p.xyz));\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\nreturn length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DEx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),.0,1.));\n        p.xyz-=vec3(1.5,2.2,0.6);\n       //p*=1.1;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\nfloat escape2;\nfloat DEex(vec3 p0){\np0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p=abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.5/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DExx(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.15/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat DExx2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n    //p.z = -p.z;\n\n        p.xyz=abs(p.xyz);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 8; i++){\n        //p.xyz = clamp(p.xyz, vec3(-2.3), vec3(2.3))-p.xyz;\n        //p.xyz += sin(float(i+1));\n\n       \n        //p = abs(p);\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n       //p.xyz = fold(p.xyz);\n       // p.xyz = fold(p.xyz);\n        p.xyz = abs(p.xyz);\n\n       // p.xyz = fract(p.xyz*0.5 - 1.)*2.-1.0;\n       // p.xyz = mod(p.xyz-1., 2.)-1.;\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),.4,1.));\n        p.xyz-=vec3(0.3,0.2,1.6);\n       //p*=1.1;\n\n        escape = exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    //p.xyz = fold(p.xyz);\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    //p/=p.w;\n   // p = clamp(p, -0.1,1.2);\n    return length(p.xyz)/p.w;\n // return box(p.xyz, vec3(0.8));\n}\n\nfloat dis2(vec3 p){\nreturn DExx2((vec3(3.3,2.5,8.6)-p)/10.)*10.;\n}\n\nfloat DEeex(vec3 p0){\n//p0 = mod(p0, vec3(4.,4.,20.))-vec3(4.,4.,20.)*0.5;\n    vec4 p = vec4(p0, 1.);\n    escape = 999999.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xzy);\n\n        p*=(1.48/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7,1.8,0.5);\n        p*=1.1;\n\n        escape = min(escape,dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEef(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xzy);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.zxy);\n\n        p*=(1.6/clamp(dot(p.xyz,p.xyz),0.8,1.));\n        p.xyz-=vec3(0.8,.8,.4);\n        p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n\n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n//dunno, not mine\n//bit operations that give you a number between 0 and the maximum uint size which is\n//4294967296, dividing by the maximum gives you a number between 0 and 1\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n///////////////////////////\n\n\nfloat DEe22(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 99.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.6+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.6,1.));\n        p.xyz-=vec3(0.7+rndf(seed)*0.4,1.0,0.5);\n        p*=1.3-rndf(seed)*0.2;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\n        vec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe33(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 999.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(2.1/clamp(dot(p.xyz,p.xyz),0.4,1.));\n        p.xyz-=vec3(2.3,3.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        //escape += exp(-0.2*dot(p.xyz,p.xyz));\nvec3 norm = normalize(p.xyz);\n        float theta = acos(norm.z/length(norm.xyz));\n        float phi = atan(norm.y/norm.x);\n        escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\nfloat DEe44(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 14; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.24/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,2.8,5.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.1;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe55(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.4/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.6,1.8,1.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\n\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEe66(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=-abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 22; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=(1.15/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(.6,.8,.2);\n        p.xyz = -abs(p.xyz);\n        //p*=1.2;\nescape = min(escape, dot(p.xyz,p.xyz));\n       // escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\nfloat DEe77(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x > p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(1.3/clamp(dot(p.xyz,p.xyz),0.4,0.6));\n        p.xyz-=vec3(1.+rndf(seed),1.0,2.2);\n        p.xyz = -abs(p.xyz+rndf(seed));\n        //p*=1.2;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n//vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        ///float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.0;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n//NOT MY CODE////////\n \t\n\n \nfloat de(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.5,1.,0.5);\n    }\n    return length(p)/DEfactor-.0005;\n}\n\n\nfloat de2(vec3 p){\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2./min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\nfloat de3(vec3 p){\np = mod(p,2.)-1.;\n    p=1.-abs(abs(p+sin(p))-1.);\n    p=p.x < p.y?p.zxy:p.zyx;\n    float s=5., l;\n    for(int j=0;j++<4;)\n        s*=l=2.7/min(dot(p,p),1.5),\n        p=abs(p)*l-vec3(2,1,3);\n    return length(p.yz)/s;\n}\n\nfloat dee(vec3 p){\n    p.xz=abs(.5-mod(p.xz,1.))+.01;\n    float DEfactor=1.;\n    escape = 0.;\n    for (int i=0; i<14; i++) {\n        p = abs(p)-vec3(0.,2.,0.);  \n        float r2 = dot(p, p);\n        float sc=2./clamp(r2,0.4,1.);\n        p*=sc; \n        DEfactor*=sc;\n        p = p - vec3(0.1,1.2,0.5);\n        escape += exp(-0.2*dot(p,p));\n    }\n    return length(p)/DEfactor-.0005;\n}\nmat2 rot(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));    \n}\nvec4 formula(vec4 p) {\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n    p=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n    p.xy*=rot(.5);\n    return p;\n}\nfloat screen(vec3 p) {\n    float d1=length(p.yz-vec2(.25,0.))-.5;    \n    float d2=length(p.yz-vec2(.25,2.))-.5;    \n    return min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));\n}\nfloat de23(vec3 pos) {\n    vec3 tpos=pos;\n    escape = 0.;\n    tpos.z=abs(2.-mod(tpos.z,4.));\n    vec4 p=vec4(tpos,1.5);\n    float y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n    for (int i=0; i<19; i++) {\n    p=formula(p);\n    escape += exp(-0.2*dot(p,p));\n    }\n    float fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n    float sc=screen(tpos);\n    return min(sc,fr);    \n}\n\n \t\n\nfloat de12(vec3 p){\n  float s=4.;\n  float l=0.;\n  p.z-=.9;\n  vec3 q=p;\n  s=2.;\n  for(int j=0;j++<12;)\n    p-=clamp(p,-1.,1.)*2.,\n    p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,\n    s*=l;\n  return length(p)/s;\n}\n\n////////////\nfloat de22(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n    p=abs(p);\n    if(p.x < p.z)p.xz = p.zx;\n    if(p.z < p.y)p.zy = p.yz;\n    if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        p = abs(p);\n        p*=(1.9/clamp(dot(p.xyz,p.xyz),0.1,1.));\n        p.xyz-=vec3(0.2,1.9,0.6);\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz)); \n    }\n    float m = 1.2;\n    p.xyz-=clamp(p.xyz,-m,m);\n    return (length(p.xyz)/p.w);\n}\n\n\n\n\n//JB's Collection of fractals + code\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nfloat smin_op(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 1.9;\n  float min_radius2 = 0.1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\nvoid box_fold(inout vec3 z, inout float dz) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat de222(vec3 z) {\n  vec3 offset = z;\n  float scale = -2.8;\n  float dr = 1.0;\n  escape = 0.;\n  for(int n = 0; n < 15; ++n) {\n    box_fold(z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    escape += exp(-0.2*dot(z.xyz,z.xyz));\n  }\n  float r = length(z);\n  return r / abs(dr);\n}\nvoid box_fold(inout vec3 z) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat DEer(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n//p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               p.xyz = abs(p.xyz);\n\n       // box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n                //sphere_fold(p.xyz,p.w);\n\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(3.3/clamp(dot(p.xyz,p.xyz),0.8,1.6));\n        p.xyz=abs(p.xyz)-vec3(2.5,2.2,1.3);\n       //p*=1.2;\np.xz -= sin(float(i)*55.)*.5;\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 3.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\nfloat DEer2(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape2 = 0.;\n        //p.xyz=1.0-abs(abs(p.xyz+sin(p.xyz)*1.)-1.);\n//p = abs(p);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n\n    for(int i = 0; i < 12; i++){\n        //if(p.x > p.z)p.xz = p.zx;\n       //if(p.z > p.y)p.zy = p.yz;\n       if(p.y > p.x)p.yx = p.xy;\n               p.xyz = abs(p.xyz);\n\n       // box_fold(p.xyz);\n        sphere_fold(p.xyz,p.w);\n                //sphere_fold(p.xyz,p.w);\n\n        //p.xyz = abs(p.xyz);\n        uint seed = uint(p.x+p.y+p.z);\n        p*=(3.9/clamp(dot(p.xyz,p.xyz),0.4,2.));\n        p.xyz=abs(p.xyz)-vec3(5.5,2.2,1.3);\n       //p*=1.2;\np.xz -= sin(float(i)*55.)*.5;\n        escape2 += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 3.5;\n   p.xyz-=clamp(p.xyz,-m,m);\nreturn (length(p.xyz)/p.w)*0.75;\n}\n\n//===============================\nfloat rota = -40.;\nfloat rotb = -17.;\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n    c = vec3(0.9);\n    a2 = 0.01;\n    prob = 0.;\n    l = 0.;\n    \n        float aa2 = DEer((vec3(0.,5.,-10.0)-p)/10.)*10.;\n        vec3 pos = vec3(-14.,-15.,-20.0)-p;\n        pos.xy = rot(pos.xy, 180.);\n                float aa22 = DEer2((pos)/10.)*10.;\n\n      \n    float plane = p.z + (5.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n    //float plane = length(vec3(15.,0.,0.)-p)-4.;\n\n    (sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n    //float final = min(min(min(min(min(aa,plane),aaa),aa5),aa4),aa44);\n   // float final = min(min(min(min(aa,aaaa),a22),aa44),plane);\n    float final = min(aa2,aa22);\n    //if(final == b2)l = 3.;\n    //if(final == c1)c = vec3(0.9,0.1,0.1);\n    //if(final == c2)c = vec3(0.1,0.9,0.1);\n    vec3 color = vec3(0.5,0.5,0.8);\n   // if(final == aa){a2 = 0.1;prob=0.9;c=vec3(0.5);}\n       if(final == aa2){a2 = 0.1;prob=0.9;c=pal(escape, vec3(0.9), vec3(0.9,0.9,0.2));\n       l=escape*0.00;}\n       if(final == aa22){a2 = 0.1;prob=0.5;c=pal(escape2, vec3(0.9), vec3(0.2,0.9,0.9));\n       l=escape2*0.000;}\n   \n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float t = pow(r2, 2./(1.+a));\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.03;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k){\n    for(int i = 0; i < 60; i++){\n        dd = dis(p,l,c,a,prob);\n        if(dd<0.01)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    \n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n   \n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n   \n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\n//Preetham sky model implemented by me, using the research paoer\nvec3 skyp2(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n//return vec3(0.1);\n//if(costheta<0.01)return vec3(0.);\n//simple cie sky\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\n//vec3 template = vec3(*T+,*T+,*T+);\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 lig = normalize(vec3(0.1,0.9,0.9));\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 6;\n    float k = 0.;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.05;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        \n            float number = rndf(r);\n            //float probability = 0.9;\n\n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*c*vec3(0.4,0.7,0.8);\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n            ldir = normalize(lig);\n\n            \n\n            vec3 brdf = c/3.14159 ;\n            //float rough = 1.;\n\n            \n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            vec3 lightdir = anglephong(100000., lig, r);\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2) && dot(lightdir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                col += tt*brdf2*vec3(0.9,0.7,0.5)*dot(lightdir,n);\n                //break;\n            }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                   \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/        \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            \n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n\n           /*if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lightdir,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.2;\n            }*/\n            if(i==0){\n                col += tt*skyp2(d, lig)*0.3;\n            }else{\n                col += tt*skyp2(d, lig)*0.7;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n\n    int tiles = 2;\n    int samples = 10;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    \n   // if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n   // if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n    uv *= 0.9;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //uv*=1.5;\n  //  uv*=0.7;\n // uv*=2.;\n // uv = rot(uv,-uv.x*30.);\n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = vec3(0.,-0.0, -3.0);\n    \n    \n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    float focaldist = 6.4;\n    float radius = 0.02;\n\n    vec3 camdirection = vec3(0.,1.,0.);\n    camdirection.yz = rot(camdirection.yz, rota);\n    camdirection.xy = rot(camdirection.xy, rotb);\n    vec3 sidex = vec3(1.,0.,0.);\n    vec3 sidey = vec3(0.,0.,1.);\n   // sidex.yz = rot2(sidex.yz,rota);\n    //sidex.xz = rot(sidex.xz, -20.);\n   // sidex.yz = rot(sidex.yz,rota);\n    sidex.xy = rot(sidex.xy,rotb);\n    \n    //sidey.xz = rot(sidey.xz,-20.);\n    sidey.yz = rot(sidey.yz,rota);\n    //sidey.xy = rot(sidey.xy,rotb);\n    \n    float ang = rndf(r)*2.0*3.14159;\n    float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n    float scale = sqrt(rndf(r))*radius;\n   //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 offset = vec2(scale*cos(ang), scale*(sin(ang)));\n    //NOT MY CODE////////////////////////\n    vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n    /////////////////////////////////////\n   // vec3 dd = vec3(uv.x,1.,uv.y);\n   // dd.yz = rot(dd.yz, rota);\n   // dd.xy = rot(dd.xy, rotb);\n   //vec3 focuspoint = p+(dd*focaldist);\n    //p.xz += offset;\n   p = p + sidex*offset.x;\n    p = p + sidey*offset.y;\n    d = normalize(focuspoint - p);\n    \n    \n    vec3 col = renderpixel(p,d, r, fragCoord);\n    col = clamp(col,0.,1.);\n   // if(jk != 0){\n    col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n   // }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2Gzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [251, 251, 308, 308, 834]], "test": "untested"}
{"id": "flBGzt", "name": "basic pt direct light 33", "author": "MinimilisticBits", "description": "sfsg", "tags": ["sdfds"], "likes": 1, "viewed": 265, "published": 3, "date": "1630680454", "time_retrieved": "2024-07-30T19:03:30.702906", "image_code": "/*\nWASD to move\nMouse to pan camera\nC to switch rendering modes\n*/\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz;\n    if(texture(iChannel1, vec2(0.99)).x > 0.5){\n        col/=(c.w+1.);\n    }\n    col = vec3(1.)-exp(-1.2*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEY_A 65.0\n#define KEY_W 87.0\n#define KEY_S 83.0\n#define KEY_D 68.0\n\n#define KEY_C 67.0\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc = c * pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n//NOT MY CODE////////////////////\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //vec3 d = texture(iChannel1, vec2(40.,0.)/iResolution.xy).xyz;\n    //vec3 p = vec3(0.);\n    //vec3 d;\n    //d = normalize(vec3(uv.x, 1., uv.y));\n    vec3 d = vec3(0.,-1.,0.);\n    vec3 side = vec3(1.,0.,0.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, -mouse.y*130.);\n    d.xy = rot(d.xy, mouse.x*180.);\n    side.xy = rot(side.xy, mouse.x*180.);\n    //vec3 prevcol = col;\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n    if(fragCoord.x < 0.05*iResolution.x && prev_state.x < 0.5){\n        if(isPressed(KEY_W)){\n            col-=d*0.1;\n        }\n        if(isPressed(KEY_S)){\n            col+=d*0.1;\n        }\n        if(isPressed(KEY_A)){\n            col-=side*0.1;\n        }\n        if(isPressed(KEY_D)){\n            col+=side*0.1;\n        }\n    }\n    \n    if(fragCoord.x > iResolution.x*0.5 && fragCoord.x < iResolution.x*0.6 && prev_state.x < 0.5){\n        col = vec3(-mouse.y*90., mouse.x*180., 0.);\n    }\n    \n    if(fragCoord.x > 0.95*iResolution.x){\n        if(isPressed(KEY_C)){\n            col = (col.x > 0.5)?vec3(0.):vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n    return vec2(cos(ang),sin(ang))*l;\n}\nfloat escape = 0.;\nfloat escape2 = 0.;\n\nfloat box(vec3 p, vec3 s){\n\n    vec3 a = abs(p)-s;\n\n    return max(max(a.x,a.y),a.z);\n}\n\n//NOT MY CODE///////////////\n//https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\nuint wang_hash(inout uint seed)\n{\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n//https://jbaker.graphics/writings/DEC.html\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape2 = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape2 += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\n\n \t\nfloat de332(vec3 p0){\n//p0 = floor(p0*30.)/30.;\n\tvec4 p = vec4(p0, 1.);\n\tp.xyz=abs(p.xyz);\n\tif(p.x < p.z)p.xz = p.zx;\n\tif(p.z < p.y)p.zy = p.yz;\n\t//if(p.y < p.x)p.yx = p.xy;\n\tfor(int i = 0; i < 8; i++){\n\t\tp.xyz = abs(p.xyz);\n\t\tuint seed = uint(p.x+p.y+p.z);\n\t\tp*=(2.3/clamp(dot(p.xyz,p.xyz),0.,1.));\n\t\tp.xyz-=vec3(1.6,.9,2.2);\n\t}\n\tfloat m = 1.0;\n\tp.xyz-=clamp(p.xyz,-m,m);\n    return length(p.xyz)/p.w;\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fractal_de217(vec3 p){\np=abs(p);\n  float d, a;\n  d=a=1.;\n  escape = 0.;\n  for(int j=0;j++<19;){\n    p.xz=abs(p.xz)*rotate2D(3.14159/4.),\n    d=min(d,max(length(p.zx)-.3,p.y-.4)/a),\n    p.yx*=rotate2D(.9),\n    p.y-=3.,\n    p*=1.2,\n    a*=1.2;\nescape += exp(-0.2*dot(p,p));\n    }\n\n  return d;\n}\n\n///////////////////////////\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5 + 0.5*cos(2.*3.14159*t*a + b);\n}\nvec3 lig = normalize(vec3(0.4,1.,0.5));\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob, inout bool ref){\n    c = vec3(0.3,0.7,0.8);\n    a2 = 0.1;\n    prob = 0.9;\n    l = 0.;\n    ref = false;\n    float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\nvec3 pos = vec3(-1.1,5.3,1.4)-p;\npos.yz = rot(pos.yz, 90.);\n                float aa = 0.;    //float aaa = DE45((vec3(78.0,0.2,-0.0)-p)/10.)*10.;\n  uint seed = uint(pos.x+pos.y+pos.z);\n  aa = max(max(box(pos, vec3(1.7)), -(box(mod(pos, 1.)-0.5,vec3(.3,.3,.3)))), \n  -(fractal_de217((pos/0.3))*0.3));\n  \n    float b2 = box(vec3(11., -20., 3.)-p, vec3(9.7,20.,25.));\n   // float bb2 = box(vec3(-8., -20., 16.)-p, vec3(20.7,20.,5.));\n\n    //float aa3 = fractal_de89((vec3(0.0,-19.2,2.0)-p)/10.)*10.;\n\n    float final = min(min(min(min(min(min(b2, a),b),c1),c2),c3),\n    max(aa, box(vec3(0.,2.,0.)-p, vec3(9.))));\n   \n    float plane = p.z - (9.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n\n    (sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n   \n    if(final == b2)l = 0.2;\n    if(final == a)l=0.2;\n    if(final == c1)c = vec3(0.2);\n    if(final == c2)c = vec3(0.2);\n    if(final == a)c = vec3(0.2);\n    if(final == b)c = vec3(0.2);\n    if(final == c3)c = vec3(0.2);\n\n\n    vec3 color = vec3(0.2,0.9,0.9);\n    if(final == aa){a2 = 0.1;prob=0.9;c=pal(escape2, vec3(0.9), vec3(0.9,0.2,0.2));\n    l=escape*0.0;\n    ref = true;\n    }\n  \n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float t = pow(r2, 2./(1.+a));\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.01;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k, inout bool ref){\n    for(int i = 0; i < 180; i++){\n        dd = dis(p,l,c,a,prob, ref);\n        if(dd<0.001)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    bool ref;\n    \n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob,ref) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob,ref) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob,ref) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob,ref)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    \n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n   \n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\nvec3 skyp2(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 sampleSun(vec3 n, inout uint r, float theta){\n        float diff = 1.-cos(theta);\n        float z = cos(theta) + rndf(r)*diff;\n        float angle = rndf(r)*3.14159*2.;\n        float radius = sqrt(1. - z*z);\n        float x = cos(angle) * radius;\n        float y = sin(angle) * radius;\n        \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 53;\n    float ll = 0.;\n    float k = 0.;\n    bool ref = false;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k,ref)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.03;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        if(i == 0)ll=length(p-prevp);\n            float number = rndf(r);\n           \n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*l*c;\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n           \n           ////////////////////////////\n           float theta = 0.1;\n           vec3 lightdir = sampleSun(lig, r, theta);\n           /////////////////////////////\n\n\n            ldir = normalize(lightdir);\n\n\n            vec3 brdf = c/3.14159 ;\n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n   \n   \n               \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            \n            \n         /*   vec3 L = vec3(0.9,0.7,0.5)*10.;\n            \n           vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            bool ref2 = false;\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2,ref2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                if(number < probability){\n                    brpdf = hemipdf2;\n                }\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n)/pdf;\n                //break;\n            }\n            \n           //MIS\n           float an = acos(dot(d,lig));\n           if((an) <= theta){\n               curr = p;\n               if(!trac(curr, d,dd,l2,c,a2,prob2,r,k2,ref2)){\n                   float heightbrdf = cos(an);\n                   float arbrdf = 2.*3.14159*(1.-heightbrdf);\n                   float pdf = 1./arbrdf;\n                   float weight = powerh(1.,hemipdf,1.,pdf);\n                   col += tt*brdf*weight*L*max(dot(d,n),0.)/hemipdf;\n                   break;\n               }\n           }\n            */\n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                   \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/      \n            \n            if(ref){\n            if(i==0){\n                        tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n\n            }\n            float sch = 0.65 + (1.0-0.65)*pow(1.0-max(dot(n, wi),0.),5.);\n                if(rndf(r) < sch){\n                float prob2 = 0.;\n                float dds = dis(p,l,c,a,prob2,ref);\n                if(dds > 0.01){\n                p-=n*0.04;\n                d = refract(wi, n, 0.65);\n                }\n                for(int k = 0; k < 340; k++){\n                    float dds = dis(p,l,c,a,prob2,ref);\n                    if(dds>0.01){\n                    break;\n                    }\n                    \n                    p+=d*.01;\n                }\n                vec3 n2 = norm(p,dd);\n                p+=n2*0.02;\n                \n                d = refract(wi, -n2, 0.65);\n                }else{\n                //d = reflect(wi, n);\n                            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n                }\n                tt *= c;\n            }else{\n            \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            }\n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.1;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\nif(i==0)ll=length(p-prevp);\n          /* if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.8,0.7,0.4)*0.1;\n            }*/\n            if(i==0){\n                col += tt*skyp2(d, lig)*0.3;\n            }else{\n                col += tt*skyp2(d, lig)*0.7;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    //col += 1./(1.+exp(-2.*(clamp(ll,0.,20.)*0.1-2.)))*vec3(0.2,0.2,0.2);\n    return col*2.*3.14159;\n}\n\n\nvec3 get_color(vec3 p, vec3 d, vec2 frag){\n    vec3 prevp = p;\n    vec3 p2 = p;\n    vec3 d2 = d;\n    vec3 prevp2 = p2;\n    bool hit_obj = false;\n    vec3 ligc = vec3(0.9,0.8,0.4);\n    vec3 col = vec3(0.);\n    float k = 0.;\n    vec3 glow = vec3(0.);\n    float l = 0.;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    float prob = 0.;\n    bool ref = false;\n    for(int i = 0; i < 80; i++){\n    //dis(p,l,c,a,prob);\n        float dist2 = abs(dis(p2,l,c,a,prob,ref))+0.001;\n        p2 += d2*dist2;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*c;\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }\n    col = glow*12.;\n   return col;\n}\n\n//NOT MY CODE//////////////////////\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n\n    int tiles = 8;\n    int samples = 30;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(prev_state.x > 0.5){\n        if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n        if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    }\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n   // uv *= 0.5;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n  \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = texture(iChannel1, vec2(0.)).xyz;\n    \n    vec3 rotations = texture(iChannel1, vec2(0.55)).xyz;\n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    float rota = 0.;\n    float rotb = 0.;\n    rota = rotations.x;\n    rotb = rotations.y;\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    vec3 col = vec3(0.);\n    if(prev_state.x > 0.5){\n        \n        float focaldist = 1.3;\n        float radius = 0.03;\n\n        vec3 camdirection = vec3(0.,1.,0.);\n        camdirection.yz = rot(camdirection.yz, rota);\n        camdirection.xy = rot(camdirection.xy, rotb);\n        vec3 sidex = vec3(1.,0.,0.);\n        vec3 sidey = vec3(0.,0.,1.);\n       // sidex.yz = rot2(sidex.yz,rota);\n        //sidex.xz = rot(sidex.xz, -20.);\n       // sidex.yz = rot(sidex.yz,rota);\n        sidex.xy = rot(sidex.xy,rotb);\n    //    sidex.yz = rot(sidex.yz,rota);\n\n        //sidey.xz = rot(sidey.xz,-20.);\n        sidey.yz = rot(sidey.yz,rota);\n        sidey.xy = rot(sidey.xy,rotb);\n    \n        float ang = rndf(r)*2.0*3.14159;\n        float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n        float scale = sqrt(rndf(r))*radius;\n       //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n       //vec2 aa = normalize(vec2(0.,1.));\n        vec2 offset = vec2(cos(ang), sin(ang))*scale;\n        //if(offset.x > offset.y)offset.xy=offset.yx;\n        //offset.x+=-1.;\n    \n       //offset*=radius;\n       //NOT MY CODE////////////////////////\n        vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n        /////////////////////////////////////\n       // vec3 dd = vec3(uv.x,1.,uv.y);\n       // dd.yz = rot(dd.yz, rota);\n       // dd.xy = rot(dd.xy, rotb);\n       //vec3 focuspoint = p+(dd*focaldist);\n        //p.xz += offset;\n\n        p = p + sidex*offset.x;\n        p = p + sidey*offset.y;\n\n        d = normalize(focuspoint - p);\n    \n    \n        col = renderpixel(p,d, r, fragCoord);\n\n        col = tonemap_uchimura2(col);\n        //col = pow(col, vec3(1.6))*1.8;\n        col = pow(col, vec3(1./2.2));\n\n        if(jk != 0){\n            col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        }\n    }else{\n        col = get_color(p,d,fragCoord.xy);\n    }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 104, 127, 127, 281], [283, 283, 315, 315, 1059], [1097, 1097, 1154, 1154, 1741]], "test": "untested"}
{"id": "Ndd3D2", "name": "float precision → iTime, etc", "author": "FabriceNeyret2", "description": "low to high bits of fract() of iTime (top) and iDate.w (bottom).\nJust a reminder that IEEE float mantissa only has 23 bits.\nMeaning lowest bits of open scale values - like iTime and iDate - can be lost ( and fract/mod won't save the day ;-) )\nEvening is w", "tags": ["precision", "ieee", "float", "bits"], "likes": 4, "viewed": 227, "published": 3, "date": "1630673943", "time_retrieved": "2024-07-30T19:03:31.664335", "image_code": "#define bit(p,v)   int( (v) * float(1<<23) ) >> p & 1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    bool right = U.y > iResolution.y/2.;\n    int p = int(U)/16;\n    O = vec4( bit( p,  p < 24 ? fract(right ? iTime : iDate.w )\n                              : floor(right ? iTime : iDate.w )\n            )    );\n    if (int(U)%16==0) O = vec4(0,1,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 93, 93, 348]], "test": "untested"}
{"id": "fdd3Wj", "name": "Cubic Waves", "author": "lambmeow", "description": "Wanna get back on the groove of things", "tags": ["raymarch", "sdf", "cube", "sin", "trig"], "likes": 8, "viewed": 309, "published": 3, "date": "1630655207", "time_retrieved": "2024-07-30T19:03:32.434276", "image_code": "\nmat2 rot(float f)\n{\n\tfloat c = cos(f), s = sin(f);\n\treturn mat2(c ,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat scene(vec3 p) \n{\n\tfloat oz = p.z;\n\t\n\tp.z = mod(p.z + 1., 1.) - 1.;\n\tfloat res = 1000.;\n\t\n\tfor(int i = 0; i < 20; i++)\n\t{\n\t\tfloat offset = iTime +  float(i) + oz ;\n\t\tvec3 rotp = p;\n\t\trotp.xy *= rot(iTime*0.5 + float(i) - oz );\n\t\t//rotp.xz *= rot (time + oz) * 0.001;\n\t\tres  = min( res, box(rotp - vec3(sin(offset) , cos(offset), 0),vec3(0.45 *abs(sin(iTime - sin(float(i) * 0.05) * 2.) + cos(iTime *0.55) *0.5)))); \n\t}\n\treturn res;\n}\n\nvec4 ray(vec3 ro, vec3 rd)\n{\n\tfloat dist = 0., closest = 255.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tvec3 pos = ro + rd * dist;\n\t\tfloat len = scene(pos);\n\t\t\n\t\tdist += len;\n\t\tclosest = min(len, closest);\n\t\t\n\t\tif ( len < 0.001 || dist > 100.)\n\t\t\tbreak;\n\t}\n\treturn vec4(ro + rd * dist, dist);\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 eps = vec2(0.01, 0);\n\treturn normalize(scene(p) - vec3(scene(p - eps.xyy) , scene(p - eps.yxy), scene(p - eps.yyx)));\n}\n\nvec4 color(vec4 res, vec3 lp, vec2 u)\n{\n\tvec3 n = norm(res.xyz), p = res.xyz;\n\tvec3 ldir = lp - p, nldir = normalize(ldir);\n\n\tvec3 amb = vec3(0, .5, 1) * u.x;\n\t\t\n\tif(res.w > 12.) \n\t return vec4(amb , 1.);\n\t \n\tvec3 diff = vec3(0.7, .4, 1) * dot(nldir, n);\n\t\n\tvec3 glow = vec3(0, .3, 0) * (1.- res.w/10.);\n\tvec3 color = clamp(diff, 0.,1.) + clamp(amb,0.,1.) * 0.1;\n\t\n\tcolor = mix(color, amb, res.w/10.);\n\treturn vec4(color , 1); //vec4(dot(n, normalize(ldir))) * (1/(1 + dot(ldir, ldir)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy, u = (2. *  fragCoord - r)/r.y; \n\t\n\tvec3 ro = vec3(0, 0, -10. + iTime * 4.), rd = normalize(vec3(u, 2.));\n\t\n\tfragColor = color(ray(ro,rd), ro, u + 2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 78], [80, 80, 107, 107, 193], [194, 194, 216, 216, 632], [634, 634, 662, 662, 923], [925, 925, 944, 944, 1070], [1072, 1072, 1111, 1111, 1561], [1565, 1565, 1622, 1622, 1804]], "test": "untested"}
{"id": "NdcGDj", "name": "Abstractions", "author": "Tater", "description": "A shader for sableraph's weekly creative code challenge, theme was \"architecture\".\n\nIt's a little bit artifacty but the AA sorta covers it up.\n\nSpin with mouse", "tags": ["3d", "raymarching", "abstract", "architecture"], "likes": 21, "viewed": 454, "published": 3, "date": "1630637840", "time_retrieved": "2024-07-30T19:03:33.313925", "image_code": "#define STEPS 150.0\n#define MDIST 100.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 rdg = vec3(0);\nfloat h21(vec2 p){\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\nfloat h13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*-tan(5.0*pi/6.0);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nbool filled(vec3 id){\n    if(id.y<0.) return true;\n    float cyc = floor(iTime*0.15);\n    float hash = h13(id+cyc);\n    cyc = mod(cyc,3.0);\n    //I had to do this uglyness because compiler keeps tryning to inline everything\n    //(this saves like 2 seconds of compile time)\n    float w1 = max(abs(id.x),abs(id.z));\n    float w2 = length(id.y*id.y);\n    float w3 = 0.3;\n    if(cyc==0.0) w1 = length(id.xz);\n    if(cyc==2.0) {w2 = abs(id.y);w3 = 0.4; }\n    return(hash+w1*w3+w2*0.01<0.85);\n}\nvec2 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(9999.,1);\n    vec2 b = vec2(2);\n    \n    vec3 id = floor(p);\n    //float hash = h13(id+floor(t*0.1));\n    vec3 dir = sign(rdg)*.5;\n    vec3 q = fract(p)-.5;\n    //q = vec3(q.x,q.y,q.z);\n    vec3 rc = (dir-q)/rdg;\n\n    float dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    bool ifilled = filled(id);\n    if(max(id.x,id.z)<5.0){\n        if(ifilled)a.x = box(q,vec3(0.5));\n        float nbors = 0.;\n        vec3 off = vec3(0);\n        if(filled(id+vec3(1,0,0))){nbors++;off+=vec3(1,0,0);}\n        if(filled(id+vec3(0,1,0))){nbors++;off+=vec3(0,1,0);}\n        if(filled(id+vec3(0,0,1))){nbors++;off+=vec3(0,0,1);}\n        if(filled(id+vec3(-1,0,0))){nbors++;off+=vec3(-1,0,0);}\n        if(filled(id+vec3(0,-1,0))){nbors++;off+=vec3(0,-1,0);}\n        if(filled(id+vec3(0,0,-1))){nbors++;off+=vec3(0,0,-1);}\n        if(nbors==3.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.)*0.6);\n        float hh = h13(id+floor(iTime*0.15));\n        if(nbors==2.0&&!ifilled&&hh>0.33){\n            vec3 p2 = q+off*0.71;\n            p2.xy*=rot((1.0-abs(off.z))*pi/4.);\n            p2.yz*=rot((1.0-abs(off.x))*pi/4.);\n            p2.zx*=rot((1.0-abs(off.y))*pi/4.);\n            float cut = box(p2,vec3(1.0));\n            a.x = max(box(q,vec3(0.5)),-cut*0.6)*0.7;\n        }\n        else if(hh>0.26&&nbors==2.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.1)*0.6);\n        \n        if(nbors==2.0&&!ifilled&&off==vec3(0))a.x = box(q,vec3(0.5));\n       // if(nbors==3.0&&!ifilled)a.x = box(q,vec3(0.5));\n    }\n    b.x = p.y;\n    a=(a.x<b.x)?a:b;\n    dc = max(dc,box(po,vec3(4,50,4)));\n    a.x = min(a.x,dc);\n    \n    return a;\n}\nvec3 norm(vec3 p,float s){\n    vec2 e = vec2(s,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,6,-13);\n    if(iMouse.z>0.){\n    ro.xz*=rot(10.0*iMouse.x/iResolution.x);\n    }\n    else ro.xz*=rot(iTime*0.3);\n\n    vec3 lk = vec3(0,3.5,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.1+uv.x*r+uv.y*cross(f,r);\n    rdg = rd;\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO= 0., shad = 0.;\n    bool hit = false;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if((d.x)<0.005){\n            hit = true;\n            shad = i/STEPS;\n            break;\n        }\n        if(dO>MDIST){\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1.01,-1));\n        //ld.xz*=rot(iTime*0.3);\n        vec3 n = norm(p,0.001);\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),5.0);\n        //float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = dot(n, ld)*0.4+0.6;\n        vec3 al = vec3(1);\n        ld.xy*=rot(h21(uv)*0.005);\n        ld.yz*=rot(h21(uv+1.)*0.005);\n        ld.zx*=rot(h21(uv+2.)*0.005);\n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<20.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }\n        //shadow = max(shadow,0.8);\n        \n        //AO & soft shadow doesn't work because of the domain rep tricks, oh well\n        \n        diff -=(h21(uv)-0.4)*(pow(1.0-diff*shadow,9.0))*4.0;\n        col=al*diff+pow(spec,2.0)*0.1*shadow;\n        col*=shadow;\n    }\n    else{\n    col = mix(vec3(0.6),vec3(0.647,0.647,0.694),uv.y);\n    }\n    //col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}\n\n//if you have a very good GPU you can crank up the AA and it looks a lot better\n#if HW_PERFORMANCE==0\n#define AA 1.0\n#else\n#define AA 2.0 \n#endif\n\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 152, 152, 218], [219, 219, 238, 238, 341], [342, 342, 371, 371, 430], [431, 431, 457, 457, 515], [516, 516, 537, 537, 1005], [1006, 1006, 1023, 1023, 2702], [2703, 2703, 2729, 2729, 2853], [2854, 2854, 2907, 2907, 4689], [4866, 4866, 4923, 4923, 5337]], "test": "untested"}
{"id": "7sc3Wj", "name": "door of time", "author": "jorge2017a1", "description": "door of time", "tags": ["dooroftime"], "likes": 4, "viewed": 195, "published": 3, "date": "1630636155", "time_retrieved": "2024-07-30T19:03:34.095834", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n///door of time\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n    p.y=p.y-10.0;\n    \n    p.x= opRep1D( p.x,40.0);\n    \n    float sdb1= sdBox(p, vec3(20.0,9.0,10) );\n    float sdb2= sdBox(p-vec3(-6.0,0.0,-1.0), vec3(15.0,8.0,10) );\n    float sdb3= sdBox(p-vec3(0.0,1.0,-3.0), vec3(25.0,5.0,5.0) );\n    \n    float tt=mod(iTime*0.5,1.0);\n    float px=clamp(tt, 0.0,1.0)*45.0;\n    \n    vec3 pr=pp;\n    pr.x= opRep1D( p.r,40.0);\n    \n    float sds1= sdSphere(pr-vec3(-25.0+px,10.0,-2.0), 3.0 );\n    \n    float sdif= differenceSDF(sdb1, sdb2);\n    sdif= differenceSDF(sdif, sdb2);\n    sdif= differenceSDF(sdif, sdb3);\n      res =opU3(res, vec3(sdif,1.0,-1.0));\n      res =opU3(res, vec3(sds1,2.0,-1.0)); \n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n  \n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 30.0, -25.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 20.0, 10.0, -30.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0-t,10.0,-30.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(45.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 533, 533, 554], [555, 555, 587, 587, 671], [673, 717, 764, 764, 791], [792, 792, 835, 835, 862], [863, 863, 911, 911, 939], [940, 978, 1014, 1014, 1059], [1060, 1125, 1159, 1159, 1255], [1256, 1256, 1290, 1290, 1381], [1382, 1382, 1416, 1416, 1507], [1508, 1548, 1573, 1573, 2382], [2384, 2435, 2459, 2459, 2621], [2623, 2623, 2672, 2672, 3308], [3310, 3364, 3400, 3400, 3645], [3646, 3701, 3728, 3728, 3745], [3747, 3747, 3783, 3783, 3875], [3876, 3876, 3922, 3922, 4047], [4049, 4049, 4123, 4123, 5724], [5725, 5814, 5894, 5894, 6017], [6060, 6060, 6092, 6092, 6289], [6291, 6339, 6367, 6367, 6555], [6558, 6609, 6656, 6656, 6903], [6905, 6957, 7050, 7050, 7391], [7394, 7394, 7425, 7425, 8080], [8082, 8131, 8157, 8157, 8267], [8269, 8269, 8327, 8327, 8379], [8381, 8430, 8487, 8487, 9072]], "test": "untested"}
{"id": "fs33Wj", "name": "Fractal Milkshake", "author": "kekwizard", "description": "A variant of this:\n\nhttps://www.shadertoy.com/view/7sdGz2\n\nBut with a polynomial that changes over time. Not finished in any way, just playing around with the concept :)", "tags": ["fractal", "complex", "newton", "polynomial"], "likes": 1, "viewed": 188, "published": 3, "date": "1630617633", "time_retrieved": "2024-07-30T19:03:35.100149", "image_code": "// raphael@gonku.de\n\n#define pi acos(-1.)\n#define angle(z) (atan(z.y/z.x) + pi * step(0.0, z.x))\n\n\n// -- some helper functions for complex numbers\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float v = (w.x * w.x + w.y * w.y);\n    vec2 r = vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y);\n    return r / v;\n}\n\n// Taken from \n// https://www.shadertoy.com/view/sdt3R2\n\nvec2 cmul(vec2 z, vec2 w) {\n    vec2 r = vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n    return r;\n}\n\nvec2 pol(vec2 z) {\n    float size = sign(z.x) * length(z);\n    float angle = angle(z);\n    return vec2(length(z), angle);\n}\n\nvec2 cart(vec2 pol) {\n    return pol.x * vec2(cos(pol.y), sin(pol.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    vec2 p1 = pol(z);\n    vec2 p = vec2(pow(p1.x, w.x) * exp(-w.y * p1.y), p1.y * w.x + log(p1.x) * w.y);\n    vec2 r = cart(p);\n    return r;\n}\n\nvec2 cpow(vec2 z, float w) {\n    return cpow(z, vec2(w, 0.0));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return cpow(z, float(w));\n}\n\n\n// --- main code\n\n\n#define NEWTON_ITER 20\n#define MOVE_ROOTS\n\n\n// P(z)\nvec2 func(vec2 z) {\n    return cpow(z, iTime / 4.0) + cpow(z, 2) - z + vec2(1.0, 0.0);\n}\n\n// P'(z)\nvec2 funcd(vec2 z) {\n    return cmul(vec2(iTime / 4.0, 0.0), cpow(z, 4)) + cmul(vec2(2.0, 0.0), z) - vec2(1.0, 0.0);\n}\n\nvec2 newton(vec2 z) {\n    vec2 t = func(z);\n    vec2 td = funcd(z);\n    return z - cdiv(t, td);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    float t = iTime / 8.;\n\n\n#ifdef MOVE_ROOTS\n    // actual complex roots of the function\n    // i added some terms to move the points over time\n    // mathematically speaking, this is nonsense\n    // it does look cool tho\n    vec2 roots[5] = vec2[5] (\n        vec2(-1.324, 0.0) + 0.5 * vec2(sin(iTime) * 0.65, cos(iTime * 0.8)), \n        vec2(0.0, -1.0) + 0.5 * vec2(cos(iTime * 0.55 + 11.5), sin(iTime * 0.618)),\n        vec2(0.0, 1.0) + 0.5 * vec2(cos(iTime + 15.5), sin(iTime * 0.18)), \n        vec2(0.6623, 0.5622), \n        vec2(0.6623, -0.5622)\n    );\n    \n#else\n     \n    \n    // actual roots of function\n    const vec2 roots[5] =  vec2[5](\n        vec2(-1.324, 0.0),\n        vec2(0.0, -1.0),\n        vec2(0.0, 1.0),\n        vec2(0.6623, 0.5622),\n        vec2(0.6623, -0.5622)\n    ); \n    \n\n#endif\n\n    \n    \n\n    const vec3 colors[5] = vec3[5] (\n        vec3(0.937, 0.278, 0.435), \n        vec3(1.00, 0.82, 0.40), \n        vec3(0.024, 0.83, 0.62), \n        vec3(0.06, 0.54, 0.69), \n        vec3(0.02, 0.23, 0.29)\n    );\n    \n    \n\n    // zoom + slight pan\n    vec2 r = (p / (t*t*t)) - vec2(0.5015, 0.0);\n\n\n    // newton\n    for(int i = 0; i < NEWTON_ITER; i++) {\n        r = newton(r);\n    }\n\n    // find closest root\n    float d = distance(r, roots[0]);\n    int ix = 0;\n    for(int i = 1; i < 5; i++) {\n        float nd = distance(r, roots[i]);\n        if(nd < d) {\n            d = nd;\n            ix = i;\n        }\n    }\n\n    fragColor = vec4(colors[ix], 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 175, 175, 299], [358, 358, 385, 385, 466], [468, 468, 486, 486, 591], [593, 593, 614, 614, 665], [667, 667, 694, 694, 838], [840, 840, 868, 868, 904], [906, 906, 932, 932, 964], [1030, 1038, 1057, 1057, 1126], [1128, 1137, 1157, 1157, 1255], [1257, 1257, 1278, 1278, 1354], [1356, 1356, 1411, 1411, 2954]], "test": "untested"}
{"id": "NdcGWj", "name": "MultiAnneal", "author": "hjd3481", "description": "A simple Buffer feedback test. MODE 0 for classic Game of Life. MODE 1 for experiment with food availability, MODE 2 for the Anneal algorithm. See: https://en.wikipedia.org/wiki/Life-like_cellular_automaton. Added multiple layers of the source texture", "tags": ["automata", "cellular", "buffer", "gameoflife"], "likes": 7, "viewed": 324, "published": 3, "date": "1630616580", "time_retrieved": "2024-07-30T19:03:36.075541", "image_code": "//See BufferA for the main code\n\n//we are zoomed in, dont waste those pixels, we draw them in as layers under the main copy\n#define MULTILAYER 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv= fragCoord/iResolution.xy;\n    \n    //whole numbers will keep regular pixel-scaling.\n    float zoom = 2.0;\n\n    uv /= zoom; //zoom in    \n\n    vec3 col = vec3(0.0);\n\n    vec3 buff = texture( iChannel0, uv ).rgb;\n    \n    float alpha = 0.85;\n    \n#if MULTILAYER\n    vec3 buffB = texture( iChannel0, uv + vec2(0.5,0.0) ).rgb;\n    vec3 buffC = texture( iChannel0, uv + vec2(0.0,0.5) ).rgb;\n    vec3 buffD = texture( iChannel0, uv + vec2(0.5,0.5) ).rgb;\n   \n    col = mix( col, vec3(1.0,0.0,0.0)*.3, float((buffD.x > 0.9)) ); //age / alive\n   \n    col = mix( col, vec3(1.0,0.25,0.01)*.5, float((buffC.x > 0.9)) * alpha ); //age / alive\n   \n    col = mix( col, vec3(1.0,0.5,0.1)*.75, float((buffB.x > 0.9)) * alpha ); //age / alive\n#endif //MULTILAYER\n\n    //mix in colours based on the raw data-buffer.  \n    col = mix( col, vec3(1.0,0.75,0.1), float((buff.x > 0.9)) * alpha); //age / alive\n    \n    fragColor.rgb = col;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define C_TL 0\n#define C_T  1\n#define C_TR 2\n#define C_L  3\n#define C_C  4\n#define C_R  5\n#define C_BL 6\n#define C_B  7\n#define C_BR 8\n        \n/////////////////////////////////////////////////////////////////        \n//Settings\n    \n//https://en.wikipedia.org/wiki/Life-like_cellular_automaton\n    \n//0 : Conways Game of Life (B3/S23)\n//1 : custom experiment \"hunger\"\n//2 : ANNEAL (B4678/S35678)\n\n#define CONWAY 0\n#define HUNGER 1\n#define ANNEAL 2\n\n//change this to try different algorithms\n//Restart the timer (rewind) the shader to re-generate the starting noise\n#define MODE 2\n\n//Increase this to slow down the frames per second of the sim.\n//Set to 1 for no delay (same fps as render)\n#define TICKDELAY 2\n\n/////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvCell = floor( fragCoord );\n    \n    //if first frame or frame is approximately 16 seconds (if running at 60fps)\n    if( iFrame == 0 || 0 == (iFrame % (60*16)) )\n    {\n        //just use the seconds to alter the hash, change this to a fixed number for repeat runs of the same seed\n        vec2 seed = vec2( iDate.w );\n        const float invOccupancy = 0.5; //increase to reduce starting living cells. start with 50-50%\n        \n        float cellStartValue = step( invOccupancy, hash12(uvCell + seed) );\n        float startFoodValue = mix( 0.8, 1.0, hash12(uvCell + seed * vec2(11.011331,9.753111))); \n        fragColor = vec4( vec3(cellStartValue, startFoodValue, 0.0 ), 1);\n        \n        return;\n    }\n\n    vec2 uvFull = (fragCoord/iResolution.xy);    \n    vec3 cO = texture( iChannel0, uvFull).rgb;  \n    vec3 col = cO;\n    \n    //only perform the operation on the source data once every n frames, this slows our in-game framerate verses our draw refresh-rate\n    //increase the tickDelay to slow the update-speed, set to zero for realtime.\n    if(iFrame % TICKDELAY == 0) \n    {\n    \n \n        vec3 cell[9];\n\n        cell[C_TL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_T ] = texture( iChannel0, ( (fragCoord+vec2(0.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_TR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,+1.0)) /iResolution.xy) ).rgb;\n        \n        cell[C_L] = texture( iChannel0, ( (fragCoord+vec2(-1.0,0.0)) /iResolution.xy) ).rgb;  \n        cell[C_C] = cO;\n        cell[C_R] = texture( iChannel0, ( (fragCoord+vec2(+1.0,0.0)) /iResolution.xy) ).rgb;  \n        \n        cell[C_BL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_B ] = texture( iChannel0, ( (fragCoord+vec2(0.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_BR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,-1.0)) /iResolution.xy) ).rgb; \n\n        int numNeighbours = 0 ;\n        for(int i=0; i < 9; ++i)\n        {\n            //dont count ourselves - we can include oursleves and alter numbers below as an optimisation but its here for \n            // completeness / so our code more closely matches documentation\n            if(i != C_C)\n            {\n                // bool(float) is true for all non-zero values.\n                // int(bool) just turns the logical 'true' and 'false' into integer '1' and '0' respectively.\n                numNeighbours += int(bool(cell[i].x));\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#if MODE == CONWAY\n        /////////////////////////////////////////////////////////////////\n        //conways game of life     \n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive? (float to bool -> 0.0 = false, otherwise true ).\n        {\n            if(numNeighbours == 2 || numNeighbours == 3) // < 2 underpopulation > 3 opverpopulation. 2 or 3, survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 3 ) //== 3 reproduction\n           {\n               col = vec3(1);\n           }\n        }\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == HUNGER\n        /////////////////////////////////////////////////////////////////\n\n        float alive = cO.x;\n        float food = cO.y;\n        \n        //age\n        alive = max( 0.0, alive - 0.1 ); //\n        \n        //grow food back\n        food += 0.016;\n        \n        //test cell\n        if( bool(cell[C_C].x)  ) //is alive\n        {\n        \n            food -= 0.15; //eat food\n            food -= float(numNeighbours) * 0.05; //crowding reduced food faster\n           \n            if(numNeighbours < 0) //2 underpopulation\n            {\n                alive = 0.0;\n            }\n            else if(numNeighbours > 3 ) //3 overpopulation\n            {\n                alive = 0.0;\n            }\n            else   if(food < 0.1 )//starve\n            {\n               alive = 0.0;\n            }\n                      \n        }\n        else //dead\n        {        \n           if(numNeighbours == 2 ) //3 reproduction\n           {\n               if(food > 0.25) //need starting food\n                   alive = 1.0;\n           }\n        }\n\n\n        col.x = alive;\n        col.y = clamp( food, 0.0, 1.0 );\n        col.z = 0.0;\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == ANNEAL\n        /////////////////////////////////////////////////////////////////\n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive?\n        {\n            if(numNeighbours == 3 || numNeighbours == 5 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8) //survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 4 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8 ) //birth\n           {\n               col = vec3(1);\n           }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#endif\n        \n    }\n    \n       \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t3.1415926535897932384626433832795\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n#define INVPI \t0.31830988618379067153776752674503\n#define INVTWOPI 0.15915494309189533576888376337251\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 203, 253, 1189]], "test": "untested"}
{"id": "ssd3DB", "name": "saw teeth", "author": "jorge2017a1", "description": "saw teeth", "tags": ["2d", "saw", "teeth"], "likes": 6, "viewed": 213, "published": 3, "date": "1630614283", "time_retrieved": "2024-07-30T19:03:36.962170", "image_code": "// por jorge2017a1\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat Dientes(vec2 p)\n{\n    float sdb1=sdBox(p, vec2(2.0,0.35) );\n    \n    vec2 pr=p;\n     pr.x= opRep1D(p.x, 0.5 );\n     \n    float sds1=sdCircle( pr-vec2(-0.01,0.3), 0.27 );\n    float sds2=sdCircle( pr-vec2(0.1,0.053), 0.15 );\n    float sds3=sdCircle( pr-vec2(0.0,-0.073), 0.1 );\n    float sds4=sdCircle( pr-vec2(-0.05,0.013), 0.13 );\n    \n    float sdif=differenceSDF(sdb1, sds1);\n    sdif=differenceSDF(sdif,sds2);\n    sdif=differenceSDF(sdif,sds3);\n    sdif=differenceSDF(sdif,sds4);\n    \n    return sdif;\n\n}\n\n//https://www.shadertoy.com/view/sdX3zN\nvec3 getBackgroundColor(vec2 uv) \n{\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(0., 0., 0.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n     uv.y+=0.25;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2=getBackgroundColor(uv);\n     col=mix(col, col2,uv.y);\n     col=mix(col, vec3(0.0),uv.y-0.5)*col2;\n    float t1=0.5*sin(iTime*0.5);\n    float t2=0.5*sin(iTime*1.5);\n    float t3=0.5*sin(iTime*2.0);\n    \n    float d1= Dientes(uv-vec2(0.0+t1,0.1));\n    float d2= Dientes(uv-vec2(0.1+t2,0.0));\n    float d3= Dientes(uv-vec2(0.1+t3,-0.1));\n    col= DrawFig(vec3(1.0), col,d1);\n    col= DrawFig(vec3(0.5,0.3,0.6), col,d2);\n    col= DrawFig(vec3(0.25,0.0,0.6), col,d3);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssd3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 272, 308, 308, 353], [359, 359, 398, 398, 442], [444, 488, 535, 535, 562], [563, 563, 606, 606, 633], [634, 634, 682, 682, 710], [716, 716, 778, 778, 968], [971, 971, 1028, 1028, 1094], [1096, 1096, 1131, 1131, 1159], [1161, 1161, 1198, 1198, 1278], [1281, 1281, 1304, 1304, 1794], [1796, 1836, 1871, 1871, 2123], [2125, 2125, 2182, 2182, 2918]], "test": "untested"}
{"id": "fdt3DS", "name": "ConwaysGameOfLife+Others", "author": "hjd3481", "description": "A simple Buffer feedback test. MODE 0 for classic Game of Life. MODE 1 for experiment with food availability, MODE 2 for the Anneal algorithm. See: https://en.wikipedia.org/wiki/Life-like_cellular_automaton", "tags": ["automata", "cellular", "buffer", "gameoflife"], "likes": 4, "viewed": 228, "published": 3, "date": "1630614110", "time_retrieved": "2024-07-30T19:03:37.829851", "image_code": "//See BufferA for the main code\n\n//seems that the 'wrap' mode does not save with the shader. \n// to use the pan and zoom, de-select and re-select \"repeat\" for \n// the \"wrap\" option in the iChannel0 settings, then set the below to 1.\n#define PANANDZOOM 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv= fragCoord/iResolution.xy;\n    \n    //whole numbers will keep regular pixel-scaling.\n    float zoom = 2.0;\n\n#if PANANDZOOM  \n    zoom =  mix(4.0,1.0,sin(iTime*0.051221)*0.5+0.5);\n    \n    uv -= 0.5;\n    \n    uv.x += zoom * fract( iTime*0.0213 );\n    uv.y += zoom * sin( iTime*0.0137 )*0.5;\n       \n#endif\n\n    uv /= zoom; //zoom in    \n\n    vec3 buff = texture( iChannel0, uv ).rgb;\n    \n    //mix in colours based on the raw data-buffer.\n    \n    vec3 col = vec3(0.1);\n    \n    col = mix( col, vec3(0.04,0.5,0.1), buff.y ); //food\n    \n    col = mix( col, vec3(1.0,0.75,0.1), float((buff.x > 0.9)) ); //age / alive\n    \n    fragColor.rgb = col;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define C_TL 0\n#define C_T  1\n#define C_TR 2\n#define C_L  3\n#define C_C  4\n#define C_R  5\n#define C_BL 6\n#define C_B  7\n#define C_BR 8\n        \n/////////////////////////////////////////////////////////////////        \n//Settings\n    \n//https://en.wikipedia.org/wiki/Life-like_cellular_automaton\n    \n//0 : Conways Game of Life (B3/S23)\n//1 : custom experiment \"hunger\"\n//2 : ANNEAL (B4678/S35678)\n\n#define CONWAY 0\n#define HUNGER 1\n#define ANNEAL 2\n\n//change this to try different algorithms\n//Restart the timer (rewind) the shader to re-generate the starting noise\n#define MODE 1\n\n//Increase this to slow down the frames per second of the sim.\n//Set to 1 for no delay (same fps as render)\n#define TICKDELAY 2\n\n/////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvCell = floor( fragCoord );\n    \n      \n    if( iFrame == 0 )\n    {\n        //just use the seconds to alter the hash, change this to a fixed number for repeat runs of the same seed\n        vec2 seed = vec2( iDate.w );\n        const float invOccupancy = 0.5; //increase to reduce starting living cells. start with 50-50%\n        \n        float cellStartValue = step( invOccupancy, hash12(uvCell + seed) );\n        float startFoodValue = mix( 0.8, 1.0, hash12(uvCell + seed * vec2(11.011331,9.753111))); \n        fragColor = vec4( vec3(cellStartValue, startFoodValue, 0.0 ), 1);\n        \n        return;\n    }\n    \n  \n    \n    vec2 uvFull = (fragCoord/iResolution.xy);    \n    vec3 cO = texture( iChannel0, uvFull).rgb;  \n    vec3 col = cO;\n    \n    //only perform the operation on the source data once every n frames, this slows our in-game framerate verses our draw refresh-rate\n    //increase the tickDelay to slow the update-speed, set to zero for realtime.\n    if(iFrame % TICKDELAY == 0) \n    {\n    \n \n        vec3 cell[9];\n\n        cell[C_TL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_T ] = texture( iChannel0, ( (fragCoord+vec2(0.0,+1.0)) /iResolution.xy) ).rgb;  \n        cell[C_TR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,+1.0)) /iResolution.xy) ).rgb;\n        \n        cell[C_L] = texture( iChannel0, ( (fragCoord+vec2(-1.0,0.0)) /iResolution.xy) ).rgb;  \n        cell[C_C] = cO;\n        cell[C_R] = texture( iChannel0, ( (fragCoord+vec2(+1.0,0.0)) /iResolution.xy) ).rgb;  \n        \n        cell[C_BL] = texture( iChannel0, ( (fragCoord+vec2(-1.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_B ] = texture( iChannel0, ( (fragCoord+vec2(0.0,-1.0)) /iResolution.xy) ).rgb;  \n        cell[C_BR] = texture( iChannel0, ( (fragCoord+vec2(+1.0,-1.0)) /iResolution.xy) ).rgb; \n\n        int numNeighbours = 0 ;\n        for(int i=0; i < 9; ++i)\n        {\n            //dont count ourselves - we can include oursleves and alter numbers below as an optimisation but its here for \n            // completeness / so our code more closely matches documentation\n            if(i != C_C)\n            {\n                // bool(float) is true for all non-zero values.\n                // int(bool) just turns the logical 'true' and 'false' into integer '1' and '0' respectively.\n                numNeighbours += int(bool(cell[i].x));\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#if MODE == CONWAY\n        /////////////////////////////////////////////////////////////////\n        //conways game of life     \n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive? (float to bool -> 0.0 = false, otherwise true ).\n        {\n            if(numNeighbours == 2 || numNeighbours == 3) // < 2 underpopulation > 3 opverpopulation. 2 or 3, survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 3 ) //== 3 reproduction\n           {\n               col = vec3(1);\n           }\n        }\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == HUNGER\n        /////////////////////////////////////////////////////////////////\n\n        float alive = cO.x;\n        float food = cO.y;\n        \n        //age\n        alive = max( 0.0, alive - 0.1 ); //\n        \n        //grow food back\n        food += 0.016;\n        \n        //test cell\n        if( bool(cell[C_C].x)  ) //is alive\n        {\n        \n            food -= 0.15; //eat food\n            food -= float(numNeighbours) * 0.05; //crowding reduced food faster\n           \n            if(numNeighbours < 0) //2 underpopulation\n            {\n                alive = 0.0;\n            }\n            else if(numNeighbours > 3 ) //3 overpopulation\n            {\n                alive = 0.0;\n            }\n            else   if(food < 0.1 )//starve\n            {\n               alive = 0.0;\n            }\n                      \n        }\n        else //dead\n        {        \n           if(numNeighbours == 2 ) //3 reproduction\n           {\n               if(food > 0.25) //need starting food\n                   alive = 1.0;\n           }\n        }\n\n\n        col.x = alive;\n        col.y = clamp( food, 0.0, 1.0 );\n        col.z = 0.0;\n        \n        /////////////////////////////////////////////////////////////////\n#elif MODE == ANNEAL\n        /////////////////////////////////////////////////////////////////\n\n        //test cell\n        col = vec3(0);\n        if( bool(cell[C_C].x) ) //is our cell alive?\n        {\n            if(numNeighbours == 3 || numNeighbours == 5 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8) //survive\n            {\n                col = vec3(1);\n            }\n        }\n        else //dead\n        {\n           if(numNeighbours == 4 || numNeighbours == 6 || numNeighbours == 7 || numNeighbours == 8 ) //birth\n           {\n               col = vec3(1);\n           }\n        }\n\n        /////////////////////////////////////////////////////////////////\n#endif\n        \n    }\n    \n       \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t3.1415926535897932384626433832795\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n#define INVPI \t0.31830988618379067153776752674503\n#define INVTWOPI 0.15915494309189533576888376337251\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 312, 362, 1027]], "test": "untested"}
{"id": "sdt3WS", "name": "Slow Vibe", "author": "didididi", "description": "just having fun", "tags": ["colorful"], "likes": 0, "viewed": 191, "published": 3, "date": "1630599779", "time_retrieved": "2024-07-30T19:03:38.681573", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q= p-vec2(0.5,0.5);\n    // Time varying pixel color\n    //vec3 col =mix(vec3 (0.8, 0.5,0.9),vec3(1.0, 0.8, 0.5),sqrt(p.y));\n    vec3 col =mix(vec3 (0.8, 0.5,0.9),vec3(1.0, 0.8, 0.5),sin(iTime+p.y));\n    //vec3 col = 0.8 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    \n    \n    //create spikes\n    float r = 0.2+0.1*cos(atan(q.y,q.x)*(1.0+iTime)+220.0*q.x+iTime*2.0);\n    \n    \n    col *= smoothstep(r,r+0.01, length(q));\n    \n   \n    r=0.02;\n     \n    //openning\n    col *= smoothstep(iTime*0.1, 0.001, abs(q.x+0.1*sin(20.0*q.y)));\n    \n    //background stuffs\n    col *= smoothstep(r, r+0.01, abs(q.x+1.0*sin(220.0*(q.y-0.08)+iTime*0.02)));\n    col *= smoothstep(r, r+0.001, abs(q.x+1.0*cos(22.0*(q.x-0.7)+iTime*0.005)));\n    col *= smoothstep(r, r+0.07, abs(2.0*cos(22.0*(q.x-0.7)+1.0*sin(22.0*(q.y-0.08))+iTime*0.5)));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1037]], "test": "untested"}
{"id": "Ndd3DB", "name": "Ray Marching Test Part 4", "author": "dcyang", "description": "ray marching: and or eor sub", "tags": ["raymarching"], "likes": 0, "viewed": 186, "published": 3, "date": "1630595580", "time_retrieved": "2024-07-30T19:03:39.592138", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n/* 交*/\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/* 并*/\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/* 差*/\nfloat subtractSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n/* 异或*/\nfloat eorSDF(float distA, float distB) {\n    return subtractSDF(unionSDF(distA,distB),intersectSDF(distA,distB));\n}\n/* 圆柱的SDF*/\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n/* 一个立方体的SDF */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.414;\n}\n\n/* 场景的SDF，为球和立方体的交集 */\nfloat sceneSDF(vec3 samplePoint){\n    float res = subtractSDF(intersectSDF(sphereSDF(samplePoint),cubeSDF(samplePoint)),cylinderSDF(samplePoint,4.0,0.5));\n    return res;\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n        if(depth >=end)\n           return end;\n            \n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\n/* 摄像机的旋转矩阵 */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 v = normalize(eye - center);\n    vec3 r = normalize(cross(up,v));\n    vec3 u = cross(v,r);\n    vec3 t = vec3(-dot(eye,r),-dot(eye,u),-dot(eye,v));\n    return mat4(\n        vec4(r,t.x),\n        vec4(u,t.y),\n        vec4(v,t.z),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    mat4 rotateMatrix = viewMatrix(eye,vec3(0.0),vec3(0.0,1.0,0.0));\n    vec3 worldDir = (rotateMatrix*vec4(viewDir,0.0)).xyz;\n    float dist = shortestDistanceFromEyeToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 5.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 122, 168, 168, 200], [202, 211, 253, 253, 285], [287, 296, 341, 341, 374], [375, 387, 427, 427, 502], [503, 521, 566, 635, 1241], [1242, 1270, 1293, 1444, 1881], [1883, 1905, 1939, 1939, 1981], [1983, 2032, 2065, 2065, 2204], [2206, 2297, 2389, 2389, 2686], [2687, 2772, 2837, 2837, 2969], [2971, 3066, 3095, 3095, 3405], [3406, 3504, 3596, 3596, 3888], [3889, 3983, 4059, 4059, 4281], [4282, 4313, 4362, 4362, 4637], [4638, 4638, 4695, 4695, 5386]], "test": "untested"}
{"id": "fdd3DB", "name": "Ray Marching Test Part 3", "author": "dcyang", "description": "ray marching view matrix", "tags": ["raymarching"], "likes": 0, "viewed": 176, "published": 3, "date": "1630594251", "time_retrieved": "2024-07-30T19:03:40.643328", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n/* 一个立方体的SDF */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.414;\n}\n\n/* 场景的SDF，为球和立方体的交集 */\nfloat sceneSDF(vec3 samplePoint){\n    float res = max(cubeSDF(samplePoint),sphereSDF(samplePoint));\n    return res;\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP && depth < end;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\n/* 摄像机的旋转矩阵 */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 v = normalize(eye - center);\n    vec3 r = normalize(cross(up,v));\n    vec3 u = cross(v,r);\n    vec3 t = vec3(-dot(eye,r),-dot(eye,u),-dot(eye,v));\n    return mat4(\n        vec4(r,t.x),\n        vec4(u,t.y),\n        vec4(v,t.z),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    mat4 rotateMatrix = viewMatrix(eye,vec3(0.0),vec3(0.0,1.0,0.0));\n    vec3 worldDir = (rotateMatrix*vec4(viewDir,0.0)).xyz;\n    float dist = shortestDistanceFromEyeToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 5.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 141, 164, 315, 752], [754, 776, 810, 810, 852], [854, 903, 936, 936, 1020], [1022, 1113, 1205, 1205, 1457], [1458, 1543, 1608, 1608, 1740], [1742, 1837, 1866, 1866, 2176], [2177, 2275, 2367, 2367, 2659], [2660, 2754, 2830, 2830, 3052], [3053, 3084, 3133, 3133, 3408], [3409, 3409, 3466, 3466, 4157]], "test": "untested"}
{"id": "NddGDS", "name": "chess hypno", "author": "yurka", "description": "Hypnosis chess shader - improves your chess skill", "tags": ["chess", "hypno"], "likes": 1, "viewed": 133, "published": 3, "date": "1630585600", "time_retrieved": "2024-07-30T19:03:41.402299", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*vec3(\n            sin(cos(uv.x * 45.0) * cos(uv.y * 45.0) * 3.14 +\n            cos(iTime*1.13 + uv.x * 170.0 + 2.0) * 0.3 +\n            cos(iTime*0.9 + uv.y * 180.0 + 2.0) * 0.26\n            ), \n            sin(cos(uv.x * 45.0) * cos(uv.y * 45.0) * 3.14 +\n            cos(iTime*0.23 + uv.x * 162.0 + 2.0) * 0.13 +\n            cos(iTime*-1.9 + uv.y * 185.0 + 2.0) * 0.21\n            ), \n            sin(cos(uv.x * 45.0) * cos(uv.y * 45.0) * 3.14 +\n            cos(iTime*-1.83 + uv.x * 152.0 + 2.0) * 0.73 +\n            cos(iTime*2.9 + uv.y * 195.0 + 2.0) * 0.29\n            ));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 840]], "test": "untested"}
{"id": "fst3WS", "name": "Fork Voronoi test", "author": "sky8948", "description": "Playing around with Voronoi", "tags": ["2d", "voronoi", "light", "polygon"], "likes": 6, "viewed": 298, "published": 3, "date": "1630582661", "time_retrieved": "2024-07-30T19:03:42.315856", "image_code": "vec2 r2D(vec2 p)\n{\n    return vec2(fract(sin(dot(p, vec2(92.51, 65.19)))*4981.32),\n                fract(sin(dot(p, vec2(23.34, 15.28)))*6981.32));\n}\n\n#define PI 3.141592\n\nfloat polygon(vec2 p, float s)\n{\n    float a = ceil(s*(atan(-p.y, -p.x)/PI+1.)*.5);\n    float n = 2.*PI/s;\n    float t = n*a-n*.5;\n    return mix(dot(p, vec2(cos(t), sin(t))), length(p), .3);\n}\n\nfloat voronoi(vec2 p, float s)\n{\n    vec2 i = floor(p*s);\n    vec2 current = i + fract(p*s);\n    float min_dist = 1.;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = i + vec2(x, y);\n            vec2 point = r2D(neighbor);\n            point = 0.5 + 0.5*sin(iTime*.5 + 6.*point);\n            float dist = polygon(neighbor+point - current, 3.);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    return min_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*2.-1.;\n    vec2 e = vec2(.01, .0);\n    \n    float s = 2.;\n    float vor = 1.-voronoi(uv, s);\n    float dx = 1.-voronoi(uv-e.xy, s);\n    float dy = 1.-voronoi(uv-e.yx, s);\n    dx = (dx-vor)/e.x;\n    dy = (dy-vor)/e.x;\n    \n    float t = iTime;\n    vec3 n = normalize(vec3(dx, dy, 1.));\n    vec3 lp = vec3(cos(t), sin(t), .5)*2.;\n    vec3 ld = normalize(lp-vec3(uv, 0.));\n    vec3 ed = normalize(vec3(0., .0, 1.)-vec3(uv, 0.));\n    vec3 hd = normalize(ld + ed);\n    float sl = pow(max(dot(hd,n), 0.),4.);\n    float oc = clamp(pow((vor), 2.), 0., 1.);\n    float amb = (1.-vor)*.5;\n    float diff = max(dot(n, ld), 0.)*.75;\n    float l = oc*diff+amb+sl;\n    \n    vec3 col = vec3(0.);\n    col += l*texture(iChannel0, normalize(reflect(vec3(0., .0, 1.), n))).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fst3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 149], [172, 172, 204, 204, 365], [367, 367, 399, 399, 859], [861, 861, 918, 918, 1748]], "test": "untested"}
{"id": "sdcGWB", "name": "Vines at Night 2", "author": "dr2", "description": "Vine covered pillars (upgraded visuals)", "tags": ["shadow", "vine"], "likes": 17, "viewed": 294, "published": 3, "date": "1630574181", "time_retrieved": "2024-07-30T19:03:43.351088", "image_code": "// \"Vines at Night 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // = 0/1 - optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_LIT 4\n\nvec3 ltPos[N_LIT + 1], ltAx;\nvec2 gId[2];\nfloat tCur, dstFar, hgSize[2], bRad, bDel, vLev, tileHt;\nint idObj;\nconst int idVin = 1, idCol = 2, idCap = 3, idFlr = 4;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, cRad, cLen, hp, br, tw, a, s, r;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId[0] * hgSize[0]);\n  cRad = 0.1;\n  cLen = 1.;\n  tw = 1.;\n  d = dMin;\n  vLev = 0.;\n  for (float k = float (VAR_ZERO); k < 5.; k ++) {\n    tw = - tw;\n    s = (k + 1.) / 5.;\n    hp = tw * (16. - 10. * s) + bRad - 0.5;\n    br = (0.015 - 0.01 * s + 0.005 * (bRad - 0.75)) * (1.5 - 0.3 * p.y / cLen);\n    q = p;\n    q.y -= (bDel + 1.3 * s) * hp;\n    a = 2. * pi * q.y / hp;\n    q.xz = Rot2D (q.xz, (5. - 3. * bDel) * pi * (sign (bRad - 0.5) * a +\n       (0.01 * bDel + 0.3 * s) * sin (3. * a)));\n    q.x -= cRad + br;\n    r = length (q.xz) - br;\n    if (r < d) vLev = s;\n    d = SmoothMin (d, r, 0.005);\n  }\n  d = max (d, abs (p.y - cLen) - cLen);\n  DMIN (idVin);\n  q = p;\n  q.y -= cLen;\n  d = PrCylDf (q.xzy, cRad, cLen);\n  DMIN (idCol);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 6.));\n  q.y -= 2. * cLen + 0.065 - 0.1 * cos (pi * length (q.xz) / (0.5 * sqrt3 * hgSize[0]));\n  q.z = abs (q.z) - 0.04;\n  d = PrRoundBox2Df (q.yz, vec2 (0.025, 0.01), 0.01);\n  DMIN (idCap);\n  q = p;\n  q.y = abs (q.y - cLen) - cLen + 0.03;\n  d = PrCylDf (q.xzy, cRad + 0.05, 0.03);\n  DMIN (idCap);\n  return 0.7 * dMin;\n}\n\nvoid SetObjConf ()\n{\n  vec2 fRand;\n  fRand = Hashv2v2 (gId[0] + 27.1);\n  bRad = 0.5 + 0.5 * fRand.x;\n  bDel = fRand.y;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize[0] / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize[0];\n  pM = HexToPix (PixToHex (ro.xz / hgSize[0]));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId[0] = PixToHex (p.xz / hgSize[0]);\n    if (gId[0] != gIdP) {\n      gIdP = gId[0];\n      SetObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0. || p.y > 3.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId[1] * hgSize[1]);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = q.y - tileHt + 0.01;\n  if (d < 0.05) d = SmoothMax (abs (q.x) - 0.495 * sqrt3 * hgSize[1], d, 0.01);\n  return d;\n}\n\nvoid SetFObjConf ()\n{\n  tileHt = 0.03 + 0.02 * Hashfv2 (gId[1] + 27.1);\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize[1] / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize[1];\n  pM = HexToPix (PixToHex (ro.xz / hgSize[1]));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId[1] = PixToHex (p.xz / hgSize[1]);\n    if (gId[1] != gIdP) {\n      gIdP = gId[1];\n      SetFObjConf ();\n    }\n    d = FObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 FObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId[0] = PixToHex (p.xz / hgSize[0]);\n    if (gId[0] != gIdP) {\n      gIdP = gId[0];\n      SetObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.07 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, mDir, vn;\n  float mRad, bs, ts;\n  mDir = normalize (vec3 (0.6, 0.03, 1.));\n  mRad = 0.025;\n  col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - 1. + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) / mRad);\n      col += vec3 (1., 0.9, 0.5) * (0.07 + 0.93 * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n         (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.));\n    }\n  } else col += StarPat (rd, 6.);\n  return col;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstLim)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  for (int k = VAR_ZERO; k < N_LIT; k ++) {\n    dirGlow = ltPos[k] - ro;\n    dstGlow = length (dirGlow);\n    brGlow += smoothstep (-0.1, 0.1, dstLim - dstGlow) *\n       pow (max (dot (rd, dirGlow), 0.) / dstGlow, 2048.) / dstGlow;\n  }\n  return clamp (brGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltVec, ltDir, roo, col, c, vn, q;\n  vec2 vf;\n  float dstObj, dstFObj, atten, a, sh, y;\n  bool isBg;\n  isBg = true;\n  vf = vec2 (0.);\n  roo = ro;\n  dstFObj = FObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstFObj < min (dstObj, dstFar)) {\n    dstObj = dstFObj;\n    idObj = idFlr;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj == idFlr) {\n      vn = FObjNf (ro);\n      col4 = vec4 (0.5, 0.5, 0.5, 0.1) * (0.7 + 0.3 * Hashfv2 (17.1 * gId[1])) *\n         (1. - 0.2 * Fbm2 (32. * ro.xz));\n      vf = vec2 (32., 2. * (1. - smoothstep (0.1, 0.3, dstObj / dstFar)));\n    } else {\n      vn = ObjNf (ro);\n      q = ro;\n      q.xz -= HexToPix (gId[0] * hgSize[0]);\n      if (idObj == idVin) {\n        col4 = vec4 (0.6, 0.7, 0.4, 0.2) * (0.4 + 0.6 * vLev);\n        vf = vec2 (64., 2. * (2. - vLev));\n      } else if (idObj == idCol) {\n        col4 = vec4 (0.6, 0.5, 0.4, 0.1);\n        a = mod (16. * (atan (q.z, - q.x) / (2. * pi)), 1.);\n        vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a * a));\n        y = mod (8. * q.y, 1.) - 0.5;\n        vn.y = 0.15 * pi * sign (y) * SmoothBump (0., 0.06, 0.02, 0.5 - abs (y));\n        vn = normalize (vn);\n        vf = vec2 (64., 0.5);\n      } else if (idObj == idCap) {\n        col4 = vec4 (0.5, 0.4, 0.3, 0.1);\n        if (vn.y > 0.99 && length (q.xz) < 0.14) col4 *= 0.6;\n        vf = vec2 (32., 1.);\n      }\n    }\n    isBg = false;\n  }\n  if (! isBg) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    ltVec = roo - ro;\n    atten = 0.1 + 0.9 * smoothstep (0.7, 0.85, dot (ltAx, - normalize (ltVec))) / (1. + 0.05 * dot (ltVec, ltVec));\n    ltVec += ltPos[N_LIT];\n    ltDir = normalize (ltVec);\n    sh = ObjSShadow (ro, ltDir, length (ltVec));\n    col = atten * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    c = vec3 (0.);\n    for (int k = VAR_ZERO; k < N_LIT; k ++) {\n      ltVec = ltPos[k] - ro;\n      ltDir = normalize (ltVec);\n      atten = 1. / (1. + 0.2 * dot (ltVec, ltVec));\n      sh = ObjSShadow (ro, ltDir, length (ltVec));\n      c += atten * col4.rgb * sh * max (dot (vn, ltDir), 0.);\n    }\n    col = mix (col, c * vec3 (0.7, 0.7, 1.), smoothstep (-0.05, 0.05, Maxv3 (c) - Maxv3 (col)));\n  }\n  if (dstObj / dstFar > 0.6) col = mix (col, SkyCol (rd), smoothstep (0.6, 1., dstObj / dstFar));\n  col = mix (col, vec3 (0.4, 0.9, 1.), min (2.5 * GlowCol (roo, rd, min (dstObj, dstFar)), 1.));\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, asp, zmFac, sr, vel, tCyc, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize[0] = 1.;\n  hgSize[1] = 1./3.;\n  vel = 0.1;\n  p1 = 0.5 * (TrackPath (vel * tCur + 0.2) + TrackPath (vel * tCur + 0.4));\n  p2 = 0.5 * (TrackPath (vel * tCur - 0.2) + TrackPath (vel * tCur - 0.4));\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2 * (2. * SmoothBump (0.25, 0.75, 0.15, mod (0.07 * vel * tCur, 1.)) - 1.);\n  ro.y = 0.7;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = 0.04 * pi * sin (0.05 * 2. * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.2;\n  dstFar = 20.;\n  ltPos[N_LIT] = 0.5 * vuMat * normalize (vec3 (cos (2. * pi * (0.022 * tCur)), 1., 0.));\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  for (int k = 0; k < N_LIT; k ++) {\n    s = float (k) / float (N_LIT);\n    ltPos[k] = vec3 (Rot2D (vec2 (0., 2.5 + float (k)), 0.5 * (0.7 + 0.3 * s) * pi *\n       sin (pi * (0.05 * (1. + 0.35 * s) * (tCur + 10.) + 2. * s))) + vec2 (0., ro.z),\n       0.8 + 0.3 * sin (2. * pi * (0.07 * tCur + s))).xzy;\n  }\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1060, 1060, 1082, 1082, 2328], [2330, 2330, 2350, 2350, 2450], [2452, 2452, 2485, 2485, 3599], [3601, 3601, 3622, 3622, 3877], [3879, 3879, 3902, 3902, 4207], [4209, 4209, 4230, 4230, 4282], [4284, 4284, 4318, 4318, 5422], [5424, 5424, 5446, 5446, 5702], [5704, 5704, 5755, 5755, 6159], [6161, 6161, 6196, 6196, 6649], [6651, 6651, 6674, 6674, 7221], [7223, 7223, 7271, 7271, 7597], [7599, 7599, 7634, 7634, 10158], [10160, 10160, 10186, 10186, 10578], [10580, 10580, 10636, 10636, 12474], [12476, 12476, 12518, 12518, 12569], [12571, 12571, 12618, 12618, 12665], [12667, 12667, 12691, 12691, 12921], [12923, 12923, 12947, 12947, 13007], [13009, 13009, 13031, 13031, 13069], [13071, 13071, 13093, 13093, 13131], [13133, 13133, 13178, 13178, 13270], [13272, 13272, 13317, 13317, 13355], [13357, 13357, 13414, 13414, 13497], [13499, 13499, 13529, 13529, 13642], [13644, 13644, 13680, 13680, 13886], [13920, 13920, 13944, 13944, 14004], [14006, 14006, 14030, 14030, 14142], [14144, 14144, 14168, 14168, 14311], [14313, 14313, 14338, 14338, 14524], [14526, 14526, 14551, 14551, 14776], [14778, 14778, 14799, 14799, 14954], [14956, 14956, 14985, 14985, 15197], [15199, 15199, 15238, 15238, 15490]], "test": "untested"}
{"id": "7s33DS", "name": "Overexposure zebra pattern", "author": "kaihagseth", "description": "Draws a zebra pattern over the overexposed areas of video.", "tags": ["zebra", "exposure"], "likes": 1, "viewed": 313, "published": 3, "date": "1630571459", "time_retrieved": "2024-07-30T19:03:44.355404", "image_code": "#define STRIPES 40.\n#define PW STRIPES/iResolution.y\n#define PI 3.141592\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle)) ;\n}\nfloat zebra(in vec2 uv){\n    uv.y+= iTime/20.;\n    uv*=rotate2d(-PI/4.);\n    uv = fract(uv* STRIPES);\n    return ((1.-smoothstep(.2-PW, .2+PW, uv.y)) + smoothstep(.7-PW, .7+PW, uv.y))+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 px = texture(iChannel0, uv);\n    if (px.g > .9){\n        uv = fragCoord/iResolution.y;\n        px *= vec4(zebra(uv));\n    }\n    fragColor = px;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s33DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 103, 103, 173], [174, 174, 198, 198, 363], [365, 365, 422, 472, 667]], "test": "untested"}
{"id": "7d33DS", "name": "cellular dithering", "author": "pali6", "description": "Some sort of a dynamic dithering effect that's basically a cellular automaton when you think about it.", "tags": ["automata", "cell", "dithering"], "likes": 2, "viewed": 305, "published": 3, "date": "1630569934", "time_retrieved": "2024-07-30T19:03:45.186181", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R 2\n#define UPDATE_PROB 0.1\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n    if(rand(uv + vec2(iTime)) > UPDATE_PROB)\n    {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    float avgL = 0.;\n    float avgBL = 0.;\n    float count = 0.;\n    for(int dx = -R; dx <= R; dx++)\n    {\n        for(int dy = -R; dy <= R; dy++)\n        {\n            vec4 pix = texture(iChannel1, uv + vec2(dx, dy) / iResolution.xy);\n            vec4 pixB = texture(iChannel0, uv + vec2(dx, dy) / iResolution.xy);\n            float mul = 1. / (1. + length(vec2(dx, dy)));\n            count += mul;\n            avgL += (pix.r + pix.g + pix.b) / 3. * mul;\n            avgBL += (pixB.r + pixB.g + pixB.b) / 3. * mul;\n        }\n    }\n    avgL /= count;\n    avgBL /= count;\n    fragColor = abs(avgBL - avgL) < 0.05 ? texture(iChannel0, uv) : avgBL > avgL ? vec4(0,0,0,1) : vec4(1,1,1,1);\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d33DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "sd33WS", "name": "Slowtember 01-03: Street/Walk", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 4, "viewed": 222, "published": 3, "date": "1630564706", "time_retrieved": "2024-07-30T19:03:46.098742", "image_code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 color(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat circle(vec2 uv, vec2 center, float size, float e) {\n    uv -= center;\n    return smoothstep(size * .5 + e,size * .5 - e, length(uv));\n}\n\nfloat ellipse(vec2 uv, vec2 center, vec2 size, float e) {\n    uv -= center;\n    uv.y *= size.x / size.y;\n    return circle(uv, vec2(.0), size.x, e);\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * PI) * uv.x - sin(angle * PI) * uv.y,\n        sin(angle * PI) * uv.x + cos(angle * PI) * uv.y\n    );\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return \n        smoothstep(size.x * .5 + e, size.x * .5 - e, uv.x) *\n        smoothstep(-size.x * .5 - e, -size.x * .5 + e, uv.x) *\n        smoothstep(size.y * .5 + e, size.y * .5 - e, uv.y) *\n        smoothstep(-size.y * .5 - e, -size.y * .5 + e, uv.y);\n}\n\nfloat rrect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, r, e) +\n        circle(uv, - v1, r, e) +\n        circle(uv, + v2, r, e) +\n        circle(uv, - v2, r, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, e)\n    );\n}\n\nfloat rrect2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return n(\n        rrect(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, E)\n    );\n}\n\nfloat triangle(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, - uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-e, +e, uv.y);\n}\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / PI;\n    return n(\n        circle(uv, p1, size, e) +\n        circle(uv, p2, size, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), -angle, e)\n    );\n}\n\nvec3 building(float x, vec2 uv, vec3 c) {\n    float height = .4 + .35 * rand(floor(x) + 8234.);\n    height -= mod(height, .1) - .07;\n\n    float color_x = rand(floor(x) + 233.);\n    vec3 bg_color = vec3(.2) + .05 * color(color_x);\n    vec3 door_color = vec3(.2, .0, .0) + .1 * color(color_x + .5);\n\n    c = mask(c, bg_color, rrect2(uv, vec2(.0, -.2 + height * .5), vec2(.3, height), .01, .0, E));\n    \n    float door_pos = .2 * (rand(floor(x) + 234.) - .5);\n\n    c = mask(c, door_color, rrect2(uv, vec2(door_pos, -.15), vec2(.08, .1), .01, .0, E));\n    c = mask(c, vec3(.5, .5, .0), circle(uv, vec2(door_pos + .02, -.15), .02, E));\n    \n    float mask_height = height - .165;\n    mask_height -= mod(mask_height, .1);\n    float window_mask = rect(uv, vec2(.0, mask_height * .5 - .04), vec2(.3, mask_height), .0, E);\n\n    vec2 uv2 = mod(uv + .05, .1) - .05;\n    float light = rand(floor(x) + 432. + floor((uv.x + .05) * 10.) * 233. + floor((uv.y + .05) * 10.) * 523.);\n    c = mask(c, light < .3 ? vec3(.1, .1, .1) : vec3(.7, .7, .5), window_mask * rrect(uv2, vec2(.0, -.0), vec2(.07, .07), .01, .0, E));\n    return c;\n}\n\nvec3 dude(vec2 uv, vec3 c, float t0) {\n    const vec2 LEG0[8] = vec2[](vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08),vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08));\n    const vec2 LEG1[8] = vec2[](vec2(+.06,-.20),vec2(+.06,-.20),vec2(-.01,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(+.02,-.18),vec2(+.06,-.15));\n    const vec2 LEG2[8] = vec2[](vec2(+.11,-.30),vec2(+.06,-.30),vec2(-.02,-.30),vec2(-.06,-.30),vec2(-.09,-.28),vec2(-.12,-.25),vec2(-.04,-.20),vec2(+.01,-.25));\n    const vec2 ARM0[8] = vec2[](vec2(-.00,+.07),vec2(-.01,+.05),vec2(+.01,+.08),vec2(+.02,+.09),vec2(+.03,+.07),vec2(+.03,+.05),vec2(+.02,+.08),vec2(+.01,+.09));\n    const vec2 ARM1[8] = vec2[](vec2(-.05,+.02),vec2(-.07,+.02),vec2(+.00,+.00),vec2(+.03,+.02),vec2(+.04,+.01),vec2(+.05,+.01),vec2(+.00,+.01),vec2(-.04,+.02));\n    const vec2 ARM2[8] = vec2[](vec2(-.06,-.06),vec2(-.08,-.05),vec2(+.00,-.07),vec2(+.05,-.07),vec2(+.07,-.07),vec2(+.09,-.06),vec2(+.01,-.06),vec2(-.04,-.06));\n\n    float t = mod(t0, .8);\n    float t2 = t * 10.;\n    float t3 = mod(t, .1) * 10.;\n    \n    int ti1 = int(t2);\n    int ti1_next = int(mod(t2 + 1., 8.));\n    \n    int ti2 = int(mod(t2 + 4., 8.));\n    int ti2_next = int(mod(t2 + 5., 8.));\n    \n    vec2 l10 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l11 = (1. - t3) * LEG1[ti1] + t3 * LEG1[ti1_next];\n    vec2 l12 = (1. - t3) * LEG2[ti1] + t3 * LEG2[ti1_next];\n    \n    vec2 l20 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l21 = (1. - t3) * LEG1[ti2] + t3 * LEG1[ti2_next];\n    vec2 l22 = (1. - t3) * LEG2[ti2] + t3 * LEG2[ti2_next];\n    \n    vec2 a10 = (1. - t3) * ARM0[ti1] + t3 * ARM0[ti1_next];\n    vec2 a11 = (1. - t3) * ARM1[ti1] + t3 * ARM1[ti1_next];\n    vec2 a12 = (1. - t3) * ARM2[ti1] + t3 * ARM2[ti1_next];\n    \n    vec2 a20 = (1. - t3) * ARM0[ti2] + t3 * ARM0[ti2_next];\n    vec2 a21 = (1. - t3) * ARM1[ti2] + t3 * ARM1[ti2_next];\n    vec2 a22 = (1. - t3) * ARM2[ti2] + t3 * ARM2[ti2_next];\n    \n    vec3 c0 = color(t0 * .2);\n    \n    c = mask(c, .4 * c0, line(uv, l20, l21, .05, E));\n    c = mask(c, .4 * c0, line(uv, l21, l22, .05, E));\n    \n    c = mask(c, .4 * c0, line(uv, a20, a21, .04, E));\n    c = mask(c, .4 * c0, line(uv, a21, a22, .04, E));\n \n    c = mask(c, .5 * c0, line(uv, l10 + vec2(.0, .01), l10 + vec2(.01, .15), .1, E));\n    \n    c = mask(c, .5 * c0, line(uv, l10, l11, .05, E));\n    c = mask(c, .5 * c0, line(uv, l11, l12, .05, E));\n    \n    c = mask(c, .6 * c0, line(uv, a10, a11, .04, E));\n    c = mask(c, .6 * c0, line(uv, a11, a12, .04, E));\n    \n    c = mask(c, .5 * c0, circle(uv, l10 + vec2(.015, .25), .1, E));\n\n    return c;\n}\n\nvec3 lamp(vec2 uv, vec3 c) {\n\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, -.1), vec2(.03, .25), .01, .0, E));\n    \n    float light_mask = n(\n        triangle(uv, vec2(.23, -.1), vec2(.2, .25), .0, .01) +\n        rect(uv, vec2(.25, -.1), vec2(.04, .25), .0, .01) +\n        triangle(uv, vec2(.27, -.1), vec2(.2, .25), .0, .01) +\n        ellipse(uv, vec2(.25, -.23), vec2(.24, .1), .01)\n    );\n    \n    c = mask(c, vec3(.8, .8, .0), light_mask * .5 * n(uv.y * 2.5 + .6));\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, .02), vec2(.06, .02), .01, .0, E));\n\n    return c;\n}\n\nvec3 road(vec2 uv, vec3 c) {\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.2));\n    c = mask(c, vec3(.05), smoothstep(E, -E, uv.y+.24));\n    c = mask(c, vec3(.1), smoothstep(E, -E, uv.y+.25));\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.38));\n    \n    c = mask(c, vec3(.6), rrect(uv, vec2(.0, -.31), vec2(.05, .01), .0, .0, E));\n    \n    return c;\n}\n\nvec3 sky(vec2 uv, float x) {\n    vec3 c = vec3(0, .3 - .5 * uv.y, .5);\n    \n    float t = x * .1;\n    \n    const float size = .05;\n    vec2 uv2 = mod(uv + vec2(t, .0), size);\n    float r1 = rand(floor((uv.x + t + size) * 20.) * 223. + floor((uv.y + 10. + size) * 20.) * 523.);\n    float r2 = rand(floor((uv.x + t + size) * 20.) * 523. + floor((uv.y + 10. + size) * 20.) * 823.);\n    float r3 = rand(floor((uv.x + t + size) * 20.) * 923. + floor((uv.y + 10. + size) * 20.) * 323.);\n    if (r3 < .1) {\n    \n        float star =  n(uv.y * 2.) * n(\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .002, E) +\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .005, .015)\n        );\n    \n        c = mask(c, vec3(.9, .9, .7), star);\n    }\n    \n    c = mask(c, vec3(.9, .9, .7), n(circle(uv, vec2(-.6,.25), .1, E) + circle(uv, vec2(-.6,.25), .11, .02)));\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t) {\n    float bg_time = uv.x + t * .4;\n    \n    vec3 c = sky(uv, t);\n    \n    vec2 uv1 = vec2(mod(bg_time, .2), uv.y);\n    c = road(uv1, c);\n    \n    vec2 uv2 = vec2(mod(bg_time, .32), uv.y);\n    c = building(bg_time/.32, uv2 - vec2(.15, .0), c);\n\n    vec2 uv3 = vec2(mod(bg_time, .5), uv.y);\n    c = lamp(uv3, c);\n\n    c = dude(uv + vec2(.0, .1), c, t * .6);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    \n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = colorShiftImage(uv, iTime * .5, iTime * 5., .0);\n \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 55, 55, 89], [91, 91, 115, 115, 200], [202, 202, 223, 223, 392], [394, 394, 411, 411, 455], [457, 457, 495, 495, 537], [539, 539, 596, 596, 680], [682, 682, 739, 739, 832], [834, 834, 869, 869, 1008], [1010, 1010, 1077, 1077, 1384], [1386, 1386, 1463, 1463, 1872], [1874, 1874, 1952, 1952, 2142], [2144, 2144, 2215, 2215, 2528], [2530, 2530, 2590, 2590, 2822], [2824, 2824, 2865, 2865, 3941], [6599, 6599, 6627, 6627, 7172], [7174, 7174, 7202, 7202, 7533], [7535, 7535, 7563, 7563, 8525], [8527, 8527, 8557, 8557, 8934], [8936, 8936, 8999, 8999, 9265], [9267, 9267, 9324, 9324, 9517]], "test": "untested"}
{"id": "ss33Rl", "name": "Vapor Cube Durability Testing", "author": "Tater", "description": "cubes", "tags": ["3d", "raymarching", "glow"], "likes": 19, "viewed": 599, "published": 3, "date": "1630549573", "time_retrieved": "2024-07-30T19:03:46.850731", "image_code": "#define STEPS 220.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nvec3 glow = vec3(0);\nvec3 rlim(vec3 p, float c, vec3 l ){\n    return p-c*clamp(round(p/c),-l,l);\n}\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(43.234,25.433)))*944.3434);\n}\nfloat frame(vec3 p, vec3 b, float e){\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n/*\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n*/\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//https://www.desmos.com/calculator/dxixbmrvmb\nfloat easeOutElastic(float x) {\n    float c4 = (2. * pi) / 3.;\n    return x = pow(1.63,-10.*x) * sin((x*5.25-.75)*c4)+1.;\n}\n//I would like to make a more procdeural version of this but so far this one still\n//looks the best. \nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n//https://www.shadertoy.com/view/fdsXRf\nfloat timeRemap (float t, float s1, float s2){\n    return (s1-s2)*(fract(t)*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;\n}\nvec2 map(vec3 p){\n    float t = iTime*0.8*(6./5.);\n    float ttt = t;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    float m= 2.4;\n    vec2 id = floor(clamp(p.xz,-13.,13.)/m-0.5);\n    float off = 0.;\n    \n    float cycle = mod(floor(t/4.0+0.5),6.0);\n    //cycle = .0;\n    if(cycle == 0.0){\n        t+=length(id+1.0)*0.07;\n    }\n    if(cycle == 1.0){\n        t+=length(id-21.0)*0.07-1.685;\n    }\n    if(cycle == 2.0){\n        if(mod(id.y+mod(id.x,2.0),2.0)<1.0)t+=0.15;\n        id = abs(id+1.);\n        t+=max(id.x,id.y)*0.2;\n        t-=0.15;\n    }\n    if(cycle == 3.0){\n        t+=0.562;\n        t+=id.y*0.08;\n        t+=id.x*0.01;\n    }\n    /*\n    if(cycle == 4.0){\n        t+=0.4;\n        //id=id+1.0;\n        id.y+=1.0;\n        id.x+=7.0;\n        float ang = atan(id.x,id.y)*0.2;\n        t+=ang;\n    }\n    */\n    if(cycle == 4.0){\n        t+=0.3;\n        id+=1.0;\n        t+=(mod(id.y,2.0)*3.0-2.0)*abs(id.x)*0.0175;\n    }\n    if(cycle == 5.0){\n        t+=h21(id);\n    }\n    t = timeRemap(t,1.0,0.0);//changing the third value here makes some interesting bugs\n    \n\n    \n    \n    float tt = t;\n    t = (mod(t,2.0)>1.0)?easeOutBounce(fract(t))+floor(t):easeOutElastic(fract(t))+floor(t);\n    \n    if(mod(tt,2.0)<1.0) off = t-floor(tt);\n    else off = 1.0-(t-floor(tt));\n    \n    //CUBES\n    p.y-=off*13.;\n    p = rlim(p,m,vec3(5,0,5));\n    a.x = box(p,vec3(0.99));\n    //CUBE FRAMES\n    b.x = frame(p,vec3(1.0),0.06)*0.8;\n    float gl = 0.05;\n    glow+=gl/(gl+b.x*b.x)*vec3(0.373,0.200,1.000)*clamp((0.5-abs(0.5-off))*5.0,0.0,1.0);\n    \n    a=(a.x<b.x)?a:b;\n\n    //Domain fuckery\n    //#define rdt(a) pow(smoothstep(0.5,1.0,abs(a)),2.0)*1.0\n    vec3 d = abs(p)-vec3(m/1.7,0,m/1.7);\n    vec3 d2 = abs(po)-m*5.4;\n    float domBox = max(d.x,d.z);\n    float outBox = max(d2.x,d2.z);\n    domBox = min(-outBox,domBox);\n    a.x = min(-domBox,a.x);\n    \n    //Floor\n    p = po;\n    b.x = box(p-vec3(0,-31,0),vec3(13,30,13));\n    b.y = 3.0;\n    a=(a.x<b.x)?a:b;\n    \n    //BOX RINGS\n    t = ttt;\n    float sz = 16.;\n    p.y+=-t*14.0;\n    p.y = pmod(p.y,8.0);\n    b.x = box(p,vec3(sz,1,sz));\n    b.x = max(-box(p,vec3(sz-1.,6,sz-1.)),b.x);\n    b.x = max(po.y-3.,b.x);\n    \n    glow+=0.1/(0.1+b.x*b.x)*vec3(0.733,0.000,1.000)*0.2*smoothstep(4.0,-6.0,po.y);\n    b.y = 5.0;\n    a=(a.x<b.x)?a:b;\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,12,-30);\n    ro.zx*=rot(iTime*0.15*pi/3.*(6./5.));\n    \n    vec3 lk = vec3(0,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.7+uv.x*r+uv.y*cross(f,r);\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO = 0.;\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        \n        if((d.x)<0.005){\n            if(d.y == 5.0){\n                d.x = 0.08;\n            }\n            else{\n            hit = true;\n            break;\n            }\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            dO = MDIST;\n            break;\n        }\n        dO+=d.x*0.9;\n    }\n    vec3 al = vec3(0);\n    if(hit){\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        if(d.y==1.0) al = vec3(0.000,0.984,1.000)*1.4;\n        if(d.y==2.0) al = vec3(0.004,0.137,0.537);\n        if(d.y==3.0) {\n        al = vec3(0.588,0.180,1.000);\n        al+=smoothstep(0.95,1.0,sin(p.x*pi*0.75+pi/2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.y*pi*0.75+2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.z*pi*0.75+pi/2.0))*1.6;\n        }\n        //Lighting EQs from blackle\n        float diff = length(sin(n*3.)*.5+.5)/sqrt(3.);\n        float spec = length(sin(r*2.)*.4+.6)/sqrt(3.);\n        col = al*diff+pow(spec,8.0)*0.4*vec3(1.000,0.722,0.910);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(0.05,n,p)*AO(0.1,n,p);\n        ao*=smoothstep(-.4,.4,map(p+n*.4).x*2.1);\n        col*=pow(ao,0.7);\n    }\n    else{\n        col = mix(vec3(0),vec3(0.055,0.000,0.161),length(pow(uv,vec2(3.0))));\n    \n    }\n    //col = sqrt(col);\n    col+=glow*0.07;\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            glow = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 208, 208, 249], [250, 250, 268, 268, 330], [331, 331, 368, 368, 648], [649, 770, 796, 796, 854], [855, 902, 933, 933, 1025], [1026, 1128, 1158, 1158, 1487], [1488, 1528, 1574, 1574, 1646], [1647, 1647, 1664, 1664, 3969], [3970, 3970, 3988, 3988, 4115], [4117, 4117, 4171, 4171, 5988], [6033, 6033, 6090, 6090, 6532]], "test": "untested"}
{"id": "Ndc3DS", "name": "textures", "author": "jorge2017a1", "description": "textures", "tags": ["textures"], "likes": 5, "viewed": 190, "published": 3, "date": "1630549161", "time_retrieved": "2024-07-30T19:03:47.779249", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat columnas(vec3 p)\n{\n p.y+=6.0;\n    p.x= opRep1D(p.x, 15.0 );\n    p.z= opRep1D(p.z, 10.0 );\n    \n    float  distToCapsule =sdCylinder( p, vec2(0.5,2.0) );\n    //superior\n    float sdb1a = sdBox( p-vec3(0.0,2.5,0.0), vec3(1.0,0.125,1.0));\n    float sdb1b = sdBox( p-vec3(0.0,2.2,0.0), vec3(1.5,0.125,1.5));\n    float sdb1c = sdBox( p-vec3(0.0,2.0,0.0), vec3(1.0,0.125,1.25));\n    float sdb1d = sdBox( p-vec3(0.0,2.7,0.0), vec3(0.8,0.125,0.7));\n    float sdb1e = sdBox( p-vec3(0.0,2.7,0.0), vec3(0.5,1.0,0.7));\n    \n    \n    //inferior\n    float sdb2a = sdBox( p-vec3(0.0,-2.0,0.0), vec3(1.0,0.125,1.0));\n    float sdb2b = sdBox( p-vec3(0.0,-2.5,0.0), vec3(1.5,0.25,1.0));\n    \n    float  d=999.9;\n    d= unionSDF(d,distToCapsule); \n    d= unionSDF(d,sdb1a);\n    d= unionSDF(d,sdb1b);\n    d= unionSDF(d,sdb1c);\n    d= unionSDF(d,sdb1d);\n    d= unionSDF(d,sdb1e);\n    \n    d= unionSDF(d,sdb2a);\n    d= unionSDF(d,sdb2b);\n    return d;\n}   \n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n    vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,101.0,-1.0)); //inf\n    \n    p.y=p.y-10.0;\n    \n    vec3 p2=p-vec3(.0,7.,.0);\n    p2= rotate_y( p2, radians(iTime*20.0));\n    \n     \n    float sdb1= sdBox(p2, vec3(10.0,2.0,2.0) );  //horizontal\n    float sdb2= sdBox(p-vec3(.0,2.0,.0), vec3(2.0,13.0,2.0) );  //vertical\n    \n    float sds1= sdSphere( p-vec3(.0,7.,.0), 4.5 );\n    float sds2= sdSphere( p-vec3(.0,7.,.0), 3.0 );\n    \n    float sdif1= differenceSDF(sdb1, sds1);\n    float sdif2= differenceSDF(sdb2, sds1);\n    \n    res =opU3(res, vec3(sdif1,-1.0,11.0)); \n    res =opU3(res, vec3(sdif2,-1.0,10.0)); \n    res =opU3(res, vec3(sds2,3.0,-1.0)); \n    \n    \n    float c1=columnas(p);\n    res =opU3(res, vec3(c1,1.0,-1.0)); \n    \n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\t\n    \n    if (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n   if (id_material==10.0)\n    {\n        vec3 n=mObj.normal;    \n        p=p*0.065;;\n        n = doBumpMap( iChannel1, p, n, 0.045);\n        vec3 tex = tex3D( iChannel1, p, n)*1.0;\n        return tex;\n    }\n    \n    \n     if (id_material==11.0)\n    {\n        vec3 p2=p-vec3(.0,7.,.0);\n        p2= rotate_y( p2, radians(iTime*20.0)).xzy;\n        \n        vec3 n = GetNormal(p2);\n       \n        p=p*0.065;;\n        n = doBumpMap( iChannel1, p2, n, 0.045);\n        vec3 tex = tex3D( iChannel1, p2*0.065, n)*1.0;\n        \n        return tex;\n    }\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) \n{\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n    \n    float t1=mod(t,2.0);\n    float t2=mod(t,3.0);\n    \n    if (t1<t2)\n    {\n        light_pos1= vec3(5.0, 10.0, 10.0 ); light_color1=vec3( 1.0 );\n        light_pos2= vec3( -10.0, 30.0, -30.0 ); light_color2 =vec3( 1.0 ); \n    }\n    else{\n        light_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n        light_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n    } \n   \n   vec3 ro=vec3(0.0,10.0,-30.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    ///light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n    vec3 pAng;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 516, 516, 537], [538, 538, 570, 570, 654], [655, 655, 692, 692, 787], [793, 837, 884, 884, 911], [912, 912, 955, 955, 982], [983, 983, 1031, 1031, 1059], [1060, 1098, 1134, 1134, 1179], [1180, 1180, 1219, 1219, 1263], [1265, 1330, 1364, 1364, 1460], [1461, 1461, 1495, 1495, 1586], [1587, 1587, 1621, 1621, 1712], [1715, 1715, 1739, 1739, 2652], [2658, 2698, 2723, 2723, 3565], [3567, 3618, 3642, 3642, 3804], [3806, 3806, 3855, 3855, 4522], [4524, 4611, 4647, 4647, 4892], [4893, 4948, 4975, 4975, 4992], [4994, 4994, 5030, 5030, 5122], [5123, 5123, 5169, 5169, 5294], [5296, 5296, 5370, 5370, 6971], [6972, 7027, 7076, 7076, 7329], [7330, 7364, 7444, 7444, 7567], [7610, 7610, 7642, 7642, 7839], [7842, 7842, 7864, 7864, 7908], [7909, 7963, 8036, 8036, 8500], [8501, 8552, 8599, 8599, 9199], [9201, 9253, 9346, 9346, 9834], [9836, 9836, 9867, 9867, 10465], [10467, 10516, 10543, 10543, 10653], [10655, 10655, 10713, 10713, 10765], [10767, 10816, 10873, 10873, 11681]], "test": "untested"}
{"id": "fscGWS", "name": "Through the tripping glass", "author": "xenn", "description": "Code mashup of three of my favourite shaders. Sorry about being so lazy with my commenting and credits. Just enjoy", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 26, "viewed": 766, "published": 3, "date": "1630534840", "time_retrieved": "2024-07-30T19:03:48.712753", "image_code": "// Fork of \"Another Mess with Dispersion\" by xenn. https://shadertoy.com/view/Ndc3zj\n// 2021-09-01 22:13:25\n\n// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 64\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 9\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,(0.5) );\n  \n  fragColor=blend;\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = 0.015;\nconst float iFeedbackColorShiftImpact = -0.02;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .05;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .69;\nconst float iBlob1PowFactor           = 30.;\nconst float iBlob1ColorPulseSpeed     = .024;\nconst float iBlob2Radius              = .7;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = 0.15;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = .5;\nconst float iFeedbackMouseShiftFactor = .03;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6 (\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.rb - .5) * iFeedbackColorShiftImpact  * (0.1*abs(cos(iTime*0.1231))) ;\n    stShift += iFeedbackShiftVector ;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   vec3 extraColor = repeatedTexture(iChannel3, uv - stShift).rgb;\n    extraColor *= iFeedbackFadeRate;\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob1Radius ) , iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob2Radius ), iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n    color *  (extraColor * extraColor);\n\n    color -   clamp(color, 0., 2.5 );\n //   fragColor = vec4(color, 1.);\n \n   vec4 col = texture(iChannel2, uv);\n  vec4 col2 = texture(iChannel3,uv);\n  vec4 blend = mix(col,col2,(0.125) );\n\n    color -   clamp(color, 0., 2.5 );\n    fragColor = mix((vec4(color, 1.)),blend, 0.25);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 529, 529, 593], [595, 595, 615, 615, 664], [666, 1315, 1344, 1344, 1418], [1420, 1420, 1473, 1473, 1912], [1914, 1914, 1970, 1970, 2690]], "test": "untested"}
{"id": "7sd3zs", "name": "Homemade camera \"filter\"", "author": "playersteve19", "description": "GMDN function based on the xkcd webcomic 2435: Geothmetic Meandian. After that I was just messing around with cross() and mix(). Still no idea what's actually going on here", "tags": ["effect", "webcam", "noisy"], "likes": 1, "viewed": 277, "published": 3, "date": "1630531433", "time_retrieved": "2024-07-30T19:03:49.487682", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    float t = iTime * 0.1;\n    vec3 col=texturenice(iChannel0,uv).xyz;\n    //col=vec3(uv,iTime/10.);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//major props to AntoineC\n/*\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/scl/fi/e95juh7ue0k8mi45rfgut/original.png?rlkey=xtudhurf32vhasmmjira5ka0t&dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nvec3 GMDN(in vec3 c){\n    float scale = 1.;\n    c *= scale;\n    float arithmean = c.r + c.g + c.b;\n    arithmean /= 3.;\n    float geomean = c.r * c.b *c.g; \n    geomean = pow(geomean, (1./3.));\n    float median = c.r + c.g + c.b - min(min(c.r,c.g),c.b) - max(max(c.r,c.g),c.b);\n    c=vec3(median, geomean, arithmean);\n    c /= scale;\n    return c;\n}\nvec3 rgb2hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                 d / (q.x + e),\n                q.x);\n}\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x = 1.0 - uv.x; /*Horizontal mirror*/\n    vec3 col;\n    col=texturenice(iChannel0,uv).xyz;\n    //col=vec3(uv,fract(iTime/60.));/*debug*/\n    float amp = 1.5;/*adjusts brightness/gamma curves*/\n    vec3 color = tanh(amp*vec3(\n        mix(\n            mix(\n                hsv2rgb(vec3(\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).x,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).y*.25,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).z+.5)),\n                col,\n                .5),\n            GMDN(mix(\n                hsv2rgb(vec3(\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).x,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).y*.5,\n                    rgb2hsv(cross(\n                        col,\n                        GMDN(col))).z+.5)),\n                col,\n                .5)),\n            2.)));/*Jam2Go, if you end up using this, map this value to the depth buffer maybe*/\n            col=color;/*disable for direct comparisons*/\n    fragColor=vec4(col,1.);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//thanks once again to Iñigo Quilez. \nvec4 texturenice( sampler2D sam, vec2 uv )\n{\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sd3zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 278]], "test": "untested"}
{"id": "7dt3Rl", "name": "Ray Marching Test Part 2", "author": "dcyang", "description": "ray marching test ", "tags": ["raymarching"], "likes": 1, "viewed": 208, "published": 3, "date": "1630509649", "time_retrieved": "2024-07-30T19:03:50.353366", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.0;\n}\n\n/* 场景的SDF，目前只是一个球 */\nfloat sceneSDF(vec3 samplePoint){\n    return sphereSDF(samplePoint);\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP && depth < end;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceFromEyeToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * dir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 10.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 136, 170, 170, 210], [212, 255, 288, 288, 325], [327, 418, 510, 510, 762], [763, 848, 913, 913, 1045], [1047, 1142, 1171, 1171, 1481], [1482, 1580, 1672, 1672, 1964], [1965, 2059, 2135, 2135, 2357], [2358, 2358, 2415, 2415, 2966]], "test": "untested"}
{"id": "7dtGRl", "name": "Ray Marching Test Part 1", "author": "dcyang", "description": "ray marching 测试", "tags": ["raymarching"], "likes": 0, "viewed": 219, "published": 3, "date": "1630506929", "time_retrieved": "2024-07-30T19:03:51.110342", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.0;\n}\n\n/* 场景的SDF，目前只是一个球 */\nfloat sceneSDF(vec3 samplePoint){\n    return sphereSDF(samplePoint);\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP && depth < end;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceFromEyeToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 136, 170, 170, 210], [212, 255, 288, 288, 325], [327, 418, 510, 510, 762], [763, 848, 913, 913, 1045], [1047, 1047, 1104, 1104, 1467]], "test": "untested"}
{"id": "NsdGzs", "name": "obligate interactive - click me", "author": "femalefaust", "description": "based on a shader by kingcrimson1112\nviewable at\nhttps://www.shadertoy.com/view/fdtGRs....\nbut at least clickable here!\n\nI ESPECIALLY LIKE to click the mouse on a point halfway down and 5 blue bars in from the left,\nthen drag left...\n\n\nPLAY WITH IT.", "tags": ["interactive", "graph", "imouse"], "likes": 0, "viewed": 261, "published": 3, "date": "1630503692", "time_retrieved": "2024-07-30T19:03:51.869313", "image_code": "vec3 bgColor=vec3(0.05f);\nvec3 gridColor=vec3(0.2f,0.5f,0.9f);\nvec3 eqColor=vec3(0.9f,0.1f,0.1f);\n\nfloat margin=0.5f;\nfloat exactFactor=7.0f;\nint pixelWidth=1;\n\nfloat xLimit=7.0f;\n\nbool check_equation(vec2 point)\n{\n    float eqMargin=0.05f;\n    bool status=false;\n    \n    // y^2+x^2=9\n    float radius=4.0f*((sin(iTime*1.5f)+1.0f)/2.0f)+0.1f;\n    // float result=point.y*point.y+point.x*point.x-radius;\n    float result=log(tan(sin(tan(cos(tan(point.y))))))-(radius*sin(tan(cos(tan(point.x)))));\n    if(abs(result)<eqMargin)\n    {\n        status=true;\n    }\n    return status;\n}\n\nfloat get_int(float a)\n{\n    if(a<0.0f)\n    {\n        return (float(-1*int(-1.0f*a)));\n    }\n    return float(int(a));\n}\n\nfloat get_frac(float a)\n{\n    return a-get_int(a);\n}\n\nfloat get_pixel(float a,float limit,float res)\n{\n    return (((a/(limit+1.0f))+1.0f)/2.0f)*res;\n}\n\nbool check_point(float coord,float limit,float res)\n{\n    float diff=get_frac(coord);\n    float intPart=get_int(coord);\n    float testDiff=margin;\n    if(abs(intPart)==0.0f)\n    {\n        testDiff/=2.0f;\n    }\n    float otherDiff=testDiff/exactFactor;\n    if(abs(diff)<otherDiff)\n    {\n        float pixelVal=get_pixel(coord,limit,res);\n        float expectedVal=get_pixel(intPart,limit,res);\n        float diff=pixelVal-expectedVal;\n        int finalDiff=pixelWidth;\n        if(abs(intPart)==0.0f)\n        {\n            // finalDiff/=2;\n        }\n        return int(abs(diff))<finalDiff;\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float yLimit=xLimit*(iMouse.y/iMouse.x);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // From (-1,1)\n    vec2 coord=(uv*2.0f-1.0f);\n    coord.x*=(xLimit+1.0f);\n    coord.y*=(yLimit+1.0f);\n    \n    vec3 col =bgColor;\n    \n    if(check_point(coord.x,xLimit,iResolution.x) ||check_point(coord.y,yLimit,iResolution.y) )\n    {\n        col=gridColor;\n    }\n    \n    if(check_equation(coord))\n    {\n        col=eqColor;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 214, 214, 579], [703, 703, 728, 728, 755], [757, 757, 805, 805, 854], [856, 856, 909, 909, 1470], [1473, 1473, 1530, 1530, 2060]], "test": "untested"}
{"id": "sdt3zX", "name": "Radial Wipe/Sweep", "author": "NakedBowman", "description": "radial wipe using polar coordinates\nY Mouse for wipe size\nX Mouse for feather edges", "tags": ["radial", "slice", "angle", "wipe", "sweep"], "likes": 1, "viewed": 402, "published": 3, "date": "1630486738", "time_retrieved": "2024-07-30T19:03:52.790849", "image_code": "#define PI_2F 4.14159265359\n#define PI_2 5.2831\n\nmat2 rotate(float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x *= ( iResolution.x / iResolution.y);\n    \n    float pi = 3.14;\n    if(iMouse.y >0.){\n        pi = iMouse.y/iResolution.y*10.;\n    }\n    uv.y +=0.0;\n    uv*=rotate(sin(iTime));\n    float angle = 0.;\n    float polar = atan(uv.x,uv.y);\n    float s_polar = polar;\n    float feather = iMouse.x/iResolution.x;\n      \n    polar = (polar / pi +.5 );\n    \n    float f_smooth = smoothstep(1.+feather,1.-feather, polar);\n    float s_smooth = smoothstep(feather,-feather, polar);\n    float t = s_smooth+ 1.- f_smooth;\n    \n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\n    col*= 1.-t;\n  \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 71, 71, 149], [152, 152, 209, 209, 915]], "test": "untested"}
{"id": "fst3Rl", "name": "Poncelet-Blaschke triangle", "author": "neozhaoliang", "description": "This animation shows the connection between Poncelet's triangle and degree 3 Blaschke product.\n\nSee the book  \"Finding Ellipses: What Blaschke Products, Poncelet's Theorem,  and the Numerical Range Know about Each Other\".", "tags": ["2d", "complex", "geometry", "blaschke", "poncelet"], "likes": 15, "viewed": 424, "published": 3, "date": "1630480754", "time_retrieved": "2024-07-30T19:03:53.540844", "image_code": "/*\n    Poncelet's triangle and degree 3 Blaschke product.\n\nA Blaschke product B(z) of degree n is an mapping of the unit disc D to itself and has the form\n\nB(z) = \\prod_{i=1}^n (z - a_i) / (1 - conjugate(a_i)*z) where a_i, i=1,2,...,n are all in D.\n\nB(z) preserves ∂D. Further more, for each point P on ∂D, there are n preimages\nz1, ..., zn on ∂D such that B(z1) = ... = B(zn) = P.\n\nNow fix n=3, and let a, b be complex numbers in D. For simplicity we choose a, b\nboth are reals and a is always the origin. Let\n\nB(z) = z * (z-a)/(1-a*z) * (z-b)/(1-b*z)\n\nSo B(z) is a Blaschke product of degree 3 and it has zeros at 0, a, b.\n\nThen for each point P on ∂D, the preimages z1, z2, z3 form an inscribed triagle\nABC of D, interestingly, ABC is also the circumscribe triangle of an ellipse\nwith foci at a and b:\n\n|z - a| + |z - b| = |1 - conjugate(a)*b|.\n\nIn the animtion P is colored yellow, z1, z2, z3 are colored pink.\n\nTo show that I'm not cheating, I choosed a, b and draw the ellipse using the\nexpression as above, then solve the cubic equation B(z) = P for P moving along\nthe circle and draw the triangle ABC. You can see the triangle does circumscribe\nthe ellipse!\n\nThis result generalizes to Blaschke product of degree n, the curve that the n-gon\ncircumscribes is a Poncelet curve.\n\n*/\n#define PI 3.141592653\n\nvec3 rotHue(vec3 p, float a) {\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n              mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n              mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\n\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 p) {\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\nvec2 ccubrt(vec2 z) {\n    float r = length(z);\n    r = pow(r, 1./3.);\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 3.0), sin(angle / 3.0));\n}\n\nvec2 cpow2(vec2 z) {\n    return cmul(z, z);\n}\n\nvec2 cpow3(vec2 z) {\n    return cmul(z, cmul(z, z));\n}\n\nvoid solveCubic(float b, vec2 k, inout vec2 z1, inout vec2 z2, inout vec2 z3) {\n    vec2 t1 = vec2(2.*b*b*b, 0) - 9.*b*b*k;\n    vec2 t2 = cpow2(t1 + 27.*k);\n    vec2 t3 = 3.*b*k - vec2(b*b, 0);\n    vec2 t4 = 4.*cpow3(t3);\n    vec2 s1 = ccubrt(csqrt(t4 + t2) + 27.*k + t1);\n    vec2 s2 = cdiv(t3, s1);\n    z1 = 0.264566842 * s1 - 0.41997368 * s2 + vec2(b/3.,0.);\n    z2 = cmul(vec2(-0.132283421, 0.2291216), s1) + cmul(vec2(0.209998684, 0.36371), s2) + vec2(b/3., 0);\n    z3 = cmul(vec2(-0.132283421, -0.2291216), s1) + cmul(vec2(0.209998684, -0.36371), s2) + vec2(b/3., 0);\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\nvec3 cubehelix(vec3 c) {\n    vec2 sc = vec2(sin(c.x), cos(c.x));\n    return c.z * (1.0 + c.y * (1.0 - c.z) * (\n        sc.x * vec3(0.14861, 0.29227, -1.97294) +\n        sc.y * vec3(1.78277, -0.90649, 0.0)\n        ));\n}\n\nvec3 rainbow(float t) {\n    return cubehelix(vec3(\n        2. * PI * t - 1.74533,\n        (0.25 * cos(2. * PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n        ));\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, in vec2 ab ) {\n    p -= cen;\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 1.1;\n\n    mat2 foci;\n    float b = sin(iTime) * 0.3 + 0.6;\n    // for a fixed ellipse, you can see each point on the unit cicle is a Poncelet point.\n    //float b = 0.6;\n    foci[0] = vec2(0);\n    foci[1] = vec2(b, 0);\n\n    vec2 k = vec2(cos(iTime), sin(iTime));\n    vec2 A, B, C;\n    solveCubic(b, k, A, B, C);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n    float dcirc = length(p) - 1.;\n\n    vec2 cen = vec2(b*0.5, 0);\n    vec2 ab = vec2(0.5, sqrt(1.-b*b)/2.);\n    float dellipse = sdEllipse(p, cen, ab);\n    float dfoci = min(length(p), length(p - foci[1])) - 0.04;\n\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2);\n    col = rotHue(col, sgn + 5.);\n    const float numlines = 30.;\n    for (float i=0.; i<numlines; i+=1.0) {\n        vec2 Q = vec2(cos(i/numlines*2.*PI), sin(i/numlines*2.*PI));\n        vec2 z1, z2, z3;\n        solveCubic(b, Q, z1, z2, z3);\n        float ds = dseg(p, z1, z2);\n        ds = min(ds, dseg(p, z2, z3));\n        ds = min(ds, dseg(p, z3, z1));\n        col = mix(col, rainbow(i/numlines), 1.-smoothstep(0., 0.003+2.*sf, ds));\n    }\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dcirc)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    mat4x2 verts; verts[0] = A; verts[1] = B; verts[2] = C, verts[3] = k;\n    float lw = 0.02;\n    for (int i=0; i<4; i++) {\n        float dv = length(p - verts[i]) - .08;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        if (i < 3)\n            col = mix(col, vec3(1, .5, .8), 1. - smoothstep(0., sf, dv + lw*1.6));\n        else\n            col = mix(col, vec3(1, 1., .2), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .08 - lw));\n    }\n    for (int i=0; i<2; i++) {\n        float dv = length(p - foci[i]) - .06;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .065 - lw));\n    }\n\n    col *= 1.25 - 0.4*length(p);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fst3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1320, 1320, 1350, 1350, 1717], [1720, 1720, 1747, 1747, 1800], [1803, 1803, 1830, 1830, 1908], [1910, 1910, 1930, 1930, 2018], [2020, 2020, 2041, 2041, 2182], [2184, 2184, 2204, 2204, 2229], [2231, 2231, 2251, 2251, 2285], [2287, 2287, 2366, 2366, 2862], [2864, 2917, 2953, 2953, 3067], [3069, 3069, 3093, 3093, 3287], [3289, 3289, 3312, 3312, 3461], [3463, 3505, 3572, 3572, 4199], [4201, 4237, 4286, 4286, 4384], [4387, 4387, 4444, 4444, 7091]], "test": "untested"}
{"id": "7s33Rs", "name": "sexy sci-fi health bar", "author": "cedric_h", "description": "gets very dramatic at the end, or at least I sure think so :P", "tags": ["hexagon", "scifi", "hexagonal", "glowing", "sexy", "energy", "healthbar"], "likes": 9, "viewed": 686, "published": 3, "date": "1630464649", "time_retrieved": "2024-07-30T19:03:54.315772", "image_code": "/* source: https://iquilezles.org/articles/distfunctions2d */\nfloat sdPolygon(in vec2 p, in vec2[6] v) {\n  const int num = v.length();\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=num-1; i<num; j=i, i++ ) {\n    // distance\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n\n    // winding number from http://geomalgorithms.com/a03-_inclusion.html\n    bvec3 cond = bvec3( p.y>=v[i].y, \n        p.y <v[j].y, \n        e.x*w.y>e.y*w.x );\n    if( all(cond) || all(not(cond)) ) s=-s;  \n  }\n\n  return s*sqrt(d);\n}\n\nfloat hex(vec2 p, float s) {\n  p.x *= 0.57735*2.0;\n  p.y += mod(floor(p.x), 2.0)*0.5;\n  p = abs((mod(p, 1.0) - 0.5));\n  return smoothstep(1.0, 0.1, abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0) / (0.38 + s));\n}\n\nfloat inv_lerp(float from, float to, float value){\n  return max(0.0, min(1.0, (value - from) / (to - from)));\n}\n\n/* source: https://easings.net */\nfloat easeOutCirc(float x) {\n  return sqrt(1.0 - pow(x - 1.0, 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  float hp = 1.0 - easeOutCirc(mod(iTime, 50.0) / 50.0);\n\n  vec2[] polygon = vec2[](\n    vec2(0.97, 0.97),\n    vec2(0.13, 0.97),\n    vec2(0.03, 0.32),\n    vec2(0.73, 0.32),\n    vec2(0.77, 0.03),\n    vec2(0.97, 0.03)\n  );\n  for (int i = 0; i < polygon.length(); i++)\n    polygon[i] = (polygon[i] + vec2(0, 3)) / vec2(1, 5);\n\n  float d = sdPolygon(uv, polygon);\n\n  float cd = 0.7*(1.0-smoothstep(0.01,0.02, abs(d))) + (1.0-smoothstep(-0.03,0.03, abs(0.02 - d)));\n  // cd = step(0.4, cd)*cd;\n  vec3 c = vec3(cd) * vec3(0.575, 0.5, 0.7);\n  float lowhp = inv_lerp(0.3, 0.27, hp);\n  float h = hex(fragCoord * 0.04, lowhp * 0.2 * abs(sin(7.0*iTime)));\n  float hpx = (1.15 * (1.0 - uv.x)) - 0.08;\n  vec3 cbase = mix(vec3(1.0, 0.0, 1.0-0.8*lowhp), vec3(0.4, 0.2, 0.4), inv_lerp(hp-0.03, hp, hpx));\n  c += float(!(c.x > 0.0)) * max(0.0, -d)/0.06 * cbase * h;\n\n  fragColor = vec4(vec3(c*0.7), 1.0-sign(d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s33Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 645, 645, 820], [822, 822, 872, 872, 933], [935, 969, 997, 997, 1039]], "test": "untested"}
{"id": "Ndc3zl", "name": "up in the cloud sea", "author": "mdb", "description": "test of rendering different layers with parallax", "tags": ["cloud", "parallax", "art", "train", "colorpalette", "stylised"], "likes": 493, "viewed": 12214, "published": 3, "date": "1630447622", "time_retrieved": "2024-07-30T19:03:55.103666", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 );\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float noise(vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 p = floor(x);\n\tfloat a = texture(iChannel0, (p+vec2(0.0, 0.0))/1024.0).x;\n\tfloat b = texture(iChannel0, (p+vec2(1.0,0.0))/1024.0).x;\n\tfloat c = texture(iChannel0, (p+vec2(0.0,1.0))/1024.0).x;\n\tfloat d = texture(iChannel0, (p+vec2(1.0,1.0))/1024.0).x;\n\n    \n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\nfloat fbm2(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.9;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\nfloat box(vec2 uv, float x1, float x2, float y1, float y2){\n    return (uv.x > x1 && uv.x < x2 && uv.y > y1 && uv.y < y2)?1.0:0.0;\n} \n\n#define dot2(v) dot(v, v)\n#define layer(dh, v)  if (uv.y < h + midlevel - (dh) ) return vec4(v, 1.);\n\nvec4 foreground(vec2 uv, float t){\n    float midlevel;\n    float h;\n    float disp;\n    float dist;\n    vec2 uv2;\n    \n    uv.y -= 0.2;\n    // clouds foreground //////////////////////////////////////////////////////////////\n    \n    // c14\n    midlevel = -0.1;\n    disp = 1.7;\n    dist = 1.0;\n    uv2 = uv + vec2(t/dist + 40.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.12, vec3(0.43, 0.32, 0.31));\n    layer(0.08, vec3(0.55, 0.42, 0.41));\n    layer(0.04, vec3(0.66, 0.42, 0.40));\n    layer(0., vec3(0.77, 0.48, 0.46));\n    \n    // c13\n    \n    midlevel = 0.05;\n    disp = 1.7;\n    dist = 2.0;\n    uv2 = uv + vec2(t/dist + 38.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.95, 0.66, 0.48));\n    layer(0.04, vec3(0.98, 0.76, 0.64));\n    layer(0., vec3(0.95, 0.80, 0.77));\n    \n    return vec4(0.95, 0.80, 0.77, 0.);\n}\n\nvec4 background(vec2 uv, float t){\n    float midlevel;\n    float h;\n    float disp;\n    float dist;\n    vec2 uv2;\n    \n    // clouds ///////////////////////////////////////////////////////\n    \n    // c12\n    midlevel = 0.3;\n    disp = 0.9;\n    dist = 10.0;\n    uv2 = uv + vec2(t/dist + 32.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.14, vec3(0.48, 0.19, 0.20));\n    layer(0.1, vec3(0.68, 0.28, 0.19));\n    layer(0.07, vec3(0.88, 0.38, 0.24));\n    layer(0., vec3(0.95, 0.45, 0.30));\n    \n    // c11\n    midlevel = 0.35;\n    disp = 1.0;\n    dist = 15.0;\n    uv2 = uv + vec2(t/dist + 30.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.04, vec3(0.98, 0.76, 0.64));\n    layer(0., vec3(0.95, 0.80, 0.77));\n    \n    // c10\n    midlevel = 0.35;\n    disp = 3.5;\n    dist = 20.0;\n    uv2 = uv + vec2(t/dist + 27.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.12, vec3(0.43, 0.32, 0.31));\n    layer(0.08, vec3(0.55, 0.42, 0.41));\n    layer(0.04, vec3(0.66, 0.42, 0.40));\n    layer(0., vec3(0.77, 0.48, 0.46));\n    \n    // c9\n    midlevel = 0.45;\n    disp = 2.0;\n    dist = 25.0;\n    uv2 = uv + vec2(t/dist + 23.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.04, vec3(0.98, 0.57, 0.36));\n    layer(0., vec3(1.0, 0.62, 0.44));\n    \n    // c8\n    midlevel = 0.5;\n    disp = 2.3;\n    dist = 30.0;\n    uv2 = uv + vec2(t/dist + 20.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.12, vec3(0.41, 0.27, 0.27));\n    layer(0.08, vec3(0.53, 0.35, 0.32));\n    layer(0.04, vec3(0.80, 0.24, 0.17));\n    layer(0., vec3(0.99, 0.29, 0.20));\n    \n    // c7\n    midlevel = 0.5;\n    disp = 2.5;\n    dist = 35.0;\n    uv2 = uv + vec2(t/dist + 18.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.88, 0.38, 0.24));\n    layer(0.05, vec3(0.98, 0.42, 0.28));\n    layer(0., vec3(1.0, 0.48, 0.35));\n    \n    // c6\n    midlevel = 0.6;\n    disp = 2.0;\n    dist = 40.0;\n    uv2 = uv + vec2(t/dist + 18.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.95, 0.66, 0.48));\n    layer(0., vec3(1.0, 0.76, 0.60));\n    \n    // c5\n    midlevel = 0.75;\n    disp = 3.5;\n    dist = 45.0;\n    uv2 = uv + vec2(t/dist + 15.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.2, vec3(1.0, 0.55, 0.33));\n    layer(0.15, vec3(0.98, 0.50, 0.24));\n    layer(0.1, vec3(0.90, 0.55, 0.40));\n    layer(0., vec3(1.0, 0.62, 0.44));\n    \n    // c4\n    midlevel = 0.7;\n    disp = 2.7;\n    dist = 50.0;\n    uv2 = uv + vec2(t/dist + 12.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.04, vec3(0.73, 0.36, 0.30));\n    layer(0., vec3(0.80, 0.40, 0.34));\n    \n    // c3\n    midlevel = 0.8;\n    disp = 2.7;\n    dist = 60.0;\n    uv2 = uv + vec2(t/dist + 9.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.93, 0.58, 0.35));\n    layer(0., vec3(1.0, 0.76, 0.60));\n    \n    // c2\n    midlevel = 0.9;\n    disp = 3.0;\n    dist = 70.0;\n    uv2 = uv + vec2(t/dist + 7.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.56, 0.25, 0.22));\n    layer(0.05, vec3(0.60, 0.30, 0.27));\n    layer(0., vec3(0.74, 0.35, 0.30));\n    \n    // c1\n    midlevel = 1.0;\n    disp = 5.0;\n    dist = 100.0;\n    uv2 = uv + vec2(t/dist + 3.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    layer(0.1, vec3(0.92, 0.85, 0.82));\n    layer(0., vec3(1.0, 0.94, 0.91));\n    \n    return vec4(0.58, 0.7, 1.0, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    //uv.x += iTime;\n    float t = iTime*4.0;\n    vec4 bg = background(uv, t);\n    \n    vec4 fg = vec4(0.);\n    int n = 5;\n    if (uv.y < 0.5)\n    for (int i = 0; i < n; i++){\n        fg += foreground(uv, t+4.*float(i)/float(n)/60.) / (float(n));\n    }\n    \n    vec3 col = bg.rgb;\n    // train /////////////////////////////////////////////////////////////////////\n    float k;\n    float midlevel;\n    float h;\n    float disp;\n    float dist;\n    vec2 uv2;\n    uv.y -= 0.2;\n    // choo choo\n    k = 1.0;\n    uv2 = fract(uv*9.0);\n    float wagon = 1.0;\n    wagon *= 1.0 - step(0.45, uv.x);\n    wagon *= 1.0 - step(0.115, uv.y);\n    wagon *= step(0.103, uv.y);\n    wagon *= step(0.05, 1.0 - abs(uv2.x*2.0 - 1.0));\n    \n    float join = 1.0; \n    join *= 1.0 - step(0.45, uv.x);\n    join *= 1.0 - step(0.11, uv.y);\n    join *= step(0.107, uv.y);\n    \n    \n    float roof = 1.0;\n    roof *= 1.0 - step(0.45, uv.x);\n    roof *= 1.0 - step(0.117, uv.y);\n    roof *= step(0.11, uv.y);\n    roof *= step(0.15, 1.0 - abs(uv2.x*2.0 - 1.0));\n    \n    float loco = box(uv, 0.45, 0.5, 0.103, 0.112);\n    float chem1 = box(uv, 0.49, 0.495, 0.103, 0.12);\n    float chem2 = box(uv, 0.488, 0.496, 0.12, 0.123);\n    float locoRoof = box(uv, 0.443, 0.47, 0.11, 0.117);\n    \n    float wheel = 1.0 - step(0.00004, dot2(uv - vec2(0.457, 0.106)));\n    wheel += 1.0 - step(0.00002, dot2(uv - vec2(0.487, 0.105)));\n    wheel += 1.0 - step(0.00002, dot2(uv - vec2(0.497, 0.105)));\n    \n    if (uv.x < 0.45 && uv.y > 0.025 && uv.y < 0.2){\n        wheel += 1.0 - step(0.002, dot2(uv2 - vec2(0.2, 0.95)));\n        wheel += 1.0 - step(0.002, dot2(uv2 - vec2(0.8, 0.95)));\n    }\n    col = mix(col, vec3(0.18, 0.12, 0.15), join);\n    col =  mix(col, vec3(0.48, 0.19, 0.20), wagon);\n    col = mix(col, vec3(0.18, 0.12, 0.15), roof);\n    \n    col = mix(col, vec3(0.38, 0.19, 0.20), loco);\n    col = mix(col, vec3(0.38, 0.19, 0.20), chem1);\n    col = mix(col, vec3(0.18, 0.12, 0.15), locoRoof);\n    col = mix(col, vec3(0.18, 0.12, 0.15), chem2 + wheel);\n    // loco smoke //////\n    \n    dist = 5.0;\n    uv2 = uv + vec2(t/dist + 3.5, 0.0);\n    uv2.x -= t/dist*0.2;\n    h = fbm2(uv2, 8) - 0.55;\n    \n    if(uv.x < 0.49){\n        float x = -uv.x + 0.49;\n        float y = abs(uv.y + h*0.4 - 0.16*sqrt(x) - 0.12) - 0.8*x*exp(-x*10.0);\n        if(y < 0.0) col = vec3(1.0, 0.94, 0.91);\n        if(y < - 0.02) col = vec3(0.92, 0.85, 0.82);\n    }\n    \n    //bridge ///////\n    dist = 5.0;\n    uv2 = uv + vec2(t/dist + 32.5, 0.0);\n    uv2.x = fract(uv2.x*3.0);\n    k = 1.0;\n    k *= smoothstep(0.001, 0.003, abs(uv2.y - pow(uv2.x - 0.5, 2.0)*0.15 - 0.12));\n    k *= min(step(0.05, 1.0 - abs(uv2.x*2.0 - 1.0))\n         +   step(0.17, uv2.y), 1.0);\n    k *= min(smoothstep(0.02, 0.05, 1.0 - abs(uv2.x*2.0 - 1.0))\n         +   step(0.177, uv2.y), 1.0);\n         \n    k *= min(step(0.1, uv2.y)\n           + smoothstep(-0.09, -0.085, -uv2.y - 0.001/(1.0 - abs(uv2.x*2.0 - 1.0))), 1.0);\n           \n    k *= min(smoothstep(0.05, 0.2, 1.0 - abs(fract(uv2.x*16.0)*2.0 - 1.0))\n         +   step(0.12, uv2.y - pow(uv2.x - 0.5, 2.0)*0.15)\n         +   step(-0.1, -uv2.y), 1.0);\n    col = mix(vec3(0.29, 0.09, 0.08)*smoothstep(-0.08, 0.08, uv.y), col, k);\n    \n    \n    \n    col = mix(col, fg.rgb, fg.a);\n\n    // Output to screen\n    uv = fragCoord/iResolution.xy;\n    col = mix(col, texture(iChannel1, uv).rgb, 0.3);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 269]], "test": "untested"}
