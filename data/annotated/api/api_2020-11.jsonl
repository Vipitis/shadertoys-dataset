{"id": "tdtyDl", "name": "the flag of Romania - 004", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 2, "viewed": 273, "published": 3, "date": "1606773187", "time_retrieved": "2024-07-30T20:32:55.889064", "image_code": "//The flag is coincidentally very similar to the civil flag of Andorra and \n//the state flag of Chad. \n//The similarity with Chad's flag, which is identical apart from allowing a broader range of shades of \n//blue, yellow and red, has caused international discussion. \n//see https://en.wikipedia.org/wiki/Flag_of_Romania\n//the gl_FragColor is a vec4 type of float values in the range 0 to 1.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // set color background\n\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float flag_X = uv.x * 1.5+1.0;\n    \n  \n  float flag_Y = 1.0 + uv.y + (sin((flag_X - iTime) * 6.0) * 0.03 * flag_X) - uv.x;\n    \n    flag_X = flag_X/2.0 - flag_Y * 0.5;\n    \n    if (flag_X > 0.0 && flag_X < 1.0  && flag_Y > 0.0) \n    { \t\t       \n\t\tfloat size = 3.0;\n\t\tif (flag_X < 1.0 / size) \n\t\t{\n\t\t\t// Output to screen fill the screen with blue\n\t\t\tfragColor = vec4(0,0,1,0);\n            \t\n\t\t} else if (flag_X < 2.0 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tfragColor = vec4(1,1,0,0);\n        \t    \n\t\t} else if (flag_X < 3.0 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tfragColor = vec4(1,0,0,0);\n\t\t}\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 392, 449, 499, 1258]]}
{"id": "tddcWl", "name": "the flag of Romania - 003", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 1, "viewed": 277, "published": 3, "date": "1606773095", "time_retrieved": "2024-07-30T20:32:56.797635", "image_code": "//The flag is coincidentally very similar to the civil flag of Andorra and \n//the state flag of Chad. \n//The similarity with Chad's flag, which is identical apart from allowing a broader range of shades of \n//blue, yellow and red, has caused international discussion. \n//see https://en.wikipedia.org/wiki/Flag_of_Romania\n//the gl_FragColor is a vec4 type of float values in the range 0 to 1.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // set color background\n\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    // set direction flag for X\n    float flag_X = uv.x * 4.0 - 1.1;\n    // set direction flag for Y and wind effect with sin and time\n    float flag_Y = uv.y / 3.0 - (sin((flag_X - iTime) * 6.0) * 0.01)  ;\n    // set sized flagX by flagY\n    flag_X = flag_X/1.8 - flag_Y/1.1;\n    // build the area for flag\n    if (flag_X > 0.0 && flag_X < 1.0  && flag_Y > 0.1  && flag_Y < 0.18) \n    { \t\n        // set a size to fill with colors \n\t\tfloat size = 4.0;\n        // build the flag by flag_X\n\t\tif (flag_X < 1.0 / size) \n\t\t{\n\t\t\t// Output to screen with fill the screen with blue\n\t\t\tfragColor = vec4(0,0,1,0);\n            \t\n\t\t} else if (flag_X < 2.0 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tfragColor = vec4(1,1,0,0);\n        \t    \n\t\t} else if (flag_X < 3.0 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tfragColor = vec4(1,0,0,0);\n\t\t}\n\t}\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 392, 449, 499, 1478]]}
{"id": "WdyBRm", "name": "CyberSkin2000", "author": "avin", "description": "visual experiment", "tags": ["simplex", "bubbles"], "likes": 38, "viewed": 845, "published": 3, "date": "1606766329", "time_retrieved": "2024-07-30T20:32:57.808931", "image_code": "#define BUBBLE_SIZE 15.0 \n#define COL1 vec3(32, 43, 51) / 255.0 \n#define COL2 vec3(235, 241, 245) / 255.0 \n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;  \n     \n    float SIZE = iResolution.x / BUBBLE_SIZE;\n        \n    float SF = 1./min(iResolution.x,iResolution.y)*SIZE*.5;\n         \n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;              \n    \n    float mask = 0.0;    \n    for(float y =- 2.0; y <= 2.0; y++ ) {\n        for(float x =- 2.0; x <= 2.0; x++ ) {\n            vec2 rid = id - vec2(x, y);\n            vec2 ruv = uv + vec2(x, y) + \n                vec2(0, mod(rid, 2.)*.5) + \n                vec2(0, sin(simplex_noise(vec3(rid*0.075, iTime))*5.)*1.0);                         \n                        \n            float l = length(ruv*.5);            \n                                                         \n            float d = smoothstep(SF,-SF,l - .65) * (ruv.y);\n                        \n            mask = max(mask, d);                       \n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    col = mix(COL1, COL2, abs(mask));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 236, 236, 356], [358, 358, 380, 380, 532], [534, 534, 563, 563, 1227], [1230, 1230, 1286, 1286, 2314]]}
{"id": "3sGfzw", "name": "3D Triangle Rasterizer", "author": "oneshade", "description": "A simple 3D rasterizer. It took me forever to get the faces right!", "tags": ["3d", "rasterizer", "triangle"], "likes": 6, "viewed": 235, "published": 3, "date": "1606763437", "time_retrieved": "2024-07-30T20:32:58.652675", "image_code": "const float Z_NEAR = 0.1;\nconst float Z_FAR = 100.0;\nconst float FOCAL_LENGTH = 1.0;\n\nvec3[] vertices = vec3[8](vec3( -1.0,  1.0,  1.0 ),\n                          vec3( -1.0, -1.0,  1.0 ),\n                          vec3(  1.0, -1.0,  1.0 ),\n                          vec3(  1.0,  1.0,  1.0 ),\n                          vec3(  1.0,  1.0, -1.0 ),\n                          vec3(  1.0, -1.0, -1.0 ),\n                          vec3( -1.0, -1.0, -1.0 ),\n                          vec3( -1.0,  1.0, -1.0 ));\n\nivec3[] triangles = ivec3[12](ivec3( 0, 1, 2 ),\n                              ivec3( 2, 3, 0 ),\n                              ivec3( 4, 5, 6 ),\n                              ivec3( 6, 7, 4 ),\n                              ivec3( 3, 2, 5 ),\n                              ivec3( 5, 4, 3 ),\n                              ivec3( 7, 6, 1 ),\n                              ivec3( 1, 0, 7 ),\n                              ivec3( 7, 0, 3 ),\n                              ivec3( 3, 4, 7 ),\n                              ivec3( 5, 2, 1 ),\n                              ivec3( 1, 6, 5 ));\n\nvec3[] faceNormals = vec3[12](vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ));\n\nvec3[] faceColors = vec3[12](vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ));\n\nvec3 transformVertex(in vec3 v) {\n    float c = cos(iTime), s = sin(iTime);\n    v.xz *= mat2(c, -s, s, c);\n    v.yz *= mat2(c, -s, s, c);\n    v += vec3(0.0, 0.0, -5.0);\n    return v;\n}\n\nvec3 transformNormal(in vec3 n) {\n    float c = cos(iTime), s = sin(iTime);\n    n.xz *= mat2(c, -s, s, c);\n    n.yz *= mat2(c, -s, s, c);\n    return n;\n}\n\nvec3 calcBaryCoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n    float abc = abs(ba.x * cb.y - ba.y * cb.x);\n\n    return vec3(bcp / abc, cap / abc, abp / abc);\n}\n\nvec3 pixelShader(in vec3 p, in vec3 n, in vec3 c) {\n    return c * max(0.0, dot(n, vec3(-0.58, 0.58, 0.58)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3[vertices.length()] transformedVertices;\n    for (int i=0; i < vertices.length(); i++) {\n        vec3 transformedVertex = transformVertex(vertices[i]) * vec3(1.0, 1.0, -1.0);\n        float perspective = FOCAL_LENGTH / transformedVertex.z;\n        transformedVertex.xy *= perspective;\n        transformedVertices[i] = transformedVertex;\n    }\n\n    vec3[faceNormals.length()] transformedNormals;\n    for (int i=0; i < faceNormals.length(); i++) {\n        transformedNormals[i] = transformNormal(faceNormals[i]);\n    }\n\n    bool pixelIsOverlappingTriangle = false;\n    vec3 fragmentPos, normal, color;\n    float fragDepth = Z_FAR;\n\n    for (int i=0; i < triangles.length(); i++) {\n        if (transformedNormals[i].z > 0.0) {\n            vec3 triA = transformedVertices[triangles[i][0]];\n            vec3 triB = transformedVertices[triangles[i][1]];\n            vec3 triC = transformedVertices[triangles[i][2]];\n\n            vec3 baryCoords = calcBaryCoords(uv, triA.xy, triB.xy, triC.xy);\n            float newFragDepth = baryCoords.x * triA.z + baryCoords.y * triB.z + baryCoords.z * triC.z;\n            if (abs(baryCoords.x + baryCoords.y + baryCoords.z - 1.0) < 0.001 && newFragDepth > Z_NEAR && newFragDepth < fragDepth) {\n                pixelIsOverlappingTriangle = true;\n                fragDepth = newFragDepth;\n                fragmentPos = baryCoords.x * vertices[triangles[i][0]] + baryCoords.y * vertices[triangles[i][1]] + baryCoords.z * vertices[triangles[i][2]];\n                normal = transformedNormals[i];\n                color = faceColors[i];\n            }\n        }\n    }\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (pixelIsOverlappingTriangle) {\n        fragColor.rgb = pixelShader(fragmentPos, normal, color);\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2382, 2382, 2415, 2415, 2566], [2568, 2568, 2601, 2601, 2721], [2723, 2723, 2788, 2788, 3124], [3126, 3126, 3177, 3177, 3237]]}
{"id": "3dyBzw", "name": "Midnight mountain ", "author": "me_123", "description": "The shader uses ray marching. the reflections are just like ray tracing, and the transparency is a different layer. the glow effect is the amount of steps to the object if the ray hit nothing.", "tags": ["raymarching"], "likes": 3, "viewed": 363, "published": 3, "date": "1606756334", "time_retrieved": "2024-07-30T20:32:59.495422", "image_code": "float min_dist = 0.001;\nfloat max_dist = 10.;\nint max_steps =200;\nvec3 lightPos = vec3(0, 1, 1);\nfloat hash(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec4 un(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash(p+vec3(0, 0, 0));\n    float b = hash(p+vec3(1, 0, 0));\n    float c = hash(p+vec3(0, 1, 0));\n    float d = hash(p+vec3(1, 1, 0));\n    float e = hash(p+vec3(0, 0, 1));\n    float f = hash(p+vec3(1, 0, 1));\n    float g = hash(p+vec3(0, 1, 1));\n    float h = hash(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nfloat terrain(vec3 p) {\n\tfloat a = 0.0;\n    float b = 1.0;\n    vec2 d = vec2(0);\n    for (int i = 0; i < 9; i += 1) {\n    \tvec3 n = nois(p).xyz;\n        d += n.yz;\n        a += b*n.x/(1.+dot(d,d));\n        b *= 0.5;\n        p = p*2.1;\n    }\n    return a;\n}\nstruct ray {\n\tfloat dist;\n    float ao;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    vec3 cc;\n};\nvec4 SDF(in vec3 p, in bool tt, bool ttt) {\n    if (!ttt) {\n        float t = (abs(nois(p*(nois(p*20.).xyz*20.)).xyz).x+1.0)/2.;//mix(vec3(0.5, 0.5, 1.0),vec3(1), vec3(p.y+0.2));\n        vec3 color = mix(vec3(t/1.5, t/3., 0.0), vec3(1), clamp(clamp(p.y+0.1, 0.0, 1.0)*20., 0.0, 1.5));\n        if (tt) {\n          return un(un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/11.).x)/2.)))/3.), vec4(vec3(0.111), (p.y+0.1)+(fbm(p*20., 4).x/2000.))), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        } else {\n          return un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/10.).x)/2.)))/3.), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        }\n    } else {\n        return vec4(vec3(0.222, 0, 0), (length(p-vec3(0.7, 0.5, 1.))-0.1)/10.);\n    }\n}\nvec3 getNormal(vec3 p, bool tt, bool ttt) {\n\tvec2 e = vec2(0.00001, 0);\n    float d = SDF(p, tt, ttt).w;\n    vec3 n = d -vec3(\n    \tSDF(p-e.xyy, tt, ttt).w,\n    \tSDF(p-e.yxy, tt, ttt).w,\n    \tSDF(p-e.yyx, tt, ttt).w\n    );\n\treturn (normalize(n));\n}\nray get_ray(vec3 ro, vec3 rd, bool tt, bool ttt) {\n\tfloat d0 = 0.0;\n    vec3 p = vec3(0);\n    float steps = 0.0;\n    vec3 color = vec3(0);\n    vec3 cc = vec3(0);\n    for (int i = 0; i < max_steps; i += 1) {\n        steps += 1.;\n        p = ro+rd*d0;\n        vec4 rr = SDF(p, tt, ttt);\n        float d = rr.w;\n        d0 += d;\n        cc += 1.;\n        color = rr.xyz;\n        if (d0 > max_dist || d < min_dist) {\n            break;\n        }\n    }\n    return ray(d0, steps, p, getNormal(p, tt, ttt), color, cc/200.);\n}\nvec3 getColor(vec3 roo, vec3 rdd, bool tt, bool ttt) {\n    vec3 color = vec3(1);\n    ray rr;\n    vec3 ro = roo;\n    vec3 rd = rdd;\n    vec3 sky;\n    float dist = 0.0;\n    for (int i = 0; i < 2; i += 1) {\n    \tfloat t = clamp(rd.y+0.5, 0.0, 0.5);\n   \t\tsky = vec3(t*1., t*1., t*1.4)*1.5;\n    \tray rr = get_ray(ro, rd, tt, ttt);\n        if (rr.dist < max_dist) {\n            dist = rr.dist;\n            if (rr.color.x != 0.111) {\n                if (rr.color.x != 0.222) {\n               \t\tcolor *= rr.color * vec3((clamp((dot(rr.normal, normalize(lightPos))+0.2)-(0.5/rr.ao), 0.0, 1.0)+0.2)/1.9)*vec3(1.2, 1.2, 1.1);\n                \tbreak;\n                } else {\n                    color = vec3(1.5, 1.5, 0.8);\n                }\n            } else {\n                ro = rr.pos*0.99;\n            \trd = reflect(rdd, rr.normal);\n                color = vec3(0.7, 0.7, 0.8);\n            }\n        } else {\n            color = vec3(rr.cc*1.5)*sky*color;\n            break;\n        }\n    }\n    color = mix(color*1.0, clamp(sky, 0.0, 1.0), (dist/10.));\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = iResolution.x/iResolution.y;\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    vec3 ro = vec3(sin(10.)*2., 0.1, cos(10.)*2.);\n    vec3 at = vec3(0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n\tvec3 color = mix(mix(getColor(ro, rd, false, false), getColor(ro, rd, true, false), 0.6), getColor(ro, rd, true, true), 0.6);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 118, 118, 217], [218, 218, 243, 243, 271], [272, 272, 301, 301, 388], [389, 389, 411, 411, 1373], [1374, 1374, 1408, 1408, 1765], [1766, 1766, 1789, 1789, 2022], [2126, 2126, 2169, 2169, 2896], [2897, 2897, 2940, 2940, 3145], [3146, 3146, 3196, 3196, 3664], [3665, 3665, 3719, 3719, 4733], [4734, 4734, 4791, 4791, 5334]]}
{"id": "wsVfzD", "name": "Neural SDF 2", "author": "simesgreen", "description": "A signed distance field, approximated by a neural network (multi-layer perceptron)!\n\nBased on:\nhttps://arxiv.org/abs/2009.09808\nhttps://github.com/nathanrgodwin/overfit-shapes\n", "tags": ["sdf", "bunny", "neuralnetwork"], "likes": 18, "viewed": 1265, "published": 3, "date": "1606747036", "time_retrieved": "2024-07-30T20:33:00.448872", "image_code": "// Neural SDF shader\n// sgreen 25/11/2020\n// \n// based on \"Overfit Neural Networks as a Compact Shape Representation\":\n// https://arxiv.org/abs/2009.09808\n// \n// trained using Nathan Godwin's code:\n// https://github.com/nathanrgodwin/overfit-shapes\n//\n// WARNING - takes about 30 seconds to compile on Windows!\n\n// magic numbers!\nconst float weights0[] = float [] (\n0.1028, 1.6673, 1.4198, -0.3303, -0.3514, 0.3852, 1.2728, 0.0222, 1.9401, -1.0903, 0.2250, \n-0.7970, 0.0080, -0.0123, -0.0033, 0.7314, -0.3248, -1.9151, 0.2630, -1.7573, -1.3383, -0.0020, \n-0.0015, 0.0052, -1.0466, 0.5547, 0.8525, -0.6951, -1.5900, 0.9958, -1.9402, 0.1746, 0.0532, \n-0.8347, -1.5226, 0.9124, -0.0014, -0.0004, 0.0014, -0.1210, 0.1571, 0.9184, -0.1586, -0.3184, \n-0.2862, -0.0026, -0.0021, -0.0110, -0.0003, -0.0026, 0.0087, 1.1592, -1.5602, 0.5586, 0.9330, \n-0.7047, 0.1727, 0.9648, 1.1793, -0.1516, 0.3526, -0.3139, 0.4080, 1.5673, 0.5157, -0.3350, \n-1.5944, 0.8795, -0.4067, -1.7084, -0.5785, -0.8153, 0.2055, -1.1105, -0.1587, 1.3749, 0.4110, \n-1.1008, 0.0028, -0.0009, 0.0012, 0.1590, -0.7882, 0.9825, -1.0313, -0.3224, -0.9920, 0.1336, \n0.2857, -0.4648, 0.0005, -0.0010, 0.0007, 1.2120, 0.8832, 1.3406 );\nconst float biases0[] = float [] (\n-0.3867, 0.1746, -0.5758, 0.2307, -0.0157, -0.4884, -0.5818, -0.0094, 0.1981, -0.3026, -0.6063, \n-0.9125, -0.0030, 0.2129, 0.1765, -0.0106, -0.0065, -0.4815, 0.1919, 0.0849, 0.3321, -0.5782, \n-0.5608, -0.2297, 0.0756, -0.4128, -0.0041, -0.0205, -0.6315, 0.1674, -0.0015, -0.0256 );\nconst float weights1[] = float [] (\n0.2037, -0.9934, -0.1013, 1.9876, -0.0311, 1.0910, 1.4144, -0.0172, 0.0383, -0.6151, 0.0747, \n0.1972, -0.0219, 0.9227, -0.6424, -0.0347, 0.0025, 0.3911, 1.3110, 1.0343, 0.4547, 0.3814, \n-0.3754, -0.5237, 0.2852, 0.2478, 0.0114, 0.3030, -0.7501, -1.3647, 0.0013, -0.0365, 0.3817, \n0.2514, 1.4081, 0.5378, 0.0503, 1.6461, 0.5127, 0.0306, -0.3719, -1.5634, -0.2897, 0.8626, \n0.0213, -0.0374, -0.7606, 0.0238, -0.0194, 1.2464, 0.2474, -1.1886, 0.1409, -0.6562, 1.5343, \n0.3555, -0.0780, -0.1540, 0.0222, 0.7055, -1.0881, 0.0873, 0.0006, 0.8332, -0.1404, 0.2851, \n0.4923, 0.4213, -0.0087, 0.6011, -0.9928, -0.0172, 0.3074, 0.3870, 1.3318, 0.2964, -0.0056, \n0.2141, -0.1002, -0.0081, -0.0143, -0.0985, -1.3874, -0.8923, -1.0612, -0.2916, 0.7248, 1.4539, \n-0.3564, 0.6867, 0.0242, 1.6232, 0.5841, -0.5504, 0.0059, 0.3762, -0.5952, -0.8804, 0.2201, \n0.3750, 0.0023, -0.2354, -1.6843, -0.0005, 0.1014, 1.0131, 1.2806, -0.4663, -0.0161, -1.9120, \n0.7502, -0.0447, 0.0063, 0.6551, 0.7904, -0.3896, -0.3006, 0.0872, 0.7532, -0.2246, 1.3207, \n-0.5176, -0.0013, -0.5836, 2.0141, 0.1730, 0.0092, -1.6107, -1.0937, 0.8592, 0.9688, -0.3333, \n-0.0002, -0.3962, 1.5307, 0.0014, -0.4677, 0.9766, -0.2486, -1.1528, -0.0284, -0.1039, 0.5820, \n-0.0255, 0.0093, -0.0674, -2.1270, 0.0605, -0.4676, -1.6150, -0.9497, -0.1346, -0.8507, -0.7330, \n-0.0079, 0.0714, 0.9042, 0.3284, 0.0205, -0.5179, 0.8930, -0.0594, 0.5634, -0.6677, -0.0236, \n1.6660, 1.4573, -0.0043, 0.4389, 1.4000, -1.2570, -0.6729, -0.0014, -0.3419, 0.1299, -0.0183, \n0.0267, -0.4031, 0.3967, 1.6200, -0.5863, 0.2568, 0.6680, -0.4042, 0.0511, 0.0509, -0.0203, \n-0.7441, 0.6488, 0.1622, -0.0121, -2.5653, -0.9385, 0.5555, 1.3995, 0.6823, -0.0182, 0.7926, \n0.5731, -0.0199, -1.3147, 1.5697, 1.0589, -1.4346, -0.0208, -0.5872, 0.4184, -0.0236, -0.0104, \n0.5920, -0.3739, 1.0562, -0.1695, 0.7168, -0.1222, 1.2475, 0.1182, 1.8880, 0.0045, 0.4134, \n0.1631, 0.3327, 0.0013, 0.2165, 1.8016, -0.8695, -0.0612, -0.0868, -0.0187, 1.4634, -0.6077, \n0.0268, 0.3631, 1.1662, -0.3248, -0.2189, 0.0065, -0.2241, -0.5289, -0.0076, -0.0265, 0.4976, \n0.7993, 0.4770, -2.1075, 0.0480, 0.7668, 1.0906, 2.0608, -1.1112, -0.0115, 0.0232, -1.0531, \n0.1299, 0.0034, 0.6244, 0.3119, -0.8879, -0.3340, 1.2381, 0.0119, 0.9355, 0.7072, 0.0065, \n-0.3339, -1.1527, -0.5357, -1.6152, 0.0048, -0.1846, -0.4670, 0.0142, -0.0103, 0.7438, -0.8238, \n0.9325, -1.1223, 0.8473, -0.2862, 0.1433, 0.2211, 0.6259, -0.0016, -0.1737, 0.6370, 1.0181, \n-0.0076, 0.1137, 0.0257, -0.2435, 0.4916, -0.6622, -0.0122, 1.1284, 0.1538, -0.0188, -1.6081, \n0.1971, -0.8243, 1.1445, -0.0195, -0.0862, 0.7766, 0.0278, -0.0177, -2.1064, 0.9050, -0.7993, \n0.6642, 0.0200, -1.4298, -0.8543, 0.0843, -1.2796, 0.0050, -0.7540, -0.3004, 0.1340, -0.0052, \n0.5084, 1.2636, -0.6925, 0.4489, 0.1704, 0.0447, 0.1760, 0.8850, 0.0289, 0.9225, -0.8288, \n-2.6319, -0.3112, 0.0520, 0.7215, 1.1524, -0.0012, -0.0950, -0.9662, -0.0557, -0.4436, -0.3644, \n0.4808, 0.4563, 1.0721, 0.7606, 0.5439, -0.0465, 0.2752, 2.2401, 0.0122, -0.0097, 0.5794, \n0.8363, -0.5419, 0.7520, 0.4836, 0.0238, -0.2551, -1.2332, -0.0031, 0.5303, -3.3239, 1.1512, \n-0.3344, -0.0142, -0.8050, -0.7677, -0.0268, 0.0123, 2.1208, 1.2948, -0.6279, 0.9257, 0.7650, \n0.6576, -0.4323, 0.1682, 0.3560, -0.0402, -0.3861, 0.2759, -0.4253, 0.0035, -1.2439, -0.5303, \n-0.1853, 1.1040, -0.7702, 0.0052, 1.1034, -1.2570, -0.0054, 0.6655, -0.1019, 0.6065, 0.4453, \n-0.0201, 0.3580, 0.1536, 0.0236, 0.0157, -0.7890, -0.2546, 0.9625, 0.0331, -0.2407, -0.1174, \n-0.7600, -0.0255, -0.0418, -0.0146, 0.5293, 0.2750, 0.3407, 0.0133, 0.6635, -0.6473, 0.5342, \n-1.2486, 0.8833, 0.0117, -0.1282, 0.9030, -0.0028, -0.3492, 0.5184, -0.7364, -0.7152, -0.0184, \n-0.6800, 0.4175, -0.0082, -0.0126, 0.7757, -0.0689, -0.5726, -0.3400, -0.1183, 0.7625, 0.6138, \n0.9709, -0.3027, 0.0152, -0.1030, 0.5747, -0.3547, -0.0143, -0.7178, -1.9158, 0.4580, 0.0387, \n0.3652, 0.0227, 1.5282, -0.8287, -0.0097, -0.8330, 0.5614, 0.0884, 1.0802, 0.0024, 0.3256, \n0.8085, 0.0063, 0.0121, 0.2118, -0.3566, -0.7868, 0.8736, -0.0054, -2.5080, 0.6331, -1.8706, \n-0.3475, -0.0149, -1.7731, 0.1858, -0.5613, -0.0083, 0.7123, -0.1025, -0.2080, 0.9823, 0.1777, \n-0.0050, -1.2860, 1.9564, -0.0007, 0.5873, 1.4092, -0.7764, 0.0264, 0.0053, -1.2972, 0.0405, \n-0.0080, 0.0104, 0.8922, 0.7314, -1.1333, -0.1260, 0.7140, 0.7637, -0.1307, 0.5906, 0.3836, \n-0.0154, 0.4272, -0.1162, -1.5735, 0.0096, -0.2321, -0.7203, -0.2287, 0.3899, 0.3967, -0.0006, \n-0.3956, 1.0182, 0.0236, -0.2099, 1.3991, -0.9546, 0.4545, 0.0096, -0.7855, 0.0759, 0.0277, \n0.0009, 0.6718, 0.6082, -0.8759, -0.2590, 2.2639, -1.3199, 0.5501, 0.8974, -0.2472, 0.0049, \n1.0487, 0.6304, -0.8398, -0.0101, -0.2444, -0.2112, -0.3450, 1.2127, 1.5077, -0.0336, 0.4984, \n-0.6986, 0.0223, 0.2118, -0.4520, 0.8194, -1.7843, 0.0076, 0.0984, -0.5388, 0.0196, -0.0072, \n-2.6783, 1.5554, -1.4202, -0.9471, -0.3936, 0.5031, -3.0838, 1.2713, 1.0798, -0.0087, 0.7303, \n-0.2588, -0.1846, 0.0006, -0.4052, -0.6369, 0.3119, 0.4323, 0.0054, -0.0143, 0.3685, -0.4835, \n-0.0266, -1.5793, 0.6067, -0.4342, -0.4682, -0.0106, -1.4014, 1.0713, 0.0145, -0.0174, 0.5207, \n0.0846, -0.9906, 0.0876, -0.4465, -0.6580, -0.0191, 0.7347, 1.1991, -0.0038, -0.7814, -0.4180, \n0.4941, 0.0094, 0.4427, 0.2668, -0.3127, -0.3145, -0.2621, -0.0155, -1.5802, -0.3939, -0.0215, \n1.3082, 0.4412, -1.0850, 1.3372, 0.0135, 0.6136, -0.0857, -0.0550, 0.0084, -0.5590, 0.4500, \n-0.7855, -0.7416, 0.4621, -0.1073, -0.3524, -0.2267, -0.2371, 0.0066, -2.3679, 0.4380, 0.7111, \n-0.0063, -0.2289, 1.2687, -0.2270, 2.2731, 0.0502, 0.0197, 0.0309, -1.0093, 0.0257, 0.3545, \n1.1503, 0.2529, 0.9224, 0.0021, 0.1398, -0.9182, -0.0390, 0.0250, -0.2668, 0.0798, 0.4717, \n-0.4359, 1.1202, 2.0226, -1.0434, 0.6737, 0.6657, 0.0167, 0.1838, -0.2465, -0.1418, 0.0042, \n0.1769, 1.6190, -1.0459, 0.6003, -0.4237, -0.0138, -0.9754, 0.8761, 0.0129, 0.2913, 1.4255, \n0.4580, 0.1268, -0.0016, 0.5374, -0.8440, -0.0268, -0.0067, 1.0087, -0.5808, 0.7826, -0.1562, \n1.0863, -0.5791, 0.4325, -0.4241, -0.0534, 0.0298, 0.0342, 0.0151, -0.0065, -0.0091, 0.9946, \n-1.1303, 0.8997, -0.0430, 1.3105, 0.0019, -0.2920, -0.8047, -0.0037, -3.5439, -1.0579, -0.1618, \n0.2730, 0.0196, -1.1384, 0.0410, 0.0291, -0.0088, -1.1101, -0.4655, 0.4312, -0.0559, 0.7520, \n-0.4250, -0.0139, -0.9089, 0.4658, -0.0065, -0.3520, -0.0613, -0.5780, -0.0042, -1.9684, 0.3147, \n0.1511, -2.9015, -1.2924, 0.0067, 0.4367, 0.7907, 0.0409, -0.0092, 0.0893, 1.1817, 1.8916, \n0.0305, 0.7592, -0.3532, -0.0036, 0.0027, 0.0161, -0.1907, 0.2640, 0.8656, -0.0626, -1.1963, \n-0.4154, -0.1718, 0.2226, 0.0154, -0.7120, -2.0126, -0.2813, 0.0036, 0.7207, -0.6098, 0.7984, \n0.7752, -0.5314, 0.0052, -0.0414, -0.1651, 0.0057, 0.5989, 1.0892, 0.1319, 0.3109, 0.0059, \n0.7426, 0.0983, -0.0027, -0.0096, -0.3693, 0.1972, -0.3136, 0.2012, -0.8557, 1.0019, -0.0456, \n0.1568, -0.4816, -0.0289, 0.7012, -0.0070, -1.3532, -0.0126, 0.7353, 0.2742, -0.0492, -0.6741, \n-1.2868, -0.0046, -0.4192, -0.8904, 0.0277, 1.3388, 0.7458, 1.3360, -0.2728, 0.0222, 0.5238, \n-0.3320, -0.0117, 0.0052, -1.3869, 0.8517, 0.2338, 0.0462, -0.3682, 0.0710, -0.4171, 0.7230, \n-0.3606, 0.0188, 1.0865, -0.1551, 0.5649, 0.0002, -0.8437, -0.7892, 0.3777, -1.1529, 0.6962, \n-0.0340, 1.1519, -0.7880, 0.0153, -2.8821, 0.2298, 0.5041, 1.9120, 0.0188, 0.5011, 0.6910, \n0.0215, 0.0281, 0.4350, 0.1090, -0.3832, -0.1811, -1.3690, 1.6927, 0.4188, -0.3184, 0.2626, \n0.0012, 0.2696, 0.7107, -0.0048, -0.0088, -0.3968, -0.8103, 0.3826, -0.4114, -0.6385, -0.0198, \n-0.2688, 0.6372, -0.0088, 0.1554, -0.0194, -2.0871, -1.2823, 0.0087, -0.5485, 0.7810, -0.0204, \n-0.0089, 1.2859, -1.4324, -0.5725, -0.1087, -0.6173, -0.1060, -0.8380, -2.2218, 0.5243, 0.0044, \n0.5747, -0.3378, -0.0720, -0.0166, -1.5445, 1.5430, 0.7032, -0.7525, -0.0559, -0.0041, -1.2377, \n-1.2170, -0.0018, 0.5231, -0.5861, -0.6081, -0.4988, 0.0206, -0.8179, -0.5841, 0.0144, -0.0081, \n0.5576, -0.2768, 1.3184, -2.6706, -0.8319, 0.7488, -1.2921, 1.1092, 0.9105, -0.0002, 1.0260, \n2.3716, 0.4689, 0.0053, -1.3012, 1.2711, -0.3959, 0.0943, 0.6500, 0.0323, 1.2036, 1.1646, \n-0.0092, 0.5430, 0.5052, -0.8343, -1.8500, -0.0068, -0.0922, 0.6508, 0.0237, 0.0179, -0.7005, \n-0.1053, 0.1508, -0.4474, 0.3639, -0.6971, 0.8756, 0.0986, -1.2861, 0.0086, -0.7588, 0.6039, \n0.3871, 0.0121, 0.1241, -0.9219, -1.2378, -0.2337, 0.0130, 0.0313, -0.0768, -0.0065, -0.0211, \n0.0784, -0.9616, 0.6584, -0.9761, 0.0163, 0.2488, -0.2900, 0.0262, 0.0140, -1.3573, -0.4574, \n0.5340, -0.5836, -1.1061, 1.4119, -0.4821, 0.0306, -0.0235, -0.0006, -0.1824, 0.0119, 0.6443, \n-0.0080, 0.4768, 1.0888, 0.1294, 1.0769, -1.4735, 0.0000, -0.3588, -0.0484, 0.0013, 0.6951, \n1.1398, 0.5132, 0.7368, -0.0034, 0.1781, 0.3593, 0.0154, -0.0099, -0.6515, -0.8216, 0.1288, \n-0.0235, 0.5572, 0.5687, -1.8520, -0.2117, 1.3683, 0.0007, -0.2192, -0.1503, 0.1511, 0.0040, \n1.0312 );\nconst float biases1[] = float [] (\n-1.5903, -1.4000, -0.9304, 0.1078, 0.9444, -0.6151, -0.9163, -1.3614, -0.2150, 0.6524, -1.4286, \n-0.9360, -0.0450, -0.7075, 0.4856, -1.5841, -1.3737, -0.2277, -0.3577, -0.1831, -1.2139, -0.7175, \n0.3511, 0.0538, -0.5451, -0.7014, -0.2137, 1.2562, -0.7662, -0.4431, -0.5397, -0.1270 );\nconst float weights2[] = float [] (\n0.9615, 0.3641, 0.7108, -1.2565, 0.3426, 0.6257, -0.7591, -0.0381, -0.4440, 0.1910, -1.9792, \n-2.0162, 0.4773, 0.5271, -1.2467, 0.4459, 0.2079, -1.4212, -0.4179, -1.7670, 0.5310, -0.8521, \n1.5889, 0.3216, -0.7682, 1.1271, -0.1154, 0.7325, 1.1688, -0.6005, -0.2962, 0.3583, -2.7215, \n-0.4042, -0.0012, 0.5562, -0.4670, 0.9071, -0.9936, 1.1625, -0.4680, -0.2204, -0.0960, -1.2111, \n0.1886, 0.3161, -0.9386, -0.1220, 1.0281, -0.6877, -0.0207, 0.4580, 0.2693, 0.2066, 0.7433, \n-0.3463, -0.2147, -0.2686, -0.4448, 1.0437, -1.0937, 0.0168, 0.7392, 0.7671, 0.2446, -0.1433, \n0.5917, -1.7294, 0.2946, -0.3953, 0.6402, 0.3588, -0.1399, -0.4596, 0.4497, -0.4538, 0.1131, \n-0.2322, -0.8198, -1.2447, -1.1113, -1.0501, 0.3899, -0.1309, 0.1831, 0.8335, -0.8446, 0.6795, \n0.7655, 0.3024, -1.0631, 0.4893, -0.4582, -0.0787, 0.0855, -0.4888, 0.3321, 0.4959, 0.5852, \n-0.5971, 0.5776, 0.0800, 0.9763, 1.2146, -0.0915, -0.2013, 1.0210, 0.8808, -0.4526, -1.0551, \n1.4202, -0.6870, -0.7511, 0.2425, -0.0143, -0.0435, 0.9191, -0.9512, -0.3755, 0.9080, -0.0164, \n0.5603, -0.7134, -0.3008, 0.9320, 0.4597, 0.4154, -0.1626, -2.2732, 0.1601, 0.3804, -0.8411, \n0.8503, -0.7037, -0.7987, 0.2593, -1.5137, -1.2783, 1.1013, -0.6130, -0.5623, -0.6166, -0.2695, \n0.6681, 1.3198, 0.7440, -0.1295, 0.7677, -0.1668, -0.0025, 1.1210, -0.4676, -0.8589, 0.9940, \n-0.9835, 0.4436, -0.4369, 0.1079, 0.1360, -0.0825, -0.7095, 0.0681, -1.3845, 0.5852, 0.8321, \n0.0605, 1.1025, 0.3809, -0.7221, 0.5267, -0.1641, -0.6587, -0.7080, 0.3581, -0.4730, -1.2431, \n0.7567, 0.4748, 0.2086, -0.3209, 0.4044, -0.0655, -0.6807, -0.5062, -0.1792, 0.9899, 0.0738, \n-0.4651, 0.5615, -0.2979, -0.0789, 0.0056, -0.2647, 0.4159, -0.0418, 0.6227, 0.4040, 0.3636, \n-0.5264, -0.0963, 1.3062, -0.2342, 0.2348, -0.7170, -0.9199, -0.4551, 0.1270, 0.2857, -1.4278, \n-0.2762, 0.4388, -0.6362, -0.2597, -0.2475, -1.0338, -0.1308, -0.0719, 0.4898, 0.0274, 0.6681, \n-0.6961, -0.8782, -1.1522, 0.7324, 1.4559, -0.5088, 0.3230, 0.0724, -0.2616, -0.1929, -0.8039, \n0.3292, 0.6831, -0.9345, 0.0043, -1.1654, -0.0865, 0.2562, -0.0593, 1.2474, -1.3338, 0.0027, \n-0.3772, -0.7264, 0.8516, -1.9820, 0.1548, -0.0778, 0.7137, -0.6119, 1.2299, 0.0138, 0.5013, \n-0.7631, -0.9939, -0.6386, -0.3077, 0.1781, -0.0237, -0.3262, 0.2881, 0.1228, 0.0844, 0.1961, \n-0.8574, 0.4877, -0.5856, -0.8566, -0.0642, 0.3583, -0.1731, -0.0220, -0.2000, -0.1868, -1.0696, \n-1.5965, 0.4023, 0.5220, -0.6586, 0.4334, -1.0592, 0.2308, -0.2647, 0.8456, -0.1612, -0.9128, \n-1.2446, -0.1251, 0.2892, -0.5044, -0.3747, -0.3555, 0.5972, -0.1808, 0.2070, -0.6374, -0.6036, \n-1.3443, -2.0261, 1.2490, -0.0177, 0.3175, 0.2166, -0.5418, 0.9668, 0.6408, 0.3539, 0.1286, \n0.5480, -0.4669, -0.7592, 0.1993, -0.5903, 0.1730, 0.1197, -0.4827, 0.4653, -0.4525, -0.8513, \n-0.4576, 0.8194, 0.9134, 1.3234, 0.9791, 0.5079, 0.4611, 0.3363, -0.4372, 0.9258, -0.5428, \n0.7705, -0.2705, 0.7332, -0.1152, 0.1458, 0.7850, 0.6869, 0.0914, 0.1422, 0.8796, -0.2120, \n0.4945, 0.9192, 0.3583, -0.1265, 0.5735, 0.2788, 0.2601, -0.8112, -0.3187, 0.3663, 0.6416, \n-0.3823, 0.2522, 0.2696, -0.5346, 0.2838, -0.2619, -0.5507, -0.7322, 0.5860, -1.0451, -0.1326, \n-0.7068, 0.4106, 0.5367, -1.2288, 0.2050, 0.2645, -0.2115, -0.0111, -0.8958, -1.2505, 0.3066, \n1.4262, 0.4448, -0.0143, -0.0997, -0.8134, 0.6952, -1.7971, 0.7330, -0.5741, 0.6936, -0.6141, \n1.7770, 0.3935, 0.1708, -0.2148, -0.0437, 0.1934, 0.0524, -1.0573, 0.2667, 0.7637, -0.4432, \n0.5039, 1.1426, 0.2580, 0.5152, -1.2821, 0.9741, 0.1809, 0.1923, -1.0616, 0.7731, -0.4472, \n-0.2922, -0.0814, 0.8629, 0.1368, 0.4933, -0.8948, -0.2161, -0.8033, -0.1695, -0.4781, 0.7218, \n0.1313, 0.3117, 0.8950, -1.1923, -0.3072, 0.6421, 0.4300, -2.4470, 1.3093, -0.4241, -0.5472, \n0.4420, 0.3381, 1.6517, -1.8540, 0.8487, 0.8205, -0.0164, -0.9833, -0.2729, 0.2228, -0.5919, \n0.0830, 0.7659, -0.0579, 0.0444, 0.1895, -1.5587, -0.6519, -0.0190, -0.8966, 1.1691, -0.7786, \n-0.1883, 0.1409, 0.0896, 1.1640, 0.5104, -0.8119, 0.8620, -1.0101, -0.3579, -1.6250, 0.0481, \n-0.4517, -0.2207, -0.2543, 0.2868, -1.8291, -0.0428, -0.2019, -0.7567, -2.2016, -0.0463, 0.7084, \n-0.6590, 0.2548, -1.3411, 1.9429, -0.2899, -0.6012, -1.8306, -0.1281, -0.0534, 0.3422, -0.5059, \n0.2954, -1.0717, 0.2148, -0.2702, 0.6576, 0.3255, 0.5079, 1.0290, -0.0792, 1.2377, -1.0057, \n2.2866, -0.6935, 0.3854, -0.7936, 0.5195, -0.5747, 0.7711, -0.9002, 0.1013, 0.6881, 0.7099, \n-0.2997, 0.0446, -0.7431, -0.7670, 0.1127, -0.8658, 1.8997, -0.4320, -0.6225, -0.3152, -1.2941, \n-0.0790, -0.8243, -0.2412, -0.1087, 0.3323, 0.1274, -1.1266, 0.2729, -0.5817, 0.2157, 0.4869, \n0.0630, -0.2592, -0.6345, -0.2924, -2.2870, -0.3677, 0.0337, -1.2604, -0.6918, -0.0929, -0.7726, \n-0.3030, 1.0100, 0.1473, 0.4599, -1.3256, 0.8796, 1.5478, 0.6699, -0.6653, 0.1552, -0.0816, \n-0.4298, -0.5381, -0.0087, -1.6599, -0.4192, -0.4127, 0.0655, -0.6082, -1.3003, -0.3227, -0.3404, \n0.5386, -0.0505, -0.4408, -0.6571, 0.8695, 0.3474, -1.0971, -0.5846, 0.4892, 0.1851, 0.0245, \n0.4851, 0.9137, 0.5579, 0.1807, -0.3458, -1.1599, 0.1899, 0.4100, 0.0861, 0.6511, -0.1799, \n-0.6587, 0.2953, -0.2669, -1.5148, 0.6587, -0.5553, -0.1108, -0.0009, 0.2148, -0.0202, -0.4221, \n0.4103, -0.2589, 0.0890, 0.6213, 0.5491, 0.2326, 0.4956, -0.1025, 0.6397, 0.0741, 0.0642, \n0.7262, 0.5070, -0.2106, -0.2947, -0.6731, 0.5036, -0.3751, 0.1505, 0.2574, -0.1145, -0.5114, \n-1.3168, 0.0144, 0.3128, -0.1230, -0.0783, 0.5160, -0.3098, -1.2948, -0.2636, -0.9889, -0.1309, \n0.8780, 0.8369, 0.6396, -0.1321, 0.5048, 0.4279, -1.6269, 0.5765, 0.4810, 0.1615, -0.5022, \n-1.4363, -0.3429, -1.3899, 0.7932, -0.2422, -0.1044, -0.3836, -1.9323, 0.0427, -0.3404, 0.1114, \n0.5713, -0.9552, 0.5966, -1.5306, 0.3490, 0.7517, 0.7451, -0.8441, -0.1107, -0.4358, 0.5782, \n-1.0853, 0.1196, -0.9939, -0.4254, -0.8361, 0.3055, -1.2385, 1.1064, -0.2365, -1.0342, -0.7817, \n0.2120, -0.3241, 0.5504, -0.7827, -0.0637, -2.1733, 0.4534, -0.5688, 0.2945, 0.9055, 0.5326, \n-0.1585, 0.7324, -0.1533, -0.3894, -1.5642, 0.4856, 0.2225, -0.2227, -1.6340, -0.4287, -0.4354, \n0.1731, 0.6402, -0.0743, 0.1931, -0.7186, 0.6786, -1.2820, -0.2227, 0.7574, 0.6806, -0.4493, \n-1.3490, 0.3093, 0.0931, -0.4481, 0.9673, 0.1425, -0.3327, -0.1494, 1.1964, 0.4227, -0.4073, \n0.7025, 0.6498, 0.7884, -0.7188, 1.3858, 0.4515, -0.9979, 0.1908, 1.3719, 0.3361, -0.8257, \n1.1756, -0.1589, -0.2409, 1.3644, -0.0627, -0.3256, -0.3890, -1.4530, 0.0177, -0.5089, 0.1421, \n-0.4634, -0.2485, 0.1502, -0.6235, -0.6336, -0.4525, -1.0850, -0.8245, 1.0048, -0.4884, -1.1681, \n-0.1713, -0.7141, 0.2250, -0.0005, -0.4913, -0.1702, -0.2851, -0.4535, -0.0510, -0.3361, -0.3893, \n0.0279, -0.0161, -0.3197, 0.3363, 0.1706, 1.1265, -0.2793, -0.0831, -0.8223, -0.3736, 0.7576, \n-0.0416, 0.6002, -0.1643, -0.2261, 1.0334, 0.5014, -0.4965, -0.8434, -0.6047, -1.4453, 0.3919, \n0.4876, 0.6502, -0.3849, -0.9699, 0.8736, -0.4790, -0.6747, 0.1407, -0.0722, 0.3787, 0.6481, \n-1.9073, 1.1740, 1.1456, -0.2385, -0.6735, 0.0134, -0.0648, 0.2784, -0.2075, 0.2192, 0.7126, \n-0.2530, 1.0569, 0.4630, -0.4768, -1.5135, -0.0320, -0.5077, -0.4773, 0.2095, 0.0581, 0.2799, \n-0.0718, 0.1004, -0.8941, -0.7096, 0.9014, -0.8832, -0.5268, 0.1379, 0.0870, 0.3177, -0.1767, \n-0.8781, 0.8684, 0.9020, -1.3122, -0.9206, -2.0631, 0.5132, -0.1977, -0.7251, -0.0888, -1.4335, \n0.4184, 1.1666, -1.1485, 0.9747, 0.3180, 0.4200, 0.4472, -0.2513, -0.5234, -0.8721, -1.8589, \n1.0140, 0.9771, 0.4363, 0.3374, -0.6595, 0.2879, -1.0252, -0.1044, -1.1856, -0.4153, -0.6517, \n-1.0178, 1.0538, 1.4262, -0.1001, 0.4477, -1.3394, 0.1495, 0.0589, -0.7254, 0.0472, 0.3313, \n-0.2133, -0.2408, -1.0380, -0.7772, 0.5337, 0.0496, -0.0411, -0.1126, 1.0657, 0.3442, 0.6248, \n-0.8121, -2.1604, 0.6243, -1.1335, 0.6896, -0.7523, 0.1527, -0.4389, 0.4157, 0.5143, 0.1589, \n-0.5768, -0.6495, -0.4035, -0.2209, 0.5325, 1.1390, 0.8578, -0.4047, 0.8918, -0.6158, 0.1705, \n-0.5199, -0.4463, -0.3637, 0.2485, -0.1858, 0.4594, 0.0173, -0.3136, 0.1836, -0.1839, -1.7145, \n-0.6577, -0.3875, -0.0999, -0.4030, 0.7508, -1.0110, 1.0949, -0.4468, 0.6666, -0.0360, 0.6937, \n0.1490, 0.1237, 0.8602, -0.3471, -0.3891, -0.4182, 0.3821, -2.4090, -1.8317, -0.5282, 0.4636, \n-0.1941, -0.7429, -0.1168, 1.3070, -0.1820, 0.7605, 0.7031, 1.0166, -0.7771, 0.4137, -0.0704, \n0.1944, -0.6597, -0.4903, 0.0338, 0.5349, -0.9897, 0.7137, 0.6469, -0.2258, -0.2187, 1.4367, \n0.2616, -1.5112, -0.9768, 0.7649, 0.3928, -0.1063, -0.3380, -0.1430, 0.4605, 0.5874, 0.7531, \n0.4078, 0.4331, 0.3250, 0.7644, 0.0315, 0.1611, 0.3085, 0.5133, 0.0586, 0.8963, -0.3265, \n-0.1730, 0.9052, 0.8342, 0.3631, 0.4212, 0.8943, -0.3559, 0.9505, -0.0670, 0.6717, 0.5663, \n-0.2270, 0.4086, -0.7122, 1.0930, 0.7699, -0.3333, -0.5880, 0.7524, 0.0631, 0.3611, -0.3387, \n0.6447, 0.7071, 1.3717, -0.2330, -0.2985, 1.2664, -0.5824, 0.7442, 1.0204, -1.5572, 0.8220, \n-1.4747, -0.8639, -1.2992, -0.2264, -0.8866, -1.6053, -0.8595, 0.2685, -1.0495, 0.5109, 0.4357, \n1.0904 );\nconst float biases2[] = float [] (\n-0.3983, 0.3359, -0.5472, -1.6984, 0.3076, -1.7286, 0.0291, 0.6512, 0.2428, -1.0264, -1.2279, \n0.0813, -0.8784, -0.2904, -0.4996, -1.2489, -0.2931, -2.0596, -0.8206, 0.3727, 0.2160, -0.9081, \n-0.2880, 0.7337, -1.3150, 0.0215, -1.1154, -0.7393, -1.0523, -0.6643, -1.0442, -0.8873 );\nconst float weights3[] = float [] (\n0.0039, -0.0125, -0.0043, -0.0141, 0.0295, -0.0254, -0.0040, 0.0001, 0.0102, 0.0220, 0.0057, \n0.0083, 0.0034, -0.0209, 0.0099, -0.0179, 0.0273, -0.0214, -0.0182, -0.0184, -0.0151, 0.0035, \n0.0006, 0.0134, -0.0076, 0.0122, -0.0277, 0.0159, 0.0163, -0.0215, -0.0076, 0.0247, -0.0573, \n0.0042, -0.0070, 0.0176, -0.0016, -0.0391, -0.0207, 0.0092, 0.0048, 0.0027, -0.0193, -0.0200, \n-0.0116, -0.0191, -0.0188, -0.0113, 0.0145, -0.0147, -0.0643, 0.0319, -0.0372, 0.0457, -0.0813, \n0.0119, 0.0334, 0.0233, -0.0298, 0.0167, -0.0174, -0.0079, -0.0194, -0.0314, -0.1111, -0.4043, \n-0.3005, -0.0540, 0.2397, 0.1314, 0.5226, 0.3570, -0.2072, 0.3573, -0.1222, -0.2606, 0.1134, \n-0.9201, -0.0910, 0.0539, -0.0296, 0.3822, 0.0619, 0.2567, 0.0119, -0.1748, -0.3136, 0.0420, \n-0.7668, -0.1395, -0.1276, 0.1549, 0.0530, -0.1428, -0.5038, -0.1618, -0.0078, -0.0399, -0.0277, \n0.0161, -0.0002, 0.0375, 0.0123, 0.0098, -0.0168, 0.0047, -0.0314, -0.0369, -0.0288, -0.0001, \n0.0202, -0.0057, 0.0282, -0.0366, -0.0351, -0.0371, -0.0074, 0.0179, -0.0141, 0.0053, 0.0316, \n-0.0117, -0.0149, -0.0339, -0.0310, -0.0066, -0.0129, 0.0986, -0.0281, 0.0171, -0.0002, -0.0002, \n0.0148, -0.0127, 0.0257, 0.0075, 0.0048, 0.0153, 0.0002, 0.0001, -0.0169, -0.0171, 0.0140, \n0.0136, 0.0226, -0.0005, 0.0059, -0.0007, -0.0259, 0.0123, -0.0085, 0.0094, -0.0026, 0.0048, \n-0.0236, 0.0088, -0.0119, -0.0165, -0.0073, 0.0272, -0.3997, -0.0646, -0.4748, 0.0980, -0.3192, \n-1.1887, -0.9240, 0.0744, -0.2605, -0.5374, -0.3752, 0.2806, -0.1946, -0.3414, 0.1628, -0.1341, \n-0.2798, 0.1494, 0.2516, 0.5300, -0.2229, -0.5047, 0.1844, -0.4397, 0.0236, -0.1883, -0.1733, \n0.1306, 0.1889, -0.2573, 0.1055, -0.1112, -0.0160, 0.0029, -0.0109, -0.0230, 0.0353, -0.0024, \n-0.0014, -0.0047, -0.0029, 0.0099, -0.0130, -0.0001, -0.0226, -0.0128, -0.0027, 0.0012, 0.0278, \n0.0018, -0.0158, 0.0066, -0.0057, 0.0299, -0.0047, 0.0232, 0.0230, 0.0189, -0.0485, 0.0065, \n-0.0125, 0.0083, 0.0098, 0.0145, -0.2843, 0.1360, -0.1590, -0.4197, 0.3097, 0.0515, -0.6931, \n0.3596, 0.5024, 0.1935, -0.0888, -0.1666, -0.2825, 0.4931, 0.3587, -0.3015, 0.0184, -0.2614, \n-0.4572, -0.5801, 0.4817, 0.2702, -0.4570, -0.0898, -0.2800, -0.2925, -0.2057, 0.0188, -0.8359, \n-0.2937, -0.1204, -0.1620, -0.0137, 0.0063, -0.0105, 0.0006, 0.0204, 0.0009, 0.0087, -0.0036, \n-0.0110, -0.0180, -0.0115, 0.0036, -0.0113, -0.0075, 0.0060, 0.0223, 0.0412, -0.0003, -0.0281, \n-0.0050, 0.0061, 0.0303, -0.0209, 0.0178, 0.0027, 0.0172, -0.0498, 0.0068, -0.0062, -0.0305, \n0.0090, 0.0216, -0.0006, -0.0029, 0.0013, 0.0237, -0.0035, 0.0071, 0.0104, 0.0081, 0.0050, \n0.0189, -0.0105, 0.0018, 0.0116, -0.0086, 0.0344, 0.0156, 0.0615, -0.0353, -0.0261, -0.0090, \n0.0005, 0.0400, 0.0072, 0.0159, 0.0098, 0.0309, -0.0684, -0.0129, -0.0158, 0.0039, -0.0111, \n0.0307, -0.2694, -0.2972, 0.3293, 0.1010, 0.0258, -0.4605, 0.1234, 0.6190, -0.3782, -0.5331, \n-0.2268, 0.8190, -0.0987, -0.2132, -0.2056, 0.2425, 0.0692, 0.4386, 0.2301, 0.1515, 0.1529, \n-0.4747, -0.1200, 0.2879, 0.1043, -0.7773, 0.0930, -0.2048, -0.0649, -0.4823, -0.1379, 0.3543, \n-0.8462, -0.3350, 0.1005, 0.1871, -0.2445, -0.4884, -0.4541, 0.0385, 0.0287, -0.7943, -0.0401, \n-0.2635, -0.2452, 0.1825, -0.2038, -0.0420, 0.0692, -0.9232, 0.0637, -0.1567, -0.1699, -0.1991, \n-0.2292, -0.3626, -0.2872, 0.1459, 0.4003, 0.0828, -0.3624, -0.5574, -0.1634, 0.1962, 0.4666, \n0.3801, -0.5025, 0.1513, 0.5822, 0.8416, 0.3831, -0.2287, 0.5995, 0.7514, -0.1493, -0.1694, \n-0.2351, 0.3374, -1.4076, 0.0078, 0.9359, -0.3488, -0.1418, 0.2597, -0.7749, 0.2772, 0.0402, \n-0.3209, 0.7518, 0.1575, 0.3333, 0.0235, 0.7109, 0.6438, 0.0843, 0.1048, 0.4977, -0.0625, \n0.0505, -0.0920, -0.2169, -0.0431, 0.1763, -0.5736, 0.2029, 0.3672, -0.0139, 0.3500, -0.8895, \n1.0033, 0.3873, -0.3738, 0.4479, -0.5078, 0.0546, 0.7087, 0.1121, 0.1215, 0.1777, 0.0260, \n0.3595, -0.2566, -0.0152, -0.3105, -0.2985, 0.0721, -0.0404, 0.5817, 0.2341, -0.2425, -0.3886, \n-0.1910, 0.4061, 0.3619, -0.2446, 0.1320, 0.1558, 0.6732, -1.5964, -0.0488, -0.2317, 0.0393, \n-0.0701, -0.0063, -0.3830, 0.0739, 0.0492, -0.0761, 0.1364, 0.6627, -0.1083, 0.3674, -1.1465, \n0.1626, -0.5847, -0.2995, 0.0215, -0.0454, -0.7884, 0.0454, 0.4416, 0.0710, 0.1936, -0.3656, \n-0.0212, -0.8280, -0.1572, -0.3725, -0.2825, 0.0677, 0.0397, -0.0422, 0.5133, -0.1535, 0.6457, \n-0.2042, -0.4008, -0.8220, -0.1280, -0.4479, 0.0899, 0.4617, -0.1454, -0.2475, -0.0147, -0.0367, \n0.1473, -0.2201, -0.3553, -0.3234, -0.1235, -0.5960, 0.0164, 0.0113, 0.0133, 0.0052, 0.0105, \n0.0157, -0.0058, -0.0429, 0.0360, 0.0023, -0.0267, -0.0150, -0.0155, -0.0235, 0.0345, -0.0028, \n0.0009, 0.0071, -0.0264, -0.0017, -0.0103, 0.0352, -0.0145, 0.0120, 0.0246, -0.0033, -0.0272, \n-0.0161, -0.0001, 0.0312, -0.0222, 0.0025, -0.6540, -0.0966, -0.1522, -0.1767, 0.2894, 0.1715, \n-0.2085, -0.1053, 0.1221, -0.5922, -0.2623, -0.0463, 0.1301, 0.3376, -0.0646, -0.3653, -0.1716, \n-0.6340, -0.1533, -0.2490, 0.0071, 0.3125, -0.2388, 0.3027, 0.4351, -0.0169, -0.1282, -0.4638, \n0.3037, 0.5839, -0.1784, -0.1407, -0.6260, 0.2673, 0.1720, 0.2260, -0.6548, -0.7909, 0.2983, \n0.2197, 0.5014, 0.4145, 0.2490, 0.2199, -0.0351, 0.3555, -0.1216, -2.2854, -0.8020, 0.7741, \n0.1356, 0.1085, -0.3565, -0.4308, 0.6916, -0.3289, -0.4633, -0.4432, 1.0548, 0.6184, -0.3230, \n0.1334, -0.4709, -0.1090, 0.0035, 0.0105, -0.0000, 0.0038, 0.0056, 0.0268, 0.0081, 0.0142, \n-0.0066, 0.0001, 0.0055, -0.0072, -0.0080, -0.0229, -0.0043, 0.0192, -0.0032, -0.0111, -0.0069, \n-0.0176, 0.0148, -0.0005, -0.0348, 0.0147, -0.0182, 0.0095, -0.0253, -0.0037, 0.0018, 0.0060, \n-0.0067, 0.0085, -0.1380, -0.1516, -0.2576, -0.3296, 0.3229, 0.4967, -0.4356, -0.1980, -0.1747, \n-0.0475, -0.1013, 0.3357, -1.0082, -0.9079, -0.1032, 0.1784, 0.7716, -0.4379, 0.2831, -0.0838, \n0.5897, -0.6358, -0.3806, -0.0302, -0.5958, -0.6468, -0.3181, 0.0446, 0.2366, -0.2941, -0.2416, \n0.3141, 0.0396, -0.0012, -0.0119, 0.0222, 0.0196, 0.0286, -0.0118, 0.0153, -0.0275, 0.0010, \n-0.0164, -0.0009, 0.0140, 0.0048, 0.0252, 0.0050, 0.0488, -0.0736, -0.0620, -0.0518, -0.0072, \n0.0210, -0.0258, 0.0174, 0.0257, -0.0046, -0.0359, -0.0079, -0.0238, -0.0116, -0.0079, 0.0526, \n0.0240, -0.0111, -0.0065, -0.0040, -0.0093, -0.0018, 0.0152, -0.0121, 0.0243, -0.0106, -0.0329, \n0.0059, -0.0118, 0.0005, 0.0308, 0.0093, 0.0540, 0.0053, -0.0180, 0.0098, 0.0151, 0.0167, \n-0.0352, 0.0329, 0.0267, 0.0103, 0.0052, 0.0110, -0.0139, -0.0115, -0.0151, -0.0003, 0.0675, \n0.1134, 0.1652, 0.1434, -0.4194, -0.0200, 0.0211, 0.0908, 0.3174, -0.2141, 0.1839, -0.0337, \n0.0362, 0.0312, 0.0983, 0.2610, -0.4272, 0.3050, 0.1847, -0.4244, -0.2417, -0.4032, 0.1031, \n-0.2263, 0.0735, -0.0056, -0.2143, -0.0659, 0.0680, 0.2444, 0.1167, 0.1722, -0.0271, 0.0136, \n-0.0018, -0.0057, 0.0274, 0.0233, 0.0071, 0.0131, 0.0036, 0.0052, 0.0030, -0.0037, -0.0064, \n-0.0120, -0.0078, 0.0048, 0.0246, -0.0195, -0.0268, -0.0042, -0.0191, 0.0236, -0.0016, 0.0187, \n-0.0231, 0.0137, -0.0124, -0.0050, -0.0035, -0.0025, -0.0035, 0.0235, -0.0863, -0.2747, -0.0108, \n-0.4556, -0.0516, -0.2851, 0.0425, 0.2456, 0.7792, -0.0678, -0.4548, -0.1451, 0.5612, -0.7380, \n0.7055, -0.3787, -0.5319, 0.4520, 0.6840, -0.4663, 0.2353, -0.3937, 0.7171, -0.9562, -0.6100, \n-0.2000, -0.0853, -0.5535, 0.0812, 0.3153, 0.0399, 0.0400, 0.3203, 0.0844, 0.1427, -0.0923, \n0.0073, -0.9656, 0.3525, -0.7014, -0.4454, 0.3953, -0.1185, 0.0713, -0.0364, 0.0244, 0.3998, \n-0.2131, -0.1445, 0.5095, 0.3547, 0.2000, -0.1532, 0.0778, 0.4257, 0.1901, 0.3652, 0.1030, \n-0.7259, 0.3797, -0.1578, -0.0644, -0.0688, 0.4507, -0.6026, -0.1536, 0.2388, -0.0779, 0.3068, \n0.1368, -0.4007, 0.3972, 0.2675, -0.0625, 0.0690, 0.1439, -0.3966, -0.2462, -0.1170, -0.0926, \n-0.3835, -0.2570, -0.4213, -0.3192, 0.1116, 0.2803, -0.1931, -0.1979, 0.1102, -0.0158, 0.2984, \n0.1359, -0.2910, -0.0050, -0.1876, -0.2082, 0.0404, 0.2161, 0.2701, -0.5539, -0.1972, 0.1112, \n-0.1928, 0.0182, -0.4393, -0.3906, -0.2795, -0.0278, -0.2386, 0.0365, 0.5180, -0.1013, 0.5163, \n-0.4942, 0.0511, -0.4277, 0.0185, -0.2714, 0.2493, -0.3520, -0.0060, 0.2447, -0.1607, -0.0850, \n-0.1570, 0.7170, 0.3975, 0.1406, -0.2307, 0.4881, 0.0488, -0.3951, -0.6936, -0.2529, 0.6593, \n-0.6423, -1.0615, 0.4348, -0.2204, 0.2450, -0.0903, 0.7853, -0.3225, -0.1225, -0.1328, 0.5915, \n-0.4914, 0.0752, -0.3520, -0.3678, 0.1690, 0.1942, 0.8825, -0.1632, 0.7632, 0.5925, 0.3541, \n0.2782, -0.1885, -0.0432, 0.2861, -0.0589, 0.1883, 0.2731, -0.6020, -0.0076, 0.0987, -0.0667, \n-0.0753, 0.2087, -0.1074, 0.2055, -0.0564, 0.5432, -1.3425, 0.3430, -0.3974, -0.1266, 0.4371, \n0.3234, 0.6657, -0.4399, -0.1186, -0.0181, -0.0669, -1.0424, -0.6556, 0.2364, -0.5882, -0.8690, \n-0.1935, -0.3310, -0.3380, -0.1665, -0.1993, -0.4783, -0.0120, 0.1874, 0.6800, -0.0083, -0.0679, \n-0.1680, 0.0455, -0.5998, -0.8488, -0.8015, -0.6805, 0.1687, 0.0129, 0.9224, -0.1131, 0.2286, \n0.6124, 0.1647, 0.3206, 0.0309, 0.4401, -0.2839, -0.4262, 0.2693, -0.3816, 0.3205, -0.1236, \n0.2643 );\nconst float biases3[] = float [] (\n-0.0627, -0.0849, 0.0910, -0.0682, -0.0564, -0.3592, -0.0685, -0.3227, -0.0645, -0.0643, -0.5981, \n-0.4058, -0.7803, -0.3026, -0.7628, -0.1935, -0.0528, -0.1235, -0.2680, -0.0463, -0.7831, -0.0773, \n-0.0768, -0.1238, -0.0595, -0.1018, -0.3578, -0.1677, -0.5204, -0.2229, -0.3683, -0.6300 );\nconst float weights4[] = float [] (\n-0.0001, 0.0018, -0.0219, -0.0017, -0.0004, 0.0187, -0.0005, -0.0321, 0.0001, 0.0003, 0.0268, \n0.0244, 0.0195, -0.0241, -0.1098, -0.0181, 0.0017, -0.0229, 0.0258, 0.0002, -0.0449, -0.0002, \n0.0014, 0.0370, -0.0001, -0.0145, 0.0160, -0.0131, 0.0236, 0.0177, 0.0217, -0.0209 );\nconst float biases4[] = float [] (\n-0.0179 );\n\nfloat leakyReLU(float x)\n{\n\treturn max(0.0, x) + 0.1 * min(0.0, x);\n}\n\nconst int H = 32;\t// size of hidden layers\n\n// compute MLP network layer\n#define COMPUTE_LAYER(I, W, B, N, M, O, R) \\\n    for(int i=0; i<M; i++) { \\\n        float r = 0.0f; \\\n        for(int j=0; j<N; j++) { \\\n            r += I[j] * W[i*N+j]; \\\n        } \\\n        r += B[i]; \\\n        O[i] = R ? leakyReLU(r) : r; \\\n    }\n\n// evaluate network at position p\n// returns distance to nearest surface\nfloat network(vec3 p)\n{\n    // temp storage\n\tfloat _out[H];\n    float _out2[H];\n    \n    // input\n    _out2[0] = p.x;\n    _out2[1] = p.y;\n    _out2[2] = p.z;\n        \n    // layer 0 (input)\n    COMPUTE_LAYER(_out2, weights0, biases0, 3, H, _out, true);\n        \n    // layer 1\n    COMPUTE_LAYER(_out, weights1, biases1, H, H, _out2, true);\n    \n\t// layer 2\n    COMPUTE_LAYER(_out2, weights2, biases2, H, H, _out, true);\n    \n\t// layer 3\n    COMPUTE_LAYER(_out, weights3, biases3, H, H, _out2, true);\n    \n    // layer 4 (output)\n    COMPUTE_LAYER(_out2, weights4, biases4, H, 1, _out, true);\n    \n    return tanh(_out[0]);\n}\n\n\nconst int maxSteps = 32;\nconst float hitThreshold = 0.0005;\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// cast ray using sphere tracing\nvec3 raycast(vec3 ro, vec3 rd, out bool hit)\n{\n    hit = false;\n    vec3 pos = ro;\n\n    for(int i=0; i<maxSteps; i++)\n    {\n        float d = network(pos);\n        //float d = sphere(pos, 0.5);\n        if (abs(d) < hitThreshold) {\n            hit = true;\n            break;\n        }\n        pos += d*rd;\n    }\n    return pos;\n}\n\nmat3 rotX(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);\n}\n\nmat3 rotY(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0, ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n#if 0\n    // visualize slice\n    float z = (iMouse.y / iResolution.y)*2.0-1.0;\n    float d = network(vec3(p, z));\n    fragColor = vec4(vec3(d), 1.0);\n#else\n    // ray cast\n    float rx = 0.0;\n    float ry = 0.0;\n    if (iMouse.z > 0.0)\n    {\n    \trx = ((iMouse.y / iResolution.y)-0.5)*3.0;    \n        ry = ((iMouse.x / iResolution.x)-0.5)*6.0;\n    }\n\t\n    // camera\n    mat3 m = rotY(ry) * rotX(-rx);\n    vec3 ro = m * vec3(0.0, 0.0, 1.5);\n    vec3 rd = m * normalize(vec3(p, -2.0));\n            \n    bool hit=false;\n    vec3 hitPos = raycast(ro, rd, hit);\n    vec3 n = normalize(cross(dFdx(hitPos), dFdy(hitPos)));\n    \n    //fragColor = vec4(hit ? hitPos : vec3(0), 1.0);\n    fragColor = vec4(hit ? n*0.5+0.5 : vec3(0), 1.0);\n#endif    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29379, 29379, 29405, 29405, 29448], [29775, 29848, 29871, 29891, 30472], [30536, 30536, 30567, 30567, 30595], [30597, 30630, 30676, 30676, 30958], [30960, 30960, 30980, 30980, 31087], [31089, 31089, 31109, 31109, 31214], [31216, 31216, 31273, 31273, 32116]]}
{"id": "tdVfzD", "name": "Ask the Mountains / Flow", "author": "lyurai", "description": "ask the mountains and flow inspired shader", "tags": ["scale"], "likes": 0, "viewed": 302, "published": 3, "date": "1606745698", "time_retrieved": "2024-07-30T20:33:01.219812", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.-iResolution.xy)/t;\n        t = iTime+float(c)/100.;\n        for(int i=0;i<5;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=8.;\n        \tuv=uv*rot(t/float(i+1));\n        }\n        \n     col[c] = fract(uv.x/t);\n        \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 480]]}
{"id": "WsVfzD", "name": "ReTrAdUi38 Crescent Vesica", "author": "ollj", "description": "drag the 4 dots.\n.y of 2 dots sets2 signs\n.x of 1 dot set length\n\nthe crescent shape (that generalized vesica) sadly is not too user friendly.\n\ni want to add it into a more intuitive wrapper\ni also want to include the moss-egg-generlitation into it.", "tags": ["ik", "hourglass", "superprim", "crescent", "vesica", "serif"], "likes": 0, "viewed": 374, "published": 3, "date": "1606726179", "time_retrieved": "2024-07-30T20:33:02.944200", "image_code": "/*\nReTrAdUi\n=[Re]Relativistic Epsilon          (buffC relativisic marcher with performance optimizations)\n,[Tr]Temporal     Reprojection     (buffD is still on its own)\n,[Ad]Automatic    Differentiation  (BuffB hopefully 3 derivatives in 4d)\n,[Ui]User         Interface        (BuffA drag and drop)\n\nthis amalgation is a bit messy, it can only go uphill from here.\nthe CommonTab has toggles between 3 scenes; Temporal Reprojection, Automatic Differentiation, and a 2d UI-focused Scene.\nbelow test is mostly about the [automatic differentiation] scene\nthe Image-MainImage function on the bottom here toggles between Re7 (relativityEngine) and all else.\nThe goal here is to unify concepts of 4 other shaders, where ever that makes sense and evades conflicts.\n*/\n\n/*\nin 3d space \n- keys [ESDF] moves camera\n- Mouse drag rotates camera (while not in edit mode)\n\n- key [t] toggles pausedTime                (camera unaffected)\n- key [g] toggles editMode (and halts Time) (mouse drag no longer rotates camera)\n\n\n\n*/\n\n//bayemode =0 has a period of 1 second //good to visualize the effect \n//bayemode =1 has a period of 1 frame, but may flicker way too much\n//bayemode =2 has a period of 1 frame, averages 7 averages of iTimeDelta (over intervals up to 1,2,4,8,1632,64,128)\n//bayemode =2 is extra slow for loading 2 fragments values of another buffer\n//bayemode =2 sucks for being way too slow without fragmentshader providing the values\n//bayemode =1 sucks while the player gives any inputs (second intgerval lags)\n//bayemode =0 sucks for maybe flickering like crazy \n#define BayeMode 2\n\n//but it should automatically adjust nicely to most resolutions (up to 1900x1000 px)\n//to maintain the same framerate at any resolution, it will automatically adjust the LoD\n//(LoD for now just the epsilon of the raymarrching)\n//BUT it does NOT predict the processing power of your gpu well\n//and that needs to be manually scaled to that by a divisor:\n\n//if you have a modern graphic card with like 6 GB vram (like geforce 1660)\n//these values are for a 1900x1000ish resolutuion) (nd smaller cones scale pretty well)\n//#define FPStarget pow(30./7.,1.68)  //60 fps\n\n//#define FPStarget (60.*3.)    //60 fps\n//#define FPStarget (50.*3.)    //50 fps\n//#define FPStarget (40.*3.)    //40 fps\n#define FPStarget (30.*3.)    //30 fps\n//#define FPStarget (20.*3.)    //20 fps\n//#define FPStarget (15.*3.)    //15 fps\n\n//#define FPStarget (1./500.)    //testing the [mie] limits for minimum epsilon\n\n//if you have an older graphic card with like 2 GB vram (geforce 0960)\n//chose any of the below, firstvalue is the fps you want (disregarding any LoD)\n\n//this one is old, the pow is likely not needed\n//you likely only change the divisor of /5.\n//#define FPStarget pow(60.,1.68) //60 fps\n//#define FPStarget pow(50.,1.68) //50 fps\n//#define FPStarget pow(40.,1.68) //40 fps\n//#define FPStarget pow(30.,1.68) //30 fps\n//#define FPStarget pow(20.,1.68) //20 fps //this integer fraction of 60 seems fine\n//#define FPStarget pow(10.,1.68) //10 fps\n//#define FPStarget pow(5.,1.68)\n\n//error to fix: a very small epsilon (hight LoD) results in noisy black dots\n//its a rough estimate, wobbly, more noticable while rotating the camera \n// on larger resolutions with lower fps\n//i did not even doisplay the fps result, and only did \"by feel\"\n\n\nvec4 Get(float a,sampler2D b\n){return texture(b,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nvec4 Get(float a){return Get(a,iRe);}\n//return texture(iRe,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\nRE,RelativityEngine,TargetFps\nTR,TemporalReprojection\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nself UI2TARD38: https://www.shadertoy.com/view/3l2GDR (amalgations2)\nparent UI2AD37: https://www.shadertoy.com/view/3tSGDz (slow progress)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\n\n//tags:\n//lod,blackhole,redshift,relativity,compatibility,dilation,bayesian,simultaneouity,bayeEp\n/*\nself    RE7 : https://www.shadertoy.com/view/tlf3zj\nparent0 RE6 : https://www.shadertoy.com/view/WtfGRj\nparent1 RE5?: https://www.shadertoy.com/view/tdfXDl\n/**/\n//todo, hide thes BaeysTheorem-oscillations in \n//- temporal reprojection\n//- a screenspace noisy-offset of parameters (uv stays unaffected)\n//- - 16x16BayerMatrix should be good enoug here\n//- all of the above\n//- a lower  FPStarget causes lessfps and better images\n//- a higher FPStarget causes higher and worse images\n//enter target fps as base below, and see it oscillate till it hopefully approaches the target fps\n//its a kind of magic of the logn() core function:\n//testing sclaing of resolutions is hard. the fps dispolay is a big overheat\n//, that tends to cost -5% of the fps.\n//the fun part, FPStarget is INDEPENDENT from the parameter below\n#define maxStepRayMarching 2000\n// within maxStepRayMarching[50..200], which mostly depends on the average scene curvature\n//which is hard to estimate becuase it has a black hole inside of it!!!\n//thats right, you enter 200 maxSteps, and   FPStarget pow(40.,1.68), and iut will reach 40 fps!\n//\"as you wish milord\"\n//initially FPStarget mapped to a targetFPS one to one (esponent was initially close to 1), \n//so yo you could enter what fps you wanted, and it would almost reach it.\n//but the more complex this gets, the worse your scales and estimates become\n//andd the overhead accumulates, and has problems to estimate its own cost.\n//currently the overhead is roughly an exponent of 1.6 to 1.7 ?\n//nonetheless, all the DIRECTIONS of the interpolations and bijections are correct\n//and with that exponent, you can enter the target fos as basis\n//it is optimized for the 500px-wide preview, may not scale too well to larger resolutions\n//i tried, this is VERY twittly.\n//this really needs BoundingVolumes, so that not all viewing angles have roughly the same complexity!!!\n//so yeah, if there ever was a shader that needed lobeps added to it...\n//but fitst let me fix compatibility iassues of this shader...\n/*\ncore idea here is, you set a target fps, and the renderer tries to just reach that FPS count.\nit may increase epsilon, if it was overperforming previously (fps was above FPStarget)\nit may decrease epsilon, if it was underperforming previously (fps was below FPStarget)\nstill, there exists a clamp() to the epsilon values\n, and a lot of of smoothened interpolation ramps and logarythms.\n, because an extreley huge epsilon makes little sense in 60fps\n, because an extremely tiny epsilon makes little sense, just to stay at a lower FPStarget\nThis begs for a better [BayesTheorem over time], but i have yet to implkement the necessary state for that.\nit does not just do this for epsilon, but also for [ReciprocalLipschitz]\n, ==[the amount you understep by]\n, ==[the interval of your volumeMarching]\nIt has a bias in vafor of the ScreenCenter \n- smaller reciprocalLipschitz near screencenter than near screen corner\n- smaller epsilon near screencenter than near screen corner\n- - the epsolon oscillations in a 1 second interval are more noticable near screen corners\n- - damnit this is inverse fovea!\nthis might be much more useful in a set with\n- Proper (axis aligned)BoundingVolume(hierarchy), may be great with fractals with simple escapeTime conditions\n- very different sceneries, a long beach horiton and a small simple box.\n- logatythmic epsilon marching\n- SoC marching\nnegative side effect;\n- it goes into the right directions, but it fails to estimate any half decent taylor series, and therfore misses the target a lot\n- , unles you add more exponents to twiddle with.\n- in too high resolutions (or at 15 or 30fps) , It may heavily oscillate between 2-4 states where it keeps being [too fast] , [too slow]\n- without proper [bayes theorem over time with buffer states] i fail to twiddle parameters to work with multiple resolutions/settings.\nbut so far the proof of concept holds up for this set, and it kinda works\n,while in     512.*384. px resolution\nmost of its magic comes from its bijective subroutine: (r2l2Ws(logn()))\n\n2020-08-02, i finally implemented the averaging over 8 averages of iTimeDelta\neach of them accumulates the incremental averave over the (up to) \nmost recent 1,2,4,8,16,32,64,128 frames, and the (non weighted) average of that\nis a pretty smooth alternative to just feedign iTimedelta or iFrameRate/60.\n*/\n\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log(x)/log(base);}//log2(x)/log2(base) has any utility? possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n//nope, i did not gain anything too useful from sucstituting for log2(x)/log2(bae), so far, i tried here, its just not pretty.\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}          //a[  0..1] <= a[1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //a[1/b..b] <= a[  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n//bayesEps concept\n//use BayesTheorem to adjust epsilon over time, to reach a target FPS\n//if you look along the horizon, expect epxsilon to increase, to maintain fps\n//if you look into a small box, expect epsilon to derase, for more precision\n//input current epsilon and TATGET fps\n//return an epsilon, in hopes to adjust epsilon, to get [[f] fps] with the next frames.\n\nfloat getEpsToFps(float e,float f   //f>0.\n){//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.5\n //.75 is a pretty high max epsilon, but its the easiest way to get performance\n //, especially further away from the camera or behind an occuder or near a black hole\n ;//mie=.00085*.8 has many dots in the spinning fractal balls on lightspeed=2.1 \n //when between blackhole of 2 and balls\n ;mie=.0009 //.00085 is ALMOST artefact free mie with recLipschitz==1.\n            //mie=.0009 is artefact free\n            //mie<.00085 makes the blackh hole looks smoother, but distant flat walls look worse.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode==2\n  //changes loD every frame, smoothly, but does +7 divisions per frame\n  ;vec4 reTime=Get(ReTime);//vec3 reTimE=Get(ReTimE).xyz//7 invremental averages\n  ;float a=suv(reTime)/4.  // divide by 4 to average 4\n  ;//float a=(suv(reTime)+suv(reTimE))/7.//average of 7 invremental averages (of different lengths)\n  ;//do NOT include iTimedelta into the above average, this just causes 1frape flickers\n  ;//im not sure if i even want the averaged 2 frames long flicker of reTime.x\n  ;i*=a/8.  //somehow a /8 modifier is needed //very smooth\n #elif BayeMode==1   \n  ;i*=iTimeDelta//changes LoD every frame, cheapest, very flickery\n #else\n  ;i/=iFrameRate//changes LoD every 60 seconds, cheap \n #endif\n ;i=i*FPStarget*6e3/(iResolution.x*iResolution.y) //6000=800*450/60\n ;e=r2l(i,6.)\n ;e=e//pow(e,2.)//sqrt(e)\n ;//e=log(e)\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae)\n ;//it seems i need a good sigmoid function here, maybe even hust atan1()\n ;return e\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not twiddle-account for many unknowns, without BayesTheorem.\n//the rotating fractal is evil here, because smaller epsilon result in BETTER lipschitz continuty AND better performance\n//so, some shapes are exceptions to general rules of optimitation-flow, with a shitty local extrema!\n//a minor drawbeck to the overall greatness of Naesian methods in sphertrackers.\n//or maybe just a bug to be fixed.\n\n//the fun of the above is, worst case is that it oscilates a bit\n//now, we can have 2 parameters independently modified in this way\n//both likely oscillate differently, and not the same (which woulc link them inapropriattrly)\n//so, lets also modify reciprocalLipschitz just like that:\n/**/\nfloat getReLipschitzToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.8//just do not make  mae>1., unless you are in logeps() marching territory.\n ;mie=.3 //mie<.3 has bad black lines in concave 90def corners\n ;//mie>.6 is already too large, for shapes\n ;//, that move with [half the speed of light][near a black hole]\n ;//- yes, these are my quality merasures for lipschitz continuity by now.\n ;//- once you have logeps()-marched a double [tensor] with lipschitz>5 \n ;//- with no continuity or performance problems\n ;//- , you kinda run out of challenges.\n ;float N=6.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode ==1   \n  ;float tt=pow(FPStarget,1./1.68)\n  ;tt=pow(tt*300./40.,1.68)\n  ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n  ;i*=tt/60.\n #else\n  ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n  ;i*=FPStarget/60.\n #endif     \n ;i=clamp(i,1./N,N)//worksave bound\n ;e=r2l(i,N)\n ;//a 1/N ratio maps to 0\n ;//a 1/1 ratio maps to 1\n ;//a N/1 ratio maps to 2 , so, this transforms a ratio into something to mix with:\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae);\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\n\n\nfloat sscocS=32.;//how better near screencenter than near screenborders\n\nfloat getReLipschitzToFps(){return getReLipschitzToFps(.25,FPStarget);}\n//our baseline is still a targetPFS\n//#define dd(a) dot(a,a)\n//now, lets make it better near the screen center\n//lets weight them over how oval-distant they are to screenspace center\n//of course the oval is scaled by sqrt(2) and is a smoothstep and all the good stuf\n\nfloat getEpsToFps(float sscoc//here it makes sense, i suppose\n){sscoc=mix(FPStarget/sscocS,FPStarget*sscocS,sscoc)//larger epsilon neart screenspace borders, smaller near center\n  ;return getEpsToFps(.001,sscoc);}\n\nfloat getReLipschitzToFps(float sscoc){//return 1.\n   ;sscoc=mix(FPStarget/sscocS,FPStarget,sscoc)//lefr value near corner, right value near center\n   ;return getReLipschitzToFps(.25,FPStarget);}\n#define reciprocalLipschitz getReLipschitzToFps()\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.xy is inner&outer bound of a dot's black border\n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bzier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n//#define viewzoom  (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n//matycentric triangle tracing speedup\nvec4 baryTriangle(float t,vec2 u,vec3 r,vec4 m,vec2 p3,vec2 p4,vec2 p0,vec2 p1,vec2 p2,vec4 c){\n ;float h=line(u,p0,p1)-.01\n ;h=min(h,line(u,p1,p2)-.01)\n ;h=min(h,line(u,p2,p0)-.01)\n ;c.w=min(h,ray(u,p3,p4)-.01) //draw ray and triangle\n ;c.x=h\n ;c.z=sdTriangle(p0,p1,p2,u)-.04\n ;float carthesianDet=c2bdet(p0,p1,p2)\n ;vec3 uu=c2b(u,p0,p1,p2,carthesianDet)\n ;vec3 ssu=sat(sign(uu))\n ;float uus=suv(ssu)\n ;//c.xyz=ssu\n ;mat3 n=mat3(p0,0,p1,0,p2,0)\n ;float ddd=0.\n ;float gpl=float(getPosLarge(ssu))\n\n ;vec3 oo=c2b(p3,p0,p1,p2,carthesianDet)\n ;vec3 tt=c2b(p4,p0,p1,p2,carthesianDet) //ray points transformed from carthesian to barycentric\n ;vec3 vs=oo-tt \n ;vec3 l=vec3(dd(p1-p2),dd(p2-p0),dd(p0-p1))//squared side length\n ;float radius=sqrt(lengthBary(oo-tt,l))//vector (oo-tt) length from barycentric vector\n //;vec3 vv=c2b(p4-p3,p0,p1,p2)\n ;float center=sqrt(lengthBary(oo-uu,l))//vector (oo-uu) length from barycentric vector\n ;c.w=min(c.w,abs(center-radius))//;c.w=min(c.w,abs(length(u-p3)-radius))\n //;c.w=min(h,ray(u,p3,p4)-.01)\n ;vec3 os=sat(floor(oo+1.))\n ;vec3 ts=sat(floor(tt+1.))//sat is needed for scale (large distances to the triangle are cheap)\n ;float ooo=suv(os)\n ;float ttt=suv(ts)//sum of vector components now points at 7 different segments:\n     //1* insideTriangle\n     //3* largeBorderTile(adjacent) \n     //3* cornerBorder   (only touches triangle corners) \n ;vec3 linesToCheck=vec3(0)\n ;if(ooo==2.//case 2: origin is in largeBorderTile\n ){if(ttt<2.&&os!=1.-ts)linesToCheck=vec3(0)\n  ;else{linesToCheck=getPosSmallV(os)//this one is simple, either misses all, or hits only one.\n      //nope nope nope,(vs) doesnt ALWAYS work HERE: \n      //but sure, there are other ways to do this, removed for now\n ;}}else if(ooo==1.){//case 1: origin is in cornerBorder\n  ;if(ttt<2.&&os!=ts)linesToCheck=vec3(0)//only the other 2 outer corners miss the triangle\n  ;else if(ttt==2.&&os!=1.-ts)linesToCheck=getPosSmallV(ts)//from cornerBorder to ADJACENT largeBorderTile, has 1 border\n      ;else{linesToCheck=1.-getPosLargeV(os);\n      ;if(1.-getPosLargeV(vs)!=linesToCheck)linesToCheck=vec3(0.)\n ;}}else //if(os==vec3(1) )//case 0: origin is in insideTriangle\n  {if(ttt==2.)linesToCheck=getPosSmallV(ts) //target is in any largeBorderTile /single border)\n  ;else linesToCheck=1.-getPosSmallV(vs)\n ;}\n /**/\n  \n ;if(linesToCheck.x>0.)c.y=min(c.y,segment(u,p1,p2)-.04)//indicating segments that are hit.\n ;if(linesToCheck.y>0.)c.y=min(c.y,segment(u,p2,p0)-.04)//indicating segments that are hit.\n ;if(linesToCheck.z>0.)c.y=min(c.y,segment(u,p1,p0)-.04)//indicating segments that are hit.\n\n //the faces that are still in may only return the NEAR intersection.\n //there is no case where there is a far intersection, the firt positive intersection can be returned as nearest.\n //i have not implemented a function that takes (linesToCheck), to trace this triangle/prism.   \n //on tracing a triangle/prism efficiently.\n //triangles imply barycentric coordinates, converters exist, but they are not too fast, and should be avoided.\n //just start in barycentric coordinates\n     //how about one moore domain, doing a 3d simplex (skewable triangle pyramid)\n\n //;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;//c.y=BezierQuadParabola(u,p0,p1,p2)           //green shows parabola\n ;m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;//c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;return c\n ;}\n\n//rotation of multiple inputs of same type for tpyes; vec4,vec3,vec2,float\n//rotate2by1(a,b) is a tripple swap\n#define rot2by1D(D) void rotate2by1(inout D a,inout D b){D s=a;a=b;b=s;}\n#define rot3by1D(D) void rotate3by1(inout D a,inout D b,inout D c){D s=a;a=b;b=c;c=s;}\n#define rot6by1D(D) void rotate6by1(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){D s=a;a=b;b=c;c=d;d=e;e=f;f=s;}\n#define rot4by2D(D) void rotate4by2(inout D a,inout D b,inout D c,inout D d                    ){rotate2by1(a,c  );rotate2by1(b,d  );}\n#define rot6by2D(D) void rotate6by2(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate3by1(a,c,e);rotate3by1(b,d,f);}\n#define rot6by3D(D) void rotate6by3(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate2by1(a,d);rotate2by1(b,e);rotate2by1(c,f);}\n#define rotND(a) a(v0)a(v1)a(v2)a(v3)\nrotND(rot2by1D)rotND(rot3by1D)rotND(rot6by1D)\nrotND(rot4by2D)rotND(rot6by2D)\nrotND(rot6by3D) \n\n#define hxl0(a,b) z=gLLxXP(a,b,o,t);if(sat(z)==z)return a-(a-b)*z\n#define hxl1(a,b) return a-(a-b)*gLLxXP(a,b,o,t)\n#define hxl2(a,b,c) float hxl0(a,b);hxl1(b,c)\n#define hxl3(a,b,c,d) float hxl0(a,b);hxl0(b,c);hxl1(d,c)\n    \nvec2 hxL1(vec3 a,vec3 b,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y)\n ,b.xy=b2c(b,X,Y)\n ;return a.xy-(a.xy-b.xy)*gLLxXP(a.xy,b.xy,o,t);}\n\nvec2 hxL2(vec3 a,vec3 b,vec3 c,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;return b.xy-(b.xy-c.xy)*gLLxXP(b.xy,c.xy,o,t);}\n\nvec2 hxL3(vec3 a,vec3 b,vec3 c,vec3 d,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;a.z=gLLxXP(b.xy,c.xy,o,t)\n ;if(sat(a.z)==a.z)return b.xy-(b.xy-c.xy)*a.z\n ;d.xy=b2c(d,X,Y)\n ;return c.xy-(c.xy-d.xy)*gLLxXP(c.xy,d.xy,o,t);}\n\n//X,Y set triangle of barycentric\n//all other params are in barycentric coords\n//origin,target,6CornersOfHex\nvec3  traceHexBaryInside(vec3 uu,vec3 oo,vec3 tt,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){vec2 o=b2c(oo,X,Y)\n ;vec2 t=b2c(tt,X,Y)\n ;vec2 p1=b2c(b1,X,Y)\n ;//vec2 p2=b2c(b2,X,Y)\n ;vec2 p3=b2c(b3,X,Y)\n ;vec2 p4=b2c(b4,X,Y)\n ;vec2 p5=b2c(b5,X,Y)\n ;vec2 p6=b2c(b6,X,Y)\n ;//return sat(floor(uu+1.)) //main triangle is white\n ;//r ia a vec4 with 1 of each color set to >0 foreach linesegment to test\n ;vec4 r=vec4(0)\n ;//uu=tt //for debug mode toggle\n //barycentric culling hell\n ;//if(uu.y<uu.z)uu.yz=uu.zy //mirror\n     \n ;if(\n     getPosSmall(floor(oo-tt))==2\n     //sign(oo.x)==sign(tt.x)\n    \n    )uu.yz=uu.zy\n ;if(uu.x<0.)r.x=1.\n ;if(uu.z>0.)r.x=1.\n ;if(uu.z<=0.&&uu.x<=1.)r.y=1.//right shade\n ;if(uu.x>0.){ \n  ;if(uu.x<1.)r.y=1.//horizontal\n  ;if(uu.y>1.)r.y=1.//right shade\n  ;if(uu.y>0.&&uu.y<1.)r.z=1.\n  ;if(uu.y<0.)r.w=1.\n  ;if(uu.z>uu.y-1.&&uu.z<uu.y+1.)r.w=1.\n  ;if(uu.x>1.&&uu.z<uu.y-1.)r.z=1.\n ;} \n ;return 1.-r.xyz //debug output a\n ;//return r.yzw //debug output a\n  ;//r=r.wxyz\n  ;float s=suv(r)     \n\n           /*\n  ;if(s==4.//if in main triangle, we have this small exclusion method\n \n  ){vec3 vs=getPos0V(floor(tt-oo))\n   ;//return vs\n       //.x points up   OR to the bottom corner\n       //.y boints side\n       //.z points down\n    //;r=vec4(0,0,0,1)\n    //;return hxL2(b3,b4,b5,o,t,X,Y).xyy\n    /*\n    ;if(vs.x==1.){\n        ;//return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n        ;                    r=vec4(1,1,0,0)\n        ;}\n   else if(vs.y==1.)return hxL3(b2b3,b4,b5,o,t,X,Y).xyy \n   ;else return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n   ;s=suv(r) \n  ;}\n/**/\n\n ;if(s==3.//test 3\n ){if(r.x==1.)return hxL3(b2,b1,b6,b5,o,t,X,Y).xyy//1110\n  ;           return hxL3(b1,b6,b5,b4,o,t,X,Y).xyy//0111\n ;}else if(s==2.//test 2\n ){if(r.x==1.)return hxL2(b2,b1,b6,o,t,X,Y).xyy//1100 b2,b1,b6\n  ;if(r.y==1.)return hxL2(b1,b6,b5,o,t,X,Y).xyy//0110 b1,b6,b5\n  ;           return hxL2(b6,b5,b4,o,t,X,Y).xyy//0011 b6,b5,b4\n ;}////test 1 \n ;s=suv(r.xy)\n ;if(s==1.\n ){if(r.x==1.)return hxL1(b2,b1,o,t,X,Y).xyy  //1000==b2,b1\n  ;           return hxL1(b1,b6,o,t,X,Y).xyy;}//0100==b1,b6\n ; if(r.z==1.)return hxL1(b6,b5,o,t,X,Y).xyy  //0010==b4,b5\n ;            return hxL1(b5,b4,o,t,X,Y).xyy;}//0001==b5,b4\n\n\nvec2 traceHexBaryOutside(vec3 o,vec3 t,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){return b2c(b1,X,Y)+vec2(.1)\n ;return vec2(.1,0);}\n\n//innerFrustrum() returns cakeslices, that cut trought (o) and all hex corners\n//no undefined cases via kerning-frustrums\nbool innF(vec2 u,vec2 o){return u.y*suv(o)>o.y*suv(u);}\nbool innS(vec2 u,vec2 o,vec2 a,vec2 b){return innF(u+a,o+a)||innF(o+b,u+b);}\nvec3 innerFrustrum(vec2 u,vec2 o//inputs are .yz of carthesian points\n){return vec3(ivec3(innS(u,o,vec2(0,-1),vec2( 0,1))\n                   ,innS(u,o,vec2(1, 0),vec2(-1,0))\n                  ,!innS(u,o,vec2(1,-1),vec2(-1,1))));}\n//110 top    center\n//010 top    right\n//011 bottom right\n//001 bottom center\n\n//return intersection of ray(ot) and barycentricHex (p0,p1,p2) (p0 is hex center)\nvec4 paintHexBary(vec2 u,vec2 o,vec2 t,vec2 p0,vec2 p1,vec2 p2\n){float cd=c2bdet(p0,p1,p2)\n ;vec4 c=vec4(1)     \n ;vec2 pro=p1-p0\n ;vec2 prt=p2-p0\n ;vec2 p3=p2-pro\n ;vec2 p4=p0-pro\n ;vec2 p5=p0-prt\n ;vec2 p6=p1-prt\n\n  //corners in barycentric (makes skew and flip simpler\n ;vec3 b0=vec3(1,0,0)\n ,b1=vec3(0,1,0)\n ,b2=vec3(0,0,1)\n ,b3=vec3(1,-1,1)\n ,b4=vec3(2,-1,0)\n ,b5=vec3(2,0,-1)\n ,b6=vec3(1,1,-1)\n     \n ;vec3 uu=c2b(u,p0,p1,p2,cd)//only for visualization\n ;vec3 oo=c2b(o,p0,p1,p2,cd)\n ;vec3 tt=c2b(t,p0,p1,p2,cd)\n ;float rotations=0.\n ;if(oo.x>1.){rotations=3.  //half rotation\n  ;uu=r36bary(uu-vec3(1,-1,0))\n  ;oo=r36bary(oo-vec3(1,-1,0))\n  ;tt=r36bary(tt-vec3(1,-1,0))\n ;}if(oo.y<0.){rotations++ //sixt rotation //rotate corner points by +1\n  ;uu=r16bary(uu-vec3(1,-1,0))\n  ;oo=r16bary(oo-vec3(1,-1,0))\n  ;tt=r16bary(tt-vec3(1,-1,0))\n ;}else if(oo.z<0.){rotations-- //negative sixt rotation //rotate corner points by -1\n  ;uu=r56bary(uu-vec3(0,1,-1))\n  ;oo=r56bary(oo-vec3(0,1,-1))\n  ;tt=r56bary(tt-vec3(0,1,-1));}//rotations range[-1..4]\n         \n ;if(rotations==-1.) rotate6by1(p6,p5,p4,p3,p2,p1)//reversed\n ;if(rotations== 4.) rotate6by2(p6,p5,p4,p3,p2,p1)//reversed \n ;if(rotations== 3.) rotate6by3(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 2.) rotate6by2(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 1.) rotate6by1(p1,p2,p3,p4,p5,p6)\n //;if(rotations==1.||rotations==3.||rotations==-1.){\n     //half of all cases are skewed the other way\n     //instead of flipping our shit, we just do pur pN in barycentric coordinates\n //;}\n ;vec3 vs=c2b(o,p0,p1,p2,cd)\n ;vec3 center=sat((floor(uu+vec3(0,1,1))))\n\n ;c.y=min(c.y,ray(u,o,t)-.005)//green ray\n ;c.y=min(c.y,abs(segment(u,o,t)-.02))//green ray segment\n\n //;o=b2c(oo,p0,p1,p2)\n //;t=b2c(tt,p0,p1,p2)\n\n ;float bariOdet=c2bdet(o,p1,p2)//triangle with o instead of p0\n ;vec3 baryO=c2b(t,o,p1,p2,bariOdet)//triangles bariOcentric coords\n ;vec2 sect=intersectB2c(o,t,p1,p2)\n     \n //;vec2 sect=p1-(p1-p2)*tt.z/(tt.z+tt.y)//projection of o on outer border (from center)\n     //;vec2 sect=(oo.z*(tt.z+tt.y)-tt.z*(oo.z+oo.y))\n ;//c.y=uu.z*(oo.z+oo.y)-oo.z*(uu.z+uu.y) // iahas a line from corner to point\n      \n ;//return mix(c,floor(1.-vec4(frustrumX,frustrumY,frustrumZ,0)),.5)\n     \n ;//c.y=min(c.y,abs(sqrt(dd(u-sect))-.02))//intersection fail\n  \n;if(tt.z*(oo.z+oo.y)>oo.z*(tt.z+tt.y) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.z*(oo.z+oo.x)>oo.z*(tt.z+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.y*(oo.y+oo.x)>oo.y*(tt.y+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n\n //tt.y>oo.y//tt.z>tt.y//mirror symmetry on the whole thing\n ){uu.zy=uu.yz\n  ;oo.zy=oo.yz\n  ;tt.zy=tt.yz\n  ;rotate6by3(p1,p3,p5,p2,p6,p4)//strided half rotation == mirror\n  ;\n  ;}  \n/**/\n     \n  ;//projecting 2 points onto the axis is warely worth it\n  ;//, only where we have 2 caes to check and within some other constrrains\n  ;//p2=p1+(p2-p1)*.5\n  ;//p4=p5+(p4-p5)*.5\n     \n ;c.z=min(c.z,abs(length(u-p0)-.03))\n ;c.z=min(c.z,abs(length(u-p1)-.05))//blue circles\n ;c.z=min(c.z,abs(length(u-p2)-.07))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p3)-.08))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p4)-.09))//to distinguish inputs (handedness)\n ;c.w=min(c.w,abs(length(u-p5)-.09 ))//to distinguish inputs (handedness)\n     \n ;vec3 X=vec3(p0.x,p1.x,p2.x)\n ;vec3 Y=vec3(p0.y,p1.y,p2.y)\n ;p1=b2c(b1,X,Y)    \n ;p2=b2c(b2,X,Y)    \n ;p3=b2c(b3,X,Y)   \n ;p4=b2c(b4,X,Y)  \n ;p5=b2c(b5,X,Y)  \n ;p6=b2c(b6,X,Y)  //testing bN \n ;c.x=min(c.x,segment(u,p2,p1))\n ;c.x=min(c.x,segment(u,p3,p2))\n ;c.x=min(c.x,segment(u,p4,p3))\n ;c.x=min(c.x,segment(u,p5,p4))\n ;c.x=min(c.x,segment(u,p6,p5))\n ;c.x=min(c.x,segment(u,p1,p6))//red hexagon\n ;c.z=min(c.z,segment(u,p0,p1))\n ;c.z=min(c.z,segment(u,p0,p2))\n ;c.z=min(c.z,segment(u,p1,p2))//blue triangle (indicates pieslice or (o)\n     \n\n     \n ;//all mirroring and showing of it is done; \n ;//all casting pout of the target is done\n     \n ;float outU=min(floor(mav(abs(vec3(1,0,0)-uu))),1.)\n ;float outO=min(floor(mav(abs(vec3(1,0,0)-oo))),1.)\n     \n\n ;vec2 intersection=vec2(0)\n ;//if(outO>0.)intersection=traceHexBaryOutside(oo,tt,b1,b2,b3,b4,b5,b6,X,Y)\n ;//else       intersection=traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y).xy\n    \n \n ;c.w=min(c.w,abs(abs(length(u-intersection)-.03)-.01))//mark intersections\n \n ;c=smoothstep(.01,-.01,c)-.01\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n\n ;vec3 cake=(floor(uu)+vec3(0,1,1))\n ;cake=sat(floor(cake))\n ;//c.xyz=cake\n ;//if(cake.x>0.&&cake.y>0.)c.xyz=cake\n ;//if(cake.x>0.&&cake.y==0.)c.xyz=cake\n ;//c.xyz=mix(c.xyz,sat(cake-vec3(outU*.7)),.5)//inside\n  \n ;//c.xyz+=sat(floor(uu+1.))//upper triangle is white\n ;//c.xyz+=suv(sat(floor(uu+1.)))*.33//upper triangle is white 4sect\n                   /*\n ;//c.xyz+=sat(floor(uu+vec3(-1,1,1)))*.4 //opposing triangle is black\n ;//c.xyz+=suv(sat(floor(uu+vec3(-1,1,1))))*.5//opposing trianggle 4sected\n ;//c.xyz+=sat(floor(uu+1.))*.4 //upper triangle is white\n ;float sect4low=suv(sat(floor(uu+vec3(-1,1,1))))\n ;//float alowerT=suv(sat(floor(uu+vec3(-1,1,1))))\n  //;c*=alowerT  \n ;float uIsInside=mav(abs(uu-vec3(1,0,0)))\n ;float aa=suv(sat(floor(uu+vec3(0,1,1))))\n ;float needsPush=float(aa<1.||uIsInside>1.)//bool(inT))\n   /**/\n ;//float isSimple=float(suv(sat(floor(uu+vec3(-1,1,1))))==0.||mav(abs(uu-vec3(1,0,0)))>1.)//bool(inT))\n ;//c.xyz=mix(c.xyz,vec3(isSimple),.5)  \n     /**/\n ;//branching case wether oo is outside or inside \n  \n ;//c.xyz=mix(c.xyz,traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y),5.)//to debug oo is uu\n ;vec3 fuck=innerFrustrum(uu.yz,oo.yz)\n ;c.xyz=mix(c.xyz,fuck,.5)\n     \n  \n ;return c;}\n\nbvec3 getFustrumTri(vec3 tt,vec3 oo\n){bvec3 i=bvec3(false)//3 fustrums over 3 lineSegments, each in 2 signs.\n ;if(sign(oo.x)<0.)i.x=innS(tt.yz,oo.yz,vec2(0,-1),vec2(-1,0))     \n ;else             i.x=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,-1))\n ;if(sign(oo.y)<0.)i.y=innS(tt.yz,oo.yz,vec2(0,0),vec2(0,-1))  \n ;else             i.y=innS(tt.yz,oo.yz,vec2(0,-1),vec2(0,0))\n ;if(sign(oo.z)<0.)i.z=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,0))       \n ;else             i.z=innS(tt.yz,oo.yz,vec2(0,0),vec2(-1,0))\n ;return not(i);}\n\nvec3 traceTriangle(vec2 u,vec2 o,vec2 t,vec2 a,vec2 b,vec2 c\n){vec4 r=vec4(1)\n ;r.x=min(r.x,segment(u,a,b))\n ;r.x=min(r.x,segment(u,b,c))\n ;r.x=min(r.x,segment(u,c,a))\n ;r.y=min(r.y,ray(u,o,t))//show ray and triangle\n ;vec3 uu=c2b(u,a,b,c)//for fustrum visualization\n ;vec3 oo=c2b(o,a,b,c)\n ;vec3 tt=c2b(t,a,b,c) \n ;bvec3 i=getFustrumTri(tt,oo)\n ;if(!any(lessThan(oo,vec3(0)))//o is in triangle ->one intersection, zNear is o\n ){vec2 hit=vec2(0)\n  ;     if(i.x)hit=inB2c2N(o,t,c,b)\n  ;else if(i.y)hit=inB2c2N(o,t,c,a)\n  ;else        hit=inB2c2N(o,t,a,b)\n  ;r.w=min(r.w,segment(u,o,hit)-.01)//visualize      intersections\n  ;r.w=min(r.w,segment(u,o,o)-.03)  //visualize near intersection (origin)\n ;}else{//we miss all OR 12 segments\n  ;vec2 hit0=vec2(0),hit1=vec2(0)     \n  ;vec3 g=vec3(i)\n  ;if(suv(g)<2.){hit0=o;hit1=o\n ;}else if(!i.x){hit0=inB2c2N(o,t,a,b);hit1=inB2c2N(o,t,c,a);if(oo.y<0.)rotate2by1(hit0,hit1)\n ;}else if(!i.y){hit0=inB2c2N(o,t,c,b);hit1=inB2c2N(o,t,a,b);if(oo.z<0.)rotate2by1(hit0,hit1)\n ;}else         {hit0=inB2c2N(o,t,c,a);hit1=inB2c2N(o,t,c,b);if(oo.x<0.)rotate2by1(hit0,hit1)\n ;}r.w=min(r.w,segment(u,hit0,hit1)-.01);//visualize     intersections\n  ;r.w=min(r.w,segment(u,hit0,hit0)-.03);//visualize far intersection\n ;}\n ;//compose visualizations\n ;r=smoothstep(.005,-.005,r)-.01 //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;r=pdOver(pdOver(v3(1,0,0,1)*r.x,v3(0,1,0,1)*r.y)\n          ,pdOver(v3(0,0,1,1)*r.z,v3(1,1,0,1)*r.w))\n ;r.xyz+=vec3(i)*.3\n //below visualizates fustrums\n ;i=getFustrumTri(uu,oo)\n ;r.xyz+=vec3(i)*.3\n ;return r.xyz;}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;v1 p3\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;//c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n ;v1 p4\n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;//c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,vec2(0),vec2(0))\n\n ;c.y=1.\n ;c.z=1.\n   \n\n ;//c=baryTriangle(t,u,r,m,p3,p4,p0,p1,p2,c) //trace triangle barycentric\n ;//vec2 p=TraceHexInsideBary(u,p3,p4,p0,p1,p2)\n ;//c.y=min(c.y,segment(u,p,p)-.05)\n \n\n  \n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;vec3 j=vec3(fract(abs(p1.x*2.)),1./7.,1./6.)\n \n ;c=paintHexBary(u,p3,p4,p0,p1,p2)\n \n     /*\n ;u*=3.\n ;p4*=4.\n ;p4.y=-p4.y\n ;p2*=2.\n ;//p3*=sign(-p4)\n  ;if(mav(abs(u))<.75){\n         ; c.xyz+=.5*(simplexRotD(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   ;//c.y  +=.5*(simplexRot(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   //above 2 have periodic tiling.xy, below not:\n   ;//c.xyz+=.5*((simplexRotD(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n   ;//c.y  +=.5*((simplexRot(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n }else if(u.x<0.\n ){vec2 cel\n  ;if(u.y>0.)cel=cellular(     u/p3.xy      +     p4.xy      ,j)\n  ;else      cel=cellular(vec3(u/p3.xy,p2.x)+vec3(p4.xy,p2.y),j) \n  ;//c.x=snoise(u/p3.xy*2.+p4.xy*9.)*.5+.5;\n  ;c.xy+=cel.xy*.6\n ;}else{\n  ;if(u.y>0.\n  ){     c.y+=.6*(snoise(     u/p3.xy+p4           )*.5+.5)\n  ;}else c.y+=.6*(snoise(vec3(u/p3.xy+p4,p2.x+p2.y))*.5+.5)\n\n ;}/**/\n ;c.xyz=traceTriangle(u,p3,p4,p0,p1,p2)\n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point (p0) on line (l0,l1)\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n     //fuck it erased a line here, dumb UI\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\n\n//https://www.shadertoy.com/view/XlVfz1\n//simplified version by iq, modified by ollj (signs,deferredSqrt,subroutines)\n//uv,radii,distanceBetweenCentersSigns\nfloat crescent2(vec2 u,vec3 r//uv.xy,radius,radius,distance\n){vec2 s=sign(r.xy);r=abs(r);//extract sign and abs distance\n ;float g=u2(step(0.,suv(s)))//sign modifier makes outside positive (more user friendly derivative)\n ;vec4 t=vec4(r,cci(r))\n ;if(t.w<t.x\n ){u.y=abs(u.y);r.x=sqrt(ccis(t.xw));r.y=u.y*t.w-u.x*r.x\n  //OR *-t.z in the condition, for something nice and different\n  ;if(mi(s*abmb((u.y-r.x)*t.z,r.y))*t.z>0.)return length(u-vec2(t.w,r.x))*g;}\n  ;u=(sqrt(vec2(dd(u),dd(u-vec2(t.z,0))))-t.xy)\n  ;return mav(u*s)*g;}\n\n\nvec4 demoCrescent(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(0)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;//v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v1 p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;v1 p1=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;v1 p2=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;v1 p3=fra(t,bufDrag(+3.).xy,r,m)*viewzoom\n ;\n ;v1 p4=abs(p0*v1(1,0))//for symmetry\n ;c.z=min(segment(u,p0,p4),segment(u,p2,vec2(0)))//fix Centers\n ;v1 s=sqrt(v1(dd(p4-p1),dd(-p3))) //2 radii\n ;c.x=length(u-p4)-s.x\n ;c.y=length(u   )-s.y\n ;  \n ;v0 d=p4.x\n ;float swap=-1.//to swap the offset option or not\n ;if(sign(p0.y)>0.&&sign(p2.y)<0.)swap=1.\n ;v1 signs=v1(sign(p2.y),sign(p0.y))\n ;c.w=crescent2(u,vec3(s.yx*signs,d))+(length(p2)-s.y)*swap\n ;v0 b=c.w\n ;c=abs(c)-.01 \n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;c.z*=4.//nehanche blue\n ;c.xy+=fract(b*16.)*.3\n ;c.xy+=.2-(sign(b)*.5+.5)*.2//brighten negative distance\n ;c=sat(c)\n ;return c\n ;}\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){//o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;//else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;//else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;o=demoCrescent(iTime,u,iResolution,iMouse);\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=sat(o)\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n\n//below code is: RE7 [[BayesianEpsilon targetFPS] [Image]]\n//iRe refers to the ichannel buffer locale of [relativistic camera movement]\n//the type of camera mkovement where [time slows down, reciprocal to the speed of light].\n//that is, reaching the speed of light is impossible, because that halts the speed of time.\n//and any 2 observers with no relative movement hate time between them pass with the speedOfLight.\n\n#define iRe iChannel2\n\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float i){return GetMaterialsColor(r,int(i));}\n\n//lod,ray,start,zFar\nvoid MarchLight(float sscoc,inout Ray r, float startTime, float f//relkativistic raymarcher\n){float acc = 0.\n ;float eps=getEpsToFps(sscoc)\n ;float lip=getReLipschitzToFps(sscoc)\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist=map(r.b,-1)\n  ;acc+=r.dist*lip\n  ;r.b+=r.dir*(r.dist)\n  ;if(abs(r.dist)<eps||acc>f)break;}}\n\nvoid MarchPOV(inout Ray r, float startTime,float sscoc\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])\n  //;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  // t' = Y(t-v*(x/Y)/c)\n  // t' = Y(0-v*(x/Y)/c)\n  // t' = Y(v*x/Y)/c\n  // t' = vx/c\n  ;r.time = startTime\n  ;r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection=(objPos[oBlackHole]-r.b)\n  ;r.dir+=(1./RayPrecision)*r.dist*reciprocalLipschitz\n      *normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<getEpsToFps(sscoc))break\n  ;r.b+= (1./RayPrecision)*(r.dist)*reciprocalLipschitz*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\n\nvec3 accHalo(vec3 oliPos,vec3 lightRelVel,float halo,vec3 lightColor){\n  ;vec3 camLightDir=normalize(oliPos-pos)\n  ;float cds=dot(camLightDir,dpos)//camDirCamSpeed \n  ;float cdl=dot(camLightDir,lightRelVel)//camDirLightSpeed\n  ;return halo*dsf(lightColor,(cSpe/(cSpe\n                      \n                                         \n     -(cds-cdl)/(1.-(cds*cdl/(cSpe*cSpe)))//haloRel\n                                         *dopplerF))*lorentzF)\n;}\n\nvec3 GetDiffuse(float sscoc, Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;//if(mat==8.)return vec3(0)//black holes are just black\n ;vec3 objVel=objVel[rayObj]\n ;vec3 lHalo =vec3(0)\n ;float[numLights] halos\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0;i<10;i++\n  ){lightLate=cLag*length(oliPos[L]-r.b)/cSpe;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos=          oliPos[L]-r.b\n  ;ProcessLightValue(r.time-lightLate+.01)\n  ;vec3  lightVel   =((oliPos[L]-r.b)-lightRelPos)/.01\n  ;vec3  lightRelVel=lightVel-objVel\n  ;float lightLorentzF   =LorentzFactor(length(lightVel))\n  ;vec3 lightDir   =normalize(lightRelPos)\n  ;vec3 camDir     =normalize(pos-r.b)\n  ;vec3 camRelVel  =dpos-objVel\n  //;float halo            =halos[L]\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   #define basicBug \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif    \n  #endif\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(sscoc,shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4\n  #ifdef redshiftdT\n  ;SetTime(r.time)\n  ;float speed=map(r.b,int(mat))\n  ;SetTime(r.time+.01)//1/100 time delta\n  ;speed-=map(r.b,int(mat))//now is propper differential\n  ;speed*=100.//scale by 100\n  //blackholes are tinted in Re0 wven without this bracket.\n  #else\n  ;float speed=0.\n  #endif\n  ;//speed += LorentzFactor(cSpe)//commented out in the original\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;vec3 lightColor =          oliCol[L].rgb \n  ;lorentzF/=mix(lorentzF,lightLorentzF,relativisticDoppler)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;cDiff+=     dsf(lightColor*matCol*atten,(cSpe/(cSpe-speed  *dopplerF))*lorentzF)\n  ;if(mat==8.)lHalo+=halos[L]//black holes suck upp all ambient and skipp dopplerShoift\n  ;else       lHalo+=accHalo(oliPos[L],lightRelVel,halos[L],lightColor)\n  ;}\n  ;if(mat==8.)return lHalo+vma2\n  ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n\nvec3 GetSampleColor(float sscoc,vec2 uv\n){Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]\n ;r.dir = qr(objRot[oCam],r.dir)\n ;MarchPOV(r,playerTime,sscoc)\n ;return GetDiffuse(sscoc,r);}\n\nvec4 mainImageRe8(vec4 o, in vec2 u\n){//vec2 u=fra(uv,iResolution)//(uv/iResolution.xy+.5)/iResolution.y\n ;float sscoc=length(u/iResolution.xy-.5) //length(u/iResolution.xy*+.5)/sqrt(2.)\n ;sscoc=smoothstep(.75,0.,sscoc)//full btight in the center, pitch black at the cotner, oval\n ;vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;float edit=Get(ReEdit).x\n ;if(edit>0.//if in edit mode\n ){if(length(abs(v)-.5)-.02<0.)return vec4(1)//circles filled\n ;}\n ;vec4 timE=Get(ReTimE)\n ;if(timE.w<0.&&abs(length(abs(v)-.5)-.03)-.003<0.)return vec4(1)//circles rings\n ;\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime=abs(timE.w)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;oCamSet(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(sscoc,v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iRe,u/iResolution.xy).rgba )//debug buffer of iRe\n ;return o;}\n\n/*\nbuffa buffers many params for diegeticUI\nbuffc buffers params for a relativistic camera\n\ni want a 3d UI, but\n- i can only rotate the head while left dragging\n- double klicking may get you out of the canvas\n\n- nomode solution, not good for direct feedback\nonMouseRelease; buffer the objectID of the object where mouse was released\ninKeyPresss: object properties of buffered objectID may change\n\n- editMode\nonKeypress, may toggle to editmode\nin editmode, mouse drag no longer moves camera\n\nonKeypress, may toggle to timeFreezesMode\n\n\ntime freeze and edit mode work in re8, but nothing is being edited\n*/\n\n\n//below is a very basic toggle-wrapper, showing what 2 shaders have been hodgepodged\n//this completes step2, fixing all namespace conflicts. (was easy for once)\n//step 2 is to clean up mainImageRe7() and its subroutines. - done re8()\n//step 3 is trckier\n//all these buffers store properties, an array of vec4 \n//and I need them to evade any conflict between them\n//so I can merge thzem into a single buffer\n//- (lets exclude BufferD for being a screenspace incrementalAveraging buffer)\n\n\n#define Scene2D\n\n//#if 1\nvec4 mainImageUI2AD37(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n//   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n//   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n//   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n//   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n//   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n//   ;o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n ;return o;}\n/**/\n//#else\n/*\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}*/\n//#endif\n/**/\n\nvec4 spin(vec4 o,vec2 u\n){vec2 v=fra(iTime,u,iResolution,iMouse)\n ;o=vec4(0)\n   \n    \n ;//o=pdOver(iDiegeticUIshow(u),o)//ui dots\n ;//o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n ;v*=rot2D(u5(cos(iTime/9.)*99.))\n ;if(v.x>0.){if(v.y>.0){\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;//o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n   ;return o;\n   ;}\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n  ;//o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  ;return o\n  ;}\n ;if(v.y>0.){\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d drawing\n  ;return o\n ;}\n ;return o\n //;return mainImageRe8(o,u)\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){\n /*vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;//o=mainImage2(o,i)\n     ;return;//number overlay\n ;}*/\n \n //;o=spin(o,u)\n    \n #if 1\n ;o=mainImageUI2AD37(o,u)\n #else\n ;o=mainImageRe8(o,u)\n #endif\n //;o=(texture(iRe,u/iResolution.xy).rgba );\n/**/\n ;}\n\n\n/*\nI like my code modular, evading namespace conflicts, while having short namespaces.\nI heavily advocate for compatibility, performance and diegetic UI.\nIO see this ignored too often\nThe acronym \"ReTrAdUi\" makes fun of bad UI design, namespaces and typos.\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n#define phi (sqrt(5.)*.5+.5)\n\n#define tiny .00001\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n//#define u2(a) su(mu(a,2.), 1.)\n#define u3(a) su(mu(a,2.),-1.)\n//#define u5(a) su(mu(a,.5),.5)\n#define u5cos(a) (u5(cos(a))\n//below is needed for old code, that i failed to update so that su() and mu() work on the right inpout types.\n#define u5cos2(a) ((cos(a))*.5+.5)\n//#define cosu5(a) u5(co(a))\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n/**///--start: iDiegeticUI v2:\n/*\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n/**/\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a) (-(miv(-(a))))\nconst vec3 vs=vec3(-1,0,1);\nv1 perp(v1 a){return a.yx*vs.xz;}\nv1 perp2(v1 a,v1 b){return vec2(a.x*b.y,-a.y*b.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\nv0 perpdot(v1 a,v1 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//v0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n\n/*\nrelativistic engine, with mutable/slower speedOfLight\n\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\n\nDoes not simulate doppler correctly\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- objects changing in size may not doppler its light bounces correctly?\n\nblatantly false shadows&gravity\n- no gravity by object masses (camera does not orbit)\n- shadows are unaffected by mass (except for black hole)\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow?\n- object rotations may result in faster than light speeds of object vertex?\n\n\n/**/\n\n\n/**///--start: RelativityEngineParams\n\n//ESDF keyboard layout is tmore compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//above for movement\n//below toggles pausing of time\n#define KEY_T 84.5\n//below toggles grabEdit mode (mouse no longer rotates camera)\n#define KEY_G 71.5\n\n//fishEyeCam sucks\n#define fishEye false\n//FieldOfView 1.57 = 90deg\n#define FOV 1.57\n//take relative velocity of photons to camera & distort field of view\n#define FOVAberrationOfLight 1.\n\n//SpeedOfLight in m/s divides by /(cSpe*cSpe), so do not make it too large!\n#define cSpe 2.5\n//do not go over speed of light it breaks time & space\n#define maxSpeed (cSpe*2.2/2.5)\n//camera acceleration =24.\n#define thrustForce (cSpe*5./2.5)\n//known bug, bouncing off something too easily accellerates you faster than light\n//iff the speed of light is high\n//for no good reason, any bounce accellerates me without constrain\n\n//PhotonLatency [0..1]; 0.=instant vision\n#define cLag 1.\n//simultaneouity==1 to pretend that simultaneouity exists\n//Then you could see the future in front of you at high speeds.\n//r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n#define simultaneouity 1.\n\n//take player/object/light vel to shift color\n#define dopplerF .5\n//take light source speed into account and their own time dilation\n#define relativisticDoppler .2\n//shrink map along velocity vector at high speed\n#define LgthContraction  1.\n//speed map frame time at high speed\n#define TimeDilation 1.\n\n//do +1 FAST (objectID-filtered) march measure how much a hit surface moves towards camera\n//important for realistic redshift, but only adffects diffuse.\n#define redshiftdT\n//higher rayprecision makes glow more bloomy, WHYYY\n#define RayPrecision 1.\n//repeatDoppler==1 seems nonsensical (just tints all in pink)\n#define repeatDoppler 0\n\n#define MaxRayDist 9.0\n\n//set by world\n#define numMats 7\n\n//black hole mass \n#define BlackHoleMassFactor 2.\n//.*cSpe)\n#define AccretionDisk 2.\n\n#define gravity vec3(0.,0.,0.)\n//end of relativity params\n\n/**///--end__: RelativityEngineParams\n\n//do not modify:\n#define pi acos(-1.)\n#define vec1 float\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n\n//#define fra(u,r) (u-.5*r.xy) /r.y\n\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos  = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n/**///--end__: iDiegeticUI v2:\n/**///--\n/**///--start: iChannel-Buffer-pattern\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**///--end__: iChannel-Buffer-pattern\n/**///--\n/**///--start: compatibilityCore \n\n\n/*\ntodo, all the trigonometry functions with glES100 to gles300 porting\nseems to be prettyx fine\n*/\n\n\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\n\n\n//every 2d determinant has a perpendicular dotproduct\n\n//nul function is needed for cases, where the same function is defined 2 times\n//eg: once with sat and once without sat (with nul instead of with sat) => difference between segment() and line()\n#define nUl(b) b nul(b a){return a;}\nnUl(v0)\nnUl(v1)\nnUl(v2)\nnUl(v3)\n    \n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\n\n/**///--end__: compatibilityCore\n/**///--\n/**///--start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created #.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**///--end__: openGl NaN-precision\n/**///--\n/**///--start: AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt=+2th derivative (and dt)\n[d***]dt=+3th derivative (and dt adnd dt)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n\nstruct d(v0 a;);//just use v0 instead of a [d]  struct\nthe whole DA set is pretty consistent, and i tried domain/ds the other way around and that sucked.\nthe first value is a float, because thats what the function returns, a length.\nAND most shapes apply the same functions to a value (no branching, all domains are NOT independent functionWise)\nbut many functions over 2d or 3d should be independent, and can be branching!\n...as a result, the d*** structs are nonsense, and i may need a BIG rewrite.\n\nso, what we may utilize here (to format an UV.xyz to give to any distanceField) is something like:\nc22 da_domain2(v2 p){return c22\n (d22(p.x,v2(1,0,0),v2(1,0,0))\n ,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n ,d22(p.y,v2(0,0,1),v2(0,0,1)));}\n//so the c22 struct first seperates by number of domains, seperating into 3 sub scructs, one foreach domain.\n//each derivative VECTOR has as many domains as the whole struct.\n//i actually wonder, WHY this is not always a type float.\n*/\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt,dt \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt,dt \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt,dt \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt,dt\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00   D00(v2   a){return d00(a.x,a.y,a.z);}\nv2     V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0     D0(v1   a){return d0(a.x,a.y);}\nv1     V1(d00  a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\n//the c* structs are used by the uv inputs, c2 is for 3d, with 1 derivative\n//a distance field is itterated over by: DAMValue s=df(da_domain1(o+i*t))\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt\nST c000{d000 x                     ;};//1 domains t,dtdt \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dtdt \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dtdt  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt,dt  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//the weirdness, that the first value is always a float, is based on the output of the function, with a scalar distance\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\n//v2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\n//the da_domain*() functions orhtogonally proiject the derivatives onto an matrix.\n//the inpput point o is spread among as many d*** structs as there are domains.\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.z,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0 da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n\n/**///--end__: AD structure\n/**///--\n/**///--start: AD functions \n\n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\n//AD uses these prexisNotation Namespaces and is defined for these domains):\n//[d0..d333] means, it is defined for up..3 derivatives over up..4 domains (but also any lesser permutation)\n//[c...] are some extended struct special cases (higher dimensional)\n//\n//ne()       0-a ,[d0..d333], also [c0..c333]\n//fl() floor(a  ),[d0..d333]\n//fr() fract(a  ),[d0..d333] <= su(1.,fl(a))==mod(a,1.) //complement..floor()\n//mo()   mod(a,b),[d0..d333] <= su(a,mu(b,fl(di(a,b)))) (true_basis_modulo)\n//si()   sin(a  ),[d0..d333]\n//co()   cos(a  ),[d0..d333]\n//ex()   exp(a  ),[d0..d333] //inverse of log()\n//ln()   log(a  ),[d0..d333]\n//sg()  sign(a  ),[d0..d333]\n//ab()   abs(a  ),[d0..d333],[c2]\n//su()        a-b,[d0..d333],[c0..c3]\n//ad()        a+b,[d0..d333],[c0..c3] <== su(a,ne(b))\n//mu()        a*b,[d0..d333],[c0..c3]\n//di()        a/b,[d0..d333]\n//po()   pow(a,b),[d0..d333] <= ex(mu(ln(x),x))\n//mi()   min(a,b),[d0..d333],[c2]\n//sr()  sqrt(a  ),[d0..d333]\n//p2()   pow(a,2),[d0..d333],[c0..c2] <=mu(a,a)\n//p3()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),a)\n//p4()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),mu(a,a))  //because for AD, mu() recursion is faster than pow(a,b)\n//dt()   dot(a,b),[d0..d333],[c0..c3] <=ad(mu(),mu()...)\n//dd()   dot(a,a),[d0..d333],[c0..c3] <= dt(a,a)\n//sd()  length(a),[d0..d333] <=po(dd(a),1./2.) == sq(dd(a))\n//cd()           , <=po(dd(a),1./3.)\n//qd()           , <=po(dd(a),1./4.)   \n//ud()           , <=po(dd(a),1./5.)\n//ata()          ,[d0..d333]\n//cl()  clamp()               <=mi(ma(a.,0.),1.)\n//st()   sat()                <=clamp(a.,0.,1.)\n//suab()         , [d0..d333] <=ab(sub(a))\n//\n//ab derivatives may be false/naive (3rd derivative is most likely nonsense)\n/**/\n\n//max(a,b)=-min(-a,-b), requires ne()\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n\n//floor(a) is a basis-function for mod() and fract() (all complement each other)\n//calculus on floor() is simpler than on fract() or mod() , so we defien fract() as 1.-floor(), and not as mod(a,1.)\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies automaticDiffernetiation (and it fixes mod())\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to multiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n//mod(a,1.) NEVER returns 1 (its a halfopen interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\nd00 AD(d00 a,v2 o){v0 O=a.c*o.x\n ;return D00(o.xyy*v2(1.,a.b,a.c)\n +v2(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\nv3 siD(v0 a){return v3(si(a),co(a),-si(a),-co(a));}//because derivatives of cin/cos have a periodicity of 4 derivatives,\nv2 siD2(v0 a){return v2(si(a),co(a),-si(a));}      //but we may also want just 2 derivatives (+base)\n\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\nd00 si(d00 a){return AD(a,siD2(a.a));}//sin()dxdxdx\nd00 co(d00 a){return AD(a,siD2(a.a).yzx);}//cos()dxdxdx\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\n\nd11 si(d11 a){d00 Omg(si,x);d00 Omg(si,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 si(d22 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 si(d33 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z);d00 Omg(si,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 si(d111 a){d000 OMg(si,x);d000 OMg(si,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 si(d333 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z);d000 OMg(si,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd11 co(d11 a){d00 Omg(co,x);d00 Omg(co,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 co(d22 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 co(d33 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z);d00 Omg(co,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 co(d111 a){d000 OMg(co,x);d000 OMg(co,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 co(d222 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 co(d333 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z);d000 OMg(co,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//once more a clear sign of my structure extending poorly HERE\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n\n\n//single parameter operations are MUCH simpler here:\n\n//ex(d000) seems to be fine\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n//ex(d00) seems to be fine\nd00  ex(d00  a){return d00 (ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c);}//(tripple) productRule\nd000 ex(d000 a){return d000(ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}//3rd derivative\nd11 ex(d11 a){d00 Omg(ex,x);d00 Omg(ex,y)              ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);d00 Omg(ex,w)\n    ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ln seems to be fine\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd00 ln(d00 a){return d00(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtdt\nd000 ln(d000 a){return d000(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtdt\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))/(a.a*a.a*a.a*a.a)//dtdtdt\n //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() is a special case of di() == one antiderivative higher.\nd1 ln(d1 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));return d1(x.a,v1(x.b,y.b));}\nd2 ln(d2 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z))\n ;return d2(x.a,v2(x.b,y.b,z.b));}\nd3 ln(d3 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z));d0 w=ln(d0(a.a,a.b.z))\n ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd11 ln(d11 a){d00 Omg(ln,x);d00 Omg(ln,y)              ;return d11(x.a,v1(x.b,y.b)    ,v1(x.c,y.c));}\nd22 ln(d22 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ln(d33 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);d00 Omg(ln,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//sg() seems to be fine\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\nd1 sg(d1 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;return d1(x.a,v1(x.b,y.b));}\nd2 sg(d2 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))\n   ;return d2(x.a,v2(x.b,y.b,z.b));}//this one is needed by sdUnterprim()\nd3 sg(d3 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z));d0 w=sg(d0(a.a,a.b.z))\n   ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd11 sg(d11 a){d00 Omg(sg,x);d00 Omg(sg,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 sg(d22 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 sg(d33 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z);d00 Omg(sg,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ab() 3rd derivative seems nonsensical, to check through!\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}//i am a bit suspicious about the derivatives here,not sure if it is THAT simple.\nd11 ab(d11 a){d00 Omg(ab,x);d00 Omg(ab,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ab(d22 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ab(d33 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z);d00 Omg(ab,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nc0   ab(c0   a){return c0  (ab(a.x));}\nc00  ab(c00  a){return c00 (ab(a.x));}\nc000 ab(c000 a){return c000(ab(a.x));}\nc1   ab(c1   a){return c1  (ab(a.x),ab(a.y));}\nc11  ab(c11  a){return c11 (ab(a.x),ab(a.y));}\nc111 ab(c111 a){return c111(ab(a.x),ab(a.y));}\nc2   ab(c2   a){return c2  (ab(a.x),ab(a.y),ab(a.z));}\nc22  ab(c22  a){return c22 (ab(a.x),ab(a.y),ab(a.z));}\nc222 ab(c222 a){return c222(ab(a.x),ab(a.y),ab(a.z));}\nc3   ab(c3   a){return c3  (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc33  ab(c33  a){return c33 (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc333 ab(c333 a){return c333(ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n//su() ad() seem to be fine\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\n#define oMg(f,x) f(d00(a.a,a.b.x,a.c.x),d00(b.a,b.b.x,b.c.x))\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)\nv0 su(v0 a,v0 sux\n//v1 su(v1 a,v0 sux\n//v1 su(v0 a,v1 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\nd00 su(d00 a,d00 b){return d00(a.a-b.a,a.b-b.b,a.c-b.c);}\nd11 su(d11 a,d11 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd22 su(d22 a,d22 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd33 su(d33 a,d33 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z);d00 wa=oMg(su,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt,dt\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd333 su(d333 a,d333 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z);d000 wa=omG(su,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\n      \nd33 su(d33 p,v3 s){return su(p,d33(s.x,v3(0),v3(0)));}\nd22 su(d22 p,v2 s){return su(p,d22(s.x,v2(0),v2(0)));}\nd11 su(d11 p,v1 s){return su(p,d11(s.x,v1(0),v1(0)));}\nd00 su(d00 p,v0 s){return su(p,d00(s  ,v0(0),v0(0)));}//this seems VERY nonsensical, to only store .x\n\nd33 su(d33 p,v0 s){return su(p,d33(s,v3(0),v3(0)));}\nd22 su(d22 p,v0 s){return su(p,d22(s,v2(0),v2(0)));}\nd11 su(d11 p,v0 s){return su(p,d11(s,v1(0),v1(0)));}\n      \n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\n\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd3 mu(d3 a,v0 b){return d3(atb\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nd00  mu(d00  a,d00  b){return d00 (a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b);}//dxdx\nd000 mu(d000 a,d000 b){return d000(a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b//dxdx\n,a.c*b.b+a.b*b.c+a.b*b.c+a.a*b.d+a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c);}//dxdxdx\nd11 mu(d11 a,d11 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mu(d22 a,d22 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mu(d33 a,d33 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z);d00 wa=oMg(mu,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mu(d333 a,d333 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z);d000 wa=omG(mu,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}    \nd00  mu(d00  a,v0 b){return mu(a,d00 (b,0.,0.));}\nd000 mu(d000 a,v0 b){return mu(a,d000(b,0.,0.,0.));}\nd11  mu(d11  a,v0 b){return mu(a,d11 (b,v1(0),v1(0)));}\nd111 mu(d111 a,v0 b){return mu(a,d111(b,v1(0),v1(0),v1(0)));}\nd22  mu(d22  a,v0 b){return mu(a,d22 (b,v2(0),v2(0)));}\nd222 mu(d222 a,v0 b){return mu(a,d222(b,v2(0),v2(0),v2(0)));}\nd33  mu(d33  a,v0 b){return mu(a,d33 (b,v3(0),v3(0)));}\nd333 mu(d333 a,v0 b){return mu(a,d333(b,v3(0),v3(0),v3(0)));}//multiply by constant, needed for sqrt()\nc3 mu(c3 p,v3 s){return c3(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z),mu(p.w,s.w));}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//special utility cases come last\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\n    \n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n\n//di() seems to be fine()\nd00  di(d00  a,d00  b){return d00 (a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a));}//dxdx\nd000 di(d000 a,d000 b){return d000(a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a) \n,((((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a)//dxdx\n+(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b)\n+(a.b*b.a-a.a*b.b)*(b.b*b.b+b.a*b.c)))*(b.a*b.a*b.a*b.a)\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n*4.*(b.b*b.a*b.a*b.a))/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a));}//dxdxdx //3rd derivative quotient rule sure is something\nd11 di(d11 a,d11 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 di(d22 a,d22 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 di(d33 a,d33 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z);d00 wa=oMg(di,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}                          \nd333 di(d333 a,d333 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z);d000 wa=omG(di,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\nd00  di(d00  a,v0 b){return di(a,d00 (b,0.,0.));}//needed for min()\nd000 di(d000 a,v0 b){return di(a,d000(b,0.,0.,0.));}//needed for min()\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),y))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define ma2(a,b,c) ma(ma(a,b),c)\n#define ma3fffff(a,b,c,d) ma(ma(a,b),ma(c,d))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n//min(x,y) = (x+y-abs(x-y))/2 == di(ad(x,su(y,ab(su(x,y)))),2.)\n//max(x,y) = (x+y+abs(x-y))/2 == di(ad(x,ad(y,ab(su(x,y)))),2.)\nd00  mi(d00  a,d00  b){return di(ad(a,su(b,ab(su(a,b)))),2.);}\nd000 mi(d000 a,d000 b){return di(ad(a,su(b,ab(su(a,b)))),2.);}     \nd11 mi(d11 a,d11 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mi(d22 a,d22 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mi(d33 a,d33 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z);d00 wa=oMg(mi,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mi(d333 a,d333 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z);d000 wa=omG(mi,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n//dot() takes vectors as input, so we take this one differently, dot() is only defined for c1(vec2) c22(vec3) c33(vec4)\n//dot()always returns a d0(float)\n//the function is ad( (ad(mu(),mu()),  ad(mu(),mu()) )\n//the function is ad( (ad(mu(),mu()),     mu()       )\n//the function is      ad(mu(),mu())\n//and multiplied terms are of type v0\n\n//ST c1  {d1   x;d1   y              ;};//2 domains t,dt   \n//ST d1  {v0   a;v1   b              ;};//2 domains t,dt\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n      \n//the c* inputs can be da_domain1(v*) outputs\nd0   dt(c0   a,c0   b){return       mu(a.x,b.x);}//dotproduct in 2d with 1 derivative (is just mu())\nd00  dt(c00  a,c00  b){return       mu(a.x,b.x);}//dotproduct in 2d with 2 derivative\nd000 dt(c000 a,c000 b){return       mu(a.x,b.x);}//dotproduct in 2d with 3 derivative   \nd1   dt(c1   a,c1   b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 1 derivative\nd11  dt(c11  a,c11  b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 2 derivative\nd111 dt(c111 a,c111 b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 3 derivative   \nd2   dt(c2   a,c2   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 1 derivative\nd22  dt(c22  a,c22  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 2 derivative\nd222 dt(c222 a,c222 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 3 derivative\nd3   dt(c3   a,c3   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 1 derivative\nd33  dt(c33  a,c33  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 2 derivative\nd333 dt(c333 a,c333 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 3 derivative\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\n#define dd(a) dt(a,a)\n//explicit dd() dual type (for uberprim)\n#define dd2(a,b) ad(p2(a),p2(b))\n//multi-dd() (muliple lengths at once)\n#define d2d(a,b)    v1(   dd(a),dd(b))\n#define d3d(a,b,c)  v2(d2d(a,b),dd(c))\n#define d4d(a,b,c,d)v3(d2d(a,b),d2d(c,d))\n         \nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\nv0 sr(v0 a){return sqrt(a);}v1 sr(v1 a){return sqrt(a);}v2 sr(v2 a){return sqrt(a);}v3 sr(v3 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\nd3 sr(d3 a){v0 q=sqrt(a.a);return d3(q,.5*rec(q)*a.b);}//first derivative shortcut is near\nd00  sr(d00  a){return ex(mu(ln(a),.5));}//2nd and 3rd derivative i do not bother with.,\nd000 sr(d000 a){return ex(mu(ln(a),.5));}\nd11  sr(d11  a){return ex(mu(ln(a),.5));}\nd111 sr(d111 a){return ex(mu(ln(a),.5));}\nd22  sr(d22  a){return ex(mu(ln(a),.5));}\nd222 sr(d222 a){return ex(mu(ln(a),.5));}\nd33  sr(d33  a){return ex(mu(ln(a),.5));}\nd333 sr(d333 a){return ex(mu(ln(a),.5));}\n\n/**///--end__: AD functions                    \n/**///--\n/**///--start: analysis common subroutines\n\n\n//compare [a] with [0.0] to return [b]==true or [c]==false\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n  #define    more(a,b,c) ((a> 0.)?b:c)\n//#define    more(a,b,c)             mix(a,b,step(c,0.))\n  #define    less(a,b,c) ((a< 0.)?b:c)\n//#define    less(a,b,c)             mix(a,b,step(0.,c))\n  #define   equal(a,b,c) ((a==0.)?b:c)\n//#define   equal(a,b,c)             mix(b,a,step2\n  #define unequal(a,b,c) ((a!=0.)?b:c)\n//#define unequal(a,b,c)             mix(a,b,step2\n  #define  unless(a,b,c) ((a>=0.)?b:c) \n//#define  unless(a,b,c)             mix(b,a,step(0.,c)) //==greater OR equal\n  #define  unmore(a,b,c) ((a<=0.)?b:c)\n//#define  unmore(a,b,c)             mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n/**///--end__: analysis common subroutines                  \n/**///--\n/**///--start: analysis Hue Gradient Gamma \n\n//rgba colorspace matrices\n      \n#define ut(a,b) (a*(1.-b))          \nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\n//Re7 Re8 rainbow (do not change or doppler shifts get skewed)\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\nvec3 rainbow(vec1 a,vec1 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(vec1 a,vec1 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(vec1 a){return rainbow(a,1./3.);}\nvec3 rainbow2(vec1 a){return rainbow2(a,1./3.);}\n                              \n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\n                      \n/**///--end__: analysis Hue Gradient Gamma \n/**///--\n/**///--start: analysis smin      \n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\n//w11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n//);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\n                      \n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(-(a)))  \n                      \nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(1./(a.x+a.y));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;//d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n/**///--end__: analysis smin \n/**///--           \n/**///--start: analysis sabs smoothstep windowfunction hulls\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/**///--end__: analysis sabs smoothstep windowfunction hulls \n/**///--           \n/**///--start: pattern debug\n                               \n//todo,, wallpaper tiling\n                               \n//needed to debug complex (number) functions.\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\n                      \n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n \n\n#define sm(a,b)smoothstep(a-10./500.,a,b)\nfloat PatternCircles(vec2 p,float m//giraffe bubbles of\n){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n              \n/**///--end__: pattern debug\n/**///--\n/**///--start: pattern hash  \n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(v0 a){return vec3(a);}                        \nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(v0 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos2,p.zy),perm2(u5cos2,p.zx),perm2(u5cos2,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+      spd);b*=1.8;z*=1.5;p*=1.2\n//;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos2,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//voronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\n\n// Salt is added to limit the x,y values. No matter what you input,\n// it returns a float [0-5900]\n// may not be a great hash\nfloat salt(float seed){float a=mod(seed,5901.); //coords=vec3(vec2(seed(1.)),0)\n float b=mod(a,2.)==.0?-.01:.11;return a+4179./sqrt(a*5.)*b+1001.*a/seed;}\n      \n/**///--end__: pattern hash            \n/**///--\n/**///--start: pattern noise\n\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL. #version 120\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo without a division\nvec3 mod7(vec3 x){return x-floor(x*(1./7.))*7.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec2 mod289(vec2 x){return  x-floor(x*(1./289.))*289.;}\nfloat mod289(float x){return x-floor(x*(1./289.))*289.;}\nvec3 permute(vec3 x){return mod289((34.*x+1.)*x);}//(34*x*34*x+x)mod 289\nfloat permute(float x){return mod289((34.*x+1.)*x);}\nvec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n      \n      \n//simplex noise:\nfloat snoise(vec2 v\n){const vec4 C=vec4(.211324865405187 //(3.-sqrt(3.))/6.\n                  , .366025403784439 //sqrt(3.0)*.5-.5\n                  ,-.577350269189626 //C.x*2.-1.\n                  , .024390243902439)//1./41.\n ;vec2 i=floor(v+dot(v,C.yy))\n ;vec2 x0=v-i+dot(i,C.xx)\n ;vec2 ii1=(x0.x>x0.y)?vec2(1,0):vec2(0,1)\n ;vec4 x12=x0.xyxy+C.xxzz\n ;x12.xy-=ii1\n ;i=mod289(i)\n ;vec3 p=permute(permute(i.y+vec3(0,ii1.y,1))+i.x+vec3(0, ii1.x,1))\n ;vec3 m=max(.5-vec3(dd(x0),dd(x12.xy),dd(x12.zw)),0.)\n ;m*=m;m*=m\n ;// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n ;// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n ;vec3 x=2.*fract(p*C.www)-1.\n ;vec3 h=abs(x)-.5\n ;vec3 ox=floor(x+.5)\n ;vec3 a0=x-ox\n ;//Normalise gradients implicitly by scaling m\n ;//Approximation of: m *= inversesqrt( a0*a0 + h*h )\n ;m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\n ;a0=vec3(a0.x*x0.x+h.x*x0.y,a0.yz*x12.xz+h.yz*x12.yw)\n ;return 130.*dot(m,a0);}\n     \n\nfloat snoise(vec3 v\n){const vec2 C=vec2(1,2)/6.\n ;const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy))\n ;vec3 x0=v-i+dot(i,C.xxx)\n ;vec3 g=step(x0.yzx,x0.xyz)\n ;vec3 l=1.-g\n ;vec3 j1=min(g.xyz,l.zxy)\n ;vec3 i2=max(g.xyz,l.zxy)\n ;vec3 x1=x0-j1+C.xxx\n ;vec3 x2=x0-i2+C.yyy\n ;vec3 x3=x0-D.yyy\n ;i=mod289(i)\n ;vec4 p=vec4(0)\n ;p=permute(p+i.z+vec4(0,j1.z,i2.z,1))\n ;p=permute(p+i.y+vec4(0,j1.y,i2.y,1)) \n ;p=permute(p+i.x+vec4(0,j1.x,i2.x,1))\n ;//Gradients: 7x7 points over a square, mapped onto an octahedron.\n ;//ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n ;float n_=1./7.\n ;vec3 ns=n_*D.wyz-D.xzx\n ;vec4 j=p-49.*floor(p*ns.z*ns.z)\n ;vec4 x_=floor(j*ns.z);\n ;vec4 y_=floor(j-7.*x_)\n ;vec4 x =x_*ns.x+ns.yyyy\n ;vec4 y =y_*ns.x+ns.yyyy\n ;vec4 h =1.-abs(x)-abs(y)\n ;vec4 b0=vec4(x.xy,y.xy)\n ;vec4 b1=vec4(x.zw,y.zw)\n ;vec4 s0=u3(floor(b0))\n ;vec4 s1=u3(floor(b1))\n ;vec4 sh=-step(h,vec4(0))\n ;vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy\n ;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww\n ;vec3 p0=vec3(a0.xy,h.x)\n ;vec3 p1=vec3(a0.zw,h.y)\n ;vec3 p2=vec3(a1.xy,h.z)\n ;vec3 p3=vec3(a1.zw,h.w)\n ;a0=taylorInvSqrt(vec4(dd(p0),dd(p1),dd(p2),dd(p3)))\n ;p0*=a0.x;\n ;p1*=a0.y;\n ;p2*=a0.z;\n ;p3*=a0.w\n ;vec4 m=max(.6-vec4(dd(x0),dd(x1),dd(x2),dd(x3)),0.)\n ;m*=m\n ;return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\n\n//fbm around 3d simplex  https://www.shadertoy.com/view/ldByDy\nfloat snoiseFbm(int octaves,float persistence,float freq,vec3 coords){\n float amp=1.,maxamp=0.,sum=0.;for(int i=0;i<octaves;++i){\n  sum+=amp*snoise(coords*freq);freq*=2.;maxamp+=amp;amp*=persistence;}\n return(sum/maxamp)*.5+.5;}\n      \n//Cellular noise (Worley noise) in 3D in GLSL.\n//returni F1 and F2 (closest and second closest)of Cellular noise (3er neighborhood)\n//subroutines\nvoid twosmolS(inout vec3 a,inout vec3 b,inout vec3 c\n){vec3 d=min(a,b);b=max(a,b);a=min(d,c);c=max(d,c);b=min(b,c);}\nvoid twosmolC(inout vec3 a\n){a.xy=(a.x<a.y)?a.xy:a.yx;a.xz=(a.x<a.z)?a.xz:a.zx;}\nvec2 twosmolE(inout vec3 a,vec3 b\n){a.yz=min(a.yz,b.xy);a.y=miv(vec3(a.yz,b.z));return a.xy;}\nvec2 twoSmallest(vec3 a,vec3 b,vec3 c\n){twosmolS(a,b,c);twosmolC(a);return twosmolE(a,b);}                      \nvec2 twoSmallest(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i\n){twosmolS(a,b,c);twosmolS(d,e,f);twosmolS(g,h,i)\n ;twosmolS(a,d,g);twosmolC(a)\n ;b=min(b,min(min(d,e),min(g,h)));return twosmolE(a,b);}                      \nvec2 twoSmallest(mat3 a,mat3 b,mat3 c\n){return twoSmallest(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]);}\n\nvec3 makeC(vec3 u,vec2 f,vec3 o,float g,vec3 j){u*=j.y\n ;vec3 x=f.x-g+j.x*(     fract(u)     -j.z)\n ;     u=f.y-o+j.x*(mod7(floor(u))*j.y-j.z);return x*x+u*u;}\n//above makeC() is for 2d, below makeC()&makeB() are for 3d\n//u is permuted hash\n//f,g,w is shift a along (sub)domain\n//o is heretic dark magic\n//j,k are modifiable scalars; j.x sets straightness, range [0..1]\nvec3 makeC(vec3 u,vec2 f,vec3 o,vec3 k,vec3 j){vec3 l=u*k.x   \n ;vec3 a=o  +j.x*     fract(l)        -k.z;\n ;vec3 b=f.x+j.x*mod7(floor(l)   )*k.x-k.z;\n ;vec3 c=f.y+j.x*     floor(u*k.y)*j.y-j.z; \n ;return a*a+b*b+c*c;}\nmat3 makeB(vec3 u,vec4 f,vec3 x,vec3 w,vec3 k,vec3 j\n){vec3 a=makeC(permute(u+w.x),f.wx,x,k,j)\n ;vec3 b=makeC(permute(u+w.y),f.wy,x,k,j)\n ;vec3 c=makeC(permute(u+w.z),f.wz,x,k,j)//3d has one more permute() iteration\n ;return mat3(a,b,c);}\n\n//j.x==straightmess[0..] j.y is like 1/7 j.z is like 1/6\nvec2 cellular(vec2 u,vec3 j\n){vec2 m=mod289(floor(u));u=fract(u)\n ;vec3 w=vec3(-1,0,1)\n ;vec3 v=vec3(-1,1,3)*.5\n ;vec3 r=permute(m.x+w)+m.y\n ;vec3\n  p=permute(r.x+w);vec3 a=makeC(p,u,v,v.x,j)\n ;p=permute(r.y+w);vec3 b=makeC(p,u,v,v.y,j)\n ;p=permute(r.z+w);     p=makeC(p,u,v,v.z,j)\n ;return sqrt(twoSmallest(a,b,p));}              \n//above is 2d, below is 3d vellular noise with 2 shortest distances in 3x neigborhood\nvec2 cellular(vec3 u,vec3 j \n){vec3 k=vec3(j.y,j.y*j.y,.5-j.y)    //this param comes with 2 derivatives\n ;     j=vec3(j.x,j.z,.5*(1.-j.z))//jitter and 1 other param (and one derivative of it)\n ;vec3 m=mod289(floor(u));u=fract(u)-.5\n ;vec3 w=vec3(-1,0,1)\n ;vec3 x=u.x-w;vec3 y=u.y-w;u=u.z-w\n ;vec3 p=permute(m.x+w)+m.y\n ;mat3 a=makeB(permute(p+w.x)+m.z,vec4(u,y.x),x,w,k,j)\n ;mat3 b=makeB(permute(p+w.y)+m.z,vec4(u,y.y),x,w,k,j)     \n ;mat3 c=makeB(permute(p+w.z)+m.z,vec4(u,y.z),x,w,k,j)\n ;return sqrt(twoSmallest(a,b,c));}\n\n// Periodic (tiling) 2-D simplex noise (hexa lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n// axis-aligned and stretched in the y direction for rectangular tiling.\n//\n// periods (p) should be EVEN integers\n// ODD periods for y will automatically be doubled.\n//\n// (rd) makes \"flow noise\" effects\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the uv\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n//\n//  return.yz are .xy derivatives\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise                \n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// TODO: One-pixel wide artefacts used to occur due to precision issues with\n// the gradient indexing. This is specific to this variant of noise, because\n// one axis of the simplex grid is perfectly aligned with the input x axis.\n// The errors were rare, and they are now very unlikely to ever be visible\n// after a quick fix was introduced: a small offset is added to the y coordinate.\n// A proper fix would involve using round() instead of floor() in selected\n// places, but the quick fix works fine.\n// (If you run into problems with this, please let me know.)\n\n      \n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p,float rot){\n#if 0\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;\n  u=4.*fract(u)-2.;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.,abs(abs(u+1.)-2.)-1.);}\n#else\n  float u = permute(permute(p.x)+p.y)*.0243902439+rot;\n  u = fract(u) * 2.*pi; // 2*pi\n  return vec2(cos(u), sin(u));}\n#endif\n                      \nfloat NoiseNoDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec3 w=vec3(dot(rgrad2(vec2(iuw.x,ivw.x),rot),a)\n             ,dot(rgrad2(vec2(iuw.y,ivw.y),rot),b)\n             ,dot(rgrad2(vec2(iuw.z,ivw.z),rot),c))     \n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c));t*=t\n ;return 11.*dot(t*t,w);}\n//above and below are TAIL subroutines, wuith or without derivatives       \nvec3 NoiseDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec2 d=rgrad2(vec2(iuw.x,ivw.x),rot)\n ;vec2 e=rgrad2(vec2(iuw.y,ivw.y),rot)\n ;vec2 f=rgrad2(vec2(iuw.z,ivw.z),rot)\n ;vec3 w=vec3(dot(d,a),dot(e,b),dot(f,c))\n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c))\n ;if(t.x<0.){a.x=0.;a.y=0.;t.x=0.;}\n ;if(t.y<0.){b.x=0.;b.y=0.;t.y=0.;}\n ;if(t.z<0.){c.x=0.;c.y=0.;t.z=0.;}\n ;vec3 t3=t*t*t;t*=t;t*=t\n ;a=a*8.*t3.x;a=t.x*d-a*w.x\n ;b=b*8.*t3.y;b=t.y*e-b*w.y\n ;c=c*8.*t3.z;c=t.z*f-c*w.z\n ;return 11.*vec3(dot(t,w),a+b+c);;}\n\nvoid NoiseHead(vec2 u,inout vec3 x,inout vec3 y\n       ,inout vec2 d0,inout vec2 d1,inout vec2 d2\n       ,inout vec2 p0,inout vec2 p1,inout vec2 p2\n){u.y+=.001\n ;vec2 uv=vec2(u.x + u.y*0.5, u.y)\n ;vec2 j0=floor(uv)\n ;vec2 f0=fract(uv)\n ;vec2 j1=(f0.x>f0.y)?vec2(1,0):vec2(0,1)\n ;p0=vec2(j0.x-j0.y*.5,j0.y)\n ;p1=vec2(p0.x+j1.x- j1.y*.5,p0.y+j1.y)\n ;p2=vec2(p0.x+.5,p0.y +1.)\n ;j1=j0+j1\n ;vec2 i2 = j0 + vec2(1)\n ;d0=u-p0;d1=u-p1;d2=u-p2\n ;x=vec3(p0.x, p1.x, p2.x)\n ;y=vec3(p0.y, p1.y, p2.y);}\n\n//4 comboinations with rotation\nvec3 simplexRotD(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nvec3 simplexRotD(vec2 u,float rot\n){vec2 d0,d1,d2,p0,p1,p2;vec3 x,y;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)        //without TilingPeriod \n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nfloat simplexRot(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}   //without Detivatives               \nfloat simplexRot(vec2 u, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)       //without TilingPeriod\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}  //without Detivative   (.yz)\n//without rotation\nvec3  simplexRotD(vec2 u,vec2 p){return simplexRotD(u,p,0.);}//tiling derivative\nvec3  simplexRotD(vec2 u       ){return simplexRotD(u  ,0.);}//       derivative\nfloat simplexRot (vec2 u,vec2 p){return simplexRot (u,p,0.);}//tiling\nfloat simplexRot (vec2 u       ){return simplexRot (u  ,0.);}\n\n/**///--end__: pattern noise\n/**///--                         \n/**///--start: complex triginometry \n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c22(c)-(c.a-c.b*i)\n#define c22(a)c4(anaa(a)).xy  //namespace conflict\nvec2 cs(v1 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(v0 a){return cs(vec2(a,a));}    \n                               \n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\nd000 ata(d000 a){v0 b=a.a*a.a+1.;v0 c=b*b;return d000(atan(a.a),a.a/b,-(b-2.)/b,2.*a.a*(a.a-4.)/(b*c));}\nd00  ata(d00  a){v0 b=a.a*a.a+1.;v0 c=b*b;return d00 (atan(a.a),a.a/b,-(b-2.)/b);}\nd0   ata(d0   a){v0 b=a.a*a.a+1.;v0 c=b*b;return d0  (atan(a.a),a.a/b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}\n\n/*\nd00 atand(d00 x,d00 y){//return atan(y,x);//2 branches, goes full circle.\n if(x.a >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}/**/\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\nv0 su(v1 a){return a.x-a.y;}\n\n#define le(a) sqrt(dd(a))\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2  \n//real and imaginary parts for polar z\nv0 arg(v1 a){return atan(a.y,a.x);}\nv1 p2c(v1 a){return v1(co(a.x),si(a.x))*a.y;}     //return carthesian of polar\nv1 c2p(v1 a){return v1(arg(a),le(a));}            //return polar      of carthesian\nv0 real(v1 z){return p2c(z).x;return z.s*co(z.t);}//return real       of carthesian\nv0 imag(v1 z){return p2c(z).y;return z.s*si(z.t);}//return imaginary  of carthesian\n\nv1 crCo(v1 a){return sqrt(length(a)+c22(a.x));}//core of complex root function,lacks sign adjustment and scaling!\n\nv1 ciCo(v1 u,v1 z,v0 r){return v1(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nv1 sqc(v1 a){v0 n=a.x+length(a);return v1(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nv3 sqc(v3 a){v3 c=v3(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nv1 po2c(v1 c){v1 d=c*c;return v1(d.x-d.y,2.*c.x*c.y);}//v1 po2c(v1 a){return muc(a,a);return v1(sub(a*a),2.*a.x*a.y);}//complex square\nv1 po3c(v1 z){v0 p=z.x*z.x,q=z.y*z.y;return z*v1(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nv1 recc(v1 a){if(a.x==0.)return v1(1e10);return c22(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nv1 lgc(v1 a){a=c2p(a);a.x=log(a.x);return a;}//return v1(log(dd(a))*.5,arg(a));}\nv3 lgc(v3 a){return v3(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nv1 suc(v1 a,v1 b){return a-b;}v1 adc(v1 a,v1 b){return a+b;}///complex addition is trivial\nv1 muc(v1 a,v1 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nv1 muc(v1 a,v1 b,v1 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nv1 muc(v3 a){return muc(a.xy,a.zw);}//parallel mult\nv1 dic(v1 a,v1 b){if(a.x==0.)return v1(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nv1 lgc(v1 a,v1 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nv1 lgc(v1 a,v0 c){return v1(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nv1 exc(v1 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//v1 lgc(v1 a,v0 c){a=c2p(a);return v1(log(a.x),a.y+c*tau);}//should be the same!\nv1 poc(v1 a,v1 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nv1 poc(v1 w,v1 z,v0 c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nv1 lgc(v1 a,v1 b,v0 c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nv1 wrtc(v1 a,v1 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nv1 wrtc(v1 a,v1 b,v0 c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//v1 sqc(v1 z){v1 c=sqrt((length(z)+c22(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\n\nv1 sic(v1 z){return .5*cs(z.x).yx*(exp(z.y)+c22(exp(-z.y)));}//v1 sic(v1 z){return v1(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  v1 sic(v1 c){v1 d=exp(c2(c.y));return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 si2c(v1 c){v1 d=v1(exp(c.y),1);return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 coc(v1 z){return .5*c22(cs(z.x))*(exp(z.y)+c22(exp(-z.y)));}\n\n//obsoleted v1 coc(v1 z){ return v1(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted v1 coc(v1 c){v1 d=exp(c2(c.y));return v1(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nv1 ta2c(v1 c){v1 d=exp(c22(c.y));v0 e=cos(c.x),s=(d.x-d.y)*.5;return v1(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nv1 tac(v1 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nv1 cotc(v1 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nv1 sihc(v1 z){return .5*cs(z.y)*(exp(z.x)+c22(exp(-z.x)).yx);}//v1 sinh(v1 z){ return 0.5*v1((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//v1 sinh2c(v1 z){z=c22(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nv1 cohc(v1 z){return coc(c22(z.yx));}//v1 cosh(v1 z){ return v1(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 v1 tahc(v1 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 v1 cothc(v1 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(v1 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 v1 cschc(v1 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nv1 arsic(v1 z){return c22(lgc(perp(z)+sqc(c22(po2c(z.yx)))+v1(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//v1 arsic(v1 z){v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(-z.y+a.x,z.x+a.y));return v1(a.y,-a.x);}\nv1 arcoc(v1 z){return-c22(lgc(z+c22(sqc(po2c(z.yx)+v1(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//v1 arcoc(v1 z){ v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(z.x+a.y,z.y-a.x));return v1(-a.y,a.x);}\nv1 csec(v1 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nv1 ccsc(v1 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nv1 arcotc(v1 z){v0 r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((v3(z.yx,-z.yx)+v3(r,0,r,0)).yxzw/r)))*.5;}//v1 arcotc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=lgc(v1(p+q-z.y,-z.x)/r);v1 b=lgc(v1(p+q+z.y,z.x)/r);return v1(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nv1 artac(v1 z){return sub2(c4(lgc(v3(1,0,1,0)-c22(z.yx).xyxy).yxwz))*.5;}//v1 artac(v1 z){ v1 a=lgc(v1(1.0+z.y,-z.x));v1 b=lgc(v1(1.0-z.y,z.x));return v1(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nv1 arcsec(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(sub2(c4(v3(z,sqc(ciCo(u,z,r)).yx)))).yx)+v1(0.,log(r));}//v1 arcsec(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(z.x-a.y,a.x-z.y));return v1(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nv1 arccsc(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+v1(0.,log(r));}//v1 arccsc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(a.x+z.y,a.y+z.x));return v1(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nv1 arcsch(v1 z){v1 u=z*z;v0 r=su(u);return lgc(c22(z)+sqc(ciCo(u.yx,z,r)))-v1(0,log(r));}//v1 arcsch(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r+p-q,-2.0*z.x*z.y));a=lgc(v1(a.x+z.x,a.y-z.y));return v1(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nv1 arsinh(v1 z){return lgc(z+sqc(po2c(z)+v1(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nv1 arcosh(v1 z){return lgc(z+muc(sqc(z.xyxy+v3(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nv1 artanh(v1 z){v0 r=1.-su(z*z);z*=2.;return .5*lgc(-v1(r,z.y)/(r+z.x));}//v1 artanh(v1 z){v0 r=z.x*z.x+z.y*z.y;return lgc(v1(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nv1 arcoth(v1 z){;v0 r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(v1(r,z.y)/(r+2.+z.x));}//v1 arcoth(v1 z){ v0 r=z.x*z.x+z.y*z.y;return lgc(v1(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nv1 arsech(v1 z){v0 r=su(z*z);return lgc(c22(z)+muc(sqc(v3(-r,0,r,0)+c22(z).xyxy)))-v1(log(r),0);}//ok-ollj\n                \nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a;}                         \n                               \n\n/**///--end__: complex triginometry \n/**///--\n/**///--start: sort\n                               \n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){const float twothirds=2./3.\n   ;if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\nvec3 getPos0V(vec3 a){vec3 r=vec3(0);r[getPos0(a)]=1.;return r;}\nvec3 getPos1V(vec3 a){vec3 r=vec3(0);r[getPos1(a)]=1.;return r;}\n//may wanrt to use getPos0() instead of getPosSmall()\nint getPosLarge(vec3 a//return position of largest  value [0..2]          \n){if(a.x>a.y){if(a.x>a.z)return 0;if(a.y>a.z)return 1;return 2\n       ;}else{if(a.y>a.z)return 1;return 3;}}\nint getPosSmall(vec3 a//return position of smallest value [0..2]          \n){if(a.x<a.y){if(a.x<a.z)return 0;if(a.y<a.z)return 1;return 2\n       ;}else{if(a.y<a.z)return 1;return 2;}}\nint getPosMid(vec3 a//return position of middle value [0..2]          \n){if(a.x<a.y){if(a.y<a.z)return 1;if(a.z<a.x)return 0;return 1  \n       ;}else{if(a.z<a.y)return 1;if(a.x<a.z)return 1;return 3;}}\nvec3 getPosLargeV(vec3 a){vec3 r=vec3(0);r[getPosLarge(a)]=1.;return r;}//return vector that indicates smalles value with a [1]   \nvec3 getPosSmallV(vec3 a){vec3 r=vec3(0);r[getPosSmall(a)]=1.;return r;}//return vector that indicates smalles value with a [1]\n//vec3 getPosMidV  (vec3 a){return vec3(1)-getPosLargeV(a)-getPosSmallV(a);}//dumb and slow but works\n      \n\n      \nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n\n                 \n//project point [a] onto line trough vecN(0) and vecN([b])  b!=0.\n//project(u-a,b-a)+a((project u on line(a,b)\n\n//return [0..1] for projection being on [a..b]\nv0 project0(v1 a,v1 b\n){float c=dd(b)\n ;if(c==0.)return -1.//projecting onto a point is nonsense, [-1] tends to be parsed as a miss\n ;return dot(a,b)/dd(b);}\n      \n\n\n//(project(o-p1,p2-p1)+p1)-o//==vector from o to projection of o on on line\n//project(p-a,b-a)+a//projected point (p) on line (a,b) (not clamped)\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest vector from point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\nv1 projectBary(v1 a,v1 b,v1 c){return b*dot(a,b)/dd(c);}//skewed mirror\n      \n     \nd3 suab(d3 p,v0 s){return su(ab((p)),s);}\nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\nd33 suab(d33 p,d33 s){return su(ab((p)),s);}           \nd22 suab(d22 p,d22 s){return su(ab((p)),s);}\nd11 suab(d11 p,d11 s){return su(ab((p)),s);}\nd00 suab(d00 p,d00 s){return su(ab((p)),s);}\nd333 suab(d333 p,d333 s){return su(ab((p)),s);}           \nd222 suab(d222 p,d222 s){return su(ab((p)),s);}\nd111 suab(d111 p,d111 s){return su(ab((p)),s);}\nd000 suab(d000 p,d000 s){return su(ab((p)),s);}\n//suab extendsions have been frustrating and halted                    \n                      \nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z),suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//c22 suab(c22 p,v2 s){return c22(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\n\n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}\n      \n/**///--end__: common aliases\n/**///\n/**///--start: linear hulls smoothstep\n\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n      \n#define fsaa 2.\n//#define fsaa 2, (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n/**///--end__: linear hulls smoothstep\n/**///\n/**///--start: Reflect and rotate            \n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\nv1 r4(v1 r){return v1(r.y,-r.x);}//perpendicular quater rotation\n                      \nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\n\n//return distance to 1/24th rotated axis (for super fast arrow shape)\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(v0 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(v0 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n        \n//modify inputs to abs(.x) == mirror vertically\nvoid mirror(inout vec2 u,inout vec2 m){m.x=abs(m.x);u.x=abs(u.x);}\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r1(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n//float angleBetween(v1 a,v1 b){return acos(dt(a,b);}\n\n//Quaternion\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dd(a)! \nv3 qn(v3 q){return q/dd(q);}\n/**/\n      /*\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n*/\n                      \n/**///--end__: Reflect and rotate  \n/**///--\n/**///--start: analytic closed-form  solutions \n\n\n//(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}//used to get closest point on ellipse: https://www.shadertoy.com/view/XttyWN\n\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  suv(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n \n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n/**///--end__: analytic solutions  \n/**///--\n/**///--start: tracing and project (euclidena and bary)\n\n\n//--start: barycentric\n\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant\nfloat c2bdetR(vec3 X,vec3 Y){return suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec3 X,vec3 Y){return 1./c2bdetR(X,Y);}     \nfloat c2bdetR(vec2 a,vec2 b,vec2 c){return c2bdetR(transp23);}\nfloat c2bdet (vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//c2bdet  for cached   division (by fragment shader) (more common)\n//c2bdetR for deferred division (intersectB2b() carthesian intersection)\n\n//return barycentric of carthesian point (t) over triangle (a,b,c)==(X,Y)\n#define c2bCore vec4 c=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*(t-vec2(X.z,Y.z)).xyxy;c.xy=vec2(suv(c.xy),suv(c.zw))\nvec3 c2b(vec2 t,vec3 X,vec3 Y,float d){c2bCore\n    ;c.xy*=d;return vec3(c.xy,1.-c.x-c.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}\n\n//float suv(vec2 a){return a.x+a.y;}\n//float suv(vec3 a){return a.x+a.y+a.z;}\n\n//barycentric tracing is great, it gives you a frustrum for free!\n\n//barycentric lineLine intersection CORE (in barycentric coords);\n//functionally identical to Intersection of ray(o,t) with RaySegmentLine(a,b)\n//but division is deferred AFTER checking if it hits\n//barycentric triangle corners are o=vec3(1,0,0)   a=vec3(0,1,0)   b=vec3(0,1,0)\n//carthesian  triangle corners are o=vec2(X.x,Y.x) a=vec2(X.y,Y.y) b=vec2(X.z,Y.z)\n//t=barycentricRayTarget   = c2b(carthesianRayTarget,X,Y,d)\n//d=barycentricDeterminant = c2bdetR(X,Y)\n//very deferred division\nvec3 intersectB2bN(vec3 t,float d\n){t.y=t.y/(d-t.x);return vec3(0,t.y,1.-t.y);}//intersection just scales a ratio\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y,float d\n){//if(d==0.)return vec3(1,0,0)//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;if(t.x==d)return vec3(1,0,0)//poorly evade division by 0 case (of parallel lines)\n ;//we can do cases before the first division\n ;//if( t.x             >abs(d))return vec3(1,0,0)//miss when looking away\n ;//the one above is only needed when one of the 2 below is NOT active\n ;if((t.x+t.y)*sign(d)>abs(d))return vec3(1,0,0)//miss <a (rayRay intersection)\n ;if(0.  >t.y *sign(d)       )return vec3(1,0,0)//miss >b (rayRay intersection)\n ;//set both above for (a<x<b) raySegment intersection\n ;//below is identical to above, BUT each side of (ab) may behave differently.\n ;if(d<0.){\n  ;//if(t.x<d    )return vec3(1,0,0)//miss when looking away from sideA\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x<d-t.y)return vec3(1,0,0)//miss <a                from sideA\n  ;//if(0. <  t.y)return vec3(1,0,0)//miss >b                from sideA\n ;}else{//if(d>0.){\n  ;//if(t.x>d    )return vec3(1,0,0)//miss when looking away from sideB\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x>d-t.y)return vec3(1,0,0)//miss <a                from sideB\n  ;//if(0. >  t.y)return vec3(1,0,0)//miss >b                from sideB \n ;}\n ;//if you only need a boolean if it hits, return it here, and skip the only division\n ;return intersectB2bN(t,d);}\n //;t.y=t.y/(d-t.x)//division deferred AFTER tracing if it hits\n //;return vec3(0,t.y,1.-t.y);}\n//wrappers:\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y){return intersectB2b(t,X,Y,c2bdetR(X,Y));}\nvec3 intersectB2b(vec3 o,vec3 t,vec3 a,vec3 b,vec3 c// intersect segment (ab)\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;return intersectB2b(t,X,Y,c2bdetR(X,Y));}\n//carthesian lineLine intersection (in barycentric coords);\nvec2 intersectB2c(vec2 o,vec2 t,vec2 a,vec2 b\n){//identical to: g=gLLxXP(a,b,o,t);if(sat(g)==g)return a-(a-b)*g\n ;vec3 X=vec3(o.x,a.x,b.x)\n ;vec3 Y=vec3(o.y,a.y,b.y)//barycentrics of triangle (0,a,b)\n ;float d=c2bdetR(X,Y)//barycentric triangle determinant\n ;if(d==0.)return o//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;c2bCore;//barycentric to carthesian BUT c.z is irrelevant \n ;c.xyz=intersectB2b(c.xyz,X,Y,d)//barycentric tracing\n ;return b2c(c.xyz,X,Y);}//outout as carthesian\n \n//N version knows that it hits, (within fustrum culling)\nvec2 inB2c2N(vec2 o,vec2 t,vec2 a,vec2 b\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;c2bCore;return b2c(intersectB2bN(c.xyz,c2bdetR(X,Y)),X,Y);}\n\n//return 3 squared lengths of triangle sides of triangle (a,b,c)\nvec3 getSqoaredLengths(vec2 a,vec2 b,vec2 c){return d3d(a-b,b-c,c-a);}\n//return SQUARED length of vector (p) in barycentric coordinates\n//t=getSqoaredLengths(a,b,c) is intended to be buffered\nfloat lengthBary(vec3 p,vec3 t){return -suv(t*p.yxx*p.zzy);}\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Distance_between_points               \n\n     \n//shortest carthesian distance may be different than euclidean. even to the 3 points??\n//anyways, this is buggy, and i cant find the bug.\n\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\n      \nfloat segmentB(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\n\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float cd=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //c2bdet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //c2bdet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,cd)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segmentB(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n /*\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{/**/\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segmentB(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}\n  //min of 3 line distances only inside the triangle\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}\n/**///--end__: barycentric\n \n//lineLineIntersection (carthesian 2d)\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection of lines AB and CD; http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;if (dotperp==0.)return A//worksave for parallel case\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return iAlong of segment(AB) with ray(CD) (beware that segment comes first!)\n//asserts that ray points towards segment !!! (that needs a second pass with swapped parameters)\n//if (sat(iAlong)==iAlong)//ray(CD) intersects the segment(AB)\n//if (sat(iAlong)>=iAlong)//ray(CD) intersects the ray(AB)\n//intersectionPoint == A+B*iAlong\nv0 gLLxXP(v1 A,v1 B,v1 C,v1 D\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 e=dot(d,perp(b)) //==perpdot() function (same order of operands?)\n ;if(e==0.)return -.1//worksave for parallel case\n ;v0 t=-dot(c,perp(d))/e\n ;return t;}//gLLxXP(a,b,o,t) tests if ray hits segment (asserting way looks towards segment)\n//intersection points:\n\nvec2 mirror(vec2 o,vec2 a,vec2 b){ //return o, mirrored on ab\n ;vec2 m=project(o-a,b)+a-o\n ;return o+m*2.;}\n\n//mirror o along the axis (x,a+(b-a)*.5) == sqap 2 parycentric components\nvec3 mirrorBaryYZ(vec3 o,vec2 a,vec2 b,vec2 c){ //return o, mirrored on ab (triangle abc)\n ;return o.yxz\n ;//vec2 ass=gLLxX(o,o+b-a,a+(b-a)*.5,c)//hard and dumb carthesian within bary\n ;//return o+(ass-o)*2.//hard and dumb carthesian within bary\n ;}\n\n//mirror o along the axis (p2,p1)\nvec3 mirrorBaryZ(vec3 o){return vec3(o.xy+o.z,-o.z);}\nvec3 mirrorBaryY(vec3 o){return mirrorBaryZ(o.xzy).xzy;}\nvec3 mirrorBaryX(vec3 o){return mirrorBaryZ(o.zyx).zyx;}\n\n//vec2 or=b2c(oo-vec3(-1,0,1).xyz,p2,p0,p1)//third rotation barycentric (but around what point?)\n//barycentrically rotate around vec3(0,0,1) by N/6 full rotations\nvec3 r16bary(vec3 o){return mirrorBaryX(o).yxz;}//oo=r16bary(oo-vec3(1,-1,0))\nvec3 r56bary(vec3 o){return mirrorBaryY(o).yxz;}//oo=r56bary(oo-vec3(0,1,-1))\nvec3 r36bary(vec3 o){return mirrorBaryZ(o).yxz;}//oo=r36bary(oo-vec3(1,-1,0))\n\n//return how far (p) is in front of ray/normal (ut), [>0],or on (u)[=0], or behind (u)[<0] (along the ray)\nfloat isInfront(vec2 u,vec2 t,vec2 p){return dot(p-u,t-u);}\n//isInfront doesnt care for zFar,isWithin asserts (t] to be zfar\n//use isWithin to check if a lineLineIntersection is within a segment.   [<]0for false, >=0 true\nfloat isWithin(vec2 u,vec2 t,float r\n){if(r>=0.){\n ;if(dd(t-u)<=r*r)return r;\n };return -1.;}\n//above already has a cached dotproduct.\nfloat isWithin(vec2 u,vec2 t,vec2 r){r.x=isInfront(u,t,r);return isWithin(u,t,r.x);}\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his MIT licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n//The MIT License\n//Copyright  2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 vv0,vec3 vv1,vec3 vv2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=vv0-vv1\n ;vec3 b=vv2-vv0\n ;vec3 p=vv0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright  2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(miv(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n// Slightly improved version of a Trapezoid primitive without flicking.\nfloat sdTrapezoidFixed(vec2 u,vec2 a,vec2 b,float ra,float rb\n){u-=a;b-=a;float c=dd(b)\n ;a=vec2(abs(dot(perp(u),b))/sqrt(c),dot(u,b)/c)\n ;b.x=rb-ra;b.y=sat((b.x*(a.x-ra)+a.y*c)/(b.x*b.x+c))\n ;vec4 r=vec4(ma0(a.x-((a.y<.5)?ra:rb)),abs(a.y-.5)-.5,a.x-ra-b.y*b.x,a.y-b.y)\n ;a.x=sign(mav(r.zy));r*=r;r.yw*=c;r.xz+=r.yw\n ;return a.x*sqrt(miv(r.xz));}//https://www.shadertoy.com/view/wtSyWc\n\n      \n/**///--end__: euclidean tracing\n/**///--\n/**///--start: AD-/mercury.sexy/hd_sdf\n\n//euclidean tracing[line line intersection] is needed for some shapes here\n                      \n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n           \n                      \n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n\n//pmod() got killed by su() incompatibility\n//#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\n////frflpm(v00,c00)  frflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)  //high domain su() incompatibility\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n                      \n//float ma(vec4 a){return 0.;}\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\n     /* killed by incompatibility                 \nfloat Blob(vec3 p){p=abs(p);p=mix(p,p.yzx,step(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n/**/\n#define fPlane(p,n,d) ad(dt(p,n),d)\n      \n      \n      \nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\n/*  old struct fr() incompatibility\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fr(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}*/\n\n           \n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\n\n//common quadratic subroutines.\nvec2 abmb(float a,float b){return vec2(a-b,b);}\nfloat ccis(vec2 r){r*=r;return r.x-r.y;}\n//return circle-circle-intersection.x; (left circle center is on vec2(0)\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\n\nconst float eRm=.0001;\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n\n//https://en.wikipedia.org/wiki/Moss%27s_Egg\n#define EarVagEgg moss\n#define CylEarVagEgg cylMoss\n//moss() is still far from standardized. rac is the central radius, should be parametric.\nfloat moss(vec2 u,vec3 m//m.x+m.xy<=1. is relevant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //cylMoss() is capped cylinder to extrude it to 3d.\nfloat moss(vec2 u,vec2 m){return moss(u,vec3(m,mix(.5,3.,sin(1.)*.5+.5)));} //ain(1.) was iTime\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(moss(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//cylMoss() is capped cylinder to extrude it to 3d.\nfloat cylMoss(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\n//distance from (u) to lenss nut hourglass (rd) (radius,circleCenterDistances)\nfloat vesica(vec2 u,float r,float d\n){u=abs(u);float b=(r*r-d*d);vec2 a=vec2(u.y*d,u.x+d);a*=a*sign(a)\n ;return((a.x/b>a.y))?length(u-vec2(0,sqrt(b)))*sign(d)\n                     :length(u+vec2(d,0))-r;}//https://www.shadertoy.com/view/XtVfRW\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat sdHorseshoe(vec2 p,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;p.x=abs(p.x)\n ;float l=length(p)\n ;p=mat2(-c.x,c.y,c.y,c.x)*p\n ;p=vec2((p.y>0.)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l )\n ;p=vec2(p.x,abs(p.y-r))-w.xy\n ;return length(max(p,0.)+min(mav(p),0.))   -w.z;\n ;//return length(ma0(p))+mi0(mav(p))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n\n      \n                      /*\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n/**/\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}  \n\n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n\n){float s=r/n\n ;float u=b-r\n ;return mi(mi(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\n      \n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n\n\n/**///--end__: AD mercury.sexy/hd_sdf\n/**///--\n/**///--start: projections\n                      \n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv22 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=vec2(0)//-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*1.)//autopilot //*iTime\n ;m=vec2(1)//mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v22(pos,dir);}\n\n//Phong+debugPlanes\n//todo (fix df() nonsense\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n                      \n                      \n/**///--end__: projections  \n/**///--\n/**///--start: AD Superprims\n      \nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//odsoleted by cir()\n/*\n#define abm(a,b) (abs(a)-b)  //ditance taxicap   -b\n#define lbm(a,b) (length(a)-b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))   //==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a)) //i am not convinced by this one\n//#define box(a,b) roundit(abm(a,b))\n/**/\n      \n//cir()  return distance of (u) to (rounded) box/circle/AxisAlignedLineSegment\n//yes, thats a lot of basic shapes\n//called cir() because all lowest LOD are boxes.\n//cirS() seperates polynomials to allow to delay the sqrt() \n//       of ALL boxes with the same thickness (if tree-branch-thicknesses are uniform)\n//       by getting sqrt(min(multiple squared values))\n//cirS() header exists with and without stretching(&automatic offset)\n//\n//u=uv point\n//b.x=thickness\n//b.y=cornerRoundness [0..1] interpolates between circle and boxRounded\n//lod=LoD lod==0 is always a square\nvec2 cirCore(vec2 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\nvec2 cirCore(vec3 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\n\n//cir header without stretch\nvec2 cirS(vec2 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\n\n//cir header with stretch option\n//s=size stretch\n//positibes are useful for segments/boxes\n//negative inputs create ray/wedge (wedge interiors (2 negative domains) are only good within +-b.x)\n//s=vec2(0,-1) creates an upwards ray, af moves the base up, till vec2(0) touches the bottom\n//s=vec2(1,0) stretches by 1 along .x and moves to the right till vec2(0) is on the surface.\n//any s>0 will create a line segment, where vec2(0) is on the surface, iff one other domain of s==0\nvec2 cirS(vec2 u,vec2 b,float l,vec2 s\n){bvec2 e=lessThan(s,vec2(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;e=greaterThan(s,vec2(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l,vec3 s\n){bvec3 e=lessThan(s,vec3(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;if(e.z){u.z-=b.y*.5;s.z=0.;u.z=min((u.z),0.);}\n ;e=greaterThan(s,vec3(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;if(e.z)u.z-=(s.z+b.y)*.5 \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\n\nfloat cir(vec2 u,vec2 b,float l,vec2 s){u   =cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec2 u,vec2 b,float l       ){u   =cirS(u,b,l  );return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l,vec3 s){u.xy=cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l       ){u.xy=cirS(u,  b,l);return more(u.x,sqrt(u.x),0.)+u.y;}\n\n//without LoD (default to 1.)\nfloat cir(vec2 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec2 u,vec2 b,vec2 s){return cir(u,b,1.,s);}\nfloat cir(vec3 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec3 u,vec2 b,vec3 s){return cir(u,b,1.,s);}\n\n//without lod & with maximum roundness (b and s swapped to avoid namespace conflict with self)\nfloat cir(vec2 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec2 u,float b,vec2 s){return cir(u,vec2(b,1.),s);}\nfloat cir(vec3 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec3 u,float b,vec3 s){return cir(u,vec2(b,1.),s);}\n//cir was tested in 2d, but 3d may have typos?)\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat horseshoe(vec2 u,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;float circle=length(u)-w.z\n ;u.x=abs(u.x)\n ;u=mat2(-c.x,c.y,c.y,c.x)*u\n ;float l=length(u)\n ;u=vec2((u.y>0.)?u.x:l*sign(-c.x),(u.x>0.)?u.y:l)\n ;u=vec2(u.x,abs(u.y-r))-w.xy;\n ;return length(max(u,0.))+ min(0.,max(u.x,u.y))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n      \n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=vec2(0)//iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(mav(dt(p,y))-o.x*3.,sqrt(miv(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\n                      \nstruct v14{float a;vec4 b;};\n                      \nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//guessing this was what this one does\n                      \nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=.5 //iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n                      \n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n             \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\n\n                      //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r){return max(box(u,vec3(r)),fOctahedron(u,r));}\n\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\n //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n                      \n/**///--end__: AD Superprims\n/**///--\n/**///--start: Glyphs\n\nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n                      \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n/**///--end__: Glyphs\n/**///--\n/**///--start: AD march RayMarchingPrimitivesBasic                 \n                      \n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}\n\n//#u,o,t) distance between (u) and segment  from   (o) to     (t)   (strethed dot always does sqrt)\n//    ray(u,o,t) distance between (u) and ray      from   (o) trough (t)   \n//   line(u,o,t) distance between (u) and line     though (o) trough (t)  \n//    ray(u)     distance between (u) and ray      from (0,0) trough (0,1) \n#define segment2(a,c,d) dd(su(a,mu(c,d(di(dt(a,c),dd(c))))))      \n#define segments(u,o,t,d) (segment2(su(u,o),su(t,o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n#define    line(u,o,t) sqrt(segments(u,o,t,nul))\n#define rAy(c) float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}\nrAy(v0)rAy(v1)rAy(v2)rAy(v3)\nfloat ray(v1 u){if(u.x>0.)return length(u);return u.y;}   \n\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\n/**///--end__: march RayMarchingPrimitivesBasic\n/**///follows:\n/**///--start: march bezier \n\n//[follows], because segment() is special case of bezier()\n   \n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n                      \n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b));}\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L){v1 l=p2-p0;float s=L*L//https://www.shadertoy.com/view/4ltyWr\n ;return .5*((p0+p2)+sqrt(max(0.,s-dot(l,l)))*sign(L)*norma(v1(-l.y,l.x)));}\n\n/**///--end__: march bezier \n/**///--\n/**///--start: RE mach RayMarchingPrimitivesBasic               \n\n                           \n\n\n//c.xy=sin/cos of angle. r is the radius //uppr segment is always round\nfloat pieSlice(vec2 u,vec2 c,float r //a simple packman\n){u.x=abs(u.x)\n ;v0 l=length(u)-r\n ;v0 m=length(u-c*clamp(dot(u,c),0.,r) )\n ;return max(l,m*sign(c.y*u.x-c.x*u.y));}//https://www.shadertoy.com/view/3l23RK\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he\n){vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dd(k2), 0., 1. );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0\n   ;return s*sqrt( min(dd(ca),dd(cb)));}//https://www.shadertoy.com/view/MlycD3\n\n//polygon distance does crossingCumbers, has better (rounded) interios than windingnumbers.\nconst int N = 5;\nfloat sdPoly(vec2[N] v, in vec2 p\n){const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }return s*sqrt(d);}//https://www.shadertoy.com/view/wdBXRW\n      \n/**///--end__: RayMarchingPrimitivesBasic\n/**///--\n/**///--start: Relativity\n\n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\nint nextMat;\nint rayMat;\nint rayObj;\nfloat matSize;\nfloat lastrDist;\nfloat lastrDistObj;\nvec4 volumetricCol;\n\n//camera buffer data of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer)\n//- 0<=x<Resolution.xy\n#define RePos   0.  \n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n//ReTime.xyzw store the averages of the (up to) most recent 2,4,8,16  iTimeDelta\n//ReTimE.xyz  store the averages of the (up to) most recent 32,64,128 iTimeDelta\n//ReTimE   .w stores relativistic cameraTime, if (.w<0) time is paused\n#define ReTime  5.  \n#define ReTimE  6.  //\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\n#define ReEdit  9.  //not yet used by Image\nfloat varWdth=1.; //scale up visually\n\n//relativity made compatible: ?\n//RE7 uses a lot of structs in arrays.\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays struct params\n//(arrays of struct params, addressed by struct enum) \n//objectOfStruct.param -> param[objectOfStruct]\n//this mage Re7 gles100 compatible, but now we need an enum foreach object.\n#define objNum 7\n//for below object properties;\nvec4 [objNum] objRot;//rotation\nvec3 [objNum] objPos;//position\nvec3 [objNum] objVel;//velocity\nvec3 [objNum] objSca;//scale\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n\n//float[objNum] objRad;//radius optimization\n#define numLights 3\nvec4 [numLights] oliCol;//colorIntensity;\nvec3 [numLights] oliPos;//position\nfloat[numLights] oliHal;//HaloResult\n//float[numLights] oliSiz;//size\n//lights have no labels\n\n//some global accumulators (some reset each frame, some dont)\n//float mGI;//avccumulator for globalIllumination?\nfloat lorentzF;\n//mat3x3 LZLgthContract;\nvec3 pos; //campos.xyz\nvec3 dpos;//relevant for each pixel of [RE] and [Image] \nfloat playerTime;\n//volume marching accumulator, used for blackHoleAccretionDisk\nfloat vma=0.; \nint curObj = 0;\nint minObjDepth=-1; \n\n\n//point,radius\nv0 sphere(v2 u,v0 r){return length(u.xyz)-r;}\n//point,size\nv0 cube(v2 u, v0 s){return mav(abs(u)-s);}\nv0 box (v2 u, v2 s){return mav(abs(u)-s);}\n//point,radius,height\nv0 cylinderZ(v2 u,v0 r,v0 h){return max(length(u.xy)-r,abs(u.z)-h);}  \nv0 cylinderY(v2 u,v0 r,v0 h){return cylinderZ(u.xzy,r,h);}\nv0 cylinderX(v2 u,v0 r,v0 h){return cylinderZ(u.zyx,r,h);}\n\n//DopplerShift //col,shiftedFreq,targetFreq\nv0 dsf(v2 c,v2 s,v0 t \n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;return suv(c*max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.))  ;}\n #else\n ;return suv(c*max(v2(0),1.-abs(s)*3.))  ;}\n #endif\n\n//dopplerShiftFactor\nvec3 dsf(vec3 c,vec3 f//all values of f are identical.\n){f*=vec3(1.,1.257,1.58)\n ;vec3 r=vec3(1,2,4)/3.\n ;return vec3(dsf(c,f,0. )+dsf(c,f,1.)*.3+dsf(c,f,-r.x)*.2\n             ,dsf(c,f,r.x) \n             ,dsf(c,f,r.y)+dsf(c,f,1.)*.5+dsf(c,f,r.z)*.25);}\nvec3 dsf(vec3 c,float f){return dsf(c,vec3(f));}\n\n//Quaternion  //pushed up a lot by RE7\n/*\n//asserting that length of quaternions are close to 1\n//we can normalize() by dividing by the squaredLength dot(a,a)! \nvec4 qn(vec4 q){return q/dot(q,q);}\n/**/\nvec4 qn(vec4 q){return q/dot(q,q);}\nvec4 aa2q(float b,vec3 a// b must be normalized!\n){b*=.5;return qn(vec4(a*sin(b),cos(b)));}\n\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nvec4 q2aa(vec4 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nvec4 qm(vec4 a, vec4 b\n){vec4 res= vec4(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return normalize(res);}\nvec3 qr(vec4 q,vec3 v\n){vec3 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n\nvec4 Transform(int i,vec4 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(vec3(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\n\nvoid oCamSet(vec3 u,vec4 rot){objPos[oCam]=u;objRot[oCam]=rot;}\n\nfloat LorentzFactor(float v){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\n\nvoid ProcessLightValue(float t\n){oliPos[0]=vec3(6.,1.,sin(t))\n ;oliCol[0]=3.*vec4(0.2,1.,.2,1)\n ;oliPos[1]=vec3(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*vec4(1,1,0.5,1)\n ;oliPos[2]=vec3(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*vec4(1,.2,1,1);}\nvoid SetTime(float t){\n ;ProcessLightValue(t)//also called in final pass\n ;objPos[oCubeMy]=vec3(0) \n ;objRot[oCubeMy]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oCubeMy]=vec3(.8)\n ;objPos[oBlackHole]=vec3(5.,sin(t*0.2),-5.)\n ;objRot[oBlackHole]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oBlackHole]=vec3(1)\n ;objPos[oCubeChil]=vec3(1)\n ;objRot[oCubeChil]=aa2q(t*1.,normalize(objPos[oCubeChil]))\n ;objSca[oCubeChil]=vec3(.4)\n ;float trainV = 2.2\n ;objVel[oTrain]= vec3((floor(mod(trainV*t/16.,2.))*2.-1.)*trainV,0,0)\n ;float trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.\n ;objPos[oTrain]=vec3(abs(1.-mod(trainV*t/16.,2.))*16.-8.,-.8,9.)\n ;objRot[oTrain]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTrain]= vec3(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;objPos[oTunnel]=vec3(0,-.8,9.)\n ;objRot[oTunnel]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTunnel]=vec3(1.,1.,1)\n ;objPos[oTunnelDoor]=objPos[oTunnel]\n ;objRot[oTunnelDoor]=objRot[oTunnel]\n ;float open = sat((1.-abs(3.*objPos[oTrain].x))*2.)\n ;objSca[oTunnelDoor]= vec3(open,open,1);}\n\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n      \n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID==processedMaterial||processedMaterial==-1){nextMat=matID;lastrDist=o;\n#define endMaterial() } if (o != lastrDist) rayMat=nextMat;\n//marchlight() MarchPOV() do map(r.b,-1) , it marches the whole set\n//object groups are assigned to a materialID\n//defined as N of beginMaterial(N)\n//if map(r.b,-1) ray hits material of an id, rayMat stores that ID\n//a second pass can then march  ONLY against a subset geomety of a previously measured materialId\n//getDiffuse may do map(r.b,mat)\n//this is used to see how fast the hit object moves to the camera\n     //but that assumes that the same way will also hit the moved object\n     //and thats a VERY silly assumption, and also, it is disabled, and may have always been.\n     //this was likely a dubm idea of the maker of this, never completely edited out.\n\n//this is cute and all, but not compatible with my infiniteReflections\n//as my infiniteReflections loop accumulates on each reflection, there is no second pass\n//groups of materials may still be useful.\n\n//to be very clear, map() so far is ALWAYS called with second parameter set to -1\n//while other inpputs wozuld only trace a subset of the DF.\nfloat map(vec3 u, int processedMaterial\n){float o=0.//0. if first operation is a SUB(), 1e10 otherwise\n ;rayObj=0\n ;vec4 w=vec4(u,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(w.w*box(w.xyz-vec3(0),vec3(10,2.5,10)))\n ;ADD(w.w*cylinderY(w.xyz-vec3(-6,0,-2.),0.1,3.))\n ;ADD(w.w*cylinderY(w.xyz-vec3( 5,0,-2.),0.1,3.))\n ;endMaterial()     \n ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(c.w*sphere(c.xyz,1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;vec4 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(blackHoleSpace.w*sphere(blackHoleSpace.xyz,.5))\n ;endMaterial()\n ;vec4 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0, .5,0),vec3(.2,.1,1.5)))\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0,-.5,0),vec3(.2,.1,1.5)))\n ;endMaterial()\n ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0, 1.4),vec3(.2,.4,0.1)))\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0,-1.4),vec3(.2,.4,0.1)))\n ;endMaterial()\n ;vec4 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.8),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,0),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.68),vec3(.1,.1,.06)))\n ;ADD(trainSpace.w*cylinderZ(trainSpace.xyz-vec3(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;float tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0;L<3;L++\n ){ADD(w.w*sphere(w.xyz-oliPos[L],.001))\n  ;vec3 relPos=oliPos[L]-pos\n  ;oliHal[L]+=o*(0.02/(dot(relPos,relPos)+.01));}\n ;return o;}\n\nvec4 GetNormal(vec3 u//4tap derivative\n){vec2 e=vec2(.003,0.)\n ;float o=map(u,-1)\n ;return vec4(normalize(vec3(map(u+e.xyy,-1)\n                            ,map(u+e.yxy,-1)\n                            ,map(u+e.yyx,-1))-o),o);}\n\n\n\n/**///--end__: Relativity\n/**///--\n/**///--start: memo\n                      \n             \n//solving with linear equations (and not with perlendicular doorproduct rhombus)\n\n/*getting the linear function of a line (o,t) //2 points on a line\ny=m*x+b\nm=(o.y-t.y)/(o.x-t.x) //slpe == rate of change over one domain (x)\nb=t.y-m*t.x           //f(0)\n\nm=(o.x-t.x)/(o.y-t.y)  //is constant\neither enter o.xy or t.xy\no.y      =m*o.x+b    \nt.y      =m*t.x+b\nt.y-m*t.x=     +b   //b is f(0)\n\nm=(o.x-t.x)/(o.y-t.y) //slope\nb=t.y-m*t.x           //f(0)  (this is a vec2 in 3d)\n\n//the above is odd for barycentric coordinates.\n//theres no y=m*x+b pointSlope form\n//sure, the slope is simple\n//oh wait, i just assert a skewed 2d coordinate system.\n\n//where ever 2 things intersect, they are the same, there they are equal.\n//this equation is a linear equation system, with as mnany lines as domains\n//substract factors to get all constants on one side\n                      \n/*  solving lonear equations with inverse matrix:\nhttps://courses.lumenlearning.com/ivytech-collegealgebra/chapter/solving-a-system-of-linear-equations-using-the-inverse-of-a-matrix/\n\n  a*x=b\n    x=b/a\n    x=b*inverse(a)\n\na is a matrix\nx are coefficients (one foreach domain)\nb may be zero vector, usually only contains constanty.\n                      \nexample (2d line intersection)\nA linear function is visible as a line where f(x)=y\ncos(x)  =y\ncos(x)-y=0\n\nany intersection of 2 things may have an intersection, where both functions are equal\n3*a+ 8*b=5\n4*a+11*by7\n\nA=mat2(vec2(3,8),vec2(4,11)\nX=vec2(a,b)\nB=vec2(5,7)\nA*X=B\ninverse(A)==mat2(11,-8,-4,3)\ninverse(A)*B==vec2(-1,1)  \nBEWARE that matrix multiplication is not commutative  inverse(A)*B != b*inverse(A)\n->\nvec2(x,y)==vec2(-1,1)\n/**/\n                      \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n/*\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n/**/\n                      \n/*\ntodo\nget RE included\n\nfix duplicates with the hg_sdf segment\n\nfix vNNN struct incompatibles (is simple)\n\nfix all that relies on high domain su() functions. (incompatibility\n- hash noise errors  , re-copy from   https://www.shadertoy.com/view/XlVyDK\n\ninclude debugHg2() marcher from       https://www.shadertoy.com/view/XlVyDK\n\na lot of hg sdf uses higher doimkensional mod mo(), which fails here an is from  /XlVyDK\n*/\n                      \n/*\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n/**/\n                      \n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\nfloat addToAverage(float a,float b,float l//remove b from incremental average a of length l\n){return ((a*l)+b)/(l+1.);}//assert l to be -=1\n\n//assume a stores an average of 2 and is 2 long, thats a*l=4\n//and b is a slow frame that is 3 long:\n//the 3 iframes long segment is 2+2+3\n//we divide by 3 for the new average\n      \n//assume a stores an average of 2 and is 2 long\n//and b is a slow frame that is 3 long\n//(2+3)/2\n  \n/**///-- start incrementalAveraging (for bayesian performance)\n      \n//[a] stores an average of [c] inputs of [t]\n//initially          a= 0\n//after first  call, a= t       /1\n//after second call, a=(t+t2   )/2\n//after second call, a=(t+t2+t3)/3 ...\n//incremental averaging //a==0 before the first call of ia()\nfloat ia(float a,float t,float c\n){return ((a*c)+t)/c;}//update average a by input t,c==number of function calls\n //assuming ia() is called every frame, and the initial frame has iFrame==0 :\n //c=1.+iFrame         accumulates a to the average of every frame\n //c=1.+min(iFrame,2.) keeps storing the averages of the 2 most recent calls\n //c=1.+min(iFrame,4.) keeps storing the averages of the 4 most recent calls\n\n//t=iTimeDelta,i=iFrame\n//a.xyzw stores 4 short term averages\nvoid performance(inout vec4 a,inout vec3 b,float t,float i){\n ;vec4 c=vec4(i)\n ;vec3 d=min(c.xyz,vec3(2,4,8))+1.  //+1 outside the () asserts initial iFrame==0\n ;     c=min(c,vec4(16,32,64,128))+1.\n ;ia(a.x,t,c.x)//a.y stores an average i of up to 2 most recent frames\n ;ia(a.y,t,c.y)//a.z stores an average i of up to 4 most recent frames\n ;ia(a.z,t,c.z)//a.w stores an average i of up to 8\n ;ia(a.w,t,c.w)  //b.x stores an average i of up to 16\n ;ia(b.x,t,d.x)  //b.y stores an average i of up to 32\n ;ia(b.y,t,d.y)  //b.z stores an average i of up to 64\n ;ia(b.z,t,d.z);}//b.w stores an average i of up to 128\n\n//now, instead of feeding the average of 60 fps to bayeps\n//or just iTimeDelta\n//we feed it the average of multiple average iTimeDeltas \n//the first frame it asserts the idela of 1/targetfps pperformance\n//the frames fter this it has averages of averages of iTimeDelta segments\n\n", "buffer_a_code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m){if(d<r){r=d;state.x=f;o=center-m;}}//for iDiegeticUI\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  //initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.45 *iResolution.y) \n  ;addInit(.8*iResolution.x,.7 *iResolution.y)\n  ;addInit(.35 *iResolution.x,.45 *iResolution.y)\n  ;addInit(.4 *iResolution.x,.8 *iResolution.y)\n  ;//addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n//compilation time of this buffer is 12-16 seconds, too long\n//therefore optionally disabled below:\n//#define compileAD\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=ds=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=ds=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      farness=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    swiftness=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure nearness.\n;\n     nearness=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    forceness=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25)   ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25)   ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n            \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;m=iMouseZwFix(m,false)\n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n     \n     \n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(smoothstep(c.xyzw,-c.xyzw,vec4(viewzoom/Aa(t,u,r,m))),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){\n #ifdef compileAD \n  ;v0 t=iTime\n  ;v2 r=iResolution.xyz\n  ;v3 m=iMouse.xyzw\n  ;m=iMouseZwFix(m,false)\n  #if (scene==3)\n  ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n  #elif (scene==2)\n  ;O=in3d(t,u,r,m)\n  #elif (scene==1)\n  ;O=in2d(t,u,r,m)\n  #elif (scene==0)\n ;O=in1d(t,u,r,m)\n  #endif \n    \n #endif \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//[Re]= [Relativity Engine] v8\n\n//parent  Re7 : https://www.shadertoy.com/view/tlf3zj    (BayesianEpsilon targetFPS)\n//parent  Re0 : https://www.shadertoy.com/view/tdfXDl\n//this seems to have brighter lights than the oldest parent Re0\n//but the diffuse calculation seems to be still identical between Re0 and Re8\n\n//press t to toggle pausing time\n//(note that telativistic effects are also paused\n//, moving closer to an object will fadstForward it to its present state\n//, moving away from an ovject, will have you see its state further in the past.\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n\n\n/*\nthis initially only rared for camera and cameraCollision\nbut now it may just buffer a lot more\n- some bayeps values\n- object properties for a UI\n- some bayeEps memory to average over (average of last few rendertimes)\n/**/\n\n\n\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nfloat keyRe(float a){return texture(iChannel1,vec2(a,.5)).x;}//key released\nfloat keyDn(float a){return texture(iChannel1,vec2(a,.2)).x;}//key down\nfloat keyDn(vec2 a){return keyDn(a.x)-keyDn(a.y);}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\n\n\n/**///---\n/**///---start: fps counter\n\n//https://www.shadertoy.com/view/Ms2cWz\n//this is improving\n//https://www.shadertoy.com/view/lsjyzR#\n//in precision and performance\n//it dares to such the boundaries of floating point percission.\n//way past 5 decimals, \n//which is were reasonable people would stop using only 16 bit float.\n//got a performance boost with code from https://www.shadertoy.com/view/MtyXDV\n//this code is bad at displaying large values in the 2billions.\n//because it insists on tpe float for large values, \n//resulting in rounding such large integers down.\n//\n//this is becase i assume most fragment shader impllementations \n//will do type float FASTER than integer divisions of integers >1million.\n//and i just do not use type int anywhere in here.\n//this funcion is important to avoid SOME rounding errors \n//that can result in \"out of bound\" glyphs that will be caught by clamp(digit,0,9))\n//but then still display the wrong glyph due to \"cascading rounding up\".\n//at roughly the 5th decmal place of values like -78987.8889999999;\nfloat powf(float i){\n //if (i<-8.)return pow(10.,floor(i));\n //line makes makes no difference because for that range you have MUCH different issues first.\n if (i>-1.){\n  if(i>3.){\n   if(i>5.){\n    if(i>6.)return 1e7;return 1e6;}else{\n    if(i>4.)return 1e5;return 1e4;}}else{\n   if(i>1.){\n    if(i>2.)return 1e3;return 1e2;}else{\n    if(i>0.)return 1e1;return 1e0;}}}else{\n  if(i>-5.){\n   if(i>-3.){\n    if (i>-2.)return 1e-1;return 1e-2;}else{\n    if (i>-4.)return 1e-3;return 1e-4;}}else{\n   if(i>-6.){\n    if (i>-6.)return 1e-5;return 1e-6;}else{\n    if (i>-8.)return 1e-7;return 1e-8;}}}}\n//based on \n//https://www.shadertoy.com/view/XsfyDl          =leading zeroes, other precision boons\n//https://www.shadertoy.com/view/lsfcRX          =bufferless bitmap-font version\n//https://www.shadertoy.com/view/4ltXDf          =font texture\n//https://www.shadertoy.com/view/MsXyzX          =less branching for above\n//based on https://www.shadertoy.com/view/Mt2GWD =log10 stuff for decimal spacing\n//\n//core function is floatShow()\n//should be easy to modify to show cursor.xy or values of matrices.\n//\n//only shows [glyphs] decimals left of the decimal point.\n//only shows min(4,[glyphs]) decimals right of the decimal point. (5th rounds poorly)\nconst float glyphs =11.;//max glyphs\n//Sets loop iterations.\n//is used in 2 loops, cycling that often,\n//..once for whats left of the decimal point, once for whats right of the decimal point\n//\n//transparent border around glyphs that\n//replaces thin border of glyph with transparency, does not add whitespace.\nconst float marginT=1.;//if (marginG==1. && small text scale) neigbors can bleed trough.\n//marginT gets obsoleted by [p<-clamp(p,0.,1.)] within char()\n//\n//some compilers may just cry and may refuse to compile shit or just return a black screen.\n#ifdef div0\n//for openGl division by 0 case handling of type float.\nconst float NaN= 0./0.;\nconst float Inf= 1./0.;\nconst float NIn=-1./0.;\nconst float Po0= pow(0.,0.);\n//pow(0.,0.) should be \"ndef\" or \"NaN\", but is \"0.\" (or \"1.\") depending on hardware.\n#endif\n#define lt(a) lessThan(vec2(-1.),a)\nbool whiteRectangle(vec2 u){\n bvec2 a=lessThan(vec2(-1.),-abs(u));//bvec2 a=greaterThan(vec2(.1), uv); \n return (a.x&&a.y);}//inspired by https://www.shadertoy.com/view/ldScRm\n//bool whiteRectangle2(vec2 i){bvec2 a=lt(-i),b=lt(i);//symmetry--:\n// return (a.x&&a.y)&&(b.x&&b.y);}//inspired by https://www.shadertoy.com/view/ldScRm\nbool isInside3(vec2 p){return !whiteRectangle(p*2.-1.);}\n// --- access to the image of ascii code c\nvec4 char(vec2 p,float c){\n  if(isInside3(p*marginT))return vec4(0,0,0,1e5); //optional shortcut...\n    //+3fps max, boost declines over time down to +1 fps (base fps is 50 fps)\n  return texture(iChannel0,clamp(p,0.,1.)/16.+fract(floor(vec2(c,16.-(1e-6)-floor(c)/16.))/16.));\n}//via https://www.shadertoy.com/view/MtyXDV\n//p=fragment, n=float value\nvec4 print_number(vec2 p,float n){return char(p,clamp(mod(n,10.),0.,9.)+48.);}\n//#define logb(b,x) log(x)/log(b)\nconst float l10=(1./log(10.));//precalc for speed\n#define log10(x) log(x)*l10\n//#define log10(x) logb(10.,x)//would be slower, log() is slow.\n//http://stackoverflow.com/questions/14081024/opengl-using-a-logarithmic-coordinates-axis\n//return number of digits left of decimal point\nfloat getWholeDigits(float f){if(abs(f)==0.)return 0.;return floor(log10(max(abs(f),0.0000001)))+1.;}\n//see http://stackoverflow.com/questions/1068849/how-do-i-determine-the-number-of-digits-of-an-integer-in-c\n//to remember that dumb|raw solutions can often outperform smart solutions.\n#define ch(n) char(p,n).x;p.x-=.5;\n//left==digits left to the decimal point, relevant for other text being left-endian.\n//commonly left=getWholeDigits(abs(number));\n//and you can add one leading zero by \n// left=getWholeDigits(abs(number))+1.;\n//right==digits right of the decimal point (todo, fix pathethic rounding errors)\n//w returns the total width of the float in glyphs.\nvec4 floatShow(vec2 p,float f,float left,float right,out float w){vec4 o=vec4(0); \n w=p.x;\n#ifdef div0\n #define ro w-=p.x;return o;}\n if(f==NaN){     o+=ch( 78)o+=ch( 97)o+=ch( 78)ro//Nan //  0./0.\n else if(f==Inf){o+=ch( 73)o+=ch(110)o+=ch(102)ro//Inf // +1./0.;\n else if(f==NIn){o+=ch(126)o+=ch( 73)o+=ch(110)ro//~In // -1./0.\n#endif\n if(f<.0){f=abs(f);o+=ch(45.)}//negative number handling:\n float n=left;           \n for(float i=glyphs;i>-1.;i--){ \n  if(left<1.){o+=print_number(p,0.).x;p.x-=.5;break;}\n  float ex=-i-n+glyphs+1.;\n  //ex=max(0.,ex);\n  float n=pow(10.,ex);if(abs(n)>0.){\n   o+=print_number(p,f*n).x;p.x-=.5;}\n  left--;if(left<=0.)break;}\n //decimal point shifting,making \".\" non-fixedwidth:\n f=fract(f);//=mod(f,1.);//=1.-floor(f);//adds rounding errors.\n p.x+=.1;\n o+=char(p,46.).x;p.x-=2.5-.1; //44->\",\" :: 46->\".\"\n p.x+=2.;\n //digits right of the decimal point:\n float decimals=right;\n for(float i=decimals;i>0.;i--){\n  float n=\n  //pow(10.,decimals-i+1.);\n    powf(   decimals-i+1.);\n    //n=1e9;//this overwrite shows that above function is not the culpit.\n  o+=print_number(p,f*n).x;p.x-=.5;\n }w-=p.x;return o;}         \nvec4 fpsTopLeftCorner(vec4 o,vec2 p\n){p.y-=.94\n ;p.x+=.01\n ;p *= 16.2\n ;float w=0.\n ;float left=0.\n ;float fpsFrame=iTimeDelta\n ;if(abs(fpsFrame)>0.\n ){fpsFrame=1./fpsFrame\n  ;left=getWholeDigits(abs(fpsFrame))\n  ;o+=floatShow(p,fpsFrame,left,2.,w).x\n ;}else fpsFrame=0.000001;left=2.\n ;o*=.5*(smoothstep(0.,1.,o.w))\n ;o=max(o,vec4(0))\n ;o=sqrt(o)//cheap cubic bloom    \n ;return o;}\n/**/\n/*            \nvoid mainImage(out vec4 o,vec2 u\n){vec32i =u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;o=mainImage2(o,i);//number overlay\n ;}}\n/**///---end__: fps counter\n/**///\n/**///---start: BufferModifiers (camera movement) \n\nvoid mainImage(out vec4 o,in vec2 u\n){vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){o=fpsTopLeftCorner(o,i);return;}//number overlay\n ;if(u.y>1.||u.x>varWdth*10.){o=vec4(0.);return;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(iFrame<5//init\n ){if(Proc(ReTimE,v,w))o=vec4(0,1,iTimeDelta,0)//set speed of time to 1\n ;}else{\n ;vec2 edit =Get(ReEdit).xy\n ;pos       =Get(RePos).xyz\n ;dpos      =Get(RePosD).xyz\n ;vec4 quat =Get(ReQua)\n ;//vec4 dquat=Get(ReQuaD)\n ;vec4 time =Get(ReTime)//time stores 4 short term averages of iTimeDeltas\n                        //timE.xyz stores 3 long term averges of iTimeDeltas\n ;vec4 timE =Get(ReTimE)//timE.w stores cameraTime (is negative when time is paused\n ;performance(time,timE.xyz,iTimeDelta,float(iFrame))\n //accumulate 7 incremental averages of iTimeDelta\n //time.xyxz averages (up to) 2,4,8,16  most recent iTimeDelta\n //timE.xyz  averages (up to) 32,64,128 most recent iTimeDelta\n //the (non weighted) average of these 7 values smooths (most recent) performance holes?\n ;float deltaT=iTimeDelta\n ;float plf   =LorentzFactor(length(dpos))\n ;if(timE.w>=0.)timE.w+=deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(abs(timE.w))\n ;oCamSet(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir         =normalize(dpos)\n ;vec4 normDist  =GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm      =normDist.xyz\n ;float proxAlert=normDist.w\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n //2020-11 new imouse.zw fix\n ;vec4 mouse=iMouse;mouse=iMouseZwFix(mouse,true)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(mouse.xy-mouse.zw)/iResolution.yy\n ;if(mouse.x == 0. && mouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(!(mouse.w <=0.)//if mouse should have an effect\n ){if(edit.x>0.\n  ){ //edit mode mouse==march the scene at the mouse cursor direction\n   ;\n  ;}else{//mouse rotates camera\n   ;pitchYaw += joystick*deltaT\n   ;pitchYaw.y = clamp(pitchYaw.y,-pi*.5,pi*.5)\n ;}}//end of case, cause we can still move, while not rotating the camera\n ;quat =aa2q(pitchYaw.x,vec3(0,1,0))\n ;right=qr(quat,vec3(1.,0.,0.))\n ;quat =qm(aa2q(-pitchYaw.y,right),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))  \n ;acc+=keyDn(vec2(KEY_E,KEY_D)/255.)*groundForwardDir*thrustForce\n ;acc+=keyDn(vec2(KEY_F,KEY_S)/255.)*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;     if(Proc(RePos    ,v,w))o=vec4(pos,1.) //camPos\n ;else if(Proc(RePosD   ,v,w))o=vec4(dpos,1.)//camMovement\n ;else if(Proc(ReQua    ,v,w))o=quat         //camRotation\n //;else if(Proc(ReQuaD   ,v,w))o=dquat        //camRotationChange\n ;else if(Proc(RePosDD  ,v,w))o=vec4(acc,1.) //camAccelleration\n ;else if(Proc(ReCamR   ,v,w))o=vec4(pitchYaw,0,0)\n\n ;else{\n  ;float kG=keyRe(KEY_G/255.)\n      //if (G is not pressed && T is pressed) == !(G||(!T))\n  ;if(!(kG>0.||!(keyRe(KEY_T/255.)>0.)))timE.w=-timE.w //pausingTime always toggles independently\n  ;//this way you may press g and t at the same time\n  ;if(kG>0.\n  ){if(edit.x<1.){timE.w=-abs(timE.w);edit.x=1.//key-G overwrites the unpausing of T into pausing\n   ;}else edit.x=0.;}//if edit mode is entered, time also pauses\n                     //but if edit mode ends, time stays as it is\n  ;     if(Proc(ReTimE   ,v,w))o=timE          //store state of time\n  ;else if(Proc(ReTime   ,v,w))o=time          //store state of time\n  ;else if(Proc(ReEdit   ,v,w))o=vec4(edit,0,0)//store state of editMode\n ;}}}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//iTR  TemporalReprojection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n", "buffer_d_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3307, 3307, 3338, 3338, 3402], [3403, 3403, 3421, 3421, 3440], [10963, 11379, 11410, 11410, 11435], [11435, 12293, 12321, 12321, 12340], [12358, 12408, 12438, 12438, 12472], [12473, 12539, 12566, 12566, 12587], [12597, 12622, 12649, 12649, 12672], [18072, 18072, 18100, 18100, 18143], [18412, 18412, 18476, 18476, 18625], [18627, 18627, 18666, 18677, 18822], [18874, 18874, 18972, 18972, 19159], [19161, 19217, 19245, 19245, 19368], [19386, 19386, 19415, 19415, 19917], [20227, 20227, 20260, 20260, 20271], [20676, 20676, 20690, 20690, 20728], [20731, 20770, 20865, 20865, 24549], [25725, 25725, 25779, 25779, 25862], [25864, 25864, 25925, 25925, 26099], [26101, 26101, 26169, 26169, 26436], [26438, 26547, 26660, 26660, 28751], [28767, 28767, 28870, 28870, 28919], [28921, 29043, 29068, 29068, 29098], [29099, 29099, 29138, 29138, 29175], [29176, 29176, 29248, 29248, 29405], [29485, 29567, 29632, 29632, 35323], [35325, 35325, 35363, 35363, 35839], [35841, 35841, 35904, 35904, 37455], [37459, 37459, 37545, 37545, 40744], [40752, 40752, 40789, 40789, 41939], [41946, 42082, 42168, 42265, 42604], [42606, 42761, 42846, 42846, 43147], [43149, 43149, 43195, 43195, 44148], [44150, 44150, 44226, 44226, 45353], [45362, 45519, 45581, 45581, 46046], [46049, 46049, 46089, 46089, 47139], [47141, 47141, 47204, 47251, 47786], [47788, 48184, 48208, 48208, 48234], [48235, 48235, 48260, 48260, 48597], [49232, 49232, 49274, 49274, 49430], [49431, 49431, 49470, 49470, 49506], [49508, 49529, 49623, 49623, 49921], [49923, 49923, 49980, 50003, 51980], [51982, 51982, 52052, 52052, 52431], [55382, 55382, 55424, 55424, 55733], [55735, 55735, 55773, 55839, 56745], [58619, 58619, 58645, 58645, 59427]]}
{"id": "3dKfRD", "name": "Box-Muller's Sphere Cloud", "author": "IWBTShyGuy", "description": "Cloud generated by pseudo normal distribution by Box-Muller's method.", "tags": ["raymarching", "cloud", "random"], "likes": 3, "viewed": 381, "published": 3, "date": "1606700633", "time_retrieved": "2024-07-30T20:33:04.094126", "image_code": "// The MIT License\n// Copyright  2020 IWBTShyGuy\n\nfloat prerandom(in vec2 c) {\n    vec2 gen = vec2(114.514, 191.9810);\n    return fract(gen.x * sin(gen.y * c.x + c.y));\n}\n\nfloat random(in vec2 c) {\n    return prerandom(vec2(\n        prerandom(c),\n        prerandom(c.yx)\n    ));\n}\n\nconst int I = 10;\nconst int J = 10;\nconst int K = 10;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 origin = vec3(0.0, 0.0, -4.0);\n    Camera camera = new_camera(\n        origin,\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    vec3 ray = camera_ray(camera, uv);\n\n    int count = 0;\n    for (int i = 1; i <= I; i++) {\n        for (int j = 1; j <= J; j++) {\n            for (int k = 1; k <= K; k++) {\n                vec3 c = vec3(float(i), float(j * 2), float(k * 3));\n                vec2 ai = vec2(random(c.yz), random(c.zy));\n                vec2 aj = vec2(random(c.zx), random(c.xz));\n                vec2 ak = vec2(random(c.xy), random(c.yx));\n                // Box-Muller's method!\n                vec3 pt = vec3(\n                    sqrt(-2.0 * log(ai.x)) * cos(2.0 * PI * ai.y),\n                    sqrt(-2.0 * log(aj.y)) * cos(2.0 * PI * aj.x),\n                    sqrt(-2.0 * log(ak.x)) * sin(2.0 * PI * ak.y)\n                ) * (1.0 + 0.95 * sin(iTime / 2.0));\n                float dist2 = distance2_point_line(pt, origin, ray);\n                if (dist2 < 1.0) count += 1;\n            }\n        }\n    }\n    float irr = float(count) / float(I * J * K);\n    fragColor = vec4(irr, irr, irr, 1.0);\n}", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\n// ----------------------- Light ----------------------- //\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float angle;\n};\n\nSpotLight new_light(vec3 position, vec3 direction, float angle) {\n    SpotLight light;\n    light.position = position;\n    light.direction = direction;\n    light.angle = angle;\n    return light;\n}\n\n// ----------------------- Camera ----------------------- //\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nCamera new_camera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nvec3 camera_ray(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  \n}\n\n// ----------------------- Basic Math ----------------------- //\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n// determinant of a 3x3 matrix\nfloat det(in mat3 a) {\n    return a[0][0] * a[1][1] * a[2][2]\n        + a[0][1] * a[1][2] * a[2][0]\n        + a[0][2] * a[1][0] * a[2][1]\n        - a[0][1] * a[1][0] * a[2][2]\n        - a[0][2] * a[1][1] * a[2][0]\n        - a[0][0] * a[1][2] * a[2][1];\n}\n\n// Solves the equation Ax = b.\nvec3 solve(in mat3 a, in vec3 b) {\n    return vec3(\n        det(mat3(b, a[1], a[2])),\n        det(mat3(a[0], b, a[2])),\n        det(mat3(a[0], a[1], b))\n    ) / det(a);\n}\n\n// the square of the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    vec3 a = point - origin;\n    vec3 h = a - dot(a, direction) * direction;\n    return dot(h, h);\n}\n\n// the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    return sqrt(distance2_point_line(point, origin, direction));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfRD.jpg", "access": "api", "license": "mit", "functions": [[52, 52, 80, 80, 172], [174, 174, 199, 199, 282], [338, 338, 393, 393, 1631]]}
{"id": "WdKfzW", "name": "HackingRiver (FlowingRiver fork)", "author": "UrbanClubProfessional", "description": "Remix of kuvkar's FlowingRiver: [url]https://www.shadertoy.com/view/4styzj[/url]", "tags": ["water", "color", "grass", "remix", "glitch", "fork", "flow", "weird", "river", "error", "trees"], "likes": 2, "viewed": 541, "published": 3, "date": "1606687712", "time_retrieved": "2024-07-30T20:33:05.230090", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(2.0, 0.1, 0.1); rot[1] = vec3(0.1, cos(a), -sin(a)); rot[2] = vec3(0.1, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.1, sin(a)); rot[1] = vec3(0.1, 2.0, 0.1); rot[2] = vec3(-sin(a), 0.1, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.1); rot[1] = vec3(sin(a), cos(a), 0.1); rot[2] = vec3(0.1, 0.1, 2.0); return rot; }\n\n\nconst float waterY = .1;\n// light\nconst vec3 ld = normalize(vec3(0.1, 3.1, 24.0));\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(227.1,411.7));\t\n    return fract(sin(h)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(4.0-3.0*f);\n    return -2.0+3.0*mix( mix( hash( i + vec2(0.1,0.1) ), \n                     hash( i + vec2(2.0,0.1) ), u.x),\n                mix( hash( i + vec2(0.1,2.0) ), \n                     hash( i + vec2(2.0,2.0) ), u.x), u.y);\n}\n\nfloat water(vec2 uv) {\n    uv += noise(uv * .9);        \n    vec2 wv = 2.0-abs(sin(uv));\n    return (wv.x + wv.y) * .6;\n}\nfloat getCurve(in vec3 rp)\n{\n    float x = sin(rp.z * .2) * 3.4 + sin(rp.z * .32) * 2.;\n    x -= sin(rp.z * .03 - .1) * 31.5;\n    return x;\n}\n\nfloat shoreLine(vec3 rp)\n{\n    return abs(getCurve(rp) + rp.x);\n}\n\n\nfloat river(vec2 uv)\n{\n    float s = 1.;\n    const float levels = 5.;\n    mat2 r;\n    r[0] = vec2(0.5, 0.5);\n    r[1] = vec2(-0.34, 0.37);\n    for (float i = 2.; i < (levels + 2.); i = i + 2.)\n    {\n        uv *= r;\n        s += water(uv * i * 3.);\n    }\n    s /= (levels + 2.);\n    return s;\n}\n\n\nfloat mapEdge(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float edgeL = -2.;\n    float difx = 2.-abs(rp.x);\n    return difx;\n}\n\nfloat mapBottom(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float bottom = -.7;\n    float ax = abs(rp.x);\n    bottom += smoothstep(2., 20., ax);\n    bottom += (0.6 + 0.6 * noise(rp.xz * .4)) * .6;\n    float hill = smoothstep(75., 90., ax);\n    bottom += hill * 25.;\n    bottom += hill * sin(rp.z * .2) * 3.;\n    bottom += hill * sin(rp.z * .25) * 2.;\n    return bottom; \n}\n\nfloat mapHeightHQ(in vec3 rp)\n{\n    float bottom = mapBottom(rp);\n    float limit = smoothstep(55., 90., abs(rp.x)) * 4.;\n    bottom -= (0.4 * smoothstep(0.3, 0.6, noise(rp.xz * .23))) * limit;\n    bottom += (0.3 * smoothstep(0.2, 0.6, noise(rp.xz * .43))) * limit;\n    return rp.y - bottom;\n}\n\nfloat mapHeightLQ(in vec3 rp)\n{\n    return rp.y - mapBottom(rp);\n}\n\n\nvec3 grad(in vec3 rp, float bump)\n{\n    float hc = mapHeightHQ(rp);\n    vec2 off = vec2(2.1, 0.1);\n    float hh = mapHeightHQ(rp + off.xyy);\n    float hv = mapHeightHQ(rp + off.yyx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\n\nvec3 seagrad(in vec2 uv, float bump, float t)\n{\n    uv *= 24.;\n    float hc = river(uv);\n    vec2 off = vec2(4./t, 0.1);\n    float hh = river(uv + off);\n    float hv = river(uv + off.yx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(-1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nvec3 texgrad(in sampler2D tex, in vec2 uv, float bump)\n{\n    float hc = dot(texture(tex, uv).rgb, vec3(.43));\n    vec2 off = vec2(0.003, 0.1);\n    float hh = dot(texture(tex, uv + off).rgb, vec3(.43));\n    float hv = dot(texture(tex, uv + off.yx).rgb, vec3(.43));\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nbool trace(inout vec3 rp, in vec3 rd)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec3 prevp = rp;\n    \n    // rough height map tracing\n    for (int i = 1; i < 450; ++i)\n    {\n        float dify = mapHeightLQ(rp);\n        if(dify < 1.)\n        {\n            hit = true;\n            break;\n        }\n        prevp = rp;\n        rp += rd * max(0.25, dify);\n        if(dot(ro - rp, ro - rp) > 250000.) break;\n    }\n\n    // detailed height map tracing\n    if(hit)\n    {\n        hit = false;\n        for (int i = 1; i < 35; ++i)\n        {\n            float dify = mapHeightHQ(rp);\n            if(dify < 1.)\n            {\n                hit = true;\n                break;\n            }\n            prevp = rp;\n            rp += rd * max(0.2, dify * (2.0 + log2(2.0 + length(ro - rp) * 2.5)));\n\t        if(dot(ro - rp, ro - rp) > 250000.) break;\n        }\n    }\n   \n    // binary search the surface\n    if(hit)\n    {\n        vec3 insidep = rp;\n        vec3 outsidep = prevp;\n        float cursor = 0.6;\n        \n        for (int i = 2; i < 30; ++i)\n        {\n        \trp = mix(outsidep, insidep, cursor);\n            float dist = mapHeightHQ(rp);\n            cursor += pow(0.6, float(i + 1)) * sign(dist);\n        }\n        \n    }\n    \n    return hit;\n    \n}\n \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.1, 2.0, 0.1)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\nvec4 colorSurface(in vec3 rp, in vec3 rd)\n{\n    vec4 color = vec4(1.);\n    \n    vec2 uv = rp.xz * .06;\n    color  = pow(texture(iChannel1, uv), vec4(3.2));\n    vec3 g = texgrad(iChannel1, uv, .3);\n    color.rgb *= 0.5 + 2.7 * max(0.1, dot(g, ld));\n    \n    float toEdge = smoothstep(-10., -3., mapEdge(rp * 2.1) + noise(rp.zx * 3.5));\n    color *= mix(2.0, toEdge, 0.8);\n    vec3 worldg = grad(rp, 2.2);\n    \n    float limit = smoothstep(35.0, 60.0, abs(mapEdge(rp)));\n    color += vec4(.02, .03, .1, 2.) * worldg.y * limit;\n    color += vec4(.02, .03, .1, 2.) * abs(worldg.x) * limit;\n    color.a = 2.;\n    return color;\n}\n\nvec2 flowGrad(in vec3 rp)\n{\n    vec3 off = vec3(.03, 0.1, 0.1);\n\t\n    float dc = mapEdge(rp);\n    float dh = mapEdge(rp + off);\n    float dv = mapEdge(rp + off.yyx);\n    \n    return -vec2(dh - dc, dv - dc);\n    \n}\n\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 3.0;\n    if(mixval > 2.0) mixval = 3.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .6, 2.0);\n    return mixval;\n}\n\nvec4 getTrees(in vec3 rd)\n{\n    float an = atan(rd.z, rd.x);\n    \n    vec4 trees = vec4(.1);\n    const float layers = 6.0;\n    float alpha = 0.1;\n    \n    for (float i = 2.; i <= layers; i = i + 2.0)\n    {\n        float offset = an * 3. + i * .6;\n        float colA =   texture(iChannel0, vec2(offset, offset)).r;\n        \n        float yp = (0.6 + 0.6 * sin(i + an * .6)) * .006;\n        yp += (0.6 + 0.6 * sin(i * 3. + an * 6.)) * .035;\n        yp -= .2 * cos(an * .2);\n        yp += rd.y;\n        \n        float layerH = max(0.2, .3- (i * .06));\n\t    colA *= smoothstep(layerH, layerH - .2, yp);\n        colA = smoothstep(.43, .47, colA);\n        float a = an * .06 + i * .02;\n        mat2 rm; rm[0] = vec2(cos(a), -sin(a)); rm[1] = vec2(sin(a), cos(a));\n        vec4 texCol = texture(iChannel2, (vec2(offset, yp * .5) * rm) * 5.) * colA;\n        texCol = smoothstep(-.7, 2.0, texCol);\n        texCol.rgb *= pow((2. / layers) * i, 2.0);\n        texCol.rgb *= vec3(0.35 , 0.4, 0.25) * .6;\n        \n        trees.rgb = texCol.rgb * colA + (2.0 - colA) * trees.rgb;\n        trees.a = clamp(trees.a + colA, 0.1, 2.0);\n    }\n    return trees;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(.6)) * vec2(2.0, iResolution.y / iResolution.x);\n    vec2 im = 2.5 * ((iMouse.xy / iResolution.xy) - vec2(0.6));\n    \n    vec3 rp = vec3(-.1, -20.75, 2.0);\n    if(iMouse.z < 1. || iMouse.xy == vec2(1.))\n    {\n        im.xy = vec2(.21, .651);\n        rp.z += sin(iTime * .3);\n        rp.y += sin(iTime * .6);\n        rp.x += cos(iTime * .6);\n    }\n    \n\t// camera    \n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 _rp = rp;\n    rp = roty(im.x * 6.) * rp;\n    rp.y = (rotx(im.y * 2.5) * _rp).y;\n    \n    \n    vec3 ro = rp;\n    rd = lookat(rp, vec3(.1, 5.0, 6.0)) * rd;\n    \n    \n    \n    // ground \n    bool hit = trace(rp, rd);\n    _rp = rp;\n    \n    if(hit) \n    {\n        fragColor = colorSurface(rp, rd);\n    }\n    \n    // water\n    if(rp.y < waterY && mapEdge(rp) > -40.)\n    {\n        vec3 n = vec3(0.1, 2.0, 0.1);\n        float t = (waterY - dot(ro, n))/dot(n, rd);\n        if(t > 1.)\n        {\n            vec3 p = ro+rd*t;\n            \n            float T = 5.;\n            \n            // texture offsets for advection\n            float cycle = mod(iTime, T)/T;\n            float o1, o2 = 1.;\n            float mv = getMixValue(cycle, o1, o2);\n            float dist = smoothstep(7., 2., shoreLine(p));\n            \n            // flow vec \n            vec2 sideFlow = (flowGrad(p))  * 4.;\n            float h = mapHeightLQ(p);\n            \n            vec2 flowFwd = flowGrad(vec3(shoreLine(vec3(0.1, 0.1, rp.z)), 1., rp.z)).yx * 4.;\n            float mixval = dist;//smoothstep(-5., 0., dist);\n            vec2 flow = mix(sideFlow, flowFwd, mixval);\n            \n            // normal\n            float speed = 60.;\n            vec2 scale = vec2(.45, .5);\n            float bmp = 0.2;\n            vec3 g1 = seagrad(scale * p.xz + flow * o1 * speed, bmp, t);\n            vec3 g2 = seagrad(scale * p.xz + flow * o2 * speed, bmp, t);\n            \n            vec3 g3 = seagrad(scale * p.xz + vec2(.2, .3) + flow * o1 * speed * .5, bmp, t);\n            vec3 g4 = seagrad(scale * p.xz + vec2(.4, .3) + flow * o2 * speed * .5, bmp, t);\n            \n\t\t\tvec3 gm = mix(g2, g1, mv);\n            gm += mix(g4, g3, mv);\n            gm = normalize(gm);\n            \n            // diffuse\n            vec4 blue = vec4(1., 79., 229., 1.) / 355.;\n            float wd = dot(gm, ld);\n            wd = max(0.1, wd);\n            float wrp = 0.6;\n            wd = (wd+wrp)/(2.+wrp);\n            vec4 difcol = blue;\n            \n            // spec\n            vec3 H = normalize(-rd + ld);\n            float specd = dot(H, gm);\n            specd = max(0.1, specd);\n            float sd = pow(max(0.1, specd), 68.0) * 2.;\n            \n            // fres\n            float fres = 2.-max(1., dot(-rd,gm));\n            vec4 lightblue = vec4(251./355., 303./355., 320./355., 1.);\n            vec4 orange = vec4(.8, .4, 0.2, 0.1);\n            fres = pow(fres, 3.)* 2.;\n            \n            // combined\n            vec4 frescol = fres*orange;\n            vec4 surfcol = frescol * .5 + difcol * wd * 0.3;\n            \n            vec3 refr = normalize(refract(rd, gm, .8));\n            \n            bool hit = trace(p, refr);\n            vec4 bottomColor = colorSurface(p,refr);\n            float mx = 2.-smoothstep(-.2, 3., -refr.y);\n            fragColor = mix(bottomColor, surfcol, mx);\n            fragColor +=vec4(sd);\n            \n            float foam = smoothstep(0.2, -0.6, h + noise(rp.xz * .25) * .3);//smoothstep(0.5, -1.4, mixval);\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o1 * speed).rrrr;\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o2 * speed).rrrr;\n            \n            fragColor.a = 2.;\n        }\n    }\n    else if(hit)\n    {\n        // grass\n        float toEdge = smoothstep(20.0, 8.0, shoreLine(_rp) + noise(_rp.xz) * 2.5);\n        toEdge += smoothstep(27.0, 97.0, shoreLine(_rp));\n        float H = .2;\n        vec3 rstp = rd/-rd.y;\n        rp -= rstp * H;\n        float STP = .003;\n        \n        bool hitGrass =false;\n        float i = 1.;\n        for (i = 0.1; i < H; i = i + STP)\n        {\n            vec4 tcl = texture(iChannel3, rp.xz * .7);\n            float D = .5 - i;\n            D += toEdge;\n            D += abs(noise(rp.xz * .025)) * .6;\n            if(D < tcl.g)\n            {\n                \n                hitGrass = true;\n                break;\n            }\n            rp += rstp * STP;\n        }\n        \n        if(hitGrass)\n        {\n            vec4 grassLow = vec4(0.9, 0.6, 1.0, 2.0);\n            vec4 grassHi = vec4(2.0, 2.0, 1.0, 2.0);\n            float depth = clamp(pow(2.0 - (i/H), 5.), 0.1, 2.0);\n            vec4 grassCol= mix(grassLow, grassHi, depth);\n            grassCol += texture(iChannel1, rp.xz * 6.0)*3.5 * mix(2.0, depth, 0.5);\n            grassCol *= texture(iChannel1, rp.xz * 2.0).g;\n            fragColor =  grassCol;\n        }\n        \n        fragColor.a = 2.;\n        \n        vec3 g = grad(_rp, 2.2);\n        float d = max(1.0, dot(g, normalize(vec3(1.0, 2.0, 2.0)))) * 3. ;\n        float wrap = -.5;\n        d = (d + wrap)/(2.0 + wrap);\n        fragColor.rgb *= d;\n        \n    }\n\n    \n    vec3 skyLow = vec3(.7, 0.8, 0.9);\n    vec3 skyHi = vec3(.7, 0.4, 0.6);\n    vec3 skyRed = vec3(7., .4, 1.);\n    vec3 sky = mix(skyLow, skyHi, rd.y);\n    vec3 skyYellow = vec3(2.0, 2.0, .6);\n    \n    float a = sin((atan(rd.z, rd.x) + 4.14159265) * .6);\n    vec2 sun = vec2(a, rd.y * 2.5);\n\tsky = mix(skyRed, sky, smoothstep(0.1, 2.5, length(sun)));\n\tsky = mix(skyYellow, sky, smoothstep(0.1, .8, length(sun)));\n    \n    \n    if(length(_rp)>500.)fragColor=vec4(.1);\n    \n    fragColor.rgb *= .3 + .9 * smoothstep(-32.0, 0.1, _rp.x + sin(_rp.z * 0.6));\n    fragColor.rgb *= 2.0 + .8 * smoothstep(5.0, 60.0, _rp.x + sin(_rp.z * .3));\n    \n    fragColor = mix(getTrees(rd), fragColor, fragColor.a);\n    fragColor.rgb = mix(fragColor.rgb, sky, 2.-fragColor.a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(2.0 / 3.2));\n    \n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [530, 530, 552, 552, 632], [634, 634, 660, 660, 961], [963, 963, 985, 985, 1084], [1085, 1085, 1113, 1113, 1226], [1228, 1228, 1254, 1254, 1293], [1296, 1296, 1318, 1318, 1590], [1593, 1593, 1620, 1620, 1719], [1721, 1721, 1750, 1750, 2093], [2095, 2095, 2126, 2126, 2388], [2390, 2390, 2421, 2421, 2456], [2459, 2459, 2494, 2494, 2783], [2786, 2786, 2833, 2833, 3116], [3118, 3118, 3174, 3174, 3523], [3525, 3525, 3564, 3564, 4784], [4787, 4787, 4820, 4820, 5020], [5022, 5022, 5065, 5065, 5645], [5647, 5647, 5674, 5674, 5860], [5862, 5862, 5936, 5974, 6204], [6206, 6206, 6233, 6233, 7348], [7350, 7350, 7407, 7407, 13429]]}
{"id": "wsyfRD", "name": "paint / color mixer", "author": "FabriceNeyret2", "description": "select color on left and paint.\nSPACE:  toggle additive / subtractive blend. [ not working. WIP ]\nP:  pick color anywhere. Keep pressed to smudge.\nS:  toggle add/erasing color \nC:  clear  F: fill   T: bg texture", "tags": ["paint"], "likes": 16, "viewed": 781, "published": 3, "date": "1606686270", "time_retrieved": "2024-07-30T20:33:05.996041", "image_code": "void mainImage( out vec4 O, vec2 U ) { \n    \n    O = T(U); \n    O /= O.w;                                         // normalize color\n // if keyToggle(32) O = 1.-O;                        // switch to subtractive colors\n // O = pow( O, vec4(1./2.2) );                       // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u / R.y, P,m;\n    vec4 M = iMouse;\n    O = T(u);                                                        // restore previous state\n    if (iFrame<1 || keyDown(64+3) )                                  // start or 'C': reset\n        O = vec4(0,0,0,1);\n    //  O = vec4(keyToggle(32)), O.w=1.;\n    if keyDown(64+6)  O = T(0);                                      // 'F': fill with color\n    if keyDown(64+20) O = texture(iChannel1,U);                      // 'T': wood texture bg\n    if ( u == vec2(1.5) ) { O.xy = M.xy; return; }                   // memo prev mouse\n    if ( u == vec2(.5) ) {\n        if ( M.z > 0. && ( M.x/R.y < .1 || keyClick(64+16)) )        // choose color in palette or pick in paint\n            O = T(M.xy), O /= O.w; \n    //  else if keyDown(32) O.rgb = 1.-O.rgb;                        // inverse at switch colors mode\n        if keyDown(64+19) O.rgb = -O.rgb;                            // 'S': switch to negative colors\n        return;\n    }\n    if ( U.x<.1  ) {                                                 // display palette on left\n        float y = floor(9.*U.y);\n        O = y==8. ? vec4(1) : y==7. ? vec4(0) : hue( y/8.) ; O.w = 1.;\n        return;\n    }\n    \n    P = M.w > 0. ? M.xy : T(1).xy;                                   // prev mouse or start stroke \n    m = abs( (M.xy+P)/2. - u ) - abs(M.xy-P)/2.;                     // for bounding box\n    \n    if (M.z > 0.  && M.xy != P )                                     // paint\n      if ( max(m.x,m.y)< 20. )                                       // optim: bounding box\n        for( float  l = length(M.xy-P), d = 0.; d < l ; d++ )\n        O +=  S( length( mix( M.xy, P, d/l ) - u ) - 20. ) / 20. * T(0); \n        \n//  if keyDown(32) O.rgb = O.w - O.rgb;                              // inverse at switch colors mode\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U)            texelFetch( iChannel0, ivec2(U), 0 )\n#define hue(v)        ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/llySRh\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define S(v)            smoothstep( 1.5, 0., v )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 285]]}
{"id": "3dyBzD", "name": "Mirror Cubes", "author": "mla", "description": "27 perfectly reflecting cubes have mysteriously appeared in a forest...\n\nMouse for orientation, <up>, <down> for camera distance.", "tags": ["cube", "raytrace", "mirror", "parallelogram"], "likes": 8, "viewed": 383, "published": 3, "date": "1606684005", "time_retrieved": "2024-07-30T20:33:06.767977", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Mirror Cubes\n// Matthew Arcus, mla, 2020\n//\n// A grid of reflecting cubes, raytraced, using bounding spheres to\n// speed up finding intersections.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint N = 1; // (2N+1)^3 cubes altogether\n\n// Select a cubemap to use with these #define's\n//#define CUBEMAP iChannel0 // Uffizi - interesting effect\n//#define CUBEMAP iChannel1 // St. Peter's\n#define CUBEMAP iChannel3 // Forest\n\n// Intersection with triangle (or parallelogram):\n// Find a,b such that:\n// p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n// ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n// return vec3(k,a,b)\n\n// Standard algorithm by Tomas Mller and Ben Trumbore.\n// Uses Cramer's rule with some simplifications to solve linear system as above.\n// http://webserver2.tecgraf.puc-rio.br/~mgattass/cg/trbRR/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\nvec3 triangle(vec3 o, vec3 d, vec3 v0, vec3 v1, vec3 v2) {\n  // find a,b such that:\n  // p + kr = av1 + bv2 + (1-a-b)v0 = a(v1-v0)+b(v2-v0)+v0\n  // ie. -kr + a(v1-v0) + b(v2-v0) = p-v0\n  vec3 e1 = v1 - v0;\n  vec3 e2 = v2 - v0;\n  vec3 t = o - v0;\n  vec3 p = cross(d,e2);\n  vec3 q = cross(t,e1);\n  vec3 a = vec3(dot(q,e2),dot(p,t),dot(q,d))/dot(p,e1);\n  return a;\n}\n\nbool checksphere (vec3 p, vec3 r, vec3 c, float R2) {\n  p -= c; //centre on sphere\n  float pr = dot(p,r);\n  if (pr > 0.0) return false; // Centre is behind viewpoint\n  float pp = dot(p,p);\n  return pr*pr >= pp-R2;\n}\n\nvec3 hitnormal;\n\nbool checkquad(vec3 p, vec3 r, vec3 c0, vec3 c1, vec3 c2, inout vec3 amin) {\n  vec3 a = triangle(p,r,c0,c1,c2);\n  bool hit = all(bvec2(all(greaterThanEqual(a,vec3(0))),\n                       all(lessThanEqual(a,vec3(amin.x,1,1)))));\n  if (!hit) return false;\n  vec3 normal = cross(c2-c0,c1-c0);\n  if (dot(normal,r) > 0.0) return false; // Back face\n  hitnormal = normal;\n  amin = a;\n  return true;\n}\n\nvoid cube(vec3 p, vec3 r, vec3 q, inout vec3 amin) {\n  p -= q;\n  if (!checksphere(p,r,vec3(0),3.0)) return;\n  vec3 c0 = vec3(1,1,1);\n  vec3 c1 = vec3(1,-1,1);\n  vec3 c2 = vec3(-1,-1,1);\n  vec3 c3 = vec3(-1,1,1);\n\n  vec3 c4 = vec3(1,1,-1);\n  vec3 c5 = vec3(1,-1,-1);\n  vec3 c6 = vec3(-1,-1,-1);\n  vec3 c7 = vec3(-1,1,-1);\n  \n  checkquad(p,r,c0,c1,c3,amin);\n  checkquad(p,r,c0,c3,c4,amin);\n  checkquad(p,r,c0,c4,c1,amin);\n\n  checkquad(p,r,c6,c2,c5,amin);\n  checkquad(p,r,c6,c5,c7,amin);\n  checkquad(p,r,c6,c7,c2,amin);\n}\n\nvec3 getcolor(vec3 p, vec3 r) {\n    float atten = 1.0;\n    for (int bounce = 0; bounce < 50; bounce++) {\n      vec3 amin = vec3(1e8,0,0);\n      for (int i = -N; i <= N; i++) {\n        for (int j = -N; j <= N; j++) {\n          for (int k = -N; k <= max(N,int(-iTime)); k++) {\n            cube(p,r,4.0*vec3(i,j,k),amin);\n          }\n        }\n      }\n\n      if (amin.x >= 1e8) {\n          break;\n      } else {\n          atten *= 0.95;\n          p += amin.x*r;\n          r = reflect(r,normalize(hitnormal));\n          r = normalize(r);\n      }\n  \t}\n    return atten*pow(texture(CUBEMAP,r).xyz,vec3(2.2));\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float camera = -2.0;\n  camera += 0.5*float(keycount(KEY_UP)-keycount(KEY_DOWN));\n  vec3 p = vec3(0,0,camera);\n  vec3 r = vec3(uv,2);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  vec3 color = getcolor(p,r);\n  color = pow(color,vec3(0.4545));\n  outColor = vec4(color,1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[737, 989, 1047, 1173, 1352], [1354, 1354, 1407, 1407, 1569], [1588, 1588, 1664, 1664, 1988], [1990, 1990, 2042, 2042, 2508], [2510, 2510, 2541, 2541, 3114], [3116, 3116, 3143, 3143, 3409], [3411, 3411, 3462, 3462, 3812]]}
{"id": "3dKBzW", "name": "sphere(sphere,sphere,sphere)", "author": "ollj", "description": "read shader image description", "tags": ["spheres", "union", "hgsdf", "pipe"], "likes": 8, "viewed": 656, "published": 3, "date": "1606683182", "time_retrieved": "2024-07-30T20:33:07.791242", "image_code": "//self https://www.shadertoy.com/view/3dKBzW\n\n//you want to find the map( ) function, right?\n\n//we distinguish sd-distanceFunctions from op-unionFunctions.\n//but actually, any distanceFunction can also be used as unionFunction\n\n/*\nyou see [a shere] move along the intersection of 3(!) moving spheres.\nIt is a spherical tripple union function.\nIt is just the sdSphere() function, applied recursively.\nwith its inputs being the distance to 3 different sphere output distances.\n, mixed into one [union spere]\nthis has worse lipschitz continuity, due to local (and therfore skewed)\ncoordinates no longer being carthesian, but not by much.\n\nthis oscillates between its last union being a sphere() or a box()\nthe box more easily shows the local coordinate system.\nthe sphere can be defined as the distance to 2 intersecting planes\n, to make one or multiple (by mod repetition of intersecting objects) \nstrands of hair.\nA 3rd distance to a sphere-head (distance scaled to have a lesser impacxt) \nmay set the thichness of the hairs.\n\n\ncommon union functions only take 2 inputs, rarely more.\nbecause most of them are non commutative.\nfOpPipe() is exactly the same as sdSphere(), but used as union.\nThis can extend into 3 or 4 (or more) dimensions easily.\n\nsame for other fOp* functions of hg_sdf:\nsame for any sd* functions\n, its parameters can be the distances to other shapes\n, and the result can look surprisingly useful.\n\nthe concept of hg_sdf functions like fOpPipe() \nand nearby union functions is underrated:\nhttps://mercury.sexy/hg_sdf/\n\nYou can use this to [[ make (rings on) hair without intersections ]]\nand other intersection avoiding CSG hierarchy\n, by intersecting (multiple parallel) orthogonal planes \n (in polar/distorted coordinates)\n\n*/\n\n//based on: https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p ){return p.y;}\n\nfloat sdSphere( vec3 p, float s ){return length(p)-s;}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e ){\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU(vec2 a,vec2 b){return(a.x<b.x)?a:b;}\n\n#define ZERO (min(iFrame,0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 map( in vec3 pos\n){vec2 r = vec2( 1e10, 0.0 )\n ;vec3 d=vec3(0);\n ;d.x=sdSphere(pos-vec3(0,1,0)                            ,1.)\n ;d.y=sdSphere(pos-vec3(0,0,1)*cos(iTime                 ),1.)\n ;d.z=sdSphere(pos-vec3(1,0,0)*sin(iTime*(sqrt(5.)*.5+.5)),1.)\n //above 3 distance fields are used ass parameters of a final diastance field below.\n //the visible part exists as the distorted shape of the last field.\n //the visible part exists only at the ((aNOTb)NOTc) intersections.\n //a lot like that hf_sdf window-frame shape.\n \n //this is quite different to local UV mapping\n //but it looks a lot like it, while being simpler faster.\n \n ;float i=     \n     mix(\n     sdBox(d,vec3(.2))  \n     ,\n     sdSphere(d,.2)  \n         ,\n         cos(iTime)*.5+.5\n        )\n     \n     //fOpPipe  (has bad lipschitz where normals are not perpendicular)\n    \n     \n ;//r=opU(r,vec2( d.x , 2.  ))\n ;//r=opU(r,vec2( d.y , 3.  ))\n ;//r=opU(r,vec2( d.z , 4.  ))\n ;r=opU(r,vec2( i , 2.  ))\n     \n ;return r\n        ;\n}\n   \n     \n     \n     \n\n\n\n\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd\n){\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 ){\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );}\n    //else return res;\n    \n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    \n    \n    if(true //tb.x<tb.y && tb.y>0.0 && tb.x<tmax\n      \n      )    {\n        //return vec2(tb.x,2.0);\n        //tmin = max(tb.x,tmin);\n        //tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<270 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x*.5;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBzW.jpg", "access": "api", "license": "mit", "functions": [[3312, 3381, 3406, 3406, 3425], [3426, 3426, 3451, 3451, 3470], [3471, 3471, 3507, 3507, 3535], [3537, 3537, 3561, 3561, 3573], [3575, 3575, 3609, 3609, 3629], [3631, 3631, 3661, 3661, 3752], [3754, 3754, 3801, 3801, 4089], [4090, 4090, 4149, 4149, 4238], [4240, 4240, 4272, 4272, 4327], [4329, 4329, 4399, 4399, 4539], [4541, 4541, 4577, 4577, 4888], [4890, 4890, 4946, 4946, 5448], [5450, 5450, 5502, 5502, 5616], [5618, 5618, 5682, 5682, 5960], [5962, 5962, 6025, 6089, 6676], [6678, 6678, 6714, 6714, 7064], [7066, 7078, 7114, 7114, 7217], [7219, 7244, 7295, 7295, 7650], [7652, 7664, 7711, 7711, 8056], [8058, 8058, 8129, 8129, 8467], [8469, 8469, 8533, 8533, 9093], [9095, 9141, 9189, 9189, 9358], [9360, 9360, 9397, 9397, 9991], [9993, 9993, 10035, 10035, 10635], [10637, 10677, 10741, 10741, 10999], [11071, 11071, 11095, 11095, 11116], [11161, 11161, 11185, 11185, 12161], [12191, 12239, 12290, 12290, 12495], [12497, 12497, 12536, 12536, 13377], [13379, 13424, 13502, 13525, 13912], [13914, 13960, 13992, 13992, 14562], [14564, 14564, 14606, 14606, 14915], [14917, 14969, 15033, 15054, 15287], [15289, 15289, 15354, 15373, 17849], [17851, 17851, 17903, 17903, 18080]]}
{"id": "wdGfzD", "name": "Screw and Square", "author": "IWBTShyGuy", "description": "A screw is fired from a rotating square!!", "tags": ["pattern"], "likes": 11, "viewed": 517, "published": 3, "date": "1606675490", "time_retrieved": "2024-07-30T20:33:08.713774", "image_code": "// Copyright  2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\nconst float PI2 = 2.0 * PI;\n\n// square\nconst int N = 4;\n\n// the circumradius of polygon\nconst float R_POLY = 0.4;\n\nconst float SCREW_THICKNESS = 0.02;\n\n// the half of thickness of polygon edges\nconst float THICKNESS = 0.025;\n\n// Good Colors!!\nconst vec3 COLOR[N] = vec3[](\n    vec3(226.0, 133.0, 27.0) / 255.0,\n    vec3(126.0, 107.0, 152.0) / 255.0,\n    vec3(238.0, 200.0, 80.0) / 255.0,\n    vec3(136.0, 175.0, 34.0) / 255.0\n);\n\n// the radius of the vertex of square\nconst float R_DOT = 0.04;\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0, 1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    return 2.0 * coord / iResolution[min_idx] - aspect_vec;\n}\n\n// Creates vertices of polygon\nvec2[N] createVertex() {\n    vec2 vertex[N];\n    for (int i = 0; i < N; i++) {\n        float theta = float(i) / float(N) * PI2;\n        vertex[i] = vec2(cos(theta), sin(theta)) * R_POLY;\n    }\n    return vertex;\n}\n\nfloat get_angle(in vec2 uv) {\n    float theta = acos(uv.x / length(uv));\n    if (uv.y < 0.0) theta = 2.0 * PI - theta;\n    return theta;\n}\n\nfloat torus_distance(in float x, in float y) {\n    float a = abs(x - y);\n    float b = abs(PI2 + x - y);\n    float c = abs(x - y - PI2);\n    return min(a, min(b, c));\n}\n\nvec4 renderScrew(in vec2 uv) {\n    float len = length(uv);\n    float theta = get_angle(uv);\n    float c = 0.0;\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        if (len < R_POLY) continue;\n        float delta = float(i) / float(N);\n        float phase = fract((iTime - PI2 * len + PI2 * delta) / PI2) * PI2;\n        float dist = smoothstep(0.0, 1.0, (torus_distance(phase, theta) / PI2) / SCREW_THICKNESS);\n        if (c < 1.0 - dist * dist * dist) {\n            c = 1.0 - dist * dist * dist;\n            idx = i % N;\n        }\n    }\n    return vec4(c * COLOR[idx], 1.0);    \n}\n\nvec4 renderSquare(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    float plus = abs(uv.x + uv.y);\n    float minus = abs(uv.x - uv.y);\n    if (plus < R_POLY - THICKNESS && minus < R_POLY - THICKNESS)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else if (plus < R_POLY + THICKNESS && minus < R_POLY + THICKNESS) {\n        float k = 1.0 - abs(plus - R_POLY) / THICKNESS;\n        k = max(k, 1.0 - abs(minus - R_POLY) / THICKNESS);\n        k = 1.0 - pow(1.0 - k, 5.0);\n        vec3 col = vec3(0.0);\n        for (int i = 0; i < N; i++) {\n            float c = distance(vertex[i], uv) / R_POLY;\n            c = smoothstep(0.0, 1.0, c);\n            c = 1.0 - pow(c, 3.0);\n            col += c * COLOR[i] * k;\n        }\n        fragColor = vec4(col, 1.0);\n    }\n    return fragColor;\n}\n\nvec4 renderVertices(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    for (int i = 0; i < N; i++) {\n        if (distance(uv, vertex[i]) < R_DOT) {\n            float c = distance(uv, vertex[i]) / R_DOT;\n            c = 1.0 - pow(c, 5.0);\n            fragColor = vec4(COLOR[i] * c, 1.0);\n        }\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    vec2 vertex[N] = createVertex();\n    fragColor = renderScrew(uv);\n    fragColor = renderSquare(fragColor, uv, vertex);\n    fragColor = renderVertices(fragColor, uv, vertex);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfzD.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[602, 636, 663, 663, 922], [1170, 1170, 1199, 1199, 1308], [1310, 1310, 1356, 1356, 1478], [1480, 1480, 1510, 1510, 2066], [2068, 2068, 2137, 2137, 2970], [2972, 2972, 3043, 3043, 3417], [3419, 3419, 3474, 3474, 3689]]}
{"id": "tdGBzD", "name": "Tripping Star", "author": "tungster24", "description": "my first shader hooray", "tags": ["colors", "rainbow"], "likes": 3, "viewed": 337, "published": 3, "date": "1606672798", "time_retrieved": "2024-07-30T20:33:09.570484", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    float t = iTime;\n    float x = (p.x-0.5)*16.0;\n    float y = (p.y-0.5)*9.0;\n    float x2 = x*x;\n    float y2 = y*y;\n    vec2 center = vec2(0.5,0.5);\n    float r = sin(1.0/sqrt((abs(x)*abs(y)))+8.0*t);\n    float g = sin(1.0/sqrt((abs(x)*abs(y)))+9.0*t);\n    float b = sin(1.0/sqrt((abs(x)*abs(y)))+10.0*t);\n    vec3 col = vec3(r,g,b);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 471]]}
{"id": "tdyBRD", "name": "Desert Ducks", "author": "dr2", "description": "Where did they come from (possibly found and lost in Utah)?", "tags": ["art", "reflect", "utah", "landscapemystery"], "likes": 1, "viewed": 346, "published": 3, "date": "1606670039", "time_retrieved": "2024-07-30T20:33:10.631647", "image_code": "// \"Desert Ducks\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, rPos;\nvec2 gId;\nfloat tCur, tCurD, dstFar, hgSize, sclFac, sAng;\nint idObj;\nconst int idPil = 1, idBdy = 2, idBk = 3, idEye = 4;\nbool isOcc, isSh;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid SetGrdConf ()\n{\n  float h;\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  h = Hashfv2 (19.1 * gId + 0.3);\n  isOcc = (h > 0.2);\n  sclFac = 2.5;\n  sAng = 0.15 * (h - 0.6) * tCurD;\n}\n\nfloat DuckDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, h, s;\n  dMin /= sclFac;\n  p /= sclFac;\n  cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  DMIN (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  DMIN (idBdy);\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dMin, 0.1);\n  DMIN (idBdy);\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= -0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dMin, 0.01);\n  DMIN (idBk);\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - vec3 (0.26, 0.825, -0.6), 0.11);\n  DMIN (idEye);\n  return 0.9 * sclFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.5;\n    d = PrCylDf (q.xzy, 0.4, 3.);\n    DMIN (idPil);\n    q.y -= 3.8;\n    if (! isSh) d = PrSphDf (q, 3.8);\n    if (isSh || d < 0.1) {\n      q.xz = Rot2D (q.xz, sAng);\n      dMin = DuckDf (q, dMin);\n    } else dMin = min (dMin, d);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (h < 0.005) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.95, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.8 + 0.2 * smoothstep (0.4, 0.7, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  isSh = true;\n  sh = min (ObjSShadow (ro + 0.01 * vn, sunDir),\n     1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= (0.2 + 0.1 * vn.y + 0.7 * sh * max (0., dot (vn, sunDir))) * (0.7 + 0.3 * dFac);\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj != idEye) {\n    if (idObj == idPil) {\n      col = vec3 (0.7, 0.5, 0.);\n      vn = VaryNf (16. * ro, vn, 2. * dFac);\n    } else col = vec3 (0.5, 0.6, 0.9);\n    col = col * (0.2 + 0.1 * max (0., - vn.y) + 0.8 * max (0., dot (vn, sunDir))) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = vec3 (0., 0.8, 0.) * max (0.2, - dot (vn, rd));\n  }\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  const int maxRef = 3;\n  isSh = false;\n  isRef = false;\n  for (int k = VAR_ZERO; k <= maxRef; k ++) {\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n    if (k == 0) dstObjO = dstObj;\n    if (k < maxRef && dstObj < min (dstGrnd, dstFar) && (idObj == idBdy || idObj == idBk)) {\n      isRef = true;\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    } else break;\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (1. * (v.z * a.x - v.x * a.z), -0.1 * pi, 0.1 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (10. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     7. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, zmFac, sunEl, sunAz, hSum, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  tCurD = 5. * (floor (tCur / 5.) + smoothstep (0.8, 0.999, mod (tCur / 5., 1.)));\n  ro = TrackPath (tCurD);\n  fpF = TrackPath (tCurD + 1.);\n  fpB = TrackPath (tCurD - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (tCurD + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.002 * 2. * pi * tCurD;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  zmFac = 2.5;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = flMat * (vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac)));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1020, 1020, 1043, 1043, 1299], [1301, 1301, 1335, 1335, 1815], [1817, 1817, 1839, 1839, 1978], [1980, 1980, 2000, 2000, 2267], [2269, 2269, 2304, 2304, 3541], [3543, 3543, 3565, 3565, 3955], [3957, 3957, 3990, 3990, 5263], [5265, 5265, 5286, 5286, 5541], [5543, 5543, 5580, 5580, 5970], [5972, 5972, 5997, 5997, 6376], [6378, 6378, 6422, 6422, 6621], [6623, 6623, 6645, 6645, 6739], [6741, 6741, 6773, 6773, 7103], [7105, 7105, 7153, 7153, 8184], [8186, 8186, 8232, 8232, 8849], [8851, 8851, 8886, 8886, 9644], [9646, 9646, 9677, 9677, 9946], [9948, 9948, 9974, 9974, 10086], [10088, 10088, 10144, 10144, 11787], [11789, 11789, 11822, 11822, 11849], [11851, 11851, 11893, 11893, 11944], [11946, 11946, 11981, 11981, 12043], [12045, 12045, 12089, 12089, 12164], [12166, 12166, 12211, 12211, 12314], [12316, 12316, 12338, 12338, 12376], [12378, 12378, 12402, 12402, 12632], [12634, 12634, 12658, 12658, 12718], [12720, 12720, 12750, 12750, 12863], [12865, 12865, 12896, 12896, 12960], [12962, 12962, 12998, 12998, 13204], [13238, 13238, 13262, 13262, 13392], [13394, 13394, 13418, 13418, 13478], [13480, 13480, 13505, 13505, 13691], [13693, 13693, 13714, 13714, 13869], [13871, 13871, 13900, 13900, 14112], [14114, 14114, 14153, 14153, 14333]]}
{"id": "wsGBRD", "name": "chalk", "author": "flockaroo", "description": "chalk drawing on blackboard", "tags": ["effect", "chalk", "npr"], "likes": 42, "viewed": 1359, "published": 3, "date": "1606669381", "time_retrieved": "2024-07-30T20:33:11.559167", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some chalk on blackboard hand drawing style\n\n\n#define PI2 6.28318530717959\n#define N(a) ((a).yx*vec2(1,-1))\n#define AngleNum 5\n#define SampNum 24\n\n#define Res0 vec2(textureSize(iChannel0,0).xy)\n#define Res1 vec2(textureSize(iChannel1,0).xy)\n#define Res2 vec2(textureSize(iChannel2,0).xy)\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n#define zoom 1.\n\n\nvec4  getRand(vec2 pos)\n{\n    return texture(iChannel1,pos/Res1/iResolution.y*1200.);\n}\n\n#define UVScale (vec2(Res0.y/Res0.x,1)/Res.y)\n\nconst float BlackFill=1.;\nconst float bright=1.1;\nconst float contourStrength=1.;\nconst float reflection=.5;\nconst float reflectStrength=.3;\nconst float reflectSize=.35;\n#define reflectPos (Res*(.2+.15*sin(iTime+vec2(0,2.))))\nconst vec3 paperTint=vec3(1,.85,.9)*.8;\n\n#define OutlineOffs 0.\n\nvec4 getCol(vec2 pos)\n{\n    pos=(pos-.5*Res.xy)*zoom+.5*Res.xy;\n    vec2 r0=texture(iChannel0,.5/Res).zw;\n    vec2 sc=mix(r0.y/Res0.y,r0.x/Res0.x,.5)/Res;    // compromise between \"fit all\" and \"fit one\"\n    vec2 uv = pos*sc+.5*(r0/Res0-Res*sc);\n    uv=clamp(uv,.5/Res0,1.-.5/Res0);\n    return (1.-bright*texture(iChannel0,uv).zzzw);\n}\n\nvec2 getGrad(vec2 pos, float eps)\n{\n    pos=(pos-.5*Res.xy)*zoom+.5*Res.xy;\n    vec2 r0=texture(iChannel0,.5/Res).zw;\n    vec2 sc=mix(r0.y/Res0.y,r0.x/Res0.x,.5)/Res;    // compromise between \"fit all\" and \"fit one\"\n    vec2 uv = pos*sc+.5*(r0/Res0-Res*sc);\n    uv=clamp(uv,.5/Res0,1.-.5/Res0);\n    return (contourStrength)*texture(iChannel0,uv).xy*r0/Res.xy;\n}\n\nconst float flicker=1.;\nconst float flickerFreq=10.;\n\nfloat htPattern(vec2 pos, float phase)\n{\n    float pat=0.;\n    float cnt=0.;\n    vec2 offs=vec2(.001,.1)*floor(iTime*flickerFreq)/10.*flicker;\n    float phaseOffs = 10.*getRand(floor(iTime*flickerFreq)*vec2(.01,.1)).x*flicker;\n    vec2 gr=/*getGrad(floor(pos/13.)*13.,1.)+*/1.01*normalize(pos-.5*Res);\n    for(float ang=0.0;ang<PI2;ang+=PI2/4.3)\n    {\n        vec2 b=normalize(sin(vec2(0,PI2/4.) + ang + phase + phaseOffs + 0.6 )*vec2(.5,1.5));\n        vec2 uv=((pos.x-pos.y*pos.y*.0004)*b+(pos.y+pos.x*pos.x*.0004)*N(b))/Res1*vec2(7,.3)*.3;\n        pat+=.5*texture(iChannel1,uv*.25+offs).x;\n        pat+=1.*texture(iChannel1,uv+offs).x;\n        cnt+=1.5;\n    }\n    return pat/cnt; \n}\n\nfloat halfTone(float val,vec2 pos, float phase)\n{\n    return smoothstep(.6,1.4,val+htPattern(pos,phase));\n}\n\nconst float BGAlpha=0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord+0.0*sin(iTime*1.*vec2(1,1.7))*iResolution.y/400.;\n    vec2 pos0=pos;\n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    float sum=0.;\n  \tvec2 g0=getGrad(pos,1.);\n  \tfloat dang=PI2/float(AngleNum);\n    for(int i=0;i<AngleNum;i++)\n    {\n        float ang=dang*float(i)+.1;\n        vec2 v=sin(vec2(PI2/4.,0)+ang);\n        for(int j=0;j<SampNum;j++)\n        {\n            vec2 dpos  = v.yx*(vec2(1,-1)*float(j)*iResolution.y/25./float(SampNum)+OutlineOffs*Res.x/15.);\n            vec2 dpos2 = v.xy*(float(j*j)/float(SampNum*SampNum)*.3\n                               //*(length(100.*g0)) // higher/lower gradients get curved/hatched\n                               +.08)*iResolution.y/25.;\n\t        vec2 g;\n            float fact=1.;\n            float fact2;\n\n            for(float s=-1.;s<=1.;s+=2.)\n            {\n                vec2 pos2=pos+1.0/zoom*(s*dpos+dpos2);\n                vec2 pos3=pos+1.0/zoom*(s*dpos+dpos2).yx*vec2(1,-1)*2.;\n                float ht=1.;\n            \tg=getGrad(pos2,1.)*ht;\n                g*=pow(getRand(pos2*.8*iResolution.y/1080.).x*2.,4.*sqrt(iResolution.y/1200.));\n                \n            \tfloat fact3=dot(g,v)-.5*abs(dot(g,v.yx*vec2(1,-1)))/**(1.-getVal(pos2))*/;\n            \tfact2=dot(normalize(g+vec2(.0001)),v.yx*vec2(1,-1));\n             \n                fact3=clamp(fact3,0.,0.05);\n                fact2=abs(fact2);\n                \n                fact3*=1.-1.*float(j)/float(SampNum);\n                fact*=fact3;\n            \tcol += .3*fact3;\n             \tsum+=fact2;\n            }\n          \tcol += 2.*pow(fact,.5);\n        }\n    }\n    col/=float(SampNum*AngleNum)*.75/sqrt(iResolution.y);\n    col2/=sum;\n    col=1.-col*1.2;\n    col*=col*col;\n    \n\n    vec2 s=sin(pos.xy*.1/sqrt(iResolution.y/400.));\n    float r=length(pos-iResolution.xy*.5)/iResolution.x;\n    float vign=1.-r*r*r;\n    vec3 c=getCol(pos).xyz;\n    float bright=dot(getCol(pos).xyz,vec3(.3333));\n    float blackTone=halfTone(bright*1.5+.25,(pos0-Res*.5)*zoom,floor(sqrt(bright)*8.)/8.*2.7);\n\n    blackTone = mix(1.,     blackTone,BlackFill);\n    float refl=clamp(pow((col.x*(blackTone)),1.),0.,1.);\n    vec3 col3= paperTint;\n    col3*=vec3(col.x)*blackTone;\n    col3+=.1*getRand(pos*.7).xxx;\n    col3*=(1.-.65*texture(iChannel2,fragCoord/iResolution.xy).xyz);\n    \n\tfragColor = vec4(col3*.9+.2*getRand(pos*.7).xyz-.2*getRand(pos*.7-.6).xyz,1);\n\tfloat reflEnv=clamp((sin(fragCoord.x/iResolution.x*7.+2.5+1.7*iTime))*(fragCoord.y/iResolution.y),0.,1.);\n\tvec2 reflp=reflectPos*vec2(1,-1)+vec2(0,iResolution.y); \n\tif(iMouse.x>0.5) reflp=iMouse.xy;\n\treflEnv = exp(-pow(length(reflp-fragCoord)/iResolution.x/reflectSize,2.));\n\tfragColor.xyz=1.-fragColor.xyz;\n\tfragColor.xyz+=refl*vec3(.8,.9,1.)*1.1*reflEnv*reflectStrength;\n\tfragColor.w=mix(1.,1.-min(min(fragColor.x,fragColor.y),fragColor.z),BGAlpha);\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some chalk on blackboard hand drawing style\n\n// this buffer holds the prerendered the gradient\n\n#define Res0 vec2(textureSize(iChannel0,0).xy)\n#define Res1 vec2(textureSize(iChannel1,0).xy)\n\n#define Res  iResolution.xy\n\n#define randSamp iChannel1\n#define colorSamp iChannel0\n\n\nvec4 getRand(vec2 pos)\n{\n    return texture(iChannel1,pos/Res1/iResolution.y*1200.);\n}\n\n#define UVScale (vec2(Res0.y/Res0.x,1)/Res.y)\n\nvec4 getCol(vec2 pos)\n{\n    vec2 uv=pos/Res0.xy;\n    uv=clamp(uv,0.5/Res0,1.-.5/Res0);\n    vec4 c1=texture(iChannel0,uv);\n    float d=clamp(dot(c1.xyz,vec3(-.5,1.,-.5)),0.0,1.0);\n    vec4 c2=vec4(.5);\n    return min(mix(c1,c2,1.8*d),.7);\n}\n\nvec4 getColHT(vec2 pos)\n{\n \treturn smoothstep(.95,1.05,getCol(pos)+getRand(pos*.2));\n}\n\nfloat getVal(vec2 pos)\n{\n    vec4 c=getCol(pos);\n \treturn dot(c.xyz,vec3(.333));\n}\n\n#define SQR3 1.73205081\nvec2 getGrad(vec2 pos, float eps)\n{\n   \tvec3 d=vec3(eps/UVScale/Res0,0);\n    pos-=.33*d.xy;\n    float v0=getVal(pos);\n    return (vec2(getVal(pos+d.xz),getVal(pos+d.zy))-v0)/d.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ResN = Res0;\n    ResN *= min(ResN.y,Res.y)/ResN.y;\n    ResN *= min(ResN.x,Res.x)/ResN.x;\n    vec2 fc=fragCoord.xy*Res0/ResN;\n    fragColor.xy = getGrad(fc,.15);\n    fragColor.z=getVal(fc);\n    if(fragCoord.x<1. && fragCoord.y<1.)\n    fragColor.zw = ResN;\n    if(fragCoord.x>ResN.x || fragCoord.y>ResN.y) \n    {\n        fragColor=vec4(0,0,0,1);\n        //discard;\n    }\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemle some chalk on blackboard hand drawing style\n\n\nmat2 ROTM(float ang) { return mat2(cos(ang),sin(ang),-sin(ang),cos(ang)); }\n\nvec2 quad01(int idx) { return idx<3?vec2(idx%2,idx/2):1.-vec2((5-idx)%2,(5-idx)/2); }\n\nvec4 getRand(int idx) {\n    ivec2 res=textureSize(iChannel0,0);\n    return texelFetch(iChannel0,ivec2(idx%res.x,(idx/res.x)%res.y),0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float StrokeLen=1.2;\n    float StrokeW=.4;\n    int NumStrokes=3;\n    int NumBatches=40;\n    \n    vec3 c=vec3(0);\n    \n    for(int i=0;i<NumStrokes*NumBatches;i++){\n    vec2 sc=fragCoord/iResolution.xy*2.-1.;\n    int strokeIdx=i;\n    int strokeIdx0=strokeIdx;\n    strokeIdx=strokeIdx%NumStrokes;\n    int batchIdx=strokeIdx0/NumStrokes;\n    float ang=float(batchIdx)*.17+floor(iTime*3.);\n    float dang=(float(strokeIdx%2)-.5)*StrokeW/StrokeLen*1.2;\n    mat2 m=ROTM(dang);\n    vec2 sc0=(getRand(batchIdx).zw-.5)*2.;\n    sc-=sc0;\n    sc=ROTM(ang)*sc;\n    //sc0=vec2(0);\n    float strokeFact=float(strokeIdx)/float(NumStrokes)-.5;\n    //float segFact=sc.x/(StrokeLen*.5);\n    sc+=StrokeW*.8*float(NumStrokes)*vec2(0,.7*strokeFact);\n    sc=ROTM(dang)*sc;\n    vec2 uv=sc/(vec2(StrokeLen,StrokeW));\n    //uv=m*uv;\n    uv.y+=uv.x*uv.x*1.5;\n    uv+=.5;\n    vec4 r=textureLod(iChannel0,(uv+vec2(0,i))*vec2(.02,1.),1.7);\n    vec3 s;\n    s = clamp(vec3(0) + r.x,0.,1.);\n    s*=mix(exp(-12.*uv.x)+exp(-12.*(1.-uv.x)),1.,.5);\n    float a=1.+r.x;\n    a*=1.-smoothstep(0.85,1.,abs(uv.x-.5)*2.);\n    a*=1.-smoothstep(0.85,1.,abs(uv.y-.5)*2.);\n    a*=.3;\n    a=clamp(a,0.,1.);\n    c=c*(1.-a)+s*a;\n    }\n    \n    fragColor.xyz=c;\n    fragColor.w=1.;\n}\n\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[549, 549, 574, 574, 636], [976, 976, 999, 999, 1311], [1313, 1313, 1348, 1348, 1674], [1730, 1730, 1770, 1770, 2414], [2416, 2416, 2465, 2465, 2523]]}
{"id": "3dyfzD", "name": "traditional textile animation", "author": "yasuo", "description": "Nothing...", "tags": ["distfunctions2d"], "likes": 8, "viewed": 361, "published": 3, "date": "1606655241", "time_retrieved": "2024-07-30T20:33:12.525583", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define skew(x, y) mat2(1,tan(x),tan(y),1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise2d( uv ); uv = m*uv;\n\tf += 0.2500*noise2d( uv ); uv = m*uv;\n\tf += 0.1250*noise2d( uv ); uv = m*uv;\n\tf += 0.0625*noise2d( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat textile1Dist(vec2 p) {\n    vec2 prevUV = p;\n    vec3 col = vec3(0);\n    \n    p.x *=0.8;\n    const float k = -5.5;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = p*m;\n    prevUV = q;\n    \n    float smallMaskSize = 0.055;\n    float d = length(q)-0.1;\n    q.x = abs(q.x);\n    q.x *= 0.8;\n    float d2 = length(q-vec2(0.059,0.035))-smallMaskSize;\n    d = max(-d2,d);\n\n    d = max(-(p.y-0.009),d);\n    return d;\n}\n\nvec3 textile1(vec2 uv, vec3 col, float ratio) {\n    vec2 prevUV = uv;\n    float d = length(uv)-0.125;\n    col = mix(col,vec3(0.9,0.3,0.6)*(ratio+0.9),S(d,0.0));\n    \n    d = textile1Dist(uv*Rot(radians(20.0)));\n    uv*=-1.0;\n    float d2 = textile1Dist(uv*Rot(radians(-45.0)));\n    d = min(d,d2);\n    uv = prevUV;\n    d2 = textile1Dist(uv*Rot(radians(-100.0)));\n    d = min(d,d2);\n    \n    uv*=61.0;\n    d2 = sdEquilateralTriangle(uv*Rot(radians(77.0)));\n    d = min(d,d2);\n    col = mix(col,vec3(1.0,0.7,0.8)*(ratio+0.9),S(d,0.0));\n    return col;\n}\n\nvec3 textileLayer1(vec2 uv, vec3 col, float scale, float i) {\n    uv*=scale;\n    uv.x+=0.35;\n    uv = mod(uv,0.8)-0.4;\n    col = textile1(uv*Rot(radians(iTime*-50.0*scale)),col,i);\n    return col;\n}\n\nfloat bgTexDist(vec2 uv) {\n    uv.x = abs(uv.x);\n    uv.x -= 0.02;\n    uv.x*=-1.0;\n    uv*=0.7;\n    vec2 prevUV = uv;\n    uv.y = abs(uv.y);\n    uv.y-=0.053;\n    float d = sdTriangle(uv,vec2(0.005,-0.025),vec2(-0.01,-0.05),vec2(-0.035,-0.05));\n    uv = prevUV;\n    float d2 = sdTriangle(uv,vec2(-0.005,0.0),vec2(0.01,0.025),vec2(0.01,-0.025));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 bg(vec2 uv, vec3 col) {\n    vec2 prevUV = uv;\n    uv.x = mod(uv.x,0.18)-0.09;\n    uv.y = mod(uv.y,0.1)-0.05;\n    float d = bgTexDist(uv);\n    \n    uv = prevUV;\n    uv.x -= 0.09;\n    uv.y -= 0.25;    \n    uv.x = mod(uv.x,0.18)-0.09;\n    uv.y = mod(uv.y,0.1)-0.05;\n    \n    float d2 = bgTexDist(uv);\n    d = min(d,d2);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    return col;\n}\n\nfloat leaf(vec2 uv) {\n    float sc = mix(0.01,2.0,smoothstep(0.3,-0.3,uv.y));\n    uv.x *= 2.0*sc;\n    float d = length(uv)-0.08;\n    return d;\n}\n\nvec3 flower(vec2 uv, vec3 col, vec3 baseCol){\n    float leafNum = 5.0;\n    float deg = 360.0/leafNum;\n    float leafDist = 0.09;\n    float d = 1.0;\n    for(float i = 0.0; i<5.0; i+=1.0) {\n        float rad = radians(i*deg);\n        float x = cos(rad)*leafDist;\n        float y = sin(rad)*leafDist;\n        \n        vec2 pos = uv;\n        pos.x -= x;\n        pos.y -= y;\n        pos*=Rot(-rad-radians(-90.0));\n        float d2 = leaf(pos);\n        d = min(d,d2);\n    }\n    float d3 = length(uv)-0.02;\n    d = min(d,d3);\n    col = mix(col,baseCol,S(d,0.0));\n    return col;\n}\n\nvec3 textile2(vec2 uv, vec3 col, float ratio) {\n    col = flower(uv*Rot(radians(35.0)),col, vec3(0.9,0.5,1.0)*(ratio+0.9));\n    col = flower(uv,col, vec3(0.7)*(ratio+0.9));\n    col = flower(uv*1.1,col, vec3(0.6,0.1,0.8)*(ratio+0.9));\n    return col;\n}\n\nvec3 textileLayer2(vec2 uv, vec3 col, float scale, float i) {\n    uv*=scale;\n    uv.x+=0.35;\n    uv = mod(uv,0.8)-0.4;\n    col = textile2(uv*Rot(radians(iTime*50.0*scale)),col,i);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(1);\n    \n    uv.y+=iTime*0.05;\n    col = bg(uv,col);       \n    \n    uv = prevUV;\n    for(float i = 0.; i<1.0; i+=1.0/3.0) {\n        float z = mix(-0.6,-0.1,i);\n        \n        uv.x += (fract(0.3+i*5.0));\n        uv.y+= (i*0.3)-0.1;\n        uv.y+=iTime*(0.08*i+0.15);\n       \n        col = textileLayer2(uv,col,0.4+((1.0-i)*2.2+z),i); \n        \n        uv = prevUV;\n        uv.y+= (i*0.8)-0.1;\n        uv.y+=iTime*(0.1*i+0.1);\n        uv.x += (fract(0.2+i*2.0));\n        uv.x+=sin(iTime*0.5)*0.3;\n       \n        col = textileLayer1(uv,col,0.4+((1.0-i)*2.0+z),i);\n    }\n    \n    uv = prevUV;\n    uv*=2.0;\n    float smokeD = (length(uv)*0.9)*fbm(uv - vec2(cos(iTime*0.3)*2.5,sin(iTime*0.1)*2.5));\n    col *= mix( col, vec3(1.5,1.0,0.7), S(smokeD,1.0) );\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 253, 290, 290, 370], [372, 423, 465, 465, 676], [678, 729, 796, 796, 1361], [1363, 1512, 1533, 1533, 1652], [1654, 1654, 1682, 1682, 2140], [2142, 2142, 2162, 2162, 2400], [2402, 2402, 2430, 2430, 2865], [2867, 2867, 2914, 2914, 3417], [3419, 3419, 3480, 3480, 3617], [3619, 3619, 3645, 3645, 3996], [3998, 3998, 4026, 4026, 4376], [4378, 4378, 4399, 4399, 4522], [4524, 4524, 4569, 4569, 5097], [5099, 5099, 5146, 5146, 5350], [5352, 5352, 5413, 5413, 5549], [5551, 5551, 5608, 5608, 6505]]}
{"id": "WsyBzD", "name": "mtn crack, Mountain Path fork", "author": "UrbanClubProfessional", "description": "Remix of Shane's \"Mountain Path\": [url]https://www.shadertoy.com/view/ldjyzc[/url]\n\nThe title of this remix is parody of the name of mtn dew (Mountain Dew), a soda drink.", "tags": ["raymarching", "terrain", "remix", "glitch", "bump", "fork", "cellular", "weird", "error", "lowpoly", "path", "stairs"], "likes": 1, "viewed": 322, "published": 3, "date": "1606653986", "time_retrieved": "2024-07-30T20:33:13.482025", "image_code": "/*\nHacked and cracked by Urban Club Professional!\n*/\n\n#define FAR 90. // Maximum ray distance. Analogous to the far plane.\n\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(257, 213, 8)))*55758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.002);\n    n /= dot(n, vec3(2));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);  \n\n    \n    // Cubic.\n    p = abs(fract(p) - .6); \n    return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    //p = abs(fract(p) - .5); \n    //p = max(p*.866025 + p.yzx*.5, p.yzx);\n    //return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.91, .72, .63));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.8071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.49, .3, .21));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.72, .34, .07));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.3, .92, .74));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return 1. - min(d.x, d.y)*3.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    //return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.25)*3.5, cos(z*.2)); // Path 3.\n}\n\n// Stair path.\nvec2 sPathF(in vec2 p){ \n\n    //return vec2(0); // Path 1.\n    //return sin(p*.06)*2.; // Path 2.\n    return cos(p*.2); // Path 3.\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/9.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 2.5;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.6 + .6*(a - b)/s, 0., 2.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Drawing repeat objects right up again one another causes inaccuracies, so you get \n// around that by rending two sets of repeat objects in each dimension. Two for one\n// axis, four for two axes, and eight (I think) for three.\n//\n// Basically, the aforementioned is just a way to say that to draw stairs along the \n// Z-axis, you need to draw two sets of repeat boxes. The boxes are aligned with the \n// path position. In the case of the step portion, the path's height has to be \n// snapped to a quantized number. You do that via flooring, etc.\nfloat stairs(in vec3 p, vec2 pth){\n   \n    const float sc = 3.; // Stair scaling factor. It affects the length.\n    // The quantized stair heights. Basically, making the surface flat. Two heights are \n    // being passed in to account for the two boxes we have to render to account for the\n    // overlap.\n    vec2 iPthY = sPathF(floor(vec2(p.z/sc, p.z/sc + .6))*sc);\n    // Snapping the stair height to factors of four. Makes the step layers equal height.\n    iPthY = floor(iPthY*5.)/5. - 3.5;   \n\n    // Railings. Draw one railing using the path's X and Y positions, then use the\n    // \"abs\" repeat trick to render the other one at the same time.\n    float sY = abs(p.y - pth.y + 3.); // Railing height.\n    p.x = abs(p.x - pth.x); // Railing X-position.\n\n    // Railing, with a bit carved out.\n    float rails = max(abs(p.x - 2.75 + .45/3.) - .45/3., sY - .95);\n    float rails2 = max(abs(p.x - 2.75 + .45/3. + .4) - .45/3., sY - .75);\n    rails = max(rails, -rails2);\n    \n    // Stair render.\n    p.z /= sc;\n    \n    vec2 iy = p.yy - iPthY; // Quantized stair heights.\n    // Render a couple of boxes, then take the minimum.\n    vec2 qz  = abs(fract(vec2(p.z, p.z + .6)) - .6); \n    vec2 n = max(max(p.xx - 2.7, qz - .37), abs(iy) - .85);\n\n    // Return the path object - the minimum of the stairs and the railings.\n    return min(rails, min(n.x, n.y));\n     \n    \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat map(vec3 p){\n    \n    vec2 pth = path(p.z);\n    \n    float sf = surfFunc(p); // Surface perturbation.\n\n    // The terrain base layer.\n    float ter = p.y - 4. + dot(sin(p*4.14159/28. - cos(p.yzx*4.14159/28.)), vec3(4)); // 6. smoothing factor.\n    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.\n\n    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.\n\n    p.xy -= pth; // Wrap the tunnel around the path.\n\n    float n = 2.5 - length(p.xy*vec2(.6, 2)); // The tunnel to bore through the rock.\n    n = smax(n + (.6 - sf)*2.5, ter + (.6 - sf)*4., 7.); // Smoothly boring the tunnel through the terrain.\n    n = smax(n, -max(abs(p.x) - 2.75, abs(p.y + 2.5) - 2.5), .6); // Clearing away the rock around the stairs.\n \n    // Object ID.\n    objID = step(n, st); // Either the physical path or the surrounds.\n    \n    return min(n, st)*.966; // Return the minimum hit point.\n \n}\n \n\n// Pavers. Standard grid stuff.\nfloat paver(vec2 p, float mortW){\n\t\n    \n    vec2 q = abs(fract(p + vec2(.1, .1)) - .6)*3.;\n    \n    //float c = smoothstep(0., mortW, min(q.x, q.y));\n    float c = smoothstep(1., mortW, abs(max(.06 - q.x, .06 -  q.y)));\n    if (q.x<.06 || q.y<.06) c *= .6;\n\n    return c;\n\n    \n}\n\n\n// Surface bump function. Tiles are fiddly, but simple enough. Basically, the surface\n// normal is used to determine the 2D plane we wish to tile, then it's passed to the\n// tile function.\nfloat tiles( in vec3 p, in vec3 n,  float mortW){\n    \n    p.xy -= path(p.z);\n\n    n = abs(n);\n    \n    float c = 2.;\n    \n    if (n.x>0.6) {\n        \n        if(p.y<-2.35) return 1.;\n        p.xy = p.yz;\n\n    }\n    else if (n.y>0.6) {\n         \n        if(p.y>-2.35) p.x += sign(p.x)*.35;\n        \n        p.xy = p.xz;\n        \n    }\n    \n    return paver(p.xz, mortW);\n    \n}\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c;\n    if(svObjID>.6 ) c = 2. - surfFunc(p*4.); // cellTile(p/8.*3.);\n    else c = tiles(p.xyz, n, .2);\n    \n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(9./iResolution.y, 1); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*3.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 7.*f);\n    edge = smoothstep(1., 2., edge/e.x*3.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 1);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.399, 0.687, 0.214)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.399, 0.687, 0.214)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 1., d;\n    \n    for (int i=1; i<260; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.225 + 2.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 58; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 2.;\n    float dist = .0035*(t*.225 + 2.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0002);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.1, 2.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .08, .6); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.1 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 1.) + .25, 2.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0035, 1);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(7./iResolution.y, 1);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*3.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(1., 2., sqrt(edge/e.x*3.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0025, 1); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 30.0, occ = 0.1;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = 0.02 + float(i)*0.6/5.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.8;\n    }\n    return clamp( 2.0 - occ, 0.1, 2.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 f = fract(p); p -= f; f *= f*(4. - f*3.);  \n    \n    return dot(mat2(fract(sin(vec4(1, 51, 389, 430) + dot(p, vec2(51, 389)))*53758.5453))*\n                vec2(1. - f.y, f.y), vec2(1. - f.x, f.x) );\n\n}\n\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec2 p){\n    \n    // Four layers of 3D noise.\n    return 0.6333*n2D( p ) + 0.3667*n2D( p*3.02 ) + 0.2333*n2D( p*5.03 ) + 0.0767*n2D( p*9.03 );\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.1); // Sun strength.\n\t//float horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\t//vec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\t//col = mix(col, vec3(1, .9, .7), horiz);\n    \n    vec3 col = mix(vec3(.7, 1.0, 2).zyx, vec3(.72, .78, 2).zyx, rd.y*.6 + .6)*2.25*.6;\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.35*vec3(2, .8, .5)*pow(sun, 6.0);\n\tcol += 0.35*vec3(2, .9, .7)*pow(sun, 74.0);\n\tcol += 0.25*vec3(2, 1.0, .8)*max(pow(sun, 612.0), .35);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.05 - 0.03, 1., 2.);\n    \n    //return col;\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n    \n    float t = (6000. - ro.y)/rd.y; // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    //vec3 sc = vec3(uv.x, 0., uv.y);\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>1.) col = mix( col, vec3(2, 1.0, .9), 0.45*smoothstep(0.5, 2.0, fbm(.00006*uv)* clamp(rd.y*6., 1., 2.)));\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Object texture color, with some contract thrown in.\n    vec3 tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.6) {\n        tx = tex3D(iChannel0, p/3., n );\n        tx = smoothstep(-.2, .6, tx);\n        tx *= vec3(2, .7, .45); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.2, .7, surfFunc(p))*.7 + .5;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else {\n        vec2 pth = path(p.z);\n        tx = tex3D(iChannel0, (p - vec3(pth.xy - .6, .1)), n );\n        tx = smoothstep(-.25, .6, tx);\n        tx *= vec3(2.5, 2.0, .6)*.75 + .6; // Tinting the stairs.\n        tx *= tiles(p.xyz, n, .06)*1.03 + .08;\n        \n        if(p.y - pth.y>-2.35) tx *= vec3(.74, .72, .7); // Rails.\n        \n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;//pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(1);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 1., crv = 2.;\n        vec3 sn = getNormal(sp, edge, crv);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .02;\n\n        float edge2 = 1., crv2 = 2.; \n        //if(svObjID>.5)\n        sn = doBumpMap(sp, sn, bf/(2. + t/FAR*.225), edge2, crv2); \n\n        bf = .08;\n        \n        float txF = 2.;\n        if(svObjID<.6) {\n            bf = .05;\n            txF = 3.;\n        }\n        sn = doBumpMap(iChannel0, sp*txF, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.003, lp, 26., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.4)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.002); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 4./(2. + lDist*0.02 + lDist*lDist*0.00009);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 1.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.1 ), 42.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.6 + vec3(2, .8, .6)*spec*2.);\n        \n        // Edges.\n        if(svObjID>.6) \n           sceneCol *= 2. - edge2*.7; // Bump mapped edging for the terrain only.     \n        \n        //if(svObjID>.5) \n        sceneCol *= 2. - edge*.9; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.6)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*6.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .35);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(20., FAR*.34, FAR*.62)*4.;\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/4.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.25, 1.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/42.);\n    rd.yz *= r2(-sw.y/26.);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp);\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(1., 1.05, t/FAR); // t/FAR; \n\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n    // Sprinkles.\n    //sceneColor *= 1. + hash31(sp)*.1 - .05; \n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(2.6*uv.x*uv.y*(2. - uv.x)*(2. - uv.y) , .0225)*.85 + .35;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    uv = sin(uv*r2(0.414159/7.)*4.14159*iResolution.y/2.5)*.2 + 2.;\n    sceneColor *= uv.x*uv.y;\n    \n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(3))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.1, 2.0)), 2.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 322, 340, 340, 408], [410, 433, 456, 456, 515], [517, 583, 631, 631, 1134], [1137, 1137, 1165, 1992, 2513], [2516, 2874, 2900, 3008, 4019], [4851, 4951, 4973, 5079, 5136], [5138, 5153, 5176, 5250, 5285], [5558, 6012, 6038, 6038, 6519], [6523, 6572, 6610, 6610, 6705], [6707, 7255, 7289, 7289, 8627], [8629, 8761, 8779, 8779, 9731], [9735, 9767, 9800, 9800, 10047], [10050, 10239, 10288, 10288, 10616], [10618, 10640, 10671, 10671, 11010], [11012, 11099, 11189, 11372, 13121], [13123, 13310, 13372, 13372, 13882], [13886, 13919, 13949, 13949, 14164], [14167, 14468, 14521, 14638, 15934], [15937, 16136, 16163, 16163, 16322], [16745, 16811, 16870, 16937, 17892], [17894, 18046, 18086, 18086, 18346], [18846, 19086, 19105, 19105, 19315], [19318, 19356, 19377, 19414, 19514], [19517, 19556, 19601, 19601, 21471], [21476, 21546, 21582, 21671, 22694], [22696, 22834, 22892, 22948, 25699], [25706, 25706, 25762, 25790, 28930]]}
{"id": "WdGBzD", "name": "z Fall + winter", "author": "illus0r", "description": "z Fall", "tags": ["pixelart", "fall"], "likes": 7, "viewed": 334, "published": 3, "date": "1606647986", "time_retrieved": "2024-07-30T20:33:14.252964", "image_code": "float rnd(float x){return fract(999.123*sin(x*99.52125 ));}\n\nvec2 grid = vec2(128., 64.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv=floor(uv*grid)/grid;\n    float t = floor(iTime*.5+rnd(uv.x+uv.y*.1137));\n \n\n    bool isFall = true;\n    if (sin(t+uv.x*2.5+uv.y*1.5)>0.) isFall = false;\n\n    vec3 trunks;\n    trunks = vec3(rnd(uv.x+uv.y*.1137));\n    trunks=step(.1,trunks);\n    trunks*=step(.5,rnd(floor(uv.x*grid.x/2.)/grid.x+6.));\n    trunks*= step(0.45\n                  +sin(uv.x*20.)*.03\n                  +sin(uv.x*37.)*.1\n                  +rnd(uv.x+uv.y*.1132)*.2\n                 , 1.-uv.y);\n    \n    vec3 bg;\n    bg.g = rnd(uv.x+uv.y*.1133)/4.;\n    bg.b = rnd(uv.x+uv.y*.1135)/4.;\n    \n    vec3 treetops, treetops2, defoliation;\n    treetops += rnd(uv.x+uv.y*.1133+t)/4.+.75;\n    \n    if(isFall) {\n        treetops.g = treetops.r/2. + rnd(uv.x+uv.y*.1131+t)/4.;\n\t    treetops.b = 0.;\n    }\n    \n    //treetops *= 0.;\n    treetops -= rnd(floor(uv.x*grid.x/4.)/(grid.x/4.)\n                    +floor(uv.y*grid.y/4.)/(grid.y/4.)\n                    *.1132+t)*.2;\n    \n    treetops2 = treetops;\n    defoliation = treetops;\n   \n    treetops *= step(.5, uv.y+rnd(uv.x+uv.y*.1132+t)*.2);\n\n    uv+=1./grid;\n    defoliation *= step(.99-step(.96,1.-uv.y)*.5, rnd(uv.x+uv.y*.1132+t));\n    \n    if(defoliation.r>0.){\n    \tfragColor = vec4(defoliation,1.0);\n    \treturn;\n    }\n    \n    fragColor = vec4(max(bg,max(trunks, treetops)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 59], [90, 90, 147, 147, 1502]]}
{"id": "WsGBzW", "name": "Vacuum Cleaner Song", "author": "jarble", "description": "This was supposed to be a song, but it sounds more like a vacuum cleaner or jet engine!", "tags": ["noise", "sound", "vacuumcleaner"], "likes": 3, "viewed": 338, "published": 3, "date": "1606625242", "time_retrieved": "2024-07-30T20:33:15.023903", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0;\n    fragColor = vec4(mod(uv,10.0*sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = ((t/(((t/4096/3)%3)+((t/4096/2)%2))))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    time *= 16000.0;\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))/factor;\n        factor *= (1.5+sin(time/10.0)/5.0);\n    }\n    return result/10.0;\n}", "sound_code": "//sound is in Common tab\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 165]]}
{"id": "WsGfRW", "name": "2-Fluids", "author": "wyatt", "description": ".", "tags": ["fluid"], "likes": 13, "viewed": 451, "published": 3, "date": "1606623522", "time_retrieved": "2024-07-30T20:33:16.009268", "image_code": "// Fork of \"Transport Dynamics\" by wyatt. https://shadertoy.com/view/wdVBRR\n// 2020-11-29 03:57:58\n\nMain {\n    vec4 a = A(U), b = B(U);\n    Q = .8*atan(a.w+vec4(0.,.5*b.w,b.w,1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_a_code": "// Apply forces\nvec2 F (vec2 u) {\n    vec4 a = A(gl_FragCoord.xy + u);\n    vec4 b = B(gl_FragCoord.xy + u);\n\treturn .125*(b.w+sqrt(a.w)*abs(sqrt(a.w)-.5))*u/dot(u,u);\n}\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = Q.w-a.w;\n    return mix(Q,a,clamp(10.*f*f,0.,1.));\n}\nMain {\n\tQ = A(U);\n    if (iFrame%2==0)  {\n        float e = .2+.8*Q.w;\n        Q.xy -= e*F(vec2(0,1));\n        Q.xy -= e*F(vec2(1,0));\n        Q.xy -= e*F(vec2(0,-1));\n        Q.xy -= e*F(vec2(-1,0));\n        Q.xy -= e*F(vec2(1,1));\n        Q.xy -= e*F(vec2(-1,1));\n        Q.xy -= e*F(vec2(1,-1));\n        Q.xy -= e*F(vec2(-1,-1));\n        if (length(Q.xy)>1.) Q.xy = normalize(Q.xy);\n        if (iFrame < 1) {\n            Q = vec4(0,0,0,.5+.1*sin(U.x)*sin(U.y));\n        }\n    } else {\n    \tQ = \n        0.125*X(Q,vec2(1,0))+\n        0.125*X(Q,vec2(0,1))+\n        0.125*X(Q,vec2(-1,0))+\n        0.125*X(Q,vec2(0,-1))+\n        0.125*X(Q,vec2(1,1))+\n        0.125*X(Q,vec2(1,-1))+\n        0.125*X(Q,vec2(-1,-1))+\n        0.125*X(Q,vec2(-1,1));\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.)\n        Q = vec4(1,0,6,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Conservative advect alternating x and y-direction\nMain {\n    Q = vec4(0);\n    if (iFrame%2==0)\n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(0,i);\n        vec4 a = A(U+u-vec2(0,0.5)),\n             b = A(U+u),\n             c = A(U+u+vec2(0,0.5));\n        float w1 = 1.+c.y-a.y;\n        if (w1>0.) {\n            float w = clamp(u.y+.5+c.y,-.5,.5)-\n                      clamp(u.y-.5+a.y,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    } else \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(i,0);\n        vec4 a = A(U+u-vec2(0.5,0)),\n             b = A(U+u),\n             c = A(U+u+vec2(0.5,0));\n        float w1 = 1.+c.x-a.x;\n        if (w1 > 0.) {\n            float w = clamp(u.x+.5+c.x,-.5,.5)-\n                      clamp(u.x-.5+a.x,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    }\n    if (Q.w > 0.) Q.xyz /= Q.w;\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Apply forces\nvec2 F (vec2 u) {\n    vec4 a = A(gl_FragCoord.xy + u);\n    vec4 b = B(gl_FragCoord.xy + u);\n\treturn .125*(b.w+sqrt(a.w)*abs(sqrt(a.w)-.5))*u/dot(u,u);\n}\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = Q.w-a.w;\n    if ((a.w+Q.w)>0.)\n        a.xyz = (Q.xyz*Q.w+a.xyz*a.w)/(a.w+Q.w);\n    return mix(Q,a,clamp(10.*f*f,0.,1.));\n}\nMain {\n\tQ = A(U);\n    if (iFrame%2==0)  {\n        float e = .2+.8*Q.w;\n        Q.xy -= e*F(vec2(0,1));\n        Q.xy -= e*F(vec2(1,0));\n        Q.xy -= e*F(vec2(0,-1));\n        Q.xy -= e*F(vec2(-1,0));\n        Q.xy -= e*F(vec2(1,1));\n        Q.xy -= e*F(vec2(-1,1));\n        Q.xy -= e*F(vec2(1,-1));\n        Q.xy -= e*F(vec2(-1,-1));\n        if (length(Q.xy)>1.) Q.xy = normalize(Q.xy);\n        if (iFrame < 1) {\n            Q = vec4(0,0,0,.5);\n        }\n    } else {\n    \tQ = \n        0.125*X(Q,vec2(1,0))+\n        0.125*X(Q,vec2(0,1))+\n        0.125*X(Q,vec2(-1,0))+\n        0.125*X(Q,vec2(0,-1))+\n        0.125*X(Q,vec2(1,1))+\n        0.125*X(Q,vec2(1,-1))+\n        0.125*X(Q,vec2(-1,-1))+\n        0.125*X(Q,vec2(-1,1));\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.)\n        Q = vec4(1,0,6,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Conservative advect alternating x and y-direction\nMain {\n    Q = vec4(0);\n    if (iFrame%2==0)\n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(0,i);\n        vec4 a = A(U+u-vec2(0,0.5)),\n             b = A(U+u),\n             c = A(U+u+vec2(0,0.5));\n        float w1 = 1.+c.y-a.y;\n        if (w1>0.) {\n            float w = clamp(u.y+.5+c.y,-.5,.5)-\n                      clamp(u.y-.5+a.y,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    } else \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(i,0);\n        vec4 a = A(U+u-vec2(0.5,0)),\n             b = A(U+u),\n             c = A(U+u+vec2(0.5,0));\n        float w1 = 1.+c.x-a.x;\n        if (w1 > 0.) {\n            float w = clamp(u.x+.5+c.x,-.5,.5)-\n                      clamp(u.x-.5+a.x,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    }\n    if (Q.w > 0.) Q.xyz /= Q.w;\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "tsKBz1", "name": "iMouse.zw compatibility patch", "author": "ollj", "description": "iMouse.zw changed for the worse, breaking compatibility.\nhttps://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\nmessy signs can be fixed, adds 2 branches.\n\nleft half folds iMouse.mz=iMouse.xy onMouseUp\nright half stays onMouseUp", "tags": ["compatibility", "imouse", "incompatibility"], "likes": 1, "viewed": 540, "published": 3, "date": "1606609412", "time_retrieved": "2024-07-30T20:33:16.782202", "image_code": "/*\nabs(iMouse.zw) is unaffected by the 2020-11 change of iMouse.zw\n,but many older shaders\n,that cared for either the sign of iMouse.z or iMouse.w \n,are now broken, because the 2 signs now have indepentend behavior:\n\nIn 2020-11 iMouse.zw signs got changed to:\n if(iMouse.z==0||iMouse.w==0){ button was never clicked since PAGE-load}\n else{\n   if(iMouse.z<0){             button is down ,clicked now OR previously}\n   if(iMouse.w<0){             button is       clicked in THIS frame}\n }\n\nBeware that it initiates as 0, so <0, and <=0, as well as sign(iMouse)\n,can make a difference (on PageLoading, before clicking)\nOn (and after) klicking, iMouse will never be 0 again\n,because the smallest (bottom left) fragment is >=1  (I floor() to ckeck)\n\nTo fix iMouse.zw (for backwards compatibility):\nyou can either use abs(iMouse.zw)\nor the iMouseZwFix() function below to more explicitly\nswitch signs of iMouse.zw back to how they used to be.\n*/\n\n//backwards compatible signs of iMouse.zw (changed in november 2020)\n//m=iMouse.xyzw\n//NewCoke==true : mode now optionally ignores the onMouseUp event \n//(onMouseUp acts as if mouse is still hold down)\n//NewCoke==false : onMouseUp m.xy=m.zw like it used to be\n//NewCoke==true  : onMouseUp      m.zw stays as if mouse is still held down\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{\n    if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n\n//----- lineSegment drag visualizer by ollj\n\nvec2 fra(vec2 a,vec2 r){return (a-.5*r.xy)/r.y;}\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\n\nvec4 mainImage3( out vec4 fragColor, vec2 u\n){vec2 r=iResolution.xy\n ;vec4 m=iMouse\n     \n ;if(u.x<r.x/2.)m=iMouseZwFix(iMouse,false) //iMouseZwFix\n ;else          m=iMouseZwFix(iMouse,true)\n\n ;u   =fra(u   ,r)  //scale to range [-.5,.5]\n ;m.xy=fra(m.xy,r)\n ;m.zw=fra(m.zw,r) \n ;if(//true\n     iMouse.z==0.\n    ){ //optionaly override m for pageload (previewImage control)\n     ;if(u.x<0.) m=vec4(.6,.4,.6, .4)\n     ;else       m=vec4(.6,.4,.7,-.4)\n    ;}\n     \n ;vec3 c=vec3(1)     \n ;c.x=segment(u,m.xy,m.zw) \n //fract to point to the OFFSCREEN position\n ;c.y=fract(length(u-m.zw)\n    *(3.+sign(iMouse.w))//indicate the 1 frame mouse was clicked\n           )     \n ;c.z=length(u-m.zw)-.1  //this one is messed up without iMouseZwFix\n ;c=smoothstep(.1,-.1,c)\n ;return vec4(c,1.0);}\n\n//end of left-endian-semicolon code by ollj\n\n\n\n\n//below code is from \n//https://www.shadertoy.com/view/llySRh\n//it helped me make a workaround patch (aboove) , but it needs 2 if conmditions.\n    \n//=== original link for citation: https://www.shadertoy.com/view/llySRh\n//find many other tricks here: https://shadertoyunofficial.wordpress.com/\n\n\n// --- printing chars, integers and floats ---------------------------\n\n// --- access to the image of ascii code c\n\n// 2 implementations.\n// Use #if 1 for extensive text use (with no superimposition nor color-appearance change)\n\n#define IMMEDIATE_DRAW 1\n\n#if IMMEDIATE_DRAW //  (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n  // variants:\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  // stub the final call function is used\n\n#else // Deferred draw (call draw_char() ). Run and compiles faster.\n      //     First only determine the valid char id at cur pixel \n      //     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n     : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );}\n#endif\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;}\n#endif\n\n\nvec4 mainImage2( out vec4 O,  vec2 uv ){\n    O -= O;\n    vec2 R = iResolution.xy, U;\n    uv /= R.y;    \n    int lod = int(mod(iTime,10.));\n    U = ( uv - vec2(.1,.8) ) * 8.;        // --- column 1\n   \n    U -= vec2(5,.5);\n    O += pInt(U, floor(iMouse.x));  U.y += .8;        // mouse location\n    O += pInt(U, floor(iMouse.y));  U.y += .8;\n    U.y += .4;\n    O += pInt(U, floor(iMouse.z));  U.y += .8;        // last mouse-click location \n    O += pInt(U, floor(iMouse.w));  U.y += .8;\n     \n    O += draw_char().xxxx;\n#if IMMEDIATE_DRAW\n    O = O.xxxx;\n#endif\n    // --- color space corrections\n   return pow(O, vec4(1./2.2) ); // shader result must be in sRGB colorspace -> gamma correction\n                               // note that it is very close to sqrt(O).\n    // similarly, color operations must be done in flat space, while textures are sRGB-encoded: pow(texture(),vec4(2.2)) or ~square.\n}\n\n\nvoid mainImage( out vec4 o, vec2 u\n){o=max(mainImage2(o,u),mainImage3(o,u));\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[941, 1277, 1317, 1317, 1664], [1712, 1712, 1736, 1736, 1760], [2124, 2124, 2170, 2170, 2906], [5552, 5552, 5592, 5592, 6453], [6456, 6456, 6493, 6493, 6534]]}
{"id": "wdVBz1", "name": "Cookie Demoparty 2020 Showdown", "author": "Alkama", "description": "Made during a friendly Shader Showdown @ Cookie Demoparty November 2020 that was streamed on Twitch.\n30 minutes round.\nNo win, no loss, just for the sport and friendship :D jeyko did a fantastic clean design shader https://www.shadertoy.com/view/3dyfz1", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 5, "viewed": 530, "published": 3, "date": "1606609173", "time_retrieved": "2024-07-30T20:33:17.573087", "image_code": "const float pi=acos(-1.);\nfloat t=0.0,d=0.0;\n\nvec3 rep(vec3 p, float r) { return mod(p,r)-.5*r; }\n\nfloat grid(vec3 p) {\n  float d=1000.;\n  float w=.4+.2*sin(t*2.5);\n  p=rep(p,1.);\n  d=min(d,length(p.xy)-w);\n  d=min(d,length(p.xz)-w);\n  d=min(d,length(p.yz)-w);\n  return d;\n}\n\nvec3 fold(vec3 p) {\n  float a=3.0;\n  for(int i=0; i<5; i++) {\n    p = 2.*clamp(p,-vec3(a),vec3(a))-p;\n    a*=.2+(.1*sin(t*2.));\n  }\n  return p;\n}\n\nfloat scene(vec3 p) {\n  p=fold(p);\n  return grid(p);\n}\n\nvec3 norm(vec3 p) {\n  vec2 e=vec2(.001,0);\n  return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx)));\n}\n\nvec2 proj(vec3 p, vec3 n) {\n  n = pow(abs(n),vec3(2.));\n  return (n.x*p.zy+n.y*p.xz+n.z*p.xy)/(n.x+n.y+n.z);\n}\n\nfloat tex( vec2 uv )\n{\n  float o=0.;\n  uv.y-=2.665;\n  for(float i=1.; i<41.; i++) {\n    uv.y+=.13+.3*sin(uv.x+i+t);\n    uv.x+=.13*sin(uv.y+i+t);\n    o+=1./((100.+80.*sin(uv.x+t*20.))*abs(uv.y));\n  }\n  return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)/vec2(iResolution.y/iResolution.x, 1);\n    \n    t = 3.55+.5*mod(iTime, 20.*pi);\n\n  \tif(abs(uv.y)+.05*cos(uv.x*2.)>.45) return;\n  \tuv/=1.-length(uv)*3.;\n  \tvec3 o=vec3(sin(t),sin(sin(t)),cos(t));\n  \tvec3 tg=.5*vec3(cos(t),cos(sin(t)),sin(t));\n \tvec3 f=normalize(tg-o);\n  \tvec3 s=normalize(cross(vec3(.4*sin(t),1,0),f));\n  \tvec3 u=normalize(cross(f,s));\n  \tvec3 dir=normalize(f*.6+uv.x*s+uv.y*u);\n  \n  \tvec3 col=vec3(0),p=o;\n  \tfor(int i=0;i<200;i++) {\n    \tfloat h=scene(p)*.85;\n    \tif(abs(h)<.01) {\n      \t\tvec2 tuv = proj(p,norm(p));\n      \t\tvec3 tint=acos(normalize(dir-p))*vec3(.5,.5,1);\n      \t\tcol = clamp(.4*tex(tuv)*tint, 0.,1.);\n      \t\tfloat den=40.+2.*sin(t*10.+p.z*5.);\n      \t\tcol*=pow(float(i)/den, 5.);\n      \t\tbreak;\n    \t}\n    \tif(d>11.) break;\n    \td+=h;\n    \tp+=dir*h;\n  \t}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 73, 73, 97], [99, 99, 119, 119, 274], [276, 276, 295, 295, 421], [423, 423, 444, 444, 477], [479, 479, 498, 498, 604], [606, 606, 633, 633, 716], [718, 718, 740, 740, 930], [932, 932, 989, 989, 1863]]}
{"id": "wdKBz1", "name": "Morning Commute", "author": "XT95", "description": "Inspired by https://twitter.com/HarryAlisavakis/status/1326077058112491521", "tags": ["godrays", "train"], "likes": 197, "viewed": 7434, "published": 3, "date": "1606606870", "time_retrieved": "2024-07-30T20:33:18.356991", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Base color\n    vec2 offset = (uv*2.-1.) * invRes*1.3;\n    vec3 col = vec3(0.);\n    col.r = texture(iChannel0, uv+offset).r;\n    col.g = texture(iChannel0, uv-offset).g;\n    col.b = texture(iChannel0, uv+offset).b;\n    \n    float t = texture(iChannel0, uv+offset).a;\n    \n    // blur godrays\n    vec4 godray = vec4(0.);\n    for(float x=-3.; x<=3.; x+=1.)\n    for(float y=-3.; y<=3.; y+=1.) { \n        vec4 tap = texture(iChannel1,uv*.5+vec2(x,y)*invRes);\n        float w = 1.;\n        if(tap.w>t+1. && t <8.)\n            w = 0.;\n    \tgodray += vec4(tap.rgb,1.)*w;\n    }\n    godray /= godray.w; \n    col += FOGCOLOR*godray.rgb*.01;\n    \n    col = pow(col, vec3(1./2.2));\n    col = pow(col, vec3(.6,1.,.8*(uv.y*.2+.8)));\n    \n    // Vignetting\n    float vignetting = pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .3)*2.5;\n    col *= vignetting;\n    //col *= .7+texture(iChannel2, vec2(0.1,0.0)).r;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0) * smoothstep(0.,10.,iTime);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24739, "src": "https://soundcloud.com/parmesanpiment/thylacine-train", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define PI 3.14159265\n\n#define saturate(x) clamp(x,0.,1.)\n#define SUNDIR normalize(vec3(0.2,.3,2.))\n#define FOGCOLOR vec3(1.,.2,.1)\n\nfloat smin( float a, float b, float k );\nfloat smax( float a, float b, float k );\nfloat box( vec3 p, vec3 b, float r );\nfloat capsule( vec3 p, float h, float r );\nvec3 hash( uint n );\nmat2 rot(float v);\n\n\nfloat time;\n\nfloat train(vec3 p) {\n    \n    // base \n    float d = abs(box(p-vec3(0., 0., 0.), vec3(100.,1.5,5.), 0.))-.1;\n    \n    // windows\n    d = smax(d, -box(p-vec3(1.,0.25,5.), vec3(2.,.5,0.0), .3), 0.03);\n    d = smax(d, -box(p-vec3(-3.,0.25,5.), vec3(.2,.5,0.0), .3), 0.03);\n    d = smin(d,  box(p-vec3(1.,0.57,5.), vec3(5.3,.05,0.1), .0), 0.001);\n    \n    // seats\n    p.x = mod(p.x-.8,2.)-1.;\n    p.z = abs(p.z-4.3)-.3;\n    d = smin(d, box(p-vec3(0.,-1., 0.), vec3(.3,.1-cos(p.z*PI*4.)*.01,.2),.05), 0.05);\n    d = smin(d, box(p-vec3(0.4+pow(p.y+1.,2.)*.1,-0.38, 0.), vec3(.1-cos(p.z*PI*4.)*.01,.7,.2),.05), 0.1);\n    d = smin(d, box(p-vec3(0.1,-1.3, 0.), vec3(.1,.2,.1),.05), 0.01);\n\n    return d;\n}\n\nfloat catenary(vec3 p) {\n    \n    p.z -= 12.;\n    vec3 pp = p;\n    p.x = mod(p.x,10.)-5.;\n    \n    // base\n    float d = box(p-vec3(0.,0.,0.), vec3(.0,3.,.0), .1);\n    d = smin(d, box(p-vec3(0.,2.,0.), vec3(.0,0.,1.), .1), 0.05);\n    p.z = abs(p.z-0.)-2.;\n    d = smin(d, box(p-vec3(0.,2.2,-1.), vec3(.0,0.2,0.), .1), 0.01);\n    \n    // lines\n    pp.z = abs(pp.z-0.)-2.;\n    d = min(d, capsule(p-vec3(-5.,2.4-abs(cos(pp.x*.1*PI)),-1.),10000.,.02));\n    d = min(d, capsule(p-vec3(-5.,2.9-abs(cos(pp.x*.1*PI)),-2.),10000.,.02));\n    \n    return d;\n}\n\n\nfloat city(vec3 p) {\n    vec3 pp = p;\n    ivec2 pId = ivec2((p.xz)/30.);\n    vec3 rnd = hash(uint(pId.x + pId.y*1000));\n    p.xz = mod(p.xz, vec2(30.))-15.;\n    float h = 5.+float(pId.y-3)*5.+rnd.x*20.;\n    float offset = (rnd.z*2.-1.)*10.;\n    float d = box(p-vec3(offset,-5.,0.), vec3(5.,h,5.), 0.1);\n    d = min(d, box(p-vec3(offset,-5.,0.), vec3(1.,h+pow(rnd.y,4.)*10.,1.), 0.1));\n    d = max(d,-pp.z+100.);\n    d = max(d,pp.z-300.);\n    \n    return d*.6;\n}\n\nfloat map(vec3 p) {\n    float d = train(p);\n    p.x -= mix(0.,time*15., saturate(time*.02));\n    d = min(d, catenary(p));\n    d = min(d, city(p));\n    d = min(d, city(p+15.));\n    return d;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float t = mint;\n    for(int i=0; i<128; i++) {\n        float d = map(ro+rd*t);\n        if (abs(d)<0.01) break;\n        t += d;\n        if (t > 300.) return 1.;\n    }\n    return 0.;\n}\n\n\nvec3 randomSphereDir( vec2 rnd )\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}\n\nvec3 randomHemisphereDir( vec3 dir, float i )\n{\n    vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n    return v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( vec3 p, vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 16;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nvec3 hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash2Interleaved( vec2 x )\n{\n    // between random & dithered pattern\n    // good for jittering and blur as well as blue noise :)\n    // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n    vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( x, magic.xy ) ) );\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,-b,b,a);\n}", "buffer_a_code": "\n\n\nfloat trace(vec3 ro, vec3 rd, vec2 nearFar) {\n    float t = nearFar.x;\n    for(int i=0; i<128; i++) {\n        float d = map(ro+rd*t);\n        t += d;\n        if( abs(d) < 0.001 || t > nearFar.y )\n            break;\n    }\n    \n    return t;\n}\nfloat traceFast(vec3 ro, vec3 rd, vec2 nearFar) {\n    float t = nearFar.x;\n    for(int i=0; i<64; i++) {\n        float d = map(ro+rd*t);\n        t += d;\n        if( abs(d) < 0.001 || t > nearFar.y )\n            break;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 eps = vec2(0.01, 0.);\n    float d = map(p);\n    \n    vec3 n;\n    n.x = d - map(p-eps.xyy);\n    n.y = d - map(p-eps.yxy);\n    n.z = d - map(p-eps.yyx);\n    n = normalize(n);\n    \n    return n;\n}\n\nvec3 skyColor(vec3 rd) {\n    vec3 col = FOGCOLOR;\n    col += vec3(1.,.3,.1)*1. * pow(max(dot(rd,SUNDIR),0.),30.);\n    col += vec3(1.,.3,.1)*10. * pow(max(dot(rd,SUNDIR),0.),10000.);\n    return col;\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    vec3 col = vec3(0.);\n    \n    vec3 diff = vec3(1.,.5,.3) * max(dot(n,SUNDIR),0.);\n    vec3 amb = vec3(0.1,.15,.2) * ambientOcclusion(p,n, .75,1.5);\n    //float shad = shadow(p,SUNDIR, 0.1,200.);\n    \n    col = diff *.03;// * shad;\n    col = (diff*0.3 + amb*.3)*.02;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    vec2 jitt = vec2(0.);\n    #if 1\n    vec2 blue = texture(iChannel1, (fragCoord.xy) / vec2(1024.0)).zw;\n    blue = fract(blue + float(iFrame%256) * 0.61803398875);\n    jitt = (blue-.5)*1. * invRes;\n\t#endif\n    vec2 v = -1.0+2.0*(uv+jitt);\n\tv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(-1.5,-.4,1.2);\n    vec3 rd = normalize(vec3(v, 2.5));\n    rd.xz = rot(.15)*rd.xz;\n    rd.yz = rot(.1)*rd.yz;\n    \n    float t = trace(ro,rd, vec2(0.,300.));\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p,t);\n    vec3 col = skyColor(rd);\n    \n    if (t < 300.) {\n        col = shade(ro,rd, p,n);\n    \n        if (p.z<6.) {\n            vec3 rrd = reflect(rd,n);\n            float t2 = traceFast(p, rrd, vec2(0.1,300.));\n            vec3 rp = p + rrd * t2;\n            vec3 rn = normal(rp,t2);\n            float fre = pow( saturate( 1.0 + dot(n,rd)), 8.0 );\n            vec3 rcol = skyColor(rrd);\n            if (t2 < 300.) {\n                rcol = shade(p,rrd, rp, rn);\n            \trcol = mix(col, FOGCOLOR, smoothstep(100.,500.,t2));\n            }\n            col = mix(col, rcol, fre*.1);\n        }\n\n\n        col = mix(col, FOGCOLOR, smoothstep(100.,500.,t));\n    }\n    \n    if (p.z<6.) {\n    \tfragColor = mix(texture(iChannel0, uv), vec4(col,t), 0.2);\n    } else {\n        fragColor = vec4(col,t);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float phaseFunction(float lightDotView)\n{\n    const float k = .9;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // early exit because we want half resolution\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes*2.;\n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    time = iTime;\n\tfloat l = texture(iChannel0, uv).a;\n    \n    vec2 v = -1.0+2.0*(uv);\n\tv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(-1.5,-.4,1.2);\n    vec3 rd = normalize(vec3(v, 2.5));\n    rd.xz = rot(.15)*rd.xz;\n    rd.yz = rot(.1)*rd.yz;\n    \n    \n    float jitt = hash2Interleaved(gl_FragCoord.xy)*.2;\n    const float eps = 0.2;\n    \n    // acc shadow loop\n    float phase = phaseFunction(dot(SUNDIR,rd));\n    vec3 godray = vec3(0.);\n    for(float i=0.0; i<1.; i+=eps) {\n       vec3 p = ro+rd*l*(i+jitt);\n       float d = shadow(p, SUNDIR, float(.1), float(500.));\n       godray += d * phase;\n    }\n\tgodray = godray;\n        \n    \n    fragColor = vec4(godray,l);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    vec4 center = texture( iChannel0, uv);\n    \n    vec4 acc = vec4(center.rgb, 1.);\n    if (center.w>8.) {\n        const int N = 3;\n        for(int j=-N; j<=N; j++)\n        for(int i=-N; i<=N; i++)\n        {\n            vec2 offset = vec2(i,j) * invRes;\n            vec4 tap = texture(iChannel0, uv + offset*.8);\n            acc += vec4(tap.rgb,tap.w>8.);\n        }\n    }\n    acc.rgb /= acc.w;\n    \n    fragColor = vec4(acc.rgb, center.w);\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1123]]}
{"id": "wdVBzh", "name": "Runner illusion (buffered)", "author": "Nrx", "description": "Nothing moves...\n\n(Click to stop the animation; press the space bar to change colors.)", "tags": ["optical", "illusion"], "likes": 12, "viewed": 440, "published": 3, "date": "1606599994", "time_retrieved": "2024-07-30T20:33:19.215695", "image_code": "// Inspired by: https://twitter.com/jagarikin/status/1329610899976437765\n\n#define COLOR_SPEED\t2.4\n#define COLOR_DELAY\t0.06\n#define KEY_SPACE\t(vec2 (32.5, 0.5) / 256.0)\n\nvec4 color (in float t) {\n\treturn vec4 (vec3 (abs (2.0 * fract (t * COLOR_SPEED) - 1.0)), 1.0);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tfloat run = step (iMouse.z, 0.5);\n\tmat4 m;\n\tif (texture (iChannel1, KEY_SPACE).r < 0.5) {\n\t\tvec4 background = vec4 (0.5, 0.5, 0.5, 1.0);\n\t\tm = mat4 (\n\t\t\tbackground,\n\t\t\tmix (background, color (iTime - COLOR_DELAY), run),\n\t\t\tcolor (iTime),\n\t\t\tmix (background, color (iTime + COLOR_DELAY), run)\n\t\t);\n\t} else {\n\t\tvec4 character = vec4 (0.8, 0.3, 0.3, 1.0);\n\t\tm = mat4 (\n\t\t\tcolor (iTime),\n\t\t\tcolor (iTime + COLOR_DELAY * run),\n\t\t\tcharacter,\n\t\t\tcolor (iTime - COLOR_DELAY * run)\n\t\t);\n\t}\n\tfragColor = m * texture (iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI\t\t\t3.14159265358979\n#define REPEAT\t\t0.3\n#define HEIGHT\t\t2.2\n#define THICKNESS\t0.025\n#define OUTLINE\t\t2.0\n#define DELTA\t\t0.0001\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nfloat charDist (in vec2 p, in float jump) {\n\tp.y -= 0.25;\n\tfloat d = length (p - vec2 (0.0, 0.1)) - 0.04;\n\td = min (d, segDist (p, vec2 (0.0, 0.1), vec2 (-0.02, -0.1)));\n\tif (jump < 0.5) {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.04, -0.15)));\n\t\td = min (d, segDist (p, vec2 (0.04, -0.15), vec2 (0.08, -0.22)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.05, -0.16)));\n\t\td = min (d, segDist (p, vec2 (-0.05, -0.16), vec2 (-0.1, -0.2)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.06, -0.03)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.03), vec2 (0.1, -0.05)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (-0.08, -0.01)));\n\t\td = min (d, segDist (p, vec2 (-0.08, -0.01), vec2 (-0.09, -0.05)));\n\t} else {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.06, -0.1)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.1), vec2 (0.04, -0.2)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.02, -0.18)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.18), vec2 (-0.06, -0.24)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.07, 0.15)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.05, 0.02)));\n\t\td = min (d, segDist (p, vec2 (0.05, 0.02), vec2 (0.11, 0.06)));\n\t}\n\treturn d - THICKNESS;\n}\n\nfloat charY (in float x) {\n\tx = floor (x / REPEAT) * REPEAT;\n\treturn max (0.0, HEIGHT - mix (-x, x * x * 0.8, step (0.0, x)));\n}\n\nfloat frameDist (in vec2 p) {\n\n\t// Vertical position of the character\n\tfloat dy = charY (p.x);\n\n\t// Distance to the stairs\n\tfloat d = p.y;\n\tif (p.x < -REPEAT * 0.5) {\n\t\tfloat dx = ceil ((p.y - HEIGHT) / REPEAT) * REPEAT;\n\t\tvec2 q = vec2 (dx - p.x, p.y - dy);\n\t\td = min (d, max (min (q.x, q.y), min (max (q.x, q.y), 0.0)));\n\t}\n\n\t// Check whether the character is in the air\n\tfloat jump = step (-REPEAT, p.x) * step (DELTA, dy);\n\n\t// Distance to the character\n\tp.x = (fract (p.x / (2.0 * REPEAT)) - 0.75) * REPEAT * 2.0;\n\tp.y -= dy;\n\treturn min (d, charDist (p, jump));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Don't waste time (but beware of a possible change of resolution!)\n\tfragColor = texture (iChannel0, vec2 (0.5) / iResolution.xy);\n\tif (fragColor.xy != iResolution.xy) {\n\t\tfragColor.xyz = vec3 (iResolution.xy, float (iFrame));\n\t} else if (fragColor.z < float (iFrame) - 1.5) {\n\t\tdiscard;\n\t}\n\tif (p == vec2 (0.5)) {\n\t\treturn;\n\t}\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tp = 1.6 * p - vec2 (0.15, -1.2);\n\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (1.0, 0.0, 0.0, 0.0);\n\n\t// Display\n\tvec4 c = vec4 (0.0, 0.0, 1.0, 0.0);\n\tfloat d = frameDist (p);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, d));\n\n\tvec2 n = normalize (vec2 (frameDist (p - vec2 (DELTA, 0.0)), frameDist (p - vec2 (0.0, DELTA))) - d);\n\tvec2 v = normalize (vec2 (REPEAT, (charY (p.x) - charY (p.x - REPEAT)))) * step (2.0 * halfPixel * OUTLINE, p.y);\n\tfloat f = dot (n, v);\n\n\tc = vec4 (0.0, step (f, 0.0), 0.0, step (0.0, f));\n\td = abs (d - halfPixel * OUTLINE) - halfPixel * OUTLINE;\n\tfragColor = mix (fragColor, c, abs (f) * smoothstep (halfPixel, -halfPixel, d));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 194, 194, 266], [268, 268, 324, 324, 874]]}
{"id": "wsKBzh", "name": "Ice caves", "author": "jarble", "description": "This is another edit of one of my cave fractals. This fractal has some interesting stalactite formations.\nUse the mouse to look around.", "tags": ["fractal", "ice", "cave", "snow", "stalactite"], "likes": 1, "viewed": 367, "published": 3, "date": "1606598937", "time_retrieved": "2024-07-30T20:33:20.310767", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 p){\n    vec3 a = p/(1000.0);\n    return p+vec3((sin(a)))*500.0;\n}\n\nfloat planet_surface(vec3 p,float i){\n    p = (sin(sin(p.yzx/i)-cos(p*i)/i));\n    return length(p) - 1.0;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    float result = 0.0;\n    p = warp(p);\n    for(float i = 1.0; i < 8.0; i *= 2.0){\n        result = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    \n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 1.0;\n    return .4+sin(2.0*vec3(0.0,0.0,(sceneSDF(p*5.0,0.0))))+vec3(.4);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        eps *= 1.0+.001*(depth+1.0);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,.5);\n    eye = warp(eye);\n    \n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        //vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = 4*((t/((t/4096/4)%5+(t/4096/2)%3+(t/4096)%2)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/10.0;\n}\n\n/*\nvec2 sound1(int t)\n{\n    int t1 = 4;\n    t *= t1;\n    t = t1*((t/((t/4096/t1)%t1+1)))|(t/t1)>>t1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0/2.;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/10.0;\n}\n*/", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 p){\n    vec3 a = p/(1000.0);\n    return p+vec3((sin(a)))*500.0;\n}\n\nfloat planet_surface(vec3 p,float i){\n    p = (sin(sin(p.yzx/i)-cos(p*i)/i));\n    return length(p) - 1.0;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    float result = 0.0;\n    p = warp(p);\n    for(float i = 1.0; i < 8.0; i *= 2.0){\n        result = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    \n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 1.0;\n    return .4+sin(2.0*vec3(0.0,0.0,(sceneSDF(p*5.0,0.0))))+vec3(.4);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)*image_scale) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.0+.001*(depth+1.0);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord);\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,.5);\n    eye = warp(eye);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.y += (cos(iTime/5.0)/5.0);\n    viewDir.x += (sin(iTime/5.0)/5.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    \n    float l0 = log(length(eye-dmap)+1.0)*2.0;\n    if(l0 < 20.0) l0 = 0.0;\n\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, min(0.0,abs(l0-dist)*.9));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 510, 510, 572], [574, 574, 611, 611, 681], [683, 683, 718, 718, 953], [955, 955, 978, 978, 1010], [1012, 1012, 1040, 1040, 1125], [1128, 1549, 1640, 1640, 2024], [2039, 2293, 2358, 2358, 2490], [2492, 2581, 2610, 2647, 2957], [2959, 3451, 3591, 3591, 4201], [4203, 4573, 4658, 4658, 5073], [5075, 5402, 5451, 5486, 5617], [5619, 5619, 5646, 5646, 5795], [5797, 5797, 5854, 5854, 6612]]}
{"id": "WdVfz1", "name": "Entree (Triangulator fork)", "author": "UrbanClubProfessional", "description": "Yet another remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "green", "barycentric", "heightmap", "weird", "error", "triangulation"], "likes": 1, "viewed": 332, "published": 3, "date": "1606592634", "time_retrieved": "2024-07-30T20:33:21.509563", "image_code": "// Triangulator by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/lllGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 50\n#define FAR 90.\n#define time iTime*0.1\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(0.834, 0.258, -0.258, 0.834);\nfloat tri(in float x){return abs(fract(x)-0.4);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.04;\n    float z=1.;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i < 3.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*0.95))/z;\n        z = z*-.75;\n\t\tp = p*0.932;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*.8))*.6+.2;\n\treturn rz*4.;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 0.9 / (v0.x * v1.y - v1.x * v0.y)+0e-8;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 0.9 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.4;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.4, iq.z+.4);\n    vec2 p2 = vec2(iq.x+.4, iq.z-.4);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.4*sw, iq.z+.4*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.4*sw,.4*sw),vec2(-.4,.4),vec2(.4,-.4), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 2.)*.8;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.000;\n    float h=precis*1.0;\n    float d = -1.;\n    for( int i=-1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*0.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.4;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.35+sin(time*0.6)*1., -.08);\n    \n    vec3 ro = vec3(sin(time*0.6+0.)*10.,2., time*40.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*4., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+0.5708), -1., sin(um.x+0.5708)));\n    right.xy *= mm2(sin(time*0.6)*0.2);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*1.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(-1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.1, 0.04, -0.1));\n        \n        float dif = clamp(dot( nor, ligt ), -1., 0.);\n        float fre = pow(clamp(0.9+dot(nor,rd),-0.1,0.9), 2.);\n        vec3 brdf = 2.*vec3(0.00,0.01,0.0);\n        brdf += 0.9*dif*vec3(.7,0.,.04);\n        col = vec3(0.25,0.06,0.4);\n        col = col*brdf + fre*1.0*vec3(.6,.7,0.);\n    }\n    col = clamp(col,0.,1.);\n\tcol = pow(col,vec3(.8));\n    col *= pow( 6.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.0);\n\tfragColor = vec4( col, 0.9 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[280, 280, 301, 301, 353], [399, 399, 421, 421, 447], [449, 449, 477, 477, 700], [702, 758, 802, 802, 1077], [1079, 1233, 1252, 1252, 1687], [1689, 1689, 1726, 1726, 1969], [2161, 2161, 2218, 2218, 3340]]}
{"id": "WdVBz1", "name": "Ampengula (Triangulator fork)", "author": "UrbanClubProfessional", "description": "Another remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]", "tags": ["3d", "raymarching", "triangle", "remix", "abstract", "glitch", "barycentric", "heightmap", "fork", "weird", "error", "triangulation"], "likes": 0, "viewed": 303, "published": 3, "date": "1606591796", "time_retrieved": "2024-07-30T20:33:22.395194", "image_code": "// Triangulator by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/lllGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 70\n#define FAR 200.\n#define time iTime*0.3\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(1.034, 0.458, -0.458, 1.034);\nfloat tri(in float x){return abs(fract(x)-0.6);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.06;\n    float z=3.;\n\tfloat rz = 1.;\n\tfor (float i= 2.;i < 5.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*2.5))/z;\n        z = z*-.95;\n\t\tp = p*2.32;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*1.0))*.8+.4;\n\treturn rz*6.;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 2.0 / (v0.x * v1.y - v1.x * v0.y)+2e-10;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 2.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.6;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.6, iq.z+.6);\n    vec2 p2 = vec2(iq.x+.6, iq.z-.6);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.6*sw, iq.z+.5*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.6*sw,.6*sw),vec2(-.6,.6),vec2(.6,-.6), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 4.)*1.0;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*3.0;\n    float d = 1.;\n    for( int i=1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*1.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*0.02;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.6;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.55+sin(time*0.8)*3., -.28);\n    \n    vec3 ro = vec3(sin(time*0.8+2.)*30.,4., time*60.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*6., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708), 1., sin(um.x+2.5708)));\n    right.xy *= mm2(sin(time*0.8)*0.4);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*1.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.3, 0.06, -0.3));\n        \n        float dif = clamp(dot( nor, ligt ), 1., 2.);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 3.);\n        vec3 brdf = 2.*vec3(0.10,0.11,0.1);\n        brdf += 1.9*dif*vec3(.8,1.,.05);\n        col = vec3(0.35,0.07,0.5);\n        col = col*brdf + fre*0.5*vec3(.7,.8,1.);\n    }\n    col = clamp(col,0.,1.);\n\tcol = pow(col,vec3(.9));\n    col *= pow( 16.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.1);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[281, 281, 302, 302, 354], [400, 400, 422, 422, 448], [450, 450, 478, 478, 700], [702, 758, 802, 802, 1078], [1080, 1234, 1253, 1253, 1689], [1691, 1691, 1728, 1728, 1969], [2161, 2161, 2218, 2218, 3337]]}
{"id": "WsKfR1", "name": "Rotation by Dragging", "author": "IWBTShyGuy", "description": "If you drag the mouse on the screen, the object will be rotated.", "tags": ["3d"], "likes": 3, "viewed": 445, "published": 3, "date": "1606588128", "time_retrieved": "2024-07-30T20:33:23.444389", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 du = vec2(1.0, 0.0) / iResolution.xy;\n    vec2 dv = vec2(0.0, 1.0) / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv + du + dv).xyz;\n    col += texture(iChannel0, uv + du).xyz;\n    col += texture(iChannel0, uv + du - dv).xyz;\n    col += texture(iChannel0, uv + dv).xyz;\n    col += texture(iChannel0, uv - dv).xyz;\n    col += texture(iChannel0, uv - du + dv).xyz;\n    col += texture(iChannel0, uv - du).xyz;\n    col += texture(iChannel0, uv - du - dv).xyz;\n    col /= 8.0;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The MIT License\n// Copyright  2020 IWBTShyGuy\n\nconst float EPSILON = 1.0e-3;\nconst float PRADIUS = 0.01;\nconst vec3 CYLINDER_COLOR = vec3(220.0, 214.0, 231.0) / 255.0;\nconst vec3 CYLINDER_REFLECT_RATIO = vec3(0.2, 0.6, 0.2);\nconst vec3 FLOOR_COLOR = vec3(117.0, 109.0, 145.0) / 255.0;\n\n// a[0]i + a[1]j + a[2]k + a[3]\nvec4 qmult(vec4 a, vec4 b) {\n    return vec4(\n        a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0],\n        -a[0] * b[2] + a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\n        a[0] * b[1] - a[1] * b[0] + a[2] * b[3] + a[3] * b[2],\n        - a[0] * b[0] - a[1] * b[1] - a[2] * b[2] + a[3] * b[3]\n    );\n}\n\n// rotation by quaternion\nvec3 qrot(vec4 q, vec3 x) {\n    vec4 x_prime = vec4(x, 0.0);\n    vec4 q_bar = vec4(-q.xyz, q.w);\n    return qmult(qmult(q, x_prime), q_bar).xyz;\n}\n\nbool mouse_dragging(out vec2 disp) {\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 p_mouse = 2.0 * texture(iChannel0, du) - 1.0;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    disp = mouse.xy - p_mouse.xy;\n    return p_mouse.z > 0.0 && mouse.z > 0.0;\n}\n\n// --------------------- cylinder --------------------- //\nstruct Cylinder {\n    vec3 origin;\n    vec3 direction; // have to be normalized\n    float radius;\n    float height;\n};\n\n// Returns positive value if a point is in a cylinde.\nfloat in_cylinder(\n    in vec3 point,\n    in Cylinder cylinder\n) {\n    float dist2 = distance2_point_line(point, cylinder.origin, cylinder.direction);\n    return cylinder.radius * cylinder.radius - dist2;\n}\n\n// Creats an orthogonal matrix whose z_axis is dir.\nmat3 create_matrix(in vec3 dir) {\n    int tmp = abs(dir[0]) < abs(dir[1]) ? 0 : 1;\n    int midx = abs(dir[tmp]) < abs(dir[2]) ? tmp : 2;\n    vec3 axis0 = vec3(0.0);\n    axis0[(midx + 1) % 3] = dir[(midx + 2) % 3];\n    axis0[(midx + 2) % 3] = -dir[(midx + 1) % 3];\n    vec3 axis1 = cross(dir, axis0);\n    return mat3(axis0, axis1, dir);\n}\n\n// Find the intersection of a ray of light with a cylinder extending infinitely around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat regular_infinite_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    out vec3 position,\n    out vec3 normal\n) {\n    vec2 p_ray = normalize(ray.xy);\n    vec2 p_org = origin.xy;\n    vec2 p_h = dot(p_ray, p_org) * p_ray - p_org;\n    float res = radius * radius - dot(p_h, p_h);\n    if (res < 0.0) {\n        return res;\n    }\n    float t = dot(p_ray, -p_org) - sqrt(res);\n    t *= 1.0 / length(ray.xy);\n    position = origin + t * ray;\n    normal = vec3(position.xy, 0.0);\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[in] height the height of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return Returns a positive value if the ray and the cylinder have a intersection.\nfloat regular_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    in float height,\n    out vec3 position,\n    out vec3 normal\n) {\n    float res = regular_infinite_cylinder_intersection(\n        origin,\n        ray,\n        radius,\n        position,\n        normal\n    );\n    if (position.z < 0.0) {\n        position = origin - origin.z / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    } else if (position.z > height) {\n        position = origin + (height - origin.z) / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    }\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in Cylinder cylinder,\n    out vec3 position,\n    out vec3 normal\n) {\n    mat3 mat = create_matrix(cylinder.direction);\n    if (abs(det(mat)) < 1.0e-3) {\n        return -1.0;\n    }\n    float res = regular_cylinder_intersection(\n        solve(mat, origin - cylinder.origin),\n        solve(mat, ray),\n        cylinder.radius,\n        cylinder.height,\n        position,\n        normal\n    );\n    position = mat * position + cylinder.origin;\n    normal = mat * normal;\n    return res;\n}\n\n// Renders the intersection of two cylinders\nfloat render_core(\n    in vec2 uv,\n    in Camera camera,\n    in SpotLight light,\n    in Cylinder cylinder[2],\n    out vec3 col\n) {\n    vec3 ray = camera_ray(camera, uv);\n    vec3 position0, normal0, position1, normal1;\n    float res0 = cylinder_intersection(camera.position, ray, cylinder[0], position0, normal0);\n    float res1 = cylinder_intersection(camera.position, ray, cylinder[1], position1, normal1);\n    float res = min(res0, res1);\n    if (res < 0.0) {\n        return res;\n    }\n    vec3 position, normal;\n    float res01 = in_cylinder(position0, cylinder[1]);\n    float res10 = in_cylinder(position1, cylinder[0]);\n    if (res01 < 0.0 && res10 < 0.0) {\n        return -1.0;\n    } else if (res01 < 0.0) {\n        position = position1;\n        normal = normal1;\n    } else if (res10 < 0.0) {\n        position = position0;\n        normal = normal0;\n    } else {\n        float depth0 = length(position0 - camera.position);\n        float depth1 = length(position1 - camera.position);\n        position = depth0 < depth1 ? position0 : position1;\n        normal = depth0 < depth1 ? normal0 : normal1;\n    }\n    vec3 phong_vector = phong_vector(position, normal, light, camera, 5.0);\n    col = CYLINDER_COLOR * dot(phong_vector, CYLINDER_REFLECT_RATIO);\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n  \n    // the (0, 0) pixel is the buffer for mouse\n    if (length(uv) < PRADIUS) {\n        fragColor = (iMouse / iResolution.xyxy + 1.0) / 2.0;\n        return;\n    }\n    \n    // First Frame\n    if (iFrame == 0) {\n        fragColor = vec4(0.40, 0.70, 0.5, 1.0);\n        return;\n    }\n\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 rot = 2.0 * texture(iChannel0, vec2(1.0, 1.0) - du) - 1.0;\n    \n    vec2 dm;\n    bool drag = mouse_dragging(dm);\n    if (drag && length(dm) > EPSILON) {\n        vec3 axis = normalize(vec3(dm.y, -dm.x, 0.0));\n        float angle = length(dm) * 3.0;\n        vec4 frot = vec4(axis * sin(angle / 2.0), cos(angle / 2.0));\n        rot = qmult(rot, frot);\n    }\n\n    if (length(uv - vec2(1.0, 1.0)) < PRADIUS) {\n        fragColor = (rot + 1.0) / 2.0;\n        return;\n    }\n\n    vec3 pos = qrot(rot, vec3(0.0, 0.0, 1.0));\n    vec3 up = qrot(rot, vec3(0.0, 1.0, 0.0));\n    float asp = iResolution.x / iResolution.y;\n    Camera camera = new_camera(5.0 * pos, -pos, up, PI / 4.0, asp);\n    SpotLight light = new_light(5.0 * pos, -pos, PI / 2.0);\n\n    Cylinder cylinder[2];\n    cylinder[0].origin = vec3(-2.0, 0.0, 0.0);\n    cylinder[0].direction = vec3(1.0, 0.0, 0.0);\n    cylinder[0].radius = 1.0;\n    cylinder[0].height = 4.0;\n    cylinder[1].origin = vec3(0.0, -2.0, 0.0);\n    cylinder[1].direction = vec3(0.0, 1.0, 0.0);\n    cylinder[1].radius = 1.0;\n    cylinder[1].height = 4.0;\n\n    vec3 col;\n    render_core(uv, camera, light, cylinder, col);\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653;\n\n// ----------------------- Light ----------------------- //\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float angle;\n};\n\nSpotLight new_light(vec3 position, vec3 direction, float angle) {\n    SpotLight light;\n    light.position = position;\n    light.direction = direction;\n    light.angle = angle;\n    return light;\n}\n\n// ----------------------- Camera ----------------------- //\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nCamera new_camera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nvec3 camera_ray(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  \n}\n\n// ----------------------- Basic Math ----------------------- //\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n// determinant of a 3x3 matrix\nfloat det(in mat3 a) {\n    return a[0][0] * a[1][1] * a[2][2]\n        + a[0][1] * a[1][2] * a[2][0]\n        + a[0][2] * a[1][0] * a[2][1]\n        - a[0][1] * a[1][0] * a[2][2]\n        - a[0][2] * a[1][1] * a[2][0]\n        - a[0][0] * a[1][2] * a[2][1];\n}\n\n// Solves the equation Ax = b.\nvec3 solve(in mat3 a, in vec3 b) {\n    return vec3(\n        det(mat3(b, a[1], a[2])),\n        det(mat3(a[0], b, a[2])),\n        det(mat3(a[0], a[1], b))\n    ) / det(a);\n}\n\n// the square of the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    vec3 a = point - origin;\n    vec3 h = a - dot(a, direction) * direction;\n    return dot(h, h);\n}\n\n// the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    return sqrt(distance2_point_line(point, origin, direction));\n}\n\n// ------------------- good old Phong model ------------------- //\nfloat phong_ambient() {\n    return 1.0;\n}\n\nfloat phong_diffuse(vec3 position, vec3 normal, SpotLight light) {\n    vec3 dir = normalize(light.position - position);\n    return dot(dir, normal);\n}\n\nfloat phong_specular(vec3 position, vec3 normal, SpotLight light, Camera camera, float alpha) {\n    vec3 light_dir = normalize(light.position - position);\n    if (dot(light_dir, normal) < 0.0) return 0.0;\n    vec3 camera_dir = normalize(camera.position - position);\n    vec3 reflect_dir = reflect(-light_dir, normal);\n    float cos_alpha = clamp(dot(camera_dir, reflect_dir), 0.0, 1.0);\n    return pow(cos_alpha, alpha);\n}\n\nvec3 phong_vector(\n    vec3 position,\n    vec3 normal,\n    SpotLight light,\n    Camera camera,\n    float specular_alpha\n) {\n    return vec3(\n        phong_ambient(),\n        phong_diffuse(position, normal, light),\n        phong_specular(position, normal, light, camera, specular_alpha)\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 640]]}
{"id": "3sVBzh", "name": "Approaching Darkness", "author": "oneshade", "description": "Another checkerboard thing.", "tags": ["tunnel", "checker", "infinite"], "likes": 6, "viewed": 190, "published": 3, "date": "1606579934", "time_retrieved": "2024-07-30T20:33:24.276165", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float distTraveled = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 pos = ro + rd * distTraveled;\n\n        pos.z -= 4.0 * iTime;\n        float c = cos(iTime), s = sin(iTime);\n        pos.xy = vec2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n\n        vec3 q = abs(pos);\n        float dist = 1.0 - max(q.x, q.y);\n        if (dist < 0.001) {\n            vec2 uv = pos.xy;\n            if (q.x > q.y) {\n                uv = pos.yz;\n            }\n\n            if (q.y > q.x) {\n                uv = pos.xz;\n            }\n\n            fragColor += mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) * ((5.0 - distTraveled) / 5.0);\n            break;\n        }\n\n        if (distTraveled > 1000.0) {\n            break;\n        }\n\n        distTraveled += dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1007]]}
{"id": "WdVfRh", "name": "Smooth Kaleidoscope 2", "author": "mrange", "description": "License CC0: Smooth Kaleidoscope 2\nBeen working a bit too much and lacked the motivation do shaders for awhile\nWanted to do something simple to get started again so went back to kaleidoscopic effects that tend to be rather simple yet nice looking", "tags": ["2d", "kaleidoscope", "sabs"], "likes": 24, "viewed": 1230, "published": 3, "date": "1606575713", "time_retrieved": "2024-07-30T20:33:25.236597", "image_code": "// License CC0: Smooth Kaleidoscope 2\n// Been working a bit too much and lacked the motivation do shaders for awhile\n// Wanted to do something simple to get started again so went back to kaleidoscopic \n// effects that tend to be rather simple yet produce appealing results.\n\n// SABS by ollj.\n// rgb2hsv from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(x)      mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PSIN(x)     (0.5+0.5*sin(x))\n\nconst mat2[] rotations = mat2[](ROT(0.0*PI/2.0), ROT(1.0*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat rand(vec2 n) { \n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 pp = p + 0.5;\n  vec2 nn = floor(pp);\n  p = fract(pp) - 0.5;\n  return nn;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = circle(p+0.5, 0.5);\n  float d1 = circle(p-0.5, 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n\n  return d;\n}\n\nfloat cell1(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d2 = circle(p, 0.25);\n  \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n\n  return d;\n}\n\nfloat cell(vec2 p, vec2 cp, vec2 n, float lw) {\n  float r = rand(n+1237.0);\n  cp *= rotations[int(4.0*r)];\n  float rr = fract(13.0*r);\n  float d = 0.0;\n  if (rr > 0.25) {\n    d = cell0(cp);\n  } else {\n    d = cell1(cp);\n  }\n  return abs(d) - lw;\n}\n\nfloat truchet(vec2 p, float lw) {\n  float s = 0.1;\n  p /= s;\n  vec2 cp = p;\n  vec2 n = mod2_1(cp);\n  float d = cell(p, cp, n, lw)*s;\n  return d;\n}\n\nfloat df(vec2 p, float rep, float time) {\n  const float lw = 0.05;\n\n  vec2 pp = toPolar(p);\n  pp.x /= 1.0+pp.x;\n  p = toRect(pp);\n  \n  vec2 cp = p;\n  \n  float sm  = 3.0/rep;\n\n  float n = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(0.05*time);\n  cp-=0.1*time;\n  \n  return truchet(cp, lw*mix(0.25, 2.0, PSIN(-2.0*time+5.0*cp.x+(0.5*rep)*cp.y)));\n}\n\nvec3 color(vec2 q, vec2 p, float rep, float tm) {\n  vec2 pp = toPolar(p);\n  \n  float d = df(p, rep, tm);\n  \n  vec3 col = vec3(0.0);\n  float aa = 2.0/RESOLUTION.y;\n  vec3 baseCol = hsv2rgb(vec3(-0.25*tm+sin(5.5*d), tanh(pp.x), 1.0));\n  col = mix(col, baseCol, smoothstep(-aa, aa, -d));\n  col = baseCol + 0.5*col.zxy;\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q    = fragCoord/RESOLUTION.xy;\n  vec2 p    = -1. + 2. * q;\n  p.x       *= RESOLUTION.x/RESOLUTION.y;\n  vec2 op   = p;\n  vec3 col  = vec3(0.0);\n  \n  float tm = TIME*0.25;\n  float aa = -1.0+0.5*(length(p));\n  float a = 1.0;\n  float ra = tanh(length(0.5*p));\n\n  for (int i = 0; i < 6; ++i) {\n    p *= ROT(sqrt(0.1*float(i))*tm-ra);\n    col += +a*color(q, p, 30.0-6.0*float(i), 1.0*tm+float(i));\n    a *= aa;\n  }\n\n  col = tanh(col);\n  col = abs(p.y-col);\n  col = max(1.0-col, 0.0);\n  col = pow (col, tanh(0.0+length(op)*1.0*vec3(1.0, 1.5, 3.0)));\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[811, 811, 831, 831, 899], [901, 901, 923, 923, 1086], [1088, 1088, 1110, 1110, 1154], [1156, 1156, 1177, 1177, 1218], [1220, 1220, 1247, 1247, 1329], [1331, 1331, 1376, 1376, 1530], [1532, 1532, 1563, 1563, 1589], [1591, 1591, 1652, 1652, 1865], [1867, 1867, 1888, 1888, 2023], [2025, 2025, 2046, 2046, 2211], [2213, 2213, 2260, 2260, 2460], [2462, 2462, 2495, 2495, 2608], [2610, 2610, 2651, 2651, 2956], [2958, 2958, 3007, 3007, 3289], [3291, 3291, 3328, 3328, 3536], [3538, 3538, 3590, 3590, 4202]]}
{"id": "tdGfz1", "name": "Colorful lens (cookie stream)", "author": "leon", "description": "Shader coded for the Cookie Collective live coding stream.\n[url]https://cookie.paris/[/url]\n[url]https://www.twitch.tv/cookiedemoparty[/url]", "tags": ["colorful", "cookie"], "likes": 25, "viewed": 800, "published": 3, "date": "1606569591", "time_retrieved": "2024-07-30T20:33:26.040449", "image_code": "//\n// Shader coded for the Cookie Collective live coding stream\n// https://cookie.paris/\n// https://www.twitch.tv/cookiedemoparty\n// \n// Leon Denise 2020.11.28\n// Licensed under hippie love conspiracy\n//\n\n// constants\nconst float PI = 3.1415;\nconst float TAU = 6.283;\n\n// rotation matrix\nmat2 rotation(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// color palette by Inigo Quilez\n// https://iquilezles.org/articles/palettes\nvec3 palette(float t)\n{\n    return vec3(0.5)+vec3(0.5)*cos(vec3(1,2,3)*t);\n}\n\nvoid mainImage(out vec4 color, in vec2 coordinate)\n{\n    vec2 p = (coordinate-0.5*iResolution.xy)/iResolution.y;\n    \n    // space distortion\n    p = normalize(p) * sin(pow(length(p), 0.5)*PI - iTime * 0.3);\n    \n    vec2 origin = p;\n    vec3 tint = vec3(0);\n\t\n    // background disks\n    const int disks = 10;\n    float falloff = 1.0;\n    for (int i = 0; i < disks; ++i)\n    {\n        float ratio = float(i)/float(disks-1);\n        \n        // rotation\n        p *= rotation(sin(iTime * 0.1) * 0.1 / falloff + 0.1 * iTime / falloff);\n        \n        // fold\n        p.x = abs(p.x)-0.3*falloff;\n        \n        // shape\n        float shape = min(1., 0.001 / max(0., length(p)-0.05));\n        \n        // color\n        tint += palette(ratio * 2. + p.y*8.) * shape;\n        \n        // falloff iteration\n        falloff /= 1.1;\n    }\n    \n    // animated dots\n    const int dots = 100;\n    for (int i = 0; i < dots; ++i)\n    {\n        float ratio = float(i)/float(dots);\n        float timeline = fract(ratio * 135.1654 + iTime * 0.5);\n        float angle = TAU * ratio * 15.547 + iTime * 0.1;\n        float radius = (0.5 + 0.5 * abs(sin(float(i)*1654.))) * timeline * 2.;\n        \n        // reset transform\n        p = origin;\n        \n        // translate\n        p += vec2(cos(angle),sin(angle)) * radius;\n\t\t\n        // shape\n        float shape = min(1., 0.0005 / max(0., length(p)-0.02));\n        \n        // color\n        tint += palette(angle*0.1 + length(origin)*2.) * shape;\n    }\n\n    color = vec4(tint,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfz1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[269, 288, 312, 312, 375], [377, 454, 477, 477, 530], [532, 532, 584, 584, 2050]]}
{"id": "wsGBz1", "name": "Cave (cookie live stream)", "author": "leon", "description": "Shader coded for the Cookie Collective live coding stream.\n[url]https://cookie.paris/[/url]\n[url]https://www.twitch.tv/cookiedemoparty[/url]", "tags": ["cave", "cookie"], "likes": 13, "viewed": 554, "published": 3, "date": "1606567495", "time_retrieved": "2024-07-30T20:33:26.805403", "image_code": "//\n// Shader coded for the Cookie Collective live coding stream\n// https://cookie.paris/\n// https://www.twitch.tv/cookiedemoparty\n// \n// Leon Denise 2020.11.28\n// Licensed under hippie love conspiracy\n//\n\n// repeat coordinate\n#define repeat(p,r) (mod(p,r)-r/2.)\n\n// rotation matrix\nmat2 rotation(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// signed distance field\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // world space\n    vec3 world = p;\n    \n\t// repeat space\n    p.z = repeat(p.z + iTime * 0.1, 3.0);\n    \n    // kaleidoscopic iterated function\n    const int count = 8;\n    float falloff = 1.0;\n    for (int i = 0; i < count; ++i)\n    {\n        // fold space\n        p.xz = abs(p.xz)-0.5*falloff;\n        \n        // rotations\n        p.yx *= rotation(sin(1.3/falloff + world.z * 0.5 + iTime * 0.1)/falloff);\n        p.xz *= rotation(sin(iTime*0.01) / falloff);\n        \n        // fold space\n        p.x = abs(p.x)-0.1;\n        \n        // sphere\n        dist = min(dist, length(p)-0.4*falloff);\n        \n        // falloff for next iteration\n        falloff /= 1.5;\n    }\n    \n    // inverse volume\n    dist = -dist;\n    \n    // carve a tunnel\n    dist = max(-length(world.xy)+0.2,dist);\n    \n    // displace surface with texture\n    dist -= texture(iChannel0, p.xz * 2.).r*0.1;\n    \n    // tubes\n    p.xz = abs(p.xz)-0.01;\n    dist = min(dist, length(p.xz)-0.001);\n    \n    // sphere on tubes\n    p.y = repeat(p.y, 0.1);\n    dist = min(dist, length(p)-0.005);\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    // coordinates\n    vec2 uv = 2.*(coordinate-0.5*iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(0,0,-4);\n    vec3 ray = normalize(vec3(uv,0.5));\n    \n    // camera animation\n    camera.x += sin(iTime*0.2)*0.1;\n    camera.y += sin(iTime*0.3)*0.05;\n    ray.xy *= rotation(sin(iTime)*0.05);\n    ray.xz *= rotation(sin(iTime*0.1)*0.5);\n    \n    // raymarch iteration\n    const int count = 30;\n    for (int index = 0; index < count; ++index)\n    {\n        // distance field\n        float dist = map(camera);\n        \n        // collide with volume\n        if (dist < 0.001)\n        {\n            // coloring\n            float shade = float(count-index)/float(count);\n    \t\tvec3 tint = vec3(0.5)+vec3(0.5)*sin(vec3(1,2,3)*shade*2.+camera.z*4.);\n            color = vec4(tint*shade, 1);\n            break;\n        }\n        \n        // march\n        camera += ray * dist;\n    }\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBz1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[263, 282, 306, 306, 369], [371, 396, 415, 415, 1532], [1534, 1534, 1588, 1607, 2471]]}
{"id": "tdyfRR", "name": "(not) moving circle illusion", "author": "bgolus", "description": "Inspired by:\nhttps://twitter.com/jagarikin/status/1331409504953540613", "tags": ["illusion"], "likes": 57, "viewed": 2700, "published": 3, "date": "1606557470", "time_retrieved": "2024-07-30T20:33:27.648149", "image_code": "// Click and move mouse around to control the ring's \"movement\" direction\n// Hold down space bar to show a grid in the background to show the ring really isn't moving\n\n// You can pause to get a better idea of what's actually happening.\n\n// inspired by this tweet\n// https://twitter.com/jagarikin/status/1331409504953540613\n\n\n\n// show two rings like the original inspiration\n#define TWO_RINGS\n\n// show arrows inside the ring(s)\n#define SHOW_ARROWS\n\n// always show the grid, even if not holding down space bar or so you can enable it on mobile\n//#define FORCE_GRID_ON\n\n\n\n// basic defines\n// slowing down the spin rate can expose how the effect works\n#define SPIN_RATE 2.0\n// a wider line doesn't make the effect stronger, but again can help expose what it's doing while still working\n#define OUTLINE_WIDTH 1.0\n#define RING_RADIUS 80.0\n\n#define pi 3.141592\n#define tau (pi * 2.0)\n\nconst int KEY_SPACE = 32;\n\n// basic 2D rotation\nvec2 rotate(vec2 coord, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec2(c * coord.x - s * coord.y, s * coord.x + c * coord.y);\n}\n\n// borrowed from Trisomie21's comments in this shader\n// https://www.shadertoy.com/view/4s23DG\nfloat lineArrow(vec2 p, vec2 p1, vec2 p2, float a) {\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat d = clamp(dot(w,v) / dot(v,v), 0., 1.);\n\tfloat l = length(w-v*d);\n\ta = max(a*d-3., l-a*d);\n\treturn min(l, a)-.5;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 ring(vec2 uv, float aa, float speed, vec2 dir)\n{\n    float dist = length(uv);\n    \n    float ring_radius = 0.6;\n    \n    float edge = min(1.0 - dist, dist - ring_radius) / aa;\n    float outline_edge = edge - OUTLINE_WIDTH;\n    \n    float dirMag = min(1.0, length(dir));\n    float dirFade = 0.0;\n    float arrow = 0.0;\n    \n    // directional movement\n    if (dir != vec2(0.0))\n    {        \n        float dir_cosine = dot(normalize(dir), normalize(uv));\n        \n        // flip movment direction if negative speed\n        if (speed < 0.0)\n            dir = -dir;\n        \n        // flip speed for ring edges on the \"back\" sides of the ring\n    \tspeed *= sign(dir_cosine);\n        \n        // fade out outline on edges not facing the axis of movement\n        dirFade = 1.0 - clamp(abs(dir_cosine / 0.7), 0.0, 1.0);\n        \n        // direction arrow\n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, normalize(dir) * (RING_RADIUS * 0.25), -normalize(dir) * (RING_RADIUS * 0.25), 20.0);\n    }\n    else\n    {\n        // grow & shring arrows calculated by flipping and swizzling the start and end points\n        vec4 arrowStartEnd = vec4(RING_RADIUS * 0.1, 0.0, RING_RADIUS * 0.35, 0.0);\n        arrowStartEnd = speed > 0.0 ? arrowStartEnd : arrowStartEnd.zwxy;\n        \n        // diagonals\n        float ur = dot(vec2(1.0, 1.0), uv);\n        float ul = dot(vec2(-1.0, 1.0), uv);\n        \n        arrowStartEnd = ul > 0.0 ? -arrowStartEnd : arrowStartEnd;\n        arrowStartEnd = (ul > 0.0 ? ur : -ur) > 0.0 ? -arrowStartEnd.yxwz : arrowStartEnd;\n        \n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, arrowStartEnd.zw, arrowStartEnd.xy, 10.0);\n    }\n    arrow = smoothstep(-1.5, 0.0, arrow);\n    arrow *= abs(speed);\n    \n    // spin UVs for main ring pattern\n    float rotation = iTime * tau * SPIN_RATE;\n    vec2 rotuv_inside = rotate(uv.xy, rotation);\n    \n    // spin UVs with offset for ring outlines\n    speed = dist > ((1.0 + ring_radius) * 0.5) ? speed : -speed;\n    vec2 rotuv_outline = rotate(uv.xy, rotation - pi * speed * 0.25);\n    \n    // colors\n    vec3 yellow = vec3(0.97, 0.77, 0.2);\n    vec3 blue = vec3(0.1, 0.25, 0.81);\n    vec3 arrow_color = vec3(0.0);\n    \n    // masks for ring and outline edges\n    edge = smoothstep(-0.75, 0.75, edge);\n    outline_edge = smoothstep(-0.75, 0.75, outline_edge + (OUTLINE_WIDTH + 1.5) * dirFade);\n    \n    // mask for ring's alternating colors\n    float inside_mask = smoothstep(-aa, aa, rotuv_inside.x);\n    inside_mask = mix(1.0 - inside_mask, inside_mask, smoothstep(-aa, aa, rotuv_inside.y));\n    \n    // mask for outine's alternatting colors\n    float outline_mask = smoothstep(-aa, aa, rotuv_outline.x);\n    outline_mask = mix(1.0 - outline_mask, outline_mask, smoothstep(-aa, aa, rotuv_outline.y));\n    \n    // mix together\n    vec3 col = mix(yellow, blue, inside_mask);\n    col = mix(mix(yellow, blue, outline_mask), col, outline_edge);\n    \n    // draw in arrows if they're enabled\n    #if defined(SHOW_ARROWS)\n    col = dist < (ring_radius - aa * 2.0) ? arrow_color : col;\n    edge += arrow;\n    #endif\n    \n    return vec4(col, edge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    vec2 halfResolution = iResolution.xy * 0.5;\n    \n    uv -= halfResolution;\n    uv /= RING_RADIUS;\n    \n    // background\n    vec3 col = vec3(0.5);\n    \n    // show grid if holding down space, or if forced on.\n    #if !defined(FORCE_GRID_ON)\n    if (texture( iChannel0, vec2((float(KEY_SPACE) + 0.5) / 256.0, 0.5 / 3.0) ).x > 0.0)\n    #endif\n    {\n    \tfloat grid = mod((floor(uv.x * 3.0) + floor(uv.y * 3.0)) + 1000.0, 2.0);\n    \tcol = vec3(grid == 0.0 ? 0.475 : 0.5);\n\t}\n    \n    // wiggle the speed between 1.0 and -1.0\n    float speed = smoothstep(0.25, 0.75, abs(fract(iTime * 0.15) * 2.0 - 1.0)) * 2.0 - 1.0;\n    \n    // rotate direction over time\n    float moveAngle = -iTime * 0.451;\n    vec2 dir = vec2(sin(moveAngle), cos(moveAngle));\n    \n    // if dir == 0, speed controls grow / shrink, so fade speed in and out and set dir to 0\n    speed *= abs(smoothstep(0.3, 0.5, abs(fract(iTime * 0.025) * 2.0 - 1.0)) * 2.0 - 1.0);\n    dir = abs(fract(iTime * 0.025) * 2.0 - 1.0) > 0.4 ? dir : vec2(0.0);\n    \n    // mouse controls\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouseRelativePos = iMouse.xy - halfResolution;\n        #if defined(TWO_RINGS)\n        float mouseDist = sdSegment(mouseRelativePos, vec2(-RING_RADIUS * 1.33, 0.0), vec2(RING_RADIUS * 1.33, 0.0));\n        #else\n        float mouseDist = length(mouseRelativePos);\n        #endif\n        \n        if (mouseDist > RING_RADIUS * 2.0)\n        {\n            dir = normalize(mouseRelativePos);\n            speed = clamp((mouseDist - RING_RADIUS * 2.1) / min(RING_RADIUS, halfResolution.y - RING_RADIUS), 0.0, 1.0);\n        }\n        else\n        {\n            dir = vec2(0.0);\n            #if defined(TWO_RINGS)\n            speed = clamp(mouseRelativePos.x / (RING_RADIUS * 1.33), -1.0, 1.0);\n            #else\n            speed = clamp(mouseDist / RING_RADIUS * 3.0 - 2.0, -1.0, 1.0);\n            #endif\n        }\n    }\n        \n    vec2 ringUV = uv;\n    \n    // support two rings by offseting uvs and flipping the speed direction\n    #if defined(TWO_RINGS)\n    if (uv.x < 0.0)\n    {\n        ringUV.x += 1.33;\n    }\n    else\n    {\n        speed = -speed;\n        ringUV.x -= 1.33;\n    }\n    // add a center point dot\n    col = mix(vec3(0.0), col, smoothstep(1.5, 3.5, length(uv * RING_RADIUS)));\n    #endif    \n    \n    float aa = 1.0 / RING_RADIUS;\n    \n    // draw ring\n    vec4 ringCol = ring(ringUV, aa, speed, dir);\n    col = mix(col, ringCol.rgb, ringCol.a);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[905, 926, 964, 964, 1094], [1096, 1191, 1243, 1243, 1402], [1404, 1404, 1456, 1456, 1575], [1577, 1577, 1630, 1630, 4690]]}
{"id": "wsyBzh", "name": "Tunnel of Lanterns", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wdyBzh]\"Tunnel of Craters.\"[/url]", "tags": ["fractal", "tunnel"], "likes": 4, "viewed": 329, "published": 3, "date": "1606543407", "time_retrieved": "2024-07-30T20:33:28.453995", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p;\n    p = (sin(sin(p1.yzx)/(.5+cos(p1/i)/i)));\n    return length(p) - 1.0;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= -3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 1.0;\n    return 10.0*sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 493, 530, 530, 622], [626, 626, 661, 661, 878], [880, 880, 903, 903, 930], [932, 932, 960, 960, 1077], [1080, 1501, 1592, 1592, 1957], [1972, 2226, 2291, 2291, 2423], [2425, 2514, 2543, 2580, 2890], [2892, 3384, 3524, 3524, 4134], [4136, 4506, 4591, 4591, 5006], [5008, 5335, 5384, 5419, 5550], [5552, 5552, 5609, 5609, 6767]]}
{"id": "wdyBzh", "name": "Tunnel of Craters", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/WtjyDz]\"Alien Hive\"[/url] fractal.", "tags": ["fractal", "tunnel"], "likes": 3, "viewed": 431, "published": 3, "date": "1606540964", "time_retrieved": "2024-07-30T20:33:29.221942", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t/3/4096)%3+(t/2/4096)%2)))|t>>4|t>>5&t>>6|t/4096;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p;\n    p = (sin(sin(p1.yzx)-cos(p1/i)/i));\n    return length(p) - 1.0;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p *= 1.0;\n    return 10.0*sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*2.0) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir += sin(eye/4.0)/2.0;\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 893], [895, 895, 922, 922, 1071], [1073, 1073, 1130, 1130, 1864]]}
{"id": "WsSBzh", "name": "Selfie Girl", "author": "iq", "description": "A raymarched procedural SDF - a girl taking a selfie, this time. Making of video here: [url]https://www.youtube.com/watch?v=8--5LwHRhjk[/url]", "tags": ["procedural", "3d", "raymarching", "sdf"], "likes": 680, "viewed": 192103, "published": 3, "date": "1606524984", "time_retrieved": "2024-07-30T20:33:30.563355", "image_code": "// Copyright Inigo Quilez, 2020 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// Source code of the mathematical painting \"Selfie Girl\".\n// Making-of video on Youtube:\n//\n// Tutorial on Youtube:  https://www.youtube.com/watch?v=8--5LwHRhjk\n// Tutorial on Bilibili: https://www.bilibili.com/video/BV1Hu4y1y7U1\n\n// The image is a single formula, but I had to split it\n// down into 3 passes here so it could be shared without\n// breaking the WebGL implementation of the web browsers\n// (which is what Shadertoy uses to run the code below\n// that implements the formula).\n\n// This \"Image\" tab in particular renders the girl through\n// raymarching and then performs the final composition with\n// the background, which is computed in \"Buffer B\" (open\n// the rest of the tabs to see explanations of what each\n// one does). For the rendering/computer graphics people - \n// there's no TAA in this pass because I didn't want to\n// compute velocity vectors for the animation, so things\n// alias a bit (feel free to change the AA define below to\n// 2 if you have a fast GPU)\n\n#define AA 1\n\n\n// This SDF is really 6 braids at once (through domain\n// repetition) with three strands each (brute forced)\nvec4 sdHair( vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id) \n{\n    vec4 b = sdBezier(p, pa,pb,pc );\n    vec2 q = rot(b.zw,an);\n  \t\n    vec2 id2 = round(q/0.1);\n    id2 = clamp(id2,vec2(0),vec2(2,1));\n    q -= 0.1*id2;\n\n    float id = 11.0*id2.x + id2.y*13.0;\n\n    q += smoothstep(0.5,0.8,b.y)*0.02*vec2(0.4,1.5)*cos( 23.0*b.y + id*vec2(13,17));\n\n    occ_id.x = clamp(length(q)*8.0-0.2,0.0,1.0);\n    vec4 res = vec4(99,q,b.y);\n    for( int i=0; i<3; i++ )\n    {\n        vec2 tmp = q + 0.01*cos( id + 180.0*b.y + vec2(2*i,6-2*i));\n        float lt = length(tmp)-0.02;\n        if( lt<res.x )\n        { \n            occ_id.y = id+float(i); \n            res.x = lt; \n            res.yz = tmp;\n        }\n    }\n    return res;\n}\n\n// The SDF for the hoodie and jacket. It's a very distorted\n// ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie( in vec3 pos )\n{\n    vec3 opos = pos;\n\n    pos.x   += 0.09*sin(3.5*pos.y-0.5)*sin(    pos.z) + 0.015;\n    pos.xyz += 0.03*sin(2.0*pos.y)*sin(7.0*pos.zyx);\n    \n    // hoodie\n    vec3 hos = pos-vec3(0.0,-0.33,0.15);\n    hos.x -= 0.031*smoothstep(0.0,1.0,opos.y+0.33);\n    hos.yz = rot(hos.yz,0.9);\n    float d1 = sdEllipsoid(hos,vec3(0.96-pos.y*0.1,1.23,1.5));\n\tfloat d2 = 0.95*pos.z-0.312*pos.y-0.9;\n    float d = max(opOnion(d1,0.01), d2 );\n    \n    // shoulders\n    vec3 sos = vec3( abs(pos.x), pos.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(1.1,-1.9,0.0) );\n    d = smin(d,se.x-mix(0.25,0.43,se.y),0.4);\n    d = smin(d,sdSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n\n    // neck\n    opos.x -= 0.02*sin(9.0*opos.y);\n    vec4 w = opElongate( opos-vec3(0.0,-1.2,0.3), vec3(0.0,0.3,0.0) );\n    d = smin(d,\n             w.w+sdCappedTorus(vec3(w.xy,-w.z),vec2(0.6,-0.8),0.6,0.02),\n             0.1);\n    \n    // bumps\n    d += 0.004*sin(pos.x*90.0)*sin(pos.y*90.0)*sin(pos.z*90.0);\n    d -= 0.002*sin(pos.x*300.0);\n    d -= 0.02*(1.0-smoothstep(0.0,0.04,abs(opOnion(pos.x,1.1))));\n    \n    // border\n    d = min(d,length(vec2(d1,d2))-0.015);\n    \n    return vec4(d,pos);\n}\n\n// moves the head (and hair and hoodie). This could be done\n// more efficiently (with a single matrix or quaternion),\n// but this code was optimized for editing, not for runtime\nvec3 moveHead( in vec3 pos, in vec3 an, in float amount)\n{\n    pos.y -= -1.0;\n    pos.xz = rot(pos.xz,amount*an.x);\n    pos.xy = rot(pos.xy,amount*an.y);\n    pos.yz = rot(pos.yz,amount*an.z);\n    pos.y += -1.0;\n    return pos;\n}\n\n// the animation state\nvec3 animData; // { blink, nose follow up, mouth } \nvec3 animHead; // { head rotation angles }\n\n// SDF of the girl. It is not as efficient as it should, \n// both in terms of performance and euclideanness of the\n// returned distance. Among other things I tweaked the\n// overal shape of the head though scaling right in the\n// middle of the design process (see 1.02 and 1.04 numbers\n// below). I should have backpropagated those adjustements\n// to the  primitives themselves, but I didn't and now it's\n// too late. So, I am paying some cost there.\n//\n// She is modeled to camera (her face's shape looks bad\n// from other perspectives. She's made of five ellipsoids\n// blended together for the face, a cone and three spheres\n// for the nose, a torus for the teeh and two quadratic \n// curves for the lips. The neck is a cylinder, the hair\n// is made of three quadratic curves that are repeated\n// multiple times through domain repetition and each of\n// them contains three more curves in order to make the\n// braids. The hoodie is an ellipsoid deformed with\n// two sine waves and cut in half, the neck is an elongated\n// torus section and the shoulders are capsules.\n//\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    outMat = 1.0;\n\n    vec3 oriPos = pos;\n    \n    // head deformation and transformation\n    pos.y /= 1.04;\n    vec3 opos;\n    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );\n    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );\n    pos.x *= 1.04;\n    pos.y /= 1.02;\n    uvw = pos;\n\n    // symmetric coord systems (sharp, and smooth)\n    vec3 qos = vec3(abs(pos.x),pos.yz);\n    vec3 sos = vec3(sabs(qos.x,0.005),pos.yz);\n    \n    // head\n    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );\n    \n    // jaw\n    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);\n\tmos.yz = rot(mos.yz,0.1*animData.z);\n\tfloat d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),\n                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),\n                 \t  0.43+sclamp(mos.y*0.5,-0.5,0.2),\n                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));\n        \n    // mouth hole\n    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);\n    \n    // lower lip    \n    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), \n                      vec3(0,0.01,0.61),\n                      vec3(0.094+0.01*animData.z,0.015,0.61),\n                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));\n    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);\n    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);\n    d = smin(d,d2,0.19);\n\n    // chicks\n    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);\n    \n    // who needs ears\n    \n    // eye sockets\n    vec3 eos = sos-vec3(0.3,-0.04,0.7);\n    eos.xz = rot(eos.xz,-0.2);\n    eos.xy = rot(eos.xy,0.3);\n    eos.yz = rot(eos.yz,-0.2);\n    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );\n\td = smax( d, -d2, 0.15 );\n\n    eos = sos-vec3(0.32,-0.08,0.8);\n    eos.xz = rot(eos.xz,-0.4);\n    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );\n    d = smax( d, -d2, 0.05 );\n\n    vec3 oos = qos - vec3(0.25,-0.06,0.42);\n    \n    // eyelid\n    d2 = sdSphere( oos, 0.4 );\n    oos.xz = rot(oos.xz, -0.2);\n    oos.xy = rot(oos.xy, 0.2);\n    vec3 tos = oos;        \n    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);\n\n    //eyebags\n    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);\n    tos.yz = rot(tos.yz,0.8);\n    tos.xy = rot(tos.xy,-0.2);\n\td = smin( d, sdTorus(tos,0.29,0.01), 0.03 );\n    \n    // eyelids\n    eos = qos - vec3(0.33,-0.07,0.53);\n    eos.xy = rot(eos.xy, 0.2);\n    eos.yz = rot(eos.yz,0.35-0.25*animData.x);\n    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );\n    d = smin( d, d2, 0.012 );\n\n\t// eyelashes\n\toos.x -= 0.01;\n    float xx = clamp( oos.x+0.17,0.0,1.0);\n    float ra = 0.35 + 0.1*sqrt(xx/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));\n    float rc = 0.18/(1.0-0.7*smoothstep(0.15,0.5,animData.x));\n    oos.y -= -0.18 - (rc-0.18)/1.8;\n    d2 = (1.0/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;\n    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;\n    \n    // nose\n    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);\n    eos.yz = rot(eos.yz,-0.23);\n    float h = smoothstep(0.0,0.26,-eos.y);\n    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;\n    eos.x = sqrt(eos.x*eos.x + 0.001);\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        \n    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );\n    d = smin(d,d2,0.05-0.03*h);\n    \n    // mouth\n    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);\n    tos = eos-vec3(0.0,-0.13,0.06);\n    tos.yz = rot(tos.yz,0.2);\n    float dTeeth = sdTorus(tos,0.15,0.015);\n    eos.yz = rot(eos.yz,-0.5);\n    eos.x /= 1.04;\n\n    // nose-to-upperlip connection\n    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;\n    d2 = max(d2,-(eos.z-0.03));\n    d = smin(d,d2,0.05);\n\n    // upper lip\n    eos.x = abs(eos.x);\n    b = sdBezier(eos, vec3(0.00,-0.22,0.17),\n                      vec3(0.08,-0.22,0.17),\n                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));\n    d2 = length(b.zw/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);\n    d = smin(d,d2,0.02);\n    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))\n                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));\n\n    // valley under nose\n    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );\n    d2 = se.x-0.03-0.06*se.y;\n    d = smax(d,-d2,0.04);\n    isLip *= smoothstep(0.01,0.03,d2);\n\n    // neck\n    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );\n    d2 = se.x - 0.38;\n\n    // shoulders\n    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );\n    d2 = smin(d2,se.x-0.21,0.1);\n    d = smin(d,d2,0.4);\n        \n    // register eyelases now\n    vec4 res = vec4( d, isLip, 0, 0 );\n    if( deyelashes<res.x )\n    {\n        res.x = deyelashes*0.8;\n        res.yzw = vec3(0.0,1.0,0.0);\n    }\n    // register teeth now\n    if( dTeeth<res.x )\n    {\n        res.x = dTeeth;\n        outMat = 5.0;\n    }\n \n    // eyes\n\tpos.x /=1.05;        \n    eos = qos-vec3(0.25,-0.06,0.42);\n    d2 = sdSphere(eos,0.4);\n    if( d2<res.x ) \n    { \n        res.x = d2;\n     \toutMat = 2.0;\n        uvw = pos;\n    }\n        \n    // hair\n    {\n        vec2 occ_id, tmp;\n\t\tqos = pos; qos.x=abs(pos.x);\n\n        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), \n                               vec3( 0.95, 0.7,0.85), \n                               vec3( 0.4,-1.45,0.95),\n                               -0.9,occ_id);\n\n        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), \n                                vec3(-1.0, 0.4,0.2), \n                                vec3(-0.6,-1.4,0.7),\n                                0.6,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}\n\n        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), \n                           vec3( 1.0, 0.5,0.45), \n                           vec3( 0.4,-1.45,0.55),\n                           -0.2,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}\n    \n\n        pres.x *= 0.8;\n        if( pres.x<res.x )\n        {\n            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );\n            uvw = pres.yzw;\n            outMat = 4.0;\n        }\n    }\n\n    // hoodie\n    vec4 tmp = sdHoodie( opos );\n    if( tmp.x<res.x )\n    {\n        res.x = tmp.x;\n        outMat = 3.0;\n        uvw  = tmp.yzw;\n    }\n\n    return res;\n}\n\n// SDF of the girl again, but with extra high frequency\n// modeling detail. While the previous one is used for\n// raymarching and shadowing, this one is used for normal\n// computation. This separation is conceptually equivalent\n// to decoupling detail from base geometry with \"normal\n// maps\", but done in 3D and with SDFs, which is way\n// simpler and can be done corretly (something rarely seen\n// in 3D engines) without any complexity.\nvec4 mapD( in vec3 pos, in float time )\n{\n    float matID;\n    vec3 uvw;\n    vec4 h = map(pos, time, matID, uvw);\n    \n    if( matID<1.5 ) // skin\n    {\n        // pores\n        float d = fbm1(iChannel0,120.0*uvw);\n        h.x += 0.0015*d*d;\n    }\n    else if( matID>3.5 && matID<4.5 ) // hair\n    {\n        // some random displacement to evoke hairs\n        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n    \th.x -= 0.02*te;\n    }    \n    return h;\n}\n\n// Computes the normal of the girl's surface (the gradient\n// of the SDF). The implementation is weird because of the\n// technicalities of the WebGL API that forces us to do\n// some trick to prevent code unrolling. More info here:\n//\n// https://iquilezles.org/articles/normalsSDF\n//\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.001;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,kk ).x );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        float kk; vec3 kk2;\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time).x;\n      //if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n// Compute soft shadows for a given light, with a single\n// ray insead of using montecarlo integration or shadowmap\n// blurring. More info here:\n//\n// https://iquilezles.org/articles/rmshadows\n//\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    // first things first - let's do a bounding volume test\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  //vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    tmax = min(tmax,sph.y);\n\n    // raymarch and track penumbra    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.005, 0.1 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n// Computes convexity for our girl SDF, which can be used\n// to approximate ambient occlusion. More info here:\n//\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n//\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,gl_FragCoord.xy/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*0.1;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>16.0 ) break;\n    }\n\tao /= 16.0;\n    return clamp( 1.0-ao*24.0, 0.0, 1.0 );\n}\n\n// Computes the intersection point between our girl SDF and\n// a ray (coming form the camera in this case). It's a\n// traditional and basic/uncomplicated SDF raymarcher. More\n// info here:\n//\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n//\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float t = 1.0;\n    \n    // bounding volume test first\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  //vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    if( sph.y<0.0 ) return vec2(-1.0);\n    \n    // clip raymarch space to bonding volume\n    tmax = min(tmax,sph.y);\n    t    = max(1.0, sph.x);\n    \n    // raymarch\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( h.x<0.001 )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.95;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n// This is a replacement for a traditional dot(N,L) diffuse\n// lobe (called N.L in the code) that fakes some subsurface\n// scattering (transmision of light thorugh the skin that\n// surfaces as a red glow)\n//\nvec3 sdif( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n}\n\n// Animates the eye central position (not the actual random\n// darts). It's carefuly synched with the head motion, to\n// make the eyes anticipate the head turn (without this\n// anticipation, the eyes and the head are disconnected and\n// it all looks like a zombie/animatronic)\n//\nfloat animEye( in float time )\n{\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    \n    float q = fract((time-0.31)/(2.0*w));\n    float s = (q > 0.5) ? 1.0 : 0.0;\n    return (t<0.15)?1.0-s:s;\n}\n\n// Renders the girl. It finds the ray-girl intersection\n// point, computes the normal at the intersection point,\n// computes the ambient occlusion approximation, does per\n// material setup (color, specularity, subsurface\n// coefficient and paints some fake occlusion), and finally\n// does the lighting computations.\n//\n// Lighting is not based on pathtracing. Instead the bounce\n// light occlusion signals are created manually (placed\n// and sized by hand). The subsurface scattering in the\n// nose area is also painted by hand. There's not much\n// attention to the physicall correctness of the light\n// response and materials, but generally all signal do\n// follow physically based rendering practices.\n//\nvec3 renderGirl( in vec2 p, in vec3 ro, in vec3 rd, in float tmax, in vec3 col, in float time )\n{\n    // --------------------------\n    // find ray-girl intersection\n    // --------------------------\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, tmax, time, cma, uvw );\n\n    // --------------------------\n    // shading/lighting\t\n    // --------------------------\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal(pos, time);\n\n        float ks = 1.0;\n        float se = 16.0;\n        float tinterShadow = 0.0;\n        float sss = 0.0;\n        float focc = 1.0;\n        //float frsha = 1.0;\n\n        // --------------------------\n        // material\n        // --------------------------\n        if( tm.y<1.5 ) // skin\n        {\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\n            // base skin color\n            col = mix(vec3(0.225,0.15,0.12),\n                      vec3(0.24,0.1,0.066),\n                      smoothstep(0.4 ,0.0,length( qos.xy-vec2(0.42,-0.3)))+\n                      smoothstep(0.15,0.0,length((qos.xy-vec2(0,-0.29))/vec2(1.4,1))));\n            \n            // fix that ugly highlight\n            col -= 0.03*smoothstep(0.13,0.0,length((qos.xy-vec2(0,-0.49))/vec2(2,1)));\n                \n            // lips\n            col = mix(col,vec3(0.14,0.06,0.1),cma.x*step(-0.7,qos.y));\n            \n            // eyelashes\n            col = mix(col,vec3(0.04,0.02,0.02)*0.6,0.9*cma.y);\n\n            // fake skin drag\n            uvw.y += 0.025*animData.x*smoothstep(0.3,0.1,length(uvw-vec3(0.0,0.1,1.0)));\n\t\t\tuvw.y -= 0.005*animData.y*smoothstep(0.09,0.0,abs(length((uvw.xy-vec2(0.0,-0.38))/vec2(2.5,1.0))-0.12));\n            \n            // freckles\n            vec2 ti = floor(9.0+uvw.xy/0.04);\n            vec2 uv = fract(uvw.xy/0.04)-0.5;\n            float te = fract(111.0*sin(1111.0*ti.x+1331.0*ti.y));\n            te = smoothstep(0.9,1.0,te)*exp(-dot(uv,uv)*24.0); \n            col *= mix(vec3(1.1),vec3(0.8,0.6,0.4), te);\n\n            // texture for specular\n            ks = 0.5 + 4.0*texture(iChannel3,uvw.xy*1.1).x;\n            se = 12.0;\n            ks *= 0.5;\n            tinterShadow = 1.0;\n            sss = 1.0;\n            ks *= 1.0 + cma.x;\n            \n            // black top\n            col *= 1.0-smoothstep(0.48,0.51,uvw.y);\n            \n            // makeup\n            float d2 = sdEllipsoid(qos-vec3(0.25,-0.03,0.43),vec3(0.37,0.42,0.4));\n            col = mix(col,vec3(0.06,0.024,0.06),1.0 - smoothstep(0.0,0.03,d2));\n\n            // eyebrows\n    \t\t{\n            #if 0\n            // youtube video version\n        \tvec4 be = sdBezier( qos, vec3(0.165+0.01*animData.x,0.105-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.015*sqrt(be.y);\n            #else\n            // fixed version\n        \tvec4 be = sdBezier( qos, vec3(0.16+0.01*animData.x,0.11-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.01*sqrt(1.0-be.y);\n            #endif\n            float dd = 1.0+0.05*(0.7*sin((sin(qos.x*3.0)/3.0-0.5*qos.y)*350.0)+\n                                 0.3*sin((qos.x-0.8*qos.y)*250.0+1.0));\n    \t\tfloat d = be.x - ra*dd;\n        \tfloat mask = 1.0-smoothstep(-0.005,0.01,d);\n        \tcol = mix(col,vec3(0.04,0.02,0.02),mask*dd );\n        \t}\n\n            // fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 0.5+0.5*smoothstep(-1.5,-0.75,uvw.y);\n            focc *= 1.0-smoothstep(0.4,0.75,abs(uvw.x));\n            focc *= 1.0-0.4*smoothstep(0.2,0.5,uvw.y);\n            \n            focc *= 1.0-smoothstep(1.0,1.3,1.7*uvw.y-uvw.x);\n            \n            //frsha = 0.0;\n        }\n        else if( tm.y<2.5 ) // eye\n        {\n            // The eyes are fake in that they aren't 3D. Instead I simply\n\t\t\t// stamp a 2D mathematical drawing of an iris and pupil. That\n\t\t\t// includes the highlight and occlusion in the eyesballs.\n            \n            sss = 1.0;\n\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\t\t\tfloat ss = sign(uvw.x);\n            \n            // iris animation\n            float dt = floor(time*1.1);\n            float ft = fract(time*1.1);\n            vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n            vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n            vec2 da = mix(da0,da1,smoothstep(0.9,1.0,ft));\n\n            float gg = animEye(time);\n            da *= 1.0+0.5*gg;\n            qos.yz = rot(qos.yz,da.y*0.004-0.01);\n            qos.xz = rot(qos.xz,da.x*0.004*ss-gg*ss*(0.03-step(0.0,ss)*0.014)+0.02);\n\n            vec3 eos = qos-vec3(0.31,-0.055 - 0.03*animData.x,0.45);\n            \n            // iris\n            float r = length(eos.xy)+0.005;\n            float a = atan(eos.y,ss*eos.x);\n            vec3 iris = vec3(0.09,0.0315,0.0135);\n            iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n            iris *= 0.35+0.7*texture(iChannel2,vec2(r,a/6.2831)).x;\n            // base color\n            col = vec3(0.42);\n            col *= 0.1+0.9*smoothstep(0.10,0.114,r);\n            col = mix( col, iris, 1.0-smoothstep(0.095,0.10,r) );\n            col *= smoothstep(0.05,0.07,r);\n\t\t\t\n            // fake occlusion backed in\n            float edis = length((vec2(abs(uvw.x),uvw.y)-vec2(0.31,-0.07))/vec2(1.3,1.0));\n            col *= mix( vec3(1.0), vec3(0.4,0.2,0.1), linearstep(0.07,0.16,edis) );\n\n            // fake highlight\n            qos = vec3(abs(uvw.x),uvw.yz);\n            col += (0.5-gg*0.3)*(1.0-smoothstep(0.0,0.02,length(qos.xy-vec2(0.29-0.05*ss,0.0))));\n            \n            se = 128.0;\n\n            // fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 1.0-linearstep(0.10,0.17,edis);\n            //frsha = 0.0;\n        }\n        else if( tm.y<3.5 )// hoodie\n        {\n            sss = 0.0;\n            col = vec3(0.81*texture(iChannel0,uvw*6.0).x);\n            ks *= 2.0;\n            \n            // logo\n            if( abs(uvw.x)<0.66 )\n            {\n                float par = length(uvw.yz-vec2(-1.05,0.65));\n                col *= mix(vec3(1.0),vec3(0.6,0.2,0.8)*0.7,1.0-smoothstep(0.1,0.11,par));\n                col *= smoothstep(0.005,0.010,abs(par-0.105));\n            }                \n\n            // fake occlusion\n            focc = mix(1.0,\n                \t   0.03+0.97*smoothstep(-0.15,1.7,uvw.z),\n                       smoothstep(-1.6,-1.3,uvw.y)*(1.0-clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0))\n                      );\n            \n            //frsha = mix(1.0,\n            //            clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0),\n            //            smoothstep(-1.6,-1.3,uvw.y)\n            //           );\n            //frsha *= smoothstep(0.85,1.0,length(uvw-vec3(0.0,-1.0,0.0)));\n        }\n        else if( tm.y<4.5 )// hair\n        {\n            sss = 0.0;\n            col = (sin(cma.x)>0.7) ? vec3(0.03,0.01,0.05)*1.5 :\n                                     vec3(0.04,0.02,0.01)*0.4;\n            ks *= 0.75 + cma.z*18.0;\n            float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n            col *= 2.0*te;\n            ks *= 1.5*te;\n            \n\t\t\t// fake occlusion\n            focc  = 1.0-smoothstep(-0.40, 0.8, uvw.y);\n            focc *= 1.0-0.95*smoothstep(-1.20,-0.2,-uvw.z);\n            focc *= 0.5+cma.z*12.0;\n            //frsha = 1.0-smoothstep(-1.3,-0.8,uvw.y);\n            //frsha *= 1.0-smoothstep(-1.20,-0.2,-uvw.z);\n        }\n        else if( tm.y<5.5 )// teeth\n        {\n            sss = 1.0;\n            col = vec3(0.3);\n            ks *= 1.5;\n            //frsha = 0.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time );\n\n        // --------------------------\n        // lighting. just four lights\n        // --------------------------\n        vec3 lin = vec3(0.0);\n\n        // fake sss\n        float nma = 0.0;\n        if( tm.y<1.5 )\n        {\n        nma = 1.0-smoothstep(0.0,0.12,length((uvw.xy-vec2(0.0,-0.37))/vec2(2.4,0.7)));\n        }\n\n        //vec3 lig = normalize(vec3(0.5,0.4,0.6));\n        vec3 lig = vec3(0.57,0.46,0.68);\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        //float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float sha = calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float spe = 2.0*ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*sha*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n\n        // fake sss for key light\n        vec3 cocc = mix(vec3(occ),\n                        vec3(0.1+0.9*occ,0.9*occ+0.1*occ*occ,0.8*occ+0.2*occ*occ),\n                        tinterShadow);\n        cocc = mix( cocc, vec3(1,0.3,0.0), nma);\n        sha = mix(sha,max(sha,0.3),nma);\n\n        vec3  amb = cocc*(0.55 + 0.45*nor.y);\n        float bou = clamp(0.3-0.7*nor.x, 0.0, 1.0 );\n\n        lin +=      vec3(0.65,1.05,2.0)*amb*1.15;\n        lin += 1.50*vec3(1.60,1.40,1.2)*sdif(dot(nor,lig),0.5+0.3*nma+0.2*(1.0-occ)*tinterShadow) * mix(vec3(sha),vec3(sha,0.2*sha+0.7*sha*sha,0.2*sha+0.7*sha*sha),tinterShadow);\n        lin +=      vec3(1.00,0.30,0.1)*sss*fre*0.6*(0.5+0.5*dif*sha*amb)*(0.1+0.9*focc);\n        lin += 0.35*vec3(4.00,2.00,1.0)*bou*occ*col;\n\n        col = lin*col + spe + fre*fre*fre*0.1*occ;\n\n        // overall\n\t\tcol *= 1.1;\n    }\n        \n    return col;\n}\n\n// Animates the head turn. This is my first time animating\n// and I am aware I'm in uncanny/animatronic land. But I\n// have to start somwhere!\n//\nfloat animTurn( in float time )\n{\t\n    const float w = 6.1;\n    float t = mod(time,w*2.0);\n    \n    vec3 p = (t<w) ? vec3(0.0,0.0,1.0) : vec3(w,1.0,-1.0);\n    return p.y + p.z*expSustainedImpulse(t-p.x,1.0,10.0);\n}\n\n// Animates the eye blinks. Blinks are motivated by head\n// turns (again, in an attempt tp avoid animatronic and\n// zoombie feel), but also there are random blinks. This\n// same funcion is called with some delay and extra\n// smmoothness to get the blink of the eyes be followed by\n// the face muscles around the face.\n//\nfloat animBlink( in float time, in float smo )\n{\n    // head-turn motivated blink\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    float blink = smoothstep(0.0,0.1,t) - smoothstep(0.18,0.4,t);\n\n    // regular blink\n    float tt = mod(1.0+time,3.0);\n    blink = max(blink,smoothstep(0.0,0.07+0.07*smo,tt)-smoothstep(0.1+0.04*smo,0.35+0.3*smo,tt));\n    \n    // keep that eye alive always\n    float blinkBase = 0.04*(0.5+0.5*sin(time));\n    blink = mix( blinkBase, 1.0, blink );\n\n    // base pose is a bit down\n    float down = 0.15;\n    return down+(1.0-down)*blink;\n}\n\n// The main rendering entry point. Basically it does some\n// setup, creating the ray that will explore the 3D scene\n// in search of the girl for each pixel, computes the\n// animation variables (blink, mouth and head movements),\n// does the rendering of the girl if it finds her under\n// the current pixel, and finally does gamme correction\n// and some minimal color processing and vignetting to the\n// image.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        time += 2.0;\n        \n        // camera movement\t\n        vec3 ro; float fl;\n        mat3 ca = calcCamera( time, ro, fl );\n    \tvec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))/1.1,fl));\n\n        // animation (blink, face follow up, mouth)\n        float turn = animTurn( time );\n        animData.x = animBlink(time,0.0);\n        animData.y = animBlink(time-0.02,1.0);\n        animData.z = -0.25 + 0.2*(1.0-turn)*smoothstep(-0.3,0.9,sin(time*1.1)) + 0.05*cos(time*2.7);\n\n        // animation (head orientation)\n        animHead = vec3( sin(time*0.5), sin(time*0.3), -cos(time*0.2) );\n        animHead = animHead*animHead*animHead;\n        animHead.x = -0.025*animHead.x + 0.2*(0.7+0.3*turn);\n        animHead.y =  0.1 + 0.02*animHead.y*animHead.y*animHead.y;\n        animHead.z = -0.03*(0.5 + 0.5*animHead.z) - (1.0-turn)*0.05;\n        \n        // rendering\n        vec4 tmp = texelFetch(iChannel1,ivec2(fragCoord),0);\n        vec3 col = tmp.xyz;\n        float tmin = tmp.w;\n        \n        if( p.x*1.4+p.y<0.8 && -p.x*4.5+p.y<6.5 && p.x<0.48)\n        col = renderGirl(p,ro,rd,tmin,col,time);\n        //else col=vec3(0,1,0);\n        \n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n \n    // compress\n    tot = 3.8*tot/(3.0+dot(tot,vec3(0.333)));\n  \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    // grade\n    tot = tot*vec3(1.02,1.00,0.99)+vec3(0.0,0.0,0.045);\n       \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Basic utility functions (SDFs, noises, shaping functions)\n// and also the camera setup which is shared between the\n// background rendering code (\"Buffer A\" tab) and the character\n// rendering code (\"Image\" tab)\n\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin3( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/smin\nfloat sclamp(in float x, in float a, in float b )\n{\n    float k = 0.1;\n\treturn smax(smin(x,b,k),a,k);\n}\n\n// https://iquilezles.org/articles/functions/\nfloat sabs(in float x, in float k )\n{\n    return sqrt(x*x+k);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opRepLim( in float p, in float s, in float lima, in float limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x-a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( in vec3 p, in float ra, in float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdArc( in vec2 p, in vec2 scb, in float ra )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\n\n#if 1\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  //----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  //----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  //----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)/dot(g,g);\n//float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  //----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n#else\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\n// my adaptation to 3d of http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g/dot(g,g);\n    float t = clamp( dot(z,d10-d20)/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return vec4(length(q),t,-k,-sign(f)*length(q-n*k));\n}\n#endif\n\n// https://iquilezles.org/articles/distfunctions\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\n\treturn vec2( length( p - b*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n    float h = clamp( p.y/b, 0.0, 1.0 );\n    p.y -= b*h;\n\treturn length(p) - mix(r1,r2,h);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n//-----------------------------------------------\n\n// ray-infinite-cylinder intersection\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )\n{\n\tvec3 oc = ro;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - rad*rad;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h)/a;\n}\n\n// ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k )\n{\n\tfloat a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;\n    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;\n    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; \n        \n    float h = b*b-a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n//-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x )\n{\n    return clamp( (x-a)/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat expSustainedImpulse( float t, float f, float k )\n{\n    return smoothstep(0.0,f,t)*1.1 - 0.1*exp2(-k*max(t-f,0.0));\n}\n\n//-----------------------------------------------\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//---------------------------------------\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)/64.0,0.0).x;\n}\nfloat noise1f( sampler2D tex, in vec2 x )\n{\n    return texture(tex,(x+0.5)/64.0).x;\n}\nfloat fbm1( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat fbm1( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm1f( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1f(tex,x); x*=2.01;\n    f += 0.2500*noise1f(tex,x); x*=2.01;\n    f += 0.1250*noise1f(tex,x); x*=2.01;\n    f += 0.0625*noise1f(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat bnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    float k = 0.5+0.5*sin(i);\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 fbm13( in float x, in float g )\n{    \n    vec3 n = vec3(0.0);\n    float s = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        n += s*vec3(bnoise(x),bnoise(x+13.314),bnoise(x+31.7211));\n        s *= g;\n        x *= 2.01;\n        x += 0.131;\n    }\n    return n;\n}\n\n//--------------------------------------------------\n//const float X1 = 1.6180339887498948; const float H1 = float( 1.0/X1 );\n//const float X2 = 1.3247179572447460; const vec2  H2 = vec2(  1.0/X2, 1.0/(X2*X2) );\n//const float X3 = 1.2207440846057595; const vec3  H3 = vec3(  1.0/X3, 1.0/(X3*X3), 1.0/(X3*X3*X3) );\n  const float X4 = 1.1673039782614187; const vec4  H4 = vec4(  1.0/X4, 1.0/(X4*X4), 1.0/(X4*X4*X4), 1.0/(X4*X4*X4*X4) );\n\n//--------------------------------------\nmat3 calcCamera( in float time, out vec3 oRo, out float oFl )\n{\n    vec3 ta = vec3( 0.0, -0.3, 0.0 );\n    vec3 ro = vec3( -0.5563, -0.2, 2.7442 );\n    float fl = 1.7;\n#if 0\n    vec3 fb = fbm13( 0.2*time, 0.5 );\n    ta += 0.025*fb;\n    float cr = -0.01 + 0.006*fb.z;\n#else\n    vec3 fb1 = fbm13( 0.15*time, 0.50 );\n    ro.xyz += 0.010*fb1.xyz;\n    vec3 fb2 = fbm13( 0.33*time, 0.65 );\n    fb2 = fb2*fb2*sign(fb2);\n    ta.xy += 0.005*fb2.xy;\n    float cr = -0.01 + 0.002*fb2.z;\n#endif\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    oRo = ro;\n    oFl = fl;\n\n    return mat3(uu,vv,ww);\n}\n\n#define ZERO min(iFrame,0)\n#define ZEROU min(uint(iFrame),0u)\n", "buffer_a_code": "// Renders the background (trees, ground, river and bridge).\n// The render uses a super basic implementation of Temporal\n// Antialiasing (TAA) without color clipping or anything,\n// but it's enough to stabilize aliasing. It also outputs\n// the deph buffer into the alpha channel for the next pass\n// (\"Buffer B\") to consume and do proper Depth Of Field.\n\n\n// The ground - it's a simple box deformed by a few sine waves\n//\nfloat sdGround( in vec3 pos )\n{\n    pos -= vec3(120.0,-35.0,-700.0);\n    pos.x += -150.0;\n    pos.z += 30.0*sin(1.00*pos.x*0.016+0.0);\n    pos.z += 10.0*sin(2.20*pos.x*0.016+1.0);\n    pos.y += 20.0*sin(0.01*pos.x+2.0)*sin(0.01*pos.z+2.0);\n    \n    return sdBox(pos,vec3(1000.0,2.0,400.0))-10.0;\n}\n\n// The bridge. It's made of five boxes repeated forever\n// with some mod() call, which are distorted with gentle\n// sine waves so they don't look like perfectly geometrical. \n//\nvec2 sdBridge( in vec3 pos )\n{\n    float issnow = 0.0;\n    vec3 opos = pos;\n    pos.x  += 50.0*sin(pos.z*0.01)+10.0;\n    pos.xz += 0.05*sin(pos.yx+vec2(0,2));                \n    vec3 sos = vec3(abs(pos.x),pos.yz);\n    float h = -16.0;\n    \n    // floor\n    vec3 ros = vec3(sos.xy,mod(sos.z+2.0,4.0)-2.0 )-vec3(0.0,h,0.0);\n    float d = sdBox(ros,vec3(20.0,1.0,1.85));\n\n    // thick bars\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h+5.0-0.4,0.0);\n    float d2 = sdBox(ros,vec3(1.2,5.0,0.7)+0.1)-0.1;\n    d = min(d,d2);\n    \n    #if 0\n    {\n    float id = floor((sos.z+5.0)/10.0);\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h-0.4,0.0);\n\tros-=vec3(-1.5,1,0);\n    ros.x -= ros.y;\n    float ra = 0.5 + 0.5*sin(float(id)+4.0);\n    float d2 = sdEllipsoid(ros,vec3(2.0,2.0,1.3)*ra);\n    issnow = clamp( 0.5+0.5*(d-d2)/0.7, 0.0, 1.0 );\n    d = smin(d,d2,0.7);\n    }\n    #endif\n\n    // small bars\n    ros = vec3(sos.xy,mod(sos.z+1.25,2.5)-1.25 )-vec3(20.0,h+5.0,0.0);\n    d2 = sdBox(ros,vec3(0.2,5.0,0.2))-0.05;\n    d = min(d,d2);\n    \n    // handle\n    d2 = sdBox(sos-vec3(20.0,h+10.0,0.0),vec3(0.5,0.1,300.0))-0.4;\n    d = min(d,d2);\n    \n    // foot bar\n    d2 = sdBox(sos-vec3(20.0,h+2.4,0.0),vec3(0.7,0.1,300.0))-0.2;\n    d = min(d,d2);\n    \n\treturn vec2(d,issnow);\n}\n\n// The trees are ultra basic and look really bad without\n// defocus, but all I needed was something that looked like\n// pine trees so the viewers would complete the picture in\n// their heads. Only four trees are evaluated at any time,\n// even though  there are inifinte many of them. Yet these\n// four trees consume most of the rendering budget for the\n// painting.\n//\nvec3 sdForest( in vec3 pos, float tmin )\n{\n    float shid = 0.0;\n    \n    const float per = 200.0;\n    \n    pos -= vec3(120.0,-16.0,-600.0);\n        \n    vec3 vos = pos/per;\n    vec3 ip = floor(vos);\n    vec3 fp = fract(vos);\n    \n    bool hit = false;\n    float d = tmin;\n    float occ = 1.0;\n    \n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 of = vec2(i,j);\n        ivec2 tid = ivec2(ip.xz + of );\n        tid.y = min(tid.y,-0);\n        \n        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;\n        \n        vec3 rf =  hash3( uint(treeId) )-0.5;\n        \n        vec3 ros = vec3( (float(tid.x)+rf.x)*per,\n                         0.0,\n                         (float(tid.y)+rf.y)*per );\n\n\n        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );\n        hei *= (tid.y==0) ? 1.0 : 1.5;\n          \n        hei *= 275.0;\n\n        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);\n        if( d2<d)\n        {\n            d = d2;\n            hit = false;\n        }\n        \n        if( d2-150.0>d ) continue;\n        \n        vec2 qos = pos.xz - ros.xz;\n        float an = atan(qos.x,qos.y);\n        float ra = length(qos);\n        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);\n\n        \n        // trick - only evalute 4 closest of the 10 cones\n        int segid = int(floor(16.0*(pos.y-ros.y)/hei));\n        for( uint k=ZEROU; k<4u; k++ )\n        {\n            uint rk = uint( min(max(segid+int(k),5),15) );\n            \n            float h = float(rk)/15.0;\n            \n            vec3 ran = hash3( treeId*24u+rk );\n            \n            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);\n\n            ros.y = h*hei;\n            \n            float hh = 0.5 + 0.5*(1.0-h);\n            float ww = 0.1 + 0.9*(1.0-h);\n            hh *= 0.7+0.2*ran.x;\n            ww *= 0.9+0.2*ran.y;\n            hh *= 1.0+0.2*vv;\n            \n            vec2 rrr = vec2( ra, pos.y-ros.y );\n            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));\n            float d2 = tmp.x-mix(1.0,vv,tmp.y);\n            if( d2<d )\n            {\n                hit = true;\n                d = d2;\n                shid = rf.z;\n                occ = tmp.y * clamp(ra/100.0+h,0.0,1.0);\n            }\n        }\n    }\n    \n    if( hit )\n    {\n        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));\n        d -= 8.0*dis-4.0;\n        //occ = dis;\n    }\n    \n\treturn vec3(d,shid,occ);\n}\n\n\n// The SDF of the landscape is made by combining ground, \n// bridge, river and trees. \n//\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    pos.xz = rot(pos.xz,0.2);\n\n    vec4 res = vec4(pos.y+36.0,0,0,0);    \n    \n    outMat = 1.0;\n    uvw = pos;\n    \n    //-------\n    {\n    vec2 d2 = sdBridge(pos);\n    if( d2.x<res.x )\n    {\n        res.xy = d2;\n        outMat = 2.0;\n    }\n    }\n    //-------\n    float d = sdGround(pos);\n    if( d<res.x )\n    {\n        res.x = d;\n        outMat = 4.0;\n    }\n    //-------\n    float bb = pos.z+450.0;\n    if( bb<d )\n    {\n    vec3 d2 = sdForest(pos,d);\n    if( d2.x<res.x )\n    {\n        res.x = d2.x;\n        res.y = d2.y;\n        res.z = d2.z;\n        outMat = 3.0;\n    }\n    }\n    \n    return res;\n}\n\n// The landscape SDF again, but with extra high frequency\n// modeling detail. While the previous one is used for\n// raymarching and shadowing, this one is used for normal\n// computation. This separation is conceptually equivalent\n// to decoupling detail from base geometry with \"normal\n// maps\", but done in 3D and with SDFs, which is way simpler\n// and can be done correctly (something rarely seen in 3D\n// engines) without any complexity.\n//\nfloat mapD( in vec3 pos, in float time )\n{\n    float matID; vec3 kk2;\n    float d = map(pos,time,matID,kk2).x;\n    \n    if( matID<1.5 ) // water\n    {\n        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);\n        g = g*g;\n    \tfloat f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);\n        d -= g*12.0*(0.5+0.5*f*g*2.0);\n    }\n    else if( matID<2.5 ) // bridge\n    {\n    \td -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));\n    }\n    else if( matID<4.5 ) // ground\n    {\n    \tfloat dis = fbm1(iChannel0,0.1*pos);\n    \td -= 3.0*dis;\n    }\n    \n    return d;\n}\n\n// Computes the normal of the girl's surface (the gradient\n// of the SDF). The implementation is weird because of the\n// technicalities of the WebGL API that forces us to do\n// some trick to prevent code unrolling. More info here:\n//\n// https://iquilezles.org/articles/normalsSDF\n//\nvec3 calcNormal( in vec3 pos, in float time, in float t )\n{\n    float eps = 0.001*t;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + \n\t\t\t\t\t  e.yyx*mapD( pos + e.yyx*eps,time ) + \n\t\t\t\t\t  e.yxy*mapD( pos + e.yxy*eps,time ) + \n\t\t\t\t\t  e.xxx*mapD( pos + e.xxx*eps,time ) );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time);\n        //if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n// Compute soft shadows for a given light, with a single ray\n// insead of using montecarlo integration or shadowmap\n// blurring. More info here:\n//\n// https://iquilezles.org/articles/rmshadows\n//\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    // first things first - let's do a bounding volume test\n    float tm = (480.0-ro.y)/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    // raymarch and track penumbra\n    for( int i=ZERO; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 25.0 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n// Computes convexity for our landscape SDF, which can be\n// used to approximate ambient occlusion. More info here:\n//\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n//\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, float sca, in vec2 px )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,px/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*1.0*sca;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>10000.0 ) break;\n    }\n\tao /= 16.0;\n    return clamp( 1.0-ao*2.0/sca, 0.0, 1.0 );\n}\n\n// Computes the intersection point between our landscape SDF\n// and a ray (coming form the camera in this case). It's a\n// traditional and uncomplicated SDF raymarcher. More info:\n//\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n//\nvec2 intersect( in vec3 ro, in vec3 rd, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float tmax = 2500.0;\n    float t = 15.0;\n\t// bounding volume test first    \n    float tm = (480.0-ro.y)/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    // raymarch\n    for( int i=ZERO; i<1024; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( (h.x)<0.0002*t )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.8;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n// Renders the landscape. It finds the ray-landscape\n// intersection point, computes the normal at the\n// intersection point, computes the ambient occlusion\n// approximation, does per material setup (color,\n// specularity, and paints some fake occlusion), and\n// finally does the lighting computation.\n//\nvec4 renderBackground( in vec2 p, in vec3 ro, in vec3 rd, in float time, in vec2 px )\n{\n    // sky color\n    vec3 col = vec3(0.45,0.75,1.1) + rd.y*0.5;\n    vec3 fogcol = vec3(0.3,0.5,1.0)*0.25;\n    col = mix( col, fogcol, exp2(-8.0*max(rd.y,0.0)) );\n    \n    // -------------------------------\n    // find ray-landscape intersection\n    // -------------------------------\n    float tmin = 1e20;\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, time, cma, uvw);\n\n    // --------------------------\n    // shading/lighting\t\n    // --------------------------\n    if( tm.y>0.0 )\n    {\n        tmin = tm.x;\n        \n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormal(pos, time, tmin);\n\n        col = cma;\n\n        float ks = 1.0;\n        float se = 16.0;\n        float focc = 1.0;\n        float occs = 1.0;\n        float snow = 1.0;\n        \n    \t// --------------------------\n        // materials\n    \t// --------------------------\n\n        // water\n        if( tm.y<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            occs = 20.0;\n        }\n        // bridge\n        else if( tm.y<2.5 )\n        {\n            float f = 0.5 + 0.5*fbm1(iChannel0,pos*vec3(8,1,8));\n            ks = f*8.0;\n            se = 12.0;\n            col = mix(vec3(0.40,0.22,0.15)*0.63,\n                      vec3(0.35,0.07,0.02)*0.2,f);\n            f = fbm1(iChannel0,pos*0.5);\n            col *= 1.0 + 1.1*f*vec3(0.5,1.0,1.5);\n          \tcol *= 1.0 + 0.2*cos(cma.y*23.0+vec3(0,0.2,0.5));\n            \n            float g = 0.5 + 0.5*fbm1(iChannel0,0.21*pos);\n            g -= 0.8*nor.x*nor.x;\n            snow *= smoothstep(0.2,0.6,g);\n        }\n        // forest\n        else if( tm.y<3.5 )\n        {\n            col = vec3(0.2,0.1,0.02)*0.7;\n            focc = cma.y*(0.7+0.3*nor.y);\n            occs = 100.0;\n        }\n        // ground\n        else if( tm.y<4.5 )\n        {\n            col = vec3(0.7,0.3,0.1)*0.12;\n            float d = smoothstep(1.0,6.0,pos.y-(-36.0));\n            col *= 0.2+0.8*d;\n            occs = 100.0;\n            snow = 1.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time, occs, px );\n\n        snow *= smoothstep(0.25,0.3,nor.y);\n        if( abs(tm.y-2.0)<0.5 )\n        {\n            snow = max(snow,clamp(1.0-occ*occ*3.5,0.0,1.0));\n            snow = max(snow,cma.x);\n        }\n\n        col = mix( col, vec3(0.7,0.75,0.8)*0.6, snow);\n\t\t\n\t\t\n    \t// --------------------------\n        // lighting\n    \t// --------------------------\n        vec3 lin = vec3(0.0);\n\n        vec3  lig = normalize(vec3(0.5,0.4,0.6));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig), 0.0, 1.0 );\n        //float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        float sha = calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        dif *= sha;\n        float spe = ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        vec3  amb = occ*vec3(0.55+0.45*nor.y);\n\n        lin += col*vec3(0.4,0.7,1.1)*amb;\n        lin += col*1.4*vec3(2.3,1.5,1.1)*dif;\n        lin += spe*2.0;\n        lin += snow*vec3(0.21,0.35,0.7)*fre*fre*fre*(0.5+0.5*dif*amb)*focc;\n\n        #if 1\n        if( abs(tm.y-2.0)<0.5 )\n        {\n\t\t\tfloat dif = max(0.2+0.8*dot(nor,vec3(-1,-0.3,0)),0.0);\n\t\t\tlin += col*vec3(0.58,0.29,0.14)*dif;\n        }\n\t\t#endif\n\t\tcol = lin;\n\n        col = mix( col, vec3(0.3,0.5,1.0)*0.25, 1.0-exp2(-0.0003*tmin) );\n    }\n\n    // sun flow\n    float glow = max(dot(rd,vec3(0.5,0.4,0.2)),0.0);\n    glow *= glow;\n    col += vec3(6.0,4.0,3.6)*glow*glow;\n\n    return vec4(col,tmin);\n}\n    \n// The main rendering entry point. Basically it does some\n// setup or creating the ray that will explore the 3D\n// scene in search of the landscape for each pixel, does\n// the rendering of the landscape, and performs the\n// Temporal Antialiasing before spiting out the color (in\n// linear space, not gama) and the deph of the scene.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render\n    vec2 o = hash3( uint(iFrame) ).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        \n    float time = 2.0 + iTime;\n    \n    // skip pixels behind girl\n    #if 1\n    if( length((p-vec2(-0.56, 0.2))/vec2(0.78,1.0))<0.85 ||\n        length((p-vec2(-0.56,-0.4))/vec2(1.00,1.0))<0.73)\n    {\n        fragColor = vec4( 0.55,0.55,0.65,1e20 ); return;\n    }\n    #endif\n\n    // camera movement\t\n    vec3 ro; float fl;\n    mat3 ca = calcCamera( time, ro, fl );\n    vec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))/1.1,fl));\n\n    vec4 tmp = renderBackground(p,ro,rd,time,fragCoord);\n    vec3 col = tmp.xyz;\n\n    //---------------------------------------------------------------\n\t// reproject from previous frame and average (cheap TAA, kind of)\n    //---------------------------------------------------------------\n    \n    mat4 oldCam = mat4( textureLod(iChannel1,vec2(0.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(1.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(2.5,0.5)/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    bool oldStarted = textureLod(iChannel1,vec2(3.5,0.5)/iResolution.xy, 0.0).x>0.5;\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*tmp.w,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = fl * cpos.xy / cpos.z;\n    // undo composition hack\n    npos = npos*1.1+vec2(-0.52,0.12); \n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= o/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<4.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel1, spos, 0.0 ).xyz;\n    \tif( !oldStarted ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    //----------------------------------\n    bool started = textureSize(iChannel0,0).x>=2 &&\n                   textureSize(iChannel2,0).x>=2 &&\n                   textureSize(iChannel3,0).x>=2;\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<4.0 )\n    {\n        if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( started?1.0:0.0, 0.0, 0.0, 0.0 );\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, tmp.w );\n    }\n    \n    if( !started ) fragColor = vec4(0.0);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Depth of Field (depth defocus) on the background. It's a basic\n// gather approach, where each pixel's neighborhood gets scanned\n// and the Circle of Confusion computed for each one of those\n// neighbor pixels. If the distance to the pixel is smaller than\n// the Circle of Confusion, the current pixel gets a contribution\n// from it with a weight that is inversely proportional to the\n// area of the Circle of Confusion, to conserve energy.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 ref = texelFetch( iChannel0, ivec2(fragCoord),0);\n    \n    vec2 q = fragCoord/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 9;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off/vec2(1280.0,720.0) ); \n\n        float coc = 0.01 + 9.0*(1.0-1.0/(1.0+0.01*abs(tmp.w)));\n        \n        if( dot(off,off) < coc*coc )\n        {\n            float w = 1.0/(coc*coc); \n            acc += vec4(tmp.xyz*w,w);\n        }\n    }\n    vec3 col = acc.xyz / acc.w;\n\n    fragColor = vec4(col,ref.w);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzh.jpg", "access": "api", "license": "proprietary-license", "functions": [[1767, 1876, 1953, 1953, 2612], [2614, 2727, 2757, 2757, 3931], [3933, 4111, 4169, 4169, 4339], [4460, 5531, 5603, 5603, 12183], [12185, 12623, 12664, 12664, 13103], [13105, 13388, 13435, 13435, 14001], [14003, 14199, 14301, 14361, 14827], [14829, 15007, 15071, 15071, 15570], [15572, 15828, 15928, 15928, 16643], [16645, 16853, 16887, 16887, 17056], [17058, 17338, 17370, 17370, 17546], [17548, 18255, 18352, 18454, 27972], [27974, 28120, 28153, 28153, 28334], [28336, 28657, 28705, 28738, 29239]]}
{"id": "wdyBRh", "name": "Ckeckercube Animation", "author": "oneshade", "description": "I had fun with the first two animations I made for the swirled series so I decided to make some extra ones for fun.", "tags": ["cube", "animation", "checker", "cubemapping", "looping"], "likes": 5, "viewed": 165, "published": 3, "date": "1606520616", "time_retrieved": "2024-07-30T20:33:31.525782", "image_code": "float sceneMap(in vec3 p) {\n    vec3 q = abs(p) - 1.0;\n    return max(q.x, max(q.y, q.z));\n}\n\nvec3 colorMap(in vec3 p) {\n    vec3 n = abs(p);\n    float m = max(n.x, max(n.y, n.z));\n\n    vec2 uv = p.xy;\n    bool flip = false;\n    if (m == n.z) {\n        flip = p.z > 0.0;\n    }\n\n    if (m == n.x) {\n        uv = p.yz;\n        flip = p.x < 0.0;\n    }\n\n    if (m == n.y) {\n        uv = p.xz;\n        flip = p.y < 0.0;\n    }\n\n    uv *= 4.0;\n    float fill = mod(floor(uv.x) + floor(uv.y), 2.0);\n    if (flip) {\n        fill = 1.0 - fill;\n    }\n\n    return vec3(fill);\n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, in float t) {\n    float distTraveled = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 pos = ro + rd * distTraveled;\n\n        float time = mod(t, 4.5);\n\n        float t1 = clamp(time * 3.0 - 3.0, 0.0, 6.28);\n        t1 = pow(t1, 1.0 + sin(t1 * 0.5));\n        float t2 = clamp(time - 3.34, 0.0, 1.0);\n        float t3 = min(3.0, time * 3.0);\n\n        pos.z += t3;\n        pos.z -= t2 * 3.0;\n\n        float c = cos(t1);\n        float s = sin(t1);\n        pos.xz = vec2(pos.x * c + pos.z * s, pos.x * s - pos.z * c);\n\n        float tumble = t2 * 1.57;\n        c = cos(tumble);\n        s = sin(tumble);\n        pos.yz = vec2(pos.y * c - pos.z * s, pos.y * s + pos.z * c);\n\n        float dist = sceneMap(pos);\n        if (dist < 0.001) {\n            return colorMap(pos);\n        }\n\n        if (distTraveled > 1000.0) {\n            break;\n        }\n\n        distTraveled += dist;\n    }\n\n    return vec3(0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float tSamples = 0.0;\n    for (float tOffset=0.0; tOffset > -0.006; tOffset -= 0.001) {\n        fragColor.rgb += raymarch(vec3(0.0, 0.0, 3.0), normalize(vec3(uv, -1.0)), iTime + tOffset);\n        tSamples += 1.0;\n    }\n\n    fragColor /= tSamples;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 92], [94, 94, 120, 120, 565], [567, 567, 618, 618, 1514], [1516, 1516, 1571, 1571, 1933]]}
{"id": "3dyfz1", "name": "Day 339 - Cookie Collective", "author": "jeyko", "description": "some stuff for cookie collective stream, modified a bit.", "tags": ["mdtmjvm"], "likes": 4, "viewed": 388, "published": 3, "date": "1606516318", "time_retrieved": "2024-07-30T20:33:32.487211", "image_code": "// Improv live coded in 30 minutes\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n#define T iTime\n\n#define pi acos(-1.)\n#define rot(j) mat2(cos(j),sin(j),-sin(j),cos(j))\n\nfloat sdLine(vec2 uv,vec2 a, vec2 b){\n  float d = 10e5;\n  vec2 dir = normalize(b - a);\n  float ang = atan(dir.y, dir.x);\n  \n  vec2 uvrota = (uv - a)*rot(ang);\n  vec2 uvrotb = (uv - b)*rot(ang);\n  \n  d = abs( uvrota.y);\n  \n  d = max(d, -(uvrota).x);\n  d = max(d, (uvrotb).x);\n  \n  return d;\n}\n\n#define xor(a,b,c) min(max(a,-b),max(-a+c,b))\n\nfloat r11(float a){ return fract(sin(a*225.12321)*21.45123);}\n\nfloat fbm(float a){ return mix(r11(floor(a)),r11(floor(a) + 1.),fract(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 oouv = uv;\n  \tvec3 col = vec3(0);\n\tfloat seg = floor(T/4.);\n  \tfor(float i = 0.; i < 3.; i++){\n        uv = oouv + i*.04*pow(length(uv),4. - fbm(T));\n\n        float r = r11(seg);\n        float rb = r11(seg + 2.);\n\n        float d = 10e5;\n\n        float ang = floor(r*4. + 4.)*pi/4.;\n\n        float amt = floor(r*9.);\n\n        #define md(g) fbm(T*(0.1 + rb) + g)\n        vec2 ouv = uv;\n        uv *= rot(ang);\n        for(float ii = 0.; ii < amt + 2.; ii++){\n          float rc = r11(ii + seg);\n          float rd = r11(ii + seg +21421.3213);\n          //float l = sdLine(uv + vec2(0 + md(i*0.02)*0.,0),vec2(0. - rc,0.), vec2(0. + rd,0.)) - 1.;\n          float l = sdLine(uv + vec2(0. + md(ii*0.42)*0.6,0),vec2(0. - rc,0.), vec2(0. + rd,0.)) - 0.01;\n          uv.y += r11(ii + seg + 124.213)*0.1;\n\n\n\n          d = min(d,l);\n\n        }\n\n\n        for(float ii = 0.; ii < amt + 3.; ii++){\n            uv = abs(uv) - 0.2*r;\n            float b = length(uv) - 0.2;\n            b = abs(b) - r11(ii + 12. + seg)*0.04;\n\n            d = xor(d,b,0.2);\n        }\n\n        d = smoothstep(dFdx(ouv.x),0.,d);\n        col[int(i)] += d;\n        \n        \n        //col = mix(col,vec3(1),smoothstep(dFdx(uv.x)*2.,0.,d + dFdx(uv.x)*0.));\n\n\n        vec4 f = smoothstep(0.,1.,fbm(uv*50.));\n        vec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n\n        f.x = pow(f.x, 5.);\n\n        float n = 0.;\n        n += f.x*.5;\n        n += pow(f.y,7.)*2.5;\n        n += pow(f.z,6.)*2.5;\n        n += pow(f.w,3.)*0.1;\n\n        n += pow(g.x,6.)*3.;\n        n += pow(g.y,4.)*1.;\n        n += pow(g.z,4.)*1.;\n\n\n        n = min(n,0.5);\n\n\n        col = max(col,0.002);\n\n        if(col.x > 0.1){\n            col -= n*1.7;\n            //col -= pow(g,5.)*2.5;\n            //col -= pow(g,2.)*.9;\n        }\n        else{\n            col += pow(n,2.)*0.1;\n            //col += f*4.;\n\n        }    \n\n    \n        \n        \n        \n  \t}\n \n      col *= vec3(1.06,0.98,0.9);\n\n\tcol = pow(max(col,0.),vec3(0.454545));\n\n    \n    if (mod(seg,4.) == 0.){\n        col = 1. - col;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 57, 57, 114], [115, 115, 148, 148, 677], [678, 678, 696, 696, 1024], [1114, 1114, 1151, 1151, 1405], [1454, 1454, 1473, 1473, 1515], [1517, 1517, 1536, 1536, 1592], [1594, 1594, 1651, 1651, 3790]]}
{"id": "WdyBz1", "name": "Life experiments 5: DNA code", "author": "illus0r", "description": "Previous version https://www.shadertoy.com/view/wdcBDl", "tags": ["life"], "likes": 1, "viewed": 594, "published": 3, "date": "1606514081", "time_retrieved": "2024-07-30T20:33:33.390795", "image_code": "// image\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n\tvec4 col;// = texture(iChannel0,uv);\n    //fragColor = col;\n    \n    for(float i=0.;i<R;i++){\n        for(float j=0.;j<R;j++){\n            vec2 ij = vec2(i,j);\n            //vec2 ij = vec2(0.);\n\t\t    //col += texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n\t\t    col = max(col,\n                      texture(iChannel1,(floor((FC))+ij)/iResolution.xy)\n                      //*\n                      //step(.00001,length(texture(iChannel0,(floor((FC))+ij)/iResolution.xy)))\n                     );\n        }\n    }\n    fragColor = col*1.5;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//a\n\n/*\nIN PROGRESS\n\n1 slow down\n0 //do nothing\n2 //speed up\n3 replicate\n4 die\n5 //jump (destination is described by next twodigits)\n//or one digit which is amount of steps backward\n//we dont remember the state: DNA rewinds when the \n6 //jumpif()\n7 mutate\n8 //do nothing\n9 //do nothing\n\nmax DNA lendth \n= 4 (rgba) * 5(float significant digits)\n= 20 digits\n\n\n\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    if(rnd(uv.x+uv.y+iTime+1.)*.5+.5<DEATH_P){\n        fragColor=vec4(.0);\n        return;\n    }\n    \n    // spawning cells\n    if(mod(float(iFrame),50000.)<=1.){\n        fragColor=vec4(0.);\n        if(abs(length((uv-.5)/iResolution.x*iResolution.xy)-.0000001)<9.001){\n            fragColor=vec4(.5,.5,.5,.5);\n        }\n        return;\n    }\n\n    // find guest\n    vec2 guest_ij;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=vec4(p,v*.5+.5);\n                break;\n            }\n        }\n    }\n    \n    // no guests\n    if(!is_guest_found){\n        vec2 ij=REPL_DIR;\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.&&rnd(uv.x+uv.y+iTime)*.5+.5<BIRTH_P*(1.+3.*length(texture(iChannel1,uv).r))/4.){\n            fragColor = vec4(.5);\n            return;\n        }\n        \n        fragColor = vec4(0.);\n        return;\n    }\n\n    \n    \n    //  ,    \n    for(float i=guest_ij.x-R;i<=guest_ij.x+R;i++){\n        for(float j=guest_ij.y-R;j<=guest_ij.y+R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 8.;\n            \t//f+=normalize(fragColor.rg-p)/dist*dist;\n            \tf+=normalize(fragColor.rg-p)*(target_dist-dist)*.5;\n            }\n        }\n    }\n    \n    if(length(fragColor)>0.){\n        p = fragColor.rg;\n        v = fragColor.ba*2.-1.;\n        p=fract(p+v);\n        v*=INERTIA;\n        //v.x+=.1*(snoise(uv*4.));\n        //v.y+=.1*(snoise(uv*4.+99.+iTime/2.));\n        v += f*.1;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        fragColor.rg = p;\n        fragColor.ba = v*.5+.5;\n        //fragColor.b = .5;\n        //fragColor.a = 1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// common\n#define R 4.\n#define max_speed 1.\n#define INERTIA .7\n#define BIRTH_P .02\n#define DEATH_P .01\n#define RESET_CYCLE 100000.\n#define REPL_DIR vec2(1.)\n// mod(floor(float(iFrame)),2.)==0.?1.:-1.\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}", "buffer_b_code": "//b\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    \n    //   .\n    if(iFrame<1 || mod(float(iFrame),RESET_CYCLE)<=1.){\n        fragColor.r = (rnd(uv.x+uv.y)*.5+.5);\n        fragColor.g = 1.-(rnd(uv.x+uv.y)*.5+.5);\n        fragColor.b = 1.-(rnd(uv.x+uv.y)*.5+.5);\n        fragColor = texture(iChannel2,uv);\n        return;\n    }\n    \n    //          \n    vec2 guest_ij, v, p;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=texture(iChannel1, uv_n);\n                fragColor=mix(fragColor,texture(iChannel2, uv_n),.00);\n                break;\n            }\n        }\n    }\n    \n    //  \n    //   ,     , \n    //   .\n    \n    //  \n    if(!is_guest_found){\n        vec2 ij=REPL_DIR;\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        // replication\n        if(length(neighbour)>0.){\n            fragColor = texture(iChannel1, uv_n);\n            fragColor.r+=rnd(uv.x+uv.y+iTime*.123456)/50.;\n            fragColor.g+=rnd(uv.x+uv.y+iTime*.223456)/50.;\n            fragColor.b+=rnd(uv.x+uv.y+iTime*.323456)/50.;\n            return;\n        }\n        fragColor = vec4(0.);\n        return;\n    }\n\n\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 59, 59, 639]]}
{"id": "3dyBR1", "name": "Dryengulater (Triangulator fork)", "author": "UrbanClubProfessional", "description": "Remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]", "tags": ["3d", "raymarching", "triangle", "remix", "abstract", "glitch", "barycentric", "heightmap", "fork", "weird", "error", "japan", "triangulation", "sakura"], "likes": 2, "viewed": 451, "published": 3, "date": "1606510695", "time_retrieved": "2024-07-30T20:33:34.248502", "image_code": "// Hacked and cracked by Urban Club Professional!\n\n#define ITR 70\n#define FAR 200.\n#define time iTime*0.3\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(1.034, 0.458, -0.458, 1.034);\nfloat tri(in float x){return abs(fract(x)-0.6);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.06;\n    float z=3.;\n\tfloat rz = 1.;\n\tfor (float i= 2.;i < 5.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*1.5))/z;\n        z = z*-.05;\n\t\tp = p*2.32;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*1.0))*.8+.4;\n\treturn rz*0.1;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 2.0 / (v0.x * v1.y - v1.x * v0.y)+2e-10;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 2.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.6;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.6, iq.z+.6);\n    vec2 p2 = vec2(iq.x+.6, iq.z-.6);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.6*sw, iq.z+.6*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.6*sw,.6*sw),vec2(-.6,.6),vec2(.6,-.6), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 4.)*1.0;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*3.0;\n    float d = 1.;\n    for( int i=1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*2.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*0.02;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.6;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.55+sin(time*0.8)*3., -.28);\n    \n    vec3 ro = vec3(sin(time*0.8+2.)*30.,4., time*60.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*6., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708), 1., sin(um.x+2.5708)));\n    right.xy *= mm2(sin(time*0.8)*0.4);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*2.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.3, 0.06, -0.3));\n        \n        float dif = clamp(dot( nor, ligt ), 1., 2.);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.1,2.0), 4.);\n        vec3 brdf = 2.*vec3(0.20,0.21,0.2);\n        brdf += 2.9*dif*vec3(.9,2.,.06);\n        col = vec3(0.45,0.08,0.6);\n        col = col*brdf + fre*0.6*vec3(.8,.9,2.);\n    }\n    col = clamp(col,1.,2.);\n\tcol = pow(col,vec3(1.0));\n    col *= pow( 6.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.2);\n\tfragColor = vec4( col, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 128, 128, 180], [226, 226, 248, 248, 274], [276, 276, 304, 304, 527], [529, 585, 629, 629, 905], [907, 1061, 1080, 1080, 1516], [1518, 1518, 1555, 1555, 1796], [1988, 1988, 2045, 2045, 3164]]}
{"id": "WsyfRh", "name": "Tentacles of Light", "author": "oneshade", "description": "I've always been mesmerized by the screensaver on my dad's iMac and I thought it was the perfect thing to create with a shader.", "tags": ["hsv", "screensaver", "tentacles", "apple", "imac"], "likes": 5, "viewed": 297, "published": 3, "date": "1606498796", "time_retrieved": "2024-07-30T20:33:35.023430", "image_code": "float Hash11(in float x) {\n    return fract(sin(x * 1254.5763) * 57465.57);\n}\n\nvec3 hue2rgb(in float hue) {\n    hue *= 6.0;\n    float x = 1.0 - abs(mod(hue, 2.0) - 1.0);\n\n    vec3 rgb = vec3(1.0, x, 0.0);\n    if (hue < 2.0 && hue >= 1.0) {\n        rgb = vec3(x, 1.0, 0.0);\n    }\n\n    if (hue < 3.0 && hue >= 2.0) {\n        rgb = vec3(0.0, 1.0, x);\n    }\n\n    if (hue < 4.0 && hue >= 3.0) {\n        rgb = vec3(0.0, x, 1.0);\n    }\n\n    if (hue < 5.0 && hue >= 4.0) {\n        rgb = vec3(x, 0.0, 1.0);\n    }\n\n    if (hue < 6.0 && hue >= 5.0) {\n        rgb = vec3(1.0, 0.0, x);\n    }\n\n    return rgb;\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float t = iTime * 0.25;\n    float c = cos(t), s = sin(t);\n    uv -= vec2(cos(t), sin(t)) * 0.15;\n\n    for (float tentacleID=0.0; tentacleID < 8.0; tentacleID++) {\n        float distFromOrigin = length(uv);\n        float tentacleHash = Hash11(tentacleID + 1.0);\n        float angle = tentacleID / 4.0 * 3.14 + iTime * (tentacleHash - 0.5);\n\n        vec3 tentacleColor = hue2rgb(fract(0.5 * (distFromOrigin - 0.1 * iTime)));\n        float fadeOut = 1.0 - pow(distFromOrigin, sin(tentacleHash * iTime) + 1.5);\n\n        vec2 offsetVector = uv.yx * vec2(-1.0, 1.0);\n        vec2 offset = offsetVector * sin(tentacleHash * (distFromOrigin + tentacleHash * iTime)) * (1.0 - distFromOrigin);\n\n        color += smoothstep(0.03, 0.0, line(uv + offset, vec2(0.0, 0.0), vec2(cos(angle), sin(angle)) * 1000.0)) * fadeOut * tentacleColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 77], [79, 79, 107, 107, 597], [599, 599, 644, 644, 752], [754, 754, 809, 809, 1776]]}
{"id": "WsGfRh", "name": "Runner illusion", "author": "Nrx", "description": "Nothing moves...\n\n(Click to stop the animation.)\n\np.s.: An optimized (pre-rendered) version is [url=https://www.shadertoy.com/view/wdVBzh]here[/url].", "tags": ["optical", "illusion"], "likes": 14, "viewed": 481, "published": 3, "date": "1606494784", "time_retrieved": "2024-07-30T20:33:35.808331", "image_code": "// Inspired by: https://twitter.com/jagarikin/status/1329610899976437765\n\n#define PI\t\t\t3.14159265358979\n#define REPEAT\t\t0.3\n#define HEIGHT\t\t2.2\n#define THICKNESS\t0.025\n#define COLOR_SPEED\t0.04\n#define COLOR_DELAY\t4.0\n#define OUTLINE\t\t2.0\n#define DELTA\t\t0.0001\n\nvec4 color (in float t) {\n\treturn vec4 (vec3 (abs (2.0 * fract (t * COLOR_SPEED) - 1.0)), 1.0);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nfloat charDist (in vec2 p, in float jump) {\n\tp.y -= 0.25;\n\tfloat d = length (p - vec2 (0.0, 0.1)) - 0.04;\n\td = min (d, segDist (p, vec2 (0.0, 0.1), vec2 (-0.02, -0.1)));\n\tif (jump < 0.5) {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.04, -0.15)));\n\t\td = min (d, segDist (p, vec2 (0.04, -0.15), vec2 (0.08, -0.22)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.05, -0.16)));\n\t\td = min (d, segDist (p, vec2 (-0.05, -0.16), vec2 (-0.1, -0.2)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.06, -0.03)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.03), vec2 (0.1, -0.05)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (-0.08, -0.01)));\n\t\td = min (d, segDist (p, vec2 (-0.08, -0.01), vec2 (-0.09, -0.05)));\n\t} else {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.06, -0.1)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.1), vec2 (0.04, -0.2)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.02, -0.18)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.18), vec2 (-0.06, -0.24)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.07, 0.15)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.05, 0.02)));\n\t\td = min (d, segDist (p, vec2 (0.05, 0.02), vec2 (0.11, 0.06)));\n\t}\n\treturn d - THICKNESS;\n}\n\nfloat charY (in float x) {\n\tx = floor (x / REPEAT) * REPEAT;\n\treturn max (0.0, HEIGHT - mix (-x, x * x * 0.8, step (0.0, x)));\n}\n\nfloat frameDist (in vec2 p) {\n\n\t// Vertical position of the character\n\tfloat dy = charY (p.x);\n\n\t// Distance to the stairs\n\tfloat d = p.y;\n\tif (p.x < -REPEAT * 0.5) {\n\t\tfloat dx = ceil ((p.y - HEIGHT) / REPEAT) * REPEAT;\n\t\tvec2 q = vec2 (dx - p.x, p.y - dy);\n\t\td = min (d, max (min (q.x, q.y), min (max (q.x, q.y), 0.0)));\n\t}\n\n\t// Check whether the character is in the air\n\tfloat jump = step (-REPEAT, p.x) * step (DELTA, dy);\n\n\t// Distance to the character\n\tp.x = (fract (p.x / (2.0 * REPEAT)) - 0.75) * REPEAT * 2.0;\n\tp.y -= dy;\n\treturn min (d, charDist (p, jump));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tp = 1.6 * p - vec2 (0.15, -1.2);\n\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5), 1.0);\n\n\t// Display\n\tvec4 c = color (float (iFrame));\n\tfloat d = frameDist (p);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, d));\n\n\tif (iMouse.z < 0.5) {\n\t\tvec2 n = normalize (vec2 (frameDist (p - vec2 (DELTA, 0.0)), frameDist (p - vec2 (0.0, DELTA))) - d);\n\t\tvec2 v = normalize (vec2 (REPEAT, (charY (p.x) - charY (p.x - REPEAT)))) * step (2.0 * halfPixel * OUTLINE, p.y);\n\t\tfloat f = dot (n, v);\n\n\t\tc = color (float (iFrame) + COLOR_DELAY * sign (f));\n\t\td = abs (d - halfPixel * OUTLINE) - halfPixel * OUTLINE;\n\t\tfragColor = mix (fragColor, c, abs (f) * smoothstep (halfPixel, -halfPixel, d));\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 286, 286, 358], [360, 360, 409, 409, 497], [499, 499, 542, 542, 1736], [1738, 1738, 1764, 1764, 1866], [1868, 1868, 1897, 1937, 2437], [2439, 2439, 2487, 2534, 3330]]}
{"id": "wsKfzz", "name": "Kaguya Houraisan's Eternity!", "author": "UrbanClubProfessional", "description": "Remix of nimitz' Moon voxels: [url]https://www.shadertoy.com/view/tdlSR8[/url]\n\nThe title of this remix is a Touhou-themed joke. *lol*", "tags": ["voxel", "remix", "glitch", "moon", "fork", "weird", "error", "hybrid", "diorama", "explorers"], "likes": 0, "viewed": 594, "published": 3, "date": "1606488427", "time_retrieved": "2024-07-30T20:33:36.761782", "image_code": "// Moon voxels\n// by nimitz 2019 (twitter: @stormoid)\n// https://www.shadertoy.com/view/tdlSR8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tShowing off a hybrid sphere-tracing(raymarching)/\n\tvoxel intersection hybrid algorithm with this little diorama.\n\t\n\tA few other technically interesting things about this shader:\n\t\n        -A new method for rendering 3D terrain, using summed triangle\n        wave octaves with rotation and displacement, will post more on this\n        technique soon.\n\t\n        -2D triangle folding for the modelling of the rocket to speed up\n        evaluation, this type of space folding (be it 2D or 3D) can be used \n        with any geometry that has any type of symmetry to accelerate evals.\n\n\t\t-A very simple form of AA, displacing the screen each frame by\n\t\ta fraction of a pixel to get only the pixels on the edge of the coverage\n\t\tlimit and blending over a few frames to smooth the result.\n\n\tAs for the rendering of this scene:\n\n\tMaterials are defined per-voxel and the colors are quantitized to 16 \n\tcolors per channel to replicate the \"pixel art\" look but the lighting \n\tcalculations are done in full color. Also using voxel AO based on fb39ca4's\n\ttechnique, which is barely visible in non-fullscreen mode.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    col = 2.12*pow( col, vec3(1.06,1.05,2.0) ) + vec3(-0.05,-0.05, -0.02); //Correction\n    \n    fragColor = vec4( col, 2.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKfzz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1340, 1340, 1397, 1397, 1637]]}
{"id": "wdKfRz", "name": "Yet another illusion...", "author": "Nrx", "description": "Nothing moves but the arrow!", "tags": ["optical", "illusion"], "likes": 11, "viewed": 384, "published": 3, "date": "1606474337", "time_retrieved": "2024-07-30T20:33:37.963570", "image_code": "#define PI\t\t\t\t3.14159265358979\n#define DISC_COUNT\t\t9.0\n#define DISC_DIST\t\t0.7\n#define DISC_RADIUS\t\t0.1\n#define HUE_SPEED\t\t0.06\n#define HUE_STEP\t\t3.0\n\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.6 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the direction\n\tfloat dir = sign (cos (iTime * 0.8));\n\n\t// Display the direction\n\tvec2 q = p *rotate (iTime * dir * 0.2);\n\tq.x *= dir;\n\tvec2 tip = vec2 (-0.01, 0.3);\n\tfloat d = max (abs (length (q) - tip.y), min (-q.x, q.x + q.y));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, 0.05)));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, -0.05)));\n\td -= 0.01;\n\tfragColor *= smoothstep (-halfPixel, halfPixel, d);\n\n\t// Divide the plan in DISC_COUNT sectors\n\tconst float arc = 2.0 * PI / DISC_COUNT;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\tp.x -= DISC_DIST;\n\n\t// Display the discs\n\tfloat h = float (iFrame) * HUE_SPEED;\n\tvec3 hsv = vec3 (h, 0.9, 0.8);\n\n\td = length (p) - DISC_RADIUS;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), step (d, 0.0));\n\n\tp.y *= dir;\n\td = max (d, -d - 2.0 * halfPixel);\n\n\thsv.x = h - HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, -p.y)));\n\n\thsv.x = h + HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, p.y)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 178, 178, 305], [307, 307, 337, 337, 415], [417, 417, 466, 466, 554], [556, 556, 604, 651, 1963]]}
{"id": "wdVBRR", "name": "Transport Dynamics", "author": "wyatt", "description": "At twenty, if you are not an idealist, then you don't have a heart. If you continue being an idealist, then you don't have a brain. ", "tags": ["fluid"], "likes": 22, "viewed": 655, "published": 3, "date": "1606448360", "time_retrieved": "2024-07-30T20:33:38.794348", "image_code": "Main {\n    vec4 a = A(U);\n\tQ = 1.1-atan(1.5*a.w)*(0.8+0.5*sin(.6+a.z+vec4(1,2,3,4)));\n    //Q = a.wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_a_code": "// Apply forces\nvec2 F (vec2 u) {\n    vec4 a = A(gl_FragCoord.xy + u);\n\treturn .125*max(a.w-.25,0.)*(a.w-.5)*u/dot(u,u);\n}\nMain {\n\tQ = A(U);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    if (x!=0||y!=0)\n       Q.xy -= F(vec2(x,y));\n   \n    Q.y -= .2/R.y*(1.+Q.z);\n\t//if (length(Q.xy)>2.) Q.xy = 2.*normalize(Q.xy);\n    if (iFrame < 1) {\n    \tQ = vec4(0,0,0,0);\n        if (U.y<.5*R.y) Q.w = 1.;\n        if (length(U-0.5*R)<0.25*R.y) Q.zw = vec2(4.,1);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<20.)\n        Q = vec4(1,0,6,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Conservative advect y-direction\nMain {\n    Q = vec4(0);\n    if (iFrame%2==0)\n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(0,i);\n        vec4 a = .5*A(U+u-vec2(0,0.5)),\n             b = A(U+u),\n             c = .5*A(U+u+vec2(0,0.5));\n        float w1 = 1.+c.y-a.y;\n        if (w1>0.) {\n            float w = clamp(u.y+.5+c.y,-.5,.5)-\n                      clamp(u.y-.5+a.y,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    } else \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(i,0);\n        vec4 a = .5*A(U+u-vec2(0.5,0)),\n             b = A(U+u),\n             c = .5*A(U+u+vec2(0.5,0));\n        float w1 = 1.+c.x-a.x;\n        if (w1 > 0.) {\n            float w = clamp(u.x+.5+c.x,-.5,.5)-\n                      clamp(u.x-.5+a.x,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    }\n    if (Q.w > 0.) Q.xyz /= Q.w;\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// density-dependent diffusion\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = Q.w-a.w;\n    return mix(Q,a,clamp(1.*f*f,0.,1.));\n}\nMain {\n    Q = A(U);\n    Q = (\n        0.125*X(Q,vec2(1,0))+\n        0.125*X(Q,vec2(0,1))+\n        0.125*X(Q,vec2(-1,0))+\n        0.125*X(Q,vec2(0,-1))+\n        0.125*X(Q,vec2(1,1))+\n        0.125*X(Q,vec2(1,-1))+\n        0.125*X(Q,vec2(-1,-1))+\n        0.125*X(Q,vec2(-1,1)));\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)\n        Q = vec4(.5,0,6,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "3sKBRz", "name": "glooper", "author": "Del", "description": "gloop - - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]\n", "tags": ["gloop"], "likes": 3, "viewed": 339, "published": 3, "date": "1606429904", "time_retrieved": "2024-07-30T20:33:39.605180", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 400.0\n#define SURF_DIST 0.01\n\nfloat sdSphere(vec3 p, vec4 s){\n\treturn  length(p-s.xyz)-s.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p){\n    \n   \tfloat sd = sdSphere(p,vec4(0,1,6,1));\n\tfloat v = 0.5+sin(iTime*2.4 + p.z*5.4+p.y*3.4+p.x*4.1)*0.5;\n\tsd += v*0.25;\n\tfloat k = 3.5+sin(p.y*3.2+iTime*3.16);\n    float d = smin(sd*0.75,p.y+.5,k);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS;i++){\n        vec3 p = ro + rd  * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    \n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.005,0);\n    \n    \n    vec3 n = d - vec3(GetDist(p - e.xyy),\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p,vec3 rd)\n{\n    float t = fract(iTime*0.54)*6.28;\n\tvec3 lightPos = vec3(0,8.+sin(t+p.z)*5.0,3);\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.0,1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    \n    if(d < length(lightPos-p))\n        dif *= .5;\n    else\n    {\n\t    vec3 ref = reflect(rd, n);\n\t\tfloat spe = max(dot(ref, l), 0.0);\n\t  \tdif += pow(spe,64.0);\n    }\n\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0,2,-2.5);\n    vec3 rd = normalize(vec3(uv.x,uv.y-.3,2));\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd *d;\n    float dif = GetLight(p,rd);\n    col = vec3(dif*(1.0+sin(rd.x)),dif,dif*0.8);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 100, 100, 132], [134, 134, 175, 175, 268], [270, 270, 292, 292, 509], [511, 511, 544, 544, 776], [779, 779, 802, 802, 1022], [1025, 1025, 1057, 1057, 1496], [1500, 1500, 1557, 1557, 1889]]}
{"id": "tsGBzR", "name": "Swirled Series", "author": "s23b", "description": "Made for the [url=https://isohedral.ca/swirled-series/]Swirled Series[/url]\n\nUse the mouse to stop the random nonsense and take control!", "tags": ["checkerboard", "short"], "likes": 8, "viewed": 441, "published": 3, "date": "1606425154", "time_retrieved": "2024-07-30T20:33:40.505772", "image_code": "#define PI 3.14159265359\n\nfloat seed;\n\nfloat hash(vec2 uv) {\n  float f = fract(cos(dot(uv ,vec2(.09123898,.0231233))) * 11111.5452313);\n    return f;\n}\n\n// xor for floats between 0. and 1.\nfloat xor(float a, float b) {\n    return mix(a, 1. - a, b);\n}\n\n// split view in 4 quadrants, alternating between black and white,\n// rotated by a mix of a1 and a2 angles (motion blur between the 2 states)\nfloat divider(vec2 uv, float a1, float a2) {\n    // skip calculations if not animating\n    if (a1 != 0. && a1 != 1. || a2 != a1) {\n        // calculate angle\n    \tfloat a = atan(uv.y, uv.x) / PI;\n        \n        // add curvy bit\n        a -= length(uv) * .02 * smoothstep(.5, .0, abs(a1 - .5));\n        \n        // calculate blur width\n        float w = (a2 - a1) / 2.;\n        a += a1 + w * .5;\n        if (a > 1.) --a;\n\n        float d1 = clamp((abs(a) - .5) / w + .5, 0., 1.);\n        float d2 = clamp((abs(1. - abs(a + .5)) - .5 ) / w + .5, 0., 1.);\n        return xor(d1, d2);\n    }\n    \n    return xor(step(0., uv.x), step(0., uv.y));\n}\n\n// calculate rotation angle from grid point and elapsed time\nfloat angle(vec2 p, float t) {\n    // pick random gridpoints to rotate\n    if (hash(p + seed) < .04) {\n        return smoothstep(0., -11., p.x * 1.5 + p.y * 2.5 - t * 37. + hash(p));\n    }\n    \n    return 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord;\n    uv -= (iResolution.xy - scale) / 2.;\n    uv /= scale;\n    vec2 crop = abs(uv - .5);\n    \n    if (max(crop.x, crop.y) > .5) {\n        fragColor = vec4(.5);\n        return;\n    }\n\n    uv *= 8.;\n    uv -= 1.;\n    \n    float d = .0;\n    \n    seed = floor(iTime / 3.) * 10.;     \n    float t = fract(iTime / 3.);\n    \n    for (float x = 0.; x < 7.; ++x) {\n\t    for (float y = 0.; y < 7.; ++y) {\n            vec2 p = vec2(x, y);\n            if (iMouse.x >= 1.) {\n                float a = smoothstep(0., 1., texelFetch(iChannel0, ivec2(p), 0).x);\n     \t    \td = xor(d, divider(uv - p, a, min(1., a + 1. / 20.)));\n            } else {\n     \t    \td = xor(d, divider(uv - p, angle(p, t), angle(p, t + 1. / 60.)));\n            }\n        }\n    }\n    \n\tfragColor = vec4(d);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// store animation progress for manual mode\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = iMouse.xy;\n    uv -= (iResolution.xy - scale) / 2.;\n    uv /= scale;\n    uv *= 8.;\n    uv -= 1.;\n    \n    vec2 pixel = fragCoord;\n    \n    float prev = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    if (iFrame == 0) prev = 1.;\n    \n    if (iMouse.z > 0. && distance(uv, fragCoord - .5) < .6 && prev == 1.) {\n        fragColor = vec4(0.);\n    } else {\n        fragColor = vec4(min(1., prev + 1. / 60.));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 151], [153, 189, 218, 218, 250], [252, 394, 438, 480, 1037], [1039, 1100, 1130, 1170, 1310], [1312, 1312, 1367, 1367, 2213]]}
{"id": "tsyfRR", "name": "strange gears", "author": "FabriceNeyret2", "description": "ref: [url]https://www.youtube.com/watch?v=SwVWfrZ3Q50&feature=youtu.be&t=61[/url]", "tags": ["gears", "short", "reproduction"], "likes": 12, "viewed": 348, "published": 3, "date": "1606390358", "time_retrieved": "2024-07-30T20:33:41.414343", "image_code": "#define S(v)   smoothstep(3./R.y,0.,v)\n#define W(n,t) l * cos( ( fract(atan(U.y,U.x)*n/6.283 +.5+t -iTime ) -.5 )*6.283/n + vec2(0,1.57) ) // polar n-wrap\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y - vec2(0,.2), V;\n     float l = length(U);\n     V = W(6.,0.);\n\n    O = vec4(.7 + .3* S( abs(abs(V.y)-.05) -.005 ) ) * S(l-.7);   // main disk + rails\n    \n    U.y += .35; l = length(U);                                    // small gear\n    V = W(3.,.25);\n    O += .5 * S(abs(V.y)-.03) *  S(l-.38);\n    \n    V.x -= .34;                                                   // pins\n    O -=  S(length(V)-.01);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 194, 194, 668]]}
{"id": "Ws3BWs", "name": "line integral convolution edge", "author": "between", "description": "lic edge flow referenced by Jan Eric Kyprianidis <www.kyprianidis.com>\n", "tags": ["edgedetection", "lic", "stylization"], "likes": 5, "viewed": 576, "published": 3, "date": "1606383072", "time_retrieved": "2024-07-30T20:33:42.298979", "image_code": "// line integral convolution\n// this sigma controls the line length\nfloat sigma = 2.0;\n\nstruct lic_t {\n    vec2 p;\n    vec2 t;\n    float w;\n    float dw;\n};\n\nvoid step(inout lic_t s) {\n    vec2 imageSize = iResolution.xy;\n    vec2 t = texture(iChannel0, s.p).xy;\n    if (dot(t, s.t) < 0.0) t = -t;\n    s.t = t;\n    s.dw = (abs(t.x) > abs(t.y)) ? abs((fract(s.p.x) - 0.5 - sign(t.x)) / t.x)\n                                 : abs((fract(s.p.y) - 0.5 - sign(t.y)) / t.y);\n    s.p += t * s.dw / imageSize;\n    s.w += s.dw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 imageSize = iResolution.xy;\n    float twoSigma2 = 2.0 * sigma * sigma;\n    float halfWidth = 2.0 * sigma;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel1, uv).xyz;\n    float w = 1.0;\n    \n    lic_t a;\n    lic_t b;\n    a.p = b.p = uv;\n    a.t = texture(iChannel0, uv).xy;\n    b.t = -a.t;\n    a.w = b.w = 0.0;\n\n    for (int i = 0; i < 20; i++) {\n        if (a.w < halfWidth) {\n            step(a);\n            float k = a.dw * exp(-a.w * a.w / twoSigma2);\n            c += k * texture(iChannel1, a.p).xyz;\n            w += k;\n        } else {\n            break;\n        }\n    }\n\n    for (int i = 0; i < 20; i++) {\n        if (b.w < halfWidth) {\n            step(b);\n            float k = b.dw * exp(-b.w * b.w / twoSigma2);\n            c += k * texture(iChannel1, b.p).xyz;\n            w += k;\n        } else {\n            break;\n        }\n    }\n\n    fragColor = vec4(clamp(vec3(0.0), vec3(1.0), vec3(1.0) - c / w), 1.0);\n    // or you can change the iChannel1 into a noise map to see the field, the recommend is RGBA Noise Medium\n    // and enlarge the sigma to get a obverious result\n    //fragColor = vec4(clamp(vec3(0.0), vec3(1.0), c / w), 1.0);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// sst\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 d = vec2(1.0)/iResolution.xy;\n    \n    vec3 u = (\n        -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz +\n        -2.0 * texture(iChannel0, uv + vec2(-d.x,  0.0)).xyz + \n        -1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n        +1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n        +2.0 * texture(iChannel0, uv + vec2( d.x,  0.0)).xyz + \n        +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n        ) / 4.0;\n    vec3 v = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz + \n           -2.0 * texture(iChannel0, uv + vec2( 0.0, -d.y)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( 0.0,  d.y)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    fragColor = vec4(dot(u, u), dot(v, v), dot(u, v), 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// gaussian blur(3x3)\n#define POS(x, y) \\\n    texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 c = ( 1.0 * POS(-1.0, -1.0) +\n               4.0 * POS( 0.0, -1.0) +\n               1.0 * POS( 1.0, -1.0) +\n               4.0 * POS(-1.0,  0.0) +\n              16.0 * POS( 0.0,  0.0) +\n               4.0 * POS( 1.0,  0.0) +\n               1.0 * POS(-1.0,  1.0) +\n               4.0 * POS( 0.0,  1.0) +\n               1.0 * POS( 1.0,  1.0)\n             ) / 36.0;\n    \n    fragColor = vec4(c, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// calculate tangent flow map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n     vec3 g = texture(iChannel0, uv).xyz;\n     float lambda1 = 0.5 * (g.y + g.x + sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n     float lambda2 = 0.5 * (g.y + g.x - sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n     vec2 v = vec2(lambda1 - g.x, -g.z);\n     vec2 t;\n     if (length(v) > 0.0) { \n         t = normalize(v);\n     } else {\n         t = vec2(0.0, 1.0);\n     }\n \n     float phi = atan(t.y, t.x);\n     float A = (lambda1 + lambda2 > 0.0)?(lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n     fragColor = vec4(t, 0.0, 0.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// sobel edge detection\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \t\n\tfragColor = texture(iChannel0, uv);\n\n    vec4 a = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y+1.0/iResolution.y));\n    vec4 b = texture(iChannel0, vec2(uv.x,      uv.y+1.0/iResolution.y));\n    vec4 c = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y+1.0/iResolution.y));\n    vec4 d = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y));\n    vec4 e = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y));\n    vec4 f = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y-1.0/iResolution.y));\n    vec4 g = texture(iChannel0, vec2(uv.x,      uv.y-1.0/iResolution.y));\n    vec4 h = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y-1.0/iResolution.y));\n    \n    vec4 sobelX = a*(-1.0) + c*(1.0) + d*(-2.0) + e*(2.0) + f*(-1.0) + h*(1.0);\n    vec4 sobelY = a*(-1.0) + b*(-2.0) + c*(-1.0) + f*(1.0) + g*(2.0) + h*(1.0);\n    \n    fragColor = vec4((sobelX + sobelY).x);\n    \n}", "buffer_d_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 184, 184, 521], [523, 523, 578, 578, 1763]]}
{"id": "wsGBRR", "name": "Rings of delusion", "author": "Nrx", "description": "Nothing moves...", "tags": ["optical", "illusion"], "likes": 17, "viewed": 659, "published": 3, "date": "1606381166", "time_retrieved": "2024-07-30T20:33:43.249437", "image_code": "// Inspired by: https://twitter.com/jagarikin/status/1331409504953540613\n\n#define PI\t\t\t3.14159265358979\n#define RADIUS\t\t0.5\n#define THICKNESS\t0.1\n#define SPEED\t\t10.0\n#define STRIPS\t\t3.0\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the animation\n\tfloat select = floor (6.0 * fract (iTime * 0.03 + step (0.0, p.x) / 3.0));\n\n\t// Display the rings & marker\n\tp.x = abs (p.x) - RADIUS * 1.6;\n\n\tfloat d = length (p) - RADIUS;\n\tfloat a = atan (p.y, p.x);\n\tfloat t = STRIPS * (a + iTime * SPEED);\n\n\tvec4 c = vec4 (1.0, smoothstep (-0.05, 0.05, cos (t)), 0.0, 1.0);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, abs (d) - THICKNESS));\n\n\tfloat m;\n\tfloat f;\n\tif (select < 1.5) {\n\t\tm = abs (length (p) - 0.15 + 0.1 * select);\n\t\tf = 1.0;\n\t\tt -= PI * (0.5 + select);\n\t} else {\n\t\tfloat dir = PI * 0.5 * (select - 2.0);\n\t\tvec2 tip = 0.15 * vec2 (-sin (dir), cos (dir));\n\t\tm = segDist (p, -tip * 0.5, tip);\n\t\tm = min (m, segDist (p, tip, tip * 0.7 + 0.3 * vec2 (tip.y, -tip.x)));\n\t\tm = min (m, segDist (p, tip, tip * 0.7 - 0.3 * vec2 (tip.y, -tip.x)));\n\t\tf = abs (sin (a + dir));\n\t\tt -= PI * 0.5 * sign (dot (p, tip));\n\t}\n\tfragColor.rgb *= smoothstep (-halfPixel, halfPixel, m - 0.02);\n\n\tc.g = smoothstep (-0.05, 0.05, cos (t));\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d - THICKNESS) - 2.0 * halfPixel));\n\tc.g = 1.0 - c.g;\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d + THICKNESS) - 2.0 * halfPixel));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 236, 236, 324], [326, 326, 374, 421, 1868]]}
{"id": "WsyfzR", "name": "webcam on ufo", "author": "mds2", "description": "looking for new in-the-loop effects to use with gstreamer.  playing with this.\n\nMostly a modification of some earlier shaders.", "tags": ["webcam", "modification", "saucer"], "likes": 20, "viewed": 1686, "published": 3, "date": "1606353486", "time_retrieved": "2024-07-30T20:33:44.104151", "image_code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define MAX_DIST 8.0\n\n#define SKY_BRITE 0.6\n\n#define CRINKLY_SHIP 0 // set to 1 to give the ship some texture\n\n\nconst float atmos_thick = 30000.0;\nconst float earth_rad = 6310000.0;\n\nfloat atmos_dist(in float dir_y) {\n\t// r^2 * dir_x^2 + (earth_rad + r *dir_y)^2 =\n    // (atmos_thick + earth_rad)^2\n    // r^2 * (dir_x^2 + dir_y^2) + \n    // r * 2.0 * dir_y * earth_rad +\n    // earth_rad^2 -\n    // (atmos_thick + earth_rad)^2 = 0.0\n    // -------------------------------\n    // r^2 * (dir_x^2 + dir_y^2) + \n    // r * 2.0 * dir_y * earth_rad -\n    // atmos_thick^2 -\n    // 2.0 * atmos_thick * earth_rad = 0.0\n    // -------------------------------\n    //r = (-b + sqrt(b^2 - 4ac)) / (2a)\n    // a = 1.0\n    // b = 2.0 * dir_y * earth_rad\n\t// c = -atmos_thick^2 - 2.0 * atmos_thick * earth_rad\n    // r approx \n    // -dir_y*earth_rad + sqrt(dir_y^2+1.005)*earth_rad\n    float b = 2.0 * dir_y * earth_rad;\n    float c = -atmos_thick * atmos_thick - 2.0 * atmos_thick * earth_rad;\n    return 0.5 * (sqrt(b * b - 4.0 * c) - b);\n}\n\nfloat dist_to_sun_visible(in vec3 ray_dir, in vec3 sun_dir) {\n    if (false && ray_dir.y < 0.0) {\n        return earth_rad;\n    }\n    if (sun_dir.y > 0.0) {\n        return 1.0;\n    }\n    // e_z = sun_dir\n    vec3 e_y = normalize(vec3(0.0, 1.0, 0.0) - sun_dir.y * sun_dir);\n    vec3 e_x = normalize(cross(e_y, sun_dir));\n\n    vec2 start_xy = earth_rad * vec2(e_x.y, e_y.y);\n    vec2 ray_xy = vec2(dot(e_x,ray_dir), dot(e_y, ray_dir)); // do not normalize\n    \n    // (start_xy + d * ray_xy) ^2 = earth_rad^2\n    // dot(start_xy, start_xy) - earth_rad^2 +\n    // 2.0 * d * dot(start_xy, ray_xy) +\n    // d^2 * dot(ray_xy, ray_xy) = 0.0\n    \n    float a = dot(ray_xy, ray_xy);\n    float b = 2.0 * dot(start_xy, ray_xy);\n    float c = dot(start_xy, start_xy) - earth_rad * earth_rad;\n    \n    return abs((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a));\n    \n}\n\nfloat atmos_weight(in vec3 dir, in vec3 sun_dir) {\n    float d = atmos_dist(dir.y);\n    float ds = max(atmos_thick, dist_to_sun_visible(dir, sun_dir));\n    return max(0.0, atmos_thick/ds - (0.5 * atmos_thick)/d);\n}\n\nvec3 get_sun_dir(in float in_time) {\n    \n    float theta = mod(0.5 * in_time, 31.41592653589793);\n    float ctheta = cos(theta);\n    float stheta = sin(theta);\n    \n    mat3 rot_mat = mat3(ctheta, 0.0, -stheta,\n                        0.0, 1.0, 0.0,\n                        stheta, 0.0, ctheta);\n    const vec3 sun_dir = normalize(vec3(0.0, 0.0, 1.0));\n    \n    const mat3 tilt_mat = mat3(0.8, 0.6, 0.0,\n                               -0.6, 0.8, 0.0,\n                               0.0, 0.0, 1.0);\n    const mat3 inv_tilt_mat = mat3(0.8, -0.6, 0.0,\n                               0.6, 0.8, 0.0,\n                               0.0, 0.0, 1.0);\n    vec3 dir = tilt_mat * sun_dir;\n    dir = rot_mat * dir;\n\treturn inv_tilt_mat * dir;\n}\n\n/**\n * Found some \"Rayleigh scatter\" equations on wikipedia.\n * Mostly copied them, but dropped some terms and simplified others.\n *\n * Vaguely ends up looking like a blue sky.\n */\nvec3 sky_color(in vec3 dir) {\n\tvec3 sun_dir = get_sun_dir(-0.1); // -1.5);\n    const vec3 lambdas = vec3(0.6, 0.5, 0.45);\n    const vec3 sky_color_weights = vec3(0.9, 1.0, 0.8);\n    const vec3 scatter_terms =\n        sky_color_weights * vec3(0.0625) / (lambdas * lambdas * lambdas * lambdas);\n    float cos_theta = max(min(dot(dir, sun_dir), 1.0), -1.0);\n    float dir_factor = (1.0 + cos_theta * cos_theta) * 0.5;\n    float w = atmos_weight(dir, sun_dir);\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n    vec3 scatter_factor = w * 2.0 * scatter_terms;\n    vec3 passthru = max(1.0 - scatter_factor, vec3(0.0));\n    float direct_intense = smoothstep(0.02, 0.018, sin_theta) * step(0.0, cos_theta);\n    return dir_factor * scatter_factor + direct_intense * passthru;\n}\n\n\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat falloff(in float x, in float range) {\n    float h = smoothstep(range, 0.0, 1.0/x);\n    return h * 0.1 * range / s_max(0.1 * range, 1.0/x, 0.05 * range);\n}\n\nvec3 perturb2(in vec3 loc) {\n    return loc;\n}\n\nfloat vehicle_sdf2(in vec3 loc) {\n    float ball1 = length(loc - vec3(0.0, -1.8, 0.0)) - 2.0;\n    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.07, 0.0)) - 0.5;\n    float result = s_min(disc, max(ball3, -loc.y), 0.1);\n    float mult = 1.0;\n#if CRINKLY_SHIP    \n    mult = 1.0 + 0.95 * mult;\n#else\n    mult = 1.0 + 0.95 * mult * smoothstep(0.025, 0.05, result);    \n#endif\n    return result * mult;\n}\n\nvec3 vehicle_sdf2_grad(in vec3 loc) {\n    float dist = vehicle_sdf2(perturb2(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle2(in vec3 orig, in vec3 dir, out float sumdist) {\n    vec3 p = orig;\n    float accum = 0.0;\n    sumdist = 0.0;\n    for (int i = 0; i < 256; ++i) {\n        float dist = vehicle_sdf2(p);\n        // mindist = min(dist, mindist);\n    \tfloat remaining = 0.2 * dist;\n        sumdist += remaining / max(1.0e-3, abs(dist));\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb2(p);\n        if (remaining < 1.0e-3) {\n            return accum;\n        }\n        if (accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce2(in vec3 pt, in vec3 dir, out float edge_term) {\n    vec3 norm = normalize(vehicle_sdf2_grad(pt));\n    edge_term = smoothstep(0.7, 0.3, abs(dot(normalize(dir), norm)));\n    return normalize(reflect(dir, norm));\n}\n\n\n\n\nvec4 castRayUFO(in vec2 fragCoord) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ray_orig = vec3(0.0, 0.5, -5.0);\n\tvec3 ray_dir = normalize(vec3(uv, 7.0));\n    \n    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;\n    wiggle = 0.2 * sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));// - 1.5;\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    wiggle = 0.05 * sin(iTime);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist = mat3(ct, st, 0.0,\n                 -st, ct, 0.0,\n                 0.0, 0.0, 1.0);\n    wiggle = 0.05 * sin(0.71 *iTime + 1.3);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist *= mat3(1.0, 0.0, 0.0,\n                  0.0, ct, st,\n                 0.0, -st, ct);\n\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    \n    ray_orig = ray_orig - vec3(0.0, 0.2, 0.0) -\n        sin(vec3(4.2, 1.2, 3.4) * iTime) * 0.2 * vec3(0.5, 0.1, 0.2);\n    float closeness = MAX_DIST;\n    float d = cast_to_vehicle2(ray_orig, ray_dir, closeness);\n    \n    vec3 ray_mul = vec3(1.0);\n    vec3 paste_color = vec3(0.0);\n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        float edginess = 0.0;\n        ray_dir = get_bounce2(pt, ray_dir, edginess);\n        ray_mul = mix(vec3(1.0, 0.9, 0.85), ray_mul, edginess);\n        vec2 window_cent = vec2(0.0, 0.3);\n        vec2 window_size = vec2(0.7, 0.4);\n        vec2 projected = (pt.zy - window_cent) / window_size;\n\n        if (abs(projected.x) < 0.5 && abs(projected.y) < 0.5) {\n            paste_color = texture(iChannel0, projected + vec2(0.5)).rgb;\n            paste_color *= smoothstep(0.5, 0.45, length(projected));\n        }\n    }\n\n    vec3 thump = sin(vec3(0.1, 0.8, -0.6) + iTime * vec3(4.1, 6.5, 5.2));\n    thump = 0.3 * smoothstep(0.8, 1.0, thump);\n\n    float darken = 0.15 * (1.0 + 3.0 * smoothstep(1.5, 0.5, dot(thump, vec3(1.0))));\n    return vec4(SKY_BRITE * darken * ray_mul * sky_color(ray_dir) +\n                (0.25 + 1.75 * smoothstep(0.05, 0.8, thump))\n                * falloff(closeness, 0.5) + paste_color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfragColor = castRayUFO(fragCoord);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyfzR.jpg", "access": "api", "license": "mit", "functions": [[1226, 1226, 1260, 1912, 2073], [2075, 2075, 2136, 2136, 2928], [2930, 2930, 2980, 2980, 3144], [3146, 3146, 3182, 3182, 3878], [3880, 4061, 4090, 4090, 4839], [4844, 4844, 4893, 4893, 5018], [5020, 5020, 5069, 5069, 5193], [5195, 5195, 5238, 5238, 5355], [5357, 5357, 5385, 5385, 5403], [5405, 5405, 5438, 5438, 5900], [5902, 5902, 5939, 5939, 6244], [6247, 6247, 6317, 6317, 6850], [6852, 6852, 6916, 6916, 7080], [7085, 7085, 7121, 7121, 9324], [9326, 9326, 9383, 9383, 9426]]}
{"id": "3dGfRR", "name": "checkerboard oxe 2", "author": "elenzil", "description": "first raymarcher in a while.\nI'm always so amazed at how fast computers are.\nfor https://isohedral.ca/swirled-series - I made the submission deadline, but a clerical error got it overlooked! );\n", "tags": ["checkerboard", "swirled"], "likes": 20, "viewed": 409, "published": 3, "date": "1606352955", "time_retrieved": "2024-07-30T20:33:44.983799", "image_code": "const float bg = 0.5;\n\nconst float distMax     =  16.0;\nconst float stepsMax    = 100.0;\nconst float distClose   =   0.003;\nconst float gradientEps =   0.00001;\n\nfloat myTime = 0.0;\n\n\nvec3 lightPos() {\n    return vec3(1.0, 2.0, 6.0);\n    return vec3(cos(myTime * 3.1), sin(myTime * 2.3), 1.0) * 4.0;\n}\n\nfloat scene(in vec3 p, out int material) {\n    float d = BIGF;\n    \n    material = 3;\n    \n    float j = floor(p.y + 4.0);\n    if (j < 0.0 || j > 7.0) {\n        return d;\n    }\n    \n    vec3 p0 = p;\n\n    mat2 mr  = rot2(myTime);\n    p.xz *= mr;\n    \n    p.xy += 3.5;\n    \n    for (float i = 0.0; i < 8.0; i += 1.0) {\n        vec3 pp = p;\n        pp.x = p.x - i;\n        pp.y = p.y - j;\n        vec3 ppp = pp;\n        ppp.z -= cos(myTime * 0.0 + length(vec2(i, j) - 3.5) * 2.0) * 0.92;\n            \n            \n//\t    ppp *= rot3(vec3(cos(myTime), sin(myTime), 0.0), myTime * 7.0 * (32.0 + (i + j)) / 32.0);\n        float dd = sdRoundBox2(ppp, vec3(0.5), cos(myTime) * -0.25 + 0.25);\n        if (dd < d) {\n            d = dd;\n            material = int(i + j) % 2 + 3;\n        }\n    }\n\n    // clip\n    d = opIntersection(d, sdBox(p0, vec3(4.0, 10.0, 10.0)));\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneGradient6(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    return normalize(vec3(scene(p+h.xyy, unused) - scene(p-h.xyy, unused),\n                          scene(p+h.yxy, unused) - scene(p-h.yxy, unused),\n                          scene(p+h.yyx, unused) - scene(p-h.yyx, unused)));\n}\nvec3 sceneGradient4(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    float fp = scene(p, unused);\n    return normalize(vec3(scene(p+h.xyy, unused) - fp,\n                          scene(p+h.yxy, unused) - fp,\n                          scene(p+h.yyx, unused) - fp));\n}\nvec3 sceneGradient3(in vec3 p) {\n    const vec2 h = vec2(gradientEps, 0);\n    int unused;\n    return normalize(vec3(scene(p+h.xyy, unused),\n                          scene(p+h.yxy, unused),\n                          scene(p+h.yyx, unused)));\n}\n\n\nvoid march(in vec3 p0, in vec3 d, out vec3 pos, out vec3 nrm, out int mat, out float stepNum) {      \n    float mindist = BIGF;\n    mat = 0;\n\n    bool keepGoing  = true;\n         stepNum    = 0.0;\n    float marchDist = 0.0;\n    \n    while (keepGoing) {\n        stepNum += 1.0;\n        if (stepNum > stepsMax) {\n            mat = 1;\n            return;\n        }\n        \n        if (marchDist > distMax) {\n            mat = 2;\n            return;\n        }\n        \n        int   mmat;\n        vec3  p = p0 + d * marchDist;\n        float mdist = scene(p, mmat);\n        \n        if (mdist < distClose) {\n            mat = mmat;\n            pos = p;\n            nrm = sceneGradient4(p);\n            return;\n            \n        }\n        \n        marchDist += mdist;\n    }       \n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{        \n    // 0 to 1 in 180 frames\n    myTime = fract(float(iFrame) / 180.0);\n    \n    // ease in/out\n    myTime = smoothstep(0.0, 1.0, myTime) * PI * 2.0;\n    \n    // ortho camera\n    float smallRes = vmin(iResolution.xy);\n    vec2 xy = XY - smallRes * 0.5;\n    if (iMouse.z > 0.0) {\n\t    xy = xy - (iResolution.xy - smallRes) * 0.5;\n    }\n    \n    vec2 uv = xy / smallRes * 8.0;\n    \n    float c = 0.4;\n    \n    if (vmax(abs(uv)) > 4.0) {\n        c += 0.02;\n    }\n    \n    int   mat;\n    vec3  nrm;\n    vec3  pos;\n    vec3  p = vec3(uv, 8.0);\n    float steps;\n    march(p, vec3(0.0, 0.0, -1.0), pos, nrm, mat, steps);\n    \n    if (mat >= 3) {\n        c = max(0.0, dot(nrm, normalize(lightPos() - pos)));\n        c *= 0.3;\n        if (mat == 4) {\n            c = c + 0.7;\n        }\n    }\n\n    float myTimeMix = cos(myTime) * 0.5 + 0.5;\n    myTimeMix *= myTimeMix;\n    if (mat == 4) {\n        c = mix(c, 1.0, myTimeMix);\n    }\n    else if (mat == 3) {\n        c = mix(c, 0.0, myTimeMix);\n    }\n    \n  //  c = pow(c, 1.0 / GAMMA);\n    \n    vec3 rgb = vec3(c);\n    if (iMouse.z > 10.0) {\n        rgb.x += steps / stepsMax;\n      //  rgb.y  = length(pos - p) / distMax;\n    }\n    \n    \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "const float BIGF  = 1e9;\nconst float GAMMA = 2.2;\nconst float PI    = 3.14159265359;\n    \nfloat vmin(in vec2 v) {return min(v.x, v.y);}\nfloat vmax(in vec2 v) {return max(v.x, v.y);}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n// same as sdRoundBox but takes the bevel out of the box instead of adding it on.\nfloat sdRoundBox2( vec3 p, vec3 b, float r )\n{\n    return sdRoundBox(p, b - r, r);\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// based on http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rot3(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n               \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 201, 201, 301], [303, 303, 345, 345, 1182], [1184, 1230, 1262, 1262, 1548], [1549, 1549, 1581, 1581, 1840], [1841, 1841, 1873, 1873, 2084], [2087, 2087, 2182, 2182, 2867], [2869, 2869, 2912, 2948, 4125]]}
{"id": "WdGBzR", "name": "(i)rationalStride (type int)", "author": "ollj", "description": "https://www.shadertoy.com/view/X\ncleaned, type int\nthis is experimental, to be simpler and more user friendly.\nto see, how i can improve on it, if only by making it less messy.", "tags": ["starguitar", "irrationalstride", "arpshepardtone", "ditherhairlinequantize", "chromaticscalecordtartanweave", "euclideanbeats", "euclideanrythm"], "likes": 0, "viewed": 244, "published": 3, "date": "1606344927", "time_retrieved": "2024-07-30T20:33:45.988114", "image_code": "//this shader simplifies previous  [stride] shaders\n//it mostly succeeds, but it has 1 remainding rounding-error-case\n//, that may duplicate the 0th row/column\n//This is a precision issue, because 0.0 duplicates into -0.000001 unpredictably\n//https://www.shadertoy.com/view/Xl3BD4 seems to adress this precision error\n//, at the cost of a LOT of arbitrary epsilon+buerocracy.\n\n//a better/slower solution is\n//https://www.shadertoy.com/view/4ttBD4\n\n//three voice harmony minor major chord (old)\n//parent: https://www.shadertoy.com/view/lsffDM \n//parent: https://www.shadertoy.com/view/XtdfDH\n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n\n/*\nI thought of a rather simple way to represent longer chords, \nascending and descending melodies.\n\nthis is the simple more constrained approach, only 3 dots.\nsolve a special case BEFORE trying a general case!\n\nThe reason why tesselation of music pitches works is\n...because we fail do distinguish hiigher resolutions of pitches.\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n\n\n/*\na problem suupoptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\n\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\n\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n#define u5(a) ((a)*.5+.5)\n\n#define vec1 float\n//red circle radius\n#define radius 1.\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n#define viewZoom mix(9.,hl2,u5(-cos(cos(iTime))))\n#define hl (viewZoom/hl2)\n#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\nfloat ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return distance of [u] to line srgment from [a] to [b]\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define dd(a) dot(a,a)\n\n//[u]FragmentPos, [m]=start [n]=end\n   \n//rationalStride() is pmodfm() BUT muich simpler (only for vec2)\n//rationalStride() is pmodfm() BUT without planckEpsilon and without CentricOffset\n//u=uv point you want to test if there is a note or not. \n//  (only has repeating grid constrain, does not filter the diagonal)\n//m=first/lowest  note  of a chord or arpeggio (frequency=.x time =.y) (set to offset+ 0.)\n//n=last /highest note  of a chord or arpeggio (frequency=.x time =.y) (set to offset+12.)\n//F=number of     notes of a chord or arpeggio == number of [A] in [BABABBABABAB] (length of 12)\nvec2 rationalStride(vec2 u,vec2 m,vec2 n,float F){\n ;n-=m;u-=m//offset by m\n ;vec2 a=floor(u)\n //above basically turns relevant intputs into type int:\n //;float F=2. //numberoif [A] in [AABAABAA..]\n ;vec2 b=F/max(vec2(F),abs(n-1.)) //how to convert this into integer modulo?\n ;// x%y = x-y*floor(x/y) //type float modulo\n ;// x%y = x-y*(x/y)      /type int version needs no floor\n ;b=floor(fract(a*b)/b)\n ;return b;}\n\n//return rational Stride; user friendly version in derms of shuffling a deck\n//a (binary) [stride] here is an evenly shuffled deck of only 2 different cards\n//but the distribution is as EVEN as possibly (not random, just offset)\n//eg: rationalStrideUserFriendly(0,7,5) \n//7,5 defines a ChromaticScale of 7 white keys to 5 black keys)\n//note that, if these values would not be rational\n//,a WHITE overwrites a BLACK (to evade flickering)\n//\n//eg: rationalStrideUserFriendly(vec2(iTime)%iResolution.xy,1.,iResolution.x-1.)\n//should be a moving hairline (untested, .y may be wild here)\n//\n//offset=UV coords\n//green= number of Green lines (green==white, but rgba coded)\n//black= number of Black lines\nvec2 rationalStrideUserFriendly(vec2 offset,float green,float black\n){return rationalStride(offset,offset+green,offset+green+black,green);}\n\nvec3 chord(vec2 u, vec2 m, vec2 n,float F\n){F-=1.\n ;//u*=iResolution.xy\n ;//m*=iResolution.xy \n ;//n*=iResolution.xy \n ;//m=vec2(0)//debug overwrite to a null-offset\n ;vec3 r=vec3(0)  \n ;r.z=Segment(u,m,n)//blue lineSegment\n ;//float d=length(m-u)//iResolution.x//3 red circles\n  //     ,e=length(n-u)//iResolution.x\n //      ,f=length(n+m-u*2.)*.5//iResolution.x  //decappped\n ;r.x=0.//min(min(d,e),f)                    //3 red circles end\n ;r.xz=ss(abs(r.xz-radius*vec2(1,.2))-hl)//yellow circles\n\n ;m=floor(m)//new concept, of making rationalStride() work with type int\n //this type int constrain seems to work [just fine]\n //, but i am not too suire about it.\n ;vec2 b=rationalStride(u,m,n,F)\n     \n ;//above code still works, even if you give it values, scaled by IResolution (or anything)\n ;//therefore this should just rasterize to type integer, i speculate.\n ;//the floor() method then just becomes something like a small shift, or a division by /256;\n ;//and the fract() function becomes a bitvise mask of &255\n ;ivec2 Iu=ivec2( u    *256.)\n ;ivec2 In=ivec2((n-1.)*256.)\n ;int If=2\n ;ivec2 Ib=If/max(ivec2(If),abs(In))\n ;//If=(Iu*Ib)&ivec2(255)\n ;if(all(equal(abs(b),vec2(0))))r.y+=.4;//oversimplified dots\n ;if(any(equal(abs(b),vec2(0))))r.y+=.2;//oversimplified crosses    \n ;//if(all(lessThan(abs(u),vec2(planckT))))r.y+=.4;//dots\n ;//if(any(lessThan(abs(u),vec2(planckT))))r.y+=.2;//crosses\n ;//vec3 r=vec3(d,t,)\n ;return r;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec3 c=vec3(0)\n ;vec2 u=fra(U)\n ;vec2 m=fra(abs(iMouse.zw));//start of holding mouse\n ;vec2 n=fra(    iMouse.xy);//current mouse pos held\n ;if(iMouse.z<=0.\n ){n=vec2(.0)\n  ;vec2 rr=viewZoom*vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=cs(iTime*.61).yx*(rr.x-rr.y)\n  ;m=cs(iTime    )   *(rr.x+rr.y)\n  ;c.xy+=.2*ss(abs(abs(length(u)-rr.x)-rr.y)-viewZoom*.5/hl2)//yellow circles show path of red dots\n  ;}\n ;c+=chord(u,m,n,4.)//core function, dodo split in 3 parts.\n ;c+=grid(u)*.2;// greyscale grid    \n ;O=vec4(c,1.)\n ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1974, 1974, 1998, 1998, 2028], [2029, 2029, 2053, 2053, 2083], [2084, 2084, 2101, 2101, 2129], [2130, 2130, 2147, 2147, 2175], [2177, 2234, 2270, 2270, 2341], [2503, 2554, 2573, 2573, 2660], [3140, 3695, 3745, 3745, 4111], [4113, 4811, 4881, 4881, 4950], [4952, 4952, 4996, 4996, 6391], [6393, 6393, 6410, 6410, 6438], [6440, 6440, 6478, 6478, 7019]]}
{"id": "3sGfRR", "name": "hacky video background removal ", "author": "mds2", "description": "So, if you are located in a bland white room, it turns out some pretty simple hacks do a halfway decent job of removing a lot of your background.  Just, make sure you're not wearing anything grey when using this.", "tags": ["video", "background", "compositing"], "likes": 4, "viewed": 742, "published": 3, "date": "1606341779", "time_retrieved": "2024-07-30T20:33:46.892695", "image_code": "const float bland_magic_cutoff = 0.7;\nconst float bright_cutoff_low = 0.8;\nconst float bright_cutoff_high = 1.2;\n\nfloat blandness(in vec3 col) {\n    vec3 cuts = smoothstep(bland_magic_cutoff * col, col, col.gbr);\n    cuts *= smoothstep(bland_magic_cutoff * col, col, col.brg);\n    return cuts.x * cuts.y * cuts.z;\n}\n\nfloat brightness(in vec3 col) {\n    return smoothstep(bright_cutoff_low,\n                      bright_cutoff_high,\n                      dot(col, vec3(1.0)));\n}\n                      \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 colLowRes = textureLod(iChannel0, uv, 2.0).rgb;\n    \n    \n    float bland = blandness(mix(colLowRes, col, 0.5));\n    float bright = brightness(colLowRes);\n    float mask = bland * bright;\n    \n    vec3 col2 = texture(iChannel1, uv).rgb;\n    \n    col = mix(col, col2, mask);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 144, 144, 315], [317, 317, 348, 348, 477], [502, 502, 559, 609, 1065]]}
{"id": "tdtfWs", "name": "Audio Eclipse TOMY", "author": "TOMY", "description": "Elipse Mic TOMY", "tags": ["tomy"], "likes": 9, "viewed": 493, "published": 3, "date": "1606330403", "time_retrieved": "2024-07-30T20:33:47.681586", "image_code": "// Fork of \"Audio Eclipse\" by airtight. https://shadertoy.com/view/MdsXWM\n// 2020-10-08 16:15:41\n\n#define SOUND_MULTIPLIER 1.0\nconst float dots = 50.; //number of lights\nconst float radius = .35; //radius of light ring\nconst float brightness = 0.03;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0,0,0.1); //background color\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\n\t\t//read frequency for this dot from audio input channel \n\t\t//based on its index in the circle\n\t\t//float vol =  texture(iChannel0, vec2(i/dots, 0.0)).x;\n        float vol = SOUND_MULTIPLIER * texture(iChannel0, vec2(i/dots, 0.0)).x;\n\t\tfloat b = vol * brightness;\n\t\t\n\t\t//get location of dot\n        float x = radius*cos(2.*3.14*float(i)/dots);\n        float y = radius*sin(2.*3.14*float(i)/dots);\n        vec2 o = vec2(x,y);\n\t    \n\t\t//get color of dot based on its index in the \n\t\t//circle + time to rotate colors\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*10.)/dots,1.,1.0));\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tc += b/(length(p-o))*dotCol;\n    }\n\t\n    //black circle overlay\t   \n\tfloat dist = distance(p , vec2(0));  \n\tc = c * smoothstep(0.43, 0.46, dist);\n\t \n\tfragColor = vec4(c,1);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 272, 293, 293, 462], [466, 466, 523, 523, 1503]]}
{"id": "WsdfDS", "name": "Sampleless lights 2D", "author": "Daizuukee", "description": "A 2D Light renderer that only uses 2 samples per light source (i know i lied) to create soft shadows", "tags": ["light"], "likes": 7, "viewed": 453, "published": 3, "date": "1606330361", "time_retrieved": "2024-07-30T20:33:48.599133", "image_code": "struct light {\n\tvec2 sp, ep;\n    vec4 col;\n    float strength;\n};\n//constructor for lights\nlight lightc(vec2 sp, vec2 ep, vec4 col, float strength) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = strength;\n    return outp;\n    \n}    \n//constructor for walls\n//(walls have the same properties as lights so it doesnt matter that we use struct light)\nlight lightc(vec2 sp, vec2 ep, vec4 col) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = 1.;\n    return outp;\n    \n}\n\nbool intersects(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    float det, gamma, lambda;\n  det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);\n  if (det != 0.) {\n    lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;\n    gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;\n    return (-0. <= lambda && lambda <= 1.) && (-0.0003 <= gamma && gamma <= 1.0003);\n  }\n    return false;\n}\n\nvec2 intersection(vec2 p1, vec2 n1, vec2 p2, vec2 n2) {\n    float x, y;\n    float slopex1 = n1.y / n1.x;\n    float slopex2 = n2.y / n2.x;\n    float offy1 = p1.y - slopex1 * p1.x;\n    float offy2 = p2.y - slopex2 * p2.x;\n    x = -(offy1 - offy2) / (slopex1 - slopex2);\n    //anti infinity\n    if(n1.x == 0.)\n        x = p1.x;\n    if(n2.x == 0.)\n        x = p2.x;\n    \n    //we cannot use x here since x could be infinity\n    float slopey1 = n1.x / n1.y;\n    float slopey2 = n2.x / n2.y;\n    float offx1 = p1.x - slopey1 * p1.y;\n    float offx2 = p2.x - slopey2 * p2.y;\n    y = -(offx1 - offx2) / (slopey1 - slopey2);\n    //anti infinity\n    if(n1.y == 0.)\n        y = p1.y;\n    if(n2.y == 0.)\n        y = p2.y;\n    return vec2(x,y);\n\t\n}\n//from https://www.shadertoy.com/view/tt23WW\nfloat linedist(vec2 p, vec2 p1, vec2 p2) {\n    vec2 v = p1, w = p2;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light lines, make sure they DONT overlap with walls\n    int lightcount = 3;\n\tlight lights[3];\n    lights[0] = lightc(vec2(0.1 + sin(iTime) / 5.,0.4 + cos(iTime) / 4.),vec2(-0.0,0.2),vec4(0,0.5,0,0),2.);\n    lights[1] = lightc(vec2(0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(0.5,-0.6),vec4(0.5,0,0,0),2.);\n    lights[2] = lightc(vec2(-0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(-0.5,-0.6),vec4(0,0,0.5,0),2.);\n    //walls, make sure they DONT overlap with lights\n    int wallcount = 2;\n    light walls[2];\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(0.4,1.,0.4,1.));\n    //color enhance (its weird but can look quite cool\n    /*\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(-1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(-20,-4.,-2,1.));\n    */\n    //standard uv\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    //zoom (who could have guessed)\n    uv *= 5.;\n    \n    for(int i = 0; i < lightcount; i++) {\n        vec2 lsp = lights[i].sp;\n        vec2 lep = lights[i].ep;\n        vec4 col = lights[i].col * (lights[i].strength - linedist(uv,lsp,lep)) / lights[i].strength;\n        \n        for(int o = 0; o < wallcount; o++) {\n        \tvec2 wsp = walls[o].sp;\n            vec2 wep = walls[o].ep;\n            \n            vec2 bound1 = min(lsp,lep);\n            vec2 bound2 = max(lsp,lep);\n            \n            //intersections from uv to the wall edges on the light line\n            vec2 inters1 = intersection(uv,normalize(wsp-uv),lsp,normalize(lep-lsp));\n            vec2 inters2 = intersection(uv,normalize(wep-uv),lsp,normalize(lep-lsp));\n            \n            //cannot get bigger shadows than there is a light\n            vec2 p1 = clamp(inters1,bound1,bound2);\n            vec2 p2 = clamp(inters2,bound1,bound2);\n            float dist = distance(p1,p2);\n            \n            //space of light covered by a wall\n            float mult = (1. - (dist) / distance(lep,lsp));\n            \n            //honestly have no idea why this is necessary but it is\n            if(intersects(uv,uv+normalize(lsp-lep)*900.,wsp,wep) || intersects(uv,uv+normalize(lsp-lep)*-900.,wsp,wep))\n                mult = 1.-mult;\n            \n            //no walls hit\n            if(!intersects(uv,p1,wsp,wep) && !intersects(uv,p2,wsp,wep))\n                mult = 1.;\n            col *= 1.-(1.-mult) * walls[o].col;\n            \n            //light line visualization\n            if(linedist(uv,lsp,lep) < 0.01)\n                fragColor += lights[i].col;\n            \n        }\n        fragColor += col;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 91, 149, 149, 275], [280, 394, 436, 436, 556], [558, 558, 611, 611, 1007], [1009, 1009, 1064, 1064, 1744], [1745, 1790, 1832, 1832, 2065], [2069, 2069, 2126, 2184, 4764]]}
{"id": "wddBWs", "name": "Inchworm - Swirled Series", "author": "oneshade", "description": "Checkerboard animation 2!\nFor the swirled series proposed here: https://isohedral.ca/swirled-series/", "tags": ["animation", "checker", "infinite", "swirledseries"], "likes": 1, "viewed": 113, "published": 3, "date": "1606327619", "time_retrieved": "2024-07-30T20:33:49.468808", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / 64.0;\n    float time = clamp(mod(iTime * 2.0, 7.28) - 0.5, 0.0, 6.28);\n\n    uv.x *= 1.5 + 0.5 * sin(time + 4.71);\n    uv.x -= 2.0 * (max(0.0, mod(time, 6.28) - 3.14) / 3.14);\n\n    fragColor = vec4(0.5);\n    if (fragCoord.x < 512.0 && fragCoord.y < 512.0) {\n        fragColor = vec4(mod(floor(uv.x) + floor(uv.y), 2.0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 409]]}
{"id": "wstBWs", "name": "Assembly Line - Swirled Series", "author": "oneshade", "description": "For the swirled series proposed here: https://isohedral.ca/swirled-series/\nI got interested in @FabriceNeyret2's checker animations for it.", "tags": ["animation", "checker", "infinite", "swirledseries"], "likes": 1, "viewed": 137, "published": 3, "date": "1606326404", "time_retrieved": "2024-07-30T20:33:50.424253", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = clamp(mod(iTime, 3.5) - 0.25, 0.0, 3.0);\n    vec2 uv = fragCoord / 64.0;\n\n    uv.x -= min(1.0, time / 1.5 * (1.0 - mod(floor(uv.y), 2.0)));\n    uv.y -= max(0.0, (time - 1.5) / 1.5 * (1.0 - mod(floor(uv.y), 2.0)));\n\n    fragColor = vec4(0.5);\n    if (fragCoord.x < 512.0 && fragCoord.y < 512.0) {\n        fragColor = vec4(mod(floor(uv.x) + floor(uv.y), 2.0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 439]]}
{"id": "tdtBDl", "name": "so much beer", "author": "lyurai", "description": "Love beer. This image I see when I barf", "tags": ["glitchcircle"], "likes": 2, "viewed": 354, "published": 3, "date": "1606318868", "time_retrieved": "2024-07-30T20:33:51.408621", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*25.-iResolution.xy)/iResolution.y+t;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<100;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 480]]}
{"id": "wsdfWl", "name": "Enter the Void", "author": "lyurai", "description": "Inspired by Gaspar Noe", "tags": ["warning"], "likes": 3, "viewed": 307, "published": 3, "date": "1606318658", "time_retrieved": "2024-07-30T20:33:52.479757", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<100;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 477]]}
{"id": "3dtBWX", "name": "Cube Circle Sketch", "author": "Shane", "description": "Loosely recreating one of Regolo Bizzi's mathematical sketches via simple procedural methods. No 3D was harmed during the making of this. :)", "tags": ["cube", "circle", "sketch", "pencil", "isometric", "paper", "art", "quad"], "likes": 103, "viewed": 1750, "published": 3, "date": "1606309169", "time_retrieved": "2024-07-30T20:33:53.595773", "image_code": "/*\n\t\n\tCube Circle Sketch\n\t------------------\n\n\tI see a lot of really classy geometric styled pencil drawings on \n    the internet by various mathematical artists -- The effort that \n    goes into some of them is really impressive. Reproducing them in \n    code form is kind of cheating, but it's a little hard to resist. :)\n\n\tThis particular arrangement is pretty common and something I've \n    seen many times in various forms, but most tend to be based off of \n    the works of mathematical artist Regolo Bizzi -- His Escheresque\n    geometric designs are everywhere, but if you've never chanced upon \n    one of them, I've provided a link below. A lot of love and effort \n    would have gone into the original sketch, but the effort that went\n    into the code version was far less impressive: Render 12 hexagons \n    on the border of a circle, orient them a bit (by PI/6), then shade \n    the faces. \n    \n    There's some extra code to give it that tech drawing feel, fake \n    lighting and a mediocre sketch algorithm included, but that's it.\n\n\tAnyway, I was more interested in producing a halfway passable look\n\tin order to render more interesting patterns. Suggestions for \n\tsimple improvements are always welcome. :)\n\n\n\n    // Links.\n\n    // You can find some of Regolo Bizzi's work at the following:\n    http://impossible-world.blogspot.com/2014/10/new-images-by-regolo-bizzi.html\n    https://www.behance.net/regolo\n\n*/\n\n\n// Cube subdivision lines. Interesting, but a bit much, I think. :)\n//#define SUBDIV_LINES \n\n// Greyscale sketch -- Sans color.\n//#define GREYSCALE\n\n// Blinking lights: It was an attempt to animate the sketch in a believable\n// way... This isn't it. :D\n//#define BLINKING_LIGHTS\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Rotation speed -- Rotation seemed like a good idea at the time, but\n    // I decided against it. :)\n    float rT = 0.;//sin(-iTime/6.*3.)/12.;\n\n    // Scaling and rotation.\n    vec2 p = rot2(rT)*uv*gSc;\n    \n    // Distance field holders for the cubes, lines and the previous\n    // cube (used for CSG related to overlap).\n    float d = 1e5, ln = 1e5, prevD = 1e5; \n    \n    // Edge width. \n    const float ew = .0025;\n    \n   \n    // The cubes are rendered along the sides of a dodecahedron. These are just some standard\n    // measurements to help place the cubes in the correct positions.\n    //\n    const float cR = .3; // Larger circle radius.\n    const float cAp = cR*cos(6.2831/24.); // Apothem.\n    const float sL = cR*acos(6.2831/24.)/2.; // Side length, which will relate to the hexagon scale.\n    \n    \n        // The offset vertex information.\n    // Hexagon vertices with scaling to enable rendering back in normal space. \n    vec2 hSc = sL*vec2(.5, .8660254);\n    vec2[6] svV = vec2[6](vID[0]*hSc, vID[1]*hSc, vID[2]*hSc, vID[3]*hSc, vID[4]*hSc, vID[5]*hSc);\n\n   \n    // Coordinate perturbation. There's small rigid one to enhance the hand-drawn look, and\n    // a larger animated one to wave the paper around a bit.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    vec2 offs2 = vec2(fbm(p*1. + iTime/4.), fbm(p*1. + .5 + iTime/4.));\n    const float oFct = .007;\n    const float oFct2 = .05;\n    p -= (offs - .5)*oFct;\n    p -= (offs2 - .5)*oFct2;\n    \n \n    \n    \n    float lnL = -cR - sL*.75; // Line length.\n    float a0 = 6.2831/24.; // Initial reference angle.\n    float dA = 6.2831/12.; // One twelth revolution.\n    float inR =  cR - sL/2.*.8660254; // Inner radius. \n    \n    \n    // Some distance field holders.\n    float gHex = 1e5, gD = 1e5, qLn = 1e5, dSh = 1e5;\n    // Z buffer, for shadows.\n    float zBuf = 0.;\n    \n    \n    \n    // Fake lighting.\n    vec3 lp = vec3(-.75, 3, -1.5);\n    vec3 ld = normalize(lp - vec3(uv, 0)); \n    ld.xy = rot2(rT)*ld.xy;\n    \n    \n    // Initialize the background.\n    vec3 col = vec3(.95, .975, 1);\n    \n    \n    vec2 q; \n    \n    // Apply some graph lines.\n    float dim = 9.; // For the lines to match up: dim = 9./(cR*3.);\n    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//\n    q = abs(mod(q, 1./dim) - .5/dim);\n    float ln3 = abs(max(q.x, q.y) - .5/dim);\n    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.8);\n    dim *= 2.;\n    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//\n    q = abs(mod(q, 1./dim) - .5/dim);\n    ln3 = max(abs(max(q.x, q.y) - .5/dim), -ln3);\n    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.65);\n    \n    // Applying light and a bit of noise to the background.\n    col *= clamp(dot(normalize(vec3(p, -1.5)), ld), 0., 1.)*.2 + .8;\n    col *= fbm(p*8.)*.1 + .9;\n    \n    \n    // Produce and render the 12 cubes. This is pretty standard stuff -- Position\n    // the cubes and render three rhomboids for the cube faces.\n    \n    // Cube face normals.\n    vec3[3] n = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, -1));\n       \n\n    // Iterate through all 12 cubes -- Some will note that you could apply polar\n    // coordinates and cut this right down to two iterations, which would definitely\n    // be faster. However, the example isn't too taxing on the system, and the\n    // brute force method simplifies the code a bit... Having said that, I might\n    // cave in an update this later. :)\n    //\n    for(int i = 0; i<12; i++){\n        \n        q = p;\n        \n        // Grey lines point to point lines.\n        vec2 a, b, nA;\n        a =  rot2(a0 + dA*float(i))*vec2(0, inR);\n        b =  rot2(a0 + dA*float(i + 3))*vec2(0, inR);\n        nA = normalize(b - a)*sL*1.6;\n        ln = min(ln, lBox(q, a - nA, b + nA, 0.));\n        \n        \n        // Hexagons.\n        vec2 hCtr = rot2(6.2831/12.*float(11 - i))*vec2(0, cR); // Hexagon center.\n        q -= hCtr; // Move to the border.\n        q = rot2(-6.2831/12.*float(11 - i))*q; // Rotate in situ.\n        //q = rot2(iTime/3.)*q; // Rotate individual hexagons.\n        float dH = sdHexagon(q, sL/2.); // Hexagon distance field.\n        d = dH;\n        \n        // Hexagon or cube shadows.\n        vec2 qSh = p + ld.xy*.03;\n        qSh -= hCtr;\n        qSh = rot2(-6.2831/12.*float(11 - i))*qSh;\n        dSh = sdHexagon(qSh, sL/2.);\n        \n        // All hexagons.\n        gHex = min(gHex, d);\n        \n        // Grey hexagon circle outlines.\n        ln = min(ln, abs(length(q) - sL/2./.8660254));\n        \n        // Cutting out the previous hexagon to avoid overlap. A Z-buffer would\n        // also work, and might be cleaner, but it's done now. :)\n        d = max(d, -(prevD - ew/3.));\n        \n        prevD = d; \n        \n        // Shadow and shadow buffer -- Needs fixing, but it'll do for now.\n        col = mix(col, mix(vec3(0), col, zBuf), (1. - smoothstep(0., sf*5., dSh - ew/2.))*.35);\n        zBuf = mix(zBuf, 1., (1. - smoothstep(0., sf*5., dSh - ew/2.))); \n  \n        // Combination of all objects... It was used to rotate things in combination with\n        // the sketch algorithm, but I decided against it.\n        gD = min(gD, min(min(ln, d), dSh));\n        \n        // Rendering the hexagon base -- Not entirely necessary, but it enhance the edges.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., d - ew/2.))*.35); // Fake AO.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d - ew/2.))*.8);\n        //col = mix(col, vec3(1), (1. - smoothstep(0., sf, d + ew - ew/2.)));\n          \n          \n             \n        // Iterate through the three cube faces.\n        for(int j = 0; j<6; j+=2){\n        \n            // Constructing the edge midpoints and normals at those\n            // points for both the string and corresponding shadows.\n            vec2[4] v = vec2[4](svV[(j + 1)%6].yx, svV[(j + 2)%6].yx, svV[(j + 3)%6].yx, vec2(0));\n\n            // Quad center and local quad ID.\n            vec2 qCtr = (v[0] + v[1] + v[2] + v[3])/4.;\n            vec2 qID = hCtr + qCtr;\n            \n            // Face quad.\n            float quad = max(sdPoly4(q, v), d);\n            \n            // Accumulated quad field.\n            gD = min(gD, quad);\n            \n            // Spectrum or rainbow colors.\n            vec3 rnbCol = .6 + .4*cos(6.2831*float(i)/12. + vec3(0, 1, 2)*1.5 + 3.14159/6.);\n            \n            #ifdef BLINKING_LIGHTS\n            float rndI = hash21(hCtr); rndI = cos(rndI*6.2831 + iTime/1.25 + .5);\n            rndI = smoothstep(.9, .95, sin(rndI*6.2831 + iTime*3.)*.5 + .5);\n            \n            vec3 rCol = vec3(.55) + float(i%3)/12.;//vec3(hash21(hCtr + .6)*.35 + .5);\n            rCol = mix(rCol, dot(rCol, vec3(.299, .587, .114))*vec3(4, 1, .5), rndI);\n            rCol = mix(rCol, rCol.xzy, sin(hash21(hCtr + .44)*6.2831 + iTime)*.35 + .35);\n            \n            // Alternative.\n            //vec3 rCol = rnbCol;\n            //rCol = mix(rCol, rnbCol*1.5, rndI);\n            #else\n            vec3 rCol = rnbCol;\n            #endif\n            \n  \n            // Face normal.\n            vec3 sn = n[j/2];\n            // Rotate the face normals about the XY axis -- Since this isn't 3D, we\n            // need to fake it.\n            sn.xy = rot2(6.2831/12.*float(11 - i))*sn.xy;\n             \n            // Using the quad distance field for a bit of shading. In this case, it\n            // gives the cubes a subtle faux ambient occulsion feel.\n            float sh = clamp(.35 - quad/.03, 0., 1.)*.3 + .7;\n            // Standard diffuse lighting.\n            float dif = max(dot(ld, sn), 0.);\n            // Lit face color.\n            rCol = rCol*(dif + .5)*sh;\n            \n            // Render the face quad.\n            col = mix(col, rCol*.5, (1. - smoothstep(0., sf, quad)));\n            col = mix(col, vec3(rCol), (1. - smoothstep(0., sf, quad + ew)));\n            \n            #ifdef SUBDIV_LINES\n            // Quad lines -- Not used.\n            \n            qLn = lBox(q, mix(v[0], v[1], .5), mix(v[2], v[3], .5), .0);\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .5), mix(v[3], v[0], .5), .0));\n            /*         \n            qLn = lBox(q, mix(v[0], v[1], .333), mix(v[2], v[3], .666), .0);\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .333), mix(v[3], v[0], .666), .0));\n            qLn = min(qLn, lBox(q, mix(v[0], v[1], .666), mix(v[2], v[3], .333), .0));\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .666), mix(v[3], v[0], .333), .0));\n            */\n            qLn = max(qLn, (prevD - ew/3.));\n            \n            vec3 svCol = col;\n            col = mix(col, col*1.35, (1. - smoothstep(0., sf*3., qLn - .003)));\n            col = mix(col, svCol*.65, (1. - smoothstep(0., sf*2., qLn - .001)));\n            #endif\n        }\n        \n         \n    }\n    \n\n    // Faking the ruled guide lines. We'll make them more pronounced outside the colored\n    // cubes and faint over the top.\n    float lAlpha = mix(.25, .125, 1. - smoothstep(0., sf*2., gHex));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln - .001*fbm(p*32. + .5)))*lAlpha);\n    // IQ's suggestion to let a trace amount of the graph paper pattern show through.\n    // The graph paper was a later addition, so I'd forgotten to include it.\n    col = mix(col, vec3(.35, .65, 1)/4., (1. - smoothstep(0., sf*2., max(gHex, ln3)))*.25);\n    \n    \n \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    q = p*8.;//mix(p*10., uv*gSc*10. - (offs - .5)*oFct  - (offs2 - .5)*oFct2, smoothstep(0., sf, gD));\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    #ifdef GREYSCALE\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .6);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .25)), .85); \n    #endif\n    //col = mix(col, colP, .5);\n    //col = mix(min(col, colP), max(col, colP), .5); \n   \n  \n     // Cheap paper grain... Also barely worth the effort. :)\n    vec2 pp = q;//floor(q*1024.);\n    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));\n    vec3 pg = .8 + (rn3.xyz*.35 + rn3.xxx*.65)*.4;\n    col *= min(pg, 1.); \n    \n    \n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\n//vec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), \n                      //vec2(.5, 0)/vec2(.5, 1), \n                      //vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n// IQ's box formula -- Modified slightly.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n  \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This renders a horizontal or vertical box-line from point \"a\" to point \"b,\" with a line \n// width of \"w.\" It's different to the the usual line formula because it doesn't render the \n// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula \n// and was put together in a hurry, so I'd imagine there are more efficient ways to do the \n// same, but it gets the job done. I put together a more generalized angular line formula as \n// well.\nfloat lBoxHV(vec2 p, vec2 a, vec2 b, float w){\n    \n   vec2 l = abs(b - a); // Box-line length.\n   p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.\n   \n   // Applying the above to IQ's box distance formula.\n   vec2 d = abs(p) - (l + w)/2.; \n   return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n/*\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n*/\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast); // Same, but with contrast.\n    //ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), ns3))); // Different contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "WsdBDs", "name": "RGB Simple Noise Effect", "author": "IWBTShyGuy", "description": "One lap is about 10 minites.", "tags": ["noise"], "likes": 5, "viewed": 468, "published": 3, "date": "1606301470", "time_retrieved": "2024-07-30T20:33:54.345768", "image_code": "// The MIT License\n// Copyright  2020 IWBTShyGuy\n\nfloat prerand(in vec2 c) {\n    vec2 rand_gen = vec2(1.14514, -1.919810);\n    float time = (iTime + 200.0) * 0.01;\n    rand_gen = mat2(cos(time), sin(time), -sin(time), cos(time)) * rand_gen;   \n    return fract(rand_gen.x * sin(rand_gen.y * c.x + c.y));\n}\n\nfloat rand(in vec2 c) {\n    return prerand(vec2(prerand(c.xy), prerand(c.yx)));\n}\n\nfloat prenoise(in vec2 c) {\n    c = c * 15.0;\n    vec2 i = floor(c);\n    vec2 f = smoothstep(0.0, 1.0, fract(c));\n    float a00 = rand(i);\n    float a10 = rand(i + vec2(1.0, 0.0));\n    float a01 = rand(i + vec2(0.0, 1.0));\n    float a11 = rand(i + vec2(1.0, 1.0));\n    return a00 * (1.0 - f.x) * (1.0 - f.y)\n        + a10 * f.x * (1.0 - f.y)\n        + a01 * (1.0 - f.x) * f.y\n        + a11 * f.x * f.y;\n}\n\nfloat noise(in vec2 c) {\n    return prenoise(vec2(prenoise(c), prenoise(vec2(prenoise(c), prenoise(c.yx)))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n    float r = noise(uv);\n    float g = noise(uv.yx);\n    float b = noise(vec2(r, g));\n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBDs.jpg", "access": "api", "license": "mit", "functions": [[52, 52, 78, 78, 307], [309, 309, 332, 332, 390], [392, 392, 419, 419, 796], [798, 798, 822, 822, 909], [911, 911, 966, 966, 1151]]}
{"id": "Wd3fD8", "name": "Vapor buildings", "author": "z0rg", "description": "Simple scrolling scene", "tags": ["vhs", "vapor", "retrowave"], "likes": 21, "viewed": 941, "published": 3, "date": "1606297772", "time_retrieved": "2024-07-30T20:33:55.570493", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = fi/fcnt;\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,.008);\n    \n\tcol += pow(postFX(uv,.02), vec3(.45));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24694, "src": "https://soundcloud.com/set_reload/yu-utsu-sun?in=el-jorge-4/sets/vapor", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 getCam(vec3 dir, vec2 uv)\n{\n    vec3 r = normalize(cross(dir, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(dir, r));\n    return dir + uv.x*r+uv.y*u;\n}\n\nfloat map(vec3 p)\n{\n    float rep = 5.5;\n    float idx = float(int((p.x+rep*.5)/rep))*15.;\n    float rep2 = 5.;\n    float ht = sin(float(int((p.z+iTime*15.+rep2*.5)/rep2))*15.);\n    p.z = mod(p.z+iTime*15.+rep2*.5,rep2)-rep2*.5;\n    p.x = mod(p.x+rep*.5, rep)-rep*.5;\n    \n    return sdBox(p-vec3(0.,.5+0.8*sin(idx+3.8), 0.), vec3(.4, 2.+ht*.5+.5, .3), idx);\n}\n\nvec4 layer3D(vec2 uv)\n{\n    vec3 col;\n    float opa;\n    \n    float dis = 5.;\n    vec3 ro = vec3(sin(iTime*.5)*.3+2.,1.+sin(iTime*.25)*.2,-5.);\n    vec3 ta = vec3(0.,-4.,15.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    float t = 0.001;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd*t;\n        float d = map(p);\n        if (abs(d) < t*0.001)\n        {\n            vec3 win = vec3(255, 188, 87)/255. * sat((sin(p.y*15.+1.)-.8)*10.);\n\t\t\twin *= sat((sin(p.x*4.)-.8)*10.);\n            vec3 win2 = vec3(255, 188, 87)/255. * sat((sin(p.y*15.+1.)-.8)*4.);\n\t\t\twin2 *= sat((sin(p.x*4.)-.8)*4.);\n            col += win+win2;\n            opa = 1.0;\n            break;\n        }\n        t += d*.5;\n    }\n    \n    return vec4(col, opa);\n}\n\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\nvec3 rdrr(vec2 uv)\n{\n    vec3 col;\n    \n    col = mix(vec3(88, 88, 232)/255., vec3(247, 102, 158)/255., pow(sat(-uv.y*2.+.2),.7));\n    vec3 sun = (vec3(207, 142, 4)/255.)*(1.-sat((length(uv)-.1)*5.))*.5;\n    col += sun;\n    vec4 layer3d = layer3D(uv);\n    col = mix(col, layer3d.xyz, layer3d.w);\n    \n    col *= pow(1.-sat(length((uv-vec2(-.2,.2))*.2)), 3.);\n    uv = myPixel(uv+5., 0.005)-5.;\n    \tcol *= sat(.5+.8*rand(uv*sin(iTime)));\n    \n    col *= 1.-sat((sin(uv.x*70.)-.99)*iResolution.x);\n    col *= 1.-sat((sin(uv.y*70.)-.99)*iResolution.x);\n\tcol += sun*(col+.5);\n    col *= pow(1.-sat(lenny(uv)),2.);\n    return col;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    uv *= pow(1.+length(uv),.5);\n    vec3 col;\n    vec2 dir = vec2(1.);\n    float strength = 0.003+0.003*length(uv*2.);\n    col.r = rdrr(uv+dir*strength).r;\n    col.g = rdrr(uv).g;\n    col.b = rdrr(uv-dir*strength).b;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n\tuv.x += sat(sin((uv.y+mod(iTime*10.0,3.5))*55.)-.9)*.08;\n    vec3 col = rdr(uv);\n    if (uv.x < -.49)\n        col = col.xxx*.3;\n    fragColor = vec4(mix(col, texture(iChannel0, ouv).xyz, 1.-1./2.),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float ca = cos(a), sa = sin(a); return mat2(ca, -sa, sa, ca); }\n// Stolen on stackoverflow\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n// My version =D, Happy that I came up with this one\n// still have to test it but the shape is good\nfloat sdBox(vec3 p, vec3 b, float idx)\n{\n    p.xz *= r2d(PI/4.0+idx*25.);\n    vec3 a = abs(p)-b;\n    return max(a.x, max(a.y, a.z));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fD8.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 431, 431, 848], [851, 851, 908, 908, 1061]]}
{"id": "WddfWs", "name": "404D Cel'u'ar Til'ng, fork", "author": "UrbanClubProfessional", "description": "Remix of \"3D Cellular Tiling\" by Shane. [url]https://www.shadertoy.com/view/ld3Szs[/url]", "tags": ["3d", "voronoi", "sss", "volumetric", "remix", "glitch", "scattering", "fork", "cellular", "weird", "tiling", "error", "404"], "likes": 6, "viewed": 567, "published": 3, "date": "1606295925", "time_retrieved": "2024-07-30T20:33:56.697480", "image_code": "/*\nHacked and cracked by Urban Club Professional! *lol*\n*/\n\n#define PI 4.14159265\n#define FAR 60.\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.25;\nconst float freqB = 0.35;\nconst float ampA = 4.6;\nconst float ampB = .95;\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*55758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(8, 257, 213)));    \n    return fract(vec3(3097152, 362144, 42768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(2.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n) - 0.3, 0.002); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(8, 257, 213);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(4. - 3.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (six to eight spheres, in this case) \n// using the darken (min(src, dst)) blend at various 3D locations on a cubic tile. Make the \n// tile wrappable by ensuring the objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four spheres. Of course, there is 8-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's way, way lower. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.6;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.166));\n    \n}\n\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n    \n    float c = .35; // Set the maximum.\n    \n    // Draw four overlapping objects (spheres, in this case) using the darken blend \n    // at various positions throughout the tile.\n    c = min(c, drawSphere(p - vec3(.91, .72, .63)));\n    c = min(c, drawSphere(p - vec3(.49, .3, .21)));\n    \n    c = min(c, drawSphere(p - vec3(.72, .34, .07)));\n    c = min(c, drawSphere(p - vec3(.3, .92, .74)));\n    \n    \n    // Add some smaller spheres at various positions throughout the tile.\n    \n    p *= 2.4142;\n    \n    c = min(c, drawSphere(p - vec3(.58, .39, .3)));\n    c = min(c, drawSphere(p - vec3(.07, .97, .88)));\n    \n    // More is better, but I'm cutting down to save cycles.\n    //c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    //c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*5.); // Normalize.\n    \n}\n\n// The same as above, but with an extra two spheres. This is used by the bump map function,\n// which although expensive, isn't too bad. Just for the record, even bump mapping a\n// reasonably fast cellular function, like 8-Tap Voronoi, can still be a drain on the GPU.\n// However, the GPU can bump map this function in its sleep.\n//\nfloat cellTile2(in vec3 p){\n    \n    float c = .35; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.91, .72, .63)));\n    c = min(c, drawSphere(p - vec3(.49, .3, .21)));\n    \n    c = min(c, drawSphere(p - vec3(.72, .34, .07)));\n    c = min(c, drawSphere(p - vec3(.3, .92, .74)));\n    \n    p *= 2.4142;\n    \n    c = min(c, drawSphere(p - vec3(.58, .39, .3)));\n    c = min(c, drawSphere(p - vec3(.07, .97, .88)));\n\n    c = min(c, drawSphere(p - vec3(.7, .96, .0)));\n    c = min(c, drawSphere(p - vec3(.28, .54, .68)));\n        \n    return (c*5.);\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\n\n\n// There's a few simple, warping tricks being employed here. One is the oldscool, \"top and bottom\n// planes\" via \"abs(p.y).\" The planes are then twisted about the XY plane with respect to distance \n// using the 2D rotation function, \"rot2(p.z/12.),\" etc, then wrapped aound a curvy path, \"path(p.z).\"\n//\n// Finally, some surface detailing is added with a sinusoidal bottom layer, and the cellular layer \n// over the top of it. Normally, adding cellular layering utterly fries the GPU, but the \"cellTile\"\n// function used here merely makes it slightly uncomfortable. :)\n//\nfloat map(vec3 p){\n    \n    \n     float sf = cellTile(p*.23); // Cellular layer.\n    \n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/22.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*2. + sin(p.yzx*.6 + iTime)), vec3(.35)); // Sinusoidal layer.\n     \n     return 3. - abs(p.y) + n + sf; // Warped double planes, \"abs(p.y),\" plus surface layers.\n   \n\n     // Standard tunnel. Comment out the above first.\n     //vec2 tun = p.xy - path(p.z);\n     //return 3. - length(tun) - (0.5-surfFunc(p)) +  dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.333))*.5+.5;\n\n \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float noi = noise3D(p*74.);\n    float vor = cellTile2(p*.85);\n    \n    return vor*1.08 + noi*.03;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.1, h;\n    for(int i = 1; i < 90; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.003*(t*.35 + 2.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.9;\n        \n    }\n\n    return clamp(t, 1., FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.003, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n*/\n\n// Using a variation of IQ's AO function to calculate thickness, but with the normal flipped.\n// IQ uses a similar setup to calculate SSS... Subsurface AO, I guess you'd call it. :)\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 5.;\n    float sca = 2., occ = 1.;\n    for(float i=1.; i<sNum + .002; i++ ){\n    \n        float hr = 0.06 + .5*i/sNum; \n        //vec3 rn = normalize(n + RandomHemisphereDir(n, hr)*rad*.5);\n        float dd = map(p - n*hr);\n        occ += (hr - min(dd, 1.))*sca;\n        sca *= 1.0;\n    }\n    return 2. - max(occ/sNum, 1.); \n    \n}\n\n/*\n// Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24;\n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += min(h, stepDist);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // Shadow value.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 1.0, l;\n    const float maxDist = 5.;\n\tconst float nbIte = 7.0;\n\t//const float falloff = 0.9;\n    for( float i=2.; i< nbIte+.6; i++ ){\n    \n        l = (i + hash(i))*.6/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(2.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(2.- ao/nbIte, 0., 2.);\n}\n\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-2., 2.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.225/(w*w) *(t1 + t2 + t3 + t4 - 5.*map(p));\n}\n\n\n/////\n// Code block to produce four layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*3. + (cos(p.yzx) + 2. + iTime*5.)*2.57);\n    return dot(p, vec3(0.2621)) + 0.6;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.35, -0.966, 0.533, 1.0365, 0.35, -0.3455127, -0.068, 0.433, 0.999519 )*2.5;\n  \n\tfloat res = 1.;\n\n    float t = trig3(p*PI);\n\tp += (t - iTime*0.35);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*0.35)*0.8071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.8071;\n\n    t = trig3(p*PI);\n\tres += t*0.6;\n\t \n\treturn res/3.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(227.1, 411.7, 84.7)))*53758.5453); }\n\n// Four layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 1.;\n    ro += rd*t/9.; // Edge the ray a little forward to begin.\n    \n    for (int i = 1; i<5; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(2./(2. + sDi*0.35 + sDi*sDi*0.06), 2.);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/3.)*sAtt;\n        // Advance the starting point towards the hit point.\n        ro += rd*t/5.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/3. + hash31(ro)*0.2-0.06, 0., 2.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.6)/iResolution.y;\n\t\n\t// Camera Setup.\n\t//vec3 lookAt = vec3(0., 0.25, iTime*2.);  // \"Look At\" position.\n\t//vec3 camPos = lookAt + vec3(2., 1.5, -1.5); // Camera position, doubling as the ray origin.\n\t\n\tvec3 lookAt = vec3(0., 0.0, iTime*7. + 0.2);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.2); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0., 2, 9);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 1., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/26. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(1);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        // Texture scale factor.\n        const float tSize0 = 2./5.; \n    \t\n        //vec3 tsp = sp-vec3(path(sp.z), 0.);\n       \n    \t// Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, tsp*tSize0, sn, 0.025);//\n        \n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .3);///(1.+t*.5/FAR)\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.002);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(2. + distlpsp*0.4); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.6;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 42.);\n        \n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.225)*0.6+0.6, .0, 2.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 2., .0, 2.), 2.);\n        \n        // Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        // Object texturing.\n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = smoothstep(-.06, 1.05, texCol)*(smoothstep(-.6, 2., crv)*.85+.35);\n        \n    \t/////////   \n        // Translucency, courtesy of a mixture XT95 and IQ;s procedures - See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        //float th = thickness( sp, sn, 1., 1. );\n        float th = thickness( sp, sn);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 2.), 2.);\n        float trans = max((tdiff + .35)*th*2.5, 0.);  \n        trans = pow(trans, 5.)*2.;        \n    \t////////        \n\n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 2.;// crv*0.5+0.5; \n    \t\n        // Shadows - They didn't add enough aesthetic value to justify the GPU drain, so they\n        // didn't make the cut.\n        //shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.8, 1.0, 2.)*spec + vec3(2, .7, .3)*spec*spec*spec*.6;\n        sceneCol += texCol*vec3(.9, 1.05, 2)*pow(fre, 5.)*3.;\n        sceneCol += vec3(2, .06, 0)*trans;\n      \n        \n        /*\n        // Cool blue hilights. Adapted from numerous examples on here. Kali uses it to great effect.\n        float per = 10.;\n    \tfloat tanHi = abs(mod(per*.5 + t + iTime, per) - per*.5);\n    \tvec3 tanHiCol = vec3(0, .2, 1)*(1./tanHi*.2);\n        sceneCol += tanHiCol;\n        */\n        \n        \n        //vec3 refCol = vec3(.5, .7, 1)*smoothstep(.2, 1., noise3D((sp + ref*2.)*2.)*.66 + noise3D((sp + ref*2.)*4.)*.34 );\n        //sceneCol += refCol*.5;\n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        //sceneCol = vec3(ao);\n\t   \n\t\n\t}\n       \n    // Blend the scene and the background with some very basic, 4-layered fog.\n    float mist = getMist(camPos, rd, light_pos, t);\n    vec3 sky = vec3(3.5, 2.75, .975)* mix(2., .82, mist)*(rd.y*.35 + 2.);\n    sceneCol = mix(sceneCol, sky, min(pow(t, 2.5)*.35/FAR, 2.));\n\n    // Clamp, perform rough gamma correction, then present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 2.)), 2.0);\n\t\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 352, 374, 374, 409], [411, 455, 475, 475, 584], [586, 738, 759, 759, 825], [828, 894, 944, 944, 1152], [1154, 1230, 1255, 1348, 2300], [2313, 3117, 3145, 3145, 3270], [3272, 3528, 3554, 3554, 4390], [4392, 4724, 4751, 4751, 5287], [5289, 5389, 5411, 5411, 5468], [5471, 6043, 6061, 6061, 6679], [7445, 7509, 7538, 7538, 7648], [7650, 7700, 7757, 7757, 8139], [8141, 8162, 8198, 8198, 8633], [8635, 8834, 8861, 8861, 9019], [9624, 9806, 9844, 9844, 10197], [10990, 11348, 11391, 11391, 11714], [11717, 11924, 11959, 11959, 12163], [12166, 12458, 12481, 12481, 12577], [12579, 12724, 12753, 12787, 13222], [13224, 13275, 13296, 13296, 13362], [13364, 13656, 13718, 13718, 14323], [14325, 14325, 14381, 14407, 20160]]}
{"id": "tdtfzf", "name": "NAND strand", "author": "paniq", "description": "For a description of how this shader works, see the comment in \"Image\"", "tags": ["nand", "strand"], "likes": 5, "viewed": 355, "published": 3, "date": "1606265520", "time_retrieved": "2024-07-30T20:33:57.656915", "image_code": "/*\n\nNAND strand\n\nEach pixel on the field represents a logical NAND cell with two tendrils \n(kind of like a neuron with two dendrites). The tendrils sample two \nrandom neighboring fields for their bit value, which are then input into\na NAND operation.\n\nAccording to the NAND rules, a cell is active when the result of the \noperation is 1, and inactive otherwise (which is when both inputs are 1). \n\nTo ensure connectivity, a cell starts extending its tendrils in random \ndirections when it is inactive, hoping to find signals.\n\nBut when a cell is active all the time, it retracts its tendrils in a \nstraight line back to the cell to reduce connectivity. \n\nIn the beginning, tendrils are placed at a random point close to the \ncell. The maximum max-norm radius is scaled from 1 to 8 pixels from left \nto right.\n\nWere the field rendered as it is, it would be constantly flickering \nbetween black and white, which is quite unpleasant to look at. Therefore \nwe alternate the visualized buffer in Buffer B to get a coherent \nvisualization.\n\nI picked NAND as the operator because it is logically universal; a \ncombination of NAND circuitry is capable of representing every other \nlogical operation (AND, OR, XOR, NOT), and I was speculating on \n\"accidental\" complexity forming in this setup. Which happened.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec4 a = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(vec3(a.x), 1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 modcoord(vec2 p) {\n    return mod(p + iChannelResolution[0].xy, iChannelResolution[0].xy);\n}\n\nfloat nand(float a, float b) {\n    // A NAND B\n    a = a * 2.0 - 1.0;\n    b = b * 2.0 - 1.0;\n    float result = 1.0 - (1.0 + a) * (1.0 + b) /2.0;\n    return result * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame == 0) {    \n        vec2 uv = fragCoord / iResolution.xy;\n        \n        vec2 h = fragCoord + (hash22(fragCoord) * 2.0 - 1.0) * mix(1.0, 8.0, uv.x*uv.x);\n        \n\t\tfragColor = vec4((uv.x < 0.5)?hash22(fragCoord).x:0.0, h, 0.0);\n    } else {\n        vec4 col1 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\t\tvec4 col2 = texelFetch(iChannel0, ivec2(modcoord(col1.yz)), 0);\n\t\tvec4 col3 = texelFetch(iChannel0, ivec2(modcoord(col2.yz)), 0);\n        \n        col1.x = nand(col2.x, col3.x);\n        \n        if (col1.x < 0.01) {\n        \t// search\n            col1.yz += 0.1 * (hash23(vec3(col1.yz, iFrame)) * 2.0 - 1.0);\n        } else if ((col2.x + col3.x) > 1.0) {\n        \t// retract\n            vec2 n = normalize(fragCoord - col1.yz);\n            col1.yz += 0.01 * n;\n        }\n        \n        fragColor = vec4(col1.x, col1.yz, 0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 b = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = ((iFrame % 2 == 0)?a:b);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1305, 1305, 1361, 1361, 1458]]}
{"id": "wdcBDl", "name": "Life experiments 4: DNA", "author": "illus0r", "description": "Previous version https://www.shadertoy.com/view/wsdBW2", "tags": ["life", "cellular", "cell"], "likes": 5, "viewed": 667, "published": 3, "date": "1606237677", "time_retrieved": "2024-07-30T20:33:58.471736", "image_code": "// image\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n\tvec4 col;// = texture(iChannel0,uv);\n    //fragColor = col;\n    \n    for(float i=0.;i<R;i++){\n        for(float j=0.;j<R;j++){\n            vec2 ij = vec2(i,j);\n            //vec2 ij = vec2(0.);\n\t\t    //col += texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n\t\t    col = max(col,\n                      texture(iChannel1,(floor((FC))+ij)/iResolution.xy)\n                      //*\n                      //step(.00001,length(texture(iChannel0,(floor((FC))+ij)/iResolution.xy)))\n                     );\n        }\n    }\n    fragColor = col*1.5;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// common\n#define R 4.\n#define max_speed 1.\n#define BIRTH_P .05\n#define DEATH_P .01\n#define RESET_CYCLE 10000.\n#define REPL_DIR vec2(-1.) \n// mod(floor(float(iFrame)),2.)==0.?1.:-1.\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}", "buffer_a_code": "//a\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    if(rnd(uv.x+uv.y+iTime+1.)*.5+.5<DEATH_P){\n        fragColor=vec4(.0);\n        return;\n    }\n    \n    // spawning cells\n    if(mod(float(iFrame),50000.)<=1.){\n        fragColor=vec4(0.);\n        if(abs(length((uv-.5)/iResolution.x*iResolution.xy)-.0000001)<9.001){\n            fragColor=vec4(.5,.5,.5,.5);\n        }\n        return;\n    }\n\n    // find guest\n    vec2 guest_ij;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=vec4(p,v*.5+.5);\n                break;\n            }\n        }\n    }\n    \n    // no guests\n    if(!is_guest_found){\n        vec2 ij=REPL_DIR;\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.&&rnd(uv.x+uv.y+iTime)*.5+.5<BIRTH_P+.01*length(texture(iChannel1,uv).r)){\n            fragColor = vec4(.5);\n            return;\n        }\n        \n        fragColor = vec4(0.);\n        return;\n    }\n\n    \n    \n    //  ,    \n    for(float i=guest_ij.x-R;i<=guest_ij.x+R;i++){\n        for(float j=guest_ij.y-R;j<=guest_ij.y+R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 8.;\n            \t//f+=normalize(fragColor.rg-p)/dist*dist;\n            \tf+=normalize(fragColor.rg-p)*(target_dist-dist)*.5;\n            }\n        }\n    }\n    \n    if(length(fragColor)>0.){\n        p = fragColor.rg;\n        v = fragColor.ba*2.-1.;\n        p=fract(p+v);\n        v*=.4;\n        //v.x+=.1*(snoise(uv*4.));\n        //v.y+=.1*(snoise(uv*4.+99.+iTime/2.));\n        v += f*.1;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        fragColor.rg = p;\n        fragColor.ba = v*.5+.5;\n        //fragColor.b = .5;\n        //fragColor.a = 1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//b\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    \n    //   .\n    if(iFrame<1 || mod(float(iFrame),RESET_CYCLE)<=1.){\n        fragColor.r = (rnd(uv.x+uv.y)*.5+.5);\n        fragColor.g = 1.-(rnd(uv.x+uv.y)*.5+.5);\n        fragColor.b = 1.-(rnd(uv.x+uv.y)*.5+.5);\n        fragColor = texture(iChannel2,uv);\n        return;\n    }\n    \n    //          \n    vec2 guest_ij, v, p;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=texture(iChannel1, uv_n);\n                //fragColor=mix(fragColor,texture(iChannel2, uv_n),.01);\n                break;\n            }\n        }\n    }\n    \n    //  \n    //   ,     , \n    //   .\n    \n    //  \n    if(!is_guest_found){\n        vec2 ij=REPL_DIR;\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        // replication\n        if(length(neighbour)>0.){\n            fragColor = texture(iChannel1, uv_n);\n            fragColor.r+=rnd(uv.x+uv.y+iTime*.123456)/100.;\n            fragColor.g+=rnd(uv.x+uv.y+iTime*.223456)/100.;\n            fragColor.b+=rnd(uv.x+uv.y+iTime*.323456)/100.;\n            return;\n        }\n        fragColor = vec4(0.);\n        return;\n    }\n\n\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 59, 59, 639]]}
{"id": "Ws3BDs", "name": "Terraforming Timelapse", "author": "ocb", "description": "Extrapolation of \"Lockdown\" shader, https://www.shadertoy.com/view/wsSczz\n\nMusic: Philip Glass, Metamorphosis 2.\n\nInfos in Image tab header", "tags": ["space", "planet", "tree", "timelapse", "crater"], "likes": 49, "viewed": 876, "published": 3, "date": "1606217122", "time_retrieved": "2024-07-30T20:33:59.513950", "image_code": "// Author: \t\tocb\n// Title: \t\tTerraforming Timelapse\n\n// Having fun with my preceding shader:\n// \"Lockdown\" https://www.shadertoy.com/view/wsSczz\n//\n// Built by adding code here and there.\n// Sorry for the code not optimized and really unreadable.\n// Too much details, too slow...\n//\n// Things to know:\n// Some camera vews are set on interesting point, depending on the landscape.\n// BUT, as random result depends on each GPU, you may change the FBM Offset (line 34) in Common tab,\n// in order to obtain more suitable landscape for the pre-defined camera position.\n//\n// Moreover, you can set cam free, line 53.\n// RAU value (line 55) is the distance to the camera target, crater center by default.\n//\n/*********************** Global *************************************/\nfloat TimeHsh;\n\n/*********************** pre-declared *******************************/\nvec3 tree(vec3 pos, vec3 ray, float tg);\n\nfloat structure(vec3 p, float scale, float startime);\n\n\n/******************** Raycasting base function ***********************/\n\nfloat plan(float p, float r, float d){\n    float t = (d-p)/r;\n    if(t<=0.) t = INFINI;\n    return t;\n}\n\nvec2 sphere(in vec3 p, in vec3 O, in float r, in vec3 ray){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    float c = dot(d,d) - r*r;\n    float D = b*b - c;\n    if (D >= 0.){\n        float VD = sqrt(D);\n        t.x= b - VD;\n        t.y= b + VD;\n        t += (INFINI-t)*step(t,vec2(0.));\n    }\n    return t;\n}\n\nvec2 cylinder(in vec2 pos, in vec2 cylO, in float cylR, in vec2 ray){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 delta = pos - cylO;\n\n    float a = dot(ray,ray);\n    float b = dot(delta, ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\n\n/*****************************    Sky   *****************************/\n\nvec3 skyCol(vec3 ray){\n    float lit = dot(ray,LIGHT);\n\tvec3 col = (.05*TimeHsh+.95)*vec3(1.,.5,0.)*max(.6-ray.y,0.)*(.7+.3*lit) + .002/(1.002-lit);\n    col = mix(col, vec3(.2,.1,0.)+.05*texture(iChannel2,ray.xz*vec2(.001,.01)+TIME).r, smoothstep(-4.,0.,-abs(TIME-40.))*(.7+.3*TimeHsh) );\n    float storm = abs(TIME-72.);\n    if(storm<=7.) col *= .2+.1*storm-.05*TimeHsh;\n    return col;\n}\n  \n/************************************************************************/\n/*\t\t\t\t\t\t\tGround fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// mapping global crater shape\nfloat shape(vec2 g){\n\tfloat a = .000001*(g.x*g.x + g.y*g.y);\n    float h = smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    return h;\n}\n\n// mapping accurate ground, adding shape + fbm + texture\nfloat ground(vec2 g, float t){\n\tfloat len = max(abs(g.x),abs(g.y));\n    if(len>5000.) return .5; \n    float h = shape(g);\n    float m = fbm(vec3(g.x,maxHill*h,g.y));\n    m *= 1.-linstep(3000.,5000.,len);\n    \n    // scaling texture\n    float tex,trans,dump;\n    if(t>300.){\n    \tfloat dump = 1.-linstep(300.,2000.,t);\n        tex = dump*1.5*texture(iChannel0,.00125*g.xy+.5).r;\n    }\n    else if(t>100.){\n    \ttrans = linstep(100.,300.,t);\n        tex = trans*1.5*texture(iChannel0,.00125*g.xy+.5).r+(1.-trans)*.3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else if(t>50.){\n        tex = .3*texture(iChannel0,.01*g.xy+.5).r;\n    }\n    else{\n    \ttrans = linstep(20.,50.,t);\n        tex = trans*.3*texture(iChannel0,.01*g.xy+.5).r+(1.-trans)*.05*texture(iChannel0,.05*g.xy+.5).r;\n    }\n    \n    return maxHill*(.4*h*m+.2*m+.4*h)+ tex;\n}\n\n\nvec3 getGndNormal(vec3 p, float t){\n    vec2 e = vec2(.1-.075*step(t,50.),0.);\t// step() to adjust accuracy to the scale\n\tfloat dx = ground(p.xz+e.xy,t) - p.y;\n    float dy = ground(p.xz+e.yx,t) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\n// Fast marching to the global shape\nfloat traceShape(in vec3 pos, in vec3 ray){\n    float t = 0., dh;\n    vec3 p = pos;\n    for(int i=0;i<60;i++){\n        dh = p.y-maxHill*shape(p.xz)*1.15;\n        if(abs(dh)<10.)break;\n        t += dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\n// Marching:\n// step 1 = fast marching to the shape\n// step 2 = fine tunning on the ground\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.,dh;\n    \n    if(pos.y > maxHill*shape(pos.xz)*1.15) t = traceShape(pos, ray);    \n   \tif(t == INFINI) return INFINI;\n    \n    vec3 p = pos + t*ray;\n    for(int i=0; i<70;i++){\n        dh = p.y-ground(p.xz,t);\n        if(abs(dh)<.01) break;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.5*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n    }\n    return t;\n}\n\nfloat groundShadows(vec2 p){\n    float txg;\n    // Ground shadow\n    vec2 g = abs(p.xy)/2000.;\n    if(sign(p.x)>0.){\n        if(sign(p.y)>0.){ txg = texture(iChannel1,g).x - iResolution.x;}\t// removing resolution info (stored in buffer A)\n        else{ txg = texture(iChannel1,g).y;}\n    }\n    else{\n        if(sign(p.y)>0.){txg = texture(iChannel1,g).w;}\n        else{txg = texture(iChannel1,g).z;}\n    }\n    \n    // Dome structure shadow\n    vec3 px = vec3(p.x, max(min(lakeH,TIME-15.),ground(p.xy,51.)), p.y);\n    float txs = sphere(px,C,R,LIGHT).y;\n    float c = 0.;\n    if(txs<INFINI){\n        vec3 pxs = px+txs*LIGHT - C;\n        float d = structure(pxs,2.,3.);\n        c = smoothstep(-.15,.12,-abs(d));\n        d = structure(pxs,4.,8.);\n        c = max(c,smoothstep(-.12,.12,-abs(d)));\n    }\n    return min(txg,1.-c);\n}\n\nvec3 PaintCrater(vec3 p, vec3 ray, float tg, vec3 norm){\n    \n    vec3 col;\n    float dist = length(p.xz);\n    // scaling texture\n    float trans;\n    vec3 tex;\n    if(dist>3000.){\n        tex = texture(iChannel0,.0000625*p.xz+.5).rgb;\n    }\n    else if(tg>100.){\n        trans = linstep(100.,300.,tg);\n        tex = trans*texture(iChannel0,.00125*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else if(tg>50.){\n        tex = texture(iChannel0,.01*p.xz+.5).rgb;\n    }\n    else{\n        trans = linstep(20.,50.,tg);\n        tex = trans*texture(iChannel0,.01*p.xz+.5).rgb+(1.-trans)*texture(iChannel0,.05*p.xz+.5).rgb;\n    }\n\n    // setting color\n    col = vec3(.5,.25,.0) + tex;\n    \n    // shade\n    col *= dot(-norm,LIGHT);\n\n    // fog\n    float tt = 3000./tg;\n    col *= min(1.,tt);\n    col = mix(skyCol(ray), col, min(.7,tt));\n\t\n    // grass\n    float level = min(lakeH,TIME-18.);\n    if(dist<1000. && p.y>level){\n        float h = smoothstep(30.,40.,TIME)*6.*tex.g*max(0.,(1.-.002*(p.y-level)));\n        float frz = abs(TIME-80.);\n\t\tif(frz>=8.) h *= step(.8,-norm.y);\n        col += vec3(-.1,-.06,-.1)*h;\n        if(frz<8.) col = mix(col,vec3(.7),step(h,(3.-.375*frz)));\n    }\n            \n    // shadow\n    if(dist<2000.){\n        float shad;\n    \tif( tree(p, LIGHT, 50.).x < INFINI) shad = .2;\n        else shad = groundShadows(p.xz);\n        col *= shad;\n    }\n\n    return col;\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tDome fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\n// coord. change\nvec2 polar(vec3 p){ return vec2(atan(p.z/p.x)+PI*step(p.x,0.),atan(length(p.xz)/p.y)); }\n\nvec3 cartesian(vec2 i){float s = sin(i.y); return vec3(s*cos(i.x),cos(i.y),s*sin(i.x));}\n\n// Black structure on sphere, depending on scale\nfloat structure(vec3 p, float scale, float startime){\n    float d = 1.;\n    vec2 a = polar(p)/PIdiv2;\n    if( .5*(1.-a.y)+mod(.1-a.x,2.) < .05*floor(10.*(TIME-startime))){\n        a.y *= 4.;\n        float iy = floor(a.y);\n        a.x *= 2.*scale;\n        a.x += 1./pow(scale,scale);\n        a.x += mod(iy,2.)*.5;\n        a = fract(a)-vec2(.5,0.);\n        d = 2.*abs(a.x);\n        /*if(iy<scale-3.) d = 1.;\n        else*/ if(iy<scale-2.) d -= smoothstep(-.02,.1,a.y)-.05;\n        else d -= smoothstep(-0.12,.5,a.y)-.05;\n    }\n    return d;\n}\n\n// Black structure on sphere.\n// Call twice at 2 different scales (thick and thin) \nfloat frame(vec3 p){\n\n    float d = structure(p,2.,3.);\n    float c = smoothstep(-.04,-.02,-abs(d));\n\n    d = structure(p,4.,8.);\n    c = max(c,smoothstep(-.03,-.01,-abs(d)));\n    \n    return c;\n}\n\nvec3 DrawStruct(vec3 p, vec3 ray){\n    vec3 col = vec3(.0);\n\n    p -= C;\t\t\t\t// origin of the coord set on the center of sphere\n    col -= frame(p);\t// blacken the frame\n\n    vec2 tile = WINTILE/PIdiv2;\t\t// number of window glass\n    vec2 a = tile*polar(p);\t\t\t// tiling polar coordinates\n    vec2 i = floor(a)/tile;\n    vec2 f = abs(fract(a)-.5);\n    \n    float prog = 8.-10.*i.y + .5*i.x;\n\n    if(prog < TIME-15.5 && prog > TIME-16.){\n        float d = smoothstep(.45,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n\t\tcol += .2*d;\n    }\n\n    if(prog < TIME-16.){\n        float d = smoothstep(.47,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n        vec3 norm = cartesian(i);\t\t// back to cartesian. Same normal for the whole window (i = floor)\n        vec3 refl = reflect(ray,norm);\t\n\n        float spec = .015/(1.01-dot(LIGHT,refl));\t\t// calculating sky reflection\n        col += spec;//*skyCol(refl);\t\t\t\t\t// and specular light\n        col += .3*spec*d;\t\t\t\t\t\t\t\t// sky reflection is used on the whole surface to set the golden color of the dome\n\n        p += C;\n        float t = traceGround(p,refl);\t\t\t\t// Adding ground reflection using the window normal\n        if(t<INFINI){\n            vec3 pr = p + t*refl;\n            pr.y = ground(pr.xz,t);\n\n            vec3 n = getGndNormal(pr,t);\n            col += .5*PaintCrater(p,refl,t,n)*groundShadows(p.xz);\n        }\n        else col += skyCol(refl);\n    }\n    return col;\n}\n\n/************************************************************************/\n/*\t\t\t\t\t\t\ttree fct\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvec4 getNextPlan(in vec2 xz, in vec2 v){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz/cellD))*cellD/v;\n    float tmin = min(dtp.x, dtp.y);\n    s *= -step(dtp,vec2(tmin));\n    return vec4(s.x,0.,s.y,tmin);\n}\n\nvec3 tree(vec3 pos, vec3 ray, float tg){\n    if(TIME<40.) return vec3(INFINI,0.,0.);\n    // trees\n    vec3 pe = pos;\n    vec2 tc = cylinder(pos.xz, vec2(0.), 900., ray.xz);\n    float te = INFINI, tx = 0.;\n\n    // Entry and exit point of the voxel run(te and tx)\n    float th = plan(pos.y,ray.y,cellH);\n    \n    if(pos.y>=cellH){\n        te = min(max(tc.x,th),tc.y);\n        tx = min(tg,tc.y);\n    }\n    else{\n        te = tc.x*step(0.,tc.x)+INFINI*step(th,tc.x);\n        tx = min(min(tg,tc.y),th);\n    }\n    \n    \n    pe += te*ray;\n    vec4 wall;\n    for(int k=0;k<maxCell;k++){\n        wall = getNextPlan(pe.xz, ray.xz);\n        te += wall.w+.01;\n        if(te>=tx) break;\n\n        pe = pos + te*ray;\n        vec2 id = floor(pe.xz/cellD+.5);\n        float proba = H2(id);\n        if(proba > PINE){\n        \tfloat gnd = ground(id*cellD,1.);\n        \tif(gnd > lakeH){\n                // pines\n                vec2 ft = 2.*(fract(pe.xz/cellD)-.5);\n                float ti = .002*H2(id+vec2(floor(40.*TIME)));\n                float H = treeH*(proba-.6)*smoothstep(50.,70.,TIME)+10.*ti;\n                float hh = H*(abs(ft.x)+abs(ft.y));\n                float tex = texture(iChannel0,.05*vec2(pe.x-pe.z, pe.y)+ti).r\n                    \t\t*texture(iChannel0,.2*vec2(pe.x+pe.z, pe.y)-ti).r;\n                tex *= smoothstep(0.,20.,hh-pe.y+gnd-H+5.);\n\n                if(tex>.03)return vec3(te,proba,tex);\n            }\n        }\n\t\telse if(proba > BUSH){\n        \tfloat gnd = ground(id*cellD,1.);\n        \tif(gnd > lakeH){\n                // bush\n                vec2 ft = abs(fract(pe.xz/cellD-.5)-.5);\n                float len = length(vec2(ft.x+ft.y,(pe.y-gnd+2.*(1.-proba)/(1.-BUSH))/cellD));\n                float ti = .001*H2(id+vec2(floor(40.*TIME)));\n                float tex = texture(iChannel2,.05*vec2(pe.x-pe.z, pe.y)+ti).r\n                    \t\t*texture(iChannel0,.01*vec2(pe.x+pe.z, pe.y)-ti).r;\n                float grow = .5*smoothstep(35.,60.,TIME)+5.*ti;\n                \n                tex *= smoothstep(-1.2*grow,-grow,-len);\n\n                if(tex>.125) return vec3(te,proba,tex);\n            }\n        }\n    }\n\n\treturn vec3(INFINI,0.,0.);\n}\n\n\nvec3 treeColor(in vec3 pos, in vec3 ray, in vec3 tt){\t// tt.x = t // tt.y = proba // tt.z = tex //\n    vec3 col;\n    vec3 pe = pos+tt.x*ray;\n    vec2 ft = 2.*(fract(pe.xz/cellD+.5)-.5);\n    if(tt.y > PINE){\n        float H = treeH*(tt.y-.6);\n        vec2 nt = normalize(ft*(H-pe.y+300.)/H -ray.xz);\n        float shad = max(0.,dot(nt,LIGHT.xz));\n        col = vec3(tt.y-.7,.25,.1)*(1.-min(1.,10.*tt.z))*shad;\n        float frz = abs(TIME-78.);\n        if(frz<8.) col = mix(col,vec3(3.)*(.25-tt.z),(1.-.125*frz));\n        //if(frz<8.) col = mix(col,vec3(.8),step(tt.z,.1-.020*frz));\n    }\n    else{\t// bush\n        vec3 nt = normalize(vec3(ft.x-ray.x,-ray.y,ft.y-ray.z));\n        float shad = max(0.,.3+.7*dot(nt,LIGHT));\n        col = vec3(.45-.25*tt.y,.4,.15)*(1.4-5.*tt.z)*shad;\n        float frz = abs(TIME-78.);\n        if(frz<8.) col = mix(col,vec3(8.)*(.24-tt.z),(1.-.125*frz));\n        //if(frz<8.) col = mix(col,vec3(.8),step(tt.z,.2-.025*frz));\n    }\n    col *= groundShadows(pe.xz);\n\treturn col;    \n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\tCamera\t\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvec3 getCamPos(inout vec3 camTarget){\n    \n #ifdef FREE_CAM\n    float \trau = RAU,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n #else\n\n    float ti = TIME;\n    \n    float rau,\n    \t  alpha,\n    \t  theta;\n    \n    if(ti<9.){\t\t\t\t\t\t\t\t// Main struct, outside\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 2000.;\n        alpha = -1.5-.1*ti;\n        theta = .2;\n    }\n    else if(ti<18.){\t\t\t\t\t\t// fine struct, inside\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 800.;\n        alpha = 1.5-.2*ti;\n        theta = .05;\n    }\n    else if(ti<29.){\t\t\t\t\t\t// Glass cover\n    \tcamTarget = vec3(0.,150.,0.);\n        rau = 1900.-20.*ti;\n        alpha = 3.9-.2*ti;\n        theta = .1+1.*smoothstep(18.,26.,ti);\n    }\n    else if(ti<33.){\t\t\t\t\t\t// Water start\n    \tcamTarget = vec3(-100.,25.,-400.);\n        rau = 200.;\n        alpha = -1.;\n        theta = .1;\n    }\n    else if(ti<45.){\t\t\t\t\t\t// Main view, water uplifting\n    \tcamTarget = vec3(0.,100.,0.);\n        rau = 900.;\n        alpha = -.5+.025*(ti-33.);\n        theta = .1;\n    }\n    else if(ti<55.){\t\t\t\t\t\t// Growth\n    \tcamTarget = vec3(0.,50.,0.);\n        rau = 800.;\n        alpha = -1.75;\n        theta = .0;\n    }\n    else if(ti<63.){\n    \tcamTarget = vec3(-150.,45.,460.);\t// Spirit Island\n        rau = 100.;\n        alpha = 1.+.025*(ti-55.);\n        theta = .1;\n    }\n    else if(ti<70.){\n    \tcamTarget = vec3(450.,50.,-300.);\t\t// little sound\n        rau = 150.;\n        alpha = -2.5+.025*(ti-63.);\n        theta = .2;\n    }else if(ti<80.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// Storm, outside\n        rau = 2000.;\n        alpha = -1.;\n        theta = .25;\n    }\n    else if(ti<88.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// winter, inside\n        //rau = 750.-10.*(ti-77.);\n        rau = 740.;\n        //alpha = -2.4;\n        alpha = -2.4-.015*(ti-77.);\n        theta = .025;\n    }\n    else if(ti<100.){\n    \tcamTarget = vec3(0.,50.,0.);\t\t// Traveling, inside\n        rau = 900.-10.*(ti-86.);\n        alpha = .3;\n        theta = .08;\n    }\n    else if(ti<110.){\n    \tcamTarget = vec3(-400.,50.,-400.);\t\t// scrolling, inside\n        rau = 200.;\n        alpha = .1*ti+4.;\n        theta = .1;\n    }\n    else {\n    \tcamTarget = vec3(0.,150.,0.);\t\t// end\n        rau = 1000.+30.*(max(0.,ti-105.));\n        alpha = .1*ti;\n        theta = .2;\n    }\n\n    \n    \n #endif\n            \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\n/************************************************************************/\n/*\t\t\t\t\t\t\t\tMain\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TimeHsh = H2(vec2(floor(40.*TIME)))*step(TIME,86.);\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 camTarget = TARGET;\n    vec3 pos = getCamPos(camTarget);\n    pos.y = max(pos.y, 10.+max(lakeH, ground(pos.xz,1.)));\n    vec3 ray = getRay(st, pos,camTarget);\n\t\t\n    vec3 col = vec3(.0);\n        \n    float tg = INFINI;    \n    tg = traceGround(pos,ray);\n    float tw = plan(pos.y,ray.y,min(lakeH,TIME-18.));\n    vec3 tt = tree(pos, ray,tg);\n    vec2  ts = sphere(pos,C,R,ray);\n    \n    float dist = max(abs(pos.x+tw*ray.x),abs(pos.z+tw*ray.z));        \n\tif(dist>1000.) tw = INFINI;\n    \n    float t = min(min(min(tg,INFINI),tw),tt.x);\n    \n\n    if(t >= INFINI){\t\t// Sky\n        col += skyCol(ray);\n    }\n        \n    else if(t == tt.x){\t\t// Tree      // tt.x = t // tt.y = proba // tt.z = tex //\n        col = treeColor(pos, ray, tt);\n    }\n    \n    else if(t == tw){\t// Lake\n        \n        float frz = abs(TIME-78.);\t// frozen time (used below)\n\n        vec3 pg = pos + tg*ray;\t\t// ground infos. used for lake bottom\n        pg.y = ground(pg.xz,tg);\n\t\t\t\t\t\t\t\t\t\t\n        vec3 nw = vec3(0.,1.,0.);\t// water infos\n        vec3 pw = pos + tw*ray;\n        float depth = max(0.,pw.y - pg.y);\n        depth = 15./(depth*depth+15.);\n        vec3 ng = getGndNormal(pg,tg);\n        col += PaintCrater(pg,ray,tg, ng);        \n        \n\n        col = mix( vec3(.0,.03,.05), col , min(depth,.5)*max(0.4,dot(nw,-ray)) );\n\t\t\n        if(frz>=10.) nw = normalize(nw+.025*texture(iChannel2,.005*pw.xz+.3*TimeHsh).rrr-.0125);\n        vec3 refl = reflect(ray,nw);\n        float spec = .1/(1.1-dot(refl,LIGHT));\n        \n        float tgr = traceGround(pw+.1,refl);\n        vec3 ttr = tree(pw, refl,tgr);\n        if(ttr.x<tgr) col = mix(col,treeColor(pos, ray, ttr),.4);\n        else if(tgr<INFINI){\t\t\t\t\t\t\n            vec3 pr = pw + tgr*refl;\n            pr.y = ground(pr.xz,tg+tgr);\n            vec3 nr = getGndNormal(pr,tg+tgr);\n            col = mix(col,PaintCrater(pr,refl,tgr,nr),.4);\n        }\n        \n        float shad;\n        if( tree(pw, LIGHT, 100.).x < INFINI) shad = .2;\n        else shad = groundShadows(pw.xz);\n\n        col += (.5*spec+.4)*skyCol(refl)*smoothstep(.2,.8,shad);\n        \n        if(frz<8.) col += vec3(.4,.45,.5)*(depth+.5)*shad*(1.-.125*frz);\n\n        \n    }\n    \n    else{ // if(t == tg){\t// Ground\n        vec3 pg = pos + tg*ray;\n        pg.y = ground(pg.xz,tg);\t\t// recalculating p.y (vertical) to be more accurate on position\n\t\t\t\t\t\t\t\t\t\t// needed due to the fine details\n        vec3 ng = getGndNormal(pg,tg);\n        col += PaintCrater(pg,ray,tg, ng); \n    }\n        \n                     \n\tif(ts.x < t){\t\t\t// Dome outside     \n        vec3 pd = pos + ts.x*ray;\n        vec3 coldom = DrawStruct(pd,ray);\t// draw frame and color\n    \tif(coldom != vec3(0.)) col = mix(col,coldom,0.5);\t\t// mixing sphere and color behind for the partial transparency\n    }\n  \t\n    if(ts.y < t){\t\t\t// Dome inside\n        vec3 pd = pos + ts.y*ray;\n        pd-=C;\n        col -= .4*frame(pd);\n        if(ts.y < ts.x){\n            vec2 tile = WINTILE/PIdiv2;\t\t// number of window glass\n            vec2 a = tile*polar(pd);\t\t\t// tiling polar coordinates\n            vec2 i = floor(a)/tile;\n            vec2 f = abs(fract(a)-.5);\n    \n    \t\tfloat prog = 8.-10.*i.y + .5*i.x;\n\n            if(prog < TIME-14. && prog > TIME-16.){\n                float d = smoothstep(.4,.5,max(f.x,f.y));\t\t\t// draw thin contour of each window\n                col -= .05*d;\n            }\n\n    \t\tif(prog < TIME-16.){\n            \tvec3 norm = cartesian(i);\t\t// back to cartesian. Same normal for the whole window (i = floor)\n            \tvec3 refl = reflect(ray,norm);\t\n            \tfloat spec = .7/(1.1-dot(LIGHT,refl));\n            \tcol *= spec;\n            }\n        }\n    }\n\n    float storm = abs(TIME-75.);\n    if(storm<=7.) col *= (.3+.1*storm)-.05*TimeHsh;\n    fragColor = vec4(.05+1.7*col,1.0);\n}\n\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24675, "src": "https://soundcloud.com/austinpiano/philip-glass-cover", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n\n// Ground def\n#define STEP 6.\n#define maxHill 200.\n\n#define lakeH 35.\n\n// Dome def\n#define R 1500.\n#define C vec3(0.,-970.,0.)\n#define WINTILE vec2(32.,64.)\n\n// Tree def\n#define treeH 80.\n#define cellD 10.\n#define maxCell 250\n#define cellH 150.\n\n// random threshold\n#define PINE .9\n#define BUSH .6\n\n/*************************************/\n/*          GROUND CONTROL           */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t// if terrain is inappropriate, ie center hill too high\n\t\t\t\t\t\t\t\t\t\t// or dome on the back-side, or too much collisions cam-terrain\n\t\t\t\t\t\t\t\t\t\t// change the offset of the fbm, as random result depends on each\n\t\t\t\t\t\t\t\t\t\t// GPU.\n#define FBM_OFFSET vec2(-.5,.5)\t\t\n\n\n\n/*************************************/\n/*            CAM CONTROL            */\n/*************************************/\n\t\t\t\t\t\t\t\t\t\t\t\t// Select one of the time set below.\n\t\t\t\t\t\t\t\t\t\t\t\t// time depending on iTime\n\t\t\t\t\t\t\t\t\t\t\t\t// or time depending on mouse \n//#define TIME iMouse.x/iResolution.x*120.\n\n#define TIME iTime\n\n\n\n\t\t\t\t\t\t\t// Uncomment FREE_CAM to have mouse controle\n\t\t\t\t\t\t\t// Change RAU value to set the distance to the visual center (target)\n//#define FREE_CAM\n\n#define RAU 800.\n\n\n\n/* centered on dome */\n#define TARGET vec3(0.,150.,0.);\n\n/* centered on Spirit Island */\n//#define TARGET vec3(-150.,50.,480.);\n\n/* following crater cliff (in) */\n//#define TARGET vec3(500.*cos(.1*iTime)+100.,60.,500.*sin(.1*iTime));\n// * following crater cliff (out) */\n//#define TARGET vec3(1200.*cos(.1*iTime)+300.,250.,1200.*sin(.1*iTime));\n\n\n/********************************************************************/\n/********************************************************************/\n\n\n#define LIGHT vec3(-0.691714463866075,0.207514339159822+.002*H2(vec2(floor(40.*TIME))),-0.691714463866075)\n//#define LIGHT normalize(vec3(-0.691714463866075,0.207514339159822+.002*H2(vec2(floor(40.*TIME))),-0.691714463866075))\n\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/* linear step = poor smoothstep but faster */\nfloat linstep(float a, float b, float x){\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\nfloat fbm(vec3 p){\n    p*= .0035;\n    vec2 uv = p.xz+FBM_OFFSET;\n\tfloat a = 1., Hz = 1., m = 1., h= p.y;\t\t\t\t\t\n    vec2 d = vec2(1.,0.);\n    for(float i=1.;i<=STEP; i++){\n        vec2 e = floor(uv*Hz), f = fract(uv*Hz);\n        f = smoothstep(0.,1.,f);\n        h += mix(\n            \tmix(H2(e),H2(e+d.xy),f.x)*a,\n            \tmix(H2(e+d.yx),H2(e+d.xx),f.x)*a,\n            \tf.y);\n        \n        a *= .2+.1*h+.05*i;\n        //a *= .5;\n        Hz *= 2.+.2*p.y;\n        m += a;\n    }\n    h/=m;\n    \n    h *= h;\n    \n    return h;\n}\n\n", "buffer_a_code": "/*******************    buffer A    *********************/\n/*\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*               Shadows pre-calculation                */\n/* The 4 channels are used to increase map resolution   */\n/* \t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/********************************************************/\n\n\nfloat ground(vec2 p){\n    \n    float a = .000001*(p.x*p.x + p.y*p.y);\n    float h =smin(a*a,abs(1./a),.2)+.8/(50.*a+1.);\n    float m = fbm(vec3(p.x,maxHill*h,p.y));\n    return max(lakeH, maxHill*(.4*h*m+.2*m+.4*h)+ texture(iChannel0,.00125*p.xy+.5).r);\n}\n\nvec3 getGndNormal(vec3 p){\n    vec2 e = vec2(.1,0.);\n\tfloat dx = ground(p.xz+e.xy) - p.y;\n    float dy = ground(p.xz+e.yx) - p.y;\n    return normalize(vec3(dx,-e.x,dy));    \n}\n\n\nfloat traceGround(in vec3 pos, in vec3 ray){\n    float t = 0.;\n    float dh = pos.y-ground(pos.xz);\n    if(dh<.1) return .0001;\n    for(int i=0; i<75;i++){\n        vec3 p = pos;\n        t += .9*dh;\n        p = pos+t*ray;\n        if(p.y > 1.6*maxHill && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y-ground(p.xz);\n        if(abs(dh)<.1)break;\n    }\n    return t;\n}\n\n\nfloat shad(vec3 p){\n    \n        p.y = ground(p.xz);\n        vec3 norm = getGndNormal(p);\n        p -= .2*norm;\n        float t = traceGround(p,LIGHT);\n        if(t<INFINI) return .2;    \n        else return 1.;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float check = floor(texelFetch(iChannel1,ivec2(fragCoord),0).x -.1);\t// checking if resolution has changed\n    if(check == iResolution.x){\t\t\t\t\t\t\t\t\t\t\t\t// in order to manage screen size change.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if no change, just reading pre-calculated shadows\n        fragColor = texture(iChannel1,fragCoord/iResolution.xy);\t\t\t// stored in Buffer A\n    }\n\n    else{   \n        vec2 st = 2000.*fragCoord.xy/iResolution.xy;\t\t\t\t// if screen size has changed, bufferA size changed too \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// shadows must be recalculated.\n        vec3 p = vec3(st.x,0.,st.y);\n        fragColor.x = shad(p)+iResolution.x;\t\t\t\t\t\t// storing new resolution info\n\n        p.z = -p.z;\n        fragColor.y = shad(p);\n\n        p.x = -p.x;\n        fragColor.z = shad(p);\n\n        p.z = -p.z;\n        fragColor.w = shad(p);\n    } \n}\n\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1030, 1030, 1068, 1068, 1133], [1135, 1135, 1194, 1194, 1478], [1480, 1480, 1549, 1549, 1880], [1955, 1955, 1977, 1977, 2344], [2530, 2561, 2581, 2581, 2689], [2691, 2748, 2778, 2778, 3583], [3586, 3586, 3621, 3621, 3833], [3836, 3873, 3916, 3916, 4215], [4217, 4308, 4352, 4352, 4771], [4773, 4773, 4801, 4801, 5599], [5601, 5601, 5657, 5657, 7010], [7193, 7210, 7229, 7229, 7298], [7300, 7300, 7323, 7323, 7388], [7390, 7439, 7492, 7492, 7979], [7981, 8065, 8085, 8085, 8261], [8263, 8263, 8297, 8297, 9705], [9887, 9887, 9927, 9927, 10119], [10121, 10121, 10161, 10161, 12284], [12287, 12287, 12340, 12385, 13298], [13480, 13480, 13517, 13517, 16010], [16012, 16012, 16068, 16068, 16272], [16452, 16452, 16509, 16509, 20410]]}
{"id": "tddBDf", "name": "vieja(e) es(x)a", "author": "jorge2017a1", "description": "vieja(e) es(x)a", "tags": ["viejaeesxa"], "likes": 1, "viewed": 324, "published": 3, "date": "1606189320", "time_retrieved": "2024-07-30T20:34:00.408558", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat VentanasCirculo(vec3 p, float numItem)\n{   \n    float tau = atan(1.0) * 8.0;\n    vec3 pp;    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(p, vec3(3.0,5.5,1.0));\n    float sdba= sdBox(p-vec3(-1.2,2.1,0.0), vec3(1.0,2.0,1.2));\n    float sdbb= sdBox(p-vec3(1.2, 2.1,0.0), vec3(1.0,2.0,1.2));\n    float sdbc= sdBox(p-vec3(-1.2,-2.1,0.0), vec3(1.0,2.0,1.2));\n    float sdbd= sdBox(p-vec3(1.2, -2.1,0.0), vec3(1.0,2.0,1.2));\n    float diff=differenceSDF(sdb1, sdba);\n    diff=differenceSDF(diff, sdbb);\n    diff=differenceSDF(diff, sdbc);\n    diff=differenceSDF(diff, sdbd);\n    float res=diff;\n     return  res;\n}\n\nfloat cilindrosconboxGrande(vec3 p, float numItem)\n{\n    vec3 pp;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.5,10.0,10.0) );\n    float res =  sdb1;\n\treturn  res;\n}\n\nfloat cilindrosconboxGrandeConPuertas(vec3 p, float numItem)\n{\n     vec3 pp;\n    // p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.5,10.0,10.0) );\n    float sdba= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.6,3.0,8.0) );\n     sdb1=differenceSDF(sdb1, sdba);\n    float res =  sdb1;\n\n\treturn  res;\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    p.y=p.y-12.0;\n    vec3 q=p;\n    float cz=110.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    float ci2= cilindrosconboxGrande( p, 8.0);\n    float ci3= cilindrosconboxGrandeConPuertas( p, 8.0);\n    \n    float ci4= cilindrosconboxGrande( p-vec3(0.0,0.0,20.0), 8.0);\n    float ci5= cilindrosconboxGrandeConPuertas(p-vec3(0.0,0.0,40.0), 8.0);\n    \n    res =opU3(res, vec3(ci2,7.0,-1.0)); \n    res =opU3(res, vec3(ci3,8.0,-1.0)); \n    res =opU3(res, vec3(ci4,9.0,-1.0)); \n    res =opU3(res, vec3(ci5,8.0,-1.0)); \n  \n\t//res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    //vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n    //vec3 ref = reflect(lig, normal);\n    float diff = dot(normal, l);\n    \n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n    //float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    //float dom = smoothstep(-1.0, 1.0, r.y);\n    \n\t\tspecular = pow( specular, shininess );\n\t\t//final += color * ( diffuse + specular/fre*0.5*dom);\n    \tfinal += color * ( diffuse*0.7 + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*15.0,1000.0);\n    itime=t;\n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 2.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n   \n    vec3 ro=vec3(0.0,10.0,-25.0+t);      \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "//---por jorge2017a1...jorgefloresp\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    float tt= mod(time,100.0);\n    float x=440.0;\n    float x2=800.0;\n    float res1=0.75 *mod( abs(sin(x *tt*0.25 )),0.8);\n     res1=sin(res1*tt);\n    \n    \n    float res2=0.75 *mod( abs(sin(x2 *tt*0.25 )),0.8);\n     res2=sin(res2*sin(tt));\n    \n    return  vec2 (res1+res2);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 435, 435, 456], [457, 457, 489, 489, 573], [574, 574, 620, 620, 707], [708, 708, 742, 742, 804], [805, 805, 842, 842, 937], [938, 938, 977, 977, 1072], [1073, 1073, 1112, 1112, 1207], [1208, 1208, 1247, 1247, 1342], [1344, 1388, 1435, 1435, 1462], [1464, 1464, 1507, 1507, 1534], [1536, 1536, 1584, 1584, 1612], [1613, 1684, 1718, 1718, 1816], [1817, 1817, 1851, 1851, 1943], [1944, 1944, 1978, 1978, 2070], [2071, 2111, 2145, 2145, 2242], [2275, 2275, 2301, 2301, 2355], [2357, 2357, 2391, 2391, 2564], [2567, 2595, 2636, 2636, 2729], [2731, 2731, 2777, 2777, 3367], [3369, 3369, 3421, 3421, 3653], [3655, 3655, 3717, 3717, 4057], [4061, 4101, 4126, 4126, 4819], [4821, 4821, 4907, 4907, 5738], [5744, 5795, 5819, 5819, 6007], [6008, 6071, 6104, 6104, 6565], [6567, 6621, 6657, 6657, 6891], [6892, 6947, 7027, 7027, 7304], [7305, 7357, 7450, 7450, 7550], [7555, 7604, 7661, 7661, 8855]]}
{"id": "3dcBWX", "name": "checkerboard spiral", "author": "teadrinker", "description": "This was fun!\nCheck this out for more info and similar stuff:\nhttps://isohedral.ca/swirled-series/", "tags": ["spiral", "checkerboard", "checkerboardspiral"], "likes": 13, "viewed": 413, "published": 3, "date": "1606185596", "time_retrieved": "2024-07-30T20:34:01.266265", "image_code": "//\n// More stuff like this:\n// https://isohedral.ca/swirled-series/\n// \n// by teadrinker / Martin Eklund 2020\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\n//\n\n\n\n#define pi 3.141592653589793\n\n\n\n// Map normal 2D space to a spiral 2D space, \n// cornerSize = pi/4 should be most correct for animating a spiral\n// (derivative of output x, along the center-line of the spiral should have constant magnitude)\n//\n// however, to align with checkerboard, we need to use cornerSize = 1.0\n//\n//   (0,0) of input space is the center of the spiral (or (0.5,0) if judged by centerpoint)\n//\n//   output x: distance to center along the spiral (space can be warped, depending on cornerSize)\n//   output y: orthogonal to x (0 to 1, for corners 0 to sqrt(2))\n\nvec2 spiral_square_gradient(vec2 U, float cornerSize) { \n\n    vec2 floorU = floor(U);\n    ivec2 i = ivec2(floorU);\n    vec2 fractU = U - floorU;\n    float x = fractU.x;\n    float y = fractU.y;\n\n    if(i.x == 0 && i.y == 0) \n        return vec2(cornerSize * atan(y, x) * 2. / pi, length(fractU));\n\n    int rad = max(abs(i.x), abs(i.y));\n    int prevRad = rad - 1;\n    float spiralDist = max(0., float(4 * prevRad * prevRad));  // straight segments\n    spiralDist += float(prevRad * 4 + 1) * cornerSize;         // corners\n\n    if(i.x == -rad && i.y == rad - 1) \n        return vec2(spiralDist + cornerSize * atan(1.-x, y) * 2. / pi, length(vec2(1.-x, y)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.x == -rad && (i.y < rad - 1 && i.y > -rad)) \n        return vec2(spiralDist + float(max(0,(rad-1)-i.y-1)) + (1.-y), 1.-x);\n    else if(rad*2 > 2)\n        spiralDist += float(rad*2 - 2);\n\n    if(i.x == -rad && i.y == -rad) \n        return vec2(spiralDist + cornerSize * atan(1.-y,1.-x) * 2. / pi, length(vec2(1.-y,1.-x)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.y == -rad && (i.x < rad && i.x > -rad)) \n        return vec2(spiralDist + float(max(0,i.x-(-rad)-1)) + x, 1.-y);\n    else\n        spiralDist += float(rad*2 - 1);\n\n    if(i.x == rad && i.y == -rad) \n        return vec2(spiralDist + cornerSize * atan(x,1.-y) * 2. / pi, length(vec2(x,1.-y)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.x == rad && (i.y < rad && i.y > -rad)) \n        return vec2(spiralDist + float(max(0,i.y-(-rad)-1)) + y, x);\n    else\n        spiralDist += float(rad*2 - 1);\n\n    if(i.x == rad && i.y == rad) \n        return vec2(spiralDist + cornerSize * atan(y,x) * 2. / pi, length(vec2(y,x)));\n    else\n        spiralDist += cornerSize;\n\n    if(i.y == rad && i.x < rad) \n        return vec2(spiralDist + float(max(0,rad-i.x-1)) + (1.-x), y);\n\n\n\treturn vec2(666., 0.); // can this happen?\n}  \n\n\n\n\n\n\nfloat smoothpowstep(float a, float b, float x, float expo)\t \n{\n\tif( x<a ) return 0.;\n\tif( x>b ) return 1.;\n\tfloat y = (x-a)/(b-a);\n\tif(y < 0.5)\n        return 0.5*pow(y*2., expo);\n\treturn 1.-0.5*pow((1.-y)*2., expo);\n}\n\nfloat smoothpowercycle(float x, float expo) {\n\tx = fract(x);\n    if(x<0.5) return smoothpowstep(0., 0.5, x, expo);\n    return 1.0 - smoothpowstep(0.5, 1.0, x, expo);\n}\n\nfloat linstep(float a, float b, float x) { \n\treturn clamp((x - a) / (b - a), 0.0, 1.0); \n}\n\n\n\n\n\n\n\nfloat anim1(float t, float spiral, float range, inout float aa)\t \n{\n    float width = 130.;\n    float anim = smoothpowstep(t*(range+width) - width, t*(range+width), spiral, 4.);\n    aa = 1.0 * (0.5 - abs(0.5 - anim));    \n    return spiral + 8. * anim;\n}\n\nfloat anim2(float t, float spiral, float range, inout float aa)\t \n{\n    t = 0.9 * (1.0 - 2.0 * abs(0.5 - t));\n    \n    float width = 130.;\n    float anim = 1. - smoothpowstep(t*(range+width) - width, t*(range+width), spiral, 6.);\n    aa = 0.4 * (0.5 - abs(0.5 - anim));\n    return spiral + 1.0 * anim;\n}\n\nfloat anim3(float t, float spiral, float range, inout float aa)\t \n{\n    aa = 0.01;  \n    float midpos = 0.5;\n    if(t>0.5)\n        midpos=0.5-0.125+0.25;\n\n    float amount =  1.0;\n    float anim = smoothpowercycle(t, 5.);\n    aa = 0.02 * (1. - 2.*abs(anim - 0.5)) * abs(spiral - midpos*range);\n    return range*midpos + (spiral-range*midpos) * (1. + amount * anim);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{  \n    O-=O; \n\n    float size = 8.;\n    \n    vec2 R = iResolution.xy,\n         U = u *= size / R.y, V;\n    \n    if (U.x > size) { O += .5; return; } // out of board\n\n    float t = fract(iTime / 3.6);\n    int it = int(floor(iTime / 3.6));\n\n    \n    float range = 56.5 + 7.5;\n    vec2 spiralSpace = spiral_square_gradient(vec2(size/2. - U.x, U.y - size/2. ), 1.);\n    float spiral = 64. - spiralSpace.x;\n\tfloat aa = 0.;\n    \n    float gray = 0.;\n    if(it%3 == 0)\n\t\tgray = anim1(t, spiral, range, aa);\n    else if(it%3 == 1)\n\t\tgray = anim2(t, spiral, range, aa);\n    else\n\t\tgray = anim3(t, spiral, range, aa);\n        \n    gray = linstep(0.5-aa, 0.5+aa, 2.*abs(0.5 - fract(gray*0.5+0.25)));\n\n    if(it%6 >= 3)\n\t\tif(spiralSpace.y > sqrt(2.) - 0.7 * smoothpowstep(0.,1.,1.-2.*abs(t-0.5), 2.))\n\t\t\tgray = 0.07; // make snake appear by adding background\n       \n   \tgray = pow(gray, 1./2.2); // gamma\n    \n    O = vec4(vec3(gray),1);\n\n    //O = vec4((spiralSpace * vec2(1./64., 1.)).yyy, 1.);\n    //O = vec4((spiralSpace * vec2(1./64., 1.)).xxx, 1.);\n    //O = vec4(spiral / 56.5,spiral / 56.5,gray,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBWX.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[749, 749, 804, 804, 2652], [2661, 2661, 2723, 2723, 2879], [2881, 2881, 2926, 2926, 3048], [3050, 3050, 3092, 3092, 3140], [3148, 3148, 3215, 3215, 3402], [3404, 3404, 3471, 3471, 3707], [3709, 3709, 3776, 3776, 4076], [4083, 4083, 4121, 4121, 5218]]}
{"id": "wddBDX", "name": "Point Light in Tunnel", "author": "milesWaugh", "description": "https://www.desmos.com/calculator/jvawk4nui5", "tags": ["tunnel", "fast", "pointlight", "realtime"], "likes": 7, "viewed": 361, "published": 3, "date": "1606167297", "time_retrieved": "2024-07-30T20:34:02.589726", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col += texture(iChannel0, uv + vec2(1. / iResolution.x, 0.))    * .5;\n    col += texture(iChannel0, uv + vec2(-1. / iResolution.x, 0.))   * .5;\n    col += texture(iChannel0, uv + vec2(0., 1. / iResolution.y))    * .5;\n    col += texture(iChannel0, uv + vec2(0., -1. / iResolution.y))   * .5;\n    col += texture(iChannel0, uv + vec2(-1., -1.) / iResolution.xy) * .25;\n    col += texture(iChannel0, uv + vec2(-1., 1.) / iResolution.xy)  * .25;\n    col += texture(iChannel0, uv + vec2(1., -1.) / iResolution.xy)  * .25;\n    col += texture(iChannel0, uv + vec2(1., 1.) / iResolution.xy)   * .25;\n    col *= .25;\n    col = col * col + (1. - col) * texture(iChannel0, uv);\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define lz sin(iTime/3.)*3.+6.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uv = normalize(vec3((fragCoord - iResolution.xy * .5) / iResolution.y, 1));\n    vec3 uv1 = uv / uv.x;\n    vec3 uv2 = uv / uv.y;\n    float rlen = min(dot(uv1, uv1), dot(uv2, uv2));\n    vec2 pos = rlen == dot(uv1, uv1) ? uv1.yz : uv2.xz;\n    pos *= .5;\n    pos.y += sign(uv.x + uv.y) * iTime * .2;\n    rlen -= lz;\n    vec3 col = vec3(pow((rlen * rlen + 1.) * .5, -15. / 22.)) * texture(iChannel0, pos).rgb;\n    fragColor = vec4(dot(uv.xy, uv.xy) < 0.01 / (lz) ? vec3(1., 1., 1.) : col, 1.);\n}", "buffer_a_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 836]]}
{"id": "wdtBDX", "name": "Distance to Polygon", "author": "oneshade", "description": "Generalization of my shader \"Distance to Triangle\" to handle arbitrary polygons.", "tags": ["2d", "sdf", "distance", "polygon"], "likes": 3, "viewed": 170, "published": 3, "date": "1606164801", "time_retrieved": "2024-07-30T20:34:03.474361", "image_code": "/*\nMy shader \"Distance to Triangle\" (https://www.shadertoy.com/view/wdtfWX)\ngeneralized to handle arbitrary polygons.\n\nIn case you are interested, the tutorial about raycasting that I followed\nis here: http://philliplemons.com/posts/ray-casting-algorithm\n*/\n\nconst vec3 outsideColor = vec3(1.0, 0.0, 0.0);\nconst vec3 insideColor = vec3(0.0, 0.0, 1.0);\nconst vec3 boundColor = vec3(0.0, 1.0, 0.0);\n\nconst int POLY_VERTS = 6;\n\nfloat sdPolygon(in vec2 p, in vec2[POLY_VERTS] poly) {\n    float d = 1000000.0;\n    float s = 1.0;\n\n    for (int v=1; v < poly.length() + 1; v++) {\n        vec2 a = poly[v - 1], b = poly[int(mod(float(v), float(poly.length())))];\n\n        vec2 pa = p - a, ba = b - a;\n        vec2 e = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        d = min(d, dot(e, e));\n\n        if (a.y > b.y) {\n            vec2 tmp = a;\n            a = b; b = tmp;\n        }\n\n        if (p.y == a.y || p.y == b.y) {\n            p.y += 0.001;\n        }\n\n        if (p.y >= b.y || p.y <= a.y || p.x >= max(a.x, b.x)) {\n            continue;\n        }\n\n        if (p.x < min(a.x, b.x)) {\n            s = -s;\n            continue;\n        }\n\n        float em = 1000000.0;\n        float edx = b.x - a.x;\n        if (!(edx == 0.0)) {\n            em = (b.y - a.y) / edx;\n        }\n\n        float pm = 1000000.0;\n        float pdx = p.x - a.x;\n        if (!(pdx == 0.0)) {\n            pm = (p.y - a.y) / pdx;\n        }\n\n        if (pm >= em) {\n            s = -s;\n        }\n    }\n\n    return sqrt(d) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float t1 = 0.5 * iTime, t2 = 1.25 * iTime, t3 = 1.5 * iTime;\n    float c1 = 0.4 * cos(t1), s1 = 0.4 * sin(t1);\n    float c2 = 0.4 * cos(t2), s2 = 0.4 * sin(t2);\n    float c3 = 0.4 * cos(t3), s3 = 0.4 * sin(t3);\n\n    vec2[] polygon = vec2[POLY_VERTS](vec2(c1, s2),\n                                      vec2(-s3, c1),\n                                      vec2(c2, s3),\n                                      vec2(s3, -c3),\n                                      vec2(c3, -c2),\n                                      vec2(s1, c2));\n\n    float d = sdPolygon(uv, polygon);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "wdtfWX", "name": "Distance to Triangle", "author": "oneshade", "description": "My first try at deriving the SDF for a triangle.", "tags": ["2d", "sdf", "triangle", "distance"], "likes": 5, "viewed": 806, "published": 3, "date": "1606160197", "time_retrieved": "2024-07-30T20:34:04.430804", "image_code": "/*\nHow it works:\n1. Take the minimum of the distances to the triangle edges.\n2. Calculate the barycentric coordinates of the point.\n3. If The barycentric coordinates don't add up to one, the point is outside the triangle.\n4. If the point is inside the triangle the distance needs to be flipped.\n*/\n\nconst vec3 outsideColor = vec3(1.0, 0.0, 0.0);\nconst vec3 insideColor = vec3(0.0, 0.0, 1.0);\nconst vec3 boundColor = vec3(0.0, 1.0, 0.0);\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    // Barycentric triangle areas\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    // Edge distances\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    // Combined edge distances\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n\n    // Combine with the appropriate sign (-1 if inside +1 if outside)\n    return tri * sign(max(-abp, max(-bcp, -cap)) * max(abp, max(bcp, cap)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 a = vec2(sin(iTime * 0.75), cos(iTime));\n    vec2 b = vec2(cos(iTime), sin(iTime * 1.25));\n    vec2 c = vec2(cos(iTime * 1.25), cos(iTime * 0.5));\n\n    a.y -= 0.333; b.y -= 0.333; c.y -= 0.333;\n    a *= 0.5; b *= 0.5; c *= 0.5;\n\n    float d = sdTriangle(uv, a, b, c);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 500, 500, 1277], [1279, 1279, 1334, 1334, 1976]]}
{"id": "tsdBWX", "name": "Ghost Cross of Two Cylinders", "author": "IWBTShyGuy", "description": "The shape is the intersection of two cylinders.\nThe shadow is the sum of these cylinders.", "tags": ["3d", "primitives"], "likes": 1, "viewed": 320, "published": 3, "date": "1606158746", "time_retrieved": "2024-07-30T20:34:05.365305", "image_code": "// basically anti-aliasing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 du = vec2(1.0, 0.0) / iResolution.xy;\n    vec2 dv = vec2(0.0, 1.0) / iResolution.xy;\n    float alpha = 1.5;\n\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv + du + dv).xyz;\n    col += texture(iChannel0, uv + du).xyz;\n    col += texture(iChannel0, uv + du - dv).xyz;\n    col += texture(iChannel0, uv + dv).xyz;\n    col += texture(iChannel0, uv - dv).xyz;\n    col += texture(iChannel0, uv - du + dv).xyz;\n    col += texture(iChannel0, uv - du).xyz;\n    col += texture(iChannel0, uv - du - dv).xyz;\n    col += texture(iChannel0, uv + 2.0 * du).xyz;\n    col += texture(iChannel0, uv - 2.0 * du).xyz;\n    col += texture(iChannel0, uv + 2.0 * dv).xyz;\n    col += texture(iChannel0, uv - 2.0 * dv).xyz;\n    col /= 12.0;\n    col = 1.0 - vec3(\n        \tpow(1.0 - col.x, alpha),\n        \tpow(1.0 - col.y, alpha),\n        \tpow(1.0 - col.z, alpha)\n    );\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592653;\n\n// ----------------------- Light ----------------------- //\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float angle;\n};\n\nSpotLight new_light(vec3 position, vec3 direction, float angle) {\n    SpotLight light;\n    light.position = position;\n    light.direction = direction;\n    light.angle = angle;\n    return light;\n}\n\n// ----------------------- Camera ----------------------- //\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nCamera new_camera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nvec3 camera_ray(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  \n}\n\n// ----------------------- Basic Math ----------------------- //\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n// determinant of a 3x3 matrix\nfloat det(in mat3 a) {\n    return a[0][0] * a[1][1] * a[2][2]\n        + a[0][1] * a[1][2] * a[2][0]\n        + a[0][2] * a[1][0] * a[2][1]\n        - a[0][1] * a[1][0] * a[2][2]\n        - a[0][2] * a[1][1] * a[2][0]\n        - a[0][0] * a[1][2] * a[2][1];\n}\n\n// Solves the equation Ax = b.\nvec3 solve(in mat3 a, in vec3 b) {\n    return vec3(\n        det(mat3(b, a[1], a[2])),\n        det(mat3(a[0], b, a[2])),\n        det(mat3(a[0], a[1], b))\n    ) / det(a);\n}\n\n// the square of the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    vec3 a = point - origin;\n    vec3 h = a - dot(a, direction) * direction;\n    return dot(h, h);\n}\n\n// the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    return sqrt(distance2_point_line(point, origin, direction));\n}\n\n// ------------------- good old Phong model ------------------- //\nfloat phong_ambient() {\n    return 1.0;\n}\n\nfloat phong_diffuse(vec3 position, vec3 normal, SpotLight light) {\n    vec3 dir = normalize(light.position - position);\n    return dot(dir, normal);\n}\n\nfloat phong_specular(vec3 position, vec3 normal, SpotLight light, Camera camera, float alpha) {\n    vec3 light_dir = normalize(light.position - position);\n    if (dot(light_dir, normal) < 0.0) return 0.0;\n    vec3 camera_dir = normalize(camera.position - position);\n    vec3 reflect_dir = reflect(-light_dir, normal);\n    float cos_alpha = clamp(dot(camera_dir, reflect_dir), 0.0, 1.0);\n    return pow(cos_alpha, alpha);\n}\n\nvec3 phong_vector(\n    vec3 position,\n    vec3 normal,\n    SpotLight light,\n    Camera camera,\n    float specular_alpha\n) {\n    return vec3(\n        phong_ambient(),\n        phong_diffuse(position, normal, light),\n        phong_specular(position, normal, light, camera, specular_alpha)\n    );\n}\n", "buffer_a_code": "// Copyright  2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst vec3 CYLINDER_COLOR = vec3(220.0, 214.0, 231.0) / 255.0;\nconst vec3 CYLINDER_REFLECT_RATIO = vec3(0.2, 0.6, 0.2);\nconst vec3 FLOOR_COLOR = vec3(117.0, 109.0, 145.0) / 255.0;\n\nconst vec3 CYLINDER0_ORIGIN = vec3(0.0, 1.0, -1.0);\nconst vec3 CYLINDER0_DIRECTION = vec3(0.0, 0.0, 1.0);\nconst vec3 CYLINDER1_ORIGIN = vec3(0.0, 0.0, 0.0);\nconst vec3 CYLINDER1_DIRECTION = vec3(0.0, 1.0, 0.0);\nconst float CYLINDER_RADIUS = 0.25;\nconst float CYLINDER_HEIGHT = 2.0;\n\nconst vec3 CORE_CENTER = CYLINDER0_ORIGIN + CYLINDER_HEIGHT * CYLINDER0_DIRECTION / 2.0;\n\nconst vec3 LIGHT_POSITION = vec3(5.0, 5.0, 0.0);\nconst vec3 LIGHT_DIRECTION = normalize(CORE_CENTER - LIGHT_POSITION);\nconst float LIGHT_FOV = PI / 15.0;\n\nconst vec3 LIGHT_GAZE = LIGHT_POSITION - LIGHT_POSITION.y / LIGHT_DIRECTION.y * LIGHT_DIRECTION;\n\nconst vec3 CAMERA_DEFAULT_POSITION = vec3(4.0, 3.5, -3.25) / 1.75;\nconst vec3 CAMERA_DEFAULT_DIRECTION = normalize(LIGHT_GAZE - CAMERA_DEFAULT_POSITION);\nconst float CAMERA_FOV = PI / 4.0;\nconst vec3 CAMERA_ROT_CENTER = LIGHT_GAZE;\nconst float CAMERA_FIX_INTERVAL = 4.0; // second\nconst float CAMERA_ROT_INTERVAL = 4.0; // rad / second\nconst float CAMERA_ONE_CYCLE = CAMERA_ROT_INTERVAL + CAMERA_FIX_INTERVAL;\n\nconst float SPOTLIGHT_BOUNDARY_SHARPNESS = 200.0;\nconst float SHADOW_BOUNDARY_SHARPNESS = 200.0;\n\nstruct Cylinder {\n    vec3 origin;\n    vec3 direction; // have to be normalized\n    float radius;\n    float height;\n};\n\n// Returns positive value if a point is in a cylinde.\nfloat in_cylinder(\n    in vec3 point,\n    in Cylinder cylinder\n) {\n    float dist2 = distance2_point_line(point, cylinder.origin, cylinder.direction);\n    return cylinder.radius * cylinder.radius - dist2;\n}\n\n// Creats an orthogonal matrix whose z_axis is dir.\nmat3 create_matrix(in vec3 dir) {\n    int tmp = abs(dir[0]) < abs(dir[1]) ? 0 : 1;\n    int midx = abs(dir[tmp]) < abs(dir[2]) ? tmp : 2;\n    vec3 axis0 = vec3(0.0);\n    axis0[(midx + 1) % 3] = dir[(midx + 2) % 3];\n    axis0[(midx + 2) % 3] = -dir[(midx + 1) % 3];\n    vec3 axis1 = cross(dir, axis0);\n    return mat3(axis0, axis1, dir);\n}\n\n// Find the intersection of a ray of light with a cylinder extending infinitely around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat regular_infinite_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    out vec3 position,\n    out vec3 normal\n) {\n    vec2 p_ray = normalize(ray.xy);\n    vec2 p_org = origin.xy;\n    vec2 p_h = dot(p_ray, p_org) * p_ray - p_org;\n    float res = radius * radius - dot(p_h, p_h);\n    if (res < 0.0) {\n        return res;\n    }\n    float t = dot(p_ray, -p_org) - sqrt(res);\n    t *= 1.0 / length(ray.xy);\n    position = origin + t * ray;\n    normal = vec3(position.xy, 0.0);\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[in] height the height of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return Returns a positive value if the ray and the cylinder have a intersection.\nfloat regular_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    in float height,\n    out vec3 position,\n    out vec3 normal\n) {\n    float res = regular_infinite_cylinder_intersection(\n        origin,\n        ray,\n        radius,\n        position,\n        normal\n    );\n    if (position.z < 0.0) {\n        position = origin - origin.z / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    } else if (position.z > height) {\n        position = origin + (height - origin.z) / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    }\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in Cylinder cylinder,\n    out vec3 position,\n    out vec3 normal\n) {\n    mat3 mat = create_matrix(cylinder.direction);\n    if (abs(det(mat)) < 1.0e-3) {\n        return -1.0;\n    }\n    float res = regular_cylinder_intersection(\n        solve(mat, origin - cylinder.origin),\n        solve(mat, ray),\n        cylinder.radius,\n        cylinder.height,\n        position,\n        normal\n    );\n    position = mat * position + cylinder.origin;\n    normal = mat * normal;\n    return res;\n}\n\n// Renders the intersection of two cylinders\nfloat render_core(\n    in vec2 uv,\n    in Camera camera,\n    in SpotLight light,\n    in Cylinder cylinder[2],\n    out vec3 col\n) {\n    vec3 ray = camera_ray(camera, uv);\n    vec3 position0, normal0, position1, normal1;\n    float res0 = cylinder_intersection(camera.position, ray, cylinder[0], position0, normal0);\n    float res1 = cylinder_intersection(camera.position, ray, cylinder[1], position1, normal1);\n    float res = min(res0, res1);\n    if (res < 0.0) {\n        return res;\n    }\n    vec3 position, normal;\n    float res01 = in_cylinder(position0, cylinder[1]);\n    float res10 = in_cylinder(position1, cylinder[0]);\n    if (res01 < 0.0 && res10 < 0.0) {\n        return -1.0;\n    } else if (res01 < 0.0) {\n        position = position1;\n        normal = normal1;\n    } else if (res10 < 0.0) {\n        position = position0;\n        normal = normal0;\n    } else {\n        float depth0 = length(position0 - camera.position);\n        float depth1 = length(position1 - camera.position);\n        position = depth0 < depth1 ? position0 : position1;\n        normal = depth0 < depth1 ? normal0 : normal1;\n    }\n    vec3 phong_vector = phong_vector(position, normal, light, camera, 5.0);\n    col = CYLINDER_COLOR * dot(phong_vector, CYLINDER_REFLECT_RATIO);\n    return res;\n}\n\n// Renders the floor\nvec3 render_floor(\n    vec2 uv,\n    Camera camera,\n    SpotLight light,\n    Cylinder cylinder[2]\n) {\n    vec3 ray = camera_ray(camera, uv);\n    float t = -camera.position.y / ray.y;\n    vec3 pt = camera.position + t * ray;\n    vec3 light_dir = normalize(pt - light.position); \n    float sub0 = cos(light.angle) - dot(light_dir, light.direction);\n    if (sub0 > 0.0) {\n        sub0 = clamp(1.0 - SPOTLIGHT_BOUNDARY_SHARPNESS * sub0, 0.0, 1.0);\n        return FLOOR_COLOR * sub0 * (-light_dir.y);\n    }\n    float sub1 = -10.0;\n    for (int i = 0; i < 2; i++) {\n        vec3 _position, _normal;\n        float tmp = cylinder_intersection(\n            light.position,\n            light_dir,\n            cylinder[i],\n            _position,\n            _normal\n        );\n        sub1 = max(sub1, tmp);\n    }\n    if (sub1 > -0.01) {\n        sub1 = clamp(1.0 - SHADOW_BOUNDARY_SHARPNESS * sub1, 0.0, 1.0);\n        return FLOOR_COLOR * sub1 * (-light_dir.y);\n    }\n    return FLOOR_COLOR * (-light_dir.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time0 = CAMERA_FIX_INTERVAL / CAMERA_ONE_CYCLE;\n    float time = clamp(fract(iTime / CAMERA_ONE_CYCLE), time0, 1.0);\n    float camera_rot_angle = 2.0 * PI * time / (1.0 - time0);\n    \n    Cylinder cylinder[2];\n    cylinder[0].origin = CYLINDER0_ORIGIN;\n    cylinder[0].direction = CYLINDER0_DIRECTION;\n    cylinder[0].radius = CYLINDER_RADIUS;\n    cylinder[0].height = CYLINDER_HEIGHT;\n    cylinder[1].origin = CYLINDER1_ORIGIN;\n    cylinder[1].direction = CYLINDER1_DIRECTION;\n    cylinder[1].radius = CYLINDER_RADIUS;\n    cylinder[1].height = CYLINDER_HEIGHT;\n    \n    mat3 camera_rot = rot(vec3(0.0, 1.0, 0.0), camera_rot_angle);\n    vec3 camera_position = CAMERA_DEFAULT_POSITION - CAMERA_ROT_CENTER;\n    camera_position = camera_rot * camera_position + CAMERA_ROT_CENTER;\n    Camera camera = new_camera(\n        camera_position,\n        camera_rot * CAMERA_DEFAULT_DIRECTION,\n        vec3(0.0, 1.0, 0.0),\n        CAMERA_FOV,\n        iResolution.x / iResolution.y\n    );\n\n    SpotLight light = new_light(\n        LIGHT_POSITION,\n        LIGHT_DIRECTION,\n        LIGHT_FOV\n    );\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = render_core(uv, camera, light, cylinder, col);\n    if (t > 0.0) fragColor = vec4(col, 1.0);\n    else fragColor = vec4(render_floor(uv, camera, light, cylinder), 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 82, 82, 1021]]}
{"id": "wdtBWX", "name": "coolFractals", "author": "Ya420", "description": "fractals", "tags": ["tag"], "likes": 1, "viewed": 289, "published": 3, "date": "1606157141", "time_retrieved": "2024-07-30T20:34:06.234980", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float k=iResolution.x/4.0;\n    int i;\n    vec2 xy = fragCoord.xy;\n    vec2 cxy0 = vec2((xy.x-iResolution.x/2.0)/k,(xy.y-iResolution.x/3.5)/k);\n    vec2 cxy = cxy0;\n    vec2 cxy1 = cxy;\n    cxy0[1]=(iMouse.x-iResolution.x/2.0)/iResolution.x*2.0;\n    cxy0[0]=(iMouse.y-iResolution.y/2.0)/iResolution.y*2.0;\n    xy.x=cxy1[0]*cxy1[0];\n    xy.y=cxy1[1]*cxy1[1];\n    for (i=0;i<3000 && (xy.x+xy.y<4.0);i++)\n    {\n       cxy[0]=xy.x-xy.y+cxy0[0]; \n       cxy[1]=2.0*cxy1[0]*cxy1[1]+cxy0[1];\n       cxy1=cxy;\n       xy.x=cxy1[0]*cxy1[0];\n       xy.y=cxy1[1]*cxy1[1];\n    }\n    fragColor = vec4(sin(float(i)),cos(float(i)/3.141592),sin(float(i)/3.141592),0.0);\n    //fragColor = vec4(float(xy.x+xy.y<4.0)*cos(xy.x+xy.y),cos(xy.x),sin(xy.y),1.0);   *cos(3.141592*cos(xy.x+xy.y))\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 832]]}
{"id": "wdtfDj", "name": "Elastic fluid", "author": "michael0884", "description": "Tracking the deformation gradient to model solid bodies. Yeah, no actual particles here.  Only particle distributions.\nSPACE - zoom in\nWith a 0 mu parameter the solid becomes a splashy fluid\n", "tags": ["particles", "ca"], "likes": 25, "viewed": 821, "published": 3, "date": "1606146092", "time_retrieved": "2024-07-30T20:34:07.388895", "image_code": "// Fork of \"Building smasher\" by michael0884. https://shadertoy.com/view/wdGcRK\n// 2020-11-22 17:42:31\n\n// Fork of \"Neo-Hookean Field\" by michael0884. https://shadertoy.com/view/3dVyDD\n// 2020-10-20 18:45:49\n\n// Fork of \"Neo-Hookean 2: Electric Boogaloo\" by michael0884. https://shadertoy.com/view/tsVyWR\n// 2020-10-16 17:16:16\n\n// Fork of \"CA Neo-Hookean\" by michael0884. https://shadertoy.com/view/WdGyWR\n// 2020-10-13 18:17:06\n\n//used sources \n//https://github.com/nialltl/incremental_mpm/blob/master/Assets/2.%20MLS_MPM_NeoHookean_Multithreaded/MLS_MPM_NeoHookean_Multithreaded.cs\n//https://www.seas.upenn.edu/~cffjiang/research/mpmcourse/mpmcourse.pdf\n\n// Fork of \"CA Paste\" by michael0884. https://shadertoy.com/view/tsGczh\n// 2020-10-12 21:02:54\n\n// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.35\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    vec2 c = vec2(0.);\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n    vec2 grad = vec2(0.);\n\n    float rho2 = 0.;\n    //compute the smoothed density and velocity\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n        vec2 dx0 = X0 - tpos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        grad += normalize(dx)*K;\n        c += M0*K*DECODE(data.w);\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n        vec2 dsize = destimator(dx0,  data.z);\n        float bsdf = sdBox(pos - X0,0.5*dsize);\n        //float bsdf = length(pos - X0) - 0.5*length(destimator(dx0));\n        rho2 += M0*smoothstep(0.3, -0.3, bsdf)/(dsize.x*dsize.y);\n    }\n\n   grad /= rho; \n   c /= rho;\n   vel /= rho;\n   De /= rho;\n    \n   //vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n   float d = 0.5*rho2;\n   col.xyz = mix(vec3(0.),1.0*texture(iChannel2, c).xyz, d);\n   col.xyz = 1. - col.xyz;\n    //col.xyz = vec3(rho2)*0.2;\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.0\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define velocity_averaging 0.\n\n//squishy solid\n#define relax 0.03\n#define distribution_size 1.0\n//estimation str\n#define difd 2.0\n//target density\n#define trho 0.\n//density target strenght\n#define rhoe 0.0\n\n//estimating the in-cell distribution size\nvec2 destimator(vec2 dx, float M)\n{\n    //size estimate by in-cell location\n    vec2 ds = clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n    return ds + 0.*max(M/(ds.x*ds.y) - 1.1, 0.)*dt;\n}\n\nfloat deformation_energy(mat2 D)\n{\n    D = transpose(D)*D;\n    return 2.*(D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\n\n// Lam parameters for stress-strain relationship\n#define elastic_lambda 0.6\n#define elastic_mu 0.0\n#define incompressible_viscosity 1.0\n\n\n//viscous fluid\n/*\n#define relax 0.05\n#define distribution_size 0.98\n// Lam parameters for stress-strain relationship\n#define elastic_lambda 0.2\n#define elastic_mu 0.1\n#define incompressible_viscousity 0.05\n*/ \n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return incompressible_viscosity*dot(dx,dv)*GS(0.8*dx);\n}\n\n\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 opRepLim(in vec2 p, in vec2 c, in vec2 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//Reintegration tracking\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    return float(sdBox(x, s) < 0.);\n}\n\nfloat particleArch(vec2 x, vec2 s)\n{\n    return float(opSubtraction(sdBox(x + vec2(0, s.y*0.4), s*vec2(0.5, 0.9)), sdBox(x, s)) < 0.);\n}\n\nfloat Building(vec2 x, vec2 s)\n{\n    vec2 room_s = s.y*vec2(0.12);\n    vec2 rep_s = vec2(0.15)*s.x;\n    float rooms = sdBox(opRepLim(x + vec2(0., -0.1*room_s.y), rep_s, vec2(30.0)), room_s);\n    float sd = opSubtraction(rooms, sdBox(x, s));\n    return float(sd < 0.);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    vec2 C = vec2(0.);\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = vec2(i,j);\n        vec4 data = T(pos + tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n        \n        \n        //particle distribution size\n        vec2 K = destimator(X0 - tpos , data.z);\n       \n        X0 += V0*dt; //integrate position\n\n        //box overlaps\n        vec2 aabb0 = max(X0 - K*0.5, -0.5); \n        vec2 aabb1 = min(X0 + K*0.5, 0.5); \n        vec2 size = max(aabb1 - aabb0, 0.); \n        vec2 center = 0.5*(aabb0 + aabb1);\n\n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K.x*K.y);\n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*DECODE(data.w);\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        vec4 nya = texture(iChannel2, clamp(1.8*X*vec2(0.166,1.)/R, vec2(0.),vec2(0.1666, 1.0)));\n        M = max(max(Building(X - R*vec2(0.5,0.32), R*vec2(0.4,0.3)),\n            particleBox(X - R*vec2(0.1,0.9), R*vec2(0.0))), \n                particleBox(X - R*vec2(0.5,0.12), R*vec2(0.47, 0.3)));\n        \n        C = mod(3.*pos/R, 1.);\n        X = vec2(0.);\n    }\n    \n    U = vec4(ENCODE(X), ENCODE(V), M, ENCODE(C));\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//deformation gradient advection and update\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n         vec2 tpos = vec2(i,j);\n        vec4 data = T(pos + tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n        mat2 D0 = mat2(T1(tpos + pos));\n        \n        //particle distribution size\n        vec2 K = destimator(X0 - tpos , data.z);\n       \n        X0 += V0*dt; //integrate position\n\n        //box overlaps\n        vec2 aabb0 = max(X0 - K*0.5, -0.5); \n        vec2 aabb1 = min(X0 + K*0.5, 0.5); \n        vec2 size = max(aabb1 - aabb0, 0.); \n        vec2 center = 0.5*(aabb0 + aabb1);\n\n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K.x*K.y);\n       \n        //add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n       D /= M;\n    }\n\telse D = mat2(1.0);\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    \n    if(M > 0.01) //not vacuum\n    {\n        //Compute the velocity gradient matrix\n        mat2 B = mat2(0.);\n        float a = 0.01;\n        float rho = 0.;\n        range(i, -1, 1) range(j, -1, 1)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            vec2 dv = V0 - V;\n\t\t\tvec2 dsize = clamp(destimator(X0 - tpos, data.z), 0.3, 1.0);\n            float weight = M0*GS(1.2*dx);\n            rho += M0*weight;\n            B += mat2(dv*dx.x,dv*dx.y)*weight;\n            a += weight;\n        }\n        B /= a;\n        rho /= a;\n      \n        float drho = rho - 1.0;\n        B -= 0.004*mat2(drho)*abs(drho);\n       \n        //integrate deformation gradient\n       \tD += 1.*dt*B*D;\n       \n        //smoothing\n        \n        float r = relax + 0.05*smoothstep(-30., 0., -pos.y);\n        D = D*(1. - r) + mat2(1.)*r;\n        \n        //clamp the gradient to not go insane\n        D = mat2(clamp(vec4(D), -5.0, 5.0));\n    }\n    \n    //save\n    U = vec4(D);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//velocity update\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.48, 0.48)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D)\n{\n    float J = abs(determinant(D)) + 0.001;\n\n    // MPM course, page 46\n    float volume = J;\n\n    // useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    // MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    // equation 38, MPM course\n    mat2 stress = (1./J)* P * F_T;\n\n    return volume * stress;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    mat2 D = mat2(T1(pos));\n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = clamp(data.z, 0., 2.0);\n    vec2 C = DECODE(data.w);\n    if(M>0.0) //not vacuum\n    {\n        //Compute the force\n      \n        vec2 F = vec2(0.);\n        float b = 0.;\n   \n        mat2 local_strain = strain(D);\n        if(M > 0.0)\n        {\n            range(i, -1,1) range(j, -1, 1)\n            {\n                if(!(i == 0 && j == 0))\n                {\n                    vec2 tpos = pos + vec2(i,j);\n                    vec4 data = T(tpos);\n\n                    vec2 X0 = DECODE(data.x) + tpos;\n                    vec2 V0 = DECODE(data.y);\n                    float M0 = data.z;\n                    vec2 dx = X0 - X;\n                    vec2 dv = V0 - V;\n                    mat2 D0 = mat2(T1(tpos));\n                    float weight = GS(1.2*dx);\n                   \n                    //F += M0*strain((D0*M + D*M0)/(M+M0))*dx*weight;\n                    mat2 strain0 = 0.5*(strain(D0) + local_strain) + mat2(0.6*dot(dx,dv));\n                    F += M0*strain0*dx*weight;\n                   \n                    b += weight;\n                }\n            }\n       \n            F /= b;\n \t\t\tF = clamp(F, -0.1,0.1);\n        }\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n            F += 0.02*normalize2(dx)*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += F*dt;\n        //X +=  0.*F*dt;\n        \n        vec3 BORD = bN(X);\n        V += 0.1*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        V *= 1. - 0.5*smoothstep(-30., 0., -pos.y);\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), data.z, ENCODE(C));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1169, 1169, 1196, 1196, 1374], [1402, 1402, 1430, 1430, 1490]]}
{"id": "3scfWX", "name": "mini-cuarto-giratorio", "author": "jorge2017a1", "description": "mini-cuarto", "tags": ["minicuarto"], "likes": 1, "viewed": 287, "published": 3, "date": "1606093386", "time_retrieved": "2024-07-30T20:34:08.225658", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat cilindrosconboxGrandeConPuertas(vec3 p, float numItem)\n{\n    vec3 pp;\n    p= rotate_x(p , radians(90.0));\n    p.xy *= genRotMat(iTime*0.125);/// genera la rotacion del engrane\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.5,10.0,10.0) );  \n    float sdba= sdBox(rep2-vec3(10.0,1.4,4.0), vec3(0.7,1.2,4.0) );\n    float sdbb= sdBox(rep2-vec3(10.0,-1.4,4.0), vec3(0.7,1.2,4.0) );\n    float sdbc= sdBox(rep2-vec3(10.0,1.4, -4.5), vec3(0.7,1.2,4.0) );\n    float sdbd= sdBox(rep2-vec3(10.0,-1.4,-4.5), vec3(0.7,1.2,4.0) );\n    sdb1=differenceSDF(sdb1, sdba);\n    sdb1=differenceSDF(sdb1, sdbb);\n    sdb1=differenceSDF(sdb1, sdbc);\n    sdb1=differenceSDF(sdb1, sdbd);\n    float res =  sdb1;\n \treturn  res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n  /*  float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras*/\n    \n    res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n   \n    p.y=p.y-10.0;\n  \n   \n    float ci3= cilindrosconboxGrandeConPuertas( p, 8.0);\n        \n   \n    res =opU3(res, vec3(ci3,8.0,-1.0)); \n  \n\n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    //vec3 h = normalize(v + l);\n    \n    \n    float diff = dot(normal, l);\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\n     \n\tspecular = pow( specular, shininess );\n\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,5.0+10.0*abs(sin(t)),-25.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "//modificado por jorge2017a1\n//https://www.johndcook.com/blog/2016/03/10/creating-police-siren-sounds-with-frequency-modulation/\n#define pi 3.141516\n\nfloat  sirena(float t, float f_c, float f_m, float beta)\n{\n    //# t    = time\n    //# f_c  = carrier frequency\n    //# f_m  = modulation frequency\n    //# beta = modulation index\n   // return sin(2.0*pi*f_c*t);\n    return sin(2.0*pi*f_c*t - beta*sin(2.0*f_m*pi*t)*0.00125*beta*cos(2.0*f_m*pi*t) );\n\n        \n \n}     \n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    float f_m;\n    \n    float f_c=1500.0;\n    \n    float t1=mod(time,7.0);\n    if (t1<3.5)\n    \t f_m=8.0;  \n    else\n         f_m=2.0;  \n        \n    \n    float beta=100.0;\n   \n    float tt =time;\n    float sir=  sirena(tt,  f_c,f_m,  beta);\n    return vec2(sir);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 435, 435, 456], [457, 457, 489, 489, 573], [574, 574, 620, 620, 707], [708, 708, 742, 742, 804], [805, 805, 842, 842, 937], [938, 938, 977, 977, 1072], [1073, 1073, 1112, 1112, 1207], [1208, 1208, 1247, 1247, 1342], [1344, 1388, 1435, 1435, 1462], [1464, 1464, 1507, 1507, 1534], [1536, 1536, 1584, 1584, 1612], [1613, 1684, 1718, 1718, 1816], [1817, 1817, 1851, 1851, 1943], [1944, 1944, 1978, 1978, 2070], [2071, 2111, 2145, 2145, 2242], [2275, 2275, 2301, 2301, 2355], [2357, 2357, 2391, 2391, 2564], [2567, 2595, 2636, 2636, 2729], [2732, 2732, 2794, 2794, 3490], [3493, 3533, 3558, 3558, 4277], [4279, 4279, 4365, 4365, 4947], [4953, 5004, 5028, 5028, 5216], [5217, 5280, 5313, 5313, 5774], [5776, 5830, 5866, 5866, 6100], [6101, 6156, 6236, 6236, 6513], [6567, 6567, 6660, 6660, 6769], [6774, 6823, 6880, 6880, 8075]]}
{"id": "3s3fWX", "name": "Domain warped sludge", "author": "freedmand", "description": "Adapting domain warping from iq in interesting ways with powers and other perturbations", "tags": ["noise", "texture"], "likes": 1, "viewed": 324, "published": 3, "date": "1606090463", "time_retrieved": "2024-07-30T20:34:09.094335", "image_code": "// Modified from domain warping techniques by iq\n// https://iquilezles.org/articles/warp\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nconst mat2 m2 = mat2( 0.13,  0.09, -0.3,  0.19 );\n\nconst vec2 noiseOffset = vec2(0.0, 0.0);\nconst float initialFrequency = 10.0;\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x) * sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += pow(0.500000*(0.5+0.5*noise( p )), 5.0); p = m*p*2.02;\n    f += pow(0.250000*(0.5+0.5*noise( p )), 0.2); p = m*p*2.03;\n    f += pow(0.125000*(0.5+0.5*noise( p )), 1.0); p = m2*p*2.01;\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(pow(fbm4(p), 2.0), pow(fbm4(p+vec2(7.8)), 3.0));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\nfloat onoise(vec2 v, float t) {\n  v = (v + noiseOffset) * initialFrequency;\n  vec2 o = fbm4_2( sin(t / 10.0)*v + vec2(noise(v), noise(v * 1.2)) ) * m;\n  o += 0.04*sin( vec2(0.12,0.14) + length(o));\n\n  vec2 n = fbm6_2( 3.0*(o + vec2(noise(o), noise(v * 1.2)))) + o * m2 * 5.0;\n\n  return pow(0.5 + 0.5*fbm4( 1.8*v + 6.0*n ), 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(onoise(uv, iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 296, 296, 327], [329, 329, 351, 351, 547], [549, 549, 571, 571, 807], [809, 809, 832, 832, 899], [901, 901, 924, 924, 983], [985, 985, 1016, 1016, 1315], [1317, 1317, 1374, 1424, 1595]]}
{"id": "wdtfD2", "name": "Control", "author": "liamegan", "description": "I've been playing a lot of the game Control recently and I love the blend of brutalist style and impossible structures.", "tags": ["3d", "tunnel", "control", "concrete"], "likes": 11, "viewed": 462, "published": 3, "date": "1606080873", "time_retrieved": "2024-07-30T20:34:09.843332", "image_code": "\n  // movement variables\n  vec3 movement = vec3(.0);\n  \n  const int maxIterations = 256;\n  const float stopThreshold = 0.005;\n  const float stepScale = .2;\n  const float eps = 0.002;\n  const vec3 clipColour = vec3(0.);\n  const vec3 fogColour = vec3(0.);\n  \n  const vec3 light1_position = vec3(0, 1., -1.);\n  const vec3 light1_colour = vec3(.8, .8, .85);\n  \n  struct Surface {\n    int object_id;\n    float distance;\n    vec3 position;\n    vec3 onsurface_position;\n    vec3 colour;\n    float steps;\n    float ambient;\n    float spec;\n  };\n  \n  // Distance function copyright Inigo Quilez\n  float opExtrusion( in vec3 p, in float primitive, in float h ) {\n      float d = primitive;\n      vec2 w = vec2( d, abs(p.z) - h );\n      return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n  }\n  float sdBox( in vec2 p, in vec2 b ) {\n      vec2 d = abs(p)-b;\n      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n  \n  vec3 path(float z) {\n    // return vec3(0,0,0.);\n    return vec3(sin(z * .1) * 4., sin(z * .05) * 2., z);\n  }\n  \n  float getBlock(vec3 position, inout int object_id, inout vec3 p) {\n    // position.z = fract(position.z) - .5;\n    // object_id = int(id);\n    float id = float(object_id);\n    float r = sin(id * .3 + iTime) * .5;\n    r = sin(texture(iChannel0, vec2((id)/255.), -10.).x * 2. + iTime * .5 - id) * .25;\n    float rw = texture(iChannel0, vec2((id)/255.), -10.).x - .5;\n    // // position.xy += r;\n    float s = sin(r);\n    float c = cos(r);\n    position.xy *= mat2(c, -s, s, c);\n    \n    p = position;\n    \n    float box = sdBox(position.xy, vec2(1.5 + rw, 1.)) * -1.;\n    float world = opExtrusion(position, box, .45) - .005;\n    return world;\n  }\n  \n  float world(in vec3 position, inout int object_id, inout vec3 p) {\n    \n    position.xy -= path(position.z).xy;\n    \n    float id = floor(position.z);\n    position.z = fract(position.z) - .5;\n    \n    int oid1 = int(id);\n    vec3 p1;\n    float block1 = getBlock(position, oid1, p1);\n    int oid0 = int(id-1.);\n    vec3 p0;\n    float block0 = getBlock(position + vec3(0,0,1), oid0, p0);\n    int oid2 = int(id+1.);\n    vec3 p2;\n    float block2 = getBlock(position + vec3(0,0,-1), oid2, p2);\n    \n    object_id = oid1;\n    p = p1;\n    \n    if(block2 < block1) {\n      block1 = block2;\n      object_id = oid2;\n      p = p2;\n    }\n    \n    return block1;\n  }\n  float world(in vec3 position, inout int object_id) {\n    vec3 p;\n    return world(position, object_id, p);\n  }\n  float world(in vec3 position) {\n    int dummy = 0;\n    return world(position, dummy);\n  }\n  \n  Surface getSurface(int object_id, float rayDepth, vec3 sp, float steps, vec3 onsurface_pos) {\n    return Surface(\n      object_id, \n      rayDepth, \n      sp, \n      onsurface_pos,\n      vec3(1.), \n      steps,\n      .5, \n      1000.);\n  }\n  \n  // The raymarch loop\n  Surface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float sceneDist = 1e4;\n    float rayDepth = start;\n    int object_id = 0;\n    float steps = 0.;\n    vec3 p;\n    for(int i = 0; i < maxIterations; i++) {\n      sceneDist = world(ro + rd * rayDepth, object_id, p);\n      steps++;\n      \n      if(sceneDist < stopThreshold || rayDepth > end) {\n        break;\n      }\n      \n      rayDepth += sceneDist * stepScale;\n    }\n    \n    return getSurface(object_id, rayDepth, ro + rd * rayDepth, steps, p);\n  }\n  \n  // Calculated the normal of any given point in space. Intended to be cast from the point of a surface\n  vec3 calculate_normal(in vec3 position) {\n    vec3 grad = vec3(\n      world(vec3(position.x + eps, position.y, position.z)) - world(vec3(position.x - eps, position.y, position.z)),\n      world(vec3(position.x, position.y + eps, position.z)) - world(vec3(position.x, position.y - eps, position.z)),\n      world(vec3(position.x, position.y, position.z + eps)) - world(vec3(position.x, position.y, position.z - eps))\n    );\n    \n    return normalize(grad);\n  }\n  \n  vec3 lighting(Surface surface_object, vec3 cam) {\n    \n    // start with black\n    vec3 sceneColour = vec3(0);\n    \n    // Surface normal\n    vec3 normal = calculate_normal(surface_object.position);\n    normal += smoothstep(.02, 0., abs(sin(surface_object.onsurface_position.x * 4.))) * .5;\n    normal += smoothstep(.01, 0., abs(sin(surface_object.onsurface_position.y * 2.))) * .5;\n    \n    // Light position\n    vec3 lp = cam;\n    // Light direction\n    vec3 ld = lp - surface_object.position;\n    \n    // light attenuation\n    // For brightly lit scenes or global illumination (like sunlit), this can be limited to just normalizing the ld\n    float len = length( ld );\n    ld = normalize(ld);\n    float lightAtten = min( 1.0 / ( 0.15*len ), 1.0 );\n    lightAtten = 1.;\n    \n    // Scene values, mainly for fog\n    float sceneLength = length(cam - surface_object.position);\n    float sceneAttenuation = min( 1. / ( 0.015 * sceneLength * sceneLength ), 1. );\n    \n    // The surface's light reflection normal\n    vec3 reflection_normal = reflect(-ld, normal);\n    \n    // Ambient Occlusion\n    float ao = 1.;\n    \n    // Object surface properties\n    float diffuse = max(0., dot(normal, ld));\n    float specular = max(0., dot( reflection_normal, normalize(cam - surface_object.position) ));\n    \n    // Bringing all of the lighting components together\n    vec3 tp = surface_object.onsurface_position * 2.;\n    vec3 c = texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    tp = surface_object.onsurface_position;\n    c += texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    tp = surface_object.onsurface_position * .5;\n    c += texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    c *= .125;\n    c *=  vec3(1,.98,.90);\n    sceneColour += ( c * (diffuse + specular )) * light1_colour * lightAtten;\n    \n    // adding fog\n    sceneColour = mix( sceneColour, fogColour, 1. - sceneAttenuation );\n    \n    return sceneColour;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float t =iTime;\n    \n    // Camera and look-at\n    vec3 cam = path(t);\n    vec3 lookAt = path(t+3.);\n    \n    // Unit vectors\n    vec3 forward = normalize(lookAt - cam);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    // FOV\n    float FOV = .9;\n    \n    // Ray origin and ray direction\n    vec3 ro = cam;\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    // Ray marching\n    const float clipNear = 0.;\n    const float clipFar = 32.;\n    Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar);\n    if(objectSurface.distance > clipFar) {\n      fragColor = vec4(clipColour, 1.);\n      return;\n    }\n    \n    float ao = (objectSurface.steps*.0025);\n    ao *= ao*4.;\n    ao = clamp(1.-ao, 0., 1.);\n    vec3 sceneColour = lighting(objectSurface, cam) * ao;\n    // vec3 sceneColour = vec3(objectSurface.steps*.01);\n    \n    fragColor = vec4(sceneColour, 1.);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[542, 588, 652, 652, 780], [783, 783, 820, 820, 906], [912, 912, 932, 960, 1021], [1027, 1027, 1093, 1165, 1671], [1677, 1677, 1743, 1743, 2331], [2334, 2334, 2386, 2386, 2444], [2447, 2447, 2478, 2478, 2536], [2542, 2542, 2635, 2635, 2781], [2787, 2810, 2870, 2870, 3324], [3330, 3434, 3475, 3475, 3891], [3897, 3897, 3946, 3975, 5930], [5933, 5933, 5990, 5990, 7049]]}
{"id": "3ddfDj", "name": "Biplanar mapping - demo", "author": "iq", "description": "A quick demo for the \"biplanar\" texture mapping technique I developed recently (see here: [url]https://www.shadertoy.com/view/ws3Bzf[/url]), comparing it to triplanar.", "tags": ["3d", "triplanar", "texturing", "texturemapping", "biplanar"], "likes": 53, "viewed": 2404, "published": 3, "date": "1606077153", "time_retrieved": "2024-07-30T20:34:10.771849", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// A quick demo for the \"biplanar\" texture mapping \n// technique I developed to compare biplanar to triplanar\n// texture mapping (https://www.shadertoy.com/view/ws3Bzf):\n//\n// Video: https://www.youtube.com/watch?v=9SMtSrV3Dac\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n//----------------\n\nfloat gShowWeights;\nfloat hShowTriplanar;\n\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n    vec3 cma = vec3(0,0,0); cma[ma.x] = 1.0; \n    vec3 cme = vec3(0,0,0); cme[me.x] = 1.0;\n    x.xyz = mix( x.xyz, cma, gShowWeights );\n    y.xyz = mix( y.xyz, cme, gShowWeights );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    x.xyz = mix( x.xyz, vec3(1,0,0), gShowWeights );\n    y.xyz = mix( y.xyz, vec3(0,1,0), gShowWeights );\n    z.xyz = mix( z.xyz, vec3(0,0,1), gShowWeights );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    vec3 col = vec3(0.0);\n    vec2 tm = castRay( ro, rd );\n    if( tm.y>-0.5  )\n    {\n        const float eps = 0.001;\n\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal( pos, eps*tm.x );\n        vec3 dposdx, dposdy;\n        calcDpDxy( ro, rd, rdx, rdy, tm.x, nor, dposdx, dposdy );\n        //dposdx = dFdx(pos);\n        //dposdy = dFdy(pos);\n\n        vec3 mateD = vec3(0.0);\n\n        if( tm.y<1.5 ) // body\n        {\n            vec3 te1 =     biplanar(  iChannel0, 0.15*pos, nor, 0.15*dposdx, 0.15*dposdy ).xyz;\n            te1 *= 0.2+0.8*biplanar(  iChannel1,      pos, nor,      dposdx,      dposdy ).xyz;\n            vec3 te2 =     triplanar( iChannel0, 0.15*pos, nor, 0.15*dposdx, 0.15*dposdy ).xyz;\n            te2 *= 0.2+0.8*triplanar( iChannel1,      pos, nor,      dposdx,      dposdy ).xyz;\n            \n            vec3 te = mix( te1, te2, hShowTriplanar*smoothstep(-0.2,0.2,sin(0.5*6.283185*iTime)) );\n            te = 1.25*(sqrt(te)-0.5)+0.5;\n            te = pow(max(te,0.0),vec3(1.8));\n            mateD = 0.16*te;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        occ *= clamp(0.5+0.5*nor.y,0.0,1.0);\n        occ *= 0.5+0.5*smoothstep(0.0,2.0,pos.y);\n\n        col = vec3(20.0*mateD*occ*exp2(-0.05*tm.x*tm.x));\n    }\n\treturn col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 tot = vec3(0.0);\n\n    float time = iTime;\n\n    // animation\n    gShowWeights = smoothstep( 2.0*kTau+0.0, 2.0*kTau+1.0, time )-\n                   smoothstep( 4.0*kTau-1.0, 4.0*kTau+0.0, time ) +\n                   smoothstep( 6.0*kTau+0.0, 6.0*kTau+1.0, time ) -\n                   smoothstep( 8.0*kTau-1.0, 8.0*kTau+0.0, time );\n        \n    // camera 1\n    float ss = -cos(time*0.5);\n    float an = -1.0 + 0.5*ss;\n    vec3 ro = vec3(5.8*sin(an),1.65,5.8*cos(an));\n    ro.y = 2.5-0.9*cos(time);\n    ro = 5.8*normalize(ro);\n    vec3 ta = vec3(0.0,1.65,0.0);\n    ro.x += 0.4*smoothstep(-1.0,1.0,ss);\n    ta.x += 0.4*smoothstep(-1.0,1.0,ss);\n\n\t// camera 2\n    float zoom = smoothstep( 4.0*kTau-2.0,4.0*kTau,time) -\n                 smoothstep( 8.0*kTau-2.0,8.0*kTau,time );\n    hShowTriplanar = zoom;\n    ro = mix( ro, vec3(-2.5,3.0,0.3+0.1*sin(0.5*time)), zoom );\n    ta = mix( ta, vec3(-1.0,2.6,0.1), zoom );\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o  = vec2(m,n)/float(AA) - 0.5;\n        vec2 p  = (2.0*(fragCoord+o              )-iResolution.xy)/iResolution.y;\n        vec2 px = (2.0*(fragCoord+o+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+o+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p  = (2.0*(fragCoord              )-iResolution.xy)/iResolution.y;\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray\n        vec3 rd  = normalize( ca * vec3(p ,-3.5) );\n        vec3 rdx = normalize( ca * vec3(px,-3.5) );\n        vec3 rdy = normalize( ca * vec3(py,-3.5) );\n\n        // render\n        vec3 col = render( ro, rd, rdx, rdy);\n\n        // gain\n        col = col*4.5/(4.0+col);\n        // gamma\n        col = pow( col, vec3(0.4545) );\n \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --- helper functions ----------------------\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv = vec3(0.0,0.0,1.0);\n    vec3  uu = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n#define ZERO (min(iFrame,0))\n\nconst float kTau = 6.283185;\n\n// --- sdf stuff -------------------------------\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    p -= c;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, out vec2 pos )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    pos = cp.xy;\n    \n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n\n//--- elephant ---------------------------------------------------------\n//\n// from https://www.shadertoy.com/view/4dKGWm\n//\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float d3 = b.x - 0.35 + 0.16*smoothstep(0.0,1.0,b.y);\n\n    b = sdSegment( p, pb, pc );\n    d3 = smin( d3, b.x - 0.18, 0.1 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.06,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n}\n\nvec2 map( vec3 p )\n{\n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    vec2 res = vec2( 2.15+p.y, 0.0 );\n    \n    // elephant bounding volume\n    //float bb = length(p-vec3(1.0,-0.75,0))-2.0;\n    //if( bb>res.x )  return res;\n\n    \n    vec3 ph = p;\n    const float cc = 0.995;\n    const float ss = 0.0998745;\n    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;\n    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;\n    \n    // head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );\n    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );\n\n    // nose\n    vec2  kk;\n    vec2  b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );\n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );\n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    d2 -= 0.005;\n    \n    float d = smin(d1,d2,0.2);\n\n    // teeth\n    vec3 q = vec3( p.xy, abs(p.z) );\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );\n    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.1 );\n    }\n    \n    // eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n\n    float st = length(qh.xy-vec2(-0.31,-0.02));\n    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));\n        \n    const mat3 rot = mat3(0.8,-0.6,0.0,\n                          0.6, 0.8,0.0,\n                          0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.02 );\n    }\n   \n\n    // body\n    {\n    const float co = 0.92106099;\n    const float si = 0.38941834;\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.6,0.0), vec3(0.9,0.7,0.8) );\n\td = smin(d, d4, 0.1 );\n    }\n\n    // back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );\n    d = smin(d,d3,0.1);\n    }\n    \n    // front-left leg\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    \n    // ear\n    const float co = 0.8775825619;\n    const float si = 0.4794255386;\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    // section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    // cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 );     \n    \n    d = smin( d, d4, 0.3*max(qh.y,0.0) ); // trick -> positional smooth\n    \n    // conection hear/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );    \n    \n    res.x = min( res.x, d );\n    \n\t//------------------\n    // teeth\n    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );\n    d2 = b.x - 0.10 + 0.08*b.y;\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 1.0 );\n    }\n    \n\t//------------------\n    //eyeball\n    const mat3 rot = mat3(0.8,-0.6,0.0,\n                          0.6, 0.8,0.0,\n                          0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    // floor plane\n    res.x = smax( res.x, -2.2-p.y, 0.1 );\n          \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*eps).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        ap *= sign( dot(ap,nor) );\n        float h = hash1(float(i));\n\t\tap *= h*0.3;\n        ao += clamp( map( pos + nor*0.01 + ap ).x*1.0/h, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*(4.0+nor.y), 0.0, 1.0 );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0);\n\n    const float tmax = 10.0;\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p );\n        res = vec2(t,h.y);\n        if( abs(h.x)<0.0001 || t>tmax ) break;\n        t += h.x*0.8;\n    }\n\n    if( t>tmax ) res = vec2(-1.0);\n\n    return res;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfDj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[501, 501, 577, 577, 1836], [1838, 1838, 1915, 1915, 2268], [2270, 2270, 2335, 2335, 3629]]}
{"id": "wsdBW2", "name": "Life experiments 3: color", "author": "illus0r", "description": "Previous version https://www.shadertoy.com/view/Ws3fW2", "tags": ["life"], "likes": 1, "viewed": 521, "published": 3, "date": "1606072366", "time_retrieved": "2024-07-30T20:34:11.728293", "image_code": "// image\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n\tvec4 col;// = texture(iChannel0,uv);\n    //fragColor = col;\n    \n    for(float i=0.;i<R;i++){\n        for(float j=0.;j<R;j++){\n            vec2 ij = vec2(i,j);\n\t\t    //col += texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n\t\t    col = max(col,texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy));\n        }\n    }\n    fragColor = col*2.;\n\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//a\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    //if(rnd(uv.x+uv.y+iTime)<-.99){\n    //    fragColor=vec4(.0);\n    //    return;\n    //}\n    \n    // spawning cells\n    if(mod(float(iFrame),50000.)<=1.){\n        fragColor=vec4(0.);\n        if(abs(length((uv-.5)/iResolution.x*iResolution.xy)-.0000001)<.001){\n            fragColor=vec4(.5,.5,.5,.5);\n        }\n        return;\n    }\n\n    // find guest\n    vec2 guest_ij;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=vec4(p,v*.5+.5);\n                break;\n            }\n        }\n    }\n    \n    // no guests\n    if(!is_guest_found){\n        vec2 ij=vec2(1.,1.);\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.&&rnd(uv.x+uv.y+iTime)>BIRTH_P){\n            fragColor = vec4(.5);\n            return;\n        }\n        \n        fragColor = vec4(0.);\n        return;\n    }\n\n    \n    \n    //  ,    \n    for(float i=guest_ij.x-R;i<=guest_ij.x+R;i++){\n        for(float j=guest_ij.y-R;j<=guest_ij.y+R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 8.;\n            \t//f+=normalize(fragColor.rg-p)/dist*dist;\n            \tf+=normalize(fragColor.rg-p)*(target_dist-dist)*.5;\n            }\n        }\n    }\n    \n    if(length(fragColor)>0.){\n        p = fragColor.rg;\n        v = fragColor.ba*2.-1.;\n        p=fract(p+v);\n        v*=.4;\n        //v.x+=.1*(snoise(uv*4.));\n        //v.y+=.1*(snoise(uv*4.+99.+iTime/2.));\n        v += f*.1;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        fragColor.rg = p;\n        fragColor.ba = v*.5+.5;\n        //fragColor.b = .5;\n        //fragColor.a = 1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//b\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    \n    //   .\n    if(iFrame<100 || mod(float(iFrame),500.)<=1.){\n        fragColor = texture(iChannel2,uv);\n        return;\n    }\n    \n    //          \n    vec2 guest_ij, v, p;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=texture(iChannel1, uv_n);\n                break;\n            }\n        }\n    }\n    \n    //  \n    //   ,     , \n    //   .\n    \n    //  \n    if(!is_guest_found){\n        vec2 ij=vec2(1.,1.);\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.){\n            fragColor = texture(iChannel1, uv_n);\n            return;\n        }\n        \n        //fragColor = vec4(0.);\n        //return;\n    }\n    \n    //  \n    \n    //for(float i=0.;i<R/2.;i++){\n    //    for(float j=0.;j<R/2.;j++){\n    //        vec2 ij = vec2(i,j);\n\t//\t    col += texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n    //    }\n    //}\n    //fragColor = max(col,texture(iChannel1,uv)*.95);\n\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// common\n#define R 4.\n#define max_speed 1.\n#define BIRTH_P .9\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 59, 59, 440]]}
{"id": "tdtBDj", "name": "checkerboard animation 8", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 6, "viewed": 306, "published": 3, "date": "1606067236", "time_retrieved": "2024-07-30T20:34:12.578020", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)    mod( floor(x), 2. )\n#define Bs(x)   smoothstep( 3./R.y, -3./R.y, abs(fract(x/2.-.25)-.5) -.25 ) // antialiased version of B\n#define xor(a,b) a+b - 2.*a*b\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float T = fract(iTime/2.), t = ease( T ), f,v,\n          n = B(iTime/2.);\n\n    U = mod( floor(U), 2. );\n    f = xor(U.x,U.y);                                   // checker cell color\n\n    if ( f > .5 ) t = 1.-t;\n    if ( n > 0. ) f = 1.-f;                             // phase2 : swap colors \n\n    U = fract(u) - .5;                                  // cross-open cells \n    int i = int( abs(U.x) < abs(U.y) );\n    u[i] += 1.1 *t * sign(U[i]) * ( .5 - abs(U[1-i]) );\n    U = Bs(u);  \n    v = xor(U.x,U.y);\n    O += xor(f,v);                                      // checker cell color XOR cross\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [422, 422, 460, 460, 1203]]}
{"id": "wddBzS", "name": "Lemarchand's Box", "author": "dean_the_coder", "description": "...from the Hellraiser series.\nA few firsts for me - Bump mapping, blood(!), and a different camera system. Quite happy, but would like to have added electricity arcs. Alas I'm hitting Shadertoy's 'Max 5 second' compile time rule...\nEnjoy!", "tags": ["3d", "raymarching", "horror", "movie", "cineshader", "pinhead"], "likes": 26, "viewed": 12877, "published": 3, "date": "1606065014", "time_retrieved": "2024-07-30T20:34:13.340980", "image_code": "// Lemarchand's Box\n//\n// ...from the Hellraiser series.\n// A few firsts for me - Bump mapping, blood(!), and a different camera system.\n// Quite happy, but would like to have added electricity arcs. Alas I'm hitting\n// Shadertoy's 'Max 5 second' compile time rule...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 50.\n#define MAX_STEPS\t\t72.\n#define SHADOW_STEPS\t 30.\n#define MAX_SHADOW_DIST  18.\n\nfloat lift, hatch, circRot, chain;\n\n#define AA  // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tvec4 po;\n\tfloat spe; // 0: None, 30.0: Shiny\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(rndRange.x, rndRange.y, n * n * (3. - 2. * n));\n}\n\nfloat istep(float a, float b) { return 1. - step(a, b); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n\treturn mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.));\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rot(vec3 p, vec3 ax, float a) {\n\t// Thanks Blackle.\n\treturn mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdUBox(vec3 p) { return sdBox(p, vec3(1)); }\n\nfloat sdCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tconst vec3 r = vec3(0, 1, 0);\n\tvec3 forward = normalize(r - ro),\n\t\t right = normalize(cross(r, forward)),\n\t\t up = cross(forward, right);\n\treturn normalize(forward + right * uv.x + up * uv.y);\n}\n\nfloat sdFan(vec3 p) {\n\tfloat d = 1e7;\n\tmat2 m = rot(.785);\n\tfor (int i = 0; i < 4; i++)\n\t\td = min(d, sdBox(p, vec3(.2 * length(p.xz), 2, 2))), p.xz *= m;\n\n\treturn d;\n}\n\nfloat hole(vec3 p) {\n\treturn sdBox(rot(p, vec3(0, 1, 0), .78), vec3(.35, 10, .35));\n}\n\n// Outline square.\nfloat sq(vec2 p, float r1, float r2) {\n\tfloat mp = max2(p);\n\treturn step(r1, mp) - step(r2, mp);\n}\n\n// Outline circle.\nfloat circ(vec2 p, float r1, float r2) {\n\tfloat d = length(p);\n\treturn istep(r1, d) * step(r2, d);\n}\n\nvec3 tex(vec4 po) {\n\tif (po.w == 0.) // Ground.\n\t\treturn po.rgb;\n\n\tif (sdUBox(po.xyz) < 0.) // Inside cube (Wood)\n\t\treturn mix(vec3(.035, .02, .01), vec3(.025, .015, .01), n11(n31(po.xyz * vec3(3, 1, 3)) * 30.));\n\n\t// On cube surface.\n\tconst vec2 e = vec2(1, -1) * .00001;\n\tvec3 n = normalize(e.xyy * sdUBox(po.xyz + e.xyy) +\n\t\t\t \t\t   e.yyx * sdUBox(po.xyz + e.yyx) +\n\t\t\t\t\t   e.yxy * sdUBox(po.xyz + e.yxy) +\n\t\t\t\t\t   e.xxx * sdUBox(po.xyz + e.xxx));\n\n\tfloat c = 0., patt = step(.25, n31(po.xyz * 42.5) * 2.2 * n31(po.xyz * 10.6));\n\tvec2 p;\n\tif (abs(n.x) > .001) {\n\t\tp = abs(po.zy);\n\n\t\t// Decoration lines.\n\t\tc = istep(.015, abs(abs(po.z + .05 * sign(po.y)) - .04)) +\n\t\t\tistep(.015, abs(p.y - .04));\n\n\t\tp = abs(po.zy * rot(.785));\n\t\tc += istep(.015, abs(p.x - .04)) + istep(.015, abs(p.y - .04));\n\t\tfloat d = step(0., p.x - .02) * step(0., p.y - .02);\n\n\t\t// Decoration squares.\n\t\tp = abs(abs(po.zy) - 1.);\n\t\tc += sq(p, .5, .53) + sq(p, .56, .59);\n\t\tc *= d;\n\n\t\t// Circle outlines.\n\t\tp = abs(po.zy);\n\t\tfloat cc = length(abs(p - .45) - .45);\n\t\tc += istep(.3, cc) * step(.27, cc);\n\n\t\t// Inner outline.\n\t\tc *= istep(.8, max2(p));\n\t\tc += sq(p, .8, .83);\n\n\t\tc *= step(.27, cc); // Cut-outs.\n\n\t\tc += istep(.22, cc) + // Circles.\n\t\t\t step(.88, max2(p)); // Outer square.\n\t} else if (abs(n.z) > .001) {\n\t\t// Inner square.\n\t\tp = abs(po.xy * rot(.785));\n\t\tc = istep(.63, max2(p));\n\n\t\t// Corner circle segments.\n\t\tc += circ(abs(abs(po.xy) - .83), .55, .4);\n\n\t\t// Spiky circle.\n\t\tp = abs(po.xy);\n\t\tc *= step(.24, length(p)) *\n\t\t\t step(.42 * pow(abs(sin(1.57 + atan(po.y, po.x) * 4.)), 10.), length(p));\n\n\t\t// Outer square.\n\t\tc += step(.88, max2(p));\n\t} else {\n\t\t// Surface pattern.\n\t\tc += step(.3, ((n31(po.xyz * 47.5) + n31(po.xyz * 30.)) * n31(po.xyz * 7.5)) / 2.);\n\n\t\t// Outer square.\n\t\tc += step(.92, max2(abs(po.xz)));\n\n\t\t// Radial lines.\n\t\tc += circ(abs(po.xz), .62, .56);\n\t\tp = vec2(1) * rot(sin(atan(po.z, po.x) * 16. + 4.5));\n\t\tc *= step(.3, p.x - .1);\n\t\tc += istep(.3, abs(p.x - .1));\n\n\t\t// Cut-out circle.\n\t\tc *= step(.56, length(po.xz));\n\n\t\t// Circle (and pattern).\n\t\tp = po.xz * rot(circRot * 1.57);\n\t\tc += istep(.5, length(po.xz)) *\n\t\t\t 1. - (istep(.12 - hatch, mod(atan(p.x, p.y) + 1.57, 1.57)) * step(.01, mod(clamp(length(p) + .12, .32, .6), .04)));\n\n\t\tp = abs(po.xz);\n\t\tpatt = 1.;\n\t}\n\n\t// Outer square.\n\tc *= istep(.98, max2(p));\n\n\treturn mix(\n\t\tvec3(.018, .011, .005),\n\t\tmix(mix(vec3(.13, .09, .002), vec3(.3, .23, .006), n31(po.xyz * 58.6)), vec3(.19, .16, .08), n31(po.xyz * 50.)),\n\t\tmin(c, patt));\n}\n\nHit topBox(vec3 p) {\n\tp.y -= min(sin(lift * 3.141) * 6., 2.);\n\tp.xz *= rot(max(0., smoothstep(0., 3., ((lift - .1) * 6.)) * 3.141 / 4.));\n\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .5, 1.); // Central circle.\n\n\tvec3 pp = p;\n\tpp.y -= .99;\n\tpp.xz = abs(pp.xz);\n\tpp -= vec3(.25, 0, .25);\n\tpp = rot(pp, normalize(vec3(-1, 0, 1)), hatch * 2.);\n\tfloat l = max(sdBox(pp, vec3(.26, .01, .26)), length(p.xz) - .5), // Lid.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 1), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = max(min(max(b, sdFan(p)), c), -ho);\n\th.d = min(h.d, l);\n\n\treturn h;\n}\n\nHit botBox(vec3 p) {\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .45, .95), // Central circle.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 2), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = min(c, max(max(b, -sdFan(p)), .5 - length(p.xz)));\n\n\treturn h;\n}\n\nfloat flrPat(vec3 p) {\n\tp.x = mod(p.x, 1.) - .5;\n\tp.y += .06;\n\treturn length(p.xy) - .1 * abs(sin(p.z * 3.141));\n}\n\nHit flr(vec3 p) {\n\tp.y += 1.04;\n\n\tfloat splat = n31(p * 30.12);\n\tvec3 rgb = mix(mix(vec3(mix(.13, .17, n31(p * 8.28))), vec3(.11, .12, .13), splat), vec3(.125, .002, .002) * splat, splat * .3 + smoothstep(.6, .8, n31(p * .46)));\n\n\tp.xz *= rot(.3);\n\treturn Hit(min(p.y, min(flrPat(p), flrPat(p.zyx + vec3(0, 0, .5)))), vec4(rgb, 0), 10.);\n}\n\nfloat chn(vec3 p, float i) {\n\tp.xy *= rot(.3);\n\tp.y += i * 2. - chain;\n\tfloat oy = p.y;\n\tconst vec3 s = vec3(.075, .15, .015);\n\tvec3 s2 = vec3(s.xy, 1.015),\n\t\tp2 = p.zyx;\n\n\tp.y = mod(oy, .45) - .225;\n\tp2.y = mod(oy - .225, .45) - .225;\n\n\treturn max(min(max(sdBox(p, s), -sdBox(p, s2)), max(sdBox(p2, s), -sdBox(p2, s2))) - .02, oy);\n}\n\nHit chains(vec3 p) {\n\tconst vec2 u = vec2(1, -1);\n\treturn Hit(min(min(min(chn(p, 0.), chn(p * u.yxx, 1.)), chn(p.zyx, 2.)), chn(p.zyx * u.yxx, 3.)),\n\t\t\t   vec4(.04, .03, .03, 0),\n\t\t\t   50.);\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\treturn minH(minH(minH(topBox(p), botBox(p)), flr(p)), chains(p));\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst float sceneAdjust = .25;\n\tconst float h = .0001 * sceneAdjust;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e*map(p+e*h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nconst vec3 sunPos = vec3(8, 3, -8);\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\n\tfloat sha = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + rd * t).d;\n\t\tsha = min(sha, 15. * h / t);\n\t\tt += h;\n\t\tif (sha < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(sha, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 sunCol = vec3(2, 1.6, 1.4);\n\tvec3 sunDir = normalize(sunPos - p),\n\t\t n = calcNormal(p);\n\n\tfloat u = tex(h.po + vec2(.02, 0).xyyy).r,\n\t\t  r = tex(h.po + vec2(.02, 0).yxyy).r;\n\tvec3 c = tex(h.po);\n\tn = normalize(vec3(c.r - r, c.r - u, 0) * .2 + n);\n\tfloat ao = dot(vec2(ao(p, n, .5), ao(p, n, 2.)), vec2(.3, .5)),\n\n\t// Primary light.\n\tpri = max(0., dot(sunDir, n)),\n\n\t// Secondary(/bounce) light.\n\tbounce = max(0., dot(sunDir * vec2(-1, 0).xyx, n)) * .3,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), h.spe)) * h.spe / 10.,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\n\t// Fog\n\tfog = exp(-length(p) * .14);\n\n\t// Combine.\n\treturn mix(((pri * mix(.4, 1., calcShadow(p, sunPos)) + bounce) * ao + spe) * sunCol * c, vec3(.01), fre) * fog;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST * d || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (d > MAX_DIST)\n\t\treturn vec3(0); // Distance limit reached - Stop.\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tlift = hatch = circRot = chain = 0.;\n\n\t// Camera.\n\tfloat time = mod(iTime, 45.),\n\t\t  t = min(min(min(time, abs(time - 8.)), abs(time - 12.)), abs(time - 36.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tvec3 cam;\n\n\tif (time < 8.) {\n\t\tcam = mix(vec3(.5, .5, 18.75), vec3(-.5, 0, 3.75), remap(time, 0., 8., 0., 1.));\n\t}\n\telse if (time < 12.) {\n\t\tcam = mix(vec3(0, 0, 5.6), vec3(-.5, .05, 5.6), remap(time, 8., 12., 0., 1.));\n\t}\n\telse if (time < 36.) {\n\t\tcam = mix(vec3(.12, .7, 3.67), vec3(.12, .7, 5), remap(time, 15., 30., 0., 1.));\n\t\tcircRot = smoothstep(0., 1., remap(time, 22., 24., 0., 1.)) - smoothstep(0., 1., remap(time, 13., 15., 0., 1.));\n\t\tlift = remap(time, 16., 21., 0., 1.) - remap(time, 25., 30., 0., 1.);\n\t\thatch = remap(time, 31., 34., 0., .98);\n\t} else {\n\t\thatch = 1.;\n\t\tchain = (time - 36.) * 4.;\n\t\tcam = mix(vec3(.02, .98, 5.78), vec3(.02, 1, 2.56), smoothstep(0., 1., remap(time, 36., 37., 0., 1.)));\n\t\tcam.z -= remap(time, 40., 41., 0., 1.2);\n\t\tdim = remap(time, 40.5, 41., 1., 0.);\n\t}\n\n\tvec3 ro = vec3(0, 0, -cam.z);\n\tro.yz *= rot(cam.y * -1.4);\n\tro.xz *= rot(cam.x * -3.141);\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.4545)), fragCoord), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[864, 920, 939, 939, 1193], [1195, 1195, 1215, 1215, 1388], [1390, 1390, 1421, 1421, 1447], [1449, 1449, 1469, 1469, 1493], [1495, 1495, 1519, 1519, 1558], [1560, 1560, 1628, 1628, 1695], [1697, 1697, 1716, 1716, 1776], [1778, 1778, 1814, 1834, 1901], [1903, 1903, 1932, 1932, 2016], [2018, 2018, 2040, 2040, 2068], [2070, 2070, 2114, 2114, 2216], [2218, 2218, 2252, 2252, 2447], [2449, 2449, 2470, 2470, 2616], [2618, 2618, 2638, 2638, 2703], [2705, 2724, 2762, 2762, 2822], [2824, 2843, 2883, 2883, 2943], [2945, 2945, 2964, 2964, 5451], [5453, 5453, 5473, 5473, 6045], [6047, 6047, 6067, 6067, 6313], [6315, 6315, 6337, 6337, 6429], [6431, 6431, 6448, 6448, 6770], [6772, 6772, 6800, 6800, 7106], [7108, 7108, 7128, 7128, 7300], [7302, 7340, 7357, 7357, 7426], [7428, 7428, 7453, 7453, 7717], [7756, 7756, 7797, 7812, 8074], [8076, 8104, 8139, 8139, 8171], [8259, 8259, 8300, 8300, 8426], [8428, 8428, 8472, 8472, 9269], [9271, 9271, 9301, 9315, 9649]]}
{"id": "tddfWj", "name": "checkerboard animation 7", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 4, "viewed": 323, "published": 3, "date": "1606060939", "time_retrieved": "2024-07-30T20:34:14.256533", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)  mod( floor(x), 2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float T = fract(iTime/2.), t = ease( T ), f,\n          n = B(iTime/2.);\n\n    if ( n > 0. ) U.x += 1.+t, T=0.;                    // phase 2: translate\n\n    U = B(U);  \n    \n    u = abs( fract(4.*u) *2. - 1. );                    // phase 1: fragmentation\n    f = smoothstep(  48./R.y, 0., max(u.x,u.y) - 1.+smoothstep(0.,1.,T) );\n    \n    O += U.x == U.y ? 1.-f : f;                         // checker cell color XOR fragmentation   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [286, 286, 324, 324, 908]]}
{"id": "wstfWj", "name": "driving crazy car", "author": "jorge2017a1", "description": "driving crazy car", "tags": ["drivingcrazycar"], "likes": 5, "viewed": 508, "published": 3, "date": "1606060610", "time_retrieved": "2024-07-30T20:34:15.007525", "image_code": "//---------Modificado por jorgefloresP....jorge2017a1---22/nov/2020\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n\n\n// by nothings\n// Derived fromn by Lou's Pseudo 3d page\n// http://www.gorenfeld.net/lou/pseudo/\n// and from space harrier glsl sandbox demo\n\n\n\n// hash from iq's live coded apple\nfloat hash(float n)\n{\n\treturn fract(sin(n)*43758.54);\n}\n\nfloat roadpoint(float n)\n{\n\tif (hash(n+0.5) > 0.75)\n\t\treturn 0.0;\n\tfloat z = (hash(n)-0.5)*2.2;\n\treturn sign(z) * pow(abs(z),2.0);\n}\n\n// cubic interpolator\nfloat noise(float x)\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\tfloat p0 = roadpoint(p);\n\tfloat p1 = roadpoint(p+1.0);\n\tfloat p2 = roadpoint(p+2.0);\n\tfloat p3 = roadpoint(p+3.0);\n\tfloat a = (-p0*0.5 + 1.5*p1 - 1.5*p2 + p3*0.5);\n\tfloat b = p0 - 2.5*p1 + 2.0*p2 - 0.5*p3;\n\tfloat c = 0.5*p2 - 0.5*p0;\n\tfloat d = p1;\n\treturn d + f*(c + f*(b + f*a));\n}\t\n\nfloat road_offset(float pos)\n{\n\treturn noise(pos/80.0)*10.0\n\t\t+ noise(pos/500.0)*80.0; // add some \"long-range\" curves\n}\n\nfloat road_slope(float pos)\n{\t\n\treturn (road_offset(pos+4.0) - road_offset(pos-4.0))/8.0;\t\n}\n\n\nvec2 pix(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 position = fragCoord.xy / iResolution.yy;\n\t//position = pix(position, 0.01);  //por @z0rg \n    \n    \n\tfloat y = position.y-0.62;\n\tif (position.y > 0.6) {\n\t\tfragColor = vec4(0.2, 0.6, 1.0, 1.0);\n\t\t// enable this \"return\" statement not to draw the ceiling\n\t\treturn;\n\t} \n\ty = -y;\n\n\t// y ranges from 0.02 to 0.62\n\tfloat z = 1.0 / y; // yscreen = y/z, so z = y / yscreen\n\t// z ranges from ~1.5 to 50\n\tfloat speed = 4.5;\n\tfloat dist = pow(z,0.75); // fudge this so the distance doesn't get too aliasy\n\tfloat spacing = 7.0;\n\tfloat bottom_trackpos = iTime*speed*spacing + 1.4*spacing;\n\tfloat trackpos = (dist+iTime*speed)*spacing;\n\tfloat xcenter = -iResolution.x/iResolution.y*0.5;\n\n\t// using average_slope instead of base_slope smooths the camera movement\n\tfloat averaged_slope = (road_slope(bottom_trackpos) + road_slope(bottom_trackpos - speed)) / 2.0;\n\tfloat base_slope = road_slope(bottom_trackpos);\n\tfloat slope = averaged_slope*0.75; // at 1.0 we're always looking strictly forward\n\tfloat slope_offset = (0.62-y) * slope * 8.0; // dunno why 8.0\n\n\tfloat x = (position.x + xcenter - slope_offset) * z; // xscreen = x/z, so x = xscreen * z\n\n\t// compute the road \"view vector\" based on the bottom of the screen\n\tfloat road_point = road_offset(bottom_trackpos);\n\troad_point = road_point - slope*3.5; // move inside the curves\n\troad_point = road_point  + sin(iTime*1.0)*0.05;// + 1.5*(mouse.x-0.5);\n\n\tx -= road_point;\n\t\n\t// compute the course path at the current point\n\tx += road_offset(trackpos);\n\n\tfloat xa = abs(x);\n\tfloat phase = sin(trackpos);\n\tfloat state = phase > 0.0 ? 0.0 : 1.0;\n\tfloat darken = state == 0.0 ? 1.0 : 0.5;\n    \n    \n    vec2 p=position+vec2(-0.4+x*0.0125, 0.0);\n    float sdb1=box( p-vec2(0.5,0.15), vec2(0.2,0.08)); //grande\n    float sdLlantaIzq=box( p-vec2(0.3,0.1), vec2(0.02,0.05)); \n    float sdLlantaDer=box( p-vec2(0.7,0.1), vec2(0.02,0.05)); \n    \n    float sdLineaA=box( p-vec2(0.5,0.1), vec2(0.15,0.0015)); \n    float sdLineaB=box( p-vec2(0.5,0.12), vec2(0.15,0.0015)); \n    \n    \n    float sdLucesA=box( p-vec2(0.35,0.19), vec2(0.015,0.035)); \n    float sdLucesB=box( p-vec2(0.65,0.19), vec2(0.015,0.035)); \n    \n    \n    float sdVentanaA= sdHexagon( p-vec2(0.5,0.24), 0.12 );\n    float sdVentanaB= sdHexagon( p-vec2(0.5,0.24), 0.1 );\n        \n    \n    sdb1 = SS(sdb1);\n    sdLlantaIzq= SS(sdLlantaIzq);\n    sdLlantaDer= SS(sdLlantaDer);\n    \n    sdLineaA= SS(sdLineaA);\n    sdLineaB= SS(sdLineaB);\n    \n    \n    sdLucesA= SS(sdLucesA);\n    sdLucesB= SS(sdLucesB);\n    \n    sdVentanaA= SS(sdVentanaA);\n    sdVentanaB= SS(sdVentanaB);\n    \n        \n    vec3 col =vec3 (0.0);\n    col=mix(col, vec3(1.0), sdVentanaA);\n    col=mix(col, vec3(0.0,0.0,1.0), sdVentanaB);\n    \n    col=mix(col, vec3(1.0), sdb1);\n    col=mix(col, vec3(0.0), sdLlantaIzq);\n    col=mix(col, vec3(0.0), sdLlantaDer);\n    col=mix(col, vec3(0.3), sdLineaA);\n    col=mix(col, vec3(0.3), sdLineaB);\n    \n    col=mix(col, vec3(0.8,0.8,0.5), sdLucesA);\n    col=mix(col, vec3(0.8,0.8,0.5), sdLucesB);\n    \n    \n    \n    \n    \n\tif (xa > 1.6)\n\t\tfragColor = vec4(0,1,0,1) * mix(1.0,darken * phase,y); // messing around here <<---\n\telse if (xa > 1.4) {\n\t\tfragColor = (state==0.0 ? vec4(1,0,0,1) : vec4(1,1,1,1));\n\t}\n\telse if (state==0.0 && abs(xa-0.45) < 0.05)\n\t\tfragColor = vec4(1,1,1,1);\n\telse\n\t\tfragColor = vec4(0.5,0.5,0.5,1.0);\n        \n        \n   \n   fragColor =mix(fragColor, vec4(col,1.0),sdVentanaA);\n   fragColor =mix(fragColor, vec4(col,1.0),sdVentanaB);\n    \n   fragColor =mix(fragColor, vec4(col,1.0),sdb1);\n   fragColor =mix(fragColor, vec4(col,1.0),sdLlantaIzq);\n   fragColor =mix(fragColor, vec4(col,1.0),sdLlantaDer);\n    \n    \n    fragColor =mix(fragColor, vec4(col,1.0),sdLineaA);\n    fragColor =mix(fragColor, vec4(col,1.0),sdLineaB);\n    \n    fragColor =mix(fragColor, vec4(col,1.0),sdLucesA);\n    fragColor =mix(fragColor, vec4(col,1.0),sdLucesB);\n    \n   \n    \n}\n", "image_inputs": [], "common_code": "//Referencia  BC: Straw Hat Pirates\n//\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\n\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}", "sound_code": "//modificado por jorge2017a1\n//https://www.johndcook.com/blog/2016/03/10/creating-police-siren-sounds-with-frequency-modulation/\n#define pi 3.141516\n\nfloat  sirena(float t, float f_c, float f_m, float beta)\n{\n    //# t    = time\n    //# f_c  = carrier frequency\n    //# f_m  = modulation frequency\n    //# beta = modulation index\n    return sin(2.0*pi*f_c*t - beta*sin(2.0*f_m*pi*t));\n\n        \n \n}     \n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    float f_m;\n    \n    float f_c=1500.0;\n    \n    float t1=mod(time,7.0);\n    if (t1<3.5)\n    \t f_m=8.0;  \n    else\n         f_m=2.0;  \n        \n    \n    float beta=100.0;\n   \n    float tt =time;\n    float sir=  sirena(tt,  f_c,f_m,  beta);\n    return vec2(sir);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 313, 334, 334, 368], [370, 370, 396, 396, 502], [504, 526, 548, 548, 875], [878, 878, 908, 908, 998], [1000, 1000, 1029, 1029, 1092], [1095, 1095, 1124, 1124, 1207], [1210, 1210, 1267, 1267, 5155]]}
{"id": "WstfD2", "name": "holoblobbob", "author": "Sebbert", "description": "a thing", "tags": ["2d"], "likes": 4, "viewed": 284, "published": 3, "date": "1606054039", "time_retrieved": "2024-07-30T20:34:15.889167", "image_code": "float t;\n\nvec3 gradient[] = vec3[](\n    vec3(255, 190, 11),\n    vec3(251, 86, 7),\n    vec3(255, 0, 110),\n    vec3(131, 56, 236),\n    vec3(58, 134, 255)\n);\nfloat scene(vec2 p)\n{\n    vec2 p1 = vec2(cos(-t), sin(t*3.7))*.4;\n    vec2 p2 = vec2(cos(t+2.), sin(t*1.7))*.4;\n\n    float c1 = length(p - p1)-(sin(t)*.3+.35);\n    float c2 = length(p - p2)-(sin(t*1.5)*.4+.5);\n    \n    \n    c2 = abs(c2-.01)-.01;\n    c1 = abs(c1-.01)-.01;\n\n    float m = opSmoothUnion(c1, c2, .5);\n    \n    return m;\n}\n\nfloat renderSDF(float d) {\n   return max(0.0, min(1.0, -d/fwidth(d))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    \n    t -= mod(t*2.1, 8.5);\n    t -= mod(t*.7, 1.6);\n    t -= mod(t*1.5, 1.65);\n    \n    vec2 res = iResolution.xy;\n    vec2 aspectUV = (fragCoord - res/2.) / min(res.x, res.y);\n    \n    \n    float d = scene(aspectUV);\n    float aad = renderSDF(d);\n    vec3 color = vec3( gradient[4]/255. ) * .12;\n    \n    for (int i = 0; i < gradient.length(); ++i) {\n    \tvec3 gradientColor = gradient[i % gradient.length()]/255.;\n        float dOutline = scene(aspectUV + float(i)*.08 * vec2(cos(-t), sin(t*3.9)));\n        \n\t\tdOutline = abs(dOutline-.01)-.0024;\n        \n        dOutline = sin(dOutline*2.);\n        color = mix(color, gradientColor, renderSDF(dOutline)*.8 );\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 176, 176, 489], [491, 491, 517, 517, 564], [566, 566, 623, 623, 1383]]}
{"id": "WstBW2", "name": "Procedural Stone Texture", "author": "freedmand", "description": "Some experimental noise functions for a stone texture", "tags": ["texture"], "likes": 1, "viewed": 335, "published": 3, "date": "1606024311", "time_retrieved": "2024-07-30T20:34:16.683045", "image_code": "// Some experimental noise functions for a stone texture\n\n// From https://thebookofshaders.com/13/\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat nnoise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 2\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * nnoise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat onoise(vec2 v) {\n    return fbm(v + fbm(v) * nnoise(v) * 1000.0);\n}\n\nconst float EPS = 100.0;\nfloat noise(vec2 v) {\n    return (\n        onoise(v - vec2(EPS, 0.0)) +\n        onoise(v + vec2(EPS, 0.0))\n    ) / 2.0;\n}\n\nconst float minV = 0.49;\nconst float maxV = 0.51;\n\nvec3 noiseCol(vec2 v) {\n    float noiseVal1 = (clamp(noise(v * 1.0), minV, maxV) - minV) * (1.0 / (maxV - minV));\n    float noiseVal = noiseVal1 / 3.0 + 0.66;\n    return mix(vec3(0.85, 0.8, 0.8), vec3(0.5, 0.5, 0.6), pow(noiseVal, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(noiseCol(uv * 5.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 99, 127, 127, 235], [237, 315, 343, 343, 725], [750, 750, 776, 776, 1115], [1117, 1117, 1139, 1139, 1190], [1217, 1217, 1238, 1238, 1338], [1391, 1391, 1414, 1414, 1630], [1632, 1632, 1689, 1739, 1852]]}
{"id": "WddBDj", "name": "corre por tu vida", "author": "jorge2017a1", "description": "corre por tu vida", "tags": ["correportuvida"], "likes": 3, "viewed": 250, "published": 3, "date": "1606016811", "time_retrieved": "2024-07-30T20:34:17.440021", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nbool blnObjTipoN2;\n\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\nmat3 getRotZ(float theta)\n{\n    float c=cos(theta);\n    float s=sin(theta);\n    \n    return mat3( c ,s, 0.,\n                -s, c, 0.,\n                 0.,0.,1.);\n}\n\nmat3 getRotY(float theta)\n{\n    \n    float c=cos(theta);\n    float s=sin(theta);\n    \n    \n    return  mat3(c, 0., -s,\n        \t     0.,1., 0.,\n             \t s, 0., c);\n}\n\nmat3 getRotX(float theta)\n{\n    float c=cos(theta);\n    float s=sin(theta);\n    \n    \n    return mat3(1., 0. ,0. ,\n                0., c,  s ,\n                0.,-s,  c );\n}\n\n\nmat3 getRotZInv(float theta)\n{\n    float c=cos(theta);\n    float s=sin(theta);\n    \n    return mat3( c ,-s, 0.,\n                 s, c, 0.,\n                 0.,0.,1.);\n}\n\n\n\nvec4 qMult(vec4 q1,vec4 q2){\n    return vec4(q1.x*q2.x-dot(q1.yzw,q2.yzw),\n                q1.x*q2.yzw+q2.x*q1.yzw+cross(q1.yzw,q2.yzw)); \n}\n\n\nvec3 rotate(vec3 v,float angle,vec3 axis){ \n    axis=normalize(axis);\n    vec4 p=vec4(cos(angle/2.),sin(angle/2.)*axis);\n    vec4 r=qMult(p,vec4(0.,v));\n    return qMult(r,vec4(p.x,-p.yzw)).yzw;\n}\n\n#define ROT(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\n\nfloat linearstep(float a, float b, float x)\n{\n    // Linear version of smoothstep, why is that not a thing of glsl functions yet?\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n//moving figures\nvec3 move( vec3 p, vec3 center, mat3 rot )\n{\n    vec3 q = vec3(p - center);\n    q = inverse(rot)*q;\n    return q;\n}\n\n\nvec3 EscenaN1(vec3 p)\n{   \n    vec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    vec3 q=p;\n    vec3 op=p;\n    float cx=47.0;\n    float cy=11.0;\n    float cz=35.0;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n    pp=q;\n    \n    \n    \n    //pared Cuarto\n    float sdb1= sdBox(p-vec3(0.0,8.0,0.0), vec3(35.0,25.0,1.0));\n    float sdb2= sdBox(p-vec3(0.0,8.0,0.0), vec3(5.0,8.0,1.2));\n\tfloat pared= differenceSDF(sdb1, sdb2);\n    res =opU3(res, vec3(pared,-1.0,1.0));\n   \n    \n    \n    //puerta que abre\n    mat3 MAT1;\n    float tt=mod(iTime, 10.0);\n    float ang=smoothstep(0.0,0.9, tt)*290.0/180.0;\n    mat3 mat3v1= getRotX(ang);\n    vec3 p1 = move(pp, vec3(0.0, 0.0, 0.0), mat3v1);\n    float AltoYyPos=8.0;\n    float sdb4= sdBox(p1-vec3(0.0,AltoYyPos-0.5,0.0), vec3(5.0,AltoYyPos,1.0));\n    res =opU3(res, vec3(sdb4,8.0,MATERIAL_NO)); \n    return res;\n    \n}\n    \n\n\nvec3 EscenaN2(vec3 p)\n{   \n    vec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\tvec3 q=p;\n    float cz=4.0;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    //pared Cuarto\n    float sdb1= sdBox(p-vec3(0.0,6.0,0.0), vec3(20.0,15.0,1.0));\n    float sdb2= sdBox(p-vec3(0.0,6.0,0.0), vec3(5.0,8.0,1.2));\n\tfloat pared= differenceSDF(sdb1, sdb2);\n    res =opU3(res, vec3(pared,-1.0,1.0));     \n\treturn res;    \n}   \n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    \n    vec3 Es1;\n\tif (blnObjTipoN2==false)\n    \tEs1= EscenaN1(p);\n    else\n    \tEs1= EscenaN2(p);\n    \t\n    res =opU3(res, Es1); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    //vec3 h = normalize(v + l);\n    \n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n  \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\treturn vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*4.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 5.0, -5.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 2.0, 5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \t\n     \n     blnObjTipoN2=false;\n   \tvec3 ro, rd;\n\n    float tm=mod(iTime,14.0);\n    \n    if (tm<7.0)\n \t{\n         blnObjTipoN2=false;\n         ro=vec3(0.0,5.0,t);\n         rd=normalize(vec3(uv,1.0));\n    }\n    else\n    {\t\n        blnObjTipoN2=true;\n        ro=vec3(0.0,5.0+5.0*abs(sin(tm)),10.0+tm*5.0);\n        rd=normalize(vec3(uv,1.0));\n    }\n\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 454, 454, 538], [540, 584, 631, 631, 658], [660, 660, 703, 703, 730], [732, 732, 780, 780, 808], [856, 856, 883, 883, 1020], [1022, 1022, 1049, 1049, 1193], [1195, 1195, 1222, 1222, 1368], [1371, 1371, 1401, 1401, 1539], [1543, 1543, 1571, 1571, 1683], [1686, 1686, 1728, 1728, 1882], [1939, 1939, 1984, 2068, 2117], [2119, 2136, 2180, 2180, 2251], [2254, 2254, 2277, 2277, 3130], [3138, 3138, 3161, 3161, 3564], [3570, 3610, 3635, 3635, 4101], [4106, 4106, 4192, 4192, 4692], [4698, 4749, 4773, 4773, 4961], [4962, 5025, 5058, 5058, 5519], [5521, 5575, 5611, 5611, 5845], [5847, 5847, 5927, 5927, 6204], [6205, 6256, 6303, 6303, 6843], [6897, 6897, 6990, 6990, 7269], [7274, 7323, 7380, 7380, 8826]]}
{"id": "wdcfDj", "name": "Circle Point Distance", "author": "mla", "description": "Curves of constant ratio of the distance to a point and a circle.\n\nInspired by [url]https://www.shadertoy.com/view/tstfWB[/url] by matthen\n\nUse the mouse to set the size of the circle and the position of the point on the x-axis.", "tags": ["circle", "quartic", "point", "conic"], "likes": 3, "viewed": 320, "published": 3, "date": "1605994442", "time_retrieved": "2024-07-30T20:34:18.329642", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Circle Point Distance\n// Matthew Arcus, mla, 2020\n//\n// Inspired by https://www.shadertoy.com/view/tstfWB by matthen:\n// A curve equidistant from a point and a circle is a conic section\n//\n// Here we plot the ratios of the distances from the black point and\n// the black circle - each isoline has the same colour, with the equal\n// ratio conic coloured white (the other curves are quartic).\n//\n// Use the mouse to set the size of the circle and the position of the\n// point on the x-axis.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 diagram(vec2 p, float r, float x) {\n  float pwidth = 0.02;\n  float lwidth = 0.005;\n  float xwidth = fwidth(p.x);\n  vec3 col = vec3(0.1); //1.0-vec3(1,1,0.8);\n  vec3 c = vec3(r,0,abs(r));\n  vec2 q = vec2(x,0);\n  float cdistance = circle(p,c);\n  float pdistance = point(p,q);\n  float k = 6.0*log(cdistance/pdistance);\n  float min = -20.0;\n  float max = 20.0;\n  float kwidth = length(vec2(dFdx(k),dFdy(k)));\n  k = clamp(k,min-0.5,max+0.5);\n  //float kwidth = length(vec2(dFdx(k),dFdy(k));\n  float kindex = round(k);\n  vec3 lcol = hsv2rgb(vec3((kindex-min)/(max-min),1,1));\n  if (kindex == 0.0) lcol = vec3(1); // Show ratio = 1 line as white\n  col = mix(lcol,col,smoothstep(0.0,1.5*kwidth,abs(k-kindex)));\n  col = mix(vec3(0),col,smoothstep(lwidth,lwidth+xwidth,cdistance));\n  col = mix(vec3(0),col,smoothstep(pwidth,pwidth+xwidth,pdistance));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0,0);\n  float r = tan(0.309*iTime), x = 1.5*cos(0.25*iTime);\n  if (iMouse.z > 0.0) {\n    mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    r = tan(0.5*PI*mouse.y);\n    x = mouse.x;\n  }\n  vec3 col = diagram(p,r,x);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "float PI = 3.14159265;\n\nfloat circle(vec2 p, vec3 c) {\n  return abs(distance(p,c.xy)-c.z);\n}\n\nfloat point(vec2 p, vec2 q) {\n  return circle(p,vec3(q,0));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 661, 701, 701, 1522], [1524, 1524, 1577, 1577, 1923]]}
{"id": "wsycWt", "name": "Fractal delight", "author": "Lumos", "description": "Edit of https://www.shadertoy.com/view/tsycRV", "tags": ["fractal", "snowflake", "koch", "psy", "trance"], "likes": 14, "viewed": 444, "published": 3, "date": "1605994167", "time_retrieved": "2024-07-30T20:34:19.175381", "image_code": "vec2 N(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy*(iTime/27.);\n    \n    uv *= 1.25;\n    vec3 col = vec3(0);\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.5;\n    vec2 n = N((5./6.) * 3.1415);\n    float d = dot(uv-vec2(.5, 0.), n);\n    \n    uv -= n*max(0., d)*2.;\n    \n   // col += smoothstep(.01, .0, abs(d)); // guide line\n    \n    n = N(mouse.y*(2./3.)*3.1415);\n    float scale = 1.;\n    uv.x += .5;\n    for(int i=0;i<5;++i)\n    {\n    \tuv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n    }\n\n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    col += smoothstep(1./iResolution.y, .0, d/scale);\n    float angle = iTime*0.0;\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    mat2 rotationMatrix = mat2( c, s,\n                               \t-s,  c);\n    \n    vec2 pivot = vec2( 0., 0.);\n    uv = rotationMatrix * (uv - pivot) + pivot;\n\n    uv /= scale;\n    col.r += uv.r*sin(iTime/2.)/2.;\n    col.b += uv.r*sin(iTime/3.)/2.;\n    col += texture(iChannel0, uv*2.+iTime/35.).rgb;\n    col += texture(iChannel1, uv+iTime/30.).rgb/2.2*(1.+(sin(iTime/4.)+1./2.));\n   \n    col -= 0.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 64], [66, 66, 123, 123, 1412]]}
{"id": "tdtfDS", "name": "bitwise integer patterns", "author": "frhun", "description": "effect of bitwise operators XOR, AND, OR\nand.. doing stuff with those numbers\n\nYou can control the movement direction with your mouse.\nAlso try the different output patterns that are currently commented out!", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 8, "viewed": 413, "published": 3, "date": "1605989774", "time_retrieved": "2024-07-30T20:34:20.016133", "image_code": "// Fork of \"fract ( XOR / n )\" by FabriceNeyret2. https://shadertoy.com/view/wllcRN\n// 2020-11-21 00:03:31\n\n// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U+300.*iTime*normalize(iMouse.xy+vec2(1.)));\n    \n    int r = I.x ^ I.y,\n        s = I.x & I.y,\n        t = I.x | I.y;\n    \n    /*\n    O = vec4(\n        fract(float(r*r) / floor(mod(iTime+6., 50.))),\n        fract(float(s*s) / floor(mod(iTime+6., 50.))),\n    \tfract(float(t*t) / floor(mod(iTime+6., 50.))),\n        1.0\n    );\n\t*/\n    \n    O = vec4(\n        fract(float(r*r*r) / floor(mod(iTime+6., 50.))),\n        fract(float(s*s*s) / floor(mod(iTime+6., 50.))),\n    \tfract(float(t*t*t) / floor(mod(iTime+6., 50.))),\n        1.0\n    );\n\t\n    //O = vec4(fract( float(r*s*t) / floor(mod(iTime+6., 50.)) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 258, 258, 914]]}
{"id": "td3fWj", "name": "checkerboard animation 6", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 1, "viewed": 295, "published": 3, "date": "1605984758", "time_retrieved": "2024-07-30T20:34:20.772112", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)  mod( floor(x), 2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float T = fract(iTime/2.), t = ease( T ), f,\n          n = B(iTime/2.);\n\n    if ( n > 0. ) U.x += t;\n    U = B(U);\n    f = float( U.x == U.y );                          // checker cell color\n    \n    T = cos(3.14*T);\n    O += n > 0. ? f : mix( 1.-f, f, .5-.5*sign(T)*pow(abs(T),length(u-4.)/2.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [286, 286, 324, 324, 772]]}
{"id": "3dcBD2", "name": "Reaction-Diffusion algorithm", "author": "mdb", "description": "this shader is a simulation between two chemicals\nyou can add element with the mouse\n\nhave fun ;)", "tags": ["simulation", "chaos"], "likes": 4, "viewed": 478, "published": 3, "date": "1605977653", "time_retrieved": "2024-07-30T20:34:21.532080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 v = vec3(1.,0.2,0.4);\n    float B = pow(texture(iChannel0,uv).y,2.);\n    vec4 col = vec4(B * v * 8.0,1.0);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//reaction diffusion algorithm \n//https://www.karlsims.com/rd.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    if(iFrame==0){\n        col = vec3(1.0,0.0,0.0);\n    }else{\n        vec2 r = 1.0/iResolution.xy;\n        vec2 laplacian = -texture(iChannel0,uv).xy\n            \t\t     +0.2*texture(iChannel0,uv + vec2(1.0,0.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(-1.0,0.0)*r).xy\n                         +0.2*texture(iChannel0,uv + vec2(0.0,1.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(0.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(1.0,1.0)*r).xy\n            \t         +0.05*texture(iChannel0,uv + vec2(1.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,-1.0)*r).xy;\n\n        vec2 last = texture(iChannel0,uv).xy;\n        float A = last.x;float B = last.y;\n        //make the elements react\n        A = A + (Da*laplacian.x - A*B*B + f*(1.0 - A))*t;\n        B = B + (Db*laplacian.y + A*B*B - (k + f)*B)*t;\n        \n        col = vec3(A, B, 0.0);\n    }\n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//reaction diffusion algorithm \n//https://www.karlsims.com/rd.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    if(iFrame==0){\n        col = vec3(1.0,0.0,0.0);\n    }else{\n        vec2 r = 1.0/iResolution.xy;\n        vec2 laplacian = -texture(iChannel0,uv).xy\n            \t\t     +0.2*texture(iChannel0,uv + vec2(1.0,0.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(-1.0,0.0)*r).xy\n                         +0.2*texture(iChannel0,uv + vec2(0.0,1.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(0.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(1.0,1.0)*r).xy\n            \t         +0.05*texture(iChannel0,uv + vec2(1.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,-1.0)*r).xy;\n\n        vec2 last = texture(iChannel0,uv).xy;\n        float A = last.x;float B = last.y;\n        //make the elements react\n        A = A + (Da*laplacian.x - A*B*B + f*(1.0 - A))*t;\n        B = B + (Db*laplacian.y + A*B*B - (k + f)*B)*t;\n        \n        col = vec3(A, B, 0.0);\n    }\n    fragColor = vec4(col,1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//reaction diffusion algorithm \n//https://www.karlsims.com/rd.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    if(iFrame==0){\n        col = vec3(1.0,0.0,0.0);\n    }else{\n        vec2 r = 1.0/iResolution.xy;\n        vec2 laplacian = -texture(iChannel0,uv).xy\n            \t\t     +0.2*texture(iChannel0,uv + vec2(1.0,0.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(-1.0,0.0)*r).xy\n                         +0.2*texture(iChannel0,uv + vec2(0.0,1.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(0.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(1.0,1.0)*r).xy\n            \t         +0.05*texture(iChannel0,uv + vec2(1.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,-1.0)*r).xy;\n\n        vec2 last = texture(iChannel0,uv).xy;\n        float A = last.x;float B = last.y;\n        //make the elements react\n        A = A + (Da*laplacian.x - A*B*B + f*(1.0 - A))*t;\n        B = B + (Db*laplacian.y + A*B*B - (k + f)*B)*t;\n        \n        col = vec3(A, B, 0.0);\n    }\n    fragColor = vec4(col,1.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//reaction diffusion algorithm \n//https://www.karlsims.com/rd.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    if(iFrame==0){\n        col = vec3(1.0,0.0,0.0);\n        //random element at the start\n        for(int i = 0; i<100; i++){\n            float x = fract(sin(float(i)*34.98)*456.23);\n            float y = fract(sin(float(i)*98.24)*9223.57);\n            if(distance(uv,vec2(x,y))<0.03)col.y = 1.;\n\n        }\n    }else{\n        vec2 r = 1.0/iResolution.xy;\n        vec2 laplacian = -texture(iChannel0,uv).xy\n            \t\t     +0.2*texture(iChannel0,uv + vec2(1.0,0.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(-1.0,0.0)*r).xy\n                         +0.2*texture(iChannel0,uv + vec2(0.0,1.0)*r).xy\n            \t\t\t +0.2*texture(iChannel0,uv + vec2(0.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(1.0,1.0)*r).xy\n            \t         +0.05*texture(iChannel0,uv + vec2(1.0,-1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,1.0)*r).xy\n            \t\t\t +0.05*texture(iChannel0,uv + vec2(-1.0,-1.0)*r).xy;\n\n        vec2 last = texture(iChannel0,uv).xy;\n        float A = last.x;float B = last.y;\n        //make the elements react\n        A = A + (Da*laplacian.x - A*B*B + f*(1.0 - A))*t;\n        B = B + (Db*laplacian.y + A*B*B - (k + f)*B)*t;\n        \n        col = vec3(A, B, 0.0);\n    }\n    if(distance(uv,iMouse.xy/iResolution.xy)<0.02 && iMouse.z>0.)col.y = 1.;\n    fragColor = vec4(col,1.);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//reaction diffusion algorithm \n//https://www.karlsims.com/rd.html\n\n//settings\nfloat Da = 1.0;\nfloat Db = 0.5;\nfloat f = 0.055;\nfloat k = 0.062;\nfloat t = 0.8;", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 320]]}
{"id": "Ws3BD2", "name": "checkerboard animation 5", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 7, "viewed": 313, "published": 3, "date": "1605977644", "time_retrieved": "2024-07-30T20:34:22.411728", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)  mod( floor(x), 2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y,\n         I = mod( ceil(U), 4. );\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float t = ease( fract(iTime/2.) ),\n          n = B(iTime/2.);\n  \n    if (n < 1.) {                                       // phase 1: broup blocks\n#define T(x,y)  if ( I.x < 2. ) U.x += I.y==2. ? -t : I.y==3. ? t : 0.\n        T(x,y); T(y,x);\n    }\n    else U *= exp2(t)/2.;                               // phase 2: unzoom\n    \n    U = B(U);\n    O += float( U.x != U.y );                           // checker cell color          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [286, 286, 324, 324, 936]]}
{"id": "3s3BD2", "name": "Seusenarnarnareu, a fork", "author": "UrbanClubProfessional", "description": "A remix of spolsh's \"Sunset Drive Unlimited\" (SDU). Seusenarnarnareu features harder gameplay: invisible reflected cars and hidden coins. Has graphical modifications. [url]https://www.shadertoy.com/view/wtS3W3[/url]\nPlease post your high scores!", "tags": ["3d", "raymarching", "game", "retro", "text", "remix", "glitch", "fork", "keyboard", "weird", "ui", "hard", "rave", "90", "80", "multipass", "arcade", "synthwave"], "likes": 3, "viewed": 619, "published": 3, "date": "1605976657", "time_retrieved": "2024-07-30T20:34:23.648421", "image_code": "// Hacked and cracked by Urban Club Professional!\n\n\nvec3 fxaa( vec3 color )\n{\n\t// FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.399, 0.687, 0.214);\n\tvec2 pp = 1.0 / R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.35 * (2.0/9.0)), (2.0/228.0));\n\n    float rcpDirMin = 3.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(9.0, 9.0),\n              max(vec2(-9.0, -9.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.6 * (\n        texture(iChannel0, F.xy * pp + dir * (2.0 / 4.0 - 0.6)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (3.0 / 3.0 - 0.6)).xyz);\n    vec3 rgbB = rgbA * 0.6 + 0.35 * (\n        texture(iChannel0, F.xy * pp + dir * -0.6).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.6).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0 );\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif // FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.9 + 0.3 * hash22( 2000.0 * ( F.xy / R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy / R.xy;\n    h.x *= R.x / R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.31 ) ) * 40.0, iFrameRate );\n#endif \n\n    // gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.5545 ) );\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\n// switches, enable/disable effects:\n#define REFLECTIONS // needs good gpu\n#define VOLUMETRICS // needs good gpu\n#define FXAA\n#define GRADE\n#define NOISE\n#define FORCED_RATIO\n// debug:\n#define SHOW_UI\n// #define FPS_COUNTER\n// #define DEBUG_2D\n// #define DEBUG_CAMERA\n// #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n// fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n// control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  // Arrow left\n\t 65.0,  // A\n\t 197.0  // a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, // Arrow right\n\t 68.0, // D\n     100.0 // d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n// Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n// https://www.shadertoy.com/view/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n// from Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n// math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data / pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) / log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value / pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}", "buffer_a_code": "// Hacked and cracked by Urban Club Professional!\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 4.5 * iTimeDelta;\n    \ts.playerPos.y = 22.5 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 50.0) / 500.0);\n        float timeMultiplier = mix( 0.75, 2.0, pow( s.paceScale, 1.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 5.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 1.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -1.0, step( nextPlayerCellID, 5.0 ) ); // head start\n        float nextCellCoinCol = floor( 3.0 * nextCellCoinRND );\n\n        // OBSTACLE\n        float nextCellObsRND = hash11( 100.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 3.0 ), 1.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -1.0, step( nextPlayerCellID, 7.0 ) ); // head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.0;                \n        if ( nextCellObsCol > -0.5 )\n        {\n            nextCellCoinCol -= 0.5; // pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 1.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -1.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; // pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    // COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t// cell pos\n        +vec2( 0.5, -0.5 )\t// move to cell center\n        -vec2( cellCoinCol, 0.0 ); // move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    // COIN end\n\n    // OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t// cell pos\n            +vec2( 0.5, -0.25 )\t// move to cell center\n            -vec2(cellObsCol, 0.0 ); // move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    // OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t// read keys that people usually press\n    // https://www.shadertoy.com/view/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) // splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) // game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 2e10;\nfloat g_glowCoinRefl = 2e10;\nfloat g_glowEnemy = 2e10;\nfloat g_glowEnemyRefl = 2e10;\nfloat g_glowPlayer = 2e10;\nfloat g_glowPlayerRefl = 2e10;\nfloat g_glowPlayerFront = 2e10;\nfloat g_glowPlayerLights = 2e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.30, 0.03, 0.00);\nconst vec3 GRID_COLOR_2 = vec3(3.600, 22.20, 2.40)/555.;\n\nconst vec3 SUN_DIRECTION = vec3(0.6, 0.035, 0.0);\nconst vec3 SKY_COLOR_1 = vec3(59., 76., 43.)/355.;\nconst vec3 SKY_COLOR_2 = vec3(0.30,0.03,0.00);\n\nconst vec3 SUN_COLOR_1 = vec3(0.4, 0.2, 0.4) * 0.6;\nconst vec3 SUN_COLOR_2 = vec3(0.2, 0.2, 0.2) * 0.6;\n\nconst vec3 CAR_COLOR_1 = vec3(0.6, 0.2, 0.6) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(0.0, 0.2, 0.2) * 2.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.6, 0.6, 0.2) * 0.2;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.6, 0.6, 0.2) * 2.5;\n\nconst vec3 FOG_COLOR = vec3(293.0, 223.00, 134.0)/555.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t// cell pos\n        +vec2( 0.5, -0.5 )\t\t// move to cell center\n        -vec2( coinPos.x, 0.0 ) // move to column\n    ) - 0.25; \t\t\t\t\t// radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    // game\n\tvec2 p0 = p;    \n    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t// scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t// fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t// move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t// COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t// skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 2.0, -2.0, step( mod( cellID, 5.0 ), 2.5 ) );\t// gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -2.0, step (cellID, 6.0 ) );\t\t// head start\n    float cellCoinCol = floor( 4.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n// COIN end\n\n// OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t// skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 2.0, -2.0, step( mod( cellID, 4.0 ), 2.5 ) );\n    cellObsRND = mix( cellObsRND, -2.0, step( cellID, 8.0) );\t// head start\n    float cellObsCol = floor( 4.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t// cell pos\n            +vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            -vec2( cellObsCol, 0.0 )\t// move to column\n        ) - 0.25;\t\t\t\t\t\t// radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t// cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t// move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n// OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); // Coord fix\n    // n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.3 * smoothstep( 2.5, 3.0, abs( p0.y ) );\n    float bgProf = 2.0 * smoothstep( 4.5, 5.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy / 10. ).r, 0.0, 1.0 );\n    float bg = 0.2 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy / 50.).r, 0.0, 2.0 );\n    float displace = 1.5 * fg + 3.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) / sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n// From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 6.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.4;\n    \n    float a = box( p, vec3( 5.2, 1.0, 2.8 ) );   \n    \n    vec3 t = p + vec3( -7.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float b = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float c = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 3.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float d = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 3.0, -0.4, 0.0 );\n    opRotate( t.yx, -0.06 );\n    float e = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 3.0, 2.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float f = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );     \n        \n    if ( id == 2.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 / 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 / 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body /= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    // front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated / PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated / PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t// player, in place in fact\n    vec2 bent = getBent();\n    \n    // game\n    vec3 p0 = pos;    \n    // bending    \n    p0.x -= 1.4 * sin( 0.06 * p0.z * PI ) * bent.x;\n    p0.y += 1.4 * sin( 0.06 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.3 * bent.x );\n    pPlayer.yz *= rot( -0.3 * bent.y );\n    // sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); // debug collider\n    \n\tfloat rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.02 * PI * bent.y + rotY -0.6 * PI );\n    pPlayer.yz *= rot( -0.02 * PI * bent.x + rotX );\n    // pPlayer.yz *= rot( -10.0*iTime ); // mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 3.0 * g_S.playerPos.y;\n    pEnv.x -= 0.6;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -2, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.6;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.6, 2.0 ) - 0.6;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        // sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); // debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 25.0 ), rd, vec3( 8.0, 5.0, 55.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 228 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                // res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 6.0 ), rd, vec3( 5.0, 5.0, 35.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 42 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    // vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 2.0, -2.0 ) * 0.6773 * 0.02;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 2; i++ )\n    {\n        vec3 e = 0.6773*(3.0*vec3((((i+4)>>2)&2),((i>>2)&2),(i&2))-2.0);\n        n += e * map( pos + 0.0006 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 2.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.02 + 0.22 * float( i ) / 5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 1.05;\n    }\n    return clamp( 2.0 - 4.0 * occ, 0.0, 2.0 ) * (0.6 + 0.6 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 2.4, SKY_COLOR_2, rd.y / 10.0 );\n\t\n    float fogFalloff = clamp( 9.0 * rd.y, 0.0, 2.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.2, -0.3, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 1.0, 2.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -2.0 ); // easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 1.087, 1.09, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.2, 1.0, 0.6 );\t\t\t        \n    \n    float stripes = mod( 60.0 * ( pow( rd.y + 0.25, 2.5 ) ) + 0.6, 2.0 ) -0.6;\n    stripes = smoothstep( 0.3, 0.31, abs( stripes ) );\n        \n    \n    // based on https://www.shadertoy.com/view/tssSz7\n    vec2 starTile   = floor( rd.xy * 50.0 );\n    vec2 starPos    = fract( rd.xy * 50.0 ) * 3.0 - 2.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 3.0 - 2.0;\n    float stars = saturate( 2.0 - ( ( sin( iTime * 2.0 + 60.0 * rd.y ) ) * 0.6 + 7.0 ) * length( starPos ) );\n    stars *= step( 0.1, -sun );\n    stars *= step( 1.0, starRand.x );\n    stars *= 6.0;\n           \n    sun = 3.0 * clamp( sun * stripes, 0.0, 2.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.2 ) / 0.4 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.9 + 0.3 * fogFalloff );\n    color = mix( color, sunCol, 0.35 * sunGlow );\n    \n    color += stars;\n\n    // return vec3(stripes);\n    // return vec3(sun);\n    // return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    // repeat car rotation with fixes\n    float rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.6 );\n    float met = 2.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.1 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) / GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE / GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.6, lPos.z - 3.0 * g_S.playerPos.y );\n        pTrail.x += 5.0 * rotY; // move the cos\n        pTrail.x -= 5.0 * rotY * ( cos( 0.85 * pTrail.y - 0.2 * PI ) * 0.6 + 0.6 ); // fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.38;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -40.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -5.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.6 );\t\t// clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.6 + 2.5 );\t// clamp on Y\n        emissive += vec3( 2.5, 0.3, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );         \n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t// spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 20.0 * vec3( 0.2 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    // spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 2.0 ) );\n    float spotAtt = 0.2 / pow( 2.0 * length( pSpot ), 3.0 );\n    spotAtt *= smoothstep( 0.2, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.4 * ( 0.9 + dot( nor, rd ) ), 3.0 );\n    float amb = clamp( 0.6 + 0.6 * nor.y, 0.0, 2.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.3, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 2.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 2.0 ), 74.0 )\n        * dif\n        * ( 0.05 + 1.06 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 2.0 ), 6.0 ) );\n   \n    color.rgb = albedo * ( 0.6 + 0.6 * occ ) * ( 0.8 + 0.4 * dif ) + spe * vec3( 2.0, 0.6, 0.2 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    // return vec4(vec3(0.4) * m, 0.5); // debug material ID\n    // return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 2.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 2.0, 2.0 ) * pos.xz / 74.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.3, 2.5 ) * pos.xz / 74.0 + iTime * vec2( 0.02, 0.2 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.7, noiseBase );\n    noise *= noiseDetail * 0.6 + 0.6;\n    noise *= smoothstep( 2.5, 0.0, pos.y ); // height falloff    \n    noise *= ( 2.0 - bent.y ); // disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ // From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n    float gFogDensity\t\t= 0.2;\n    rayOrigin.z += 3.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 42; ++i )\n    {\n        float t = ( float( i ) + 0.6 + dither ) * 6.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.2 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.2 );\n    color = mix( fogColor, color, fogAlpha );\n    // color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.6 * vec3( exp( -g_glowCoin * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.4 * vec3( exp( -g_glowCoinRefl * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 2.0 * vec3( exp( -saturate(g_glowPlayer) * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowPlayerRefl) * 20.0 ) );\n    bloom += vec3( 0.2, 0.06, 0.0 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerLights) * 25.0 ) );\n    bloom += vec3( 0.0, 0.06, 0.2 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerFront) * 25.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowEnemy) * 6.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 6.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 2.0 );\n    sHit sRes = castRay( ro, rd, 2.0, 50.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.6 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 2.0, 0.0 ), dither * 0.2 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.2, 30.0 ); // only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.1 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.1 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.1 );\n            \n#endif // REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 2.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.0006 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif // VOLUMETRICS\n    \n    // blur mask\n    col.a = 1.1 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.06, 0.0 ) ) ) * 0.7 + 0.8 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy / iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    // camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.3 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 1.5 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    // ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    // render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy / R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\n#endif // FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; // flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        // drawGameFlat( color, p0, s );\n    \t// drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}", "buffer_b_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 5. ? 2397642579u : ( t.x < 9. ? 2142969413u : ( t.x < 22. ? 2163282770u : ( t.x < 26. ? 2280202016u : ( t.x < 30. ? 2414090057u : 27477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 5. ? 2751607624u : ( t.x < 9. ? 2919902579u : 24949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y / R.x; // ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    // splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide\n        \n        float maskTitle = titleText( p2 ); // Moonset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); // press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); // Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide\n    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.22801,\n\t0.22299,\n\t0.20908,\n\t0.09931,\n\t0.07750,\n\t0.05709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 / vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n    \n \tvec2 uv = F.xy / R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); // 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ // based on gtoledo3 (XslGz8)\n  // added zoomimg\n\tvec2 cc = coord - 0.6;\n    vec2 p = cc * zoom;\n    coord = p + 0.6;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 3.51;\n    const float b = 0.04;\n    const float c = 3.43;\n    const float d = 0.69;\n    const float e = 0.24;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 9;\t\n    float scale = 2.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0 / float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.5 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.5 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.5 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.0, 0.9972, scale );\n\t\tgf *= mix( 1.0, 0.998,  scale );\n        bf /= mix( 1.0, 0.9988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    // barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.2, 1.07 );\n    \n    // chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    // color = texture( iChannel0, uv ).rgb;\n    \n    // vignette\n\tcolor.rgb *= 0.8 + 0.4 * clamp( pow( 38.0 * uv.x * uv.y * ( 2.0 - uv.x ) * ( 2.0 - uv.y ), 3.0 ), 0.0, 2.0 );\n\t\n\t// grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.06 ), vec3( 0.9 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 77, 123, 1599], [1601, 1601, 1658, 1658, 2359]]}
{"id": "Ws3fW2", "name": "Life experiments 3: replication", "author": "illus0r", "description": "Previous version https://www.shadertoy.com/view/WstBWB", "tags": ["life"], "likes": 3, "viewed": 295, "published": 3, "date": "1605972909", "time_retrieved": "2024-07-30T20:34:24.696619", "image_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n\tvec4 col = texture(iChannel0,uv);\n    fragColor = col;\n    //fragColor = vec4((noise(uv*9.)*2.-1.),(noise(p*9.+99.)*2.-1.),0.,1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R 5.\n#define max_speed 1.\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n  //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}", "buffer_a_code": "float rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    // spawning cells\n    if(mod(float(iFrame),1000000.)<=1.){\n        fragColor=vec4(0.);// `p` of 0. means empty cell\n        //if(mod(FC.x+.5,16.)==0. && mod(FC.y+.5,16.)==0.){\n        //if(rnd(uv.x*4.1+uv.y*9.01+iTime*.001)*.5+.5<.1){\n        if(abs(length((uv-.5)/iResolution.x*iResolution.xy)-.0000001)<.001){\n            //fragColor=vec4(.5,.5,.5+.0*rnd(uv.x),.5+.0*rnd(uv.y));//.5 to place to the center\n            fragColor=vec4(.5,.5,.5,.5);\n        \treturn;\n        }\n    }\n    \n    if(rnd(uv.x+uv.y+iTime+1.)>.95) return;\n\n    // find guest\n    vec2 guest_ij;\n    bool is_guest_found = false;\n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            if(p.x+v.x<1. && p.y+v.y<1. && p.x+v.x>=0. && p.y+v.y>=0.){\n            \tis_guest_found = true;\n                guest_ij=vec2(i,j);\n                // set fragColor to represent guest\n                fragColor=vec4(p,v*.5+.5);\n                break;\n            }\n        }\n    }\n    \n    // no guests\n    if(!is_guest_found){\n        vec2 ij=vec2(1.,1.);\n        vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n        vec4 neighbour=texture(iChannel0,uv_n);\n        if(length(neighbour)>0.&&rnd(uv.x+uv.y+iTime)>.85){\n            fragColor = vec4(.5);\n            return;\n        }\n        \n        fragColor = vec4(0.);\n        return;\n    }\n\n    \n    \n    //  ,    \n    for(float i=guest_ij.x-R;i<=guest_ij.x+R;i++){\n        for(float j=guest_ij.y-R;j<=guest_ij.y+R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            //v = neighbour.ba*2.-1.;\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 4.;\n            \tf+=normalize(fragColor.rg-p)/dist*dist;\n            \tf+=normalize(fragColor.rg-p)*(target_dist-dist)*.5;\n            }\n            \n            \n            //if(p.x<1. && p.y<1. && p.x>=0. && p.y>=0.){\n            //    fragColor.rg = p;\n            //    fragColor.ba = v*.5+.5;\n            //    //break;\n            //}\n        }\n    }\n    \n    //         \n    //     ,     .\n    //      .\n    \n    // :\n    //  .   ,  .\n    //    \n    //   t1    t1  , \n    //     .\n    //   .\n    \n    //  :    ,    \n    //         .\n    // :    ,    .\n    //    .\n    \n    //    \n    //   :\n    //,        .\n    //        t2.\n    //    \n    //         , \n    //  ,       t2\n    //    \n    //      .   )\n    //   t2,    t1. ,    t1 \n    //    t2.        t1?\n        \n    // move by old speed\n    \n    \n        \n    if(length(fragColor)>0.){\n        p = fragColor.rg;\n        v = fragColor.ba*2.-1.;\n        p=fract(p+v);\n        v*=.99;\n        v.x+=.2*(snoise(uv*4.));\n        v.y+=.2*(snoise(uv*4.+99.+iTime/2.));\n        v += f/20.;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        fragColor.rg = p;\n        fragColor.ba = v*.5+.5;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col = vec4(1.);\n    \n    for(float i=0.;i<1.;i++){\n        for(float j=0.;j<1.;j++){\n            vec2 ij = vec2(i,j);\n            vec4 tex = texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n            if(length(tex)>0.)\n\t\t    col -= 2.*tex.a * (1.-vec4(.3, .7, .1, 1.));\n\t\t    //col = max(col,texture(iChannel0,(FC+ij)/iResolution.xy));\n        }\n    }\n    //if(length(col)>0.) fragColor = vec4(1.);\n    fragColor = col;\n    fragColor = min(fragColor,texture(iChannel1,uv));\n    fragColor = mix(fragColor,vec4(1.),.01);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 215]]}
{"id": "3dcBW2", "name": "checkerboard animation 4.b", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 18, "viewed": 394, "published": 3, "date": "1605966659", "time_retrieved": "2024-07-30T20:34:25.542358", "image_code": "// variant of https://shadertoy.com/view/3s3BW2\n\nfloat ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n    x = clamp(x, 0.,1.);                                // stepier than smoothstep or .5-.5*cos\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x\n                  :                4.* x*x*x ;\n}\n\n#define D \\\n    V = abs( ( fract(U/2.)-.5)*mat2( cos(3.14/2.*t + vec4(0,11,33,0))) ); \\\n    O += smoothstep( w, -w, max(V.x,V.y) - .25 ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y, V;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float T = iTime/2.,\n       // t = ease( 1.5*fract(T) - U.x/16. ),\n          t = ease( 1.5*fract(T) - U[int(T)%2]/16. ),\n          n = mod(T,2.), w = 4./R.y;\n\n    if (n > 1.)  U.x++, t = 1.-t;\n    U -= .5; D;\n    U++;     D;\n    if (n < 1.)  O = 1.-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 72, 156, 343], [484, 484, 522, 522, 926]]}
{"id": "3s3BW2", "name": "checkerboard animation 4", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 5, "viewed": 287, "published": 3, "date": "1605966218", "time_retrieved": "2024-07-30T20:34:26.303323", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define D \\\n    V = abs( ( fract(U/2.)-.5)*mat2( cos(3.14/2.*t + vec4(0,11,33,0))) ); \\\n    O += smoothstep( w, -w, max(V.x,V.y) - .25 ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y, V;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float t = ease( fract(iTime/2.) ), w = 4./R.y,\n          n = mod(iTime/2.,2.);\n\n    if (n > 1.)  U.x++, t = 1.-t;\n    U -= .5; D;\n    U++;     D;\n    if (n < 1.)  O = 1.-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [390, 390, 428, 428, 754]]}
{"id": "3scfDj", "name": "checkerboard animation 3", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 3, "viewed": 294, "published": 3, "date": "1605964096", "time_retrieved": "2024-07-30T20:34:27.176987", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)  mod( floor(x), 2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float t = ease( fract(iTime/2.) ), T,\n          y = B(U.y+1.);\n    int n = int(iTime/2.+1.) % 3;\n    if (n==1) { abs(U.x + 4.*t -6.) > 2. ? O++ : O; return; } // phase 2: block to left\n    if (n==2) t = 1.-t, y = 1.-y, U.x = 8.-U.x;         // phase 3 = sym of phase 1\n  \n    if ( U.x < 4.*t ) { O++; return; }                  // empty area = white\n    T = 2.-t;\n    U.x += floor( (8.-U.x) / T ) * T - t*y;             // pack black tiles\n\n    O += float( B(U.x) == y );                          // checker cell color          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [286, 286, 324, 324, 1003]]}
{"id": "WdcBDB", "name": "Isometric Weave Pattern", "author": "Shane", "description": "A random weave pattern on a hexagonal isometric grid, rendered in an impossible-geometry style.", "tags": ["hexagon", "geometry", "isometric", "impossible", "weave"], "likes": 46, "viewed": 812, "published": 3, "date": "1605963081", "time_retrieved": "2024-07-30T20:34:28.285024", "image_code": "/*\n\n\tIsometric Weave Pattern\n    -----------------------\n\n\tUsing a subdivided hexagon grid to produce a random weave, rendered\n    in an impossible geometry style.\n\n\tSince I hadn't seen a randomized isometric weave before, I thought \n    it'd be interesting to programatically produce one. There's a bit of \n    code here, but a lot of it is window dressing. The principle behind\n\tits constuction is pretty simple:\n\n    Partition space into a hexagonal grid. With each hexagonal cell, \n    partition it into three rhomboids which will each make up a cube face. \n    Choosing the SHOW_HEX_GRID define will make it more clear, since you \n    can see the three rhomboid partitionings in the background.\n\n    With each rhomboid quad, render two straight lines between the mid \n    side edges, or one line over the other to form a cross. Cut each line \n    down the middle and assign a normal, depending upon whether it's \n    facing in the X, Y or Z directions.\n\n    The process is very similar to a hexagonal Truchet weave, but with \n\tthe lines having a straight edge isometric quality. This is just one\n\tof many styles, and just one way to produce this particular \n    arrangement -- This is a weave, but you could include cross beams and\n    so forth for way more variation. I'd imagine there'd be more elegant \n    solutions... which I'll leave to anyone bored enough to give it a go. :)\n\n\n\n    Related examples:\n\n    // Cool, clever and concise.\n\tisometric textured 3-story-map - FabriceNeyret2 \n    https://www.shadertoy.com/view/WdsXW4\n\n    // An oldschool isometric tiling example. One of my favorites on here.\n    Isometric City 2.5D - knarkowicz\n    https://www.shadertoy.com/view/MljXzz\n\n    // I'm pretty sure BigWIngs was the first to put a hexagonal weave\n    // on Shadertoy. He also has other weave examples that are worth\n    // looking up.\n    Hexagonal Truchet Weaving - BigWIngs\n    https://www.shadertoy.com/view/llByzz\n\n    // Awesome impossible geometry example... I probably should have \n    // consulted it before writing mine, as the code is much cleaner. :)\n    Impossible Chainmail - BigWIngs\n    https://www.shadertoy.com/view/td23zV\n \n    // Another impossible geometry example done in a different way.\n    Impossible Geometric Lattice - Shane\n    https://www.shadertoy.com/view/wd3XRj\n\n*/ \n \n\n\n// Hexagon cell routine. It's a shortened version of a 4-tap 3D routine, so it's\n// not as consise as it should be. If you're after that, try this version:\n//\n// Minimal Hexagonal Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\nvec4 hexCell(vec2 q){\n\n    // Block dimension: Length to height ratio with additional scaling.\n    //const vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = GSCALE*2.;\n    \n    // Two initial tile positions for a hexagon with a pointed top.\n    //vec2[2] ps4 = vec2[2](vec2(-1, .5), vec2(0, -.5));\n    vec2[2] ps4 = vec2[2](vec2(-.5, .5), vec2(.5, -.5));\n  \n    //Local coordinates of the closest hexagon cell and cell ID\n    vec2 lP, id;\n    \n        // Distance.\n    float minD = 1e5;\n    \n    // You definitely don't need a loop here, but as mentioned above, this\n    // has been cut down from a 3D routine.\n    for(int i = 0; i<2; i++){\n\n        // Cell center.\n        vec2 cntr = ps4[i]/2.; \n         \n        vec2 p = q.xy; // Local coordinates.\n        vec2 ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n           \n        // The hexagon cell distance or bound.... Kind of... Technically, it's \n        // \"max(abs(p.x)*.8660256 + abs(p.y)*.5, abs(p.y)),\" but this will work.\n        float d = dot(p, p);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and object ID. \n        if(d<minD){\n            \n            minD = d;\n            // Setting the local coordinates and ID.\n            lP = p;\n            // Individual tile ID.\n            id = ip + cntr; // Multiply by \"s\" for scaling.\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(lP, id);\n}\n\n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n/*\n// Object swapping.\nvoid swap(inout float a, inout float b){ float tmp = a; a = b; b = tmp; }\nvoid swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\nvoid swap(inout vec3 a, inout vec3 b){ vec3 tmp = a; a = b; b = tmp; }\n*/\n\n\nvec3 colorSurf(vec3 rd, vec3 ld, vec3 sn){\n   \n    vec3 col = vec3(.6, .25, .1)*(max(dot(sn, ld), 0.) + .25);\n    col += vec3(1, .6, .2)*pow(max(dot(reflect(sn, ld), rd), 0.), 4.); \n    //col += abs(sn)/2.;\n    return col;\n}\n\nvec3 UVToXYZ(vec2 p) {\n    return vec3(p.x + p.y, p.x, p.y);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n     // Global scale. Rendundant here.\n    const float gSc = 1.;\n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaled than transalated coordinates.\n    vec2 p = uv*gSc + vec2(0, .5)*iTime/8.;\n  \n    // The hexagon information for the current cell. This returns the\n    // local coordinates (h4.xy), and the unique central position ID (h4.zw).\n    vec4 h4 = hexCell(p);\n    vec2 svP = h4.xy; // Local coordinates.\n    \n    vec2 ap = abs(svP);\n    float hexDist = max(ap.y*.8660256 + ap.x*.5, ap.x) - (GSCALE).x;\n    \n    // The offset vertex information.\n    // Hexagon vertices with scaling to enable rendering back in normal space. \n    vec2 dim = GSCALE;\n    vec2[6] svV = vec2[6](vID[0]*dim, vID[1]*dim, vID[2]*dim, vID[3]*dim, vID[4]*dim, vID[5]*dim);\n\n    \n    // Containers for the midpoint edges and corresponding\n    // normals for the string and string shadows.\n    vec4 svEP[6];\n    \n    \n    \n    // The two line distance fields.\n    float ln = 1e5, ln2 = 1e5;\n    // Line edge width.\n    #ifdef SHOW_HEX_GRID\n    // Thinner lines when the hexagonal cell grid is displayed, just to \n    // make it easier to see things.\n    const float ew = .02;\n    #else\n    const float ew = .03;\n    #endif\n    \n    // The quad distace field. There are 3 rhomboidal quads per hexagon cell.\n    float qDist = 1e5;\n    // The minimum quad ID, based on the minimum quad central position.\n    vec2 qID = vec2(0);\n    // The box quad ID.\n    int bID = 0;\n    \n    \n    // The face surface normals. The first is for upward facing surfaces, and the others are\n    // for left and right facing. As an aside, it'd be possible to code hexagon, octagon\n    // surface cross sections too, but that'd be pretty painful, so I'm sticking to squares. :)\n    vec3 nr1 = vec3(0, 1, 0), nr2 = normalize(vec3(0, 0, -1)), nr3 = normalize(vec3(1, 0, 0));\n    //swap(nr1, nr2); // Swapping face normals.\n    // The two surface normals -- Initially to the left edge, but probably don't need to be.\n    vec3 sn = nr2, sn2 = nr2; \n   \n    \n    // For each hexagon, partition into three rhomboids then render two lines through \n    // each whilst assigning normals.\n    \n    for(int j = 0; j<6; j+=2){\n        \n        // Constructing the edge midpoints and normals at those\n        // points for both the string and corresponding shadows.\n        vec2[4] v = vec2[4](svV[(j + 1)%6], svV[(j + 2)%6], svV[(j + 3)%6], vec2(0));\n \n        // Quad center and local quad ID.\n        vec2 ctr = (v[0] + v[1] + v[2] + v[3])/4.;\n        vec2 lID = h4.zw + ctr;\n        \n        // Some random numbers for this particular quad.\n        float rndI = hash21(lID + .327);\n        float rndI2 = hash21(lID + .493);\n       \n        // Mid edge points. You can offset the lines from the mid point\n        // slightly (<.25) to create warped patterns. You could also \n        // offset on an edge by edge basis, but I wanted to keep things\n        // simple.\n        float offs = 0.;//sin(iTime)*.05;\n        vec2 e0 = mix(v[0], v[1], .5 + offs);\n        vec2 e1 = mix(v[1], v[2], .5 - offs);\n        vec2 e2 = mix(v[2], v[3], .5 + offs);\n        vec2 e3 = mix(v[3], v[0], .5 - offs);\n     \n\n        float quad = sdPoly4(svP, v);\n        \n        // If this particular quad is closer, calculate some lines. By the way, \n        // the \"quad<1e-3\" line is there, so that we mostly calculate the \n        // following just once. Normally, you'd just find the nearest quad, \n        // save the edge points and perform this outside the loop, but I'm trying\n        // to keep things more compact.\n        if(quad<qDist && quad<1e-3){\n            \n            \n            qDist = quad; // Minimum distance.\n            qID = lID; // Minimum quad ID.\n            bID = j/2; // Cube or box ID -- There are 3 in all.\n \n            // Swapping end points is a way to switch from two parallel quad lines\n            // to ones that cross over.\n            if(rndI<.5) { \n                 swap(e2, e3); \n            }\n            \n            // Line one and two tangents.\n            vec2 tn = normalize(e2 - e0);\n            vec2 tn2 = normalize(e3 - e1);\n            \n            // The distance fields for line one and two. Note that I've extended the\n            // mid edge points beyond the quad boundaries. This will get rid of\n            // border seam lines.\n            const float ndg = .5; // Change to \"-.02,\" or something to shorten the lines.\n            ln = lBox(svP, e0 - tn*ndg, e2 + tn*ndg, ew);\n            ln2 = lBox(svP, e1 - tn2*ndg, e3 + tn2*ndg, ew); \n            \n            // Determine which side of the center line we're on for each\n            // line segment.\n            float line02 = line(svP, e0, e2);\n            float line13 = line(svP, e1, e3);\n            \n            // Setting the face normal: This is dependent on the quad we're\n            // in (top or two sides) which side of the central line of each\n            // line segment we're in and the normal orientation (up, sloping\n            // down, etc). By the way, there's probably a more elegant way\n            // to go about setting the face normals, but these calculations\n            // are only performed once, so it doesn't matter too much... I'll\n            // leave the more elegant solution to Fabrice. :)\n            //\n            if(j==0){ // Top rhomboidal quad.\n            \n                 // Straight up and down line segment one.\n                if(abs(tn.x)<.1) {\n                    // Left side of the line, X-dominant normal.\n                    if(line02<0.) sn = nr3;\n                    else sn = nr2; // Right side of the line, Z-dominant normal.\n                }\n                else{ // Left or right line one.\n                    if(line02<0.) sn = nr3; // Bottom side of the line, X-dominant normal.\n                    else sn = nr1; // Top side of the line, Y-dominant normal.\n                }\n                \n                // Straight up and down line segment two.\n                if(abs(tn2.x)<.1) {\n                    if(line13<0.) sn2 = nr3; // Left side of the line, X-dominant normal.\n                    else  sn2 = nr2; // Right side of the line, Z-dominant normal.\n                }\n                else{  // Left or right line two.\n                    if(line13<0.) sn2 = nr1;  // Top side of the line, Y-dominant normal.\n                    else sn2 = nr2;  // Bottom side of the line, Z-dominant normal.\n                }\n                \n            }\n             \n            if(j==2){  // Bottom right rhomboidal quad.\n            \n                // Similar logic to above (See \"j==0\").\n                if(abs(tn.x)<.2) {\n                    \n                    if(line02<0.) sn = nr2;\n                    else sn = nr3;\n                }\n                else{\n                    \n                    if(line02<0.) sn = nr1;\n                    else {                        \n                        if(tn.y>.0) sn = nr3;\n                        else sn = nr2;\n                    }\n                }\n                \n                if(abs(tn2.x)<.2) {\n                    if(line13<0.) sn2 = nr2;\n                    else sn2 = nr3;\n                }\n                else{\n                    if(line13<0.) sn2 = nr1;\n                    else sn2 = nr3;\n                }\n                \n            }  \n            \n            \n             if(j==4){ // Bottom right rhomboidal quad.\n            \n                // Similar logic to above (See \"j==0\").\n                if(abs(tn.x)<.2){\n                    if(line02<0.) sn = nr2;\n                    else sn = nr3;\n                }\n                else{\n                    if(line02<0.) sn = nr2;\n                    else sn = nr1;\n                }\n                 \n                \n                if(abs(tn2.x)<.2) {\n                    if(line13<0.) sn2 = nr2;\n                    else sn2 = nr3;\n                }\n                else{\n                    if(line13<0.){\n                        if(tn2.y>.0) sn2 = nr2;\n                        else sn2 = nr3;\n                    }\n                    else sn2 = nr1;\n                }\n                \n            }           \n \n            // Randomly swapping the rendering order of the lines for\n            // more variation.\n            if(rndI2<.5){\n                swap(ln, ln2);\n                swap(sn, sn2);\n            }\n \n            \n            \n        }\n \n    }\n    \n    \n    // Rendering.\n \n    // At this point, you have access to the two line distance field values, and\n    // their respective normals. You also have the quad distance field values and\n    // normals, so at this point, you can render whatever you want in as simple\n    // or as complex a manner as you'd like.\n    \n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    // Fake point light... Very fake, but it's only used to create a bit of\n    // gradient shine within the scene, so it doesn't matter.\n    vec3 ld = normalize(vec3(.5, 3, -3) - UVToXYZ(uv));\n    //vec2 xy = rot2(3.14159/3.)*uv;\n    //vec3 ld = normalize(vec3(.5, 3, -3) - vec3(xy.x, uv.y, xy.y));\n    vec3 ld2 = -ld.zxy; // Another light.\n\n    \n        \n    // Initializing the scene color to the background color.\n    vec3 col = vec3(1);\n    \n    // The two line distance field colors.\n    vec3 lnCol = vec3(1);\n    vec3 lnCol2 = vec3(1);\n    \n    \n    \n    // Face IDs. One for each pylon, or line.\n    int faceID1 = abs(sn.x)>.8? 0 : abs(sn.y)>.8? 1 : 2;\n    int faceID2 = abs(sn2.x)>.8? 0 : abs(sn2.y)>.8? 1 : 2;\n \n    #ifdef FLAT_SHADING\n        // Flat shading option.\n    \n        // The three face colors. I've arranged for the lightest side to face up.\n        const vec3 cc = vec3(1, .8, .55);\n        //vec3 aCol[3] = vec3[3](cc*cc*cc*.5, cc, cc*cc*.8);\n        //vec3 aCol[3] = vec3[3](vec3(1, .15, .3), vec3(1, .5, .85), vec3(.6, .1, 1));\n        vec3 aCol[3] = vec3[3](vec3(1, .1, .01), vec3(1, .6, .1), vec3(1, .2, .0));\n        // The two line colors.\n        lnCol = aCol[faceID1];\n        lnCol2 = aCol[faceID2];\n    #else    \n        // Using the face normal to lighting the surface.\n    \n        lnCol = colorSurf(rd, ld, sn); \n        lnCol2 = colorSurf(rd, ld, sn2); \n        //lnCol = vec3(1)*dot(lnCol, vec3(.299, .587, .114));\n        //lnCol2 = vec3(1)*dot(lnCol2, vec3(.299, .587, .114));\n        //lnCol += pow(colorSurf(rd, ld2, sn).zyx, vec3(2))/16.; \n        //lnCol2 += pow(colorSurf(rd, ld2, sn2).zyx, vec3(2))/16.; \n    #endif\n\n    // The cross hatching pattern on each face. Oriented to match the face.\n    vec3 aR = vec3(-3.14159/3., 0, 3.14159/3.) + 3.14159/1.;\n    vec2 qUV = rot2(aR[faceID1])*p;\n    vec2 qUV2 = rot2(aR[faceID2])*p;\n    float freq = 150.;\n    float pat = abs(fract(qUV.y*freq) - .5)*2. - .1;\n    float pat2 = abs(fract(qUV2.y*freq) - .5)*2. - .1;\n    pat = smoothstep(0., sf*freq*2., pat);\n    pat2 = smoothstep(0., sf*freq*2., pat2);\n    #ifdef HATCHING\n    // Applying the hatch pattern to each line.\n    lnCol *= pat*.4 + .7;\n    lnCol2 *= pat2*.4 + .7;\n    #endif\n    \n    // The background cubes consist of the three face quads. The top quad has\n    // an upward facing normal, and the sides have X or Z faceing normals. \n    vec3 cN = bID == 0? nr3 : bID == 1? nr2 : nr1;\n\n    // The cube cross hatch pattern.\n    freq = 150.;\n    vec2 qUV3 = rot2(aR[(bID + 1)%3])*p;\n    float pat3 = abs(fract(qUV3.y*freq) - .5)*2. - .1;\n    pat3 = smoothstep(0., sf*freq*2., pat3);\n    \n    #ifndef FLAT_SHADING\n    //vec3 cCol = colorSurf(rd, ld, cN);\n    vec3 cCol = vec3(1, .95, .9);\n    // Add some blue light to the cube faces.\n    cCol += pow(colorSurf(rd, ld2, cN).zyx, vec3(2))/2.; \n    #else \n    vec3 cCol = vec3(.25, .2, .15);\n    col = cCol;\n    #endif\n    \n    // Random blinking.\n    float rnd = hash21(qID + .13);\n    rnd = smoothstep(.9, .95, sin(6.2831*rnd + iTime*2.)*.5 + .5);\n    // Shading the background with one of the normals.\n    float sh3 = dot(colorSurf(rd, ld, nr1), vec3(.299, .587, .114));\n    \n    // Hexagonal cell background shade.\n    //float sh = max(.5 - qDist/.1, 0.);\n    float sh = max(.5 - hexDist/.1, 0.);\n    \n    #ifdef FLAT_SHADING\n    sh = 1., sh3 = 1.; rnd = 0.;\n    #endif\n    // Border highlight color.\n    vec3 hiCol = cCol*vec3(.3, .4, 1)*4.*sh3;\n   \n    // Applying shade and hatching to the cube background.\n    cCol *= sh3*sh;\n    #ifdef HATCHING\n    cCol *= (pat3*.4 + .7);\n    #endif\n   \n    // Rendering the hexagonal quad segment in the background -- Dark edge and coloring.\n    col = mix(col, cCol, (1. - smoothstep(0., sf, qDist + .0035)));\n    #ifndef FLAT_SHADING\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., abs(qDist) - .0035/2.*6.))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*6.))); \n    col = mix(col, mix(vec3(sh3), hiCol, rnd), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*3.))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.)));\n    #else\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*5.)));\n    //col = mix(col, vec3(.25, .2, .15)*2., (1. - smoothstep(0., sf, abs(qDist) - .0035/2.*3.)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(qDist) - .0035/2.)));\n    #endif\n   \n    // Shading the lines.\n    sh = max(.5 - ln/.03, 0.);\n    float sh2 = max(.5 - ln2/.03, 0.);\n    \n    #ifdef FLAT_SHADING\n    sh2 = 1.;\n    #endif\n\n     \n    // Rendering the first line layer -- Drop shadow, edges, color and center line.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., ln))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    //col = mix(col, vec3(.5)*sh, 1. - smoothstep(0., sf, ln + .005));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln + .005 + .0035));\n    col = mix(col, lnCol*sh, 1. - smoothstep(0., sf, ln + .005)); // + .005 + .0035\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln + ew - .0015));\n \n    // Doing the same for the second line layer \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., ln2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2)); \n    //col = mix(col, vec3(.5)*sh2, 1. - smoothstep(0., sf, ln2 + .005));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 + .005 + .0035));\n    col = mix(col, lnCol2*sh2, 1. - smoothstep(0., sf, ln2 + .005)); // + .005 + .0035\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 + ew - .0015));\n \n \n    #ifdef SHOW_HEX_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(hexDist) - .005/2.*3.))*.5); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(hexDist) - .005/2.*3.))); \n    col = mix(col, vec3(1, .95, .9), (1. - smoothstep(0., sf, abs(hexDist) - .005/2.))); \n    #endif\n \n    // Mixing in a bit of gradient color.\n    col = mix(col, col.xzy, length(uv)*.25);\n    \n    //col = mix(col.zyx, col.yxz, .8); // Other colors.\n    \n    // Applying a subtle silhouette, for art's sake.\n\tuv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n                          \n\n    // Rough gamma correction, and we're done.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "\n// Display the individual hexagon grid cells.\n//#define SHOW_HEX_GRID\n    \n// Flat shading. No lighting.\n//#define FLAT_SHADING\n \n// Apply hatching\n#define HATCHING\n\n// Tile scale.\n#define GSCALE vec2(1./5.)*vec2(.5, .8660254)\n\n\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -1./3.)/vec2(.5, 1), vec2(-.5, 1./3.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 1./3.)/vec2(.5, 1), vec2(.5, -1./3.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\n//vec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), vec2(.5, 0)/vec2(.5, 1), \n                      //vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n\n \n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ \n    \n    p = mod(p, 256.);\n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    return fract(sin(mod(dot(p, vec2(27.649, 57.583)), 6.2831859))*43758.5453); \n}\n*/\n\n/*\n// UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input.\n// Also, in theory, you could tweak the figures by hand to get a really\n// scrambled output... When I'm feeling less lazy, I might do that.\nfloat hash21(vec2 p) {\n\n    p = fract(p/128.)*128. - vec2(59.340627, 73.465623);\n    return fract(dot(p.xyx*p.xyy, vec3(20.390625, 80.703127, 12.4281203)));\n    \n}\n*/\n\n\n\n// This is IQ's WebGL 2 hash formula: I've modified it slightly to \n// take in the normal decimal floats that we're used to passing. It \n// works here, I think, but I'd consult the experts before using it.\n//\n// I remember reading through a detailed explanation of the C++ hash \n// we all used to use many years ago (which the following would be\n// similar to), but have long since forgotten why it works. By the \n// way Nimitz and Dave Hoskins have formulae on Shadertoy that's worth\n// looking up.\n//\n// Integer Hash - III - IQ\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash21(vec2 p){\n    \n    uvec2 q = floatBitsToUint(p);\n\tq = 1103515245U*((q>>1U)^q.yx);\n    uint n = 1103515245U*(q.x^(q.y>>3U));\n    return float(n)/float(0xffffffffU);\n}\n \n\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n \n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4590, 4590, 4632, 4632, 4814], [4816, 4816, 4838, 4838, 4878]]}
{"id": "WdcfDj", "name": "cross intersection - 001", "author": "catafest", "description": "it creates a sdBox model for two 3D vectors and is used to draw a cross at the mouse position", "tags": ["3d", "cross", "vectors", "imouse", "sdbox"], "likes": 2, "viewed": 465, "published": 3, "date": "1605961755", "time_retrieved": "2024-07-30T20:34:29.114806", "image_code": "// use mouse and click on shader screen area\n\n// it creates a sdBox model for two 3D vectors and is used to draw at the mouse position\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// UV unwrapping by iResolution function\nvec2 uvmap(vec2 uv)\n{\n    return ( uv - iResolution.xy) /iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// unwrapping coords\n    vec2 uv = uvmap(fragCoord.xy);\n\t// first 3D vector (0.01, 0.01, 0.01)\n    vec3 p0 = vec3(0.01);\n    // a vector based by unwrapping coords and mouse coords\n    vec2 p1 = uv-uvmap(iMouse.xy);\n    // second vector based by p1 vector\n    vec3 p_m = vec3(p1,0.0);\n  \t// this formula will intersection in the cross \n    p_m = 1.0-p_m*100.0/(p_m*100.0+0.1);\n\t// create draw box with  sdBox using\n    // the p0 and p_m formula for cross intersection\n    vec3 col = vec3(sdBox(p0, p_m));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 135, 166, 166, 253], [255, 296, 317, 317, 369], [371, 371, 428, 450, 996]]}
{"id": "wddfDB", "name": "Random Graph", "author": "mla", "description": "Variation on [url]https://www.shadertoy.com/view/tstfzs[/url] with randomization & a few tweaks.\n\nFull screen best & mouse to zoom in, as before.", "tags": ["random", "graph"], "likes": 4, "viewed": 270, "published": 3, "date": "1605959132", "time_retrieved": "2024-07-30T20:34:29.877766", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Random Graph\n// Matthew Arcus, mla, 2020\n//\n// Variation of https://www.shadertoy.com/view/tstfzs\n//\n// Take N points in a circle, draw a line between each pair of\n// points. The obvious way to do this in a fragment shader is to test\n// the pixel against every point pair, but this gets slow for larger\n// number of points. A better way is to maintain two indexes into the\n// points, i and j, and each time around the loop, after testing for\n// proximity to the line between i and j, increment the index that\n// will move the line towards the pixel rather than away (draw a\n// diagram if this isn't clear).\n//\n// We can also draw the lines selectively, for example, randomize when\n// each line appears, so the complete graph structure only emerges gradually.\n// \n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 64; // number of nodes\nconst int P = 16;  // bipartite block size\nint Q; // sub block size\nconst float T = 15.0; // Cycle time\nconst float X = 6.0;  // Speed (N/X should be 10 seconds or so)\n\nbool select(int i, int j) {\n  if (Q == 0) return true; // Complete graph\n  // For a bipartite graph, divide up into blocks of P points, the\n  // first Q points of each block are connected to every point in the\n  // last P-Q of each block.\n  return (i%P < Q) != (j%P < Q);\n}\n\nbool rselect(int i, int j) {\n  if (!select(i,j)) return false;\n  // Randomly choose whether to display each line, based on the time,\n  // so lines gradually all appear.\n  uint h = ihash(uint(i) + uint(256*j));\n  return float(h) / 4294967296.0 < mod(iTime,T)/10.0;\n}\n\nvec3 diagram(vec2 p) {\n  float lwidth = fwidth(p.x);\n  vec3 col = vec3(1,1,0.8);\n  if (dot(p,p) > 1.0+lwidth) return col;\n  int cycle = int(iTime/T);\n  Q = cycle%(P/2+1);\n  float k = float(N);\n  //k *= smoothstep(0.0,k,min(k,X*mod(iTime,T)));\n  float d2 = 1e8;\n  for (float i = 0.0, j = 1.0; j < k; ) {\n    float offset = 0.5*float(Q-1); // Centre on Q block\n    float ii = 2.0*PI/k*(i-offset);\n    float ij = 2.0*PI/k*(j-offset);\n    vec2 q = vec2(sin(ii),cos(ii));\n    vec2 r = vec2(sin(ij),cos(ij));\n    if (rselect(int(i),int(j))) d2 = min(d2,segment2(p,q,r));\n    vec2 n = r-q;\n    if (dot(p-q,vec2(-n.y,n.x)) > 0.0) i++;\n    else j++;\n  }\n  col = mix(vec3(0),col,smoothstep(0.0,lwidth,sqrt(d2)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p -= mouse; // Centre on mouse\n    p *= 0.55*iResolution.y/iResolution.x; // And zoom\n  }\n  vec3 col = diagram(p);\n    col = 1.0-col;\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "float PI = 3.14159265;\n\n// Distance squared of p from line segment qr.\nfloat segment2(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float h = dot(p,r)/dot(r,r);\n  h = clamp(h,0.0,1.0);\n  p -= h*r;\n  return dot(p,p);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1138, 1138, 1165, 1165, 1411], [1413, 1413, 1441, 1441, 1678], [1680, 1680, 1702, 1702, 2398], [2400, 2400, 2453, 2453, 2782]]}
{"id": "ts3fDN", "name": "[]Scale Sequencer 3", "author": "Catzpaw", "description": "scale sequencer version 3\nnew features:\nadded chord sequence\nnon-diatonic chord\nauto inversion\na song can use up to 4 scales\nnew:vec2 getNoteByChord(t,l)\nnew:float getChord(n)", "tags": ["music"], "likes": 15, "viewed": 477, "published": 3, "date": "1605958281", "time_retrieved": "2024-07-30T20:34:30.983809", "image_code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//Image:animation\n\n//SNIPPETS\n#define ZERO min(iFrame,0)\nconst float pi=acos(-1.);\nconst float ip=1./pi;\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//BUFFER\nvec4 tx0(int x){return texture(iChannel0,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y));}\n\n//FONT SDF\n//5x6 dot matrix font\nconst int[64] font=int[](\n0x00000000,0x08e71004,0x14a00000,0x15f52bea,0x19ca10e7,0x26b21359,0x1823462e,0x08400000,\n0x10421088,0x04421082,0x01157d51,0x00427c84,0x00000082,0x00007c00,0x00000002,0x20821041,\n0x1d19e62e,0x0862108e,0x1d18383f,0x1d16422e,0x18a4a7e8,0x1e17c22e,0x1c17c62e,0x3f041084,\n0x1d17462e,0x1d18fa0e,0x00400080,0x00400082,0x00820888,0x000f83e0,0x00222082,0x1d141004,\n0x1d9ad722,0x1d18fe31,0x1f17c62f,0x1d10862e,0x1f18c62f,0x3e17843f,0x3e10bc21,0x1d10e63e,\n0x231fc631,0x1c42108e,0x2108422e,0x2293a631,0x0210843f,0x23bac631,0x233ad731,0x1d18c62e,\n0x1f18bc21,0x1d18c536,0x1f18be31,0x1d13222e,0x3e421084,0x2318c62e,0x2318c544,0x2318d771,\n0x22a22a31,0x23151084,0x3f06083f,0x1842108c,0x02221110,0x0c421086,0x08a88000,0x0000001f);\nfloat get1bit(int pos,int data){int b=(data>>(pos&31))&1;b=pos<0?0:b;b=pos>31?0:b;return b>0?1.:0.;}\nfloat sdPixel(vec2 p){p=abs(p)-.45;return length(max(p,0.))+min(max(p.x,p.y),0.);}\nfloat sdLetter(vec2 p,int char){vec2 q=floor(p);if(q.x<0.||q.x>4.||q.y<-0.||q.y>5.)return 2.;\n      p=fract(p)-.5;p.x+=step(get1bit(int(q.x+q.y*5.),font[char]),.5);return sdPixel(p);}\n\n//TEXTAREA SDF\n//      HELL YEAH!      I AM SCALE SEQUENCER 3 (44chars)\nconst int[9] text=int[](0x00000000,0x2cb25a00,0x28865e40,0x00000001,0x21029000,0x218f302d,0x25cc096c,0x23ba5d71,0x004c0ca5);\nconst int textChars=44;\nint   textChar(int pos){if(pos<0||pos>=textChars)return 0;return int((text[pos/5]>>(pos%5)*6)&63);}\nfloat sdTextArea(vec2 p,vec2 r,float pos,float num){\n    p.x*=6./5.;p+=r*.5;\n    if(p.x<0.||p.x>r.x||p.y<0.||p.y>r.y)return 2.;\n    vec2 q=floor(p);p=fract(p);\n    int char=textChar(int((r.y-q.y-1.)*r.x+mod(q.x,r.x)));\n    return sdLetter(p*vec2(6.,7.),char);\n}\n\n//TEXTURE\nvec2 tr(vec2 p){\n    p=fract(p*ip)*pi-pi*.5;\n    for(int i=ZERO;i<4;i++)p=abs(p)/dot(p,p)-vec2(sin(iTime*.13),sin(iTime*.27))*.05-.8;\n    return p;\n}\nvec3 tx(vec2 p){\n\tp.y+=iTime;\n\tfloat h=(floor(p.x)+iTime)*.05;\n\tfloat v=fract(floor(abs(sin(p.x*3.)*sin(p.y*17.))*6.)*.7);\n\treturn hsv(h,.3,v*.7+.3);\n}\n\n//MAIN\nfloat[6] wavfreq=float[](3.,8.,4.,5.,50.,31.);\n#define SSAA_BEGIN float spp=.5/iResolution.x;vec3 fcol=vec3(0);for(int ssx=0;ssx<2;ssx++)for(int ssy=0;ssy<2;ssy++){uv.x+=ssx>0?spp:0.;uv.y+=ssy>0?spp:0.;vec3 col=vec3(0);\n#define SSAA_END   fcol+=col;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.-iResolution.xy)/iResolution.x;        \n    SSAA_BEGIN //==================================================\n\n\t//tunnel\n    float l=length(uv),a=atan(uv.x,uv.y),t=fract(iTime*.1)*pi*2.;\n    vec2 p=vec2(l,a+.5/length(uv)+t);\n    col=tx(tr(p))-l*l*.3;\n\n    //wave\n    float vol=tx0(0).r;\n    vec2 wav=vec2(0);\n    for(int i=ZERO;i<6;i++){\n        vec4 g=tx0(i+1);\n        vec2 v=g.xy*.6;\n        float x=float(i+1);\n        wav+=sin(x+(uv.x*wavfreq[i])+iTime*41.)*v*.2;\n        col-=smoothstep(.05,.04,abs(uv.x-x*.1))*smoothstep(.01,.00,abs(uv.y)-v.x)*.3*vol;\n        col-=smoothstep(.05,.04,abs(-uv.x-x*.1))*smoothstep(.01,.00,abs(uv.y)-v.y)*.3*vol;\n    }\n    col-=smoothstep(.02,.01,abs(uv.y-wav.x))*.5*vol;\n    col-=smoothstep(.02,.01,abs(uv.y-wav.y))*.5*vol;\n    col=clamp(col,0.,1.);\n\n    //text\n    float d=sdTextArea(uv*float(textChars/2)*.51,vec2(textChars/2,2),0.,float(textChars));\n    col+=d<=0.?vec3(1):vec3(0);\n    col=clamp(col,0.,1.);\n\n    SSAA_END //====================================================\n    fragColor = vec4(fcol*.25,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n// See \"Common\" tab\n", "sound_inputs": [], "common_code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//Common:scale sequencer 3\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =120.;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=885.; //random seed for gate generator;\nconst float noteSeed=278.; //random seed for note generator;\n\n//SCALE\nint key=0; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\n//const uint[4] scl=uint[](0xcb975420u,0xcb975420u,0xcb975420u,0xcb975420u); //major,major,major,major\nconst uint[4] scl=uint[](0xcb975420u,0xca875320u,0xcb875320u,0xcb975320u); //major,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xca875320u,0xca875320u,0xcb875320u,0xcb975320u); //minor,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xc9974420u,0xca775530u,0xca775530u,0xca775530u); //pentatonic(major,minor)\n//const uint[4] scl=uint[](0xcb775540u,0xcb755420u,0xcb755420u,0xcb755420u); //ryukyu(pentatonic,hexatonic)\n//const uint[4] scl=uint[](0xba875410u,0xba875410u,0xba875410u,0xba875410u); //maqam hijaz octatonic\n//const uint[4] scl=uint[](0xba876320u,0xba876320u,0xba876320u,0xba876320u); //gypsy minor octatonic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x01000041u,0x01000001u,0x010000c1u,0x01000081u,\n\t0x01000041u,0x01000001u,0x010000c1u,0x01000081u,\n\t0x01000046u,0x01000004u,0x010000c5u,0x01000081u,\n\t0x01000044u,0x01000005u,0x020000c2u,0x03000085u\n);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605713u,0x46746589u,0x56183614u,0x360e1510u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390710u,  //08-0B melody\n    0x460e121cu,0x00000000u,0x00000000u,0x00000000u,  //0C-0F melody\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,  //10-13 \n    0x70333444u,0x00000000u,0x63111232u,0x00000000u,  //14-17 accompaniment,bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1= 8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,\n    0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\nconst int len2=16;const uint[len2] seq2=uint[]( //bassdrum+conga\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0e01e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0801e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0801e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0000001fu);\nconst int len3= 1;const uint[len3] seq3=uint[]( //bass\n    0x00000616u);\nconst int len4=16;const uint[len4] seq4=uint[]( //chord\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u);\nconst int len5= 2;const uint[len5] seq5=uint[]( //accompaniment\n    0xa0000814u,0xe8814814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x00000004u,0x00000005u,0x00000006u,0x00000007u,\n    0x00000004u,0x00000005u,0x00000006u,0x0000000cu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//FOLDBACK DISTORTION (input,threshould,ratio)\n//float fbdist(float v,float t,float f){return abs(v)>t?sign(v)+(t-v)*f:v;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\n//vec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\n//vec2 c30piano(float f,float x){return vec2(osc_c30(f*(1.-detune),3),osc_c30(f*(1.+detune),3))*max(env_d(x,.05),env_d(x,2.5)*.6);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(7./(x*.4+.1),.25)*env_d(x,.03);}\nfloat neshc(float x){return osc_duty(9./(x*.4+.1),.25)*env_d(x,.03);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\n//float lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n// track(t,l,s)\n//   t...time\n//   l...measure length (steps/bpm)\n//   s...step now playing\n//\n//   getPattern(t,patternSequence)...get pattern data now playing\n//   getGate(t,l)...get noteTime and noteNum from percussive pattern\n//   getNote(t,l)...get noteTime and noteNum from melodic pattern\n//   getNoteByChord(t,l)...noteNum will restricted by chord\n//   getChord(n)...get chord noteNum 0:root 2:3rd 4:5th 6:7th\n//\n// render(t,l,inout o,e)\n//   o...audio output\n//   e...false:render is called by delay effect\n//\n//   scaleChord(t,l,chordSequence)...set scale & chord for following tracks\n//\n//--------------------------------------------------------------------------------\n//TRACK 1 NES noise snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.6:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.3:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.4:0.;\n    return o;\n}\n//TRACK 2 NES sqr bassdrum,lowconga,highconga\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.4:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\n//TRACK 3 NES sqr bass and LPF saw\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+36.)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6):vec2(0);\n    return o;\n}\n//TRACK 4 N163 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*.25:vec2(0);\n    return o;\n}\n//TRACK 5 N163 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*.30:vec2(0);\n    return o;\n}\n//TRACK 6 N163 & NES tri melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30lead(freq(n.y+36.03)*n.x,n.x)*.6+tri4lead(freq(n.y+48.)*n.x,n.x)*.5:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):vec2(0); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s);         //TRACK 2 bassdrum,lowconga,highconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 accompaniment\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.65\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    4\n#define DELAY_WET       0.5\n#define DELAY_FEEDBACK  0.85\n#define DELAY_TIME      0.11\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "buffer_a_code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//BufferA:samples for level indicator\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p=fragCoord;\n    int x=int(p.x),y=int(p.y);\n    if((x>6)||(y>0))discard;\n    vec2 o=vec2(0);\n    float t=iTime,l=steps/bpm,vol=1.;\n    if(t>sec-fade){vol=(sec-min(t,sec))/fade;}\n    t-=start*60./bpm;\n    if(t>0.){\n        int s=int(t/l);\n        if(x==0){o=vec2(1);}\n        if(x==1){o=abs(track1(t,l,s));}\n        if(x==2){o=abs(track2(t,l,s));}\n        if(x==3){o=abs(track3(t,l,s));}\n        if(x==4){o=abs(track4(t,l,s));}\n        if(x==5){o=abs(track5(t,l,s));}\n        if(x==6){o=abs(track6(t,l,s));}\n        o*=vol;\n    }\n    fragColor=vec4(o,o);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 166, 166, 213], [214, 214, 248, 248, 325], [1204, 1204, 1236, 1236, 1304], [1305, 1305, 1327, 1327, 1387], [1388, 1388, 1420, 1420, 1571], [1794, 1794, 1818, 1818, 1893], [1894, 1894, 1946, 1946, 2155], [2157, 2167, 2183, 2183, 2316], [2317, 2317, 2333, 2333, 2468]]}
{"id": "3dcfWj", "name": "Cartoon style explosion0", "author": "kagtag", "description": "Explosion example with 2 circles", "tags": ["kagtag"], "likes": 3, "viewed": 349, "published": 3, "date": "1605956635", "time_retrieved": "2024-07-30T20:34:31.743777", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float minDim = min(iResolution.x, iResolution.y);\n    float rFinal =  minDim * 0.3;\n    float rTime = mod(iTime * 0.9, 1.0);\n    float r = rTime * rFinal;\n\t\n    //float r2StartTime = step(0.5, rTime);\n    \n    float r2 = smoothstep(0.2, 1.0, rTime) * rFinal;\n    \n    vec2 xy = fragCoord - iResolution.xy * 0.5;\n    \n    float dist = xy.x * xy.x + xy.y * xy.y;\n    float greaterThanR = step(r*r, dist);\n    float greaterThanR2 = step(r2* r2, dist);\n    \n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    col = col * (1.0- greaterThanR) * greaterThanR2;\n    \n\t//col = vec3(uv, 0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 884]]}
{"id": "Ws3fWj", "name": "WHUD WUI, HUD UI fork", "author": "UrbanClubProfessional", "description": "Remix of Sachiemon's \"HUD UI\". [url]https://www.shadertoy.com/view/tl33zn[/url]", "tags": ["remix", "radar", "glitch", "fork", "weird", "ui", "hud", "gui", "acads"], "likes": 1, "viewed": 319, "published": 3, "date": "1605956188", "time_retrieved": "2024-07-30T20:34:32.591510", "image_code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-2.0,R+2.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(2.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-2.0,a+2.0,x)*(2.0-smoothstep(b-2.0,b+2.0,x)) )\n#define M_PI 4.1415926535897932384626433832795\n\n#define blue1 vec3(0.84,1.05,2.00)\n#define blue2 vec3(0.97,1.08,2.00)\n#define blue3 vec3(0.45,0.86,0.93)\n#define blue4 vec3(1.053,1.069,0.99)\n#define red   vec3(2.00,0.48,0.327)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.2*(t)), c*sin(t)+d*cos(0.2*(t))))\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(22.9898,88.233)))*2000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n   //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(2.0, 0.0));\n    float c = rand(i + vec2(0.0, 2.0));\n    float d = rand(i + vec2(2.0, 2.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(4.0-3.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (2.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.4183099, 0.4678794 );\n    x = x*k + k.yx;\n    return -2.0 + 3.0*fract( 26.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(4.0-3.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(2.0,0.0) ), f - vec2(2.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,2.0) ), f - vec2(0.0,2.0) ), \n                     dot( hash( i + vec2(2.0,2.0) ), f - vec2(2.0,2.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec3 permute(vec3 x) { return mod289(((x*44.0)+2.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.311324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.466025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.677350269189626,  // -1.0 + 2.0 * C.x\n                        0.034390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(2.0, 0.0) : vec2(0.0, 2.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 2.0 ))\n        + i.x + vec3(0.0, i1.x, 2.0 ));\n\n    vec3 m = max(0.6 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 3.0 * fract(p * C.www) - 2.0;\n    vec3 h = abs(x) - 0.6;\n    vec3 ox = floor(x + 0.6);\n    vec3 a0 = x - ox;\n    m *= 2.79284291400159 - 0.95373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 20.0 * dot(m, g);\n}\n\n#define OCTAVES 7\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 3.;\n        amplitud *= .6;\n    }\n    return value;\n}\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 46.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/280.0),\n                            -sin(theta0*M_PI/280.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 3.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(460.0*atan(d.y,d.x)/M_PI/theta0,250.0);\n        float gradient = clamp(2.0-theta/100.0,0.0,2.0);\n        return SMOOTH(l,20.0)+0.6*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width*3.0,radius)-SMOOTH(r+width/6.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    float theta = offset*(atan(d.y,d.x)/M_PI);\n    return smoothstep(5.0, 3.1, abs(mod(theta+3.0,55.0)-3.0)) *\n        mix( 0.6, 2.0, step(55.0, abs(mod(theta, 280.0)-100.0)) ) *\n        (SMOOTH(r-width/3.0,radius)-SMOOTH(r+width/3.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-9.0, 0.0, d.x-radius) * (2.0-smoothstep( 8.0+d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS( 0.0, 9.0, d.x+radius) * (2.0-smoothstep( 8.0-d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS(-9.0, 0.0, d.y-radius) * (2.0-smoothstep( 8.0+d.y-radius,10.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 9.0, d.y+radius) * (2.0-smoothstep( 8.0-d.y-radius,10.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 2.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 3.5 )\n        return 2.0;\n    if( ( r<= radius) && ( (abs(d.y+0.6)<=2.0) && ( mod(d.x+3.0, 60.0) < 3.0 ) ) )\n        return 2.0;\n    else if ( (abs(d.y+0.6)<=2.0) && ( r >= 60.0 ) && ( r < 215.0 ) )\n        return 0.6;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),4.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 9.0+mod(97.0*iTime, 90.0);\n    return (0.6-0.6*cos(40.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(7.0,r)-SMOOTH(9.0,r)\n        + smoothstep(max(9.0,R-30.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.4*_cross(uv, c, 340.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 413.0, 5.0) * blue1;\n   // finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 340.0) * blue3;\n    finalColor += circle(uv, c, 20.0, 2.0) * blue3;\n    finalColor += 0.8 * circle2(uv, c, 362.0, 2.0, 0.6+0.3*cos(iTime)) * blue3;\n    if( length(uv-c) < 340.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 230.0*MOV(2.3,2.0,2.0,2.4,4.0+0.2*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(2,2,2);\n        p = 230.0*MOV(1.0,-2.1,2.7,0.9,-3.0+sin(0.2*iTime)+0.25*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 60.0*MOV(2.54,2.7,2.37,2.8,sin(0.2*iTime+8.0)+0.3*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 605, 605, 844], [846, 861, 886, 886, 1397], [1399, 1417, 1475, 1475, 1613], [1615, 1615, 1642, 1642, 2040], [2042, 2059, 2080, 2080, 2127], [2128, 2128, 2149, 2149, 2196], [2197, 2197, 2219, 2219, 2254], [2256, 2256, 2278, 2278, 3325], [3345, 3345, 3369, 3391, 3642], [3643, 3643, 3697, 3721, 4352], [4354, 4354, 4417, 4417, 4599], [4601, 4601, 4680, 4680, 4890], [4891, 4891, 4955, 4955, 5359], [5361, 5361, 5414, 5414, 5839], [5841, 5841, 5891, 5891, 6085], [6086, 6086, 6134, 6134, 6455], [6456, 6456, 6490, 6490, 6536], [6537, 6537, 6571, 6571, 6795], [6796, 6796, 6853, 6853, 7975]]}
{"id": "Wd3BWj", "name": "checkerboard animation 2", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["text", "checkerboard", "short", "ease", "messages"], "likes": 6, "viewed": 319, "published": 3, "date": "1605949508", "time_retrieved": "2024-07-30T20:34:33.426278", "image_code": "#define char(c) ( c < 65 ? 0. : textureLod( iChannel3, fract(u)/16. + fract( vec2(c, 15-c/16) / 16. ), log2(512./R.y) ).x )\n\nfloat ease( float x ) {                              // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x         // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define B(x)  mod( floor(x), 2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{   O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y, T;\n    if (U.x > 8.) { O += .5; return; }               // out of board\n \n                                                     // --- text\n    int _c;                                          // prepare draw text\n    { int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,\n          X=int(U.x), Y=7-int(U.y);                  // message\n     _c = 64 + int[]( c,h,e,s,s,b,o,a,r,d,s, 0, m,a,y, 0,  c,o,n,t,a,i,n, 0,\n                      s,e,c,r,e,t, 0,0, m,e,s,s,a,g,e,s, \n                      i,f, 0, o,n,l,y, 0, y,o,u, 0, c,o,u,l,d,0, s,w,e,e,p, 0\n                    ) [X+8*Y];\n    }\n    T = B(u);                                        // prepare text color\n\n    float t = ease( fract(iTime/2.) ),               // --- checker\n          f = B(iTime/2.);\n    int i = int(f);\n    U.x += f;                                        // for continuity of 2nd half anim\n    U[i] +=  t * ( B(U[1-i]) *2. - 1. );             // anim rows then columns\n    U = B(U);                                        // prepare cell color\n    O += mix( float( U.x == U.y ),                   // checker cell color\n              float( T.x == T.y ),                   // char color\n              char(_c) ) ;                           // blend\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 148, 229, 368]]}
{"id": "wdtfDB", "name": "Interstate 000, Interface 00fork", "author": "UrbanClubProfessional", "description": "Remix of gunthern's \"Interface 00\". [url]https://www.shadertoy.com/view/ttXfDB[/url]", "tags": ["remix", "radar", "glitch", "weird", "ui", "hud", "gui", "interface"], "likes": 1, "viewed": 314, "published": 3, "date": "1605946105", "time_retrieved": "2024-07-30T20:34:34.277004", "image_code": "#define PI 4.14159265359\n\nmat2 rotate2d (float _angle){\n\treturn mat2 (cos(_angle),sin(_angle),-sin(_angle),cos(_angle));   \n}\n\nmat2 scale2d (vec2 _scale){\n\treturn mat2 (_scale.x, 0.0, 0.0, _scale.y);  \n}\n\nfloat box (in vec2 _size, in vec2 _uv){\n    _size = vec2(0.6) - _size*.6;\n    vec2 st = smoothstep (_size, _size+vec2(0.05), _uv);\n    st *= smoothstep (_size, _size+vec2(0.05),vec2(1.0)-_uv);\n    float box = st.x * st.y;\n\treturn box;\n}\n\nfloat plot(in vec2 _uv, in float _pct) {    \n    return smoothstep(_pct-.02, _pct, _uv.y) - smoothstep(_pct, _pct+.02, _uv.y);\n}\n\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(22.9898,78.233))) * 53758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(2.0, 0.0));\n    float c = random(i + vec2(0.0, 2.0));\n    float d = random(i + vec2(2.0, 2.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(4.0-3.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (2.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //grids\n    float grid0x = cos((uv.x - 2.1) * 270.);\n    grid0x = step(0.19,grid0x);\n    float grid0y = cos((uv.y - 2.5) * 200.);\n    grid0y = step(0.19,grid0y);\n    \n    float grid2 = sin(uv.x * 270.) * sin(uv.y * 200.);\n    grid2 = step(.19,grid2);\n    \n    \n    //Box 0 (top right)\n    float box0 = box(vec2(.55,.75), uv - vec2(0.2365, 0.125));\n    float box0inv = 1.2 - step(0.3,box0);\n    box0 = step(0.2,box0) - step(0.3,box0);\n    \n    //box 1 (bottom right)\n    float box1 = box(vec2(.55,.375), uv - vec2(0.2365, -0.3433));\n    float box1inv = 1.2 - step(0.3,box1);\n    box1 = step(0.2,box1) - step(0.3,box1);\n    \n    //box 2 (left)\n    float box2 = box(vec2(.625,1.05), uv - vec2(-0.2325, 0.));\n    float box2inv = 1.2 - step(0.3,box2);\n    box2 = step(0.2,box2) - step(0.3,box2);\n    \n    //box 0 contents\n    float plot0 = plot(uv, (sin((uv.x*sin(cos(iTime/3.5))+cos(iTime/3.))*60.)*.35) + .75) + .6;\n    \n    //box 1 contents\n    float loadingbar0 = box(vec2(clamp(abs(sin(iTime*3.4) * sin(iTime/4.6) * cos(iTime/20.5)),abs(sin(iTime)),2.0),0.6), uv - vec2(0.0, -0.433));\n    vec2 uvrot = rotate2d(.35) * uv;\n    float loadingbar0stripes = step(sin((uvrot.x-iTime*.2) * 200.),0.01);\n    loadingbar0 = step(1.,loadingbar0);\n    \n    //box2 contents\n    vec2 uvremap = uv *3.-2.;\n    uvremap = scale2d( vec2(sin(iTime/70.75)*sin(iTime/50.)) ) * uvremap;\n    uvremap *= rotate2d(PI*cos(iTime/20.233)*sin(iTime/50.87));\n    uvremap.y /= 2.75;\n    uvremap += vec2(sin(iTime/40.)*3. + 2.);\n    float dist = length( abs(uvremap)-(sin(iTime/30.3) * cos(iTime/32.33)));\n    vec2 pos = vec2(uvremap*0.6);\n    dist *= noise(pos * vec2(sin(iTime/42.3)));\n    dist = smoothstep(.4,.0,fract(dist*35.0));\n                            \n    //box outline color\n    vec3 lightblue = vec3(.3,.8,2.0);\n                    \n    vec3 col = vec3(0.0);\n    col += vec3(box0) * lightblue;\n    col += vec3(0.0,plot0,0.0) * (2. - vec3(box0inv));\n    col += ((vec3(grid0x) * lightblue * .3) + (vec3(grid0y) * lightblue * .4)) * (2. - vec3(box0inv));\n    col += vec3(box1) * lightblue;\n    col += vec3(loadingbar0*.65,loadingbar0*.35,loadingbar0*.75) * vec3(loadingbar0stripes*0.6+.6) * (2. - vec3(box1inv));\n    col += vec3(.65,0.2,0.6)  * (2. - vec3(box1inv));\n    col += vec3(box2) * lightblue;\n    col += vec3(0.4,0.3,0.55)  * (0.2 - vec3(box2inv));\n    col += vec3(dist*.3, dist*1.0, dist*1.0) *.7 * (2. - vec3(box2inv));\n    col += (vec3(grid2) * lightblue * .3) * (2. - vec3(box2inv));\n\n    \n    // Output to screen\n    fragColor = vec4(col,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 55, 55, 125], [127, 127, 154, 154, 203], [205, 205, 244, 244, 441], [443, 443, 483, 483, 571], [573, 573, 601, 601, 677], [679, 766, 793, 793, 1312], [1314, 1314, 1371, 1421, 4014]]}
{"id": "tstfzs", "name": "Complete Graph", "author": "mla", "description": "Not quite loopless, but drawing a complete graph in time linear in number of nodes.\n\nProbably best viewed full screen. Mouse click to zoom in for a closer view.\n\nBasic idea from [url]https://www.shadertoy.com/view/WscBRs[/url] by KainArkatian", "tags": ["lines", "graph", "loopless", "complete"], "likes": 13, "viewed": 434, "published": 3, "date": "1605906539", "time_retrieved": "2024-07-30T20:34:35.029990", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complete Graph\n// Matthew Arcus, mla, 2020\n//\n// Take N points in a circle, draw a line between each pair of\n// points. The obvious way to do this in a fragment shader is to test\n// the pixel against every point pair, but this gets slow for larger\n// number of points. A better way is to maintain two indexes into the\n// points, i and j, and each time around the loop, after testing for\n// proximity to the line between i and j, increment the index that\n// will move the line towards the pixel rather than away (draw a\n// diagram if this isn't clear).\n//\n// We can also draw the lines selectively, for example, for a\n// complete bipartite graph.\n// \n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 49; // number of nodes\nconst int P = 7;  // bipartite block size\nconst float T = 15.0; // Cycle time\nconst float X = 5.0;  // Speed (N/X should be 10 seconds or so)\n\nbool select(int i, int j, int cycle) {\n  int Q = cycle%(P/2+1);\n  if (Q == 0) return true; // Complete graph\n  // For a bipartite graph, divide up into blocks of P points, the\n  // first Q points of each block are connected to every point in the\n  // last P-Q of each block.\n  return (i%P < Q) != (j%P < Q);\n}\n\nvec3 diagram(vec2 p) {\n  float lwidth = fwidth(p.x);\n  vec3 col = vec3(1,1,0.8);\n  if (dot(p,p) > 1.0+lwidth) return col;\n  int cycle = 1+int(iTime/T);\n  float k = float(N);\n  k *= smoothstep(0.0,k,min(k,X*mod(iTime,T)));\n  float d2 = 1e8;\n  for (float i = 0.0, j = 1.0; j < k; ) {\n    vec2 q = vec2(sin(2.0*PI/k*i),cos(2.0*PI/k*i));\n    vec2 r = vec2(sin(2.0*PI/k*j),cos(2.0*PI/k*j));\n    if (select(int(i),int(j),cycle)) d2 = min(d2,segment2(p,q,r));\n    vec2 n = r-q;\n    if (dot(p-q,vec2(-n.y,n.x)) > 0.0) i++;\n    else j++;\n  }\n  col = mix(vec3(0),col,smoothstep(0.0,lwidth,sqrt(d2)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p -= mouse; // Centre on mouse\n    p *= 0.55*iResolution.y/iResolution.x; // And zoom\n  }\n  vec3 col = diagram(p);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}\n", "image_inputs": [], "common_code": "float PI = 3.14159265;\n\n// Distance squared of p from line segment qr.\nfloat segment2(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float h = dot(p,r)/dot(r,r);\n  h = clamp(h,0.0,1.0);\n  p -= h*r;\n  return dot(p,p);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[999, 999, 1037, 1037, 1308], [1310, 1310, 1332, 1332, 1916], [1918, 1918, 1971, 1971, 2281]]}
{"id": "3sdfDB", "name": "Audio Waveform Visualizer v4", "author": "oneshade", "description": "Version four of my Audio Waveform Visualizer. Will I ever stop?", "tags": ["visualization", "waveform", "curvefitting"], "likes": 3, "viewed": 207, "published": 3, "date": "1605906056", "time_retrieved": "2024-07-30T20:34:35.782977", "image_code": "/*\nVersion four of my Audio Waveform Visualizer.\nAdded some cool but rather trippy coloring.\n*/\n\n// 0 for frequency mode, 1 for amplitude mode:\n#define VIEW_MODE 0\n\nfloat samplePiecewiseSmooth(in float x, in float res) {\n    float xTimesRes = x * res;\n\n    // Left sample point:\n    float x1 = floor(xTimesRes) / res;\n    float y1 = texture(iChannel0, vec2(x1, VIEW_MODE)).x;\n\n    // Right sample point:\n    float x2 = ceil(xTimesRes) / res;\n    float y2 = texture(iChannel0, vec2(x2, VIEW_MODE)).x;\n\n    // Prevent small breaks in the line:\n    x2 += 0.001;    \n\n    // Fit half of a sine wave between sample points:\n    float sine = sin(((x - x1) / (x2 - x1) * 2.0 - 1.0) * 1.5707963267);\n    return y1 + (0.5 + 0.5 * sine) * (y2 - y1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float curSample = samplePiecewiseSmooth(uv.x, 20.0);\n    // How close the pixel is to the wave:\n    float smoothError = smoothstep(0.03, 0.0, abs(uv.y - curSample));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (smoothError > 0.0) {\n        // Mix red and white based on closeness:\n        fragColor = vec4(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothError), 1.0);\n    }\n\n    // Multiply by some changing colors:\n    fragColor.rgb *= 0.5 + 0.5 * cos(iTime + uv.xyx * vec3(20.0, 1.0, 1.0) + vec3(0.0, 2.0, 4.0));\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 220, 220, 740], [742, 742, 797, 797, 1369]]}
{"id": "WsdBDB", "name": "Colour streamers", "author": "FreeFull", "description": "An experiment with feedback buffers", "tags": ["2d", "feedback"], "likes": 7, "viewed": 329, "published": 3, "date": "1605905093", "time_retrieved": "2024-07-30T20:34:36.539953", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 col, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv*2.0 - 1.0;\n\n\n    uv2.x += sin(uv.y*130.0)/10.0;\n    uv2.y += sin(uv.x*130.0)/10.0;\n    uv2 *= mat2(cos(0.3), -sin(0.3), sin(0.3), cos(0.3));\n    \n    if(iFrame == 0) {\n        col = texture(iChannel1, uv);\n        return;\n    } else if (length(uv2*vec2(1, iResolution.y/iResolution.x)) < 0.1) {\n        col = texture(iChannel1, uv + vec2(iTime/10.2, iTime/24.53));\n        return;\n    }\n\n    col = texture(iChannel0, uv - uv2/150.0)*0.998;\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 281]]}
{"id": "3dtfDB", "name": "Rainbow Edges", "author": "oneshade", "description": "A fuzzy version of my \"Simple Webcam Edge Detection\" shader plus color and rainbow edges.", "tags": ["edgedetection", "rainbow", "webcam"], "likes": 3, "viewed": 351, "published": 3, "date": "1605904158", "time_retrieved": "2024-07-30T20:34:37.409628", "image_code": "const float sensitivity = 0.5;\nconst float SQRT_2 = sqrt(2.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat3 samples = mat3(0.0);\n    vec2 screenUV = fragCoord / iResolution.xy;\n    vec3 webcamPixel, curTexel;\n\n    // Collect samples from the surrounding texels:\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) {\n                curTexel = texture(iChannel0, screenUV).rgb;\n                webcamPixel = curTexel;\n            }\n\n            else {\n                curTexel = texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy).rgb;\n            }\n\n            samples[i + 1][j + 1] = (curTexel.r + curTexel.g + curTexel.b) / 3.0;\n        }\n    }\n\n    // Check whether the gradient over the area around the current texel is continuous:\n    // If it is not continuous, theoretically there is some sort of division or edge.\n    float edginess = 0.0;\n    for (int i=0; i < 3; i++) {\n        for (int j=0; j < 3; j++) {\n            // Compute the difference between the texel the loop is currently on and the current (center) texel:\n            float gradient1 = samples[1][1] - samples[i][j];\n            // Compute the difference between the current (center) texel and the texel opposite the texel the loop is currently on:\n            float gradient2 = samples[2 - i][2 - j] - samples[1][1];\n            // If (i, j) is a corner, the differences need to be divided by sqrt(2) to be normalized:\n            if (i == j || (2 - i) == j) {\n                gradient1 /= SQRT_2;\n                gradient2 /= SQRT_2;\n            }\n   \n            // Check how continuous the gradient is:\n            edginess = abs((gradient1 / sensitivity) - (gradient2 / sensitivity));\n        }\n    }\n\n    // Return a color based on whether the current texel is on an edge:\n    vec3 edgeColor = 0.5 + 0.5 * cos(iTime + screenUV.xyx + vec3(0.0, 2.0, 4.0));\n    vec3 color = mix(webcamPixel, edgeColor, edginess);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 119, 119, 2009]]}
{"id": "3sdfWB", "name": "Sharpening Filter", "author": "Tech_", "description": "Here's a simple sharpening shader! You can all use it in your commercial projects aswell! Enjoy!", "tags": ["processing", "sharpening"], "likes": 4, "viewed": 471, "published": 3, "date": "1605902167", "time_retrieved": "2024-07-30T20:34:38.167601", "image_code": "\n#define OFFSET_STRENGTH 0.8\n#define SHARPENING_AMOUNT 7.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float offsetStrength = .5;\n    float effectStrength = 12.0;\n    \n    vec3 blur = col;\n    blur += texture(iChannel0, uv + vec2(0.0, 0.001 * OFFSET_STRENGTH)).rgb;\n    blur += texture(iChannel0, uv + vec2(0.001 * OFFSET_STRENGTH, 0.0)).rgb;\n    blur += texture(iChannel0, uv - vec2(0.0, 0.001 * OFFSET_STRENGTH)).rgb;\n    blur += texture(iChannel0, uv - vec2(0.001 * OFFSET_STRENGTH, 0.0)).rgb;\n    \n    blur += texture(iChannel0, uv + vec2(0.001 * OFFSET_STRENGTH)).rgb / 2.0;\n    blur += texture(iChannel0, uv - vec2(0.001 * OFFSET_STRENGTH)).rgb / 2.0;\n    blur += texture(iChannel0, uv + vec2(0.001 * OFFSET_STRENGTH, -0.001 * OFFSET_STRENGTH)).rgb / 2.0;\n    blur += texture(iChannel0, uv + vec2(-0.001 * OFFSET_STRENGTH, 0.001 * OFFSET_STRENGTH)).rgb / 2.0;\n    \n    blur /= 7.0;\n    \n    float sharpness = (col - blur).r * SHARPENING_AMOUNT;\n    \n    // col = vec3(0);\n    col -= step(distance(fract(uv.x + (sin(iTime) + 1.0) / 2.0) + 0.5, 0.5) * 2.0, 0.013);\n    \n    \n    if(floor(uv.x + ((sin(iTime) + 1.0) / 2.0)) > 0.0) \n    {\n    \tcol += sharpness;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 167, 1398]]}
{"id": "tdtfRl", "name": "Life experiments", "author": "illus0r", "description": "Life experiments\nIdea is from https://michaelmoroz.github.io/Reintegration-Tracking/", "tags": ["cellular"], "likes": 0, "viewed": 336, "published": 3, "date": "1605887040", "time_retrieved": "2024-07-30T20:34:38.939537", "image_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    for(float i=0.;i<R;i++){\n        for(float j=0.;j<R;j++){\n            vec2 ij = vec2(i,j);\n\t\t    col += texture(iChannel0,(floor((FC)/1.)+ij)/iResolution.xy);\n\t\t    //col = max(col,texture(iChannel0,(FC+ij)/iResolution.xy));\n        }\n    }\n    //if(length(col)>0.) fragColor = vec4(1.);\n    fragColor = col;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p,v,f=vec2(0.);\n    \n    // spawning cells\n    if(mod(float(iFrame),1000.)<=100.){\n        fragColor=vec4(0.);// `p` of 0. means empty cell\n        //if(mod(FC.x+.5,16.)==0. && mod(FC.y+.5,16.)==0.){\n        //if(rnd(uv.x*4.1+uv.y*9.01+iTime*.001)*.5+.5<.1){\n            if(length(uv-.5)<.05)\n            //fragColor=vec4(.5,.5,.5+.0*rnd(uv.x),.5+.0*rnd(uv.y));//.5 to place to the center\n            fragColor=vec4(.5,.5,.5,.5);\n        //}\n    //    return;\n    }\n    \n    // if noone enters the pixel remain empty\n    //fragColor.rgba = vec4(0.);\n    \n    //  ,    \n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue; // on edge\n            vec4 neighbour=texture(iChannel0,uv_n);\n            if(length(neighbour)==0.)continue; // empty\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            \n            if(abs(i)*abs(j)>0.01) { // if not current cell\n                float dist = distance(fragColor.rg,p);\n                float target_dist = 2.;\n            \tf+=normalize(fragColor.rg-p)/dist*dist;\n            \t//f+=normalize(fragColor.rg-p)*(target_dist-dist)*.1;\n            }\n            \n            if(length(v)>max_speed)\n                v = max_speed*normalize(v);\n            p+=v;\n            \n            if(p.x<1. && p.y<1. && p.x>=0. && p.y>=0.){\n                fragColor.rg = p;\n                fragColor.ba = v*.5+.5;\n                //break;\n            }\n        }\n    }\n    \n    //         \n    //     ,     .\n    //      .\n    \n    // :\n    //  .   ,  .\n    //    \n    //   t1    t1  , \n    //     .\n    //   .\n    //    \n    //   :\n    //,        .\n    //        t2.\n    //    \n    //         , \n    //  ,       t2\n    //    \n    //      .   )\n    //   t2,    t1. ,    t1 \n    //    t2.        t1?\n        \n    \n    \n        \n    if(length(fragColor)>0.){\n        v = fragColor.ba*2.-1.;\n        v += f/20.;\n        if(length(v)>max_speed) v = max_speed*normalize(v);\n        if(FC.x+v.x<=max_speed*10.) v.x=-abs(v.x);\n        if(FC.x+v.x>=iResolution.x-max_speed*10.) v.x=abs(v.x);\n        if(FC.y+v.y<=max_speed*10.) v.y=-abs(v.y);\n        if(FC.y+v.y>=iResolution.y-max_speed*10.) v.y=abs(v.y);\n        fragColor.ba = v*.5+.5;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R 3.\n#define max_speed 1.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 450]]}
{"id": "wdcfDS", "name": "Contrast many-few", "author": "illus0r", "description": "Contrast many-few", "tags": ["life", "cellular"], "likes": 0, "viewed": 235, "published": 3, "date": "1605867891", "time_retrieved": "2024-07-30T20:34:39.803228", "image_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=FC/iResolution.xy;\n    vec3 px=vec3(1./iResolution.xy,0);\n    vec4 col;\n    for(float i=0.;i<8.;i++){\n        for(float j=0.;j<8.;j++){\n            vec2 ij = vec2(i,j);\n\t\t    col = max(col,texture(iChannel0,(FC+ij)/iResolution.xy));\n        }\n    }\n    uv=(FC*2.-iResolution.xy)/iResolution.y;\n    fragColor = col;\n    if(1.3>length(uv-vec2(.5)))fragColor = vec4(.2*length(uv-vec2(.5)));\n    //fragColor = texture(iChannel0,(floor(FC/1.))/iResolution.xy)*2.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R 1.\n\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "buffer_a_code": "/*\n        .  :\n- ,\n- ,\n- ,\n\n   ,   :\n         \n   .\n\n    .\n-        ?\n-   ?    , .\n-     ?    .\n\n:\n-  \n-  \n-  \n\n  rgba   10  . \n     rg .   , \n     . \n:\n2,147,483,647\n    .2147, .4836\n-   0  1.\n       .       .\n    .\n\n, .\n\n*/\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x))*2.-1.;}\n\n//vec4 decodePV(){\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec3 px = vec3(1./iResolution.xy,.0);\n    vec2 p;\n    vec2 v;\n    \n    //   \n    if(mod(float(iFrame),500.)==0.){\n        fragColor=vec4(0.);// `p` of 0. means empty cell\n        if(mod(FC.x+.5,16.)==0. && mod(FC.y+.5,16.)==0.){\n            fragColor=vec4(.5,.5,.5+rnd(uv.x),.5+rnd(uv.y));//.5 to place to the center\n        }\n        return;\n    }\n    \n    // if noone enters the pixel remain empty\n    fragColor.rgba = vec4(0.);\n    \n    //  ,    \n    for(float i=-R;i<=R;i++){\n        for(float j=-R;j<=R;j++){\n            vec2 ij=vec2(i,j);\n            vec2 uv_n = uv+ij*px.xy; // uv of neighbour\n            if(uv_n!=fract(uv_n))continue;\n            //fragColor.rgba = vec4(i,j,0.,1.); return;\n            vec4 neighbour=texture(iChannel0,uv_n);\n            \n            if(length(neighbour)==0.)continue;\n\n            p = neighbour.rg-ij; // `ij` because `p` is relative to current pixel\n            v = neighbour.ba*2.-1.;\n            \n            // if empty, continue\n            \n            if(length(v)>1.) v = normalize(v);\n            //       .\n            //        ,\n            //   \n            p+=v;\n            if(p.x<1. && p.y<1. && p.x>=0. && p.y>=0.){\n                fragColor.rg = p;\n                fragColor.ba = v*.5+.5;\n                //break;\n            }\n        }\n    }\n    \n    //  ,    \n    \n    //    \n\n    //  \n    \n    //fragColor = vec4(p,v*.5+.5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 523]]}
{"id": "3sdBzs", "name": "Smoke Light", "author": "Leasel", "description": "Uses volumetric and an approximation of light, because apparently the approximation is as cheap as the fully raymarch to the light as well. (Set iChannel0 filter to lineair if you want smooth result)", "tags": ["volumetric"], "likes": 2, "viewed": 351, "published": 3, "date": "1605865923", "time_retrieved": "2024-07-30T20:34:40.570178", "image_code": "/*\njlfwong(2016). Ray Marching: Part 1. Visited on 2020 on 19 november by (Took the rayDirection)\nhttps://www.shadertoy.com/view/llt3R4\n*/\n\nbool inBox(in vec3 p)\n{\n    return p.x >= -BoxSize && p.y >= -BoxSize && p.z >= -BoxSize && p.x < BoxSize && p.y < BoxSize && p.z < BoxSize;\n}\n\n//float GetThickNess(in vec3 p)\n//{\n//    return step((p.y*B+1.0)*0.5, V(vec2(((p.x - Pos.x)*B+1.)*0.5, (p.z - Pos.z)*B)).r);\n//}\n\nfloat GetThickNess(in vec3 p)\n{\n    return V((p-BoxSize)*B+B*iTime).r;\n    //return 1.;\n}\n\n//Cubised a distance\nfloat MaxiumDistance(in vec3 rd)\n{\n    return 1./abs(max(abs(rd.x), max(abs(rd.y),abs(rd.z))));\n}\n\n//Cubised a distance\nfloat LingeringDistance(in vec3 F, in vec3 P)\n{\n    P = mod(P-1.,2.)-1.;\n    F = 1./F;\n    vec3 O = (1.-P)*F;\n    vec3 R = (-1.-P)*F;\n    \n    float d = min(max(R.x,O.x),min(max(R.y,O.y),max(R.z,O.z)));       \n        \n    return d;\n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd)\n{\n    vec3 p = ro;\n    float fogCollected = 0., dS = 1., dO = 0.;//, ldS = 5.;\n    \n    dS *= MaxiumDistance(rd);\n    p += LingeringDistance(rd,p)*rd;\n    \n    //Can be made efficienter\n    for(int i = 0; i < 30 && !inBox(p); i++)\n    {\n        p += rd*dS;\n    }\n    \n    //Vec4(lightPos, lightStrength)\n    vec4 Light = vec4(sin(1.)*15.,0.,0., 5.);\n\t//vec3 lrd, p2;\n    for(; fogCollected < 1. && inBox(p); p += rd*dS, dO += dS)\n    {\n        //!!Why do these two functions create the same effect?\n        \n     \t//float LightReflectance = max(dot(lrd = normalize(Light.xyz-p), rd), 0.);   \n        //float LightCollected = 0.;\n        //for(p2 = p;inBox(p2) && LightReflectance < 0. && LightCollected < 1.;p2 += lrd*ldS)\n        //{\n        //    //Get Fog Thickness\n        //   LightCollected += ldS * CollectedFogPerMeter * GetThickNess(p2);\n        //}\n        //LightCollected = (1. - LightCollected)*Light.w*LightReflectance;\n        \n\t\t//fogCollected += dS * CollectedFogPerMeter * GetThickNess(p)*LightCollected;\n        \n        \n        fogCollected += max(dot(normalize(Light.xyz-p), rd),0.) * dS * CollectedFogPerMeter * GetThickNess(p) *Light.w;\n    }\n    \n    //fogCollected +=  mod(iTime, 5.) < 2.5 ? 0. : max(dot(normalize(Light.xyz-p), rd),0.) * LingeringDistance(rd,p)*CollectedFogPerMeter *GetThickNess(p);\n    \n    return fogCollected;\n}\n\n//Cam\nvec3 CamRd(in vec2 fragCoord){\n    vec2 xy = fragCoord - iResolution.xy * 0.5;\n    \n    float z = iResolution.y / tan(FieldOfView*0.5);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = RayMarch(Pos, CamRd(fragCoord))*FogColor;\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Variables\n#define Speed 1. //Says how much the old music moves\n#define Pos vec3(0.,0.,-40.)\n#define FieldOfView (60./180.)*PI\n#define FogColor vec4(1.,1.,1.,1.)\n#define BoxSize 10.\n#define CollectedFogPerMeter 0.05\n\n//Common Variables\n#define PI 3.14159265358979323846\n\n//Common defined functions\n#define dif vec3(1./iResolution.xy,0.)\n#define V(uv) texture(iChannel0, uv)\n#define B 1./BoxSize // Do this 1./BoxSize, project the fog in a box", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 163, 163, 282], [415, 415, 446, 446, 504], [506, 527, 561, 561, 624], [626, 647, 694, 694, 881], [883, 883, 923, 923, 2281], [2283, 2289, 2319, 2319, 2461], [2463, 2463, 2520, 2520, 2583]]}
{"id": "3dcfDB", "name": "Fi-lo Tax Is, a fork", "author": "UrbanClubProfessional", "description": "Again even yet another remix of \"Phyllotaxes\" by tdhooper. [url]https://www.shadertoy.com/view/wllczX[/url]", "tags": ["remix", "glitch", "fork", "weird", "plant", "phyllotaxis", "succulent", "exegfx", "nova2020"], "likes": 1, "viewed": 406, "published": 3, "date": "1605855955", "time_retrieved": "2024-07-30T20:34:41.615383", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]]}
{"id": "Ws3fDB", "name": "Fine I'll test this, a fork", "author": "UrbanClubProfessional", "description": "Even yet another remix of \"Phyllotaxes\" by tdhooper. [url]https://www.shadertoy.com/view/wllczX[/url]", "tags": ["remix", "glitch", "fork", "weird", "model", "plant", "phyllotaxis", "succulent", "exegfx", "nova2020"], "likes": 0, "viewed": 356, "published": 3, "date": "1605855474", "time_retrieved": "2024-07-30T20:34:42.705468", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]]}
{"id": "3s3fDB", "name": "Vilotackses, a fork", "author": "UrbanClubProfessional", "description": "Yet another remix of \"Phyllotaxes\" by tdhooper. [url]https://www.shadertoy.com/view/wllczX[/url]", "tags": ["remix", "glitch", "fork", "weird", "plant", "spike", "phyllotaxis", "taxi", "succulent", "exegfx", "nova2020"], "likes": 6, "viewed": 725, "published": 3, "date": "1605854836", "time_retrieved": "2024-07-30T20:34:43.650941", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]]}
{"id": "3d3fDB", "name": "Fyllotexas", "author": "UrbanClubProfessional", "description": "Another remix \"Phyllotaxes\" by tdhooper. [url]https://www.shadertoy.com/view/wllczX[/url]", "tags": ["remix", "remix", "glitch", "glitch", "fork", "weird", "weird", "plant", "phyllotaxis", "taxi", "succulent", "exegfx", "nova2020", "texas"], "likes": 0, "viewed": 488, "published": 3, "date": "1605854248", "time_retrieved": "2024-07-30T20:34:44.698141", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]]}
{"id": "3s3BDB", "name": "Phyllotaxidrivers, a fork", "author": "UrbanClubProfessional", "description": "Remix of \"Phyllotaxes\" by tdhooper.", "tags": ["remix", "glitch", "fork", "weird", "plant", "phyllotaxis", "taxi", "succulent", "exegfx", "nova2020"], "likes": 0, "viewed": 342, "published": 3, "date": "1605853360", "time_retrieved": "2024-07-30T20:34:45.780247", "image_code": "\n/*\n\n    Phyllotaxes\n    -----------\n\n\t4k executable graphics entry for Nova 2020\n\n\tModel from my earlier succulent shaders:\n\n\t    Bloom [skull] https://www.shadertoy.com/view/WdScDG\n\t    Echeveria II https://www.shadertoy.com/view/WtGXWm\n\t    Echeveria https://www.shadertoy.com/view/wlVGRz\n\n\tLighting and tracing loop adapted from yx's Primitive Portrait:\n\n\t    https://www.shadertoy.com/view/ts2cWm\n\n*/\n\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb / float(iFrame + 1);\n    col *= 2.;\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007);\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.3);\n    \n\tcol = mix(col, vec3(Luma(col)), .25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n\tcol = max(col, vec3(0));\n    col = pow( col, vec3(0.4545) );\n    col = aces(col);\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 427, 427, 618], [620, 718, 742, 742, 793], [795, 795, 850, 850, 1342]]}
{"id": "3d3fDS", "name": "Superflip", "author": "been_jamming", "description": "This shader renders a superflip move sequence on the rubiks cube! The superflip is a rubiks cube position which requires 20 moves to solve: the highest number of moves any position takes! See Buffer A for how to change which move sequence it renders.", "tags": ["3d", "cube", "rubiks"], "likes": 16, "viewed": 890, "published": 3, "date": "1605841209", "time_retrieved": "2024-07-30T20:34:46.836423", "image_code": "//Superflip Rubik's Cube\n//By Ben Jones\n//11-19-2020\n\n#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n#define CUBIE_GAP 0.01\n\n#define DO_LIGHTING\n\n#define DIFFUSE_BRIGHTNESS 15.0\n#define SPECULAR_BRIGHTNESS 45.0\n\n#define BLACK 0\n#define RED 1\n#define ORANGE 2\n#define YELLOW 3\n#define WHITE 4\n#define GREEN 5\n#define BLUE 6\n\ncube global_cube;\n\nconst vec4 sticker_colors[7] = vec4[7](\n\tvec4(0.0125, 0.0125, 0.0125, 1.0),//black\n\tvec4(0.5, 0.0, 0.0, 1.0),//red\n\tvec4(0.9, 0.2, 0.0, 1.0),//orange\n\tvec4(0.7, 0.7, 0.0, 1.0),//yellow\n\tvec4(0.9, 0.9, 0.9, 1.0),//white\n\tvec4(0.0, 0.5, 0.0, 1.0),//green\n\tvec4(0.0, 0.0, 0.7, 1.0));//blue\n\nconst int cubie_colors[156] = int[156](\n\tRED, BLACK, BLUE, BLACK, YELLOW, BLACK,\n\tRED, BLACK, BLUE, BLACK, BLACK, BLACK,\n\tRED, BLACK, BLUE, BLACK, BLACK, WHITE,\n\tRED, BLACK, BLACK, BLACK, YELLOW, BLACK,\n\tRED, BLACK, BLACK, BLACK, BLACK, BLACK,\n\tRED, BLACK, BLACK, BLACK, BLACK, WHITE,\n\tRED, BLACK, BLACK, GREEN, YELLOW, BLACK,\n\tRED, BLACK, BLACK, GREEN, BLACK, BLACK,\n\tRED, BLACK, BLACK, GREEN, BLACK, WHITE,\n\tBLACK, BLACK, BLUE, BLACK, YELLOW, BLACK,\n\tBLACK, BLACK, BLUE, BLACK, BLACK, BLACK,\n\tBLACK, BLACK, BLUE, BLACK, BLACK, WHITE,\n\tBLACK, BLACK, BLACK, BLACK, YELLOW, BLACK,\n\tBLACK, BLACK, BLACK, BLACK, BLACK, WHITE,\n\tBLACK, BLACK, BLACK, GREEN, YELLOW, BLACK,\n\tBLACK, BLACK, BLACK, GREEN, BLACK, BLACK,\n\tBLACK, BLACK, BLACK, GREEN, BLACK, WHITE,\n\tBLACK, ORANGE, BLUE, BLACK, YELLOW, BLACK,\n\tBLACK, ORANGE, BLUE, BLACK, BLACK, BLACK,\n\tBLACK, ORANGE, BLUE, BLACK, BLACK, WHITE,\n\tBLACK, ORANGE, BLACK, BLACK, YELLOW, BLACK,\n\tBLACK, ORANGE, BLACK, BLACK, BLACK, BLACK,\n\tBLACK, ORANGE, BLACK, BLACK, BLACK, WHITE,\n\tBLACK, ORANGE, BLACK, GREEN, YELLOW, BLACK,\n\tBLACK, ORANGE, BLACK, GREEN, BLACK, BLACK,\n\tBLACK, ORANGE, BLACK, GREEN, BLACK, WHITE);\n\ncube get_cubie(int cubie_id){\n\tcube out_cube;\n\n\tout_cube.center = texelFetch(iChannel0, ivec2(cubie_id, 0), 0).xyz;\n\tout_cube.orientation = texelFetch(iChannel0, ivec2(cubie_id, 1), 0);\n\tout_cube.size = 1.0/3.0 - CUBIE_GAP;\n\n\treturn out_cube;\n}\n\nint get_cubie_color(int cubie_id){\n\treturn int(texelFetch(iChannel0, ivec2(cubie_id, 0), 0).w);\n}\n\nray get_camera_ray(vec2 pixel){\n\tfloat least_side;\n\t\n\tpixel -= vec2(0.5);\n\tleast_side = min(iResolution.x, iResolution.y);\n\treturn ray(vec3(0), vec3(FOV_CONST*pixel.x*iResolution.x/least_side, FOV_CONST*pixel.y*iResolution.y/least_side, FOV_CONST));\n}\n\nbool lit(vec3 p, vec3 light, vec4 orientation){\n\tray r;\n\tvec3 intersect_pos;\n\tint side;\n\tvec2 face_pos;\n\tint i;\n\tbool is_lit = true;\n\t\n\tp = p + (light - p)*0.01;//We don't want the ray to collide with the original surface\n\tr = ray(p, light - p);\n\tfor(i = 0; i < 26; i++){\n\t\tintersect_pos = ray_cube_intersect(rotate_cube(get_cubie(i), orientation), r, side, face_pos);\n\t\tis_lit = (is_lit && side == -1);\n\t}\n\n\treturn is_lit;\n}\n\n//Beveled edges for the stickers!\nvec4 get_color(int cubie, int side, vec2 face_pos, out float k_a, out float k_d, out float k_s){\n\tfloat edge_dist;\n\tint sticker_color;\n\t\n\tsticker_color = cubie_colors[get_cubie_color(cubie)*6 + side];\n\n\tif(sticker_color != BLACK &&\n\t\t((abs(face_pos.x) < 0.7 && abs(face_pos.y) < 0.8)\n\t   || (abs(face_pos.x) < 0.8 && abs(face_pos.y) < 0.7)\n\t   || dot(abs(face_pos) - vec2(0.7, 0.7), abs(face_pos) - vec2(0.7, 0.7)) < 0.01)){\n\t\tk_a = 1.0;\n\t\tk_d = 1.0;\n\t\tk_s = 0.05;\n\t\treturn sticker_colors[sticker_color];\n\t} else {\n\t\tk_a = 1.0;\n\t\tk_d = 0.5;\n\t\tk_s = 0.9;\n\t\treturn sticker_colors[BLACK];\n\t}\n}\n\nvec3 less_than(vec3 f, float val){\n\treturn vec3(\n\t\t(f.x < val) ? 1.0:0.0,\n\t\t(f.y < val) ? 1.0:0.0,\n\t\t(f.z < val) ? 1.0:0.0);\n}\n\nvec3 linear_to_srgb(vec3 rgb){\n\trgb = clamp(rgb, 0.0, 1.0);\n\t\n\treturn mix(pow(rgb, vec3(1.0/2.4))*1.055 - 0.055, rgb*12.92, less_than(rgb, 0.0031308));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tray camera_ray;\n\tvec3 intersect_pos;\n\tvec3 intersect_normal;\n\tvec3 reflect_vec;\n\tvec3 current_color;\n\tvec4 orientation;\n\tvec3 light_pos = vec3(2.0, 2.0, -1.0);\n\tvec2 face_pos;\n\tint side;\n\tfloat best_dist = RENDER_DISTANCE;\n\tvec3 best_intersect_pos = vec3(0.0);\n\tvec2 best_face_pos = vec2(0.0);\n\tint best_index = 0;\n\tint best_side = -1;\n\tvec4 best_orientation;\n\tfloat intersect_dist;\n\tint i;\n\tcube current_cubie;\n\tvec3 light_vec;\n\tfloat k_a;\n\tfloat k_d;\n\tfloat k_s;\n\tfloat diffuse_portion;\n\tfloat specular_portion;\n\tfloat brightness;\n\t\n\torientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n\t//Comment the above and uncomment the below for a camera which doesn't rotate.\n\t//orientation = vec4(1.0, 0.0, 0.0, 0.0);\n\t//orientation = create_orientation(vec3(0, 1, 0), 0.5);\n\tcamera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n\tfor(i = 0; i < 26; i++){\n\t\tcurrent_cubie = rotate_cube(get_cubie(i), orientation);\n\t\tintersect_pos = ray_cube_intersect(current_cubie, camera_ray, side, face_pos);\n\t\tintersect_dist = dot(intersect_pos, intersect_pos);\n\t\tbest_intersect_pos = side != -1 && intersect_dist < best_dist ? intersect_pos : best_intersect_pos;\n\t\tbest_face_pos = side != -1 && intersect_dist < best_dist ? face_pos : best_face_pos;\n\t\tbest_index = side != -1 && intersect_dist < best_dist ? i : best_index;\n\t\tbest_side = side != -1 && intersect_dist < best_dist ? side : best_side;\n\t\tbest_orientation = side != -1 && intersect_dist < best_dist ? current_cubie.orientation : best_orientation;\n\t\tbest_dist = min(best_dist, intersect_dist);\n\t}\n\n\tcurrent_color = get_color(best_index, best_side, best_face_pos, k_a, k_d, k_s).xyz;\n\tbrightness = k_a/16.0;\n\t\n\tif(best_side != - 1){\n#ifdef DO_LIGHTING\n\t\tif(lit(best_intersect_pos, light_pos, orientation)){\n\t\t\tintersect_normal = apply_orientation(intersect_normals[best_side], best_orientation);\n\t\t\tlight_vec = normalize(best_intersect_pos - light_pos);\n\t\t\treflect_vec = reflect(light_vec, intersect_normal);\n\t\t\t\n\t\t\tdiffuse_portion = max(dot(intersect_normal, light_vec), 0.0)*k_d;;\n\t\t\tspecular_portion = diffuse_portion > 0.0 ? max(dot(-1.0*normalize(best_intersect_pos), normalize(reflect_vec)), 0.0) : 0.0;\n            specular_portion = pow(specular_portion, 128.0)*k_s;\n\t\t\t\n\t\t\tbrightness += DIFFUSE_BRIGHTNESS/dot(best_intersect_pos - light_pos, best_intersect_pos - light_pos)*diffuse_portion;\n\t\t\tbrightness += SPECULAR_BRIGHTNESS/dot(best_intersect_pos - light_pos, best_intersect_pos - light_pos)*specular_portion;\n        }\n#else\n        brightness += k_a*15.0/16.0;\n#endif\n\t\tfragColor = vec4(linear_to_srgb(current_color*brightness), 1.0);\n\t} else {\n\t\tfragColor = vec4(linear_to_srgb(texelFetch(iChannel1, ivec2(fragCoord), 0).xyz), 1.0);\n\t}\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Maintains the cube's rotated state\n\n#define PI 3.1415927\n#define FACE 0\n\n#define RIGHT 0\n#define LEFT 1\n#define FRONT_I 2\n#define BACK_I 3\n#define UP 4\n#define DOWN 5\n#define DELAY 6\n#define RIGHT_I 7\n#define LEFT_I 8\n#define FRONT 9\n#define BACK 10\n#define UP_I 11\n#define DOWN_I 12\n\n\n//Here you can modify the moves that the shader does.\n//The shader does one move every second and repeats when it gets to the end of the list.\n//You can use the DELAY move to add one-second pauses.\n#define NUM_MOVES 34\n\nint moves[NUM_MOVES] = int[NUM_MOVES](\n\tRIGHT_I,\n\tUP,\n\tUP,\n\tBACK,\n\tLEFT_I,\n\tFRONT,\n\tUP_I,\n\tBACK,\n\tDOWN,\n\tFRONT,\n\tUP,\n\tDOWN_I,\n\tLEFT,\n\tDOWN,\n\tDOWN,\n\tFRONT_I,\n\tRIGHT,\n\tBACK_I,\n\tDOWN,\n\tFRONT_I,\n\tUP_I,\n\tBACK_I,\n\tUP,\n\tDOWN_I,\n\tDELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY);\n\ncube cubies[26] = cube[26](\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0));\n\nint animation_frame;\n\nint face_cubies[63] = int[63](\n\t0, 1, 2, 3, 4, 5, 6, 7, 8,\n\t17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t2, 5, 8, 11, 13, 16, 19, 22, 25,\n\t0, 3, 6, 9, 12, 14, 17, 20, 23,\n\t0, 1, 2, 9, 10, 11, 17, 18, 19,\n\t6, 7, 8, 14, 15, 16, 23, 24, 25,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1);\n\nvoid write_initial_positions(out vec4 fragColor, ivec2 coords){\n\tif(coords.y == 0 && coords.x < 26){\n\t\tfragColor = vec4(cubies[coords.x].center, coords.x);\n\t} else if(coords.y == 1 && coords.x < 26){\n\t\tfragColor = cubies[coords.x].orientation;\n\t} else {\n\t\tfragColor = vec4(0.0);\n\t}\n}\n\nvec3 face_normals[13] = vec3[13](\n\tvec3(1, 0, 0),\n\tvec3(-1, 0, 0),\n\tvec3(0, 0, 1),\n\tvec3(0, 0, -1),\n\tvec3(0, 1, 0),\n\tvec3(0, -1, 0),\n\tvec3(0, 0, 0),\n\tvec3(-1, 0, 0),\n\tvec3(1, 0, 0),\n\tvec3(0, 0, -1),\n\tvec3(0, 0, 1),\n\tvec3(0, -1, 0),\n\tvec3(0, 1, 0));\n\nbool cubie_in_face(int cubie, int face){\n\treturn cubie == face_cubies[face*9] ||\n\t\t   cubie == face_cubies[face*9 + 1] ||\n\t\t   cubie == face_cubies[face*9 + 2] ||\n\t\t   cubie == face_cubies[face*9 + 3] ||\n\t\t   cubie == face_cubies[face*9 + 4] ||\n\t\t   cubie == face_cubies[face*9 + 5] ||\n\t\t   cubie == face_cubies[face*9 + 6] ||\n\t\t   cubie == face_cubies[face*9 + 7] ||\n\t\t   cubie == face_cubies[face*9 + 8];\n}\n\nvoid fix_cubie_position(out vec4 fragColor, vec4 info, ivec2 coords){\n    float cubie_num;\n    vec3 cubie_center;\n    vec4 cubie_info;\n    vec4 orientation;\n    \n    if(coords == ivec2(0, 2)){\n        fragColor = vec4((animation_frame + 1)%NUM_MOVES, 0.0, 0.0, 0.0);\n    } else if(cubie_in_face(coords.x, moves[animation_frame]%7)){\n        if(coords.y == 0){\n            cubie_info = info;\n        } else {\n            cubie_info = texelFetch(iChannel0, ivec2(coords.x, 0), 0);\n        }\n        orientation = create_orientation(face_normals[moves[animation_frame]], -PI/2.0);\n        cubie_center = apply_orientation(cubie_info.xyz - vec3(0.0, 0.0, 4.0), orientation);\n        cubie_num = round(-cubie_center.z*3.0/2.0 - cubie_center.y*9.0/2.0 - cubie_center.x*27.0/2.0 + 13.0);\n        cubie_num = cubie_num > 12.0 ? cubie_num - 1.0 : cubie_num;\n        if(coords.y == 0){\n            fragColor = vec4(cubies[coords.x].center, texelFetch(iChannel0, ivec2(cubie_num, 0), 0).w);\n        } else if(coords.y == 1){\n            fragColor = normalize(texelFetch(iChannel0, ivec2(cubie_num, 1), 0));\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, coords, 0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tivec2 coords;\n\tfloat frame_time;\n\tvec2 frame_info;\n\tbool on_face;\n\tfloat delta;\n\tvec3 center;\n\tvec4 orientation;\n\n\tcoords = ivec2(fragCoord);\n\t\n\tif((coords.x >= 26 || coords.y > 1) && coords != ivec2(0, 2)){\n\t\tdiscard;\n\t}\n\t\n\tif(iFrame == 0){\n\t\twrite_initial_positions(fragColor, coords);\n\t\treturn;\n\t}\n\n\tfragColor = texelFetch(iChannel0, coords, 0);\n\tframe_info = texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n\tanimation_frame = int(frame_info.x);\n\tframe_time = frame_info.y;\n\tif(frame_time == 1.0){\n\t\tfix_cubie_position(fragColor, fragColor, coords);\n\t\treturn;\n\t}\n\tdelta = iTimeDelta;\n\tif(frame_time + delta > 1.0){\n\t\tdelta = 1.0 - frame_time;\n\t\tif(coords == ivec2(0, 2)){\n\t\t\tfragColor = vec4(animation_frame, 1.0, 0.0, 0.0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(coords == ivec2(0, 2)){\n\t\tfragColor = vec4(animation_frame, delta + frame_time, 0.0, 0.0);\n\t\treturn;\n\t}\n\n\ton_face = cubie_in_face(coords.x, moves[animation_frame]%7);\n\tif(on_face && coords.y == 0){\n\t\tcenter = fragColor.xyz;\n\t\tcenter = apply_orientation(center - vec3(0.0, 0.0, 4.0), create_orientation(face_normals[moves[animation_frame]], delta*PI/4.0));\n\t\tfragColor = vec4(center + vec3(0.0, 0.0, 4.0), fragColor.w);\n\t} else if(on_face && coords.y == 1){\n\t\torientation = fragColor;\n\t\torientation = compose_orientation(create_orientation(face_normals[moves[animation_frame]], delta*PI/4.0), orientation);\n\t\tfragColor = orientation;\n\t} else\n\t\tfragColor = texelFetch(iChannel0, coords, 0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Procedural \"lights in the distance\"\n\n#define PI 3.1415927\n#define NUM_CIRCLES 15\n#define RADIUS 0.35\n\nvec3 get_random_continuous_vec(float id, float scale){\n\treturn vec3(sin(mod(id*1013.0 + iTime*scale, 2.0*PI)), cos(mod(id*4079.0 + iTime*scale, 2.0*PI)), cos(mod(id*7237.0 + iTime*scale, 2.0*PI)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tint i;\n\tfloat min_side;\n\tvec2 rand_vec;\n\tfloat dist;\n\tvec3 total = vec3(0.0);\n\tfloat rad;\n\t\n\tmin_side = min(iResolution.x, iResolution.y);\n\tfor(i = 0; i < NUM_CIRCLES; i++){\n\t\trand_vec = get_random_continuous_vec(float(i), 0.01).xy;\n\t\trand_vec = vec2(rand_vec.x*iResolution.x/min_side, rand_vec.y*iResolution.y/min_side);\n\t\tdist = distance(fragCoord/min_side, rand_vec);\n\t\trad = clamp((RADIUS - dist)/RADIUS, 0.0, 1.0);\n\t\ttotal += rad*(get_random_continuous_vec(float(i + NUM_CIRCLES), 0.05)*0.5 + vec3(1.0)*0.5);\n\t}\n\t\n\tfragColor = vec4(total*0.075, 1.0);\n}\n", "buffer_b_inputs": [], "common_code": "struct cube{\n\tvec3 center;\n\tvec4 orientation;\n\tfloat size;\n};\n\nstruct ray{\n\tvec3 p;\n\tvec3 vec;\n};\n\t\nvec3 intersect_normals[6] = vec3[6](\n\tvec3(-1, 0, 0),\n\tvec3(1, 0, 0),\n\tvec3(0, -1, 0),\n\tvec3(0, 1, 0),\n\tvec3(0, 0, -1),\n\tvec3(0, 0, 1));\n\nvec4 create_orientation(vec3 axis, float angle){\n\tfloat len;\n\tvec4 outvec;\n\t\n\tlen = length(axis);\n\taxis *= sin(angle)/len;\n\toutvec.yzw = axis;\n\toutvec.x = cos(angle);\n\t\n\treturn outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n\treturn vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n\tvec4 outvec;\n    mat4 comp_matrix;\n    \n    comp_matrix[0] = b.xyzw;\n    comp_matrix[1] = b.yxwz*vec4(-1.0, 1.0, -1.0, 1.0);\n    comp_matrix[2] = b.zwxy*vec4(-1.0, 1.0, 1.0, -1.0);\n    comp_matrix[3] = b.wzyx*vec4(-1.0, -1.0, 1.0, 1.0);\n    return comp_matrix*a;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n\tvec4 v;\n\t\n\tv.x = 0.0;\n\tv.yzw = p.xyz;\n\treturn compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nray apply_orientation_ray(ray r, vec4 o){\n\treturn ray(apply_orientation(r.p, o), apply_orientation(r.vec, o));\n}\n\ncube rotate_cube(cube c, vec4 o){\n\tc.center -= vec3(0.0, 0.0, 4.0);\n\tc.center = apply_orientation(c.center, o);\n\tc.orientation = compose_orientation(o, c.orientation);\n\tc.center += vec3(0.0, 0.0, 4.0);\n\treturn c;\n}\n\n//Gets the intersection data between a ray and a cube\nvec3 ray_cube_intersect(cube c, ray r, out int side, out vec2 face_pos){\n\tray translated_ray;\n\tfloat d = 10000.0;\n\tfloat t = 0.0;\n\tvec2 comps;\n\tbool best;\n\t\n\tside = -1;\n\t\n\ttranslated_ray = ray(r.p - c.center, r.vec);\n\ttranslated_ray = apply_orientation_ray(translated_ray, inverse_orientation(c.orientation));\n\t\n\tt = (c.size - translated_ray.p.x)/translated_ray.vec.x;\n\tcomps = t*translated_ray.vec.yz + translated_ray.p.yz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 0 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : vec2(0.0);\n\t\n\tt = (-c.size - translated_ray.p.x)/translated_ray.vec.x;\n\tcomps = t*translated_ray.vec.yz + translated_ray.p.yz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 1 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (c.size - translated_ray.p.y)/translated_ray.vec.y;\n\tcomps = t*translated_ray.vec.xz + translated_ray.p.xz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 2 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (-c.size - translated_ray.p.y)/translated_ray.vec.y;\n\tcomps = t*translated_ray.vec.xz + translated_ray.p.xz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 3 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (c.size - translated_ray.p.z)/translated_ray.vec.z;\n\tcomps = t*translated_ray.vec.xy + translated_ray.p.xy;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 4 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (-c.size - translated_ray.p.z)/translated_ray.vec.z;\n\tcomps = t*translated_ray.vec.xy + translated_ray.p.xy;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 5 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\n\tface_pos /= c.size;\n\t\n\treturn d*r.vec + r.p;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1787, 1787, 1816, 1816, 2031], [2033, 2033, 2067, 2067, 2130], [2132, 2132, 2163, 2163, 2383], [2385, 2385, 2432, 2432, 2810], [2812, 2846, 2942, 2942, 3436], [3438, 3438, 3472, 3472, 3564], [3566, 3566, 3596, 3596, 3719], [3721, 3721, 3775, 3775, 6557]]}
{"id": "WscfWS", "name": "Rotated Scaled Regular 6-gons", "author": "IWBTShyGuy", "description": "No context regular 6-gons and one black square animation", "tags": ["pattern"], "likes": 4, "viewed": 345, "published": 3, "date": "1605836433", "time_retrieved": "2024-07-30T20:34:47.670194", "image_code": "// Copyright  2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.1415926536;\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\n\n// the thickness of lines\nconst float THICKNESS = 0.015;\n\n// The outer rotation polygon is N-GON.\nconst int N = 6;\n// the frequancy of waves (Hz)\nconst float FREQ = 1.75;\n// circumradius\nconst float RADIUS = 0.5;\n// the omega of the center rectangle\nconst float OMEGA_RECT = PI / 2.4;\n// the length of the edges of the center rectangle\nconst float L_RECTANGLE = 0.17;\n// If there are not enough waves, make this integer higher.\nconst int REPEAT = 3;\n\nconst float THETA = PI / float(N);\n// the cosine of PI / N.\nconst float COS = cos(THETA);\n// the rotation matrix generate polygon\nconst mat2 ROT = mat2(cos(THETA), sin(THETA), -sin(THETA), cos(THETA));\n// the omega of the outer polygon\nconst float OMEGA = THETA * FREQ;\n// inner radius\nconst float INNER_RADIUS = COS * RADIUS;\n/// velocity of wave\nconst float VELO = pow(cos(THETA) + sin(THETA) / tan(THETA * float(N / 2 - 1)), float(N));\n\nmat2 rot(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvec2 uv_coord(vec2 coord) {\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0, 1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    return 2.0 * coord / iResolution[min_idx] - aspect_vec;\n}\n\nfloat line(vec2 uv, vec2 pt0, vec2 pt1) {\n    vec2 a = uv - pt0;\n    vec2 b = pt1 - pt0;\n    float t = dot(a, b) / dot(b, b);\n    vec2 h = a - t * b;\n    if (0.0 < t && t < 1.0) {\n        float x = 1.0 - 4.0 * dot(h, h) / (THICKNESS * THICKNESS);\n        return smoothstep(0.0, 1.0, x);\n    }\n    return 0.0;\n}\n\nfloat regpolygon(vec2 uv, vec2 pt, int n) {\n    vec2 pt0 = pt;\n    mat2 rot = rot(2.0 * PI / float(n));\n    float score = 0.0;\n    for (int i = 0; i < n; i++) {\n        vec2 pt1 = rot * pt0;\n        score = max(score, line(uv, pt0, pt1));\n        pt0 = pt1;\n    }\n    return score;\n}\n\nfloat radiation(vec2 uv, vec2 pt, int n) {\n    mat2 rot = rot(2.0 * PI / float(n));\n    float score = 0.0;\n    for (int i = 0; i < n; i++) {\n        score = max(score, line(uv, pt, vec2(0.0)));\n        pt = rot * pt;\n    }\n    return score;\n}\n\nfloat circle(vec2 uv, float r) {\n    float x = r - length(uv);\n    x = 1.0 - 4.0 * x * x / (THICKNESS * THICKNESS);\n    return smoothstep(0.0, 1.0, x);\n}\n\nbool in_rectangle(vec2 uv, vec2 pt) {\n    return abs(uv.x) < abs(pt.x) && abs(uv.y) < abs(pt.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    float step = 0.0;\n\n    vec2 rect_vert = vec2(L_RECTANGLE * cos(iTime * OMEGA_RECT), L_RECTANGLE);\n    if (in_rectangle(uv, rect_vert)) {\n        fragColor = vec4(BLACK, 1.0);\n        return;\n    }\n    \n    vec2 pt0 = vec2(cos(OMEGA * iTime), sin(OMEGA * iTime)) * RADIUS;\n    step = max(step, regpolygon(uv, pt0, N));\n    step = max(step, radiation(uv, pt0, N));\n    step = max(step, radiation(uv, ROT * pt0 * COS, N));\n\n    vec2 pt1 = vec2(cos(OMEGA * iTime), -sin(OMEGA * iTime)) * RADIUS;\n    step = max(step, regpolygon(uv, pt1, N));\n    step = max(step, radiation(uv, pt1, N));\n    step = max(step, radiation(uv, ROT * pt1 * COS, N));\n\n    step = max(step, circle(uv, INNER_RADIUS));\n\n    vec2 pt2 = vec2(1.0, 0.0);\n    for (int i = 0; i < N / 2 * REPEAT; i++) {\n        float rep = float(REPEAT);\n        float c0 = pow(VELO, rep * fract((iTime - float(2 * i) / FREQ) * OMEGA / PI / rep));\n        step = max(step, regpolygon(uv, pt2 * RADIUS * c0, N));\n        float c1 = pow(VELO, rep * fract((iTime - float(2 * i + 1) / FREQ) * OMEGA / PI / rep));\n        step = max(step, regpolygon(uv, ROT * pt2 * RADIUS * c1, N));\n    }\n    fragColor = vec4(WHITE * step, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscfWS.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1081, 1081, 1104, 1104, 1172], [1174, 1174, 1201, 1201, 1460], [1462, 1462, 1503, 1503, 1772], [1774, 1774, 1817, 1817, 2057], [2059, 2059, 2101, 2101, 2301], [2303, 2303, 2335, 2335, 2456], [2458, 2458, 2495, 2495, 2556], [2558, 2558, 2613, 2613, 3828]]}
{"id": "3stfzj", "name": "Twister effect", "author": "maksy", "description": "My take on the classic.\n\nBased on this shader: https://www.shadertoy.com/view/lsX3WM", "tags": ["2d", "oldschool", "twister"], "likes": 2, "viewed": 326, "published": 3, "date": "1605819454", "time_retrieved": "2024-07-30T20:34:48.727368", "image_code": "#define S smoothstep\nconst float M_PI = 3.141;\nconst float twister_thick = 0.22;\nconst float thick = 0.012;\n\nvec4 borderColor(float x0, float x1, vec2 uv, \n                 float leftVisible, float rightVisible, \n                 vec4 intCol, vec4 extCol) {\n\n    vec4 white = vec4(1.);\n    \n   \t// the exterior side of the left border\n\tfloat outside = (step(uv.x, x0-thick) + step(x0, uv.x));\n    vec4 borderLeft = mix(white, extCol, S(x0, x0-thick, uv.x)) \n    \t* (1. - outside) * leftVisible;\n        \n    // the interior side of the left border\n    outside = (step(uv.x, x0) + step(x0+thick, uv.x));\n    vec4 borderLeft2 = mix(intCol, white, S(x0+thick, x0, uv.x)) \n    \t* (1. - outside)* leftVisible;      \n    \n    // the exterior side of the right border\n    outside = (step(uv.x, x1) + step(x1+thick, uv.x));        \n    vec4 borderRight = mix(white, extCol, S(x1, x1+thick, uv.x))\n        * (1.- outside) * rightVisible ;\n    \n    // the interior side of the right border\n    outside = (step(uv.x, x1-thick) + step(x1, uv.x));            \n    vec4 borderRight2 = mix(intCol, white, S(x1-thick, x1, uv.x))\n    \t* (1.- outside) * rightVisible;\n    \n    return borderLeft + borderLeft2 + borderRight + borderRight2;     \n}\n\nvec4 getColor(float x0, float x1, vec2 uv, vec4 intCol, vec4 extCol,\n              vec4 fragColor) {\n      \n    vec4 rightCol = vec4(0.);\n    vec4 leftCol = vec4(0.);\n        \n    leftCol = borderColor(x0, x1, uv, 1., 0., intCol, extCol);       \n    rightCol = borderColor(x0, x1, uv, 0., 1., intCol, extCol);\n   \n    if (leftCol != vec4(0.))\n        return leftCol;\n    else if (rightCol != vec4(0.))\n   \t\treturn rightCol;                 \n   \n    return fragColor;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\n\t\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\tvec4 white = vec4(1.0);\n\t\n    /* Creates four points and rotates them by sin of y, time and stuff.\n     * If p1 < p2, a side is visible. Draw a line between each such\n     * pair of points.\n     */\n    float twist = (M_PI / 180.0 * (iTime * 75.0 + \n\t\t\t\t(uv.y * 120.0) * sin((((iTime * 32.5) + \n\t\t\t\t(uv.y * 120.0)) * 3.0 / 4.0) * M_PI / 110.0) )) / .5;\n    \n\tfloat x0 = sin(twist) * twister_thick;\n\tfloat x1 = sin(0.5 * M_PI + twist) * twister_thick;\n\tfloat x2 = sin(1.0 * M_PI + twist) * twister_thick;\n\tfloat x3 = sin(1.5 * M_PI + twist) * twister_thick;\t\n    \n    // Background color\n    fragColor = mix(vec4(0.01), vec4(0.15),smoothstep(.6, .002, abs(uv.x) * 0.59));\n    \n    // Add color onto the visible sides.\n\tvec4 C1 = vec4(1.,0.,0.,0.);\n\tvec4 C2 = vec4(0.,1.,0.,0.);\n\tvec4 C3 = vec4(0.,0.,1.,0.);\n\tvec4 C4 = vec4(1.0,0.52, 0.0, 1.0);\n    \n    if (x0 < x1 && uv.x > x0-thick && uv.x < x1+thick) { \n    \tfragColor = mix(vec4(0.1), C1, S(0.3, 0.002, abs(uv.x) *.95));\n    }\n    if (x1 < x2 && uv.x > x1-thick && uv.x < x2+thick)\n        fragColor = mix(vec4(0.1), C2, S(0.3, 0.002, abs(uv.x) *.95));\n    \n    if (x2 < x3 && uv.x > x2-thick && uv.x < x3+thick) {\n        fragColor = mix(vec4(0.1), C3, S(0.3, 0.002, abs(uv.x) *.95));\n    }        \n    if (x3 < x0 && uv.x > x3-thick && uv.x < x0+thick) {\n        fragColor = mix(vec4(0.1), C4, S(0.3, 0.002, abs(uv.x) *.95));\n    }\n    \n    // Add borders.\n    vec4 extCol = vec4(0.15);\n    vec4 intCol = vec4(0.2);\n    \n\tif (x0 < x1) {\n        fragColor = getColor(x0, x1, uv, intCol, extCol, fragColor);\n    }    \n    \n\tif (x1 < x2) {\n    \tfragColor = getColor(x1, x2, uv, intCol, extCol, fragColor);\n    }\n   \n   \tif (x2 < x3) {\n    \tfragColor = getColor(x2, x3, uv, intCol, extCol, fragColor);\n    }\n    \n    if (x3 < x0) {\n    \tfragColor = getColor(x0, x3, uv, intCol, extCol,fragColor);\n    \tif (x2 < x3) {\n            fragColor = getColor(x3, x0, uv, intCol, extCol, fragColor);    \t\n    \t}\n    }\n       \n    vec3 col2 = pow(fragColor.xyz,vec3(.454545));\n \tfragColor = vec4(col2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 257, 257, 1227], [1229, 1229, 1329, 1329, 1700], [1702, 1702, 1759, 1759, 3875]]}
{"id": "wsdfRl", "name": "The Battle of End Times", "author": "xenn", "description": "1. to the mutually assured death YAAAAYYYYY \nor\n2. The proverbial frog snuff. Zymotic heat death in climate collapse\n\nRemember, we spent infinite more time in the unlife up until this strange aberration, experience, \"life\" , let's do it again!", "tags": ["particles", "ca"], "likes": 6, "viewed": 554, "published": 3, "date": "1605806191", "time_retrieved": "2024-07-30T20:34:49.866322", "image_code": "// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0.5, 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(1.1521*01.0*vec3(0.21+sin(iTime*0.521),0.31+cos(iTime*0.15),0.1+sin(iTime*(0.219)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24645, "src": "https://soundcloud.com/stromunfall8bit/the-battle-of-evermore-8bit", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 03.5\n\n#define fluid_rho 0.3\n\n\n//mold stuff \n#define sense_ang 0.56\n#define sense_dis 0.50*(0.1*sin(time*1.0)+01.21)\n#define sense_force 0.5923743275\n#define trailing 010.0*sin(time*02.1141)\n#define acceleration 0.435932017\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.347503666*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.2910\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(0.0*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 20.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 306], [308, 308, 344, 344, 394], [396, 396, 412, 412, 440], [442, 442, 487, 487, 1657]]}
{"id": "3sdfRs", "name": "running uniform for api usage", "author": "jemappelle", "description": "literally just added some uniforms to the base shader, so i can present my work with laptop hardware", "tags": ["arbitrary"], "likes": 0, "viewed": 244, "published": 3, "date": "1605794864", "time_retrieved": "2024-07-30T20:34:50.788856", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+(vec3(0,2,4)*vec3(lowFreqFFT, midFreqFFT, highFreqFFT)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 210, 441]]}
{"id": "ws3Bzf", "name": "Biplanar mapping", "author": "iq", "description": "A cheaper alternative to Box/Triplanar mapping that performs only two texture fetches instead of three. Useful for texturing 3D geometry when it doesn't have UV coords but can't afford 3D texturing and when triplanar mapping take up too much bandwidth.", "tags": ["3d", "triplanar", "boxmap", "biplanar"], "likes": 101, "viewed": 30484, "published": 3, "date": "1605765292", "time_retrieved": "2024-07-30T20:34:51.662520", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// An alternative to box mapping (a.k.a. \"roundcube\" or \n// \"triplanar\" mapping), where some extra ALU computations\n// are performed but one texture fetch is avoided, for a\n// total of just two.\n\n// The idea is that instead of doing the 3 planar projections\n// (in the X, Y and Z directions) and later blend them\n// together based on the alignment of the normal vector to\n// each of those three directions, we can perhaps get away\n// with picking only the two most relevant projection\n// directions out of the three and ignore the third.\n// That introduces in theory some discontinutity but it\n// seems is not noticeable, and it saves a precious\n// texture fetch.\n\n// Note that the texture coord derivatives need to be taken\n// before the projection axis selections are done, to\n// prevent filtering issue. Check the biplanar() function\n// below.\n//\n// More information here:\n//\n// https://iquilezles.org/articles/biplanar\n//\n// For a more complicated example of biplanar texturing:\n//\n// https://www.shadertoy.com/view/3ddfDj\n//\n// Also for comparison, here's traditional boxmapping:\n//\n// https://www.shadertoy.com/view/MtsGWH\n\n\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // determine major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // determine minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // determine median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend factors\n    vec2 w = vec2(n[ma.x],n[me.x]);\n    // make local support\n    w = clamp( (w-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // shape transition\n    w = pow( w, vec2(k/8.0) );\n    // blend and return\n    return (x*w.x + y*w.y) / (w.x + w.y);\n}\n\n\n//===============================================================================================\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 p )\n{\n\tfloat d = length(p-vec3(0.0,1.0,0.0))-1.0;\n    d = smin( d, p.y, 1.0 );\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // camera movement\t\n        float an = 0.2*iTime;\n        vec3 ro = vec3( 2.5*sin(an), 2.0, 2.5*cos(an) );\n        vec3 ta = vec3( 0.0, 1.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 1.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float h = map(pos);\n            if( h<0.001 ) break;\n            t += h;\n            if( t>tmax ) break;\n        }\n        \n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + rd*t;\n            vec3 nor = calcNormal( pos, 0.001 );\n            float occ = clamp(0.4 + 0.6*nor.y, 0.0, 1.0);\n            col = biplanar( iChannel0, 0.5*pos, nor, 8.0 ).xyz;\n            col = col*col;\n            col *= occ;\n            col *= 2.0;\n            col *= 1.0-smoothstep(1.0,6.0,length(pos.xz));\n        }\n        // to gamma space\n        col = sqrt( col );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3Bzf.jpg", "access": "api", "license": "mit", "functions": [[2277, 2277, 2343, 2387, 3639], [3803, 3803, 3844, 3844, 3933], [3935, 3935, 3959, 3959, 4048], [4050, 4096, 4142, 4142, 4339]]}
{"id": "ws3BRs", "name": "Simple Cuboid", "author": "andraantariksa", "description": "Simple cube from what I have learn in university", "tags": ["cube", "beginner"], "likes": 3, "viewed": 449, "published": 3, "date": "1605759070", "time_retrieved": "2024-07-30T20:34:52.420494", "image_code": "#define BACKFACE_CULLING\n\nfloat signVector( in vec2 point, in vec2 arbitraryPoint, in vec2 normal )\n{\n    return dot(point - arbitraryPoint, normal);\n}\n\nvec2 lineNormal( in vec2 a, in vec2 b )\n{\n    return vec2(-(b.y - a.y), b.x - a.x);\n}\n\nbool isInsideTriangle( in vec2 point, in vec2 v1, in vec2 v2, in vec2 v3 )\n{\n    float s1 = signVector(point, v1, lineNormal(v1, v2));\n    float s2 = signVector(point, v2, lineNormal(v2, v3));\n    float s3 = signVector(point, v3, lineNormal(v3, v1));\n    \n    return ((s1 > 0.0f) && (s2 > 0.0f) && (s3 > 0.0f))\n        || ((s1 < 0.0f) && (s2 < 0.0f) && (s3 < 0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vertices[8] = vec3[8](\n        vec3(-0.3f, 0.3f, -0.3f),\n        vec3(-0.3f, 0.3f, 0.3f), // Front left top\n        \n        vec3(0.3f, 0.3f, -0.3f),\n        vec3(0.3f, 0.3f, 0.3f), // Front right top\n            \n        vec3(-0.3f, -0.3f, -0.3f),\n        vec3(-0.3f, -0.3f, 0.3f), // Front left bottom\n\n        vec3(0.3f, -0.3f, -0.3f),\n        vec3(0.3f, -0.3f, 0.3f)  // Front right bottom\n    );\n    \n    uvec3 verticesIdx[12] = uvec3[12](\n        // Front surface\n        uvec3(1, 5, 7),\n        uvec3(1, 7, 3),\n        // Left surface\n        uvec3(1, 4, 5),\n        uvec3(0, 4, 1),\n        // Right surface\n        uvec3(3, 7, 2),\n        uvec3(7, 6, 2),\n        // Bottom surface\n        uvec3(5, 6, 7),\n        uvec3(5, 4, 6),\n        // Top surface\n        uvec3(1, 3, 2),\n        uvec3(2, 0, 1),\n        // Back surface\n        uvec3(0, 6, 4),\n        uvec3(0, 2, 6)\n    );\n    \n    float zc = 1.0f;\n    float angularSpeed = iTime * 10.0f / (2.0f * 3.14159265359f);\n    mat4 rotXMat = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, cos(angularSpeed), -sin(angularSpeed), 0.0f,\n        0.0f, sin(angularSpeed), cos(angularSpeed), 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 rotYMat = mat4(\n        cos(angularSpeed), 0.0f, sin(angularSpeed), 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n        -sin(angularSpeed), 0.0f, cos(angularSpeed), 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 perspectiveMat = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n    \t0.0f, 0.0f, 1.0f, 1.0f/-zc,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 st = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n    \t0.0f, 0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    for (int i = 0; i < 8; ++i)\n    {\n        vec4 verticesInPerspective = st * perspectiveMat * rotXMat * rotYMat * vec4(vertices[i], 1.0f);\n        vertices[i] = verticesInPerspective.xyz / verticesInPerspective.w;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    \n    for (int i = 0; i < 12; ++i)\n    {\n        if (\n#ifdef BACKFACE_CULLING\n            dot(\n            \tcross(\n                    vertices[verticesIdx[i][1]] - vertices[verticesIdx[i][0]],\n                    vertices[verticesIdx[i][2]] - vertices[verticesIdx[i][1]]),\n                vec3(0.0f, 0.0f, -1.0f)\n            ) < 0.0f &&\n#endif\n            isInsideTriangle(\n            uv,\n            vec2(vertices[verticesIdx[i][0]]),\n            vec2(vertices[verticesIdx[i][1]]),\n            vec2(vertices[verticesIdx[i][2]])))\n        {\n\t\t\tcolor.r = float(i)/12.0;\n            color.g = float(i)/12.0;\n            color.b = (12.0-float(i))/12.0;\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3BRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 101, 101, 151], [153, 153, 194, 194, 238], [240, 240, 316, 316, 608]]}
{"id": "wd3Bzl", "name": "Audio Waveform Visualizer v3", "author": "oneshade", "description": "I think this is a neat culmination of two projects. You can now switch between a view of the frequencies to the amplitudes. BEWARE! The amplitudes change FAST!", "tags": ["visualization", "waveform", "curvefitting"], "likes": 3, "viewed": 462, "published": 3, "date": "1605747926", "time_retrieved": "2024-07-30T20:34:53.372947", "image_code": "/*\nVersion three of my Audio Waveform Visualizer.\nI combined the sampling technique from version 2 (https://www.shadertoy.com/view/Wd3BRl)\nwith the curve fitting idea from my shader \"Sine Wave Curve Fitting\". The coloring was\npartially inspired by Dave_Hoskins shader \"Curve fitting\". The curve fitting idea didn't\nturn out to be too great for modelling characters but it was fun to experiment with and\nmaybe I'll use it again sometime. However, I decided it would work nicely in my Audio\nWaveform Visualizer so this is what I did with it.\n*/\n\n// 0 for frequency mode, 1 for amplitude mode:\n#define VIEW_MODE 0\n\nfloat samplePiecewiseSmooth(in float x, in float res) {\n    float xTimesRes = x * res;\n\n    // Left sample point:\n    float x1 = floor(xTimesRes) / res;\n    float y1 = texture(iChannel0, vec2(x1, VIEW_MODE)).x;\n\n    // Right sample point:\n    float x2 = ceil(xTimesRes) / res;\n    float y2 = texture(iChannel0, vec2(x2, VIEW_MODE)).x;\n\n    // Prevent small breaks in the line:\n    x2 += 0.001;    \n\n    // Fit half of a sine wave between sample points:\n    float sine = sin(((x - x1) / (x2 - x1) * 2.0 - 1.0) * 1.5707963267);\n    return y1 + (0.5 + 0.5 * sine) * (y2 - y1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float curSample = samplePiecewiseSmooth(uv.x, 20.0);\n    // Difference between the pixel position and the sample:\n    float smoothError = smoothstep(0.03, 0.0, abs(uv.y - curSample));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // If the pixel is close to the line (I know, the naming isn't very intuitive):\n    if (smoothError > 0.0) {\n        // Mix red and yellow based on closeness:\n        fragColor = vec4(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), smoothError), 1.0);\n    }\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3Bzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 612, 667, 667, 1187], [1189, 1189, 1244, 1244, 1778]]}
{"id": "WscBzs", "name": "sRGB vs gamma encoding", "author": "ttg", "description": "sRGB is [b]NOT[/b] the same thing as 2.2 gamma !\n\nIf the top two strips have visually consistent light fall-off, you have a true sRGB display pipeline.\nIf the bottom two strips have this consistency, your display pipeline is using gamma=2.2 encoding.", "tags": ["gamma", "srgb", "srgbvspow"], "likes": 3, "viewed": 354, "published": 3, "date": "1605739471", "time_retrieved": "2024-07-30T20:34:54.212702", "image_code": "/*\n\nsRGB is *NOT* the same thing as 2.2 gamma !\n\nTop half of image: sRGB-encoded output\nBottom half of image: gamma-encoded\n\nIf the top two strips have visually consistent light fall-off,\n  you have a true sRGB display pipeline.\n\nIf the bottom two strips have this consistency,\n  your display pipeline is using gamma=2.2 encoding.\n\nIt's hard to say which is more common, and harder to say which is more correct.\nThere's a discussion about that here: https://www.shadertoy.com/view/4tXcWr\n\nIn theory your OS could be correctly managing colors for image files even if\nWebGL (Shadertoy) is being displayed as gamma=2.2 - it's just a\n\"bug in the standards\" that a specific encoding isn't mandated or even\navailable for websites to choose.\n\nMore likely, if you see the gamma=2.2 behavior, your system is just assuming\nthe display is sRGB when it is not.\n\nAt least you can count on some crude approximation of one of these two\nencodings being used - anything else looks so clearly wrong that even browser\nmakers would notice an inconsistency.\n\n*/\n\nvec3 srgb_decode (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),lessThan(vec3(.04045),e));\n}\n\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = (uv.x-.05)/(.95-.05);\n    \n#define DITHER(p) float(int(dot(floor(fragCoord),vec2(413,229)))%512<int((p)*512.))\n\n#if 1\n    // Center: 20% intensity\n    // Top/bottom: 100% intensity\n    vec3 col = (abs(uv.y-.5)>.25 ? 1.*(uv.x) : .2*(uv.x) ) * vec3(.1,.4,1.);\n#else\n    // Center: 20% intensity continuous values\n    // Top/bottom: 20% intensity two-value dither\n    vec3 col = (abs(uv.y-.5)>.25 ? .2*DITHER(uv.x) : .2*(uv.x) ) * vec3(.1,.4,1.);\n#endif\n    \n    if (uv.x<0.||uv.x>1.) col = vec3(0.);\n\n    // Top half:    sRGB encoding\n    // Bottom half: gamma=2.2 encoding\n    fragColor = vec4(\n      uv.y>.5 ? srgb_encode(col)\n              : pow(col, vec3(1./2.2))\n      ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1042, 1042, 1069, 1069, 1149], [1151, 1151, 1178, 1178, 1261], [1263, 1263, 1320, 1320, 2052]]}
{"id": "3d3BRj", "name": "pulsing circle outline", "author": "Peewi", "description": "pulsing circle outline", "tags": ["test"], "likes": 2, "viewed": 355, "published": 3, "date": "1605730009", "time_retrieved": "2024-07-30T20:34:55.060435", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // some bs\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 white = vec3(0.9);\n    vec3 col = bg;\n    //vec2 center = vec2(200.0, iResolution.y - 150.0);\n    vec2 center = iMouse.xy;\n\n    float l = length(fragCoord-center);\n    float radius = ((cos(iTime*3.0)+1.0) * 40.0);\n    //float radius = 1.0;\n    float am = abs(l - radius)-2.;\n    am = clamp(am, 0.0, 1.0);\n    col = mix(white, bg, am);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 605]]}
{"id": "WscBRl", "name": "Fake Caustic w/Voronoi - Golfed", "author": "oneshade", "description": "Golfed version of my \"Fake Caustic w/Voronoi\" shader. Happy code golfing!", "tags": ["voronoi", "caustic", "codegolf"], "likes": 7, "viewed": 257, "published": 3, "date": "1605722956", "time_retrieved": "2024-07-30T20:34:55.999923", "image_code": "/* 377 char version (27 chars shorter) by gelami */\n#define v(x, y) for(int x=-y; x++ < 2;)\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    float t = 0., w = 1., d, g, z;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y, x, n;\n\n    v(l,0) {\n        x = q * 4. / w;\n        d = 1.;\n        v(i,2)\n            v(j,2)\n                n = floor(x) + vec2(i, j), n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime)),\n                d = mix(g = length(x - n), d,\n                        z = clamp(.5 + 5. * (g - d), 0., 1.) )\n                            - .1 * z * (1. - z);\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n    o /= t;\n}\n/**/\n\n/* Another shorter version (404 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w;\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = floor(x) + vec2(i, j); n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - n), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Even shorter version (408 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = f + vec2(i, j); n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - n), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Shorter version (409 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = f + vec2(i, j), p = n + .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - p), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Original version (414 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l < 2; l++) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                vec2 n = f + vec2(i, j), p = n + .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - p), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n        }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "tdcBRf", "name": "Artistic Water Foam", "author": "Daizuukee", "description": "An artistic Water shader, the perlin noise function is not written by me.", "tags": ["water", "artistic"], "likes": 11, "viewed": 459, "published": 3, "date": "1605720479", "time_retrieved": "2024-07-30T20:34:56.872590", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 point (vec2 st) {\n  return vec2(random(st),random(st.yx)) / 2. + 0.5;\n}\n\nfloat dist (vec2 a, vec2 b) {\n  return sqrt(pow(a.x - b.x,2.) + pow(a.y - b.y,2.));\n}\n\nvec4 voronoi(vec2 p, float roundness, out vec2 smallestp) {\n  \n  int C = 2;\n  \n  float offset = 1.5;\n  \n  vec2 closest;\n  float mindist = float(C*C);\n  float secondmin = mindist;\n  vec2 secclosest;\n  \n  \n  for(int x = -C; x <= C; x++)\n    for(int y = -C; y <= C; y++) {\n      vec2 vp = point(floor(p) + vec2(x,y)) * offset;\n      float d = dist(vp + floor(p) + vec2(x,y),p);\n      \n      float size = pow(random(vp) / 4. + 0.5,roundness);\n      float comp = d * size;\n      \n      if(mindist > comp) {\n        secclosest = closest;\n        secondmin = mindist;\n        \n        closest = vp + vec2(x+y);\n        smallestp = floor(p) + vec2(x, y);\n        mindist = comp;\n      }\n      else if(secondmin > comp) {\n        secclosest = vp + vec2(x+y);\n        secondmin = comp;\n      }\n    }\n    \n  return vec4(fract(closest.x),fract(closest.y),mindist,(secondmin - mindist));\n}\n\nvec4 voronoi (vec2 p, float roundness) {\n  vec2 temp;\n  return voronoi(p,roundness,temp);\n}\n\n\n\n//\n\nvec3 permute( vec3 x){\n  return mod(((x*34.0) +1.0)*x,  289.0) ;\n}\nvec3 taylorInvSqrt (vec3 r){\n  return  1.79284291400159-0.85373472095314*r;\n  }\nfloat snoise(vec2 P){\n  const vec2 C = vec2 (0.211324865405187134,  // (3.0-sqrt ( 3 . 0 ) ) / 6 . 0 ;\n  0.366025403784438597) ;  //  0.5*( sqrt ( 3 . 0 )-1.0) ;\n  //  First  corner\n  vec2 i = floor(P+ dot (P,C.yy)  ) ;\n  vec2 x0=P-i+ dot (i,C.xx) ;// Other  corners\n  vec2 i1;\n  i1.x = step (x0.y,x0.x) ;  //  1.0 if(x0.x > x0.y ,  e l s e  0.0\n  i1.y = 1.0-i1.x;\n  // x1 = x0-i1 + 1.0*C. xx ;  x2 = x0-1.0 + 2.0*C. xx ;\n  vec4 x12 = x0.xyxy + vec4 (C.xx,C.xx*2.0-1.0) ;x12.xy-=i1;//  Permutations\n  i = mod(i,  289.0);  // Avoid  truncation  in  polynomial  evaluation\n  vec3 p = permute(permute(i.y+ vec3 (0.0 ,i1.y,  1.0  ) )+i.x+ vec3 (0.0 ,i1.x,  1.0  ) ) ;//  Circularly  symmetric  blending  kernel\n  vec3 m = max(0.5-vec3 ( dot (x0,x0) ,  dot (x12.xy,x12.xy) ,dot (x12.zw,x12.zw) ) ,  0.0) ;m=m*m;m=m*m;//  Gradients  from 41  points  on a  line ,  mapped onto a diamond\n  vec3 x= fract(p*(1.0  /  41.0) )*2.0-1.0  ;vec3 gy= abs (x)-0.5  ;vec3 ox= floor(x+ 0.5) ;  // round (x)  i s  a GLSL 1.30  feature\n  vec3 gx = x-ox;//  Normalise  gradients  i m p l i c i t l y  by  s c a l i n g m\n  m *= taylorInvSqrt(gx*gx+gy*gy) ;// Compute  f i n a l  noise  value  at P\n  vec3 g;g.x=gx.x*x0.x+gy.x*x0.y;g.yz=gx.yz*x12.xz+gy.yz*x12.yw;//  Scale  output  to  span  range  [-1 ,1]//  ( s c a l i n g  f a c t o r  determined by  experiments )\n  return  130.0*dot (m,g) ;\n}\n\n\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  float size = 12.;\n  uv *= size;\n  uv += iTime * vec2(1,0) + vec2(cos(iTime) * 0.2,0);\n  float PixelSize = 0.08;\n  //uv = floor(uv / PixelSize) * PixelSize;\n  \n  vec2 pos = vec2(0);\n  vec4 v = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.)) * 0.25),-4. + sin(iTime * 0.5) * 0.5,pos);\n  if(v.a < 0.3) {\n    out_color = vec4(1);\n  }\n  else {\n    vec4 waterv = vec4(0.5);\n    int iterations = 4;\n    for(int i = 0; i < iterations; i++) {\n    waterv += (random(voronoi(uv + random(vec2(i,float(i) + 0.9)) * pow(4.,float(i)), -2.).xy) - 0.5) * (float(iterations-i)/(float(iterations)/30.));\n    }\n    float depth = pow(floor((pos.y + 10. * size) / (size / 0.2)) / 8.,0.3) * pow(floor((-pos.y + 5. * size) / (0.4 * size)) / 12.,10.);\n    float noise = (snoise(uv / 10.) + 1.) + 0.5;\n    out_color = vec4(0.1,0.4,0.9,1) * pow(v.a,0.4) / 8. * pow(point(waterv.xy).y,0.4) * depth * noise * 4.;\n    \n    vec4 nv = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.) + 900.) * 0.25 + 0.4),-4.  + sin(iTime * 0.5) * 0.5,pos);\n    if(nv.a < 0.3) {\n      out_color *= 0.5;\n    }\n  }\n    vec2 position;\n    vec4 lastv = voronoi(uv*20.,20.,position);\n    out_color *= vec4(1.-random(position.xy)/8.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 128], [130, 130, 152, 152, 206], [208, 208, 237, 237, 293], [295, 295, 354, 354, 1171], [1173, 1173, 1213, 1213, 1264], [1272, 1272, 1294, 1294, 1338], [1339, 1339, 1367, 1367, 1418], [1419, 1419, 1440, 1440, 2793]]}
{"id": "Wd3BRl", "name": "Audio Waveform Visualizer v2", "author": "oneshade", "description": "Version two of my shader \"Audio Waveform Visualizer v1\". I made the resolution adjustable in order to avoid jaggedness.", "tags": ["visualization", "waveform"], "likes": 4, "viewed": 171, "published": 3, "date": "1605720050", "time_retrieved": "2024-07-30T20:34:57.772184", "image_code": "float samplePiecewiseLinear(in float x, in float res) {\n    float x1 = floor(x * res) / res;\n    float y1 = texture(iChannel0, vec2(x1, 0.0)).x;\n\n    float x2 = ceil(x * res) / res;\n    float y2 = texture(iChannel0, vec2(x2, 0.0)).x;\n\n    float interp = fract(x * res);\n    return y1 * (1.0 - interp) + y2 * interp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float curSample = samplePiecewiseLinear(uv.x, 10.0);\n    vec3 color = vec3(smoothstep(0.03, 0.0, abs(uv.y - curSample)));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 317], [319, 319, 374, 374, 578]]}
{"id": "tsdfRf", "name": "sin cos waves", "author": "henrmota", "description": "Playing around.", "tags": ["noise"], "likes": 2, "viewed": 323, "published": 3, "date": "1605709845", "time_retrieved": "2024-07-30T20:34:58.595982", "image_code": "#define EPS 1./iResolution.y\nfloat f(vec2 p) {\n    float freq = texture(iChannel1, vec2(0., 0.)).r * 3.;\n    float amp = texture(iChannel1, vec2(0.1, 0.)).r ;\n    return p.y - \n        sin(freq * 3. * p.x + freq * mod(iTime, 5.))*0.5 * amp\n        - cos(freq * 2. * p.x + amp * mod(iTime, 5.))*0.5 * amp;\n}\n\nvec2 grad( in vec2 x)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n                  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord- iResolution.xy)/iResolution.y;\n\t\n    // Time varying pixel color\n    vec3 col = vec3(0);\n   \n    \n    float value = abs(f(uv));\n    vec2 g = grad(uv);\n    \n    \n    //value = abs(value);\n    float d = value/length(g);\n    col += smoothstep(10.*EPS, 3.*EPS, d);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = mix(texture(iChannel1, uv), texture(iChannel0, uv), 0.1);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 46, 46, 306], [308, 308, 331, 331, 457], [477, 477, 534, 584, 935]]}
{"id": "wddBRX", "name": "Laves  Graph ", "author": "mla", "description": "[url]https://en.wikipedia.org/wiki/Laves_graph[/url]\n\nSee header for controls.", "tags": ["lattice", "laves", "tridiamond"], "likes": 17, "viewed": 666, "published": 3, "date": "1605701119", "time_retrieved": "2024-07-30T20:34:59.356947", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Laves Graph: https://en.wikipedia.org/wiki/Laves_graph\n// Matthew Arcus, mla, 2020\n//\n// Also known as the tridiamond and the K4 lattice.\n//\n// Controls:\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance\n// i: apply inversion\n// c: show fundamental cell\n// r: autorotation\n// z: zooming\n//\n// A cubic lattice with each vertex connected to 3 others. Vertices are in\n// 4 classes, here coloured red, green, blue, yellow and edges in 6\n// classes, edges in each class have the same coloured end vertices\n// and are parallel.\n//\n// The lattice is chiral and the edges form spirals, in fact, the\n// lattice is related to the gyroid surface - see Alan Schoen's AMS\n// letter here: http://www.ams.org/notices/200806/tx080600663p.pdf\n//\n// The construction is from Coxeter - in a 4x4x4 cell, put vertices\n// at (0,0,0),(2,2,2),(1,2,3),(3,0,1),(2,3,1),(0,1,3),(3,1,2),(1,3,0)\n// and join the vertices distance sqrt(2) apart. Here we offset\n// Coxeter's coordinates by 1 as this makes for slightly more\n// efficient drawing and also makes a nice symmetric fundamental cell\n// (press 'c' to see just the cell).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint maxsteps = 100;\nfloat maxdist = 20.0;\nfloat pradius = 0.3;  // Point radius\nfloat lradius = 0.1;  // Line radius\n\nbool dorotate = true; // Autorotate\nbool doinvert = true;\nbool showregion = false;\nbool dozoom = false;\n\nfloat cell(vec3 p, out int type) {\n  type = 0;\n  float d = 1e8, d0 = d;\n  d = min(d, point(p,vec3(1,1,1))-pradius);\n  d = min(d, point(p,vec3(3,3,3))-pradius);\n  if (d < d0) { d0 = d; type = 1; }\n\n  // Points with a 0 coordinate repeat at 4.\n  d = min(d, point(p,vec3(2,3,0))-pradius);\n  d = min(d, point(p,vec3(2,3,4))-pradius); // Repeated point (etc.)\n  d = min(d, point(p,vec3(0,1,2))-pradius);\n  d = min(d, point(p,vec3(4,1,2))-pradius);\n  if (d < d0) { d0 = d; type = 2; }\n\n  // Cyclic permutations of previous 4 points\n  d = min(d, point(p,vec3(0,2,3))-pradius);\n  d = min(d, point(p,vec3(4,2,3))-pradius);\n  d = min(d, point(p,vec3(2,0,1))-pradius);\n  d = min(d, point(p,vec3(2,4,1))-pradius);\n  if (d < d0) { d0 = d; type = 3; }\n\n  // Cyclic permutations of previous 4 points\n  d = min(d, point(p,vec3(3,0,2))-pradius);\n  d = min(d, point(p,vec3(3,4,2))-pradius);\n  d = min(d, point(p,vec3(1,2,0))-pradius);\n  d = min(d, point(p,vec3(1,2,4))-pradius);\n  if (d < d0) { d0 = d; type = 4; }\n\n  d = min(d, segment(p,vec3(1,1,1),vec3(0,1,2))-lradius); // -1,0,1\n  d = min(d, segment(p,vec3(0,1,2),vec3(0,2,3))-lradius); // 0,1,1\n  d = min(d, segment(p,vec3(0,2,3),vec3(1,2,4))-lradius); // 1,0,1\n  d = min(d, segment(p,vec3(1,2,4),vec3(2,3,4))-lradius); // 1,1,0\n  d = min(d, segment(p,vec3(2,3,4),vec3(3,3,3))-lradius); // 1,0,-1\n  \n  // Cyclic permutations of previous 5 edges\n  d = min(d, segment(p,vec3(1,1,1),vec3(2,0,1))-lradius);\n  d = min(d, segment(p,vec3(2,0,1),vec3(3,0,2))-lradius);\n  d = min(d, segment(p,vec3(3,0,2),vec3(4,1,2))-lradius);\n  d = min(d, segment(p,vec3(4,1,2),vec3(4,2,3))-lradius);\n  d = min(d, segment(p,vec3(4,2,3),vec3(3,3,3))-lradius);\n  \n  // Cyclic permutations of previous 5 edges\n  d = min(d, segment(p,vec3(1,1,1),vec3(1,2,0))-lradius);\n  d = min(d, segment(p,vec3(1,2,0),vec3(2,3,0))-lradius);\n  d = min(d, segment(p,vec3(2,3,0),vec3(2,4,1))-lradius);\n  d = min(d, segment(p,vec3(2,4,1),vec3(3,4,2))-lradius);\n  d = min(d, segment(p,vec3(3,4,2),vec3(3,3,3))-lradius);\n\n  if (d < d0) { d0 = d; type = 0; }\n  return d;\n}\n\nfloat getdist(vec3 p, out int type) {\n  float k = 1.0;\n  if (doinvert) {\n    k = 0.3*dot(p,p);\n    p /= k;\n  }\n  p += 2.0; // Centre region\n  p.xy += vec2(0.5,-0.5); // Align to centre of gyroid\n  if (!showregion) {\n    if (dozoom) p.z += 2.0*iTime;\n    // Space division into 4x4x4 cubes\n    p = mod(p,4.0);\n  }\n  return k*cell(p,type);\n}\n\nfloat getdist(vec3 p) {\n  int type;\n  return getdist(p,type);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  float precis = 0.001;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert (i < 30);\n    vec3 p = ro + t*rd;\n    float d = getdist(p);\n    if (doinvert) d *= 0.6;\n    // Longer distance estimates can be inaccurate, so clamp to avoid overstepping.\n    t += min(d,0.8);\n    if (t < 0.0 || t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec3 getnormal(vec3 p) {\n  float d = getdist(p);\n  vec2 e = vec2(0.001, 0);\n  vec3 n = d - vec3(getdist(p-e.xyy),\n                    getdist(p-e.yxy),\n                    getdist(p-e.yyx));\n  return normalize(n);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.yx = rotate(p.yx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 getcolor(int type) {\n  if (type == 0) return vec3(0.5);\n  if (type == 1) return vec3(1,0,0);\n  if (type == 2) return vec3(0,1,0);\n  if (type == 3) return vec3(0,0,1);\n  if (type == 4) return vec3(1,1,0);\n  return vec3(0,1,1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  doinvert = key(CHAR_I);\n  showregion = key(CHAR_C);\n  dorotate = !key(CHAR_R);\n  dozoom = !key(CHAR_Z);\n\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 m = iMouse.xy/iResolution.y;\n  vec3 ro = vec3(0,0,-6);\n  vec3 rd = vec3(uv,2);\n  vec3 light = normalize(vec3(1,2,-3));\n  light = transform(light);\n  maxdist *= exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  //ro.z *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  ro.z -= 0.5*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n  ro = transform(ro);\n  rd = transform(rd);\n  rd = normalize(rd);\n  float t = march(ro, rd);\n  vec3 background = vec3(0.9,0.8,1.0);\n  if (doinvert) background = vec3(0.1);\n  vec3 col = background;\n  if (t < maxdist) {\n    vec3 p = ro+t*rd;\n    int type;\n    getdist(p,type);\n    vec3 n = getnormal(p);\n    col = getcolor(type);\n    float diffuse = mix(1.0,dot(n,light),0.8);\n    col *= diffuse;\n    float fog = t/maxdist;\n    col = mix(col,background,fog);\n  }\n    \n  col = pow(col,vec3(0.4545));\t// gamma correction\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else   \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p,q);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_O = 79;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel0, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel1, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1528, 1528, 1562, 1562, 3589], [3591, 3591, 3628, 3628, 3930], [3932, 3932, 3955, 3955, 3995], [3997, 3997, 4028, 4028, 4391], [4393, 4393, 4417, 4417, 4608], [4610, 4610, 4637, 4637, 4927], [4929, 4929, 4954, 4954, 5161], [5163, 5163, 5215, 5215, 6298]]}
{"id": "tdcBzf", "name": "Optimized cube", "author": "been_jamming", "description": "Optimizing my earlier cube ray-tracing experiment.", "tags": ["raytracing", "lighting"], "likes": 6, "viewed": 154, "published": 3, "date": "1605667115", "time_retrieved": "2024-07-30T20:35:00.250558", "image_code": "#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n\ncube global_cube;\n\nray get_camera_ray(vec2 pixel){\n    float least_side;\n    \n    pixel -= vec2(0.5);\n    least_side = min(iResolution.x, iResolution.y);\n    return ray(vec3(0), vec3(FOV_CONST*pixel.x*iResolution.x/least_side, FOV_CONST*pixel.y*iResolution.y/least_side, FOV_CONST));\n}\n\n//I include this because I eventualy plan to have more than one cube in the scene\nbool lit(vec3 p, vec3 light){\n    ray r;\n    vec3 intersect_pos;\n    int side;\n    float edge_dist;\n    \n    p = p + (p - light)*0.01;//We don't want the ray to collide with the original triangle\n    r = ray(p, light - p);\n    intersect_pos = ray_cube_intersect(global_cube, r, side, edge_dist);\n    \n    return side != -1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ray camera_ray;\n    vec3 intersect_pos;\n    vec3 intersect_normal;\n    vec4 current_color;\n    vec3 light_pos = vec3(2.0, 2.0, 0.0);\n    float l;\n    float edge_dist;\n    int side;\n    \n    intersect_normals[0] = vec3(-1, 0, 0);\n    intersect_normals[1] = vec3(1, 0, 0);\n    intersect_normals[2] = vec3(0, -1, 0);\n    intersect_normals[3] = vec3(0, 1, 0);\n    intersect_normals[4] = vec3(0, 0, -1);\n    intersect_normals[5] = vec3(0, 0, 1);\n    global_cube.orientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n\tglobal_cube.center = vec3(0, 0, 4);\n    \n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    intersect_pos = ray_cube_intersect(global_cube, camera_ray, side, edge_dist);\n    current_color = edge_dist >= 6.0/7.0 ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(1.0);\n    current_color = edge_dist >= 5.0/7.0 && edge_dist < 6.0/7.0 ? vec4(1.0, 0.5, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 4.0/7.0 && edge_dist < 5.0/7.0 ? vec4(1.0, 1.0, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 3.0/7.0 && edge_dist < 4.0/7.0 ? vec4(0.0, 1.0, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 2.0/7.0 && edge_dist < 3.0/7.0 ? vec4(0.0, 0.0, 1.0, 1.0) : current_color;\n    current_color = edge_dist >= 1.0/7.0 && edge_dist < 2.0/7.0 ? vec4(0.3, 0.0, 0.5, 1.0) : current_color;\n    current_color = edge_dist < 1.0/7.0 ? vec4(0.6, 0.0, 0.8, 1.0) : current_color;\n    \n    if(side != - 1){\n        if(lit(intersect_pos, light_pos)){\n            intersect_normal = apply_orientation(intersect_normals[side], global_cube.orientation);\n            l = max(dot(intersect_normal, normalize(intersect_pos - light_pos)), 0.0);\n            fragColor = current_color*(l*3.0 + 1.0)/4.0;\n            fragColor.w = 1.0;\n        } else {\n            fragColor = current_color*0.25;\n            fragColor.w = 1.0;\n        }\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "struct cube{\n    vec3 center;\n    vec4 orientation;\n};\n\nstruct ray{\n    vec3 p;\n    vec3 vec;\n};\n    \nvec3 intersect_normals[6];\n\nvec4 create_orientation(vec3 axis, float angle){\n    float len;\n    vec4 outvec;\n    \n    len = length(axis);\n    axis *= sin(angle)/len;\n    outvec.yzw = axis;\n    outvec.x = cos(angle);\n    \n    return outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n    return vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n    vec4 outvec;\n    \n    outvec.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    outvec.y = a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z;\n    outvec.z = a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y;\n    outvec.w = a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x;\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n    vec4 v;\n    \n    v.x = 0.0;\n    v.yzw = p.xyz;\n    return compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nray apply_orientation_ray(ray r, vec4 o){\n    return ray(apply_orientation(r.p, o), apply_orientation(r.vec, o));\n}\n\n//Gets the intersection data between a ray and a cube with side length of 1\nvec3 ray_cube_intersect(cube c, ray r, out int side, out float edge_dist){\n    ray translated_ray;\n    float d = 10000.0;\n    float t = 0.0;\n    vec2 comps;\n    bool best;\n    \n    side = -1;\n    edge_dist = 0.0;\n    \n    translated_ray = ray(r.p - c.center, r.vec);\n    translated_ray = apply_orientation_ray(translated_ray, inverse_orientation(c.orientation));\n    \n    t = (1.0 - translated_ray.p.x)/translated_ray.vec.x;\n    comps = t*translated_ray.vec.yz + translated_ray.p.yz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 0 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.x)/translated_ray.vec.x;\n    comps = t*translated_ray.vec.yz + translated_ray.p.yz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 1 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (1.0 - translated_ray.p.y)/translated_ray.vec.y;\n    comps = t*translated_ray.vec.xz + translated_ray.p.xz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 2 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.y)/translated_ray.vec.y;\n    comps = t*translated_ray.vec.xz + translated_ray.p.xz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 3 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (1.0 - translated_ray.p.z)/translated_ray.vec.z;\n    comps = t*translated_ray.vec.xy + translated_ray.p.xy;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 4 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.z)/translated_ray.vec.z;\n    comps = t*translated_ray.vec.xy + translated_ray.p.xy;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 5 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    return d*r.vec + r.p;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 103, 103, 338], [340, 422, 451, 451, 747], [749, 749, 803, 803, 2802]]}
{"id": "wscfzX", "name": "Sound visualizer with hexagons", "author": "levonchic", "description": "Remake for this one https://www.shadertoy.com/view/Xdsfzj \nA bit refactored with more detailed options and tweaks and no buffers", "tags": ["sound", "visualizer", "geometry"], "likes": 4, "viewed": 446, "published": 3, "date": "1605655352", "time_retrieved": "2024-07-30T20:35:01.286788", "image_code": "// MIT License (c) bitrate16\n// Decorative settings\n#define BAR_HEIGHT        0.75        // Bar height (0.0 ~ 1.0)\n#define BAR_PERIOD        8           // Bar stepping\n#define BAR_WIDTH         8           // Bar height\n#define BAR_COLOR         vec4(1.0)   // Bar colors\n\t\t\t\t\t\t\t\t\t  // Triangle color\n#define BG_TRIANGLE       vec4(-.065) \n\t\t\t\t\t\t\t\t\t  // Primary background color\n#define BG_COL            vec4(0.065) \n\t\t\t\t\t\t\t\t\t  // Secondary background color\n#define BG_NCOL           vec4(0.005) \n#define BG_GRADIENT_START 0.49        // Gradient effect start value\n#define BG_GRADIENT_SCALE 0.45        // Gradient effect scale\n\n// Input settings\n#define IN_SOUND          0.25        // Sound probe coord (0.25 - Frequences, 0.75 - Raw wave)\n#define IN_TRIANGLE       0.25        // Sound probe for triangle shake (0.25 - Frequences, 0.75 - Raw wave)\n#define IN_TRIANGLE_HOR   0.0         // Sound x probe for triangle shake (For x)\n#define IN_TRIANGLE_SCALE 0.8         // Scale of triangle shake\n\n// Hexagonal prefences\n#define HEX_0_SPEED  1.0 // Speed of Hexagon 0 (Inner)\n#define HEX_1_SPEED -0.5 // Speed of Hexagon 1\n#define HEX_2_SPEED  0.6 // ...\n#define HEX_3_SPEED -0.7 // ...\n#define HEX_4_SPEED  0.8 // ...\n#define HEX_5_SPEED -0.9 // ...\n#define HEX_6_SPEED  1.0 // ...\n#define HEX_7_SPEED -1.1 // ...\n\n// Left/Right alignment\nfloat signv(vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool inTriangle(vec2 p, vec2 pos, float d) {\n    float side2 = d * 0.866025405;\n    vec2 v1 = vec2(pos.x,         pos.y + d);\n    vec2 v2 = vec2(pos.x - side2, pos.y - d / 2.0);\n    vec2 v3 = vec2(pos.x + side2, pos.y - d / 2.0);\n    \n    bool b1, b2, b3;\n    b1 = signv(p, v1, v2) < 0.0;\n    b2 = signv(p, v2, v3) < 0.0;\n    b3 = signv(p, v3, v1) < 0.0;\n    \n    return (b1 == b2) && (b2 == b3);\n}\n\nbool inHexagon(vec2 p, vec2 pos, float d, float a) {\n    float x_ = pos.x - p.x;\n    float y_ = pos.y - p.y;\n    float s_ = sin(a);\n    float c_ = cos(a);\n    float dx = abs(x_ * c_ - y_ * s_)/d;\n    float dy = abs(x_ * s_ + y_ * c_)/d;\n    float ar = 0.25 * sqrt(3.0);\n    return (dy <= ar) && (ar * dx + 0.25 * dy <= 0.5 * ar);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = iResolution.xy * 0.5;\n    float centerLength = length(center);\n    float maxResolution = min(iResolution.x, iResolution.y);\n    \n    // Background: 8 hex + triangle + vingette\n    fragColor = vec4(BG_GRADIENT_START - length(fragCoord.xy - center) / centerLength * BG_GRADIENT_SCALE);\n    \n    // 1/3 of maximal dimension of iResolution\n    float d = 0.333 * maxResolution;\n    if(inTriangle(fragCoord, center, d * (0.9 + IN_TRIANGLE_SCALE * texture(iChannel0, vec2(IN_TRIANGLE_HOR, IN_TRIANGLE)).x))) \n        fragColor += BG_TRIANGLE;\n    if(inHexagon(fragCoord, center, d, iTime * HEX_0_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 2.0, iTime * HEX_1_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 3.0, iTime  * HEX_2_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 4.0, iTime * HEX_3_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 5.0, iTime  * HEX_4_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 6.0, iTime * HEX_5_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 7.0, iTime  * HEX_6_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 8.0, iTime * HEX_7_SPEED))\n        fragColor += BG_NCOL;\n    \n    // Locate bars\n    int ifragX = int(fragCoord.x) - BAR_WIDTH / 2;\n\tint ifragXmod = (ifragX + (BAR_PERIOD + BAR_WIDTH)) % (BAR_PERIOD + BAR_WIDTH);\n    \n    float barXfrag = float(ifragX - ifragXmod);\n    float value = texture(iChannel0, vec2(barXfrag / iResolution.x, IN_SOUND)).x;\n    float res2y = iResolution.y * 0.5;\n        // ifragXmod < BAR_WIDTH && \n    if (ifragXmod < BAR_WIDTH && abs(res2y - fragCoord.y) / res2y < value * BAR_HEIGHT)\n        fragColor += BAR_COLOR;\n}", "image_inputs": [{"id": 24630, "src": "https://soundcloud.com/itzmusicfree/rarkid-moonlapse", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscfzX.jpg", "access": "api", "license": "mit", "functions": [[1322, 1346, 1386, 1386, 1462], [1464, 1464, 1508, 1508, 1862], [1864, 1864, 1916, 1916, 2195], [2197, 2197, 2252, 2252, 4099]]}
{"id": "Ws3Bzf", "name": "Human Meat Grinder", "author": "jpupper", "description": "So , I was trying to make a colorfull , full of love shader but i came out with this. \n\n\nSpecial thanks to kali for the structure\n\ncode is in spanish but whatever.", "tags": ["raymarching"], "likes": 16, "viewed": 528, "published": 3, "date": "1605632113", "time_retrieved": "2024-07-30T20:35:02.363908", "image_code": "\n// RESTAR UN OBJETO A OTRO\n\n// Igual al ejemplo anterior, pero reemplazamos la esfera central\n// por otro objeto que resulta de restarle a un cubo la esfera\n\n\n// VARIABLES GLOBALES\n\nfloat det = 0.05;\nfloat maxdist = 800.;\nint maxsteps = 100;\nvec3 objcol;\n\n// FUNCION DE ROTACION\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// FUNCIONES DE DISTANCIA PRIMITIVAS \n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\n// construccion de un objeto usando las primitivas combinadas con max\n// para obtener su interseccion. Esto generar una forma que es igual\n// al espacio donde formas combinadas se intersecten.\n// en este caso intersectamos un cubo con una esfera\n\nfloat obj1(vec3 p,vec3 s) \n{\n\n    s.y+=1.-abs(p.x);\n    s.y*=.2;\n    float box = box(p, s);\n\n   // p.y+=fract(p.y*.1+time);\n    //p.x+=fract(time);09\n    float sph = sphere(p,0.9);\n    float d = box;\n    return d;\n}\n\nfloat obj2(vec3 p) \n{\n    float box = box(p, vec3(0.2,500.1,0.2));\n  \n    // de esta manera le restamos al cubo la forma de la esfera\n    float d = box;\n    return d;\n}\n\n\n// FUNCION DE ESTIMACION DE DISTANCIA\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \n    \nfloat de(vec3 p) \n{\n\n    float ms = floor(10.0)+1.;\n\n \n    p.z+=iTime*10.;\n       float indexy = floor(p.z/ms);\n    // rotamos en dos ejes\n    p.xy *= rot(iTime*.03+indexy);\n\n    float id2 = floor(p.z/ms);\n    \n    p.x = mod(p.x, ms) - ms/2.;\n    p.z = mod(p.z, ms) - ms/2.;\n \n    //p.z+=sin(id2*4+time);\n    //p.y = mod(p.y, ms*2.) - ms*2/2;\n    \n    \n    vec3 p3 = p;\n    float obj2 = obj2(p3); //Columna\n    //p.xz*=rot(time);\n   //  p.xy*=rot(time);\n   // p=abs(p);\n    //0p -= sin(time)*.1+.51;\n   \n    vec3 p2 = p;\n    float ms2 = 3.0;\n    \n    p2.y+=iTime;\n   // p2.z+=time;\n    float id = floor(p2.y/ms2);\n    \n   \n    p2.y = mod(p2.y,ms2) -ms2/2.;\n    p2.xz*=rot(iTime*2.+id*10.);\n \n    \n    float obj1 = obj1(p2,vec3(0.8+sin(id+iTime*5.)*.5+.5,0.,0.0));\n    \n   // obj1 = opSmoothIntersection(obj1,obj2,-0.8);\n    //p.z =sin(p.x*1);\n   //   obj1 = max(obj1, sphere(p2, sin(time)*.02+1.1));\n    // obtenemos la distancia minima entre obj1 y obj2 para combinarlas en la escena\n    float d = opSmoothUnion(obj1, obj2,.0);\n      //    d = min(obj1, obj2);0\n     // d = obj2;\n    // coloreamos segun el objeto con el que choca el rayo\n    if (d == obj2) objcol = vec3(.0, 0.0, 0.0);\n    if (d == obj1) objcol = vec3(sin(id*5.+iTime)*.5+.5, sin(id*5.+iTime)*.1+.1, 0.0);\n\n    return d*0.2;\n}\n\n\n\n\n\n\n\n\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n    \n    vec3 lightdir = normalize(vec3(1.5, 1.2, -1.)); \n    \n    // aqu definimos el color del objeto segn la variable objcolor seteada en la funcion\n    // de distancia. La guardamos en col antes de llamar a la funcion normal\n    vec3 col = objcol;\n    \n    \n    vec3 n = normal(p);\n    \n    float diff = max(0.2, dot(lightdir, n));\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0.2, dot(lightdir, refl)), 5.);\n    \n    float amb = .1;\n    \n    \n    \n\n    return (col*(amb + diff) + spec * .8);\n    \n}\n\n\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p =vec3(0);\n    vec3 col = vec3(0);\n    \n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    }\n    else \n    {\n        // para este background estoy ubicando la posicin en el fondo de la escena\n        // from + distancia mxima * direccin del rayo\n        p = from + maxdist * dir;\n        // usamos esta posicin para dibujar un fondo\n        // en este caso es un fondo simple usando la funcin sin\n       // col += vec3(.0);\n    }\n    \n     col = mix(vec3(.0),col, exp(-.0005*td*td));\n    \n    \n    return col;    \n}\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    vec3 from = vec3(0., 0., -15.);\n \n    vec3 dir = normalize(vec3(uv, 1.));\n    dir.yz*=rot(.8);\n    \n    from.x-=sin(iTime);\n \n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3Bzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 300, 300, 359], [401, 401, 435, 435, 465], [467, 467, 494, 494, 572], [823, 823, 851, 851, 1038], [1040, 1040, 1061, 1061, 1208], [1211, 1249, 1301, 1301, 1400], [1402, 1402, 1460, 1460, 1560], [1562, 1562, 1621, 1621, 1720], [1731, 1731, 1750, 1750, 3026], [3055, 3055, 3077, 3077, 3196], [3216, 3216, 3246, 3246, 3777], [3808, 3808, 3842, 3842, 4589], [4600, 4600, 4657, 4657, 4958]]}
{"id": "WsdfRj", "name": "Decay for Edge/Corner", "author": "iY0Yi", "description": "Found on iq's youtube.\nhttps://www.youtube.com/watch?v=s5NGeUV2EyU", "tags": ["edge", "decay"], "likes": 25, "viewed": 648, "published": 3, "date": "1605613199", "time_retrieved": "2024-07-30T20:35:03.432052", "image_code": "// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.002\n#define MAX_DIST 1000.\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n\n#define AMB_COL vec3(.2, 0.4717, 0.8500)\n#define AMB_STRENGTH 0.6100\n#define FOG_COL vec3(1., 0.7717, 0.6500)\n#define FOG_START 0.5740\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n// \"init\": initialize camera and lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\nvec3  sdLight001_dir;\nvec3  sdLight001_col;\nfloat sdLight001_clip_start;\nfloat sdLight001_clip_end;\nfloat sdLight001_softness;\n#define L0_dir sdLight001_dir\n#define L0_col sdLight001_col\n#define L0_str sdLight001_clip_start\n#define L0_end sdLight001_clip_end\n#define L0_sft sdLight001_softness\nvec3  sdLight002_dir;\nvec3  sdLight002_col;\nfloat sdLight002_clip_start;\nfloat sdLight002_clip_end;\nfloat sdLight002_softness;\n#define L1_dir sdLight002_dir\n#define L1_col sdLight002_col\n#define L1_str sdLight002_clip_start\n#define L1_end sdLight002_clip_end\n#define L1_sft sdLight002_softness\n\nvoid init()\n{\n\tCamera_pos = vec3(0., 38., 4.2);\n\tCamera_quat = vec4(0.0205, 0.7140, 0.6996, 0.0200);\n\tCamera_fov = 0.085;\n\tsdLight001_dir = normalize(vec3(-0.5, 0.5, 0.5));\n\tsdLight001_col = vec3(1., 0.9081, 0.7761)*2.;\n\tsdLight001_clip_start = 0.0010;\n\tsdLight001_clip_end = 50.;\n\tsdLight001_softness = 10.;\n\tsdLight002_dir = normalize(vec3(0.0538, -0.6674, -0.7427));\n\tsdLight002_col = vec3(0.1523, 0.1523, 0.1523)*.5;\n\tsdLight002_clip_start = 0.0500;\n\tsdLight002_clip_end = 30.;\n\tsdLight002_softness = 50.;\n\n}\n\nvec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n    vec3 dir = normalize(vec3(0,-.025,-1));//quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Camera_pos.xzy;\n    float fov = Camera_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_WHITE vec3(0.6415, 0.5984, 0.4882)*.4\n#define MAT_BRICK vec3(0.5025, 0.2454, 0.1800)*.7\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    p.y+=iTime*.05;\n    R(p.xz, sin(iTime*.25)*.5);\n    \n    float n = sms(.5, .0, fbm(p, 2)*fbm(p*8.+1., 3))*.5 + noise(p*60.)*.025;\n    \n    p += noise(p*100.+1.)*.002 + n*.01;\n    \n    vec3 q = p;\n    \n    const float MARGIN = 2.8;\n    const float MOD_SIZE = 2.1;\n    const float ANIM_SPEED = 1.;\n    float rounded;\n    \n    q.y = mod(q.y, MOD_SIZE)-MOD_SIZE*.5;\n    \n    // Radius\n    float minR = .025;\n    float maxR = MOD_SIZE*.3; // 0.5 == over all\n    float stepR = floor((sin(iTime*ANIM_SPEED)+1.)*5.)*.1; // .0, .1, .2, ... 1.  \n    float r = stepR * maxR + minR;\n    \n    q.x -= MARGIN*.5;\n    \n    // Cube bricks\n    rounded = sdBox(q, vec3(1)-r)-r;\n\td = sdBox(q, vec3(1)-minR)-minR;\n    d += abs(d-rounded)*n;\n    res = v4OpUnion(vec4(d, MAT_BRICK), res);\n    \n    q.x += MARGIN;\n    \n    // Cylinder bricks\n    rounded = sdCappedCylinder(q, vec2(1)-r)-r;\n    d = sdCappedCylinder(q, vec2(1)-minR)-minR;\n    d += abs(d-rounded)*n;\n\tres = v4OpUnion(vec4(d, MAT_BRICK), res);\n    \n    // White glue\n    q=p;\n    q.y += MOD_SIZE*.5;\n    q.y = mod(q.y, MOD_SIZE)-MOD_SIZE*.5;\n    q+=n*.1;\n    \n    q.x -= MARGIN*.5;\n    d = sdBox(q, vec2(.95, .05).xyx-minR)-minR;\n    res = v4OpUnion(vec4(d, MAT_WHITE), res);    \n\n    q.x += MARGIN;\n    d = sdCappedCylinder(q, vec2(.95, .05)-minR)-minR;\n    res = v4OpUnion(vec4(d, MAT_WHITE), res);\n    \n    res.x*=.75;\n    return res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    int i = 0;\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n        res = min( res, k*h/t);\n        t += h;\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 5.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=AMB_COL*.1;\n    }\n    else\n    {\n        vec3 n = normal(p);\n\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir));\n        float shadow = shadow(p+n*.0001, n);\n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, 5.);\n        ao += ambientOcclusion(p, n, .5, 5.);\n        ao += ambientOcclusion(p, n, 2., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        vec3 shadeLight1 = vec3(L0_col*light1*1.5);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\n        col = shadeLight1;\n        col *= shadow;\n        col += light2*ao*1.;\n        col += ao*AMB_COL*1.;\n        col *= base_col;\n    }\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n    init();\n    camera(uv);\n    render();\n    col *= vec3(1.-pow(length(uv), 2.5)*.5);\n\tcol = ACESFilm(col);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// hashom & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\nfloat noise( in float co )\n{\n    float p = floor(co);\n    float f = fract(co);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 co) {\n    vec3 p = floor(co);\n    vec3 f = fract(co);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec3 n, int rep){\n    float sum = 0.0;\n    float amp= .9;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*float(rep);\n        amp *= 1./float(rep);\n    }\n    return sum;\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 445, 469, 469, 539], [1298, 1298, 1311, 1311, 1810], [1866, 1974, 2013, 2013, 2092], [2094, 2094, 2116, 2116, 2612], [2614, 2703, 2745, 2745, 2856], [2858, 2858, 2877, 2877, 2915], [2917, 2917, 2945, 2945, 3026], [3028, 3028, 3067, 3067, 3089], [3091, 3091, 3128, 3128, 3154], [3347, 3347, 3369, 3369, 4818], [4820, 4892, 4910, 4910, 5268], [5270, 5342, 5363, 5489, 5695], [5697, 5769, 5799, 5799, 6125], [6127, 6275, 6307, 6307, 6419], [6420, 6420, 6465, 6465, 6567], [6568, 6568, 6652, 6652, 7056], [7058, 7130, 7171, 7171, 7344], [7346, 7418, 7433, 7433, 8255], [8257, 8329, 8351, 8351, 8491], [8493, 8565, 8620, 8620, 8905]]}
{"id": "tddBz2", "name": "cheap sine noise 2", "author": "johan2", "description": "a variation without frequency or amplitude difference between the iterations\nhttps://www.shadertoy.com/view/WscBz2", "tags": ["noise", "sines"], "likes": 10, "viewed": 510, "published": 3, "date": "1605606115", "time_retrieved": "2024-07-30T20:35:04.385503", "image_code": "//variation of: https://www.shadertoy.com/view/WscBz2\n\n//identity rotated golden angle around x, then around y\n#define m3 mat3(-0.73736, 0.45628, 0.49808, 0, -0.73736, 0.67549, 0.67549, 0.49808, 0.54371)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 q = vec3(uv * 10., iTime * .2);\n   \tvec3 c = vec3(0);\n    for(int i = 0; i <8; i++){\n        q = m3 * q; \n        vec3 s = sin(q.zxy);\n        q += s * 2.;\n        c += s;\n    }\n    fragColor = vec4(mix(vec3((c.x + c.y + c.z) * 0.5), c, 0.5) * .15 + .5, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 262, 262, 571]]}
{"id": "wdtBz2", "name": "Circular Time Wipe", "author": "IWBTShyGuy", "description": "This is a circularly reduced version of the timewipe effect used in tiktok.", "tags": ["webcam"], "likes": 1, "viewed": 788, "published": 3, "date": "1605605984", "time_retrieved": "2024-07-30T20:35:05.356905", "image_code": "// The MIT License\n// Copyright  2020 IWBTShyGuy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wide = max(iResolution.x, iResolution.y);\n    float narrow = min(iResolution.x, iResolution.y);\n    float asp = wide / narrow;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = (uv - 0.5) * iResolution.xy / wide;\n    float r = 1.0 / asp - (iTime - START_RAG) * VELOCITY;\n    float len = abs(r - length(pos));\n    if (len < THICKNESS) {\n        float c = 1.0 - len / (THICKNESS * 2.0);\n        fragColor = vec4(c * c * c, c * c, c, 1.0);\n    } else fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wide = max(iResolution.x, iResolution.y);\n    float narrow = min(iResolution.x, iResolution.y);\n    float asp = wide / narrow;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = (uv - 0.5) * iResolution.xy / wide;\n    float r = 1.0 / asp - (iTime - START_RAG) * VELOCITY;\n    if (length(pos) < r)\n        fragColor = texture(iChannel0, uv);\n    else\n        fragColor = texture(iChannel1, uv);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float START_RAG = 5.0;\nconst float VELOCITY = 0.1;\nconst float THICKNESS = 0.01;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBz2.jpg", "access": "api", "license": "mit", "functions": [[52, 52, 109, 109, 610]]}
{"id": "wsdBR2", "name": "Whirling Reflections (Youtube)", "author": "scry", "description": "as seen on https://www.youtube.com/watch?v=QD51HsYwHX0\nbad attempt at reflections lol but still made a cool effect I'm happy with :)", "tags": ["3d", "raymarch", "youtube"], "likes": 6, "viewed": 402, "published": 3, "date": "1605592838", "time_retrieved": "2024-07-30T20:35:06.110890", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime iTime*0.067\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec3 ps(vec3 p) {\n    p.y += sin(p.z*.25)*0.6;\n    p.x += sin(p.z*0.1)*0.8;\n    return p;\n}\n\nvec3 pm(vec3 p, vec3 ro) {\n    float sd = .2;\n    sd += sin(p.z*0.002)*10.1;\n    p = ps(p);\n    float r = length(p.xy);\n    float pr = -p.z*sin(p.z*0.4)*0.1+sin(p.z*0.1)*2.;\n    //p.y = (fract(p.y*sd)-0.5)/sd;\n    p.xy = mix(p.xy,p.xy*r2d(pr),sin(p.z*0.01-iTime*2.)*0.5+0.5);\n    vec3 op = p;\n    vec3 pf = floor((p)*sd);\n    //p.y += time*1.;\n    p.z += iTime*sin(pf.y);\n    p.xyz = (fract(p.xyz*sd)-0.5)/sd;\n    return p;\n}\n\nvec4 map(vec3 p, vec3 ro) {\n    vec3 op = p;\n    float r = length(p.xy);\n    //p = pm(p*0.2,ro);\n    p = pm(p,ro);\n    float d = (length(p)-(0.2+sin(op.z*0.09)*0.15)*r*0.4);\n    //p = pm(vec3(op.xy,op.z),ro);\n    //d = min(d,(length(p)-(0.2+sin(op.z*0.09)*0.15)*r*0.4));\n    d = max(d,-(length(op.yx)-(.03+(op.z-ro.z)*0.05)+sin(op.z*2.2)*sin(op.z*0.08)));\n    //d = max(d,-(length(op-ro)-0.1));\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO, ii;\n    for (int i=0;i<160;i++) {\n        vec3 p = ro+rd*dO;\n        vec4 dS = map(p,ro);\n        dO += dS.w*0.4;\n        //dO += dS.w*(0.5+dS.z*0.9);\n        ii += 0.1;\n        if (dO > 500. || dS.w < 0.01) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec2 RM1(vec3 ro, vec3 rd) {\n    float dO, ii;\n    for (int i=0;i<110;i++) {\n        vec3 p = ro+rd*dO;\n        vec4 dS = map(p,ro);\n        dO += dS.w*0.13;\n        //dO += dS.w*(0.5+dS.z*0.9);\n        ii += 0.1;\n        if (dO > 200. || dS.w < 0.1) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec2 tv = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * tv;\n    \n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 ro = vec3(0.,0.,iTime*3.);\n    ro.xy = -ps(ro).xy;\n    float c= length(uv);\n    //ro.y -= sin(ro.z*.5)*0.9;\n    //ro.x -= sin(ro.z*0.4);\n    vec3 rd = normalize(vec3(uv,2.*sin(iTime*0.1)));\n    //rd.xy += ps(vec3(rd.xy,ro.z)).xy;\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec4 mp = map(p,ro);\n    //col += d.x*0.1;\n    //col = mp.xyz*4.;\n    vec2 dd = RM1(vec3(p.xy,d.x),vec3(mp));\n    col = vec3(cos(dd.y*2.),sin(dd.x*0.04),p.z/400.);\n    col.z = sin(col.r+col.b);\n    col += sin((d.x+ro.z)*0.01)*1.4;\n    col += sin(d.x*3.1)*1.3;\n    col = 1.-col.xzy;\n    col.y += sin((d.y*0.1-ro.z))*0.8;\n    col *= 0.5;\n    //col += dd.y*.04;\n    //if (dd.x < 0.2) {\n    //    col = sin(d.xxx*10.);\n    //}\n    vec3 bak = texture(iChannel0,tv).rgb;\n    //col = mix(clamp(col,0.,1.),bak,0.25+d.x*0.013);\n    tv += sin(p.xy*53.)*0.004;\n    vec3 bak1 = texture(iChannel0,tv).rgb;\n    //col = mix(col,bak1,0.56);\n    col = mix(col,bak,0.98);\n    fragColor = vec4(col, 1.);\n    \n    \n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 223]]}
{"id": "WstBR2", "name": "raytraced cube", "author": "been_jamming", "description": "My first attempt at ray-tracing a cube with a point light source. If anybody could tell me why the shadow flickers when a face transitions between facing towards and away the light source, I would greatly appreciate it.", "tags": ["raytracing"], "likes": 1, "viewed": 324, "published": 3, "date": "1605580174", "time_retrieved": "2024-07-30T20:35:06.912745", "image_code": "#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n\nvec4 orientation;\n\nvec3 get_camera_ray(vec2 pixel){\n    float least_side;\n    \n    pixel -= vec2(0.5);\n    least_side = min(iResolution.x, iResolution.y);\n    return vec3(0.15*pixel.x*iResolution.x/least_side, 0.15*pixel.y*iResolution.y/least_side, FOV_CONST);\n}\n\nbool lit(vec3 p, vec3 light){\n    vec3 ray;\n    float d;\n    int i;\n    vec3 pos;\n    vec3 normal;\n    triangle tri;\n    \n    p = p + (light - p)*0.001;//We don't want the ray to collide with the original triangle\n    for(i = 0; i < 12; i++){\n        tri = triangles[i];\n        tri = translate_triangle(tri, -p);\n        d = ray_triangle_intersect(light - p, rotate_triangle(tri, vec3(0, 0, 4) - p, orientation), pos, normal);\n        if(d > 0.0)\n            return false;\n    }\n    \n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tint i;\n    vec3 camera_ray;\n    vec3 pos;\n    vec3 intersect_pos;\n    vec3 intersect_normal;\n    vec3 normal;\n    float d;\n    float p;\n    float least_distance = RENDER_DISTANCE + 1.0;\n    vec4 current_color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 light_pos = vec3(10.0, 15.0, 0.0);\n    \n    orientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n\n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    //Loop through 12 triangles and determine if camera ray intersects them\n    for(i = 0; i < 12; i++){\n        d = ray_triangle_intersect(camera_ray, rotate_triangle(triangles[i], vec3(0, 0, 4), orientation), pos, normal);\n        if(d > 0.0 && d < least_distance){\n            least_distance = d;\n            current_color = colors[i];\n            intersect_pos = pos;\n            intersect_normal = normal;\n        }\n    }\n    \n    if(least_distance < RENDER_DISTANCE){\n        if(lit(intersect_pos, light_pos)){\n            p = abs(dot(normalize(intersect_normal), normalize(intersect_pos - light_pos)));\n            fragColor = current_color*(p*3.0 + 1.0)/4.0;\n            fragColor.w = 1.0;\n        } else {\n            current_color *= 0.25;\n            current_color.w = 1.0;\n            fragColor = current_color;\n        }\n    } else {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    }\n}", "image_inputs": [], "common_code": "//Verticies of cube triangle\n\nstruct triangle{\n    vec3 vertex0;\n    vec3 vertex1;\n    vec3 vertex2;\n};\n\ntriangle triangles[12] = triangle[12](triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(-1.0, 1.0, 3.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(-1.0, 1.0, 3.0), vec3(1.0, 1.0, 3.0)),\n                                      triangle(vec3(1.0, 1.0, 5.0), vec3(-1.0, 1.0, 5.0), vec3(1.0, 1.0, 3.0)),\n                                      triangle(vec3(-1.0, -1.0, 5.0), vec3(-1.0, -1.0, 3.0), vec3(-1.0, 1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 3.0), vec3(-1.0, 1.0, 5.0), vec3(-1.0, -1.0, 3.0)),\n                                      triangle(vec3(-1.0, -1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(-1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, -1.0, 3.0), vec3(1.0, -1.0, 5.0), vec3(-1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, -1.0, 3.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(1.0, 1.0, 3.0), vec3(1.0, 1.0, 5.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(-1.0, -1.0, 5.0), vec3(1.0, -1.0, 5.0)),\n                                      triangle(vec3(-1.0, 1.0, 5.0), vec3(1.0, 1.0, 5.0), vec3(1.0, -1.0, 5.0)));\n\n//Colors of the triangles\nvec4 colors[12] = vec4[12](vec4(0.0, 0.0, 1.0, 1.0),\n                           vec4(0.0, 0.0, 1.0, 1.0),\n                           vec4(0.0, 0.5, 1.0, 1.0),\n                           vec4(0.0, 0.5, 1.0, 1.0),\n                           vec4(0.5, 0.0, 1.0, 1.0),\n                           vec4(0.5, 0.0, 1.0, 1.0),\n                           vec4(0.5, 0.5, 1.0, 1.0),\n                           vec4(0.5, 0.5, 1.0, 1.0),\n                           vec4(0.0, 0.5, 0.0, 1.0),\n                           vec4(0.0, 0.5, 0.0, 1.0),\n                           vec4(1.0, 0.0, 1.0, 1.0),\n                           vec4(1.0, 0.0, 1.0, 1.0));\n\nbool same_side(vec3 p1, vec3 p2, vec3 a, vec3 b){\n    vec3 cp1;\n    vec3 cp2;\n    \n    cp1 = cross(b - a, p1 - a);\n    cp2 = cross(b - a, p2 - a);\n    if(dot(cp1, cp2) > 0.0){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool inside_triangle(vec3 p, triangle tri){\n\tif(same_side(p, tri.vertex0, tri.vertex1, tri.vertex2) &&\n       same_side(p, tri.vertex1, tri.vertex0, tri.vertex2) &&\n       same_side(p, tri.vertex2, tri.vertex0, tri.vertex1))\n        return true;\n    else\n        return false;\n}\n\ntriangle translate_triangle(triangle tri, vec3 v){\n    return triangle(tri.vertex0 + v, tri.vertex1 + v, tri.vertex2 + v);\n}\n\n//Return distance of intersection if there is an intersection, otherwise return -1.0\nfloat ray_triangle_intersect(vec3 ray, triangle tri, out vec3 pos, out vec3 normal){\n    float t;\n    vec3 ABC;\n    vec3 i;\n    float K;\n    \n    //Get the plane\n    ABC = cross(tri.vertex2 - tri.vertex0, tri.vertex1 - tri.vertex0);\n    normal = ABC;\n    K = dot(ABC, tri.vertex0);\n    \n    //Get the point of intersection, if it exists\n    t = K/dot(ABC, ray);\n    if(t < 0.0){\n        return -1.0;\n    }\n    i = t*ray;\n    pos = i;\n    \n    //Determine if this point is on the triangle\n   \tif(inside_triangle(i, tri))\n       return i.x*i.x + i.y*i.y + i.z*i.z;\n    else\n       return -1.0;\n}\n\nvec4 create_orientation(vec3 axis, float angle){\n    float len;\n    vec4 outvec;\n    \n    len = length(axis);\n    axis *= sin(angle)/len;\n    outvec.yzw = axis;\n    outvec.x = cos(angle);\n    \n    return outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n    float len;\n    \n    len = length(orientation);\n    orientation /= len;\n    orientation.yzw = -orientation.yzw;\n    \n    return orientation;\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n    vec4 outvec;\n    \n    outvec.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    outvec.y = a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z;\n    outvec.z = a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y;\n    outvec.w = a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x;\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n    vec4 v;\n    \n    v.x = 0.0;\n    v.yzw = p.xyz;\n    return compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\ntriangle rotate_triangle(triangle tri, vec3 center, vec4 o){\n    tri = triangle(apply_orientation(tri.vertex0 - center, o), apply_orientation(tri.vertex1 - center, o), apply_orientation(tri.vertex2 - center, o));\n\ttri = triangle(tri.vertex0 + center, tri.vertex1 + center, tri.vertex2 + center);\n    return tri;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 104, 104, 315], [317, 317, 346, 346, 820], [822, 822, 876, 876, 2260]]}
{"id": "3d3fRB", "name": "Dry ice", "author": "xjorma", "description": "First experiment with Eulerian fluid simulation, Jos Stam style. Took inspiration from Tritop shader https://www.shadertoy.com/view/MdSczK for the fluid simulation.\nTried to give a 3d looks even if the simulation is 2D.\n\n", "tags": ["simulation", "fluid", "fog", "smoke", "advection", "incompressible", "incompressible", "navier", "stokes", "jos", "stam"], "likes": 57, "viewed": 2526, "published": 3, "date": "1605570610", "time_retrieved": "2024-07-30T20:35:07.851236", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define RENDER3D\t1\n\n#if  RENDER3D\n\n#define AA 0\n\nfloat sceneIntersection(in vec3 ro,in vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, in float dist)\n{\n    float mint = dist;\n    inter = vec3(0);\n    normal = vec3(0);\n    color = vec3(0);\n   \t// Spheres\n    for(int i = 0 ; i < nbSphere ; i++)\n    {\n        vec2 p2d = rotate(float(i) * tau / float(nbSphere) + iTime * 0.2, 0.8);\n\t\tvec3 pos = vec3(p2d.x, ballRadius, p2d.y);\n    \n\n        float t = sphIntersect( ro, rd, pos, ballRadius).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            inter = (ro + mint * rd);\n            normal = normalize(inter - pos);\n            color = vec3(1, 0, 0);\n        }     \n    }\n\n    // Floor\n    {\n        float aspecRatio = iResolution.x / iResolution.y;  \n        vec3 boxNormal;\n    \tfloat t = boxIntersection(ro, rd, vec3(aspecRatio,0.1,1), vec3(0,-0.1,0),boxNormal).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            inter = (ro + mint * rd);\n\t\t\tnormal = boxNormal;\n            ivec2 tileId = ivec2(vec2(inter.x, inter.z) * 3. + 100.);\n            color = ((tileId.x & 1) ^ (tileId.y & 1)) == 0 ? vec3(0.3) : vec3(0.15);  \n        }       \n    }\n\treturn mint;\n}\n\nfloat sampleFog(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    if(max(uv.x, uv.y) > 1. || min(uv.x, uv.y) < 0.)\n    {\n        return 0.;\n    }\n    return texture(iChannel0, uv).z;\n}\n\nvec3 Render(in vec3 ro,in vec3 rd,in float dist)\n{\n    vec3  inter;\n    vec3  normal;\n    vec3  baseColor; \n\n    float mint = sceneIntersection(ro, rd, inter, normal, baseColor, dist);\n    \n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(vec3(0.1, 1, 0.7));\n    vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;\n\n    \n    if(mint<dist)\n    {\n        float shadowDist = 0.;\n        for(int i = 0 ; i < nbSlice ; i++)\n        {\n            vec3 shadowPos = inter + shadowStep * float(i);\n            float v = sampleFog(shadowPos) * fogHeigth;\n            shadowDist += min(max(0., v - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;\n        }\n        float shadowFactor = exp(-shadowDist * ShadowDensity * 0.25);\n        color = baseColor * (max(0., dot(normal, lightDir) * shadowFactor) + 0.2);\n    }\n    else\n    {\n        color = vec3(0);\n    }\n    \n\n    // Compute Fog\n\tfloat t;\n    if(floorIntersect(ro, rd, fogHeigth, t))\n    {\n        vec3 curPos = ro + rd * t;\n        vec3 fogStep = (fogHeigth / float(nbSlice)) * rd / abs(rd.y);\n        float stepLen = length(fogStep);\n        float curDensity = 0.;\n        float transmittance = 1.;\n        float lightEnergy = 0.;\n        for(int i = 0; i < nbSlice; i++)\n        {\n            if( dot(curPos - ro, rd) > mint)\n                break;\n            float curHeigth = sampleFog(curPos) * fogHeigth;\n            float curSample = min(max(0., curHeigth - curPos.y), fogSlice) * stepLen / fogSlice;\n            if(curSample > 0.001)\n            {\n                vec3 shadowPos = curPos;\n                float shadowDist = 0.;\n\n                for (int j = 0; j < nbSlice; j++)\n                {\n                    shadowPos += shadowStep;\n                    if(shadowPos.y > fogHeigth)\n                    {\n                        break;\n                    }\n                    float curHeight = sampleFog(shadowPos) * fogHeigth;\n             \t\tshadowDist += min(max(0., curHeight - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;\n               }\n\n                \n            \tfloat shadowFactor = exp(-shadowDist * ShadowDensity);\n                curDensity = curSample * FogDensity;\n                float absorbedlight =  shadowFactor * (1. * curDensity);\n                lightEnergy += absorbedlight * transmittance;\n                transmittance *= 1. - curDensity;\t\n            }\n            curPos+= fogStep;       \n        }\n        color = mix(color, vec3(lightEnergy), 1. - transmittance);\n    }  \n    \n    \n    return color;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera       \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) - radians(90.);\n        float phi\t= -radians(30.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd, 6.);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\t\n#else\t// RENDER3D \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).z), 1);\n}\n#endif\t// RENDER3D", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec3 sampleMinusGradient(vec2 coord)\n{\n    vec3\tveld\t= texture(iChannel1, coord / iResolution.xy).xyz;\n    float\tleft\t= texture(iChannel0,(coord + vec2(-1, 0)) / iResolution.xy).x;\n    float\tright\t= texture(iChannel0,(coord + vec2( 1, 0)) / iResolution.xy).x;\n    float\tbottom\t= texture(iChannel0,(coord + vec2( 0,-1)) / iResolution.xy).x;\n    float\ttop \t= texture(iChannel0,(coord + vec2( 0, 1)) / iResolution.xy).x;\n    vec2\tgrad \t= vec2(right - left,top - bottom) * 0.5;\n    return\tvec3(veld.xy - grad, veld.z);\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.99 + 0.01 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Euler advection\n    vec2\tvelocity = sampleMinusGradient(fragCoord).xy;\n    vec3\tveld = sampleMinusGradient(fragCoord - dissipation * velocity).xyz;\n    float\tdensity = veld.z;\n    velocity = veld.xy;\n\n\n    vec2\tuv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Inject emiter\n    \n    for(int i = 0 ; i < nbSphere ; i++)\n    {\n        vec2 p = rotate(float(i) * tau / float(nbSphere) + iTime * 0.2, 0.8);\n        float dist = distance(uv, p);\n        if(dist < ballRadius)\n        {\n            density += ((ballRadius - dist) / ballRadius) * 0.20;\n            density = min(density, 1.);\n         \tvelocity = normalize(-p) * 3.;   \n        }\n        \n    }\t    \n    \n    // damp\n    //d *= 0.999;  \n    fragColor = vec4(vignette(vec3(velocity, density), fragCoord / iResolution.xy, 1.), 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Divergence\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n    float vel_x_left\t= texelFetch(iChannel0, icoord + ivec2(-1,  0) , 0).x;\n    float vel_x_right\t= texelFetch(iChannel0, icoord + ivec2( 1,  0) , 0).x;\n    float vel_y_bottom\t= texelFetch(iChannel0, icoord + ivec2( 0, -1) , 0).y;\n    float vel_y_top\t\t= texelFetch(iChannel0, icoord + ivec2( 0,  1) , 0).y;\n    float divergence\t= (vel_x_right - vel_x_left + vel_y_top - vel_y_bottom) * 0.5;\n    fragColor = vec4(divergence,vec3(1)); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 1st interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless pass we need to do many pass at once.\n\n\n// code generated by :\n/*\n#include <iostream>\n\nconst int tabSize = 48;\n\nstd::int64_t divTab[tabSize][tabSize];\nstd::int64_t preTab[tabSize][tabSize];\n\n\nvoid recurse(int x, int y, int level)\n{\n    level--;\n    divTab[x][y] += std::int64_t(1) << std::int64_t(level * 2);\n    if (level)\n    {\n        recurse(x - 1, y, level);\n        recurse(x + 1, y, level);\n        recurse(x, y - 1, level);\n        recurse(x, y + 1, level);\n    }\n    else\n    {\n        preTab[x - 1][y]++;\n        preTab[x + 1][y]++;\n        preTab[x][y - 1]++;\n        preTab[x][y + 1]++;\n    }\n}\n\nvoid clear(std::int64_t (&tab)[tabSize][tabSize])\n{\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            tab[x][y] = 0;\n        }\n    }\n}\n\nvoid output(const char *functionName, std::int64_t(&tab)[tabSize][tabSize], std::int64_t multiplier)\n{\n    std::int64_t total = 0;\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            if (tab[x][y])\n            {\n                total += tab[x][y];\n                std::cout << \"\\tp += \" << tab[x][y] << \".*\" << functionName << \"(\" << x - tabSize / 2 << \", \" << y - tabSize / 2 << \");\\n\";\n            }\n        }\n    }\n    total *= multiplier;\n    std::cout << \"\\treturn\\tp / \" << total << \".;\\n\";\n}\n\nint main()\n{\n    clear(divTab);\n    clear(preTab);\n    recurse(tabSize / 2, tabSize / 2, 10);\n    output(\"div\", divTab, 2);\n    output(\"pre\", preTab, 1);\n}\n*/\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getDiv( void )\n{\n    float p = 0.;\n    p += 1.*div(-9, 0);\n    p += 9.*div(-8, -1);\n    p += 4.*div(-8, 0);\n    p += 9.*div(-8, 1);\n    p += 36.*div(-7, -2);\n    p += 32.*div(-7, -1);\n    p += 97.*div(-7, 0);\n    p += 32.*div(-7, 1);\n    p += 36.*div(-7, 2);\n    p += 84.*div(-6, -3);\n    p += 112.*div(-6, -2);\n    p += 436.*div(-6, -1);\n    p += 320.*div(-6, 0);\n    p += 436.*div(-6, 1);\n    p += 112.*div(-6, 2);\n    p += 84.*div(-6, 3);\n    p += 126.*div(-5, -4);\n    p += 224.*div(-5, -3);\n    p += 1092.*div(-5, -2);\n    p += 1280.*div(-5, -1);\n    p += 2336.*div(-5, 0);\n    p += 1280.*div(-5, 1);\n    p += 1092.*div(-5, 2);\n    p += 224.*div(-5, 3);\n    p += 126.*div(-5, 4);\n    p += 126.*div(-4, -5);\n    p += 280.*div(-4, -4);\n    p += 1694.*div(-4, -3);\n    p += 2752.*div(-4, -2);\n    p += 6656.*div(-4, -1);\n    p += 6464.*div(-4, 0);\n    p += 6656.*div(-4, 1);\n    p += 2752.*div(-4, 2);\n    p += 1694.*div(-4, 3);\n    p += 280.*div(-4, 4);\n    p += 126.*div(-4, 5);\n    p += 84.*div(-3, -6);\n    p += 224.*div(-3, -5);\n    p += 1694.*div(-3, -4);\n    p += 3520.*div(-3, -3);\n    p += 11016.*div(-3, -2);\n    p += 16128.*div(-3, -1);\n    p += 24608.*div(-3, 0);\n    p += 16128.*div(-3, 1);\n    p += 11016.*div(-3, 2);\n    p += 3520.*div(-3, 3);\n    p += 1694.*div(-3, 4);\n    p += 224.*div(-3, 5);\n    p += 84.*div(-3, 6);\n    p += 36.*div(-2, -7);\n    p += 112.*div(-2, -6);\n    p += 1092.*div(-2, -5);\n    p += 2752.*div(-2, -4);\n    p += 11016.*div(-2, -3);\n    p += 21664.*div(-2, -2);\n    p += 47432.*div(-2, -1);\n    p += 59712.*div(-2, 0);\n    p += 47432.*div(-2, 1);\n    p += 21664.*div(-2, 2);\n    p += 11016.*div(-2, 3);\n    p += 2752.*div(-2, 4);\n    p += 1092.*div(-2, 5);\n    p += 112.*div(-2, 6);\n    p += 36.*div(-2, 7);\n    p += 9.*div(-1, -8);\n    p += 32.*div(-1, -7);\n    p += 436.*div(-1, -6);\n    p += 1280.*div(-1, -5);\n    p += 6656.*div(-1, -4);\n    p += 16128.*div(-1, -3);\n    p += 47432.*div(-1, -2);\n    p += 92224.*div(-1, -1);\n    p += 163476.*div(-1, 0);\n    p += 92224.*div(-1, 1);\n    p += 47432.*div(-1, 2);\n    p += 16128.*div(-1, 3);\n    p += 6656.*div(-1, 4);\n    p += 1280.*div(-1, 5);\n    p += 436.*div(-1, 6);\n    p += 32.*div(-1, 7);\n    p += 9.*div(-1, 8);\n    p += 1.*div(0, -9);\n    p += 4.*div(0, -8);\n    p += 97.*div(0, -7);\n    p += 320.*div(0, -6);\n    p += 2336.*div(0, -5);\n    p += 6464.*div(0, -4);\n    p += 24608.*div(0, -3);\n    p += 59712.*div(0, -2);\n    p += 163476.*div(0, -1);\n    p += 409744.*div(0, 0);\n    p += 163476.*div(0, 1);\n    p += 59712.*div(0, 2);\n    p += 24608.*div(0, 3);\n    p += 6464.*div(0, 4);\n    p += 2336.*div(0, 5);\n    p += 320.*div(0, 6);\n    p += 97.*div(0, 7);\n    p += 4.*div(0, 8);\n    p += 1.*div(0, 9);\n    p += 9.*div(1, -8);\n    p += 32.*div(1, -7);\n    p += 436.*div(1, -6);\n    p += 1280.*div(1, -5);\n    p += 6656.*div(1, -4);\n    p += 16128.*div(1, -3);\n    p += 47432.*div(1, -2);\n    p += 92224.*div(1, -1);\n    p += 163476.*div(1, 0);\n    p += 92224.*div(1, 1);\n    p += 47432.*div(1, 2);\n    p += 16128.*div(1, 3);\n    p += 6656.*div(1, 4);\n    p += 1280.*div(1, 5);\n    p += 436.*div(1, 6);\n    p += 32.*div(1, 7);\n    p += 9.*div(1, 8);\n    p += 36.*div(2, -7);\n    p += 112.*div(2, -6);\n    p += 1092.*div(2, -5);\n    p += 2752.*div(2, -4);\n    p += 11016.*div(2, -3);\n    p += 21664.*div(2, -2);\n    p += 47432.*div(2, -1);\n    p += 59712.*div(2, 0);\n    p += 47432.*div(2, 1);\n    p += 21664.*div(2, 2);\n    p += 11016.*div(2, 3);\n    p += 2752.*div(2, 4);\n    p += 1092.*div(2, 5);\n    p += 112.*div(2, 6);\n    p += 36.*div(2, 7);\n    p += 84.*div(3, -6);\n    p += 224.*div(3, -5);\n    p += 1694.*div(3, -4);\n    p += 3520.*div(3, -3);\n    p += 11016.*div(3, -2);\n    p += 16128.*div(3, -1);\n    p += 24608.*div(3, 0);\n    p += 16128.*div(3, 1);\n    p += 11016.*div(3, 2);\n    p += 3520.*div(3, 3);\n    p += 1694.*div(3, 4);\n    p += 224.*div(3, 5);\n    p += 84.*div(3, 6);\n    p += 126.*div(4, -5);\n    p += 280.*div(4, -4);\n    p += 1694.*div(4, -3);\n    p += 2752.*div(4, -2);\n    p += 6656.*div(4, -1);\n    p += 6464.*div(4, 0);\n    p += 6656.*div(4, 1);\n    p += 2752.*div(4, 2);\n    p += 1694.*div(4, 3);\n    p += 280.*div(4, 4);\n    p += 126.*div(4, 5);\n    p += 126.*div(5, -4);\n    p += 224.*div(5, -3);\n    p += 1092.*div(5, -2);\n    p += 1280.*div(5, -1);\n    p += 2336.*div(5, 0);\n    p += 1280.*div(5, 1);\n    p += 1092.*div(5, 2);\n    p += 224.*div(5, 3);\n    p += 126.*div(5, 4);\n    p += 84.*div(6, -3);\n    p += 112.*div(6, -2);\n    p += 436.*div(6, -1);\n    p += 320.*div(6, 0);\n    p += 436.*div(6, 1);\n    p += 112.*div(6, 2);\n    p += 84.*div(6, 3);\n    p += 36.*div(7, -2);\n    p += 32.*div(7, -1);\n    p += 97.*div(7, 0);\n    p += 32.*div(7, 1);\n    p += 36.*div(7, 2);\n    p += 9.*div(8, -1);\n    p += 4.*div(8, 0);\n    p += 9.*div(8, 1);\n    p += 1.*div(9, 0);\n    return  p / 1048576.;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    float div = getDiv();\n    float p = getPre() - div;\n    fragColor = vec4(p, div, vec3(1));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst float dissipation \t= 0.95;\n\nconst float ballRadius\t\t= 0.06;\nconst float fogHeigth\t\t= ballRadius * 2.;\nconst int\tnbSlice\t\t\t= 32;\nconst float fogSlice\t\t= fogHeigth / float(nbSlice);\nconst int\tnbSphere \t\t= 3;\nconst float ShadowDensity \t= 25.;\nconst float FogDensity \t\t= 20.;\n\nconst float tau =  radians(360.);\n\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nbool floorIntersect(in vec3 ro, in vec3 rd, in float floorHeight, out float t) \n{\n    ro.y -= floorHeight;\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n// https://iquilezles.org/articles/intersectors\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 center,out vec3 oN ) \n{\n    ro -= center;\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}", "buffer_d_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 2nd interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless passed we need to do many pass at once.\n\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).y;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{ \n    float p = getPre() - div(0,0);\n    fragColor = vec4(p,vec3(1));\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": []}
{"id": "Wsdfzj", "name": "cilindro-viaje", "author": "jorge2017a1", "description": "cilindro-viaje", "tags": ["cilindroviaje"], "likes": 2, "viewed": 274, "published": 3, "date": "1605560828", "time_retrieved": "2024-07-30T20:35:08.715924", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nbool blnObjTipoN2;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//------------------\n\n\nfloat tau = atan(1.0) * 8.0;\n//---------------------\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n//---------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n//---------------------\nvec3 engranecirculo(vec3 p, float numItem)\n{\n\n    vec3 pp=p;\n\n    if (blnObjTipoN2==true)\n        p=p;\n    else\n    p.zy *= genRotMat(radians(90.0));\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n    float  sdbAnilloB;\n        \n    if (blnObjTipoN2==false)\n    \t sdbAnilloB= sdTorus(pp-vec3(0.0,0.0,1.0), vec2(5.5,0.5) );\n    else\n \t{       \n         p.zy *= genRotMat(radians(90.0));\n         sdbAnilloB= sdTorus(p-vec3(0.0,0.0,1.0), vec2(5.8,0.5) );\n\t}    \n        \n    rep2= rotate_x(rep2,radians(90.0));\n    \n    float  sdCilindros=sdCylinder(rep2-vec3(5.0,1.0,0.0), vec2(0.25,15.0) );\n    \n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    res=opU3(res,vec3(sdCilindros,3.,-1.0));\n    res=opU3(res,vec3(sdbAnilloB,4.0,-1.0));\n  \n\treturn  res;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n  \n    \n    res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    \n    p.y=p.y-5.0;\n    \n\tvec3 q=p;\n    float cx, cy, cz;\n    \n    \n    if (blnObjTipoN2==false)\n    {\n     \tcy=15.0;\n    \tq.y = mod(q.y+0.5*cy,cy)-0.5*cy;\n\t\tp=q;\n\t}\n    else\n    {\n     \tcz=20.00;\n    \tq.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    \tp=q;\n\t}    \n    \n    vec3 sp1= engranecirculo(p-vec3(0.0,5.0,0.0), 10.0);\n    res =opU3(res, vec3(sp1.x,sp1.y,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n    \n    float diff = dot(normal, l);\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//-------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n  blnObjTipoN2=false;\n   \tvec3 ro, rd;\n\n    float tm=mod(iTime,14.0);\n    \n    if (tm<7.0)\n \t{\n         blnObjTipoN2=false;\n         ro=vec3(10.0-5.0*abs(sin(tm*0.5)),50.0*abs(sin(tm*0.225)),0.0);\n         ro= rotate_y(ro, radians(90.0));\n    \t rd=normalize(vec3(uv,1.0));\n        \n\t}\n    else\n    {\t\n        blnObjTipoN2=true;\n         ro=vec3(10.0-tm*10.0,10.0,0.0+0.0);\n         ro= rotate_y(ro, radians(90.0));\n    \t rd=normalize(vec3(uv,1.0));\n    }\n        \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsdfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 453, 453, 515], [516, 516, 553, 553, 648], [649, 649, 688, 688, 783], [784, 784, 823, 823, 918], [919, 919, 958, 958, 1053], [1055, 1099, 1146, 1146, 1173], [1175, 1175, 1218, 1218, 1245], [1247, 1247, 1295, 1295, 1323], [1324, 1433, 1467, 1467, 1565], [1566, 1566, 1600, 1600, 1692], [1693, 1693, 1727, 1727, 1819], [1820, 1860, 1894, 1894, 1991], [2045, 2069, 2095, 2095, 2149], [2150, 2174, 2208, 2208, 2381], [2382, 2406, 2450, 2450, 3171], [3172, 3212, 3237, 3237, 3899], [3904, 3904, 3990, 3990, 4706], [4712, 4763, 4787, 4787, 4975], [4976, 5039, 5072, 5072, 5533], [5535, 5589, 5625, 5625, 5859], [5860, 5940, 6020, 6020, 6297], [6351, 6351, 6444, 6444, 6545], [6550, 6599, 6656, 6656, 8230]]}
{"id": "Ws3Bzj", "name": "Mandelbrot rainbow", "author": "been_jamming", "description": "Renders the mandelbrot set with a trippy rainbow effect", "tags": ["fractal"], "likes": 1, "viewed": 104, "published": 3, "date": "1605548269", "time_retrieved": "2024-07-30T20:35:09.570640", "image_code": "#define ITERATIONS 100\n\nvec2 multiply_complex(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nfloat len(vec2 a){\n    return sqrt(a.x*a.x + a.y*a.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 c;\n    vec2 z = vec2(0);\n    vec2 dz = vec2(0);\n    float min_side;\n    float s_red;\n    float s_green;\n    float s_blue;\n    float dist;\n    int i;\n    \n    min_side = min(iResolution.x, iResolution.y);\n    c = fragCoord.xy/min_side*2.0;\n    c = c - vec2(iResolution.x/min_side, iResolution.y/min_side) - vec2(0.5, 0.0);\n    for(i = 0; i < ITERATIONS; i++){\n        if(z.x*z.x + z.y*z.y > 1000000.0)\n            break;\n        dz = multiply_complex(dz, z)*2.0 + vec2(1.0);\n        z = multiply_complex(z, z) + c;\n    }\n    if(i == ITERATIONS){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        dist = len(z)*log(len(z))/len(dz) + iTime/20.0;\n        if(mod(dist, 0.02) > 0.01)\n            s_red = smoothstep(0.0, 0.01, mod(dist, 0.02) - 0.01);\n        else\n            s_red = smoothstep(0.01, 0.0, mod(dist, 0.02));\n        if(mod(dist - 0.053, 0.02) > 0.01)\n            s_green = smoothstep(0.0, 0.01, mod(dist - 0.053, 0.02) - 0.01);\n        else\n            s_green = smoothstep(0.01, 0.0, mod(dist - 0.053, 0.02));\n        if(mod(dist - 0.007, 0.02) > 0.01)\n            s_blue = smoothstep(0.0, 0.01, mod(dist - 0.007, 0.02) - 0.01);\n        else\n            s_blue = smoothstep(0.01, 0.0, mod(dist - 0.007, 0.02));\n        fragColor = vec4(s_red, s_green, s_blue, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3Bzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 62, 62, 119], [121, 121, 139, 139, 177], [179, 179, 233, 233, 1544]]}
{"id": "wd3Bz2", "name": "Pool in the Middle of Nowhere", "author": "oneshade", "description": "Simple pool model with displacements sampled from a soft voronoi heightmap.", "tags": ["voronoi", "simulation", "water", "heightmap"], "likes": 33, "viewed": 575, "published": 3, "date": "1605545282", "time_retrieved": "2024-07-30T20:35:10.376484", "image_code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n*/\n\n// Settings:\nconst bool SHADOWS = false;\nconst int AA = 1; // Set to 2 if your computer is fast enough.\n\n// Screen variables:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nvec2 antialiasing = vec2(AA);\n\n// Light variables:\nvec3 lightDirection = normalize(vec3(0.58, 1.5, -0.58));\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(1.0, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 3000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 200;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n    return surfaceUnion;\n}\n\n// Smooth union of surfaces with different materials from my shader \"Smooth Union Inclusive of Colors\" (https://www.shadertoy.com/view/tscBz8).\nSurface SmoothUnion(in Surface surface1, in Surface surface2, in float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (surface2.signedDistance - surface1.signedDistance) / smoothness, 0.0, 1.0);\n    return Surface(mix(surface2.ambientColor, surface1.ambientColor, interpolation),\n                   mix(surface2.diffuseColor, surface1.diffuseColor, interpolation),\n                   mix(surface2.specularColor, surface1.specularColor, interpolation),\n                   mix(surface2.shininess, surface1.shininess, interpolation),\n                   mix(surface2.signedDistance, surface1.signedDistance, interpolation) - smoothness * interpolation * (1.0 - interpolation));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    p = Rotate(Translate(p, vec3(0.0, -100.0, 0.0)), vec3(-30.0, 0.0, 0.0));\n\n    vec2 uv = (p.xz + vec2(175.0, 100.0)) / vec2(350.0, 200.0);\n    vec3 waterTexture = texture(iChannel0, uv).rgb;\n    float displacement = waterTexture.b * 50.0;\n    Surface water = Surface(vec3(0.0, 0.0, 0.0),\n                            waterTexture,\n                            vec3(1.0, 1.0, 1.0), 32.0,\n                            max(sdPlane(Translate(p, vec3(0.0, 35.0, 0.0)), vec3(0.0, 1.0, 0.0)) - displacement,\n                                sdCuboid(Translate(p, vec3(0.0, 35.0, 0.0)), 1000.0, 350.0, 200.0)));\n\n    uv = vec2(mod(atan(p.z, p.x), 1.57), p.y + 75.0) / vec2(1.57, 150.0);\n    vec3 wallTexture = texture(iChannel1, uv).rgb;\n    Surface wall = Surface(0.3 * wallTexture,\n                           wallTexture,\n                           vec3(0.0, 0.0, 0.0), 0.0,\n                           max(sdCuboid(Translate(p, vec3(0.0, 25.0, 0.0)), 150.0, 375.0, 225.0),\n                               -sdCuboid(p, 1000.0, 350.0, 200.0)));\n\n    uv = mod(p.xz / 800.0, 1.0);\n    vec3 groundTexture = texture(iChannel2, uv).rgb;\n    Surface ground = Surface(vec3(0.0, 0.0, 0.0),\n                             groundTexture,\n                             vec3(0.0, 0.0, 0.0), 0.0,\n                             sdPlane(Translate(p, vec3(0.0, 10.0, 0.0)), vec3(0.0, 1.0, 0.0)));\n\n    return Union(water, SmoothUnion(wall, ground, 10.0));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Shadow mapping function:\nbool visibleFromLight(in vec3 p, in vec3 normal) {\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return false;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n    }\n\n    return true;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n\n    float inShadow = SHADOWS ? visibleFromLight(hitPosition, normal) ? 1.0 : 0.0 : 1.0;\n\n    return illuminationAmbient + inShadow * (illuminationDiffuse + illuminationSpecular);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - 0.5 * iResolution.xy;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nSoft voronoi heightmap for the surface of the pool.\nThe idea came from the soft voronoi pattern I employed in my shader \"Fake Caustic w/Voronoi\" (https://www.shadertoy.com/view/wd3fR2).\n*/\n\n#define LAYERS 2.0\n#define FREQUENCY 4.0\n#define DECAY 0.6\n#define SOFTNESS 0.5\n#define WASHOUT 0.8\n#define POWER 2.5\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    return 0.5 + 0.5 * vec2(sin(p.x + p.y * 2.0 + iTime), cos(p.y - p.x + 2.0 * iTime));\n}\n\nfloat voronoi(in vec2 uv, in float scale) {\n    uv *= scale;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), SOFTNESS);\n        }\n    }\n\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    float totalScale = 0.0;\n    float scale = 1.0;\n\n    for (float layer=0.0; layer < LAYERS; layer++) {\n        float voronoiSample = pow(voronoi(uv, FREQUENCY / scale), POWER);\n        color += mix(vec3(0.0, 0.7, 0.9), vec3(1.0 + WASHOUT), voronoiSample) * scale;\n        totalScale += scale;\n        scale *= DECAY;\n    }\n\n    color /= totalScale;\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3Bz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1085, 1122, 1159, 1159, 1183], [1185, 1185, 1248, 1248, 1331], [1333, 1381, 1438, 1438, 1606], [1608, 1752, 1836, 1836, 2438], [2440, 2460, 2498, 2498, 2518], [2520, 2520, 2555, 2555, 3166], [3168, 3195, 3224, 3224, 4652], [4654, 4703, 4736, 4736, 5156], [5158, 5186, 5236, 5236, 5773], [5775, 5830, 5918, 5918, 6557], [6559, 6580, 6607, 6607, 7290], [7292, 7325, 7380, 7380, 7993]]}
{"id": "wd3fR2", "name": "Fake Caustic w/Voronoi", "author": "oneshade", "description": "Caustic effect created by mixing an aqua color with white based on (smooth) minimal distances to points moving around in cells in a gridlike structure. I thought some layering was kind of cool and added that to. I might try code golfing this sometime.", "tags": ["voronoi", "caustic"], "likes": 10, "viewed": 261, "published": 3, "date": "1605539722", "time_retrieved": "2024-07-30T20:35:11.191306", "image_code": "#define LAYERS 2.0\n#define FREQUENCY 4.0\n#define DECAY 0.6\n#define SOFTNESS 0.1\n#define WASHOUT 0.3\n#define POWER 2.5\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    return 0.5 + 0.5 * vec2(sin(p.x + p.y * 2.0 + iTime), cos(p.y - p.x + 2.0 * iTime));\n}\n\nfloat voronoi(in vec2 uv, in float scale) {\n    uv *= scale;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), SOFTNESS);\n        }\n    }\n\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    float totalScale = 0.0;\n    float scale = 1.0;\n\n    for (float layer=0.0; layer < LAYERS; layer++) {\n        float voronoiSample = pow(voronoi(uv, FREQUENCY / scale), POWER);\n        color += mix(vec3(0.0, 0.7, 0.9), vec3(1.0 + WASHOUT), voronoiSample) * scale;\n        totalScale += scale;\n        scale *= DECAY;\n    }\n\n    color /= totalScale;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3fR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 167, 167, 270], [272, 272, 302, 302, 393], [395, 395, 438, 438, 851], [853, 853, 908, 908, 1389]]}
{"id": "3dtBWM", "name": "My Fluid Learn 2", "author": "GamerWang", "description": "more complex fluid", "tags": ["fluid"], "likes": 2, "viewed": 459, "published": 3, "date": "1605512048", "time_retrieved": "2024-07-30T20:35:12.051007", "image_code": "// Chimera's Breath\n// by nimitz 2018 (twitter: @stormoid)\n// https://www.shadertoy.com/view/4tGfDW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSimulation code is in the \"common\" tab (and extra defines)\n\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\n#define EDGE_WIDTH 15.\n\n//#define SHOW_V\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n    if (fragCoord.y < EDGE_WIDTH || fragCoord.y >= (iResolution.y-EDGE_WIDTH))\n        col = vec4(0);\n    fragColor = vec4(1) - col;\n    \n    #ifdef SHOW_V\n    \n    vec4 vCol = textureLod(iChannel1, fragCoord/iResolution.xy, 0.);\n    fragColor = vCol;\n    \n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1.)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n/*\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\n#define dt 0.16\n#define USE_VORTICITY_CONFINEMENT\n#define MOUSE_ONLY\n\n//Recommended values between 0.03 and 0.2\n//higher values simulate lower viscosity fluids (think billowing smoke)\n#define VORTICITY_AMOUNT 0.2\n\nfloat mag2(vec2 p){return dot(p,p);}\nvec2 point1(float t) {\n    t *= 0.62;\n    return vec2(0.12,0.5 + sin(t)*0.2);\n}\nvec2 point2(float t) {\n    t *= 0.62;\n    return vec2(0.88,0.5 + cos(t + 1.5708)*0.2);\n}\n\nvec4 solveFluid(sampler2D smp, vec2 uv, vec2 w, float time, vec3 mouse, vec3 lastMouse)\n{\n\tconst float K = 0.2;\n\tconst float v = 0.55;\n    \n    vec4 data = textureLod(smp, uv, 0.0);\n    vec4 tr = textureLod(smp, uv + vec2(w.x , 0), 0.0);\n    vec4 tl = textureLod(smp, uv - vec2(w.x , 0), 0.0);\n    vec4 tu = textureLod(smp, uv + vec2(0 , w.y), 0.0);\n    vec4 td = textureLod(smp, uv - vec2(0 , w.y), 0.0);\n    \n    vec3 dx = (tr.xyz - tl.xyz)*0.5;\n    vec3 dy = (tu.xyz - td.xyz)*0.5;\n    vec2 densDif = vec2(dx.z ,dy.z);\n    \n    data.z -= dt*dot(vec3(densDif, dx.x + dy.y) ,data.xyz); //density\n    vec2 laplacian = tu.xy + td.xy + tr.xy + tl.xy - 4.0*data.xy;\n    vec2 viscForce = vec2(v)*laplacian;\n    data.xyw = textureLod(smp, uv - dt*data.xy*w, 0.).xyw; //advection\n    \n    vec2 newForce = vec2(0);\n    #ifndef MOUSE_ONLY\n    #if 1\n    newForce.xy += 0.75*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0001);\n    newForce.xy -= 0.75*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0001);\n    #else\n    newForce.xy += 0.9*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0002);\n    newForce.xy -= 0.9*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0002);\n    #endif\n    #endif\n    \n    if (mouse.z > 1. && lastMouse.z > 1.)\n    {\n        vec2 vv = clamp(vec2(mouse.xy*w - lastMouse.xy*w)*400., -6., 6.);\n        newForce.xy += .001/(mag2(uv - mouse.xy*w)+0.001)*vv;\n    }\n    \n    data.xy += dt*(viscForce.xy - K/dt*densDif + newForce); //update velocity\n    data.xy = max(vec2(0), abs(data.xy)-1e-2)*sign(data.xy); //linear velocity decay\n    \n    #ifdef USE_VORTICITY_CONFINEMENT\n   \tdata.w = (tr.y - tl.y - tu.x + td.x);\n    vec2 vort = vec2(abs(tu.w) - abs(td.w), abs(tl.w) - abs(tr.w));\n    vort *= VORTICITY_AMOUNT/length(vort + 1e-9)*data.w;\n    data.xy += vort;\n    #endif\n    \n    data.y *= smoothstep(.5,.48,abs(uv.y-0.5)); //Boundaries\n    \n    data = clamp(data, vec4(vec2(-10), 0.5 , -10.), vec4(vec2(10), 3.0 , 10.));\n    \n    return data;\n}", "buffer_b_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1.)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n//shader incoming relating to this palette\nvec3 getPalette(float x, vec3 c1, vec3 c2, vec3 p1, vec3 p2)\n{\n    float x2 = fract(x/2.0);\n    x = fract(x);   \n    mat3 m = mat3(c1, p1, c2);\n    mat3 m2 = mat3(c2, p2, c1);\n    float omx = 1.0-x;\n    vec3 pws = vec3(omx*omx, 2.0*omx*x, x*x);\n    return clamp(mix(m*pws, m2*pws, step(x2,0.5)),0.,1.);\n}\n\nvec4 pal(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.2, 0.5, .7), vec3(.9, 0.4, 0.1), vec3(1., 1.2, .5), vec3(1., -0.4, -.0));\n    return vec4(pal, 1.);\n}\n\nvec4 pal2(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.4, 0.3, .5), vec3(.9, 0.75, 0.4), vec3(.1, .8, 1.3), vec3(1.25, -0.1, .1));\n    return vec4(pal, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec2 velo = textureLod(iChannel0, uv, 0.).xy;\n    vec4 col = textureLod(iChannel1, uv - dt*velo*w*3., 0.); //advection\n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = vec4(0);\n    vec4 lastMouse = texelFetch(iChannel1, ivec2(0,0), 0).xyzw;\n    \n    if (iMouse.z > 1. && lastMouse.z > 1.)\n    {\n        float str = smoothstep(-.5,1.,length(mo - lastMouse.xy/iResolution.xy));   \n        //col += str*0.0009/(pow(length(uv - mo),1.7)+0.002)*pal2(-iTime*0.7);\n        col += str*0.0009/(pow(length(uv - mo),1.7)+0.006);\n    }\n    \n    #ifndef MOUSE_ONLY\n    col += .00001/(0.0005+pow(length(uv - point1(iTime)),1.75));\n    col += .00001/(0.0005+pow(length(uv - point2(iTime)),1.75));\n    #endif\n    \n    \n    if (iFrame < 20)\n    {\n        col = vec4(0.);\n    }\n    \n    col = clamp(col, 0.,5.);\n    col = max(col - (0.0001 + col*0.004)*.5, 0.); //decay\n    \n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = iMouse;\n\n    fragColor = col;\n    \n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1129, 1129, 1186, 1186, 1524]]}
{"id": "3scfzj", "name": "Ascii art with sdf morphing", "author": "henrmota", "description": "Ascii art with animated morphing", "tags": ["sdfmorphingasciiart"], "likes": 6, "viewed": 449, "published": 3, "date": "1605490426", "time_retrieved": "2024-07-30T20:35:12.809978", "image_code": "#define PI 3.14159265359\n#define TWO_PI 2.*PI\n#define FBM_OCTAVES 4\n#define DX 1./iResolution.x\n#define DY 1./iResolution.y\n\n//1d pseudo-random for shaders\nfloat random(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); \n}\n\nvec3 getPixelated(vec2 p, float size) {\n    p = floor(p * size)/size;\n\n    return texture(iChannel1, p).rgb;\n}\n\nfloat charDistance(vec2 p, float char) {\n  return texture(\n        iChannel0, \n        p/16. + fract( vec2(char, floor(15. - char / 16.)) / 16. )\n    ).w;  \n}\n\nfloat getChar(vec2 p, float size) {\n    vec3 pix = getPixelated(p, size); \n    float b = dot(pix, vec3(1./3.));\n    \n    float char = floor(mix(150., 220., b));\n    p = fract(p*size);\n    \n\treturn charDistance(p, char);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    float t = clamp(cos(iTime) * 3. + 3., 0., 1.);  \n\t\n    float char1 = getChar(uv, 65.);\n    \n    vec3 pix = texture(iChannel1, uv).rgb;\n    vec3 bw = vec3(dot(pix, vec3(1./3.)));\n    \n    \n    float bigChar = charDistance(uv, 82.);\n    \n    float d = smoothstep(0.50, 0.49, mix(bigChar, char1, t));\n    \n   \tcol += d * pix; \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 156, 178, 178, 274], [276, 276, 315, 315, 386], [388, 388, 428, 428, 546], [548, 548, 583, 583, 769], [772, 772, 829, 879, 1347]]}
{"id": "wstfzB", "name": "Contrast thin thick", "author": "illus0r", "description": "Contrast thin thick", "tags": ["raymarching"], "likes": 1, "viewed": 301, "published": 3, "date": "1605473936", "time_retrieved": "2024-07-30T20:35:13.566954", "image_code": "float sdBox( vec3 p, vec3 b ){vec3 q = abs(p) - b;return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nfloat glow;\nfloat dist(vec3 p){\n    p.z-=2.;\n    p.yz*=rot(3.1415/4.);\n    p.xz*=rot(3.1415/4.);\n    float d = 2.*sin(iTime*2.);\n    float thick = sdBox(p+vec3(0.,d/2.,.0),vec3(1.,.5,1.));\n    float hole = sdBox(p+vec3(0.,d/2.,.0),vec2(.1,.51).xyx);\n    float thin = sdBox(p-vec3(0.,d*2.,.0),vec2(.005,1.5).xyx);\n    thick = max(thick,-hole);\n    if(thin<thick && thin<.001)glow=1.;\n\treturn min(thick, thin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = (FC*2.-iResolution.xy)/iResolution.y;\n\n    float d=0.,e,col = 0.5;\n    vec3 p,rd = vec3(0.,0.,1.);\n    int i;\n    for(i=0;i<99;i++){\n        p=rd*d+vec3(uv,-.1);\n        d+=e=dist(p);\n        if(e<.001)break;\n    }\n    col=1.-sqrt(d/3.);\n    if(glow==1.){\n    \tfragColor = vec4(vec3(1.,0.,0.),1.0);\n    }\n    else {\n    \tfragColor = vec4(vec3(col),1.0);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 110], [111, 111, 129, 129, 176], [189, 189, 208, 208, 587], [589, 589, 639, 639, 1025]]}
{"id": "wddBzB", "name": "cabeza-simple-v3", "author": "jorge2017a1", "description": "cabeza-simple-v3", "tags": ["cabezasimplev3"], "likes": 2, "viewed": 309, "published": 3, "date": "1605470240", "time_retrieved": "2024-07-30T20:35:14.513423", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.01\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n//float sdSphere( vec3 p, float s )\n//\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n//float sdTorus( vec3 p, vec2 t )\n//\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\n\nvec3 HacerOjoConCabeza4en1(float sdcabeza,float sdPupila, float sdIris, float sdesclerotica, bool pblnCabeza )\n{\n    \n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    //sdescleroticaDer>sdIrisDer>sdPupilaDer  (eje x,y)\n    //sdPupilaDer>sdIrisDer>sdescleroticaDer ( eje z)\n    \n    float uniontdo;\n    /*\n    uniontdo= sdcabeza;\n    uniontdo= unionSDF(uniontdo, sdPupila);\n    uniontdo= unionSDF(uniontdo, sdIris);\n    uniontdo= unionSDF(uniontdo, sdesclerotica);\n    \n    float interstdo;\n    interstdo=sdcabeza;\n    interstdo=intersectSDF(interstdo, sdPupila);\n    interstdo=intersectSDF(interstdo, sdIris); \n    interstdo=intersectSDF(interstdo, sdesclerotica);\n    \n    \n    float diftdo=sdcabeza;\n    diftdo=differenceSDF(diftdo,sdesclerotica);\n    diftdo=differenceSDF(diftdo, sdPupila);\n    diftdo=differenceSDF(diftdo, sdIris);\n    */\n    float interAB=intersectSDF(sdIris, sdcabeza);\n    float interAC=intersectSDF(sdPupila, sdcabeza);\n    float interAD=intersectSDF(sdesclerotica, sdcabeza);\n    \n    if (pblnCabeza)    res =opU3(res, vec3(sdcabeza,16.0,MATERIAL_NO));    \n    res =opU3(res, vec3(interAD,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(interAB,4.0,MATERIAL_NO));\n    res =opU3(res, vec3(interAC,0.0,MATERIAL_NO)); \n    \n    return res;\n}\n   \n\n\n\nfloat nose(vec3 p)\n{\n\tvec3 n;\n    n=p;\n\tn.xz =rotatev2(p.xz, radians(45.0));\n    float d  = sdRoundBox(n, vec3(0.45,2.0,0.45), .8); \n    return d;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec3 BendCurvaFija(vec3 pos,vec3 center)\n{    \n    vec3 p1=pos-center;\n    float c = cos(-0.15*p1.x);\n    float s = sin(-0.15*p1.x);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 p2 = vec3(m*p1.xy,p1.z);\n    return p2;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n\n    p= rotate_y(p-vec3(0.0,0.0,0.0), radians(180.0+20.0*sin(iTime)));\n    \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+35.0; //pared izq\n    float planeDist4 = 35.0-p.x;  //pared der\n    float planeDist5 = -p.z+45.0;  //pared frente\n    float planeDist6 = p.z+45.0;  //pared atras\n    \n    //res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    \n    \n    res =opU3(res, vec3(planeDist1,1.0,-1.0)); //inf\n    res =opU3(res, vec3(planeDist2,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist5,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,1.0,MATERIAL_NO));\n   \n  \n    p.y=p.y-5.0;\n \n    \n     float separacionOjoX=3.0;\n    float sdPupilaDer= sdCylinderXY(p- vec3( separacionOjoX,10.0,-10.0), vec2(0.5,4.0) );\n    float sdPupilaIzq= sdCylinderXY(p- vec3(-separacionOjoX,10.0,-10.0), vec2(0.5,4.0) );\n    \n    float sdIrisDer= sdCylinderXY(p- vec3( separacionOjoX,10.0, -10.0), vec2(1.0,3.0) );\n    float sdIrisIzq= sdCylinderXY(p- vec3(-separacionOjoX,10.0,-10.0), vec2(1.0,3.0) );\n \n    float sdescleroticaDer=sdEllipsoid(p-vec3(separacionOjoX,10.0,-10.0), vec3(2.5,1.8,3.0) );\n    float sdescleroticaIzq=sdEllipsoid(p-vec3(-separacionOjoX,10.0,-10.0), vec3(2.5,1.8,3.0) );\n    \n    \n    \n    float sdCabeza= sdEllipsoid(p-vec3(0.0,11.0,-14.0), vec3(8.0,11.0,6.0) );\n    vec3 resojoDer =HacerOjoConCabeza4en1(sdCabeza,sdPupilaDer, sdIrisDer, sdescleroticaDer, true);\n    vec3 resojoIzq =HacerOjoConCabeza4en1(sdCabeza,sdPupilaIzq, sdIrisIzq, sdescleroticaIzq,false);\n    res =opU3(res, resojoDer); \n    res =opU3(res, resojoIzq);     \n    \n    \n    \n    float sdnariz= nose(p-vec3(0.0,8.0,-9.0));\n    res =opU3(res, vec3(sdnariz,16.0,MATERIAL_NO));     \n    \n    \n    float sdcejaIzq= sdBox(p-vec3( 3.5,12.0,-8.0), vec3(1.5,0.2,3.0) );\n    float sdcejaDer= sdBox(p-vec3(-3.5,12.0,-8.0), vec3(1.5,0.2,3.0) );\n  \tfloat interCejaIzq= intersectSDF(sdCabeza, sdcejaIzq);\n    float interCejaDer= intersectSDF(sdCabeza, sdcejaDer);\n    \n    res =opU3(res, vec3(interCejaIzq,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(interCejaDer,0.0,MATERIAL_NO)); \n    \n    \n    ///Boca\n    float sdBoca= sdBox(p-vec3( 0.0,4.5,-8.0), vec3(2.5,0.2,3.0) );\n    float interBoca= intersectSDF(sdCabeza, sdBoca);\n    res =opU3(res, vec3(interBoca,2.0,MATERIAL_NO)); \n    \n    \n    vec3 p2= BendCurvaFija(p,vec3(0.0,16.5,-11.0));\n    float caps = sdCapsule(p2, vec3(-4.0, 4.0, 0.0), vec3(4.0, 4.0, 0.0), 0.5);\n    res =opU3(res, vec3(caps,8.0,MATERIAL_NO));     \n    \n    \n    p2= BendCurvaFija(p,vec3(0.0,16.0,-12.0));\n    caps = sdCapsule(p2, vec3(-6.0, 5.0, 0.0), vec3(6.0, 5.0, 0.0), 0.5);\n    res =opU3(res, vec3(caps,9.0,MATERIAL_NO));  \n    \n    \n    p2= BendCurvaFija(p,vec3(0.0,3.0,-10.0));\n    caps = sdCapsule(p2, vec3(-3.0, 3.0, 0.0), vec3(3.0, 3.0, 0.0), 0.5);\n    res =opU3(res, vec3(caps,31.0,MATERIAL_NO));  \n    \n    \n    p2= BendCurvaFija(p,vec3(0.0,13.0,-14.0));\n    caps = sdCapsule(p2, vec3(-8.0, 8.0, 0.0), vec3(8.0, 8.0, 0.0), 0.5);\n    res =opU3(res, vec3(caps,8.0,MATERIAL_NO));  \n    \n\t\n    \n    \n    float slinea1= sdBox(p-vec3(0.0,15.0,-10.0), vec3(10.0,0.25,2.0));\n    float slinea2= sdBox(p-vec3(0.0,12.0,-10.0), vec3(10.0,0.25,2.0));\n    float slinea3= sdBox(p-vec3(0.0,8.0,-10.0), vec3(10.0,0.25,2.0));\n    \n    float interLinea1= intersectSDF(sdCabeza, slinea1);\n    float interLinea2= intersectSDF(sdCabeza, slinea2);\n    float interLinea3= intersectSDF(sdCabeza, slinea3);\n    \n\n    res =opU3(res, vec3(interLinea1,0.0,MATERIAL_NO));  \n    res =opU3(res, vec3(interLinea2,0.0,MATERIAL_NO));  \n    res =opU3(res, vec3(interLinea3,0.0,MATERIAL_NO));  \n      \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    \n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n    vec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n   // vec3 h = normalize(v + l);\n    //vec3 lightDir = normalize(plight_pos);\n    //vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    //vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n    float diff =clamp( dot(normal, l), 0.0, 1.0);;\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\tspecular = pow( specular, shininess );\n   \t\n    float fre = pow(clamp(1.0 + dot(rd, normal), 0.0, 1.0), 3.0);\n    final += color * ( diffuse + specular+fre*0.5);\n    //final = 0.9 * final + 0.1;\n    \n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n            \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    return colobj;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(15.0, 10.0, -15.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -15.0, 16.0, 15.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n \n    \n    vec3 ro=vec3(0.0,15.0,-10.0);\n    \n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------FIN\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.5843,0.33,0.0)    ///cafe\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "//---por jorgeflores ----jorge2017a1\n\n//referencia\n//https://www.shadertoy.com/view/wsScWV ......Creado por NonGrate en 2020-04-19\n\n///Referencia  la grande comunidad de usuarios de  Shadertoy... :)\n//Reference the large community of Shadertoy users ... :)\n\n//#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n\n// Durations\nconst float pulg=2.0;\n    \n\nconst float WHOLE_NOTE = 1.0*pulg;\nconst float HALF_NOTE = 1.0/2.0*pulg;\nconst float _2_NOTE = 1.0/2.0*pulg;\nconst float _4_NOTE = 1.0/4.0*pulg;\nconst float _8_NOTE = 1.0/8.0*pulg;\nconst float _16_NOTE = 1.0/16.0*pulg;\nconst float _32_NOTE = 1.0/32.0*pulg;\nconst float DOUBLE_NOTE = 2.0*pulg;\n\nconst float OCT00 = 0.0/8.0*pulg;\nconst float OCT01 = 1.0/8.0*pulg;\nconst float OCT02 = 2.0/8.0*pulg;\nconst float OCT03 = 3.0/8.0*pulg;\nconst float OCT04 = 4.0/8.0*pulg; //1/2\nconst float OCT05 = 5.0/8.0*pulg;\nconst float OCT06 = 6.0/8.0*pulg;\nconst float OCT07 = 7.0/8.0*pulg;\nconst float OCT08 = 8.0/8.0*pulg;\nconst float OCT09 = 9.0/8.0*pulg;\nconst float OCT0908 = 9.0/8.0*pulg;\n\nconst float SEG_1 = 1.0*pulg;\nconst float SEG_2 = 2.0*pulg;\nconst float SEG_1D2 =1.0/ 2.0*pulg;\nconst float SEG_1D8 =1.0/ 8.0*pulg;\nconst float SEG_1D16 =1.0/ 16.0*pulg;\nconst float SEG_3D16 =3.0/ 16.0*pulg;\nconst float SEG_3D4 =3.0/ 4.0*pulg;\nconst float SEG_1D4 =1.0/ 4.0*pulg;\n\n\n\n\nstruct TNote {\n    // in Hz, see \"common\" tab\n    float note;\n    float octave;\n    float offset; // offset - time in seconds when to start playing note\n    float duration;  // duration of a note (1/4, 1/8, ...), see \"common\" tab\n};\n\n\n\n\nfloat n2f(float n)\n{\n    return 440.0*pow(2.0,(n-69.0)/12.0);\n}\n\n\nfloat n2m(float n)\n{\n    return pow(2.0,n/12.0);\n}\n\n\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n///-----------------------------------\n\nconst float t2 =6.5;\n\nconst TNote[] notes = TNote[] \n    (\n    //9/8*0.0\n    TNote(C, 4.0,OCT0908*0.0+ OCT07, _8_NOTE), \n    ///------------\n    //9/8*1.0\n    TNote(F, 2.0,OCT0908*1.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*1.0+ OCT01, SEG_1), \n    TNote(C, 2.0,OCT0908*1.0+ OCT01, SEG_1),\n        \n    TNote(A, 3.0,OCT0908*1.0+ OCT01, _2_NOTE),\n        \n    TNote(A, 3.0,OCT0908*1.0+ SEG_1D2+OCT01, _8_NOTE),\n        \n    TNote(C, 4.0,OCT0908*1.0+ SEG_1D2+OCT01*2.0, SEG_3D16),\n    TNote(D, 4.0,OCT0908*1.0+ SEG_1D2+OCT01*2.0+SEG_3D16, _8_NOTE),\n     //------------\n    //9/8*2.0   \n    TNote(E, 2.0,OCT0908*2.0+ OCT01, SEG_1), \n    TNote(G, 2.0,OCT0908*2.0+ OCT01, SEG_1),\n    TNote(C, 3.0,OCT0908*2.0+ OCT01, SEG_1), \n    \n    TNote(G, 3.0,OCT0908*2.0+ OCT01, SEG_3D4),\n        \n    TNote(G, 3.0,OCT0908*2.0+ OCT01*7.0, SEG_1D8),\n    TNote(A, 3.0,OCT0908*2.0+ OCT01*8.0, SEG_1D8),\n    \n    //------------\n    //9/8*3.0 \n       \n    //TNote(E, 2.0,OCT0908*3.0+ OCT01, SEG_1), \n    //TNote(G, 2.0,OCT0908*3.0+ OCT01, SEG_1),\n    //TNote(C, 3.0,OCT0908*3.0+ OCT01, SEG_1), \n       \n    TNote(AS, 3.0,OCT0908*3.0+ OCT01, SEG_1D4), \n        \n    TNote(F, 4.0,OCT0908*3.0+ OCT01+SEG_1D4, SEG_1D4), \n    \n    TNote(F, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8, SEG_3D16), \n    TNote(E, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8+SEG_3D16, SEG_1D8), \n    TNote(C, 4.0,OCT0908*3.0+ OCT01+SEG_1D4*2.0+SEG_1D8+SEG_3D16+SEG_1D8, SEG_1D8),\n     ///---------------------   \n    //9/8*4.0 \n    \n    TNote(F, 2.0,OCT0908*4.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*4.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*4.0+ OCT01, SEG_1),\n        \n    TNote(D, 4.0,OCT0908*4.0+ OCT01, SEG_1D8),\n    TNote(C, 4.0,OCT0908*4.0+ OCT01+SEG_1D8, SEG_1D16),\n    TNote(AS, 3.0,OCT0908*4.0+ OCT01+SEG_1D8+SEG_1D16, SEG_1D16),\n        \n    TNote(A, 3.0,OCT0908*4.0+ OCT01+SEG_1D8+SEG_1D16*2.0, SEG_1D2),\n        \n    TNote(C, 3.0,OCT0908*4.0+ OCT09-SEG_3D16, SEG_3D16),\n      ///---------------------   \n    //9/8*5.0    \n        \n    TNote(F, 2.0,OCT0908*5.0+ OCT01, SEG_1), \n    TNote(AS,2.0,OCT0908*5.0+ OCT01,SEG_1), \n    TNote(D, 3.0,OCT0908*5.0+ OCT01, SEG_1), \n        \n    TNote(D, 4.0,OCT0908*5.0+ OCT01, SEG_1D8), \n    TNote(D, 4.0,OCT0908*5.0+ OCT01+SEG_1D16, SEG_3D16), \n    \n    TNote(D, 4.0,OCT0908*5.0+ OCT01*4.0, SEG_3D16), \n    TNote(G, 4.0,OCT0908*5.0+ OCT01*5.0, SEG_1D8), \n    TNote(F, 4.0,OCT0908*5.0+ OCT01*6.0, SEG_3D16), \n    TNote(E, 4.0,OCT0908*5.0+ OCT01*7.0, SEG_3D16), \n    TNote(F, 4.0,OCT0908*5.0+ OCT01*7.5, SEG_1D16), \n    TNote(D, 4.0,OCT0908*5.0+ OCT01*8.0, SEG_3D16),\n        \n    //9/8*6.0\n    TNote(F, 2.0,OCT0908*6.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*6.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*6.0+ OCT01, SEG_1),\n    \n    TNote(C, 4.0,OCT0908*6.0+ OCT01*1.0, SEG_1D4),\n    TNote(F, 3.0,OCT0908*6.0+ OCT01*5.0, SEG_3D16),\n    TNote(G, 3.0,OCT0908*6.0+ OCT01*6.0+SEG_1D16, SEG_3D16),\n    TNote(A, 3.0,OCT0908*6.0+ OCT01*7.0+SEG_1D16, SEG_3D16),    \n    TNote(D, 4.0,OCT0908*6.0+ OCT01*8.0+SEG_1D16, SEG_3D16),\n   \n    //9/8*7.0\n    TNote(E, 2.0,OCT0908*7.0+ OCT01, SEG_1), \n    TNote(G, 2.0,OCT0908*7.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*7.0+ OCT01, SEG_1),\n        \n    TNote(C, 4.0,OCT0908*7.0+ OCT01, SEG_1D4),\n    \n    TNote(C, 4.0, OCT0908*7.0+ OCT01*4.0, SEG_3D16),\n    TNote(AS, 3.0,OCT0908*7.0+ OCT01*5.0, SEG_3D16),\n    TNote(A, 3.0, OCT0908*7.0+ OCT01*6.0, SEG_1D4),\n        \n    TNote(E, 3.0,OCT0908*7.0+ OCT01*9.0, SEG_3D16),\n        \n    //9/8*8.0\n    TNote(F, 2.0,OCT0908*8.0+ OCT01, SEG_1), \n    TNote(A, 2.0,OCT0908*8.0+ OCT01, SEG_1), \n    TNote(C, 3.0,OCT0908*8.0+ OCT01, SEG_1),\n        \n    TNote(F, 3.0,OCT0908*8.0+ OCT01, SEG_1D2)\n        \n        \n     \n);\n\n\nvec2 noteFreq(TNote note, float time) {\n    \n    // 6.2831 = 2pi\n    // exp() goes exponentially down to fade out the volume\n    //return vec2(sin(6.2831 * note.frequency * time) * exp(-1.0/note.duration * (time - note.offset)));\n    float n1=saw(time,note.note, note.octave)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    float n2=saw(time,note.note, note.octave+1.0)* exp(-1.0/note.duration * (time - note.offset)); \n    float n3=saw(time,note.note, note.octave+2.0)* exp(-1.0/note.duration * (time - note.offset)); \n    return vec2((n1+n2+n3)/2.0);\n    \n}\n\n\nvec2 mainSound( in int samp,float time) \n{\n    vec2 result;\n    \n    // time counts in seconds\n    // (time - x) is required, because we want to \"reset\" exp() function\n    // otherwise the output of exp() function will go down globally\n    // and we'll hear only first note\n\n    float ftime= mod(time, 16.5);\n    for (int i = 0; i < notes.length(); i++) {\n        TNote note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        {\n            result += noteFreq(note, ftime);\n            \n        }\n    }\n\n\treturn result*0.35;\n    //return result;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 461, 493, 493, 577], [582, 582, 628, 628, 715], [716, 817, 854, 854, 949], [950, 950, 989, 989, 1084], [1085, 1085, 1124, 1124, 1219], [1220, 1220, 1259, 1259, 1354], [1356, 1400, 1447, 1447, 1474], [1476, 1476, 1519, 1519, 1546], [1548, 1548, 1596, 1596, 1624], [1672, 1737, 1771, 1771, 1869], [1870, 1870, 1904, 1904, 1996], [1997, 1997, 2031, 2031, 2123], [2124, 2164, 2198, 2198, 2295], [2297, 2297, 2334, 2334, 2417], [2419, 2419, 2496, 2496, 2631], [2634, 2634, 2746, 2746, 3898], [3906, 3906, 3926, 3926, 4054], [4056, 4056, 4106, 4106, 4233], [4235, 4235, 4277, 4277, 4447], [4449, 4489, 4514, 4514, 8458], [8463, 8463, 8549, 8549, 9409], [9415, 9466, 9490, 9490, 9678], [9679, 9742, 9775, 9775, 10239], [10241, 10295, 10331, 10331, 10565], [10566, 10655, 10735, 10735, 11012], [11013, 11054, 11147, 11147, 11251], [11253, 11302, 11359, 11359, 12581]]}
{"id": "wdtfRS", "name": "SoftClip", "author": "TinyTexel", "description": "A soft clip that smoothly blends between the Reinhard tone mapping transfer function and a hard clip.", "tags": ["function", "tonemapping", "clip", "transfer"], "likes": 15, "viewed": 674, "published": 3, "date": "1605454468", "time_retrieved": "2024-07-30T20:35:15.271397", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n\tA soft clip that smoothly blends between the Reinhard tonemapping transfer function and a hard clip.\n    \n    related: \n    \n            https://www.shadertoy.com/view/tltyR2 | SoftClip2\n            https://www.shadertoy.com/view/dt3fWl | GeneralizedClip\n*/\n\nfloat Reinhard(float x) { return x / (x + 1.0); }\nfloat HardClip(float x) { return   min(x, 1.0); }\n\n// x: [0, inf], s: (-1, 1] / (soft, hard]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\nfloat InvSoftClip(float x, float s)\n{\n    return x * (s*x + x - 2.0) / (x * 2.0 - 2.0);\n}\n\n// x: [-inf, inf], s: (-1, 1] / (soft, hard]\nfloat SoftClipS(float x, float s)\n{\n    float y = sqrt(SoftClip(x*x, s));// sqrt(f(x)) ensures C2 at x=0\n    \n    return x < 0.0 ? -y : y;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    // relevant plotting code:\n    \n    // black\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \n    \n    // grey\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.0) -tex.y, 1.) * 0.5);  \n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.55) -tex.y, 1.) * 0.5);  \n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.85) -tex.y, 1.) * 0.5);  \n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.9921875) -tex.y, 1.) * 0.5);\n    \n    // red\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(SoftClip(tex.x, max(-0.99, sin(iTime))) -tex.y, 1.));  \n\n       \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfRS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[367, 367, 392, 392, 416], [417, 417, 442, 442, 466], [468, 510, 544, 544, 608], [610, 610, 647, 647, 699], [701, 746, 781, 781, 888], [891, 891, 939, 939, 2209]]}
{"id": "WsdfRS", "name": "pick & pan objects: 3 methods", "author": "FabriceNeyret2", "description": "- simple pick: click on a disk and pan.\n- + press&keep D: pick a whole disk region\n- + press&keep F: frame a region when pick a disk to move the selection", "tags": ["mouse", "picking", "tuto", "gui", "selection", "panning"], "likes": 13, "viewed": 1014, "published": 3, "date": "1605441810", "time_retrieved": "2024-07-30T20:35:16.023386", "image_code": "void mainImage( out vec4 O, vec2 U )\n{  \n    O-=O;\n    \n    for (int i = 1; i < N; i++ )                                                // --- draw disks\n        O +=  clamp( ( 10. - length( U - R.y*T(vec2(i,0)).xy ) ) *.5 , 0., 1. ) // mask\n            * hue( float(i)/50. );                                              // color\n    \n    if ( mouseClicked ) {                                                       // --- mousegrab UI\n        vec2 M = iMouse.xy, S = abs(iMouse.zw);\n        float METHOD = T(0).y;\n        if (METHOD==2.) O += max(0., 1.- .5* abs(length( U - M) - 100. ));      // neighborhood\n        vec2 D = min( abs(U-M), abs(U-S) );\n        if (METHOD==3. && T(0).x==1. &&\n            ( D.x<1. && in(U.y,M.y,S.y) || D.y<1. && in(U.x,M.x,S.x) ) ) O++;   // frame\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 150;       // number of disks\n\n#define R             iResolution.xy\n#define T(U)          texelFetch( iChannel0, ivec2(U), 0 )\n\n// --- most  utils from https://www.shadertoy.com/view/llySRh\n                                                        \n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame). cf https://www.shadertoy.com/view/3dcBRS\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) \n#define keyClick(a)  ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define hash(p)        fract( sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453 )\n\n#define in(x,a,b)    ( x > min(a,b) && x < max(a,b) )\n", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > .5 )  discard;\n    if ( iFrame < 1 )  { O.xy = hash( U.x+iTime )*R/R.y; return; }       // init disks\n    O = T(U);                                                            // restore previous state\n    \n    vec2 M = iMouse.xy / R.y;\n \n    int METHOD = keyClick(64+6) ? 3 :  keyClick(64+4) ? 2 : 1;           // D: 2 (disk) F: 3 (framed)\n    if ( U.x == .5 && mouseDown ) O-=O;                                  // reset state if F released too early\n    if ( U.x == .5 ) O.y = float(METHOD);                                // for UI ( see Image tab )\n    \nif (METHOD==1) {        // --- method 1: pick one object ------------------------------ \n\n    if ( U.x == .5 )                                                     // mouse target in (0,0).w\n        if ( mouseDown ) {\n            for( int i=1; i<N; i++ ) \n                if (length( M-T(vec2(i,0)).xy ) < 10./R.y ) O.w = float(i)+.5; // pick disk \n        }\n        else if ( mouseUp ) O.w = 0.;                                    // deselect\n    if ( U.x == T(0).w ) O.xy = M;\n\n} else if (METHOD==2) { // --- method 2: pick a neighborhood -------------------------- \n\n    if ( U.x == .5 ) { O.zw = M; return; }                               // prev mouse pos in (0,0).zw        \n    if ( mouseDown &&  length(M-O.xy) < 100./R.y ) O.w = 1.;             // disk picked in region\n    if ( mouseUp ) O.w = 0.;                                             // release all disks   \n // if ( O.w == 1. ) O.xy = M;                                           // if picked, follow mouse\n    if ( mouseClicked && O.w == 1. ) O.xy += M - T(0).zw;                // if picked, follow mouse\n\n} else if (METHOD==3) { // --- method 3: pick a framed region -------------------------\n\n    if ( U.x == .5 ) {                                                   // mouse state in (0,0)\n        if ( mouseDown ) {\n            O.x = 0.; int d = 0;\n            for( int i=1; i<N; i++ )                                     // do we clicked on a disk ?\n                if (length( M-T(vec2(i,0)).xy ) < 10./R.y ) d = i;       // pick disk \n            if ( d == 0 ) O.x = 1.;                                      // no disk clicked: start a framing\n                else      O.x = 2.;                                      // a disk is clicked: panning mode\n        }\n       // if ( mouseUp ) O.x = O.x==1. ? 3. : 0.;\n        O.zw = M;                                                        // prev mouse pos in (0,0).zw\n        return;\n    }\n    vec2 S = abs(iMouse.zw) / R.y;                                       // framing start\n    if ( mouseUp && T(0).x == 2. ) O.w = 0.;                             // up while panning: deselect all\n    if ( mouseUp && T(0).x == 1.                                         // framing end: select framed disks\n         && in(O.x, S.x,M.x) &&  in(O.y, S.y,M.y) ) O.w = 1.; \n    if ( mouseClicked  && T(0).x == 2. && O.w == 1. ) O.xy += M - T(0).zw; // if picked, follow mouse \n}\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 791]]}
{"id": "WdtBRS", "name": "Julia Fractal Orbit Trap", "author": "JuliaPoo", "description": "A small doodle bcuz I'm bored", "tags": ["julia", "orbit", "trap"], "likes": 7, "viewed": 599, "published": 3, "date": "1605434684", "time_retrieved": "2024-07-30T20:35:16.776373", "image_code": "#define MAX_ITER 500\n#define INF 100.\n\n#define col1 vec3(1., .3, .4)\n#define col2 vec3(.4, 1., .2)\n#define col3 vec3(.3, .4, 1.)\n\nfloat trap(in vec2 uv, in vec2 p) {\n    float txt = texture(iChannel0, uv).x;\n    return distance(uv, p) * (txt + 1.);\n}\n\nfloat shake(float off)\n{\n    return sin(iTime*.5 + off) + .2*sin(iTime*.7+.5 + off*.3) + .1*sin(iTime+.3 + off*.7);\n}\n\nvec3 render(in vec2 uv)\n{\n    float s = .13*sin(iTime*.3);\n    vec2 c = vec2(-0.77568377,0.134646737) + s*s;\n    int i = 0;\n    \n    float mdist1 = INF; float mdist2 = INF; float mdist3 = INF;\n    float dist1, dist2, dist3; \n    for (i=0; i<MAX_ITER; ++i)\n    {\n        if (uv.x*uv.x + uv.y*uv.y > 4.) break;\n        \n        uv = vec2(uv.x*uv.x - uv.y*uv.y, 2.*uv.x*uv.y) + c;\n        \n        dist1 = trap(uv, vec2(0.,0.));\n        dist2 = trap(uv, vec2(0.,.5));\n        dist3 = trap(uv, vec2(.5,0.));\n        \n        if (mdist1 > dist1) mdist1 = dist1;\n        if (mdist2 > dist2) mdist2 = dist2;\n        if (mdist3 > dist3) mdist3 = dist3;\n    }\n    \n    // Compute smooth iteration:\n    // https://iquilezles.org/articles/msetsmooth\n    float iter = float(i) - log2(log2(dot(uv,uv))) + 4.0;\n    iter /= float(MAX_ITER);\n    \n    vec3 col = mdist1*col1 + mdist2*col2 + mdist3*col3;\n    col *= (cos(iter*1.57)+.6)/2.;\n    col *= col;\n    col = 1.-col;\n    \n    return clamp(vec3(col), 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s1, s2;\n    s1 = shake(0.); s2 = shake(1.5);\n    \n    vec2 uv = (1.9 + .1*s1)*(fragCoord/iResolution.xy - .5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = render(uv);\n    vec3 w = vec3(2.,.2,.1);\n    col += vec3(.1,-.7,.2)*(length(w) - dot(col, w));\n    col = pow(col, vec3(1., 1.5, 1.9));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 165, 165, 250], [252, 252, 276, 276, 369], [371, 371, 396, 396, 1369], [1371, 1371, 1428, 1428, 1783]]}
{"id": "wdcfzB", "name": "Grid from 3 points", "author": "Plento", "description": "Learned about barycentric coordinates today.", "tags": ["2d", "grid", "triangles", "barycentric"], "likes": 7, "viewed": 346, "published": 3, "date": "1605428649", "time_retrieved": "2024-07-30T20:35:17.525370", "image_code": "// Plento\n\n// Learned about barycentric coordinates today.\n\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv.x += iTime*.08 + 10.;\n    \n    vec3 col = vec3(1);\n    \n    // Triangle scale\n    float scl = 0.5;\n    \n    // The points of the triangle\n    vec2 A = vec2(0., .25)*scl;\n    vec2 B = vec2(-0.25, -0.25)*scl;\n    vec2 C = vec2(0.25, -0.25)*scl;\n    \n    // The point we want the barycentric coords of\n    vec3 M = vec3(uv.x, uv.y, 1.);\n    \n    // Matrix with the points\n    mat3 mat = mat3(vec3(A, 1.), vec3(B, 1.), vec3(C, 1.));\n    \n    // Inverse of the matrix * the point = barycentric coords\n    vec3 bc = inverse(mat) * M;\n    vec3 bid = floor(bc);\n    \n    // Offset position based on ID\n    bc.x -= cos(bid.z*80.+bid.y*90. + iTime*.03)*2.;\n    \n    // Set new ID \n    vec3 rbc = fract(bc-.5)-.5;\n    bid = floor(bc);\n    \n    // Color based on ID\n    float t = (bid.x*55.56 + bid.y*60.46 + bid.z*50.2);\n    col = .5+.3*cos(vec3(1.2, 0.3, 1.3) * t + vec3(1.4, 0.3, 3.3));\n    \n    // Pick random side to add shadow thing\n    int i = int(floor(hash13(bid*343.3)*3.));\n    col *= min(ss(.0, .1, abs(rbc[i]))+.42, 1.);\n    \n    // Grid lines\n    col *= ss(0.0, 0.0124, abs(rbc.x) - 0.02);\n    col *= ss(0.0, 0.0124, abs(rbc.y) - 0.02);\n    col *= ss(0.0, 0.0124, abs(rbc.z) - 0.02);\n    \n    \n    col += texture(iChannel0, vec3(cos(bc.y*3.),sin(bc.x*2.),cos(bc.z*3.))).xyz*.14;\n    \n    f = vec4(col, 1.0);\n}\n\n\n\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 206, 206, 309], [311, 311, 351, 351, 1716]]}
{"id": "wscBRB", "name": "Sliced Amoeba", "author": "Plento", "description": "Having fun with a circle and a loop", "tags": ["2d", "mouse"], "likes": 9, "viewed": 347, "published": 3, "date": "1605411095", "time_retrieved": "2024-07-30T20:35:18.272373", "image_code": "// Cole Peterson\n#define R iResolution\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec3 col = vec3(0);\n\n    float r = .47;\n    float n = 24.;\n    float sw = 0.0;\n    \n    for(float i = n; i > 0.; i--)\n    {\n        vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n        uv *= (i*.001 + .1);\n        uv *= rot(-i*.01);\n        uv -= vec2(iTime*.012*sw, -iTime*.01);\n        if(iMouse.z>0.)uv-=m*.15;\n        vec2 id = floor(uv*8.);\n        \n        uv.y += sin(i*.5 + iTime*4. + uv.x*300.)*.002;\n        uv.x += cos(i*.5 + iTime*4. + uv.y*300.)*.002;\n        \n        vec2 ruv = fract(uv*12.)-.5;\n        id = floor(uv*12.);\n        sw = floor(mod(id.y, 2.))*2. - 1.;\n        \n        vec3 nc = .55+.3*cos(vec3(2.,3.,0.4)*(id.x*40.+id.y+i*50. + iTime*.05)*3.);\n       \n        float s = max(pow(dot(ruv, .8*vec2(cos(iTime*1.85*sw), sin(iTime*1.85*sw)))*4.6, 5.0), 0.0001);\n        nc *= s+.7;\n        nc *= ((n-i)*1.4 / n);\n        \n    \tcol = mix(col, nc, ss(r, r - .015, length(ruv)));\n        col *= ss(0.003, 0.01, abs(length(ruv) - r+.005));\n        \n        r -= i*0.001;\n    }\n    col = 1.-exp(-col*1.4);\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 156, 156, 208], [210, 210, 251, 251, 1298]]}
{"id": "wscBzS", "name": "waving colors 3", "author": "elenzil", "description": "yep.", "tags": ["tags", "comma", "separated"], "likes": 3, "viewed": 280, "published": 3, "date": "1605403512", "time_retrieved": "2024-07-30T20:35:19.104149", "image_code": "float aspect;\nfloat phTex;\n    \n// https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float t) {\n    vec3 c = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    c = c * 0.9 + 0.1;\n    return c;\n}\n\nvec3 color(float u1, float u2, float v) {\n    vec2 uv = vec2(u1 * iResolution.x / 256.0, v * iResolution.y / 256.0 - iTime * 0.0002 * phTex * iResolution.y);\n    float noise = (0.5 + 0.7 * texture(iChannel0, uv).x);\n    vec3 c = palette(u2);\n    return c * mix(1.0, noise, phTex);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect = iResolution.x / iResolution.y;\n        \n    // artificial down-resing to test AA\n    const float pixelate = 1.0; //  + (sin(iTime) * 0.5 + 0.5) * 14.0;\n    \n    fragCoord = round(fragCoord / pixelate);\n    \n    vec2 res = ceil(iResolution.xy / pixelate);\n    \n    vec2 uv = fragCoord/res.xy;\n    \n    const int bins = int(40.0 / pixelate);\n\n    vec3 col = vec3(0.0);\n    \n    // phased-in behavior\n    float phWig = smoothstep(3.0, 15.0, iTime);\n    float phBin = smoothstep(6.0, 18.0, iTime);\n    float phTap = smoothstep(9.0, 30.0, iTime);\n    float phPin = smoothstep(0.0, 15.0, iTime);\n          phTex = smoothstep(1.0, 09.0, iTime);\n    float phCol = smoothstep(9.0, 45.0, iTime);\n    \n    float accum = 0.0;\n\n    // horizontal AA amount\n    float binEdge = 4.0 / res.x;\n\n    \n    for (int bin = 0; bin < bins; ++bin) {\n        float binMid = (float(bin) + 0.5)/float(bins);\n        float t = uv.x;\n        \n        // taper the overall thing\n        t = ((t - 0.5) * (1.0 + pow(uv.y, 0.8) * 0.3 * phPin)) + 0.5;\n        \n        // wiggle the things\n        float fmod = sin(binMid * 3.0 - iTime * 0.31) * 0.5 + 0.5;\n        t += abs(uv.x - 0.5) * phWig * uv.y * 0.2 * sin(uv.y * 20.0 - iTime * (1.0 + phBin * binMid + 0.6) + fmod);\n        \n        // wiggle the overall thing a tiny bit\n        t += 0.01 * phWig * uv.y * sin(uv.y * 7.0 - iTime);\n        \n        float binWidth = 1.0 / float(bins) * (1.0 - phTap * uv.y * 0.75);\n        float binBeg = binMid - binWidth * 0.5;\n        float binEnd = binMid + binWidth * 0.5;\n        if (t >= binBeg - binEdge && t < binEnd + binEdge) {\n            // AA:\n            float amount = 1.0;\n            if (t < binBeg) {\n                amount = smoothstep(binBeg - binEdge, binBeg, t);\n            }\n            else if (t > binEnd) {\n                amount = 1.0 - smoothstep(binEnd, binEnd + binEdge, t);\n            }\n            \n            float uvyMod = mod(float(bin), 2.0) * 2.0 - 1.0;\n            float st1 = sin(iTime * 0.04) * 0.5 + 0.5;\n            float tMod = 1.0 * mix(1.0, uvyMod, phCol * st1);\n            vec3 c = color(t, t + tMod, uv.y * uvyMod);\n            c = mix(c, vec3(0.2), uv.y * 0.9 * phTex);\n    \t\tcol += c * amount;\n            accum += amount;\n        }\n        binBeg = binEnd;\n    }\n    \n    col /= max(accum * 1.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 97, 165, 165, 208], [210, 210, 233, 233, 368], [370, 370, 411, 411, 652]]}
{"id": "3dcfzB", "name": "Mountains on Mars", "author": "jarble", "description": "An edit of [url=https://www.shadertoy.com/view/MlBGzm]WalkInMars[/url], with a more detailed fractal terrain.", "tags": ["raymarching", "terrain", "mountain"], "likes": 3, "viewed": 462, "published": 3, "date": "1605387928", "time_retrieved": "2024-07-30T20:35:19.858133", "image_code": "// Utility stuff\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\n\nconst int STEPS = 170;\nconst float FAR = 1500.0;\n\n\n//scene\nfloat map1(vec3 pos)\n{\n    float offset = 0.002;\n    float px = pos.x * offset;\n    float pz = pos.z * offset;\n    vec2 v = vec2(px, pz);\n    \n    float fbm = texture(iChannel0, v, -100.0).r;\n    fbm = smoothstep(0.1, 0.4, fbm * 0.25);\n    fbm *= 3.25;\n    \n    float rocks = texture(iChannel1, vec2(pos.x, pos.z) * 0.1, -100.0).r;\n    fbm += smoothstep(0.1, 1.0, rocks) * 0.15;\n    return fbm;\n    \n}\n\nfloat map(vec3 pos){\n    float factor = 1.0;\n    float result = 0.0;\n    for(int i = 0; i < 4; i++){\n        result += map1(pos/factor/factor)*factor;\n    \tfactor *= 1.25;\n    }\n    return pos.y - result;\n}\n\nvec3 light = vec3(-2.0, 1.0, 1.0);\nvec4 lightcol = vec4(0.8, 0.3, 0.3, 0.0);\nvec3 origin;\n\n\n\nvec4 getcolor(in vec3 rp, in vec3 dir)\n{\n    vec4 color = mix(lightcol, vec4(0.8, 0.5, 0.5, 0.0) * 0.7, smoothstep(0.0, 1.0, rp.y));\n    vec3 offset = vec3(0.07, 0.0, 0.0);\n    vec3 grad = vec3( map(rp + offset.xyy) - map(rp - offset.xyy),\n                     offset.x * 2.0,\n                     map(rp + offset.yyx) - map(rp - offset.yyx));\n\n    grad = normalize(grad);\n    float d = dot(grad, light);\n    d = clamp(d, 0.0, 1.0);\n    color *= d;\n    \n    dir = normalize(rp - origin);\n    float r = 1.0 - clamp(dot(-dir, grad), 0.0, 1.0);\n    r = pow(r, 4.0);\n    color += r * vec4(0.7, 0.2, 0.0, 0.0) * 0.8;\n    \n    return color;\n    \n}\n\nbool trace(in vec3 origin, in vec3 dir, out vec4 color, out vec3 hitp)\n{\n    vec3 rp = origin;\n    float h = 0.0;\n    for (int i = 0; i < STEPS; ++i)\n    {\n        rp += h * 0.5 * dir + dir * 0.01;\n        h = map(rp);\n\t    vec3 _rp = rp - origin;\n        if (dot(_rp, _rp) > FAR)\n        {\n            break;\n        }\n        \n        if(h <= 0.0)\n        {\n            color = getcolor(rp, dir);\n            hitp = rp;\n            return true;\n        }\n    }\n    \n    vec3 _rp = rp - origin;\n    hitp = rp;\n    \n    if(dot(_rp,_rp) < FAR)\n    {\n        rp.y = 0.1;\n        \n        color = getcolor(rp, dir);\n        return true;\n    }\n    color = vec4(0.0);\n    return false;\n}\n    \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0);\n    vec2 uv = fragCoord.xy / iResolution.y;\n\tlight = normalize(light);\n    \n    vec2 m = iMouse.xy;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0)\n    {\n       m = iResolution.xy * 0.4;\n    }\n    \n    vec2 mouse = ((m.xy / iResolution.y) - vec2(0.4)) * 4.0;\n    origin = vec3(iTime * 0.8, 0.45, iTime * 0.9);\n    origin.y = -map(origin) + 0.8;\n    \n    vec3 dir = vec3(uv - vec2(0.5), 1.0);\n    dir *= rotx(mouse.y);\n    dir *= roty(mouse.x);\n    \n    vec3 hitp = vec3(0.0);\n    \n    if(!trace(origin, dir, color, hitp))\n    {\n        \n        //some stars\n        vec4 stars = texture(iChannel2, (uv + vec2(mouse.x, -mouse.y)) * 0.25);\n        stars.r *= 1.4;\n        stars.g *= 1.1;\n        stars.b += pow(sin(uv.x + mouse.x ) * 0.5 + 0.5, 15.0);\n            \n        float flter = 1.0;\n        stars -= flter;\n        stars = clamp(stars, 0.0, 1.0);\n        stars += smoothstep(0.0, 0.3, pow(stars.r, 2.0) * 2.0);\n        \n        // blinking\n        stars *= texture(iChannel0, vec2(iTime * 0.003) + uv * 0.01);\n        \n        color += stars;\n        \n    }\n    \n    // fog\n    float fz = abs(hitp.z - origin.z) / FAR;\n    fz = pow(fz, 1.35) * 7.0;\n    fz *= clamp( 2.0 - hitp.y, 0.0, 1.0) * 1.25;\n    color += vec4(1.0, 0.4, 0.2, 0.0) * fz * 11.0;\n    fragColor = color;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/(2*2*2*2*2*2)+t/2*2*2*2*2))*(t>>(t/4096+((t/(4096)))))|(t>>(t/(2+(t/4096)%3)+(t/(131072))))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n\n/*\nint s1(int t, int b){\n\treturn (t/b/4096)%b;\n}\n\nvec2 sound1(int t)\n{\n    int t1 = t*(s1(t/10,10)+1);\n    t = t*(6-s1(t1*t/7,3)+s1(t1/7,6)/2+s1(t1/11,3)/2+s1(t1/13,6)/2-s1(t1,2))|t1>>6|t1>>5;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n*/\n\n/*\nint s1(int t, int b){\n\treturn (t/4096)%b;\n}\n\nvec2 sound1(int t)\n{\n    t = t*(2-s1(t/3,3)+s1(t/6,7)-s1(t,2))|t>>6|t>>5;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n*/\n\n/*\nint s1(int t, int b){\n\treturn (t/b/4096)%b;\n}\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/(2-s1(t,3)+s1(t,7)-s1(t,2))))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n*/", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 57, 57, 184], [185, 185, 205, 205, 332], [386, 394, 416, 416, 795], [797, 797, 817, 817, 1003], [1098, 1098, 1138, 1138, 1739], [1741, 1741, 1813, 1813, 2423], [2432, 2432, 2489, 2489, 3798]]}
{"id": "WscBzB", "name": "Generations (<2.3Kb)", "author": "dean_the_coder", "description": "The result of an ultra-quick coding session.\nA reproduction of a common image.", "tags": ["3d", "raymarching", "chess", "reproduction", "cineshader"], "likes": 19, "viewed": 12520, "published": 3, "date": "1605387755", "time_retrieved": "2024-07-30T20:35:20.614112", "image_code": "// Generations (4K)\n//\n// The result of an ultra-quick coding session.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 123 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define N\tnormalize\n\nstruct H {\n\tfloat d;\n\tvec3 mat;\n\tfloat spe;\n};\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat B(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.)); }\n\nfloat cap(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat P(vec3 p) {\n\tp.y -= 3.2;\n\tfloat d = max(length(p.xz) - .3, p.y);\n\td = smin(d, length(p) - .8, .1);\n\tp.y += 1.05;\n\td = smin(d, cap(p, .75, .07), .5);\n\tp.y += 1.5;\n\td = smin(d, cap(p, .75, .12), .5);\n\tp.y += .4;\n\treturn smin(d, cap(p, .9, .2), .4);\n}\n\nfloat K(vec3 p) {\n\tp.y -= 1.85;\n\tfloat d = cap(p, .4 - .14 * cos(p.y * 1.4 - .8), 2.);\n\tp.y--;\n\td = smin(d, cap(p, .7, .1), .2);\n\tp.y += 2.;\n\td = smin(d, cap(p, .7, .1), .2);\n\tp.y += .5;\n\td = smin(d, cap(p, 1., .3), .1);\n\tp.xz *= mat2(.76484, -.64422, .64422, .76484);\n\tp.y -= 4.;\n\treturn min(min(d, B(p, vec3(.5, .2, .1))), B(p, vec3(.2, .5, .1)));\n}\n\nH map(vec3 p) {\n\tH h = H(P(p * 1.2), vec3(.8), 20.);\n\tfloat gnd = length(p.y);\n\tif (gnd < h.d) {\n\t\th.d = gnd;\n\t\th.mat = vec3(.2);\n\t}\n\n\treturn h;\n}\n\nvec3 no(vec3 p, float t) {\n\tvec2 e = vec2(.5773, -.5773) * t * .003;\n\treturn N(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nfloat sha(vec3 p) {\n\tvec3 rd = N(vec3(-8, 8, -8) - p);\n\tfloat res = 1.,\n\t      t = .5;\n\tfor (float h, i = 0.; i < 32.; i++) {\n\t\th = K(p + rd * t);\n\t\tres = min(res, 150. * h / t);\n\t\tt += h;\n\t\tif (res < .01 || t > 20.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, H data) {\n\tvec3 l = N(vec3(-8, 8, -8) - p),\n\t     n = no(p, d);\n\tfloat ao = dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\t      primary = max(0., dot(l, n)),\n\t      bounce = max(0., dot(l * vec3(-1, 0, -1), n)) * .1,\n\t      spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(l, n))), data.spe));\n\tprimary *= mix(.4, 1., sha(p));\n\treturn data.mat * ((primary + bounce) * ao + spe) * vec3(2, 1.6, 1.4) * exp(-length(p) * .1);\n}\n\nvec3 rgb(vec3 ro, vec3 rd) {\n\tvec3 p;\n\tfloat d = .01;\n\tH h;\n\tfor (float steps = 0.; steps < 45.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tif (d > 64.) return vec3(0);\n\t\td += h.d;\n\t}\n\n\treturn applyLighting(p, rd, d, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec3 f, r,\n\t     ro = vec3(2, 5, -10),\n\t     col = vec3(0),\n\t     R = iResolution;\n\tro.yz *= mat2(.98007, -.19867, .19867, .98007);\n\tf = N(vec3(2, 4, 0) - ro);\n\tr = N(cross(vec3(0, 1, 0), f));\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = ((fc + vec2(dx, dy) * .5) - .5 * R.xy) / R.y;\n\t\t\tcol += rgb(ro, N(f + r * uv.x + cross(f, r) * uv.y));\n\t\t}\n\t}\n\n\tcol = pow(col / 4., vec3(.45));\n\tvec2 q = fc.xy / R.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[469, 469, 508, 508, 600], [602, 602, 627, 627, 665], [667, 667, 704, 704, 812], [814, 814, 831, 831, 1068], [1070, 1070, 1087, 1087, 1421], [1423, 1423, 1438, 1438, 1569], [1571, 1571, 1597, 1597, 1759], [1761, 1761, 1780, 1780, 2018], [2020, 2020, 2055, 2055, 2086], [2088, 2088, 2142, 2142, 2586], [2588, 2588, 2616, 2616, 2844], [2846, 2846, 2891, 2891, 3444]]}
{"id": "WdcBRB", "name": "Session raymarching", "author": "illus0r", "description": "Session raymarching", "tags": ["raymarching"], "likes": 2, "viewed": 272, "published": 3, "date": "1605376288", "time_retrieved": "2024-07-30T20:35:21.372085", "image_code": "float sdBox( vec3 p )\n{\n  vec3 b = vec3(1.);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = (FC*2.-iResolution.xy)/iResolution.y;\n    float d=0.,e;\n    vec3 rd=normalize(vec3(uv,1.)), p;\n    rd.xz*=rot(iMouse.x/100.);\n    rd.xy*=rot(iMouse.y/100.);\n    for(int i=0;i<99;i++){\n        p=rd*d;// uncomment for isometry: +vec3(uv*5.,0.);\n        float size=.2+.15*sin(p.x+iTime);\n        p.z+=iTime;\n        //p=normalize(p)/length(p);\n        p=mod(p,1.);\n        p-=.5;\n        d+=e=(length(p)-size);\n        if(e<.01)break;\n    }\n    float col = (d*.1)+.5;\n    \n    //uv=normalize(uv)/length(uv);\n    //uv = mod(uv,1.);\n    //uv-=.5;\n    //uv*=2.;\n    //col = length(uv)/1.5;\n    fragColor = vec4(col*vec3(203.,221.,180)/255.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 131], [132, 132, 150, 150, 197], [198, 198, 248, 248, 904]]}
{"id": "3tBczt", "name": "LEGO", "author": "zduny", "description": "Click to rotate around X axis.\n\nPress arrows to change size.\nPress SHIFT to toggle between a plate and a brick.\nPress C to change color.\nPress SPACE to stop rotation around Y axis.\n", "tags": ["raymarching", "interactive", "vector", "lego"], "likes": 21, "viewed": 699, "published": 3, "date": "1605375940", "time_retrieved": "2024-07-30T20:35:22.305589", "image_code": "const vec3 background = vec3(0.85);\nconst bool rounded = true;\nconst bool logo = true;\nconst bool shadows = true;\nconst int  reflections = 1;\nconst bool antialiasing = true;\n\nconst bool showLogoTexture = false;\nconst bool showBlurred = false;\n\nconst float tolerance = 0.005;\nconst int steps = 256;\nconst float minStep = 0.001;\n\nconst float studRadius = 0.3;\nconst float studHeight = 0.1;\nconst float logoHeight = 0.015;\n\nconst float pi = 3.1416;\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\nfloat rounding = rounded ? 0.016 : 0.0;\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nfloat sdRound(in float sd, in float radius) { return sd - radius; }\n\nfloat sdSmoothUnion(in float sd1, float sd2, in float radius) {\n  float h = clamp(0.5 + 0.5 * (sd2 - sd1) / radius, 0.0, 1.0);\n  return mix(sd2, sd1, h) - radius * h * (1.0 - h);\n}\n\nfloat sdSmoothSubtraction(in float sd1, in float sd2, in float k) {\n  float h = clamp(0.5 - 0.5 * (sd1 + sd2) / k, 0.0, 1.0);\n  return mix(sd1, -sd2, h) + k * h * (1.0 - h); \n}\n\nfloat sdBox(in vec3 position, in vec3 dimensions) {\n  vec3 q = abs(position) - dimensions;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdBrick(in vec3 position, in vec3 size) {\n  float brick = sdBox(position, size - rounding);\n  float result = sdRound(brick, rounding);\n\n  return result;\n}\n\nfloat sdCylinder(in vec3 position, in float radius, in float height) {\n  vec2 d = abs(vec2(length(position.xz), position.y)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdStuds(in vec3 position, in vec3 size) {\n  position.xz = fract(position.xz);\n  position.xz -= vec2(0.5);\n  position.y -= size.y + studHeight - rounding * 2.0;\n    \n  float studs = sdCylinder(position, \n                           studRadius - rounding * 2.0, \n                           studHeight);\n    \n  return sdRound(studs, rounding * 2.0);\n}\n\nfloat sdLogo(in vec3 position) {\n  position.xz = fract(position.xz);\n    \n  float tex = texture(iChannel2, clamp(vec2(position.x, 1.0 - position.z), 0.01, 1.0)).r;\n  return -pow(tex, 0.4) * logoHeight;\n}\n\nfloat sdCutout(in vec3 position, in vec3 size) {\n  position.y += 0.2 - logoHeight * 2.0;\n    \n  float box = sdBox(position, vec3(size.x - 0.18 - rounding, size.y, size.z - 0.18 - rounding));\n    \n  return sdRound(box, rounding);\n}\n\nfloat sdStudsCutout(in vec3 position, in vec3 size) {   \n  position.x -= fract(size.x);\n  position.z -= fract(size.z);\n  position.xz = fract(position.xz);\n  float cutouts = sdCylinder(position - vec3(0.5, 0.0, 0.5), 0.15 - rounding, size.y - rounding - 0.01);\n    \n  return sdRound(cutouts, rounding);  \n}\n\nfloat sdTubes(in vec3 position,  in vec3 size, in float innerRadius) {\n  float radius = innerRadius - rounding;\n  float height = size.y - rounding - 0.05;\n  \n  float halfWidth = size.x * 0.5;\n \n  if (size.x > 0.5) {\n    position.x = clamp(position.x, -size.x + 0.5, size.x - 0.5);\n  }\n  if (size.z > 0.5) {\n    position.z = clamp(position.z, -size.z + 0.5, size.z - 0.5);\n  }\n  position.x -= fract(size.x) - (size.x < 1.0 ? 0.0 : 0.5);\n  position.z -= fract(size.z) - (size.z < 1.0 ? 0.0 : 0.5);\n  position.xz = fract(position.xz);\n  position -= vec3(0.5, -0.05, 0.5);\n  float tubes = sdRound(sdCylinder(position, radius + 0.11, height), rounding);\n  float cutout = sdCylinder(position, innerRadius + 0.01, height + 0.2);\n\n  return sdSmoothSubtraction(tubes, cutout, rounding);\n}\n\nvec2 rotation = vec2(0.0, 0.68);\nvec3 brickSize = vec3(1.0, 0.6, 1.5);\nvec3 brickColor = vec3(0.03, 0.55, 0.79);\n\nfloat map(in vec3 position) {\n  float result = sdBrick(position, brickSize);\n    \n  if (position.y < brickSize.y) {  \n    float cutout = sdCutout(position, brickSize);\n    float studs = sdStudsCutout(position, brickSize); \n      \n    bool smallTube = brickSize.x < 1.0 || brickSize.z < 1.0;\n      \n    result = sdSmoothSubtraction(result, cutout, rounding);\n    result = sdSmoothSubtraction(result, studs, rounding);\n      \n    if (brickSize.x > 0.5 || brickSize.z > 0.5) {\n      float tubes = sdTubes(position, brickSize, smallTube ? 0.073 : studRadius);\n      result = sdSmoothUnion(result, tubes, rounding);\n    }\n  }\n    \n  if (position.y > brickSize.y) {\n    position.x -= mod(brickSize.x, 1.0);\n    position.z -= mod(brickSize.z, 1.0);\n    float studs = sdStuds(position, brickSize);\n    if (studs < logoHeight * 2.0) { \n      studs += logo ? sdLogo(position) : 0.0; \n    }\n    result = sdSmoothUnion(result, studs, rounded ? 0.015 : 0.0);  \n  }    \n    \n  return result;\n}\n\nvec3 calculateNormal(in vec3 position, in float pixelSize) {\n  vec2 e = vec2(1.0, -1.0) * pixelSize * 0.1;\n  return normalize(\n      e.xyy * map(position + e.xyy) + e.yyx * map(position + e.yyx) +\n      e.yxy * map(position + e.yxy) + e.xxx * map(position + e.xxx));\n}\n\nstruct AABB {\n  vec3 min;\n  vec3 max;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \nmat4 rotationMatrix(in vec3 axis, in float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(in vec3 translation) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n              translation.x, translation.y, translation.z, 1.0);\n}\n    \nRay createRayPerspective(in vec2 resolution, in vec2 screenPosition,\n                         in float verticalFov) {\n  vec2 topLeft = vec2(-resolution.x, -resolution.y) * 0.5;\n  float z = (resolution.x * 0.5) / abs(tan(verticalFov * 0.5));\n\n  return Ray(vec3(0.0), normalize(vec3(topLeft + screenPosition, -z)));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nvoid transformRay(inout Ray ray, mat4 matrix) {\n  ray.origin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  ray.direction = normalize(matrix * vec4(ray.direction, 0.0)).xyz;\n}\n\nvoid reflectRay(inout Ray ray, vec3 position, vec3 normal) {\n  ray.origin = position + normal * 0.01;\n  ray.direction = reflect(ray.direction, normal);\n}\n\nvoid transformNormal(inout vec3 normal, in mat4 matrix) {\n  normal = normalize((matrix * vec4(normal, 0.0)).xyz);\n}\n\nbool rayIntersectsAABB(in Ray ray, in AABB aabb, out float t0, out float t1) {\n  vec3 invR = 1.0 / ray.direction;\n\n  vec3 tbot = invR * (aabb.min - ray.origin);\n  vec3 ttop = invR * (aabb.max - ray.origin);\n\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n\n  vec2 t = max(tmin.xx, tmin.yz);\n  t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  t1 = min(t.x, t.y);\n\n  return t0 <= t1;\n}\n\nvec3 shade(in Ray ray, in vec3 position, in vec3 normal, in vec3 light) {\n  vec3 reflection = reflect(-light, normal); \n    \n  float diffuse = max(0.0, dot(light, normal));\n  float specular = pow(max(dot(-ray.direction, reflection), 0.0), 16.0);\n        \n  return diffuse * brickColor + vec3(0.3) * specular;\n}\n\nvec4 blend(in vec4 under, in vec4 over) {\n  vec4 result = mix(under, over, over.a);\n  result.a = over.a + under.a * (1.0 - over.a);\n    \n  return result;\n}\n\nbool intersectsBrick(inout Ray ray, in AABB aabb) {\n  float t, t1;\n  if (!rayIntersectsAABB(ray, aabb, t, t1)) {\n    return false;\n  }\n \n  t = max(t, 0.0);  \n  for (int i = 0; i < steps; i++) {\n    vec3 position = positionOnRay(ray, t);\n    float sd = map(position);\n     \n    if (sd < tolerance) {\n      ray.origin = position;\n      return true;\n    }\n    \n    t += max(tolerance, sd);\n      \n    if (t > t1) {\n      return false;\n    }\n  }\n    \n  return false;\n}\n\nfloat intersectsBrickShadow(inout Ray ray, in AABB aabb) {\n  float res = 1.0;\n  float ph = 1e10;\n  float k = 10.0;\n    \n  float t, t0, t1;\n  if (!rayIntersectsAABB(ray, aabb, t, t1)) {\n    return res;\n  }\n  t = max(0.0, t0);\n  for (int i = 0; i < steps; i++) {\n    vec3 position = positionOnRay(ray, t);\n    float sd = map(position);\n     \n    float y = sd * sd / (2.0 * ph);\n    float d = sqrt(sd * sd - y * y);\n    res = min(res, k * d / max(0.0, t - y));\n    ph = sd;\n      \n    t += min(sd, 0.005);\n      \n    if (res < 0.0001 || t > t1) {\n      break;\n    }\n  }\n    \n  return clamp(res, 0.0, 1.0);\n}\n\nvec4 trace(in Ray ray) {\n  AABB aabb = AABB(-brickSize, brickSize);\n  aabb.min -= vec3(0.01);\n  aabb.max += vec3(0.01);\n  aabb.max.y += (studHeight + logoHeight) * 2.0;\n    \n  mat4 transform = rotationMatrix(up, rotation.x) * \n                   rotationMatrix(right, rotation.y) *\n                   translationMatrix(vec3(0.0, 0.0, 6.0));\n    \n  vec3 light = vec3(-0.9, 0.9, 2.5);\n  \n  vec3 forward = forward;\n  transformRay(ray, transform);\n  transformNormal(light, transform);\n  transformNormal(forward, transform);\n  \n  float mul = 1.0;\n  vec3 result = vec3(0.0);\n  for (int i = 0; i <= reflections; i++) {\n    if (intersectsBrick(ray, aabb)) {\n      vec3 normal = calculateNormal(ray.origin, 0.001);\n      float shadow = 1.0;\n      \n      if (shadows) {\n        Ray shadowRay = Ray(ray.origin, normalize(light));\n        shadowRay.origin += normal * 0.001;\n        shadow = intersectsBrickShadow(shadowRay, aabb);\n      }\n          \n      result += mul * brickColor * 0.2;\n      result += mul * shadow * shade(ray, ray.origin, normal, light);\n      \n      reflectRay(ray, ray.origin, normal);\n      mul *= 0.045;\n    } else {\n      result += mul * background;\n      break;\n    }\n  }\n    \n  return vec4(result, 1.0);\n}\n\nvec4 takeSample(in vec2 position, float pixelSize) {\n  const float fov = pi / 2.0;\n  Ray ray = createRayPerspective(iResolution.xy, position, fov);\n  return trace(ray);\n}\n\nvec4 superSample(in vec2 fragCoord) {\n  const int sampleCount = antialiasing ? 4 : 1;\n  const vec2[] samplePositions = vec2[](                             \n    vec2(-0.125, -0.375), vec2(0.375, -0.125),      \n    vec2(-0.375,  0.125), vec2(0.125,  0.375)       \n  );                                                         \n  vec4 result = vec4(0.0);                                    \n  float samplesSqrt = sqrt(float(sampleCount));                        \n  for (int i = 0; i < sampleCount; i++) {                              \n    result += takeSample(fragCoord + samplePositions[i],               \n                         1.0 / samplesSqrt);                           \n  }                                                                    \n                                                                         \n  return result / float(sampleCount);                                  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  rotation = texelFetch(STORAGE, rotationDataLocation, 0).xy;\n  brickSize = texelFetch(STORAGE, brickSizeDataLocation, 0).rgb;\n  brickColor = texelFetch(STORAGE, brickColorDataLocation, 0).rgb;\n    \n  if (showLogoTexture) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv += vec2(0.5);\n    if (showBlurred) {\n      fragColor = texture(iChannel2, uv);\n    } else {\n      fragColor = texture(iChannel1, uv);\n    }\n    return;\n  }  \n    \n  fragColor = vec4(toSRGB(superSample(fragCoord).rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0);\nconst ivec2 rotationDataLocation = ivec2(1, 0);\nconst ivec2 brickSizeDataLocation = ivec2(2, 0);\nconst ivec2 brickColorDataLocation = ivec2(3, 0);\n", "buffer_a_code": "const int KEY_SHIFT = 16;\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_C     = 67;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isKeyUp(in int key) {\n  return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.0;\n}\n\nbool isKeyToggled(in int key) {\n  return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.0;\n}\n\nbool saveRotationData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == rotationDataLocation) {\n    if (iFrame == 0) {\n      fragColor = vec4(0.0, 0.68, 0.0, 0.0);\n    } else {\n      vec2 rotation = texelFetch(STORAGE, rotationDataLocation, 0).xy;\n      rotation.x += isKeyToggled(KEY_SPACE) ? 0.0 : 0.003;\n      rotation.y = iMouse.x > 0.0 \n        ? mix(rotation.y, -iMouse.y / iResolution.y * 8.0 - 1.0, 0.03) \n        : rotation.y;\n      fragColor = vec4(rotation, 0.0, 0.0);\n    }\n    return true;\n  }\n    \n  return false;\n}\n\n\nbool saveBrickSizeData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == brickSizeDataLocation) {\n    if (iFrame == 0) {\n      fragColor = vec4(vec3(1.0, 0.6, 1.5), 0.0);\n    } else {\n      vec3 size = texelFetch(STORAGE, brickSizeDataLocation, 0).rgb;\n      if (isKeyUp(KEY_DOWN)) {\n        size.z -= 0.5;\n      }\n      if (isKeyUp(KEY_UP)) {\n        size.z += 0.5;\n      }\n      if (isKeyUp(KEY_LEFT)) {\n        size.x -= 0.5;\n      }\n      if (isKeyUp(KEY_RIGHT)) {\n        size.x += 0.5;\n      }\n      size.xz = clamp(size.xz, 0.5, 8.0);\n      size.y = isKeyToggled(KEY_SHIFT) ? 0.2 : 0.6;\n        \n      fragColor = vec4(size, 0.0);\n    }\n    return true;\n  }\n    \n  return false;\n}\n\nconst int colorsLength = 12;\nconst vec3[] colors = vec3[](\n  vec3(0.949, 0.803, 0.215), // Bright Yellow\n  vec3(0.996, 0.541, 0.094), // Bright Orange\n  vec3(0.788, 0.101, 0.035), // Bright Red\n  vec3(0.784, 0.439, 0.627), // Bright Purple\n  vec3(0.0  , 0.333, 0.749), // Bright Blue\n  vec3(0.039, 0.203, 0.388), // Earth Blue\n  vec3(0.027, 0.545, 0.788), // Dark Azur\n  vec3(0.137, 0.470, 0.254), // Dark Green\n  vec3(0.294, 0.623, 0.290), // Bright Green\n  vec3(0.733, 0.913, 0.043), // Bright Yellowish Green\n  vec3(0.345, 0.164, 0.070), // Reddish Brown\n  vec3(0.019, 0.074, 0.113)  // Black\n);\n\nvec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\n\nbool saveBrickColorData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == brickColorDataLocation) {\n    if (iFrame == 0) {\n      int index = 2;\n      fragColor = vec4(toLinear(colors[index]), float(index));\n    } else {\n      vec4 color = texelFetch(STORAGE, brickColorDataLocation, 0);\n      if (isKeyUp(KEY_C)) {\n        color.w += 1.0;\n      }\n      color.w = float(int(color.w) % colorsLength);\n      color.rgb = mix(color.rgb, toLinear(colors[int(color.w)]), 0.15);\n        \n      fragColor = color;\n    }\n    return true;\n  }\n    \n  return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);  \n    \n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n    \n  if (saveRotationData(iFragCoord, fragColor)) {\n    return;\n  }\n    \n  if (saveBrickSizeData(iFragCoord, fragColor)) {\n    return;\n  }\n    \n  if (saveBrickColorData(iFragCoord, fragColor)) {\n    return;\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created with Shadertoy-SVG: https://zduny.github.io/shadertoy-svg/\n\nconst int samples = 4; // (square root, actual number = samples^2)\n\nconst vec3 positions[225] =\n    vec3[225](vec3(0.9408613367791228, 0.43095909706765456, 0),\n              vec3(0.9264762435267317, 0.44352663509707624, 0),\n              vec3(0.8947861254762883, 0.4638692865687953, 0),\n              vec3(0.8777536433400679, 0.4715814511436973, 0),\n              vec3(0.841995189500208, 0.48193008580309815, 0),\n              vec3(0.8048872251098951, 0.48530129825064333, 0),\n              vec3(0.7861678547856077, 0.4842916850607259, 0),\n              vec3(0.7490796945333518, 0.47672464768502254, 0),\n              vec3(0.7309834472672143, 0.47010427463184123, 0),\n              vec3(0.6967507470536414, 0.45128546857518964, 0),\n              vec3(0.6815966127536668, 0.4397110894047105, 0),\n              vec3(0.6551836294986841, 0.41262743744267205, 0),\n              vec3(0.634461035245403, 0.3809322504759403, 0),\n              vec3(0.626419887197555, 0.3635934525495947, 0),\n              vec3(0.6174678863278233, 0.3359891364381042, 0),\n              vec3(0.47899216991926896, -0.24549629059456585, 0),\n              vec3(0.4741737266143069, -0.2751084016236367, 0),\n              vec3(0.473508033500468, -0.29441126217125624, 0),\n              vec3(0.4778079185647557, -0.33209980412273227, 0),\n              vec3(0.4891422806195873, -0.36776620212046324, 0),\n              vec3(0.5069424579864692, -0.40045137004997605, 0),\n              vec3(0.5306397889869092, -0.42919622179679773, 0),\n              vec3(0.5445221803251843, -0.44179131469092675, 0),\n              vec3(0.575999001128787, -0.4628274056990749, 0),\n              vec3(0.5934512651744912, -0.471028632284476, 0),\n              vec3(0.6313136680076146, -0.48217771366078943, 0),\n              vec3(0.6700652677983625, -0.48548096726553785, 0),\n              vec3(0.7077538097498388, -0.48118108220125, 0),\n              vec3(0.7434202077475696, -0.46984672014641854, 0),\n              vec3(0.7761053756770824, -0.45204654277953654, 0),\n              vec3(0.8048502274239044, -0.4283492117790967, 0),\n              vec3(0.8286956768735618, -0.3993233888235917, 0),\n              vec3(0.8466826379115826, -0.36553773559151465, 0),\n              vec3(0.8557512754292231, -0.33741694258942456, 0),\n              vec3(0.996423388384482, 0.25472647096242323, 0),\n              vec3(1, 0.29294405649279703, 0),\n              vec3(0.9960265197448488, 0.3307089760104401, 0),\n              vec3(0.9846915584576656, 0.3670555420215273, 0),\n              vec3(0.7570787710671805, -0.3279246723576778, 0),\n              vec3(0.7481456607517563, -0.34489128805259295, 0),\n              vec3(0.7363053501222789, -0.3595089915158228, 0),\n              vec3(0.7220133343540593, -0.37147883456812697, 0),\n              vec3(0.705725108622407, -0.38050186903026445, 0),\n              vec3(0.6878961681026325, -0.3862791467229943, 0),\n              vec3(0.6689820079700466, -0.3885117194670758, 0),\n              vec3(0.649438123399958, -0.38690063908326805, 0),\n              vec3(0.6304205367457778, -0.3813442914822551, 0),\n              vec3(0.6058327710290847, -0.3668259574428918, 0),\n              vec3(0.5925016292489125, -0.3537028573471296, 0),\n              vec3(0.5819678219692868, -0.33835579970027974, 0),\n              vec3(0.5720660623804614, -0.31216168851770726, 0),\n              vec3(0.5701398889260951, -0.28352583320630764, 0),\n              vec3(0.7155770729851352, 0.3272211318267263, 0),\n              vec3(0.7245101833005594, 0.3441877475216413, 0),\n              vec3(0.7363504939300369, 0.35880545098487127, 0),\n              vec3(0.7506425096982563, 0.3707752940371754, 0),\n              vec3(0.7669307354299086, 0.37979832849931283, 0),\n              vec3(0.7847596759496831, 0.38557560619204273, 0),\n              vec3(0.803673836082269, 0.38780817893612424, 0),\n              vec3(0.8330139122006925, 0.38387499214489884, 0),\n              vec3(0.8511765563761193, 0.3765710374186516, 0),\n              vec3(0.8670548875320945, 0.36613614277101764, 0),\n              vec3(0.8803725907900135, 0.35302297421472734, 0),\n              vec3(0.8908533512712726, 0.3376841977625116, 0),\n              vec3(0.8982208540972669, 0.3205724794271009, 0),\n              vec3(0.9021987843893928, 0.3021404852212259, 0),\n              vec3(0.49404521200236484, 0.32051485979824523, 0),\n              vec3(0.48453276188440575, 0.3577040643779089, 0),\n              vec3(0.4771903875232675, 0.3751107130887582, 0),\n              vec3(0.4578154766529401, 0.40706596689622404, 0),\n              vec3(0.432829864860236, 0.4345676472763559, 0),\n              vec3(0.4030049704751837, 0.4568443358991251, 0),\n              vec3(0.3691122118278114, 0.47312461443450343, 0),\n              vec3(0.3508814516338892, 0.4787750316912871, 0),\n              vec3(0.3319230072481476, 0.4826370645524623, 0),\n              vec3(0.29392752080375106, 0.4846864612988684, 0),\n              vec3(0.2612007307844826, 0.48048830820567073, 0),\n              vec3(0.2302822471806536, 0.47103805054705644, 0),\n              vec3(0.20168320536497242, 0.4567572335473808, 0),\n              vec3(0.17591474071014757, 0.43806740243099923, 0),\n              vec3(0.15348798858888713, 0.41539010242226715, 0),\n              vec3(0.13491408437389962, 0.3891468787455399, 0),\n              vec3(0.12070416343789314, 0.35975927662517293, 0),\n              vec3(0.1132180666353646, 0.33590866248028545, 0),\n              vec3(-0.025338065404089227, -0.24549634892148534, 0),\n              vec3(-0.030138663741522187, -0.27510780484715514, 0),\n              vec3(-0.03077473905960626, -0.29440849931717467, 0),\n              vec3(-0.026382729388821247, -0.33208369115772834, 0),\n              vec3(-0.021501053563444672, -0.35021629512770946, 0),\n              vec3(-0.0067323828414551645, -0.3844667856656981, 0),\n              vec3(0.01422201609720819, -0.4152246749992118, 0),\n              vec3(0.026835852193426657, -0.4289915274635997, 0),\n              vec3(0.05597077473090595, -0.45269631448625475, 0),\n              vec3(0.07234545200867437, -0.46239235564396874, 0),\n              vec3(0.10834321567353711, -0.47686699975078806, 0),\n              vec3(0.12770761787487328, -0.4814513703741509, 0),\n              vec3(0.16645647691437215, -0.4847091805549651, 0),\n              vec3(0.20413166875492594, -0.4803171708841801, 0),\n              vec3(0.23976561979432254, -0.46886097801576615, 0),\n              vec3(0.27239075643035005, -0.45092623860369346, 0),\n              vec3(0.30103950506079724, -0.4270985893019323, 0),\n              vec3(0.31357036712323705, -0.41315793489678415, 0),\n              vec3(0.3344403332411665, -0.38158898948668446, 0),\n              vec3(0.3489149773479858, -0.3455912258218219, 0),\n              vec3(0.42894164996584827, -0.011973834455500498, 0),\n              vec3(0.42972497189919556, 0.005285807701407088, 0),\n              vec3(0.4243979338193449, 0.022557766661810377, 0),\n              vec3(0.410058067874302, 0.03884635586226634, 0),\n              vec3(0.3951169066462894, 0.04640446369357787, 0),\n              vec3(0.381196346171893, 0.04853615910943173, 0),\n              vec3(0.29306584924039014, 0.048288253738397215, 0),\n              vec3(0.274830481833795, 0.04272753468825939, 0),\n              vec3(0.2605446253882744, 0.030976607914030365, 0),\n              vec3(0.25170207774583986, 0.014529271257721282, 0),\n              vec3(0.24954095118037345, 0.000010362544709030003, 0),\n              vec3(0.25170207774583986, -0.014508546168303221, 0),\n              vec3(0.2605446253882744, -0.030955882824612358, 0),\n              vec3(0.274830481833795, -0.042706809598841385, 0),\n              vec3(0.283547839032084, -0.04635430745454747, 0),\n              vec3(0.31863004442757803, -0.048515434020013674, 0),\n              vec3(0.25202421179653345, -0.32792467235767736, 0),\n              vec3(0.2430911014811088, -0.3448912880525925, 0),\n              vec3(0.22438277766140802, -0.36584357985454286, 0),\n              vec3(0.20067054935175999, -0.380501869030264, 0),\n              vec3(0.18284160883198575, -0.38627914672299396, 0),\n              vec3(0.15420575352058608, -0.3882053201773602, 0),\n              vec3(0.13463670610345768, -0.3845783042799128, 0),\n              vec3(0.11660773985991546, -0.37726960481225597, 0),\n              vec3(0.09378165831698615, -0.3605708705373532, 0),\n              vec3(0.07691326269863996, -0.3383557997002793, 0),\n              vec3(0.06947573809880092, -0.3212402796776524, 0),\n              vec3(0.0647789303657329, -0.29324752838512047, 0),\n              vec3(0.06639001074954098, -0.2737036438150323, 0),\n              vec3(0.20590410104503487, 0.3127127704626628, 0),\n              vec3(0.21430798481922464, 0.33602689053214585, 0),\n              vec3(0.2307763633722193, 0.3590033597484454, 0),\n              vec3(0.24497227602406446, 0.37110352110207073, 0),\n              vec3(0.2612004704622315, 0.3802611176093988, 0),\n              vec3(0.288338328393416, 0.3877891213826372, 0),\n              vec3(0.31743891786417455, 0.3869192865064165, 0),\n              vec3(0.34946754816430725, 0.37512846657511933, 0),\n              vec3(0.3628577585368089, 0.365782121700417, 0),\n              vec3(0.37946114119164776, 0.34811165849076364, 0),\n              vec3(0.3938616180155652, 0.3191469867055984, 0),\n              vec3(0.3981023608114145, 0.2852790298923329, 0),\n              vec3(0.40366307986155214, 0.26704366248573774, 0),\n              vec3(0.40885812964828094, 0.2593136830277175, 0),\n              vec3(0.42314398609380155, 0.24756275625348856, 0),\n              vec3(0.4463802520051028, 0.24175413183231625, 0),\n              vec3(0.470219090251927, 0.2480492150414748, 0),\n              vec3(0.4849219338265358, 0.2599629758397277, 0),\n              vec3(0.4902778529410525, 0.2677196751665549, 0),\n              vec3(-0.4238290609360067, -0.3879545880996168, 0),\n              vec3(-0.42399143141451245, -0.3857869964555996, 0),\n              vec3(-0.3435303791941341, -0.04876145696646751, 0),\n              vec3(-0.1881453922760149, -0.04826752864897948, 0),\n              vec3(-0.17862738206770856, -0.04635430745454769, 0),\n              vec3(-0.16218004541139952, -0.037511759812112966, 0),\n              vec3(-0.15042911863717046, -0.023225903366592502, 0),\n              vec3(-0.14678162078146462, -0.014508546168303545, 0),\n              vec3(-0.1448683995870328, 0.005011261049414758, 0),\n              vec3(-0.15042911863717046, 0.02324662845600997, 0),\n              vec3(-0.16218004541139952, 0.037532484901530376, 0),\n              vec3(-0.17862738206770856, 0.04637503254396521, 0),\n              vec3(-0.19314629078072088, 0.04853615910943141, 0),\n              vec3(-0.3201711275962441, 0.04853615910943141, 0),\n              vec3(-0.2395580256922737, 0.3877292902425807, 0),\n              vec3(-0.013614947063175453, 0.3879753131890342, 0),\n              vec3(0.001553809488533675, 0.3901364397545005, 0),\n              vec3(0.010271166686822708, 0.3937839376102065, 0),\n              vec3(0.024557023132343314, 0.4055348643844355, 0),\n              vec3(0.03339957077477784, 0.42198220104074474, 0),\n              vec3(0.035560697340244474, 0.436501109753757, 0),\n              vec3(0.03339957077477784, 0.45102001846676926, 0),\n              vec3(0.024557023132343314, 0.46746735512307847, 0),\n              vec3(0.010271166686822708, 0.4792182818973075, 0),\n              vec3(0.001553809488533675, 0.4828657797530134, 0),\n              vec3(-0.012965099224478305, 0.4850269063184797, 0),\n              vec3(-0.28168609287903024, 0.48485067306612756, 0),\n              vec3(-0.3043423804615203, 0.47698065006041873, 0),\n              vec3(-0.32039964632717177, 0.4593075787165124, 0),\n              vec3(-0.5323543124694348, -0.42474224806260563, 0),\n              vec3(-0.5337338883980041, -0.43998512769155146, 0),\n              vec3(-0.5289140955923151, -0.45796681352017904, 0),\n              vec3(-0.5177230286574426, -0.4726176319384635, 0),\n              vec3(-0.5012621748910309, -0.48217218549675583, 0),\n              vec3(-0.48805568326353965, -0.4848137981736519, 0),\n              vec3(-0.18106368398796246, -0.4846778019002089, 0),\n              vec3(-0.16282831658136732, -0.47911708285007126, 0),\n              vec3(-0.1485424601358467, -0.46736615607584225, 0),\n              vec3(-0.13969991249341207, -0.4509188194195329, 0),\n              vec3(-0.13780384309711902, -0.4313999159620832, 0),\n              vec3(-0.14369958214938683, -0.41318230940945977, 0),\n              vec3(-0.1559911147398615, -0.3989255304682293, 0),\n              vec3(-0.17289041011825634, -0.3901082881133118, 0),\n              vec3(-0.8900128517657221, -0.3879545880996168, 0),\n              vec3(-0.6958469474912434, 0.43024439706208367, 0),\n              vec3(-0.6970680454957241, 0.44937401560737006, 0),\n              vec3(-0.7052111612782105, 0.46615542921161646, 0),\n              vec3(-0.711534261055692, 0.4730785079255896, 0),\n              vec3(-0.7279951148221036, 0.4828153067067156, 0),\n              vec3(-0.7474699697899465, 0.48548096726553785, 0),\n              vec3(-0.756841335071212, 0.48394209929187737, 0),\n              vec3(-0.7735159477880796, 0.4757893172039107, 0),\n              vec3(-0.7858110168317786, 0.461806574093651, 0),\n              vec3(-0.789707952521583, 0.45298025484212406, 0),\n              vec3(-0.9986204823983503, -0.42409851472697496, 0),\n              vec3(-1, -0.4393413360290013, 0),\n              vec3(-0.9951802071943109, -0.4573230218576287, 0),\n              vec3(-0.9839891402594383, -0.4719738402759131, 0),\n              vec3(-0.9675282864930268, -0.48152839383420565, 0),\n              vec3(-0.9543217948655356, -0.48417000651110154, 0),\n              vec3(-0.6473297955899583, -0.48403401023765885, 0),\n              vec3(-0.629094428183363, -0.4784732911875213, 0),\n              vec3(-0.6148085717378426, -0.4667223644132922, 0),\n              vec3(-0.6059660240954079, -0.4502750277569829, 0),\n              vec3(-0.6040688937631473, -0.43076335438168084, 0),\n              vec3(-0.6099273821747845, -0.41268783466083125, 0),\n              vec3(-0.6220949031388547, -0.3986636757539205, 0),\n              vec3(-0.6387381593037988, -0.3900488756991408, 0),\n              vec3(-0.6530549597150334, -0.3879545880996168, 0),\n              vec3(-0.1875131137334065, -0.3879545880996168, 0),\n              vec3(0.4962741058527447, 0.2909237200595889, 0),\n              vec3(0.9001729001451884, 0.2680691160390561, 0),\n              vec3(0.9714728267726251, 0.392803750658161, 0));\nconst ivec3 triangles[219] = ivec3[219](\n    ivec3(0, 61, 1), ivec3(0, 62, 61), ivec3(0, 224, 62), ivec3(1, 60, 2),\n    ivec3(1, 61, 60), ivec3(2, 60, 3), ivec3(3, 59, 4), ivec3(3, 60, 59),\n    ivec3(4, 58, 5), ivec3(4, 59, 58), ivec3(5, 58, 6), ivec3(6, 57, 7),\n    ivec3(6, 58, 57), ivec3(7, 56, 8), ivec3(7, 57, 56), ivec3(8, 56, 9),\n    ivec3(9, 55, 10), ivec3(9, 56, 55), ivec3(10, 54, 11), ivec3(10, 55, 54),\n    ivec3(11, 53, 12), ivec3(11, 54, 53), ivec3(12, 52, 13), ivec3(12, 53, 52),\n    ivec3(13, 52, 14), ivec3(14, 52, 15), ivec3(15, 51, 16), ivec3(15, 52, 51),\n    ivec3(16, 51, 17), ivec3(17, 50, 18), ivec3(17, 51, 50), ivec3(18, 50, 19),\n    ivec3(19, 49, 20), ivec3(19, 50, 49), ivec3(20, 48, 21), ivec3(20, 49, 48),\n    ivec3(21, 47, 22), ivec3(21, 48, 47), ivec3(22, 47, 23), ivec3(23, 46, 24),\n    ivec3(23, 47, 46), ivec3(24, 46, 25), ivec3(25, 45, 26), ivec3(25, 46, 45),\n    ivec3(26, 44, 27), ivec3(26, 45, 44), ivec3(27, 43, 28), ivec3(27, 44, 43),\n    ivec3(28, 42, 29), ivec3(28, 43, 42), ivec3(29, 41, 30), ivec3(29, 42, 41),\n    ivec3(30, 40, 31), ivec3(30, 41, 40), ivec3(31, 39, 32), ivec3(31, 40, 39),\n    ivec3(32, 38, 33), ivec3(32, 39, 38), ivec3(33, 38, 223),\n    ivec3(33, 223, 34), ivec3(34, 223, 35), ivec3(35, 65, 36),\n    ivec3(35, 223, 65), ivec3(36, 64, 37), ivec3(36, 65, 64),\n    ivec3(37, 63, 224), ivec3(37, 64, 63), ivec3(62, 224, 63),\n    ivec3(66, 143, 67), ivec3(66, 144, 143), ivec3(66, 222, 144),\n    ivec3(67, 143, 68), ivec3(68, 142, 69), ivec3(68, 143, 142),\n    ivec3(69, 142, 70), ivec3(70, 141, 71), ivec3(70, 142, 141),\n    ivec3(71, 140, 72), ivec3(71, 141, 140), ivec3(72, 139, 73),\n    ivec3(72, 140, 139), ivec3(73, 139, 74), ivec3(74, 139, 75),\n    ivec3(75, 138, 76), ivec3(75, 139, 138), ivec3(76, 137, 77),\n    ivec3(76, 138, 137), ivec3(77, 137, 78), ivec3(78, 136, 79),\n    ivec3(78, 137, 136), ivec3(79, 135, 80), ivec3(79, 136, 135),\n    ivec3(80, 134, 81), ivec3(80, 135, 134), ivec3(81, 134, 82),\n    ivec3(82, 133, 83), ivec3(82, 134, 133), ivec3(83, 133, 84),\n    ivec3(84, 132, 85), ivec3(84, 133, 132), ivec3(85, 131, 86),\n    ivec3(85, 132, 131), ivec3(86, 131, 87), ivec3(87, 130, 88),\n    ivec3(87, 131, 130), ivec3(88, 130, 89), ivec3(89, 129, 90),\n    ivec3(89, 130, 129), ivec3(90, 128, 91), ivec3(90, 129, 128),\n    ivec3(91, 128, 92), ivec3(92, 127, 93), ivec3(92, 128, 127),\n    ivec3(93, 126, 94), ivec3(93, 127, 126), ivec3(94, 126, 95),\n    ivec3(95, 125, 96), ivec3(95, 126, 125), ivec3(96, 124, 97),\n    ivec3(96, 125, 124), ivec3(97, 123, 98), ivec3(97, 124, 123),\n    ivec3(98, 123, 99), ivec3(99, 122, 100), ivec3(99, 123, 122),\n    ivec3(100, 121, 101), ivec3(100, 122, 121), ivec3(101, 121, 102),\n    ivec3(102, 120, 103), ivec3(102, 121, 120), ivec3(103, 119, 104),\n    ivec3(103, 120, 119), ivec3(104, 109, 105), ivec3(104, 119, 109),\n    ivec3(105, 107, 106), ivec3(105, 109, 107), ivec3(107, 109, 108),\n    ivec3(109, 119, 110), ivec3(110, 113, 111), ivec3(110, 114, 113),\n    ivec3(110, 118, 114), ivec3(110, 119, 118), ivec3(111, 113, 112),\n    ivec3(114, 118, 115), ivec3(115, 117, 116), ivec3(115, 118, 117),\n    ivec3(144, 147, 145), ivec3(144, 148, 147), ivec3(144, 149, 148),\n    ivec3(144, 222, 149), ivec3(145, 147, 146), ivec3(149, 222, 150),\n    ivec3(150, 222, 151), ivec3(152, 181, 153), ivec3(152, 186, 181),\n    ivec3(152, 187, 186), ivec3(152, 221, 187), ivec3(153, 181, 154),\n    ivec3(154, 165, 155), ivec3(154, 180, 165), ivec3(154, 181, 180),\n    ivec3(155, 159, 156), ivec3(155, 160, 159), ivec3(155, 164, 160),\n    ivec3(155, 165, 164), ivec3(156, 158, 157), ivec3(156, 159, 158),\n    ivec3(160, 163, 161), ivec3(160, 164, 163), ivec3(161, 163, 162),\n    ivec3(165, 180, 166), ivec3(166, 177, 167), ivec3(166, 178, 177),\n    ivec3(166, 180, 178), ivec3(167, 172, 168), ivec3(167, 177, 172),\n    ivec3(168, 171, 169), ivec3(168, 172, 171), ivec3(169, 171, 170),\n    ivec3(172, 177, 173), ivec3(173, 175, 174), ivec3(173, 176, 175),\n    ivec3(173, 177, 176), ivec3(178, 180, 179), ivec3(181, 185, 182),\n    ivec3(181, 186, 185), ivec3(182, 184, 183), ivec3(182, 185, 184),\n    ivec3(187, 193, 188), ivec3(187, 194, 193), ivec3(187, 221, 194),\n    ivec3(188, 190, 189), ivec3(188, 193, 190), ivec3(190, 192, 191),\n    ivec3(190, 193, 192), ivec3(195, 205, 196), ivec3(195, 206, 205),\n    ivec3(195, 211, 206), ivec3(195, 212, 211), ivec3(195, 220, 212),\n    ivec3(196, 205, 197), ivec3(197, 205, 198), ivec3(198, 200, 199),\n    ivec3(198, 205, 200), ivec3(200, 205, 201), ivec3(201, 205, 202),\n    ivec3(202, 205, 203), ivec3(203, 205, 204), ivec3(206, 210, 207),\n    ivec3(206, 211, 210), ivec3(207, 209, 208), ivec3(207, 210, 209),\n    ivec3(212, 218, 213), ivec3(212, 219, 218), ivec3(212, 220, 219),\n    ivec3(213, 218, 214), ivec3(214, 218, 215), ivec3(215, 218, 216),\n    ivec3(216, 218, 217));\nconst int len = 219;\n\nbool sameSide(vec3 p1, vec3 p2, vec3 a, vec3 b) {\n  vec3 cp1 = cross(b - a, p1 - a);\n  vec3 cp2 = cross(b - a, p2 - a);\n\n  return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n  return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath(vec2 p) {\n  for (int i = 0; i < len; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = positions[triangle[0]];\n    vec3 b = positions[triangle[1]];\n    vec3 c = positions[triangle[2]];\n\n    if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 0 && !resolutionChanged()) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    return;\n  }  \n    \n  fragColor = vec4(vec3(0.0), 1.0);\n  float normalizer = float(samples * samples);  \n  float step = 1.0 / float(samples);\n      \n  for (int sx = 0; sx < samples; sx++) {\n    for (int sy = 0; sy < samples; sy++) {  \n      vec2 uv = (fragCoord + vec2(float(sx), float(sy)) * step) / iResolution.xy;\n      uv *= 2.0;\n      uv -= vec2(1.0);\n      uv *= 2.24;\n      if (inPath(uv)) {\n        fragColor += vec4(1.0);\n      }\n    }\n  }\n  fragColor /= normalizer;\n  fragColor.a = 1.0;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const int samples = 30;\nconst float sigma = float(samples) * 0.25;\n\nconst float pi = 3.1416;\n\n#define pow2(x) (x * x)\n\nfloat gaussian(vec2 i) {\n  return 1.0 / (2.0 * pi * pow2(sigma)) *\n         exp(-((pow2(i.x) + pow2(i.y)) / (2.0 * pow2(sigma))));\n}\n\nvec3 blur(sampler2D sp, vec2 uv, vec2 scale) {\n  vec3 col = vec3(0.0);\n  float accum = 0.0;\n  float weight;\n  vec2 offset;\n\n  for (int x = -samples / 2; x < samples / 2; ++x) {\n    for (int y = -samples / 2; y < samples / 2; ++y) {\n      offset = vec2(x, y);\n      weight = gaussian(offset);\n      col += texture(sp, uv + scale * offset).rgb * weight;\n      accum += weight;\n    }\n  }\n\n  return col / accum;\n}\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 0 && !resolutionChanged()) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel2, uv);\n    return;\n  }\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = vec4(blur(iChannel1, uv, vec2(0.00045)), 1.0);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 636, 636, 674], [676, 676, 721, 721, 743], [745, 745, 808, 808, 925], [927, 927, 994, 994, 1103], [1105, 1105, 1156, 1156, 1263], [1265, 1265, 1312, 1312, 1425], [1427, 1427, 1497, 1497, 1633], [1635, 1635, 1682, 1682, 1988], [1990, 1990, 2022, 2022, 2193], [2195, 2195, 2243, 2243, 2425], [2427, 2427, 2480, 2480, 2732], [2734, 2734, 2804, 2804, 3513], [3629, 3629, 3658, 3658, 4608], [4610, 4610, 4670, 4670, 4878], [4976, 4976, 5027, 5027, 5495], [5497, 5497, 5542, 5542, 5683], [5689, 5689, 5806, 5806, 6004], [6006, 6006, 6050, 6050, 6093], [6095, 6095, 6142, 6142, 6265], [6267, 6267, 6327, 6327, 6420], [6422, 6422, 6479, 6479, 6537], [6539, 6539, 6617, 6617, 6938], [6940, 6940, 7013, 7013, 7250], [7252, 7252, 7293, 7293, 7407], [7409, 7409, 7460, 7460, 7873], [7875, 7875, 7933, 7933, 8479], [8481, 8481, 8505, 8505, 9704], [9706, 9706, 9758, 9758, 9876], [10774, 10774, 10829, 10829, 11352]]}
{"id": "tsVcWt", "name": "Storm in a teacup", "author": "dean_the_coder", "description": "This started with me trying to work out how to make a cloud, and then developed from there.\nThe sea and plane are deliberately voxel-y, partly to keep the frame rate up and partly coz I just like it.\nNo airplanes were harmed in the making of this shader.", "tags": ["3d", "raymarching", "water", "cineshader"], "likes": 99, "viewed": 16499, "published": 3, "date": "1605367661", "time_retrieved": "2024-07-30T20:35:23.057579", "image_code": "// Processed by 'GLSL Shader Shrinker' (Shrunk by 501 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// Storm in a teacup\n//\n// This started with me trying to work out how to make a cloud,\n// and then kinda developed from there...\n// The sea and plane are deliberately voxel-y, partly\n// to keep the frame rate up and partly coz I just like it. :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time, flash, glow;\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tbool isCloud;\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat noise(float n) {\n\tfloat flr = floor(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.9898) * 43758.545);\n\treturn mix(rndRange.x, rndRange.y, fract(n));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nMarchData sdSea(vec3 p, const float bowlInner) {\n\tMarchData result;\n\tresult.isCloud = false;\n\tmat2 r = rot(23.23);\n\tvec2 af = vec2(1);\n\tfloat t = time * .4,\n\t      wave = noise(p.x);\n\tfor (int i = 0; i < 8; i++) {\n\t\twave += (1. - abs(sin((p.x + t) * af.y))) * af.x;\n\t\tp.xz *= r;\n\t\taf *= vec2(.5, 1.64);\n\t}\n\n\tresult.d = max(p.y + 1. - wave * .3, bowlInner);\n\tresult.mat = vec3(.03, .09, .12) * wave;\n\treturn result;\n}\n\nMarchData sdCup(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(1);\n\tresult.isCloud = false;\n\tfloat bowlInner = length(p) + p.y * .1 - 2.;\n\tresult.d = smin(max(abs(bowlInner) - .06, p.y), max(max(abs(length(p.xy - vec2(2, p.x * p.x * .1 - 1.1)) - .5) - .06, abs(p.z) - .06), -bowlInner), .1);\n\treturn minResult(result, sdSea(p, bowlInner));\n}\n\nfloat sdSaucer(vec3 p) {\n\tfloat l = length(p.xz);\n\tp.y += 1.9 - l * (.1 + .02 * smoothstep(0., .1, l - 2.05));\n\treturn sdCappedCylinder(p.xzy, 2.6, .01) - .02;\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 forward = normalize(-ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdCloud(vec3 p) {\n\tp.y -= 1.3;\n\tfloat d = min(length(p + vec3(.4, 0, 0)), length(p - vec3(.4, 0, 0)));\n\tif (d < 2.0) d -= abs(smoothstep(0., 1., (noise(p * 4.) + noise(p * 9.292 - vec3(0, time, 0)) * .4) * .3) - .4) + .55;\n    return d;\n}\n\nMarchData sdPlane(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(.29, .33, .13);\n\tresult.isCloud = false;\n\n\t// Scale, position, rotate.\n\tp *= 1.5;\n\tp.xz *= rot(time * .6);\n\tp.xy -= vec2(1.5, .4);\n\tp.xy *= rot(sin(time * 3.) * .1);\n\n\t// Fuselage.\n\tvec3 ppp,\n\t     pp = p + vec3(0, 0, .15);\n\tresult.d = sdBox(pp, vec2(.04 + pp.z * .05, .3).xxy);\n    \n    if (result.d > 2.0) return result;\n\n\t// Prop.\n\tppp = pp;\n\tppp.z -= .33;\n\tppp.xy *= rot(time * 8.);\n\tfloat d = sdBox(ppp, vec3(.09, .01 * sin(length(p.xy) * 34.), .005));\n\n\t// Tail.\n\tpp.yz += vec2(-.05, .26);\n\tresult.d = min(min(result.d, sdBox(pp, vec3(.01, .06 * cos(pp.z * 25.6), .03))), sdBox(pp + vec3(0, .05, 0), vec3(.15 * cos(pp.z * 12.), .01, .03)));\n\n\t// Wings\n\tp.y = abs(p.y) - .08;\n\tresult.d = min(result.d, sdBox(p, vec3(.3, .01, .1)));\n\tif (d < result.d) {\n\t\tresult.d = d;\n\t\tresult.mat = vec3(.05);\n\t}\n\n\tresult.d = (result.d - .005) * .4;\n\treturn result;\n}\n\n// Map the scene using SDF functions.\nbool hideCloud;\nMarchData map(vec3 p) {\n\tMarchData result = sdCup(p);\n\tresult.d = min(result.d, sdSaucer(p));\n\tresult = minResult(result, sdPlane(p));\n\tfloat d,\n\t      gnd = length(p.y + 1.7);\n\tif (flash > 0.) {\n\t\td = max(length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * .08) - vec2(.5, 0)), p.y - .7);\n\t\tglow += .001 / (.01 + 2. * d * d);\n\t\tif (d < result.d) result.d = d;\n\t}\n\n\tif (gnd < result.d) {\n\t\tresult.d = gnd;\n\t\tresult.mat = vec3(.2);\n\t}\n\n\tif (!hideCloud) {\n\t\td = sdCloud(p);\n\t\tif (d < result.d) {\n\t\t\tresult.d = d * .7;\n\t\t\tresult.isCloud = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tvec2 e = vec2(.5773, -.5773) * t * 1e-4;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nvec3 cloudNormal(vec3 p) {\n\tconst vec2 e = vec2(.5773, -.5773);\n\treturn normalize(e.xyy * sdCloud(p + e.xyy) + e.yyx * sdCloud(p + e.yyx) + e.yxy * sdCloud(p + e.yxy) + e.xxx * sdCloud(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 32.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 10. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 3.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunDir = normalize(vec3(6, 10, -4) - p),\n\t     n = calcNormal(p, d);\n\treturn data.mat * (max(0., dot(sunDir, n)) * mix(.4, 1., calcShadow(p, vec3(6, 10, -4))) + max(0., dot(sunDir * vec3(-1, 0, -1), n)) * .3) * dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)) * vec3(2, 1.6, 1.4) * exp(-length(p) * .14);\n}\n\nvec3 cloudLighting(vec3 p, float den) {\n\tvec3 n = cloudNormal(p),\n\t     col = vec3(2, 1.6, 1.4) * (1. + flash);\n\treturn min(.75, den) * max(.1, dot(normalize(vec3(6, 10, -4) - p), n)) * cloudAo(p, n, 1.) * col;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tMarchData h;\n\tfloat d = .01,\n\t      den = 0.,\n\t      maxCloudD = 0.;\n\thideCloud = false;\n\tvec3 p, cloudP;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (h.d < .0015) {\n\t\t\tif (!h.isCloud) break;\n\t\t\thideCloud = true;\n\t\t\tcloudP = p;\n\t\t\tmaxCloudD = 20. - sdCloud(p + rd * 20.);\n\t\t}\n\n\t\tif (d > 55.) break; // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (hideCloud) {\n\t\tfor (float i = 0.; i < 20.; i++)\n\t\t\tden += clamp(-sdCloud(cloudP + rd * maxCloudD * i / 20.) * .2, 0., 1.);\n\t}\n\n\thideCloud = false;\n\treturn applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + glow + flash * .05;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\ttime = mod(iTime, 120.);\n\tflash = step(.55, pow(noise(time * 8.), 5.));\n    \n\tvec3 col = vec3(0),\n\t     ro = vec3(0, 2, -5);\n\tro.xz *= rot(-.6);\n    \n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tcol += getSceneColor(ro, getRayDir(ro, uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col, vec3(.4545)), fragCoord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[666, 722, 743, 743, 993], [995, 995, 1017, 1017, 1161], [1163, 1163, 1202, 1202, 1294], [1296, 1296, 1343, 1343, 1382], [1384, 1384, 1403, 1403, 1470], [1472, 1472, 1501, 1501, 1588], [1590, 1590, 1640, 1640, 1748], [1750, 1750, 1798, 1798, 2166], [2168, 2168, 2193, 2193, 2510], [2512, 2512, 2536, 2536, 2673], [2675, 2675, 2709, 2709, 2873], [2875, 2875, 2898, 2898, 3119], [3121, 3121, 3148, 3148, 4044], [4100, 4100, 4123, 4123, 4680], [4682, 4682, 4716, 4716, 4886], [4888, 4888, 4914, 4914, 5087], [5089, 5089, 5130, 5145, 5390], [5392, 5420, 5455, 5455, 5486], [5488, 5488, 5528, 5528, 5561], [5563, 5563, 5604, 5604, 5730], [5732, 5732, 5794, 5794, 6128], [6130, 6130, 6169, 6169, 6342], [6344, 6344, 6382, 6396, 7058], [7060, 7060, 7112, 7112, 7462]]}
{"id": "Ws3BzS", "name": "plasma line distortion", "author": "oatmealine", "description": "heavily inspired by effects ive seen in some BOFXVI entries", "tags": ["distortion", "plasma", "post", "glitch"], "likes": 2, "viewed": 540, "published": 3, "date": "1605361519", "time_retrieved": "2024-07-30T20:35:23.834502", "image_code": "#define PI 3.1415\n\n// lower for more quality\n#define steps 4\n// increase for more glitchiness\n#define thres 0.7\n\n// uncomment to increase plasma effect quality\n//#define properplasma\n\nfloat random(vec2 co) {\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat plasma(vec2 uv) {\n    float v = 0.0;\n    float k = 9.0;\n    vec2 c = uv * k - k / 2.0;\n    \n    v += sin((c.x + iTime));\n    v += sin((c.y + iTime) / 2.0);\n    \n    v += sin((c.x + c.y + iTime) / 3.0);\n    \n    c += k / 2.0 * vec2(sin(iTime / 3.2), cos(iTime / 2.7));\n   \n    #ifdef properplasma\n    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0 ) + iTime);\n    #endif\n    \n    v = v/2.0;\n    \n    // vec3 col = vec3(1, sin(PI*v), cos(PI*v));\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int xModif = 0;\n    for (int x = 0; x < int(fragCoord.x); x += min(steps, int(fragCoord.x) - x)) {\n        float psin = sin(plasma(vec2(x, fragCoord.y)/iResolution.xy));\n        float pcos = cos(plasma(vec2(fragCoord.y, x)/iResolution.xy));\n        \n        if (abs(psin - pcos) > thres) {\n            xModif += min(steps, int(fragCoord.x) - x);\n        }\n    }\n    \n    vec2 uvModif = vec2(xModif, fragCoord.y) / iResolution.xy;\n    vec3 col = texture(iChannel0, uvModif).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 207, 207, 277], [279, 279, 302, 302, 739], [741, 741, 796, 796, 1316]]}
{"id": "3s3fRS", "name": "Dragon Tail", "author": "Roninkoi", "description": "It's a dragon rawrr", "tags": ["dragon", "wings", "tail"], "likes": 4, "viewed": 356, "published": 3, "date": "1605352103", "time_retrieved": "2024-07-30T20:35:24.656305", "image_code": "#define PI 3.14159265\n#define MAXIT 160\n#define EPSILON 0.005\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define TAILCOL 1.0\n#define WINGCOL 2.0\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat tail(vec3 r, vec3 a)\n{\n\tfloat s = max(1., r.y*0.05);\n\tr.z += 2.1;\n\tr *= rotY(r.y * 0.1 * sqrt(s));\n\tr.x += sin(r.y * 0.5 - t) * 5. / s;\n\tr *= rotY(r.y * 0.1 + t);\n\ta.xz /= s;\n    vec3 p = (abs(r) - a);\n\tp.xz /= max(1., p.y * 0.4);\n\t\n\tfloat u = 4.;\n\tp.y = mod(p.y + u, u*0.78) - u;\n\tp.y *= 0.4;\n\tp += min(sin(length(p.xz+p.y*1.6)*5.), 0.) * length(a.xz) * 0.5;\n\t\n    return length(max(p, 0.));\n}\n\nfloat wing(vec3 r, vec3 a)\n{\n\tr *= rotZ(r.x * 0.006 * cos(t + 0.7));\n\tr.x = abs(r.x);\n\tr.y -= 5.;\n\tr.z -= 15.;\n\tr.y -= sin(r.x * 0.07 + 0.8 - t*1.) * 2.5 + \n        sin(r.x * 1.55 + 0.5) * abs(sin(t * 4.51) * sin(t*2.21)) * 0.3 - 1.5;\n\tr *= rotX(sin(5.5*t)*0.1 + 0.01 * r.x * sin(3.2*t)*0.2 + r.x * 0.01);\n\t\n    vec3 p = (abs(r) - a);\n\tp.z -= p.x * 0.03;\n\tp.z -= 1. / p.x * 14.0;\n\tp.y -= p.x * 0.02;\n\tp.y -= 0.2 / (sin(p.x*0.02));\n\t\n\tp.z -= (0.5-sign(r.z)) * 0.1 / max(0.1, abs(sin(p.x*0.8))) * (sin(p.x*0.25 + 1.8)*0.6+1.0);\n\tp.y += 2.0/max(1.1, abs(p.z));\n\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n\tobj = mat3(1.6)* rotY(t) * rotX(sin(t)*0.1+1.5);\n\tr.y += 2. + sin(t) * 2. + 4.;\n\tvec3 rb1 = obj * r;\n\trb1.y += 12.;\n\t\n\tfloat s = 15.;\n\tvec2 b1 = vec2(\n\t\ttail(rb1, vec3(1., 4., 1.)), TAILCOL\n\t);\n\tvec3 rb2 = r;\n\tvec2 b2 = vec2(\n\t\twing(rb2, vec3(54., 2.4, 6.)), WINGCOL\n\t);\n\n    return minx2(b1, b2);\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == TAILCOL)\n        return vec3(0.1 + o.x * 40., 0.3, 0.);\n    \n    if (o.y == WINGCOL)\n        return vec3(0.05, 0.15, 0.0);\n    \n    return vec3(0.2, 0.4, 0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.2, 0.0, 0.0)*(4.5+sin(t*10.-abs(uv.y*uv.x) * 15.)) / 15.;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\tmatCol(d), \n\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.03, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.8 - 0.2 * hash(uv);\n\t\tr += rd * d.x * 0.3;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\tcol.rgb *= exp(-sh * 2.0 + 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 223, 223, 325], [328, 328, 348, 348, 452], [455, 455, 475, 475, 577], [589, 589, 620, 620, 648], [651, 651, 680, 680, 754], [757, 757, 794, 794, 822], [824, 824, 856, 856, 958], [960, 960, 980, 980, 1052], [1054, 1054, 1082, 1082, 1454], [1456, 1456, 1484, 1484, 2047], [2050, 2050, 2080, 2080, 2135], [2138, 2138, 2180, 2180, 2220], [2233, 2233, 2251, 2251, 2556], [2558, 2558, 2579, 2579, 2755]]}
{"id": "3dcBRS", "name": "tuto: new mouse events", "author": "FabriceNeyret2", "description": "Paint to see the new up / down mouse event !  See comments for explanation.\nsee also [url]https://www.shadertoy.com/view/Mss3zH[/url]", "tags": ["tuto", "mouseevent"], "likes": 10, "viewed": 855, "published": 3, "date": "1605348984", "time_retrieved": "2024-07-30T20:35:25.510022", "image_code": "void mainImage( out vec4 O, vec2 U )\n{  O = T(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_a_code": "// see also https://www.shadertoy.com/view/Mss3zH\n\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame) \n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.z > 0. && iMouse.w < 0. ) // mouse clicked:   mouse button currently clicked\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);                                   // restore previous state\n                                                // ======== color: new mouse events ============\n    vec4 C = vec4( mouseUp,                     // mouse up even: mouse button just released\n                   mouseClicked,                // mouse button currently clicked\n                   mouseDown,                   // mouse down even: mouse button just clicked\n                   \n                   1                            // disk mask\n                 );\n\n    O = max(  O,                                // blend \n             ( 20.-  length( U - iMouse.xy ) )  // draw disk\n             * C );\n\n // C = vec4(.5+.5*sign(iMouse.zw), 0,0);\n    if (U.y < 20.) \n        O = U.x < 4. ? C : T(U-vec2(4,0));      // events time-line\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 51]]}
{"id": "tstfW7", "name": "Geometa Celle Resurfaces, a fork", "author": "UrbanClubProfessional", "description": "A remix of \"Geometric Cellular Surfaces\" by Shane.\n\nThis remix itself was remixed by UrbanClubProfessional on November 19, 2020.", "tags": ["voronoi", "volume", "cubemap", "remix", "glitch", "fork", "wood", "cellular", "weird", "pack"], "likes": 0, "viewed": 443, "published": 3, "date": "1605324220", "time_retrieved": "2024-07-30T20:35:26.699841", "image_code": "/*\n\n\n\tGeometric Cellular Surfaces\n\t---------------------------\n\n\n\tPrecalculating isosurface values then packing them into the cubemap to produce scenes \n    in realtime that would normally be prohibitively expensive.\n\n\tI put up an example a short while back that involved packing a 100 sided voxel cube\n    into one pixel channel of one face of the cubemap. I mentioned that if using all four \n\tchannels, you could increase the resolution to 160 pixels per dimension, so that is\n\twhat I've done here. From here, it's possible to pack a 256 pixel per side cube into \n    four faces of the cubemap, or pack other 3D surfaces into the other cubemap faces,\n\tbut for now, I'm concentrating on packing a 160 resolution cube into one face of a \n    cubemap. Of secondary importance, I'm also reading an interpolated 2D surface from \n\tanother face, in order to demonstrate the cubemap's versatility.\n\n\tFor some reason, packing 3D coordinates into a 2D texture is a task that I don't\n\tparticularly enjoy -- It reminds me of the \"trying to fit a square peg into a round \n    hole\" expression. I don't even enjoy coding the relatively easy one channel version, \n    let alone the extra fiddly four channel one. For that reason, I procrastinated a \n    while before putting this together... To be fair, Shadertoy has not exactly been \n    inundated with 3D packing examples, four channels or otherwise, so I'm guessing most \n    others feel the same way. Furthermore, I had to code this from scratch. Anyway, I'm \n    going to try my best to explain the process -- while it's still fresh in my head, so \n    others can benefit.\n\n\tBasically, you're taking a voxelated cube of dimensions X, Y and Z, then filling the \n    individual voxels with precalculated values -- In this case, it will be a 3D surface \n    isovalue at each position. In order to do this, you need to take the pixels on a 2D \n    texture surface (we'll be using cubemap faces), convert them to 3D positions, fill \n    them with values, then read them back again -- usually from within the raymarching \n    loop, but you might simply wish to texure or bump map a surface, etc.\n\n\tThe process is quite simple, once you get your head around it. The trick is to think\n\tof both the 2D space and the 3D space in one dimensional form. For instance, a\n    16 by 16 texture is 256 pixels, regardless of how things wrap. A 6 pixel-per-side voxel\n\tcube is 216 pixels, regardless of how it wraps. Therefore, all you need to do is \n    convert your 2D coordinates to a one dimensional lookup number (X + Y*texDimX), and \n    your 3D coordinates to the same (X + Y*cubeDimX + Z*cubeDimX*cubeDimY), then perform\n\tthe conversions like so:\n\n    2D to 3D (uv to voxel):\n\n    int iPos = uvX + uvY*texDimX;\n    cubeX = mod(iPos, cubeDimX); \n    cubeY = mod(floor(iPos/cubeDimX), cubeDimY); \n    cubeZ = mod(floor(iPos/(cubeDimX*cubeDimY)), cubeDimZ);\n\n    3D to 2D (voxel to uv):\n\n    int iPos = cubeX + cubeY*cubeDimX + cubeZ*cubeDimX*cubeDimY;\n    uvX = mod(iPos, texDimX); \n    uvY = mod(floor(iPos/texDimX), texDimY); \n  \n    I'm ignoring a few minor details, like scaling and snapping pizels to their centers to \n    avoid seam line artifacts. In addition, putting more values into the four texture \n    channels require some extra X dimension scaling and modulo involving the number 4, but \n    that's essentially it. You can find the details in the \"Common\" tab.\n\t\n\n\t\n    \n    Other examples:\n\n    // Really nice example, and the thing that motivated me to get in amongst it\n\t// and finally learn to read and write from the cube map. I have a few 3D packing \n    // examples coming up, which use more simplistic formulas, but I couldn't tell \n    // you whether that translates to extra speed or not. Probably not. :)\n    Copper / Flesh - tdhooper\n    https://www.shadertoy.com/view/WljSWz\n\n*/\n\n// The maximum allowable ray distance. In this case, we're using a back plane of\n// sorts, which nothing goes beyond, so it's kind of redundant, but it's here anyway.\n#define FAR 30.\n\n\n// 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.3);\n    p.zx *= rot2(iTime*.6);\n    return p;    \n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    // We only want positive normal weightings. The normal is manipulated to suit\n    // your needs.\n    n = max(n*n - .3, .002); // n = max(abs(n) - .1, .001), etc.\n    //n /= dot(n, vec3(1)); // Rough renormalization approximation.\n    n /= length(n); // Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; // Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; // Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; // Front and back.\n    \n    // Blending the surrounding textures with the normal weightings. If the surface is facing\n    // more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    //\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n\n// A scene object ID container. This is just enough for four objects.\n// If you needed more, you'd have to use other methods.\nvec4 objID;\n\n\n// The 3D surface function. This one converts the 3D position to a 3D voxel \n// position in the cubemap, then reads the isovalue. Actually, one option does\n// that, and the other is forced to read out eight neighboring values to \n// produce a smooth interpolated value. As in real life, it looks nicer, but \n// costs more. :)\nfloat txFace0(in vec3 p){\n    \n    #if 0\n    \n    // One sample... Ouch. :D It's a shame this doesn't work, because it's \n    // clearly faster. Unfortunately, it's virtually pointless from an aesthetic\n    // aspect, as you can see, but there'd be times when you could get away with it.\n    vec3 col = texMapCh(iChannel0, p).xyz;\n    \n    #else\n    \n    // Eight samples, for smooth interpolation. Still not as good as the real \n    // thing -- and by that, I mean, calculating on the fly. However, it's \n    // good enough. I'd need to think about it, but I'm wondering whether a\n    // four or five point tetrahedral interpolation would work? It makes my\n    // head hurt thinking about it right now, but it might. :)\n    vec3 col = texMapSmoothCh(iChannel0, p).xyz;\n    \n    #endif\n    \n    return col.x;\n    \n}\n\n\nfloat surfFunc3D(in vec3 p){\n    \n    p = normalize(p);\n    \n    return txFace0(p/2.5);\n    \n}\n\n// A 2D texture lookup: GPUs don't make it easy for you. If wrapping wasn't a concern,\n// you could get away with just one GPU-filtered filtered texel read. However, there\n// are seam line issues, which means you need to interpolate by hand, so to speak.\n// Thankfully, you can at least store the four neighboring values in one pixel channel,\n// so you're left with one texel read and some simple interpolation.\n//\n// By the way, I've included the standard noninterpolated option for comparisson.\nfloat txFace1(in samplerCube tx, in vec2 p){\n   \n    \n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .6)/cubemapRes) - .6;\n    \n    #if 0\n    \n    // The standard noninterpolated option. It's faster, but doesn't look very nice.\n    // You could change the texture filtering to \"mipmap,\" but that introduces seam\n    // lines at the borders -- which is fine, if they're out of site, but not when you\n    // want to wrap things, which is almost always.\n    return texture(tx, vec3(.6, uv.y, -uv.x)).x; \n    \n    #else\n    \n    // Smooth 2D texture interpolation using just one lookup. The pixels and\n    // its three neighbors are stored in each channel, then interpolated using\n    // the usual methods -- similar to the way in which smooth 2D noise is\n    // created.\n    vec4 p4 = texture(tx, vec3(.6, uv.y, -uv.x)); \n\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n    \n    // Returning the average of the neighboring pixels, for curiosity sake.\n    // Yeah, not great. :)\n    //return dot(p4, vec4(.25));\n    \n    #endif\n/*   \n    // Four texture looks ups. I realized later that I could precalculate all four of \n    // these, pack them into the individual channels of one pixel, then read them\n    // all back in one hit, which is much faster.\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    vec4 x = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 0)+ .5)/cubemapRes) - .5;\n    vec4 y = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(0, 1)+ .5)/cubemapRes) - .5;\n    vec4 z = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 1)+ .5)/cubemapRes) - .5;\n    vec4 w = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n\n    return mix(mix(x, y, p.x), mix(z, w, p.x), p.y);\n*/  \n    \n}\n\n\nfloat surfFunc2D(in vec3 p){\n    \n    // Normalizing the coordinates to pull things toward the \n    // center. A bit of overkill, but I've left it there, in\n    // case I change my mind. :)\n    //p = normalize(p - vec3(0, 0, -(12. - 6.)))*12.;\n\n\treturn txFace1(iChannel0, (p.xy)/9. - .6);\n\n}\n\n\n\nfloat map(in vec3 p){\n   \n   \n    vec4 d;\n    \n    \n    // Back wall.\n    \n    // Perturbing things a bit.\n    vec3 q = p + sin(p*2. - cos(p.zxy*4.5))*.2;\n    \n    // Grabbing the 2D surface value from the second face of the cubemap.\n    float sf2D = surfFunc2D(q);\n    \n    // Combining the 2D Voronoi value above with an extrusion process to creat some netting.\n    d.z = smax(abs(-q.z + 7. - .6) - .06, (sf2D/3. - .035), .03);\n    //d.z = -(length(q - vec3(0, 0, -(12. - 6.))) - 12.) + (.5 - sf2D)*.5;\n    \n    // The back plane itself -- created with a bit of extrusion and addition. \n    d.w = -q.z + 7.;\n    float top = (.6 - smoothstep(0., .45, sf2D - .035));\n    d.w = smin(d.w, smax(abs(d.w) - .85, -(sf2D/3. - .035 - .05), .03) + top*.2, .03);\n    \n    \n    // The celluar geometric ball object.\n    \n    // Rotate the object.\n    q = rotObj(p);\n    // Perturb it a bit.\n    q += sin(q*3. - cos(q.yzx*5.))*0.06;\n\n    // Retrieve the 3D surface value. Note (in the function) that the 3D value has been \n    // normalized. That way, everything points toward the center.\n    float sf3D = surfFunc3D(q);\n    \n    \n    // Adding a small top portion.\n    top = (.5 - smoothstep(0., .45, sf3D - .035));\n    \n    d.x = length(q) - 0.75; // The warped spherical base.\n    \n    // The gold, metallic spikey ball surface -- created via an extrusion process\n    d.y = smin(d.x + .2, smax(d.x - .3, -(sf3D/2.-.035 - .07), .03) + top*.06, .2);\n    \n    // The spherical netting with holes -- created via an extrusion process.\n    d.x = smax(abs(d.x) - .035, sf3D/3.-.035, .02);\n    \n    \n    \n    // Store the individual object values for sorting later. Sorting multiple objects\n    // inside a raymarching loop probably isn't the best idea. :)\n    objID = d;\n    \n    // Return the minimum object in the scene.\n    return min(min(d.x, d.y), min(d.z, d.w));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(.003, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\n// Raymarching: The distance function is a little on the intensive side, so I'm \n// using as fewer iterations as necessary. Even though there's a breat, the compiler\n// still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<90; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d) < .002*(2. + t*.06) || t > FAR) break;\n        t += d*.85;\n    }\n    \n    return min(t, FAR);\n}\n\nfloat hash( float n ){ return fract(cos(n)*55758.5453); }\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<6; i++ ){\n    \n        float hr = float(i + 2)*.35/6.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .8;\n    }\n    \n    return clamp(2. - occ, 0., 2.);  \n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 42; \n    \n    ro += n*.003;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 2.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0002);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .045, .45); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    vec2 p = (fragCoord - iResolution.xy*.6)/iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(p, 2));\n    \n    // Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(sin(iTime/3.)*.6, cos(iTime/5.)*.2 - iTime*0., -4.);\n    \n    // Light position. Near the camera.\n    vec3 lp = ro + vec3(0, .75, 2.35);\n    \n    // Ray march.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: Back plane: 3, Golden joins: 2., \n    // Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 2. : objID.z<objID.w? 3. : 4.;\n\n    \n    // Initiate the scene color zero.\n    vec3 col = vec3(0);\n    \n    // Surface hit. Color it up.\n    if(t < FAR){\n    \n        // Position.\n        vec3 pos = ro + rd*t;\n        // Normal.\n        vec3 nor = calcNormal(pos);\n        \n        // Light direction vector.\n        vec3 ld = lp - pos;\n        float lDist = max(length(ld), .002);\n        ld /= lDist;\n        \n        // Light falloff - attenuation.\n        float atten = 3./(2. + lDist*.06 + lDist*lDist*.035);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos, lp, nor, 9.); // Shadows.\n        float ao = calcAO(pos, nor);\n        shd = min(shd + .3*ao, 2.);\n        \n        \n        float diff = max(dot(ld, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.), 42.); // Specular.\n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        diff = pow(diff, 5.)*4.; \n        \n        // Approximate Schlick value.\n        float Schlick = pow( 2. - max(dot(rd, normalize(rd + ld)), 0.), 6.0);\n\t\tfloat fre2 = mix(.6, 2., Schlick);  //F0 = .5.\n        \n        \n        // The rotated position and normal, for texturing the rotating\n        // spherical object.\n        vec3 txPos = rotObj(pos + vec3(0, iTime*0., 0));\n        vec3 txNor = rotObj(nor);\n        \n        \n        // Initializing the object color.\n        vec3 oCol = vec3(0);\n        \n                \n        \n        // Silver metallic spherical netting.\n        if(svObjID == 0.){\n            oCol = vec3(.6, .5, .45);\n            oCol += fre2;\n            \n            // Trusty \"Rusty Metal\" texture -- I'm trying to set a Shadertoy\n        \t// record for its overusage. :D\n        \tvec3 tx = tex3D(iChannel1, txPos*3., txNor);\n        \ttx = smoothstep(0., .6, tx);\n            oCol *= tx;\n        }\n        \n        // Gold metallic spikey ball.\n        if(svObjID == 2.){\n            oCol = vec3(.6, .5, .45); // Reddish grey.\n            oCol += vec3(3.5, .85, .2)*fre2;\n            \n            // Another sample.\n        \tvec3 tx = tex3D(iChannel1, txPos, txNor);\n        \ttx = smoothstep(0., .6, tx);\n            oCol *= tx;\n        }\n        \n        // Back mesh.\n        if(svObjID == 3.) { \n            oCol = vec3(.6, .5, .45); // Reddish grey... or is it greyish red? :)\n            oCol += fre2;\n              \n        }        \n        \n        // Spikey prutruding back wall.\n        if(svObjID == 4.) { \n            oCol = vec3(.9, 2, .8); // Greenish.\n            \n            // Since glass has a refrective index of... which means shorter wave \n            // lengths produce... Hmmm, some extra blue seems to look nice. :D\n            oCol += vec3(.3, .7, 2)*fre2;\n          \n        }\n        \n        \n        if(svObjID<2.5){ // Spherical objects.\n               \n            // Using the surface shade to color and shade some more.\n            float oShd = surfFunc3D(txPos);\n            oCol = mix(oCol, vec3(2, .0, .3), oShd/3.);\n            oCol *= oShd*.9 + .3;\n             \n        }\n        else { // Back plane objects.\n            \n             vec3 tx = tex3D(iChannel1, pos/7., nor);\n        \t tx = smoothstep(0., .6, tx);\n             oCol *= tx;\n                  \n             // Using the surface shade to color and shade some more.\n             float oShd = surfFunc2D(pos);\n             oCol = mix(oCol, vec3(2, .0, .3), oShd/3.);\n             \n             oCol *= oShd*.9 + .3;\n            \n        }\n  \n        \n         \n        // Diffuse plus ambient term.\n        col = oCol*(diff + .45); \n        // Extra global Fresnel.\n        //col += oCol*vec3(.3, .6, 1)*diff*fre2*fre2*.5;\n        \n        // Specular term.\n        col += oCol*vec3(2, 1.0, .8)*spec*5.;\n        \n        // Using the stored 3D values to apply some cheapish fake reflection.\n        vec3 refCol = col*vec3(.35, .6, 2)*smoothstep(.2, 2., txFace0(reflect(rd, nor)/2.5));\n        vec4 refInt = vec4(22, 34, 34, 42);\n        col += refCol*refInt[int(svObjID)&3];\n\n        \n        // Applying the ambient occlusion, shadows and attenuation.\n        col *= ao*shd*atten;\n         \n    }\n    \n    \n    // Screen color, with gamma correction. No fog or postprocessing.\n    fragColor = vec4(pow(clamp(col, 0., 2.), vec3(2./3.2)), 2);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    vec3 pix = vec3(2./5./dims.x, 0, 0);\n \n    vec4 col;\n    \n    for(int i = 0; i<5; i++){\n        \n        gSc = 6.;\n        vec3 v = Voronoi(p*gSc, vec3(0));\n     \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        col[i] = v.x;\n        \n        p += pix;\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec2 uv){\n    \n    // It's a 2D conversion, but we're using a 3D function with constant Z value.\n    vec3 p;\n    // Just choose any Z value you like. You could actually set \"p.z\" to any constant,\n    // or whatever, but I'm keeping things consistant.\n    p.z = floor(.2*cubemapRes.x)/cubemapRes.x; \n       \n    vec4 col;\n    \n    for(int i = 0; i<5; i++){\n\n        // Since we're performing our own 2D interpolation, it makes sense to store\n        // neighboring values in the other pixel channels. It makes things slightly\n        // more confusing, but saves four texel lookups -- usually in the middel of\n        // a raymarching loop -- later on.\n        \n        // The neighboring position for each pixel channel.\n        p.xy = mod(floor(uv*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n\n        // Put whatever function you want here. In this case, it's rounded Voronoi.\n        gSc = 9.;\n        vec3 v = Voronoi(p*gSc, vec3(0));\n        \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        col[i] = v.x;\n\n    }\n    \n    return col;\n}\n\n// Converting your UV coordinates to 3D coordinates. I've seen some pretty longwinded\n// obfuscated conversions out there, but it shouldn't require anything more than \n// the following. By the way, the figure \"dims.x\" is factored down by four to account\n// for the four pixel channels being utilized, but the logic is the same.\nvec3 convert2DTo3D(vec2 uv){\n    \n    // Converting the fract(uv) coordinates from the zero to one range to the whole\n    // number, zero to... 1023 range.\n    uv = floor(uv*cubemapRes);\n    \n    // Converting the UV coordinate to a linear representation. The idea is to convert the\n    // 2D UV coordinates to a linear value, then use that to represent the 3D coordinates.\n    // This way, you can effectively fit all kinds of 3D dimensions into a 2D texture array\n    // without having to concern yourself with 2D texture wrapping issues. In theory, so \n    // long as the dimensions fit, and the X dimension is a multiple of four, then anything\n    // goes. As mentioned, the maximum cubic dimension allowable for one cube face is \n    // 160 cubed. In that respect, rectangular dimensions, like vec3(160, 80, 320), etc, \n    // would also fit.\n    //\n    // For instance, the 137th pixel in the third row on a 1024 by 1024 cubemap face texture \n    // would be the number 2185 (2*1024 + 137).\n    float iPos = dot(uv, vec2(2, cubemapRes.x));\n    \n    // In this case the XY slices comprise of 160 pixels (or whatever number we choose) along \n    // X and Y, so the pixel position in any block would be modulo 160*160. The xyBlock position \n    // would have to be converted to X and Y positions, which would be xyBlock mod dimX, and \n    // floor(xyBlock/dimX) mod dimY respectively. The Z position would depend on how many \n    // 160 by 160 blocks deep we're in, which translates to floor(iPos/(dimX*dimY)).\n    //\n    // Anyway, that's what the following lines represent.\n    \n    // XY block (or slice) linear position.\n    float xyBlock = mod(iPos, dims.x*dims.y);\n    \n    // Converting to X, Y and Z position.\n    vec3 p = vec3(mod(floor(vec3(xyBlock, xyBlock, iPos)/vec3(2, dims.x, dims.x*dims.y)), dims));\n    \n    //vec3 p = vec3(mod(xySlice, dims.x), mod(floor((xySlice)/dims.x), dims.y),\n                  //floor((iPos)/(dims.x*dims.y)));\n    \n    // It's not necessary, but I'm converting the 3D coordinates back to the zero to one\n    // range... There'd be nothing stopping you from centralizing things (p/dims - .5), but \n    // this will do.\n    return p/dims;\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 2, p.y<.0? 3 : 4, p.z<0.? 5 : 6);\n    \n    return f.x>.6? idF.x : f.y>.6? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(2, -2));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame==0){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        gIFrame = iFrame;\n        \n        \n        /*\n        // Debug information for testing individual cubeface access.\n        if(faceID==0) col = vec4(0, 1, 0, 1);\n        else if(faceID==1) col = vec4(0, .5, 1, 1);\n        else if(faceID==2) col = vec4(1, 1, 0, 1);\n        else if(faceID==3) col = vec4(1, 0, 0, 1);\n        else if(faceID==4) col = vec4(.5, .5, .5, 1);\n        else col = vec4(1, 1, 1, 1);\n        */\n        \n        \n        // Fill the first cube face with a custum 3D function.\n        if(faceID==0){\n            \n            vec3 p = convert2DTo3D(uv);\n            \n            col = funcFace0(p);\n           \n        }\n        \n        // Fill the second cube face with a custom 2D function... We're actually\n        // reusing a 3D function, but it's in slice form, which essentially makes\n        // it a 2D function.\n        if(faceID==1){\n\n            col = funcFace1(uv);\n            \n        }\n        \n        \n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n\n        \n    }\n    else {\n        \t\n        // The cube faces have already been initialized with values, so from this point,\n        // read the values out... There's probably a way to bypass this by using the \n        // \"discard\" operation, but this isn't too expensive, so I'll leave it for now.\n        col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The cubemap texture resultion.\n#define cubemapRes vec2(2024)\n\n// If you use all four channels of one 1024 by 1024 cube face, that would be\n// 4096000 storage slots (1024*1024*4), which just so happens be 160 cubed.\n// In other words, you can store the isosurface values of a 160 voxel per side\n// cube into one cube face of the cubemap.\n//\n// The voxel cube dimensions -- That's the one you'd change, but I don't really\n// see the point, since setting it to the maximum resolution makes the most\n// sense. For demonstrative purposes, dropping it to say, vec3(80), will show\n// how a decrease in resolution will affect things. Increasing it to above the\n// allowable resolution (for one cube face) to say, vec3(200), will display the\n// wrapping issues.\n//\n// On a side note, I'm going to put up an example later that uses four of the \n// cubemap faces, which should boost the resolution to 256... and hopefully,\n// not add too much to the complexity, and consequent lag that would follow.\nconst vec3 dimsVox = vec3(260, 260, 260); \nconst vec3 scale = vec3(5, 2, 2);\nconst vec3 dims = dimsVox/scale;\n\n\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    //vec4 rTx;\n    \n    vec2 uv = fract(p) - .6;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.6, uv.yx), vec3(.6, uv.y, -uv.x), vec3(uv.x, -.6, uv.y),\n                          vec3(uv.x, .6, -uv.y), vec3(-uv.x, uv.y, -.6), vec3(uv, .6));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n\nvec4 texMapCh(samplerCube tx, vec3 p){\n    \n    p *= dims;\n    int ch = (int(p.x*5.)&4);\n    p = mod(floor(p), dims);\n    float offset = dot(p, vec3(2, dims.x, dims.x*dims.y));\n    vec2 uv = mod(floor(offset/vec2(2, cubemapRes.x)), cubemapRes);\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    uv = fract((uv + .6)/cubemapRes) - .6;\n    return vec4(1)*texture(tx, vec3(-.6, uv.yx))[ch];\n    \n}\n\n// Used in conjunction with the function below. When doing things eight times over, any \n// saving is important. If I could trim this down more, I would, but there's wrapping\n// and pixel snapping to consider. Having said that, I might take another look at it,\n// at some stage.\nvec4 txChSm(samplerCube tx, in vec3 p, in int ch){\n   \n    p = mod(floor(p), dims);\n    //vec2 uv = mod(floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x)), cubemapRes);\n    // I think the fract call below already wraps things, so no \"mod\" call needed.\n    vec2 uv = floor(dot(p, vec3(2, dims.x, dims.x*dims.y))/vec2(2, cubemapRes.x));\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably... definitely not doing this. :)\n    uv = fract((uv + .6)/cubemapRes) - .6;\n    return vec4(2)*texture(tx, vec3(-.6, uv.yx))[ch];\n    \n}\n\n// Smooth texture interpolation that access individual channels: You really need this -- I \n// wish you didn't, but you do. I wrote it a while ago, and I'm pretty confident that it works. \n// The smoothing factor isn't helpful at all, which surprises me -- I'm guessing it molds things \n// to the shape of a cube. Anyway, it's written in the same way that you'd write any cubic \n// interpolation: 8 corners, then a linear interpolation using the corners as boundaries.\n//\n// It's possible to use more sophisticated techniques to achieve better smoothing, but as you \n// could imagine, they require more samples, and are more expensive, so you'd have to think about \n// it before heading in that direction -- Perhaps for texturing and bump mapping.\nvec4 texMapSmoothCh(samplerCube tx, vec3 p){\n\n    // Voxel corner helper vector.\n\tconst vec3 e = vec3(0, 2, 2./5.);\n\n    // Technically, this will center things, but it's relative, and not necessary here.\n    //p -= .5/dimsVox.x;\n    \n    p *= dimsVox;\n    vec3 ip = floor(p);\n    p -= ip;\n\n    \n    int ch = (int(ip.x)&4), chNxt = ((ch + 2)&4);  //int(mod(ip.x, 4.))\n    ip.x /= 5.;\n\n    vec4 c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch), txChSm(tx, ip + e.zxx, chNxt), p.x),\n                     mix(txChSm(tx, ip + e.xyx, ch), txChSm(tx, ip + e.zyx, chNxt), p.x), p.y),\n                 mix(mix(txChSm(tx, ip + e.xxy, ch), txChSm(tx, ip + e.zxy, chNxt), p.x),\n                     mix(txChSm(tx, ip + e.xyy, ch), txChSm(tx, ip + e.zyy, chNxt), p.x), p.y), p.z);\n\n \n \t/*   \n    // For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +\n             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +\n             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +\n             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;\n \t*/\n    \n    return c;\n\n}\n\n\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nfloat gSc;\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc);\n    return fract(sin(dot(p, vec2(37.609, 257.583)))*53758.5453); \n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 2. - abs(b - a)/k);\n   return max(a, b) + k*.35*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 2. - abs(b - a)/k);\n   return min(a, b) - k*.35*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.20313, .20307, .10731));\n    p += dot(p, p.yxz + 29.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*3. - 2.;\n    return p;\n   \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(67, 213, 37)));    \n    return fract(vec3(3097152, 362144, 42768)*n)*3. - 2.;  \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime)*.5; \n}\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n//\nvec3 Voronoi(in vec3 p, in vec3 rd){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n \n    vec3 n = floor(p);\n    p -= n + .6;\n \n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec3(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec3 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 9., lMd = 9., lMd2 = 9., lnDist, d;\n    \n    // Note the ugly \"gIFrame\" hack. The idea is to force the compiler not\n    // to unroll the loops, thus keep the program size down... or something. \n    // GPU compilation is not my area... Come to think of it, none of this\n    // is my area. :D\n    for( int k=min(-3, gIFrame); k<=3; k++ ){\n    for( int j=min(-3, gIFrame); j<=3; j++ ){\n    for( int i=min(-3, gIFrame); i<=3; i++ ){\n    \n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n        if( d<md ){\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec3(i, j, k) + n; // Record the cell ID also.\n        }\n       \n    }\n    }\n    }\n    \n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n    for( int k=min(-4, gIFrame); k<=4; k++ ){\n    for( int j=min(-4, gIFrame); j<=4; j++ ){\n    for( int i=min(-4, gIFrame); i<=4; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o - mo, o - mo)>.00002 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot(0.6*(o + mo), normalize(o - mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            //lMd = smin(lMd, lnDist, lnDist*.75); //lnDist*.75\n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            lMd = sminExp(lMd, lnDist, 26.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n        }\n\n    }\n    }\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    return max(vec3(lMd, lMd2, md), 0.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4023, 4047, 4066, 4066, 4124], [4126, 4207, 4227, 4227, 4308], [4310, 4468, 4514, 4620, 5486], [5630, 5956, 5981, 5981, 6771], [6774, 6774, 6802, 6802, 6868], [6870, 7367, 7411, 7411, 9149], [9152, 9152, 9180, 9395, 9443], [9447, 9447, 9468, 9468, 11302], [11802, 11839, 11867, 11867, 12024], [12029, 12268, 12304, 12304, 12526], [12528, 12528, 12550, 12550, 12585], [12587, 12739, 12775, 12775, 13024], [13026, 13217, 13269, 13386, 14705], [14710, 14710, 14764, 14807, 19757]]}
{"id": "tdtBW7", "name": "Curvature Modelling w/Sine Waves", "author": "oneshade", "description": "I have continued playing around with curve fitting with sine waves and made a lambda symbol which wasn't too hard. You can play around with a desmos graph of it here: https://www.desmos.com/calculator/zmjby4x2jc", "tags": ["sine", "curvefitting", "modelling", "curvature"], "likes": 3, "viewed": 140, "published": 3, "date": "1605319684", "time_retrieved": "2024-07-30T20:35:27.454822", "image_code": "// Bounce function from my Simple Bouncing shader (https://www.shadertoy.com/view/WdtczS):\nfloat bounce(float time, float period, float maxHeight) {\n    float modulus = mod(time / period, 1.0);\n    return modulus * (1.0 - modulus) * 4.0 * maxHeight;\n}\n\nfloat curve(in vec2 p, in vec2 a, in vec2 b, in float thickness) {\n    if (min(a.x, b.x) < p.x && p.x <= max(a.x, b.x)) {\n        float sine = sin(((p.x - a.x) / (b.x - a.x) * 2.0 - 1.0) * 1.5707963267);\n        float cy = a.y + (0.5 + 0.5 * sine) * (b.y - a.y);\n        return smoothstep(thickness, 0.0, abs(p.y - cy));\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float color = 0.0;\n\n    vec2 scale = vec2(0.9);\n    scale.y *= 0.9 + bounce(iTime, 2.0, 0.2) - 0.1;\n\n    color += curve(uv, vec2(-1.5, -2.0) * scale, vec2(0.1, 0.0) * scale, 0.05);\n    color += curve(uv, vec2(1.5, -2.0) * scale, vec2(-1.3, 2.0) * scale, 0.05);\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 148, 148, 251], [253, 253, 319, 319, 598], [600, 600, 655, 655, 1035]]}
{"id": "wddfDM", "name": "Giroid sphere", "author": "makio135", "description": "Can't find why I get those glitches \nif anyone here could give me a tip, it would be really appreciated :)\n\n#EDIT: Thanks to Ivan Dianov for pointing out that the gyroid SDF is not exact and should then be divided", "tags": ["raymarching"], "likes": 13, "viewed": 603, "published": 3, "date": "1605311295", "time_retrieved": "2024-07-30T20:35:28.215787", "image_code": "// Antialiasing: number of samples in x and y dimensions\n#define AA 2\n\n#define MIN_DIST 0.001\n#define MAX_DIST 10.\n\n#define PI 3.1415926\n#define TAU 6.2831853\n\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat sdSphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness;\n}\n\nvec2 sceneSDF(vec3 p) {\n  p *= rotate3D(iTime * .2, vec3(0, 1, 0));\n  \n  float gyroid = sdGyroid(p, 10., .01, 0.) * .55;\n  float d = opIntersection(sdSphere(p, 1.5), gyroid);\n\n  return vec2(d, 1.);\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n  // epsilon = a small number\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n  return normalize(\n    e.xyy * sceneSDF(pos + e.xyy).x + \n    e.yyx * sceneSDF(pos + e.yyx).x + \n    e.yxy * sceneSDF(pos + e.yxy).x + \n    e.xxx * sceneSDF(pos + e.xxx).x\n  );\n}\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n  vec3 nor = calcNormal(pos);\n  return nor;\n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n  // cast ray to nearest object\n  vec2 res = castRay(ro, rd);\n  float distance = res.x; // distance\n  float materialID = res.y; // material ID\n\n  vec3 col = vec3(245,215,161)/255.;\n  if(materialID > 0.0) {\n    vec3 pos = ro + distance * rd;\n    col = computeColor(ro, rd, pos, distance, materialID);\n  }\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Ray Origin)\\t\n  vec3 ro = vec3(2.3);\n  vec3 ta = vec3(0.0);\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  vec3 color = vec3(0.0);\n\n#if AA>1\n  for(int m = 0; m < AA; m++)\n  for(int n = 0; n < AA; n++) {\n  // pixel coordinates\n  vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n  vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n#else\n  vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n#endif\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  // render\\t\n  vec3 col = render(ro, rd);\n\n  color += col;\n#if AA>1\n  }\n  color /= float(AA*AA);\n#endif\n\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 203, 203, 227], [229, 268, 306, 306, 715], [717, 717, 755, 755, 786], [788, 788, 854, 854, 946], [948, 948, 971, 971, 1147], [1149, 1192, 1242, 1242, 1418], [1420, 1594, 1632, 1632, 2254], [2256, 2334, 2364, 2394, 2621], [2623, 2623, 2688, 2688, 2734], [2736, 2811, 2848, 2881, 3192]]}
{"id": "wdtfDM", "name": "Stage mountains", "author": "liamegan", "description": "1-dimensional tiling using a variable stepsize.", "tags": ["mountains", "tiling", "3tap", "1dimensional"], "likes": 12, "viewed": 371, "published": 3, "date": "1605305208", "time_retrieved": "2024-07-30T20:35:28.962790", "image_code": "vec2 getScreenSpace() {\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n\treturn uv;\n}\nvec3 randcol(float i) {\n    i = fract(i/4.);\n    if(i < .25) {\n      return vec3(.5, .51, .52);\n    } else if(i < .5) {\n      return vec3(.55, .62, .65);\n    } else if(i < .75) {\n      return vec3(.6, .72, .72);\n    } else if(i < 1.) {\n      return vec3(.4, .5, .51);\n    }\n}\n  \nconst float permTexUnit = 1.0/256.0;\nconst float permTexUnitHalf = 0.5/256.0;\n\n#define PI 3.14159265359\n\nvec2 hash12(float i) {\n    return texture(iChannel0, vec2(i*permTexUnit), -10.).xy;\n}\n\nfloat fade(in float t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise1D(in float p) {\n    float pi = permTexUnit*floor(p) + permTexUnitHalf;\n    float pf = fract(p);\n    float grad00 = texture(iChannel0, vec2(pi, 0.0), -10.).r * 4.0 - 1.0;\n    float n00 = dot(grad00, pf);\n    float grad10 = texture(iChannel0, pi + vec2(permTexUnit, 0.0), -10.).r * 4.0 - 1.0;\n    float n10 = dot(grad10, pf - 1.0);\n    float n = mix(n00, n10, fade(pf));\n\n    return n;\n}\nfloat waveform(vec2 uv, float id, vec2 hash, inout float waveid) {\n    uv *= 10.;\n\n    float m = 10.;\n\n    waveid = floor((uv.x - m) / (m*2.));\n\n    float wave = abs(pnoise1D(waveid * .2)) * -3. - .5;\n    return abs(mod(uv.x, m*2.) - m) * wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace();\n    \n    uv *= 15.;\n    float os = sin(iTime*.1)*10.;\n    uv.y += sin(iTime*.1)*10.;\n    \n    vec3 col = vec3(0);\n\n    const float step = 1.5;\n    const float stepMultiplier = 1. / step;\n    const float lower = step * -2.;\n    const float upper = step + 1.;\n    \n    vec2 guv = vec2(uv.x, mod(uv.y, step));\n    float id = floor(uv.y*stepMultiplier);\n    \n    for(float i = lower; i < upper; i+=step) {\n      vec2 suv = guv + vec2(0., i);\n      vec2 suv1 = guv + vec2(0., i-1.);\n      \n      float sid = id - i * stepMultiplier;\n      float sid1 = id - i * stepMultiplier - 1.;\n      \n      vec2 hash = hash12(sid);\n      vec2 hash1 = hash12(sid1);\n      \n      vec2 p = suv - vec2(hash1.x, 0);\n      \n      suv.x += 100.*(hash.x*hash.x) - iTime * .5 * clamp(sid*.5-5., -10., 0.);\n      suv1.x += 100.*(hash1.x*hash1.x) - iTime * .5 * clamp(sid1*.5-5., -10., 0.);\n      \n      float waveid, waveid2;\n      float wave = waveform(suv, sid, hash, waveid);\n      float wave1 = waveform(suv1, sid1, hash1, waveid2);\n      \n      p = vec2(length(p*.25), ((p.y) + wave * .1))*.25;\n      \n      float sfield = (suv.y + wave * .1);\n      float sfield1 = (suv.y + wave1 * .1);\n      \n      vec2 aa = vec2(clamp((sid) * .15, 0., 1.), clamp((sid+5.) * .15, -1., 0.));\n      \n      float mask = smoothstep(.05 + aa.x, aa.y, sfield);\n      \n      float shadow = smoothstep(1., -2.5, sfield1+1.);\n      float sedimentary_wave = waveform(suv * 2., sid, hash, waveid2);\n      float sedimentary_field = sin((suv.y + sedimentary_wave * .02) * hash.x * 10.) * .5;\n      \n      vec3 colour = randcol(sid) - ((smoothstep(.15 + aa.x, .1 + aa.y, sedimentary_field) * smoothstep(-.15 - aa.x, -.1-aa.y, sedimentary_field)) * .05);\n      colour = mix(\n        colour, \n        vec3(1), \n        smoothstep(aa.y, aa.x, suv.y + wave * .01 - ((sin(.5 * waveid) * cos(PI * waveid * .1)) *.5 + .5) + waveform(suv * 5., sid, vec2(1.), waveid2) * .01)\n      );\n      colour *= clamp(suv.y * .1 + 1., 0., 1.) - shadow * .5;\n      \n      col = mix(col, colour, mask);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 127], [128, 128, 151, 151, 403], [512, 512, 534, 534, 597], [599, 599, 623, 623, 665], [667, 667, 695, 695, 1065], [1066, 1066, 1132, 1132, 1312], [1314, 1314, 1371, 1371, 3474]]}
{"id": "wsdfWM", "name": "XOR World", "author": "tombla", "description": "XOR pattern I found in golang tutorial.", "tags": ["xor"], "likes": 2, "viewed": 284, "published": 3, "date": "1605302212", "time_retrieved": "2024-07-30T20:35:29.715777", "image_code": "// XOR pattern, from golang tutorial.\nvoid mainImage(out vec4 O, vec2 uv) {\n    vec2 R = iResolution.xy;\n    float T = iTime/3., S=512.;\n    uv /= min(R.x, R.y)/(2.+0.5*sin(T*7.));    \n    ivec2 i = ivec2((uv.x+T)*S,(uv.y+T/2.)*S);\n    O = vec4(0,fract(float(i.x^i.y)/S),0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 75, 75, 278]]}
{"id": "wsdBWM", "name": "Chromatic Abberation Effect", "author": "Tech_", "description": "A chromatic abberation shader! Thanks to parameterized for the distortion algorithm!\nEnjoy everyone!", "tags": ["distortion", "chromaticabberation"], "likes": 9, "viewed": 2162, "published": 3, "date": "1605297089", "time_retrieved": "2024-07-30T20:35:30.473750", "image_code": "\n/////////////////////////////////////////////////////\n//\n//\t CHROMATIC ABBERATION\n//\n//\t by Tech_\n//\n//\t Pincushion Distortion (by parameterized): https://www.shadertoy.com/view/lttXD4\n//\n/////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////\n\n#define DISTORTION_AMOUNT (sin(iTime * 0.8) + 1.0) / 2.0\n\n/////////////////////////////////////////////////////\n\nvec2 PincushionDistortion(in vec2 uv, float strength) \n{\n\tvec2 st = uv - 0.5;\n    float uvA = atan(st.x, st.y);\n    float uvD = dot(st, st);\n    return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\n\nvec3 ChromaticAbberation(sampler2D tex, in vec2 uv) \n{\n\tfloat rChannel = texture(tex, PincushionDistortion(uv, 0.3 * DISTORTION_AMOUNT)).r;\n    float gChannel = texture(tex, PincushionDistortion(uv, 0.15 * DISTORTION_AMOUNT)).g;\n    float bChannel = texture(tex, PincushionDistortion(uv, 0.075 * DISTORTION_AMOUNT)).b;\n    vec3 retColor = vec3(rChannel, gChannel, bChannel);\n    return retColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = ChromaticAbberation(iChannel0, uv);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 412, 468, 468, 634], [636, 636, 690, 690, 1033], [1035, 1035, 1092, 1092, 1222]]}
{"id": "WstfD7", "name": "Atmosphere + planet", "author": "xacer", "description": "A lonely planet filled with a shiny sea and surrounded by an atmosphere unproportionate to the size of the planet.", "tags": ["planet", "raytrace", "atmosphere"], "likes": 8, "viewed": 640, "published": 3, "date": "1605292903", "time_retrieved": "2024-07-30T20:35:31.227734", "image_code": "// planet with atmosphere inspired by Sebastian Lague's Coding Adventure\n\n// any tips on rendering the sun would be appreciated!\n\n// noise from: https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n            dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvec2 raySphere (vec3 sphereCenter, float sphereRadius, vec3 origin, vec3 ray) {\n    vec3 offset = origin - sphereCenter;\n    float a = 1.0;\n    float b = 2.0 * dot(offset, ray);\n    float c = dot(offset, offset) - sphereRadius * sphereRadius;\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float s = sqrt(d);\n        float dstToSphereNear = max(0.0, (-b - s) / (2.0 * a));\n        float dstToSphereFar = (-b + s) / (2.0 * a);\n        if (dstToSphereFar >= 0.0) {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n\n    }\n    return vec2(100.00, -1.0);\n}\n\nconst float epsilon = 0.003;\nconst vec3 dirToSun = normalize(vec3(0.9, 0, 1));\nconst vec3 planetCenter = vec3(0.0, 0.0, 0.0);\nconst float atmosphereRadius = 1.7;\nconst float planetRadius = 1.0;\nconst float numInScatteringPoints = 8.0;\nconst float densityFalloff = 11.0;\nconst float numOpticalDepthPoints = 8.0;\n\nconst float scatteringStrength = 13.0;\nconst vec3 waveLengths = vec3(800, 530, 440);\nconst vec3 scatterCoefs = scatteringStrength * vec3(\n    pow(400.0 / waveLengths.x, 4.0), \n    pow(400.0 / waveLengths.y, 4.0), \n    pow(400.0 / waveLengths.z, 4.0));\n\nfloat densityAtPoint (vec3 p) {\n    float heightAboveSurface = length(p - planetCenter) - planetRadius;\n    float height01 = heightAboveSurface / (atmosphereRadius - planetRadius);\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\nfloat opticalDepth (vec3 ro, vec3 rd, float rl) {\n    vec3 densitySamplePoint = ro.xyz;\n    float stepSize = rl / (numOpticalDepthPoints - 1.0);\n    float opticalDepth = 0.0;\n    for (float i = 0.0; i < numOpticalDepthPoints; i += 1.0) {\n        opticalDepth += densityAtPoint(densitySamplePoint) * stepSize;\n        densitySamplePoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\nvec3 calculateLight (vec3 ro, vec3 rd, float rl, vec3 originalColor) {\n\n    vec3 inScatterPoint = ro.xyz;\n\n    float stepSize = rl / (numInScatteringPoints - 1.0);\n\n    vec3 inScatteredLight = vec3(0, 0, 0);\n\n    float viewRayOpticalDepth = 0.0;\n\n    float ii = 0.0;\n    for (float i = 0.0; i < numInScatteringPoints; i += 1.0) {\n\n        float sunRayLength = raySphere(\n            planetCenter, atmosphereRadius, inScatterPoint, dirToSun).y;\n\n        float sunRayOpticalDepth = opticalDepth(\n            inScatterPoint, dirToSun, sunRayLength);\n\n        viewRayOpticalDepth = opticalDepth(\n            inScatterPoint, -rd, stepSize * ii);\n\n        vec3 transmittance = exp(\n            (-sunRayOpticalDepth-viewRayOpticalDepth) * scatterCoefs);\n\n        float localDensity = densityAtPoint(inScatterPoint);\n\n\n        inScatteredLight += \n            localDensity * transmittance * \n            scatterCoefs * stepSize;\n        inScatterPoint += \n            rd * stepSize;\n\n        ii += 1.0;\n    }\n\n    float originalTransmittance = exp(-2.0*viewRayOpticalDepth);\n    return originalTransmittance * originalColor + inScatteredLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.yy;\n\t\n    vec3 ray = normalize(vec3(uv, 1.0));\n    float rot = iTime*0.4;\n    vec3 cpos = -4.0 * vec3(cos(rot + 3.14 / 2.0), 0, sin(rot + 3.14 / 2.0));\n   \t\n    float ct = cos(rot), st = sin(rot);\n    ray.xz = vec2(ray.x * ct - ray.z * st, ray.x * st + ray.z * ct);\n    \n    vec2 dstToPlanet = raySphere(planetCenter, planetRadius, cpos, ray);\n    \n    vec3 tint = vec3(0, 0, 0);\n    \n    if (dstToPlanet.y > 0.0) {\n    \tvec3 pos = cpos + ray * dstToPlanet.x;\n        vec3 normal = normalize(pos);\n        float ns = 10.0 + iTime * 0.2;\n        vec3 normal_edit = vec3(\n            snoise(normal.xyz*25.0+ns), \n            snoise(normal.yzx*25.0+ns), \n            snoise(normal.zyx *25.0+ns));\n       \tnormal += normal_edit * 0.2;\n        float diffuse = max(dot(normal, dirToSun), 0.0);\n        float specular = dot(reflect(ray, normal), dirToSun);\n        specular = pow(max(specular, 0.0), 16.0);\n\n        float light = 0.7 * diffuse + 0.3 * specular;\n\n        tint = vec3(0.8, 0.8, 0.8) * light;\n    } else {\n        float dp = dot(ray, dirToSun);\t\t\t\n        float sn = snoise(ray.xyz * 50.0);\n        if (sn > 0.8) {\n            sn -= 0.8;\n            tint = vec3(sn, sn, sn) * 5.0;\n        }\n        if (dp > 0.997) {\n            dp -= 0.997;\n            dp *= 1000.0;\n            tint = dp * vec3(1.0, 0.8, 0.5);\n        }\n    }\n    vec2 t = raySphere(planetCenter, atmosphereRadius, cpos, ray);\n    if (t.y > 0.0) {\n        float nt = t.x, ft = min(t.y, dstToPlanet.x - t.x);\n        vec3 posInAtmosphere = cpos + ray * (nt + epsilon);\n        tint = calculateLight(posInAtmosphere, ray, ft - epsilon * 2.0, tint);\n    }\n    fragColor = vec4(tint,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 212, 233, 233, 284], [285, 285, 306, 306, 357], [358, 358, 380, 380, 419], [420, 420, 448, 448, 502], [503, 503, 525, 525, 2450], [2453, 2453, 2532, 2532, 3057], [3624, 3624, 3655, 3655, 3908], [3910, 3910, 3959, 3959, 4296], [4298, 4298, 4368, 4368, 5435], [5437, 5437, 5494, 5494, 7220]]}
{"id": "tsdBRM", "name": "Weathering - JFIG Contest", "author": "zibout", "description": "Mthode empirique pour vieillir des terrains.\nReprsentation du terrain inspire du papier : \"Authoring Landscapes by Combining Ecosystem and Terrain Erosion Simulation\" [Cordonier et Al.]\n#START_FRAME permet d'avoir le temps de se mettre en plein cran.", "tags": ["terrain", "jfig2020", "jfigcontest"], "likes": 11, "viewed": 836, "published": 3, "date": "1605291265", "time_retrieved": "2024-07-30T20:35:32.216092", "image_code": "////////////////////////\n// IMAGE - SCENE RENDERING\n////////////////////////\n\n// Rendering the actual water height yeild in strong visual artifacts \n// on slopes due to discrete step along the ray\n#define SHOW_WATER 1\n\n\n#define OVER4PI 1.0/3.141592\nconst vec3 L = normalize(vec3(-0.4, 0.5, -0.3));   \n\n\n\nfloat cumulus(in float h) \n{ \n    return( smoothstep(0., 0.1625, h) - smoothstep(0.88,0.98,h) );    \n}\n\n// Intersection function from Inigo Quilez\n// https://iquilezles.org/\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nvec3 ShadeSurface(vec3 albedo, vec3 L, vec3 N, vec3 V, vec3 LightColor)\n{\n    float NdotL = max(dot(N, L), 0.0);\n    return albedo * NdotL * LightColor;\n}\n\nvec3 ShadeSpecular(vec3 L, vec3 N, vec3 V, vec3 LightColor)\n{\n    vec3 halfwayDir = normalize(L - V);  \n    return vec3(pow(max(dot(N, halfwayDir), 0.0), 16.0));\n}\n\n\nvec3 TerrainAlbedo(vec3 p, vec4 terrainData)\n{\n    vec3 rock = vec3(0.4, 0.4, 0.4);     \n    vec3 sand = vec3(1.0, 0.8, 0.7);                \n    vec3 vegetation = vec3(0.4, 0.7, 0.4);\n    vec3 albedo = rock;\n    \n    if(terrainData.y > 0.0)\n    {\n        float ratio = clamp(terrainData.y*100.0, 0.0, 1.0);\n        albedo = mix(albedo, sand, ratio);\n    }\n    \n    if(terrainData.z > 0.0)\n    {\n        float ratio = clamp(terrainData.z*100.0, 0.0, 1.0);\n        albedo = mix(albedo, vegetation, ratio);\n    }\n           \n    \n    return albedo;\n}\n\nvec4 TerrainData(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nvec3 TerrainNormal(vec2 uv)\n{\n    return normalize(texture(iChannel3, uv).xyz);\n}\n\nvec3 WaterNormal(vec2 uv)\n{\n    return normalize(texture(iChannel2, uv).xyz);\n}\n\nfloat SampleClouds(vec2 uv, float h)\n{\n    float heightRatio = smoothstep(0.8, 0.84, h) - smoothstep(0.86, 0.9, h);\n    return heightRatio * texture(iChannel1, uv).x;\n}\n\nfloat henyey_greenstein_phase_function(float g, float mu) \n{\n\tfloat gg        = g * g;\n\treturn( ((1. - gg) / pow( 1. + gg - 2. * g * mu, 1.5)) * OVER4PI );\n}\n\nfloat PhaseFunction(float g1, float g2, float alpha, float mu)\n{\n    return mix(henyey_greenstein_phase_function(g1,mu),henyey_greenstein_phase_function(g2,mu),alpha);\n}\n\nfloat DistanceAttenuation(float value, float sigma)\n{\n    return exp(-value*sigma);\n}\n\nvec3 sky(vec3 rd)\n{\n    return mix(vec3(0.6, 0.8, 1.0), vec3(1.0, 1.0, 1.0), rd.y);\n}\n\n\n// RENDER FUNCTION\n////////////////////////\nvec3 TraceRay(vec3 ro, vec3 rd)\n{\n    \n    vec3 boundsN; \n    vec2 bounds = boxIntersection(ro-0.5, rd, vec3(0.5, 0.5, 0.5), boundsN);\n    \n    float terrainResolution = min(min(iResolution.x, iResolution.y), float(MAX_TERRAIN_SIZE));\n    vec2 toTerain = (terrainResolution-1.0)/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    // Intersecting terrain bounding box\n    // Check ray -> bouding box intersection\n    if(bounds.y > 0.0) \n    {\n        bounds.x = max(bounds.x, 0.0);\n        vec3 LColor = vec3(1.0, 1.0, 1.0);\n\n        float tStep = 0.005;\n        float tMax = bounds.y;\n        \n        vec3 p = ro + rd * bounds.x;\n        vec2 terrainUV = p.xz * toTerain;\n        vec3 pStep = rd * tStep;\n        vec2 terrainUVVar = (rd.xz * tStep) * toTerain;\n        vec4 datas = TerrainData(terrainUV);\n\t\t\n        vec3 absorption = vec3(1.0);\n        bool inWater = false;\n        // Raymarch heightmap\n        float prevPH = p.y;\n        float prevH = TerrainHeight(datas);        \n\n        for(float t = bounds.x ; t<= tMax ; t += tStep)\n        {\n            \n            //float sampleH \n            datas = TerrainData(terrainUV);\n            float h = TerrainHeight(datas);\n            float ph = p.y;\n            float wh = h + datas.w;\n            \n            #if SHOW_WATER\n            if(p.y < wh - 0.02)\n            {\n                // Phase change, account for water surface participation\n                if(!inWater) \n                {\n                    // Force using terrain bounding box normals if the intersection happens on the edge.\n                    vec3 N = t == bounds.x ? boundsN : WaterNormal(terrainUV);\n                    color += ShadeSpecular(L, N, rd, LColor);\n                }\n                inWater = true;\n                // Absorption due to water medium\n                absorption *= vec3(DistanceAttenuation(25.0, tStep), DistanceAttenuation(12.0, tStep), DistanceAttenuation(10.0, tStep)); \n            }else{\n                inWater = false;\n            }\n            #endif\n            if(ph < h) \n            {\n                // We refine the intersection point with the surface.\n                // Should be done with water surface but I was in a hurry\n                float x = 1.0 - (prevH-prevPH) / (ph-prevPH-h+prevH);\n                tMax = t - x*tStep;\n                p -= pStep * x;\n                terrainUV = p.xz * toTerain;\n                datas = TerrainData(terrainUV);\n                \n                vec3 N = t == bounds.x ? boundsN : TerrainNormal(terrainUV);\n                vec3 albedo = TerrainAlbedo(vec3(p), datas);\n                color += ShadeSurface(albedo, L, N, -rd, LColor) * absorption ;\n                break;\n            }\n            if(p.y > 0.8 && p.y < 0.9)\n            {\n                float density = SampleClouds(terrainUV, p.y) * 30.0;\n                if(density > 0.0){\n                    // Absorption due to cloud medium\n                    float Tr   =  DistanceAttenuation(density, tStep);\n                    float Tr2 = 1.0;\n                    // Compute absorbed light to current sample point\n                    for(int i = 0 ; i < 10 ; i++)\n                    {\n                        vec3 cloudP = p + L * float(i) * 0.005;\n                        float cloudDensity = SampleClouds( cloudP.xz * toTerain, cloudP.y) * 30.0;\n                        Tr2 *= DistanceAttenuation(cloudDensity, 0.01);\n                    }\n                    // Cloud scattering\n                    vec3 Scat = Tr2 * (5.0*LColor) * density * PhaseFunction(0.8,-0.2,0.5,dot(L, rd)); \n\n                    color += absorption * ((Scat-Scat*Tr) / density);\n                    absorption *= vec3(Tr);\n                }\n                \n            }\n            \n            prevPH = p.y;\n            prevH = h;\n            p += pStep; \n            terrainUV += terrainUVVar;\n\n        }\n        \n        // If no intersection occured render sky\n        if(tMax == bounds.y) \n        {\n            color += sky(rd) * absorption;\n        }\n        \n    }else{ // Render sky color\n        color = sky(rd);\n    }\n    \n\treturn color;    \n}\n\n\n// Main - Setup camera and trace ray\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float terrainResolution = min(min(iResolution.x, iResolution.y), float(MAX_TERRAIN_SIZE));\n    vec2 toTerain = (terrainResolution-1.0)/iResolution.xy;\n    \n    // Create Ray (iquilez)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\t\n\tfloat fov = 2.0;\n\tfloat dist = 1.4 - 1.4*iMouse.y/iResolution.y;\n\tfloat an = -0.7 + 2.0*3.141592*iMouse.x/iResolution.x - 0.3*iTime;\n\tvec3 ro = vec3( dist*cos(an), 0.0, dist*sin(an) ) + vec3(0.5, 1.2, 0.5); //1.2\n    vec3 ta = vec3( 0.5, 0.25, 0.5 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n    \n    vec3 color = TraceRay(ro, rd);\n    \n        \n    fragColor = vec4(color, 1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////\n// BUFFER A\n////////////////////////\n// FragColor => (Rock Height, Sand, Vegetation, water)\n// Compute initial heightmap from frame 0 to START_FRAME\n// Then weather it for until the end of times.\n\n#if 1\n        const int neighnorsCount = 9;\n        const ivec2 neighbors[9] = ivec2[](\n            ivec2(-1, -1), ivec2(-1,  0), ivec2(-1,  1), \n            ivec2( 0, -1), ivec2( 0,  0), ivec2( 0,  1), \n            ivec2( 1, -1), ivec2( 1,  0), ivec2( 1,  1)\n\t\t);\n        const float weights[9] = float[](\n            0.077847, 0.123317, 0.077847,\n            0.123317, 0.195346,\t0.123317, \n            0.077847, 0.123317, 0.077847\n        );\n        #else\n\t\tconst int neighnorsCount = 25;\n        const ivec2 neighbors[25] = ivec2[](\n            ivec2(-2, -2), ivec2(-2, -1), ivec2(-2, 0), ivec2(-2, 1), ivec2(-2, 2), \n            ivec2(-1, -2), ivec2(-1, -1), ivec2(-1, 0), ivec2(-1, 1), ivec2(-1, 2), \n            ivec2( 0, -2), ivec2( 0, -1), ivec2( 0, 0), ivec2( 0, 1), ivec2( 0, 2), \n\t\t\tivec2( 1, -2), ivec2( 1, -1), ivec2( 1, 0), ivec2( 1, 1), ivec2( 1, 2), \n\t\t\tivec2( 2, -2), ivec2( 2, -1), ivec2( 2, 0), ivec2( 2, 1), ivec2( 2, 2)\n        );\n        const float weights[25] = float[](\n            0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n            0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n            0.023792, 0.094907, 0.150342, 0.094907, 0.023792, \n            0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n            0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n        );\n#endif\n\n\n\n\n\n\n// Credit to haqreu\n// https://www.shadertoy.com/view/wsXyD8\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\n// INITIAL TERRAIN HEIGHMAP GENERATION\nvec4 terrainHeightMap(vec2 terrainUV)\n{\n    vec4 data = vec4(0.0);\n    \n    float terrainHeight = 0.0;\n    \n    \n\tvec4 C = texture(iChannel3, terrainUV);\n    float baseH = (C.x + C.y + C.z)/3.0;        \n\n    float jfigHeight = 0.0;\n    \n    const float offset = 0.05;\n    const float size = 0.2;\n    if(terrainUV.x < (1.0-offset) && (1.0-terrainUV.y) > offset && terrainUV.x > (1.0-size-offset) && (1.0-terrainUV.y) < (size+offset))\n    {\n        vec2 jfigUV = vec2(remap(terrainUV.x, 1.0-size-offset, 1.0-offset, 1.0, 0.0), remap(1.0-terrainUV.y, size+offset, offset, 0.0, 1.0));\n        \n        jfigHeight = jfig(uint(jfigUV.x * float(JFIGW)), uint(jfigUV.y* float(JFIGH))) ? 1.0 : 0.0;\n        jfigHeight = jfigHeight * 0.005 + remap(terrainUV.y, 0.7, 0.9, 0.1, 0.2);\n        terrainHeight = 0.11 + jfigHeight;\n        data.y = 0.005;\n    }else{        \n    \tterrainHeight = 0.1 + 0.2 * baseH + gaussian(length(terrainUV*2.0-1.0), 0.5)*(0.2 + baseH);\n    }\n    data.x = terrainHeight;\n    data.w = clamp(SEA_LEVEL-TerrainHeight(data), 0.0, 1.0);\n    return data;\n}\n\nvec4 terrainTestHeightMap(vec2 terrainUV)\n{\n    \n    return vec4(0.1 + (terrainUV.x > 0.5 ? 0.0 : 0.1), (terrainUV.y > 0.5 ? 0.0 : 0.1), 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //MAX_TERRAIN_SIZE\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 samplePos = ivec2(fragCoord);\n    \n    int terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    \n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if(iFrame < START_FRAME){\n        \n        ///////////////////////\n        /// INITIAL TERRAIN CREATION\n        ///////////////////////\n        vec2 terrainUV = vec2(samplePos)/vec2(terrainDef);\n        vec4 data = terrainHeightMap(terrainUV);\n        //data = terrainTestHeightMap(terrainUV);\n        \n        fragColor = data;\n    \n    \n    }else{\n        ///////////////////////\n        /// EVOLUTION\n        ///////////////////////\n        \n        vec4 data = texelFetch(iChannel0, samplePos, 0);\n        float groundHeight = TerrainHeight(data);\n        float totalHeight = groundHeight + data.w;\n        float waterVariation = 0.0;\n        float sandVariation = 0.0;\n        for(int i = 0 ; i < neighnorsCount ; i++)\n        {\n            ivec2 nPos = clamp(samplePos + neighbors[i], 0, terrainDef-1);\n            vec4 nData = texelFetch(iChannel0, nPos, 0);\n            \n            float nGroundHeight = TerrainHeight(nData);\n            float nTotalHeight = nGroundHeight + nData.w;\n            \n            float hDiff = nTotalHeight - totalHeight;\n            if(hDiff < 0.0){\n                hDiff = max(hDiff, -data.w);\n            }else{\n                hDiff = min(hDiff, nData.w);\n            }\n            waterVariation += hDiff * weights[i];\n            \n            \n            float GroundhDiff = nGroundHeight - groundHeight;\n            if(GroundhDiff < 0.0){\n                GroundhDiff = max(GroundhDiff, -data.y);\n            }else{\n                GroundhDiff = min(GroundhDiff, nData.y);\n            }\n            sandVariation += GroundhDiff * weights[i];\n            \n            \n        }\n        \n        // WATER MOVEMENT\n        data.w += waterVariation;\n        \n        // SAND MOVEMENT\n        data.y = max(data.y + sandVariation * SAND_MOVEMENT_RATE, 0.0);\n        \n        // ERROSION (Due to the strength of water movement)\n        float soilErrosion = abs(waterVariation * ERROSION_RATE);\n        data.y += soilErrosion;\n        data.x = max(data.x - soilErrosion, 0.0);\n        \n        \n        \n\t\t\n        // VEGETATION FORMATION\n        vec3 N = normalize(texelFetch(iChannel1, samplePos, 0).xyz);\n\t\tfloat NdotUp = max(dot(N, vec3(0.0, 1.0, 0.0)), 0.0);\n        if(NdotUp > 0.8 )\n        {\n            float v = remap(NdotUp, 0.8, 1.0, 0.0, 1.0) * data.w * max(min(data.y, VEGETATION_FORMATION_RATE), 0.0);\n            data.y -= v;            \n            data.z += v;\n        }\n        \n        // WATER ABSORPTION BY VEGETATION\n        float waterAbsorption = data.z * VEGETATION_ABSORPTION_RATE;\n        data.w -= waterAbsorption;\n\n        if(data.y < data.w) // More water than vegetationit dies\n        {\n            float dyingVegetation = min(VEGETATION_DRAWNING_RATE, data.z);\n        \tdata.y += dyingVegetation;            \n            data.z -= dyingVegetation;\n        }\n        \n        // WATER EVAPORATION\n        data.w = max(data.w - EVAPORATION_RATE*iTimeDelta, 0.0);\n        \n        // RAIN\n        float clouds = texelFetch(iChannel1, samplePos, 0).x;\n        data.w += clouds * RAINFALL_RATE * iTimeDelta;\n        \n        //data.w = max(data.w, clamp(SEA_LEVEL-groundHeight, 0.0, 1.0));\n        \n        fragColor = data;\n        \n    }\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////\n// Common\n////////////////////////\n#define START_FRAME 100\n#define MAX_TERRAIN_SIZE 512\n\n\n// SIMULATION PARAMETERS\n////////////////////////\n#define EVAPORATION_RATE 0.003\n#define RAINFALL_RATE 0.008\n#define VEGETATION_ABSORPTION_RATE 0.001\n\n#define SEA_LEVEL 0.25\n\n#define ERROSION_RATE 0.1\n\n#define SAND_MOVEMENT_RATE 0.1\n\n#define VEGETATION_FORMATION_RATE 0.04\n#define VEGETATION_DRAWNING_RATE 0.02\n\n// UTILITIES\n////////////////////////\nfloat TerrainHeight(vec4 terrainData)\n{\n    return terrainData.x +  terrainData.y +  terrainData.z;\n}\n\nfloat WaterHeight(vec4 terrainData)\n{\n    return terrainData.x +  terrainData.y +  terrainData.z +  terrainData.w;\n}\n\n\nfloat remap(in float value, in float original_min, in float original_max, in float new_min, in float new_max)\n{\n    return new_min + (((value - original_min) / (original_max - original_min)) * (new_max - new_min));\n}\n\nfloat gaussian(float d, float sigma)\n{\n    return(1.0/(sigma*sqrt(2.0*3.141592)))*exp(-(d*d)/(2.0*(sigma*sigma)));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_d_code": "\n////////////////////////\n// BUFFER D - TERRAIN NORMALS COMPUTATION\n////////////////////////\n// Compute terrain normal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tivec2 nL = clamp(samplePos - ivec2(1, 0), 0, terrainDef-1);\t\n    ivec2 nR = clamp(samplePos + ivec2(1, 0), 0, terrainDef-1);\n\tivec2 nD = clamp(samplePos - ivec2(0, 1), 0, terrainDef-1);\n\tivec2 nU = clamp(samplePos + ivec2(0, 1), 0, terrainDef-1);\n    \n    float hL = TerrainHeight(texelFetch(iChannel0, nL, 0));\n    float hR = TerrainHeight(texelFetch(iChannel0, nR, 0));\n    float hD = TerrainHeight(texelFetch(iChannel0, nD, 0));\n    float hU = TerrainHeight(texelFetch(iChannel0, nU, 0));        \n    \n    float fac = 0.5 * float(terrainDef);\n    \n    vec3 N = vec3((hL-hR)*fac, 1.0, (hD-hU)*fac);\n    \n    fragColor = vec4(normalize(N), 1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n////////////////////////\n// BUFFER B\t- COMPUTE CLOUD MAP\n////////////////////////\n\n// Noise function from Inigo Quilez\n// https://iquilezles.org/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat w1( in vec3 x )\n{\n    float dx = noise(x+vec3(6.53, 21.932, 21.123));\n    float dy = noise(x+vec3(9.77, 7.34, 3.1));\n    float dz = noise(x+vec3(3.91, 71.73, 8.23));\n    return noise(x+vec3(dx, dy, dz));\n}\n\nfloat weatherMap( in vec2 x )\n{\n    return 0.5 * w1(vec3(x*5.0, iTime*0.25)) + 0.25 * w1(vec3(x.yx*10.0, iTime*0.2)) + 0.125 * w1(vec3(x.yx*20.0, iTime*0.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec2 uv = fragCoord / vec2(terrainDef);\n    \n    float v = clamp(weatherMap(uv+vec2(iTime*0.5)), 0.0, 1.0);\n    \n    fragColor = vec4(v, v, v, 1.0);\n    \n    \n}\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n////////////////////////\n// BUFFER C - WATER NORMALS COMPUTATION\n////////////////////////\n//Water Normal\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 samplePos = ivec2(fragCoord);\n    \n\tint terrainDef = min(min(int(iResolution.x), int(iResolution.y)), MAX_TERRAIN_SIZE);\n    if(samplePos.x >= terrainDef || samplePos.y >= terrainDef){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tivec2 nL = clamp(samplePos - ivec2(1, 0), 0, terrainDef-1);\t\n    ivec2 nR = clamp(samplePos + ivec2(1, 0), 0, terrainDef-1);\n\tivec2 nD = clamp(samplePos - ivec2(0, 1), 0, terrainDef-1);\n\tivec2 nU = clamp(samplePos + ivec2(0, 1), 0, terrainDef-1);\n    \n    float hL = WaterHeight(texelFetch(iChannel0, nL, 0));\n    float hR = WaterHeight(texelFetch(iChannel0, nR, 0));\n    float hD = WaterHeight(texelFetch(iChannel0, nD, 0));\n    float hU = WaterHeight(texelFetch(iChannel0, nU, 0));        \n    \n    //Water surface perturbation tests\n    #if 0\n    \thL += 0.005 * sin(float(samplePos.x - 1)*0.05+iTime);    \n    \thR += 0.005 * sin(float(samplePos.x + 1)*0.05+iTime);\n\t\thD += 0.005 * cos(float(samplePos.y - 1)*0.05+iTime);    \n    \thU += 0.005 * cos(float(samplePos.y + 1)*0.05+iTime);\n    #endif \n    \n    float fac = 0.5 * float(terrainDef);\n    \n    vec3 N = vec3((hL-hR)*fac, 1.0, (hD-hU)*fac);\n    \n    fragColor = vec4(normalize(N), 1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 332, 332, 406], [408, 478, 554, 554, 1036], [1039, 1039, 1112, 1112, 1193], [1195, 1195, 1256, 1256, 1358], [1361, 1361, 1407, 1407, 1909], [1911, 1911, 1938, 1938, 1975], [1977, 1977, 2006, 2006, 2058], [2060, 2060, 2087, 2087, 2139], [2141, 2141, 2179, 2179, 2309], [2311, 2311, 2371, 2371, 2468], [2470, 2470, 2534, 2534, 2639], [2641, 2641, 2694, 2694, 2726], [2728, 2728, 2747, 2747, 2813], [2816, 2860, 2893, 2893, 6987], [6990, 7052, 7109, 7109, 7973]]}
{"id": "WddBWM", "name": "Contrast small-big", "author": "illus0r", "description": "Contrast small-big", "tags": ["inversion"], "likes": 0, "viewed": 254, "published": 3, "date": "1605265241", "time_retrieved": "2024-07-30T20:35:32.976060", "image_code": "float f(float t) {\n    // just finetuning the time. \n    // looks difficult, hence here's simplified version\n    // which makes pretty the same:\n    //return sin(t)*.5+.5;\n    return .1+pow(10.*(sin(t*3.+3.1415)*.5+.5), 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // two similar 3-liners below draw two circles:\n    \n    // `- vec2(.05,0.)` is optional. It moves a circle a bit to the right\n    vec2 uv1 = uv - vec2(.05,0.);\n    // it's the most difficult part.\n    // Learn more on https://en.wikipedia.org/wiki/Inversive_geometry\n    // try commenting this line out to see the shape without the inversion.\n    uv1 = normalize(uv1)/length(uv1);\n\t// drawing the shape which is just a right half of the screen.\n    float sph1 = step(f(iTime),uv1.x);\n\n    // move a circle a bit to the left\n    vec2 uv2 = uv - vec2(-.05,0.);\n    // inversion\n    uv2 = normalize(uv2)/length(uv2);\n    // here are two differences from above:\n    // +3.1415 is for make circles move in different phases\n    // `-uv2.x` to color the left half of the screen.\n    //                           \n    float sph2 = step(f(iTime+3.1415),-uv2.x);\n\n    // `max` is to show both circles at once\n    fragColor = vec4(vec3(max(sph1, sph2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 171, 227], [229, 229, 286, 286, 1322]]}
{"id": "tdcBDM", "name": "waving colors 2", "author": "elenzil", "description": "simple waving colors. added some horizontal anti-aliasing and shaping.", "tags": ["spangled"], "likes": 1, "viewed": 309, "published": 3, "date": "1605223575", "time_retrieved": "2024-07-30T20:35:33.735030", "image_code": "// https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float t) {\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // artificial down-resing to test AA\n    const float pixelate = 1.0;\n    \n    fragCoord = round(fragCoord / pixelate);\n    \n    vec2 res = ceil(iResolution.xy / pixelate);\n    \n    vec2 uv = fragCoord/res.xy;\n    \n    const int bins = int(40.0 / pixelate);\n\n    vec3 col = vec3(0.0);\n    \n    // phased-in behavior\n    float phWig = smoothstep(1.0, 15.0, iTime);\n    float phBin = smoothstep(6.0, 18.0, iTime);\n    float phTap = smoothstep(9.0, 30.0, iTime);\n    float phPin = smoothstep(0.0, 15.0, iTime);\n    \n    float accum = 0.0;\n\n    // horizontal AA amount\n    float binEdge = 4.0 / res.x;\n\n    \n    for (int bin = 0; bin < bins; ++bin) {\n        float binMid = (float(bin) + 0.5)/float(bins);\n        float t = uv.x;\n        \n        // taper the overall thing\n        t = ((t - 0.5) * (1.0 + pow(uv.y, 0.8) * 0.5 * phPin)) + 0.5;\n        \n        // wiggle the things\n        float fmod = sin(binMid * 3.0 - iTime * 0.31) * 0.5 + 0.5;\n        t += abs(uv.x - 0.5) * phWig * uv.y * 0.4 * sin(uv.y * 20.0 - iTime * (1.0 + phBin * binMid + 0.6) + fmod);\n        \n        // wiggle the overall thing a tiny bit\n        t += 0.01 * phWig * uv.y * sin(uv.y * 7.0 - iTime);\n        \n        float binWidth = 1.0 / float(bins) * (1.0 - phTap * uv.y * 0.75);\n        float binBeg = binMid - binWidth * 0.5;\n        float binEnd = binMid + binWidth * 0.5;\n        if (t >= binBeg - binEdge && t < binEnd + binEdge) {\n            // AA:\n            float amount = 1.0;\n            if (t < binBeg) {\n                amount = smoothstep(binBeg - binEdge, binBeg, t);\n            }\n            else if (t > binEnd) {\n                amount = 1.0 - smoothstep(binEnd, binEnd + binEdge, t);\n            }\n            \n    \t\tcol += palette(t) * amount;\n            accum += amount;\n        }\n        binBeg = binEnd;\n    }\n    \n    col /= max(accum * 1.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 133, 133, 176], [178, 178, 201, 201, 297]]}
{"id": "wdcfWM", "name": "Vibrant Fitzhugh-Nagumo", "author": "mkennan", "description": "The FitzHugh-Nagumo model of neuron excitation.", "tags": ["diffusion", "reaction", "fitzhugh", "nagumo"], "likes": 4, "viewed": 390, "published": 3, "date": "1605220816", "time_retrieved": "2024-07-30T20:35:34.490012", "image_code": "/*\n\n    Michael Kennan, November 2020, https://www.shadertoy.com/view/wdcfWM\n\n    FlexMonkey,     October 2017,  https://www.shadertoy.com/view/MtSczD \n\n\tSimon Gladman   October 2017,  http://flexmonkey.blogspot.co.uk/     \n\n\tBased on https://github.com/GollyGang/ready/tree/gh-pages/Patterns/FitzHugh-Nagumo\n*/\n#define PI 3.1415926535\n#define TAU 2.0 * PI\n\nvec4 clr(float value) {\n  float bias = 2.3;\n  float ang = (value + 0.1) * TAU - 1.32 - bias * clamp(1.2 * cos(iTime * 0.1), -0.7, 0.7);\n\n  return vec4(\n    sin(ang + PI * 0.0) * 0.5 + 0.5,\n    sin(ang + PI * 0.5) * 0.5 + 0.5,\n    sin(ang + PI * 1.0) * 0.5 + 0.5,\n    1.0\n  );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n  vec2 pos = fragCoord.xy / iResolution.xy;\n  vec2 val = texture(iChannel0, pos).xy;\n\n  fragColor = clr(val.x * val.x + val.y);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Michael Kennan, November 2020, https://www.shadertoy.com/view/wdcfWM\n\n    FlexMonkey,     October 2017,  https://www.shadertoy.com/view/MtSczD \n\n\tSimon Gladman   October 2017,  http://flexmonkey.blogspot.co.uk/     \n\n\tBased on https://github.com/GollyGang/ready/tree/gh-pages/Patterns/FitzHugh-Nagumo\n\n*/\n#define PI 3.1415926535\n\nfloat a0  = -0.15;\nfloat a1  =  1.8;\nfloat eps =  0.025;\nfloat del =  4.0;\nfloat k1  =  1.05;\nfloat k2  = -0.5;\nfloat k3  =  1.4;\n\nfloat timestep = 0.06;\n\nfloat noise(vec2 co) {\n    vec2 seed = vec2(sin(co.x), cos(co.y));\n    return fract(sin(dot(seed ,vec2(12.98,79.233) * iTime)) * 43758.5453);\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x)  { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  perm(vec4 x)    { return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec2 v, float f) { // [-1,1]\n  vec3 p = vec3(v,f);\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = perm(b.xyxy);\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = perm(c);\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  float sum = o4.y * d.y + o4.x * (1.0 - d.y);\n  sum = sum * 2.0 - 1.0;\n  return clamp(sum, -1.0, 1.0);\n}\n\nvec4 t(vec2 v) {\n  return texture(iChannel0, v);\n}\n\nvec4 t(vec2 v, vec2 p, float x, float y) {\n  return t(vec2(v + vec2(x * p.x, y * p.y)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = fragCoord.xy / iResolution.xy;\n  vec2 pix = 1.0 / iResolution.xy;\n\n  vec4 ab = texture(iChannel0, pos);\n\n  float diagonal = 0.0;\n  float aligned  = 1.0;\n  vec3 laplacian = vec3(\n    aligned * (\n      t(pos, pix, 1.0, 0.0) +\n      t(pos, pix, 0.0, 1.0) +\n      t(pos, pix,-1.0, 0.0) +\n      t(pos, pix, 0.0,-1.0)\n    ) +\n    diagonal * (\n      t(pos, pix, 1.0, 1.0) +\n      t(pos, pix,-1.0, 1.0) +\n      t(pos, pix, 1.0,-1.0) +\n      t(pos, pix,-1.0,-1.0)\n    )\n    - 4.0 * (aligned + diagonal) * t(pos)\n  );\n\n\n  float a = ab.x;\n  float b = ab.y;\n\n  float del_a = k1*a - k2*a*a - a*a*a - b + laplacian.x;\n  float del_b = eps*(k3*a - a1*b - a0) + del*laplacian.y;\n\n  vec2 result = vec2(clamp(a + del_a * timestep, -1.0, 1.0),\n                     clamp(b + del_b * timestep, -1.0, 1.0));\n\n  if(ab.xyz == vec3(0)) {\n      float h = 0.4;\n      float w = h * iResolution.y / iResolution.x;\n      \n      if (abs(pos.x - 0.5) < w && abs(pos.y - 0.5) < h) {\n        fragColor = vec4(noise(pos) * 4.0, 0.0, 0.0, 0);\n      }\n      else {\n        fragColor = vec4(-1, -noise(pos) * 0.2, 0, 1);\n      }\n\n  }\n  else {\n      // `z` holds sum of `x` species....\n      fragColor = vec4(result.xy, ab.z + result.x, 1.0);\n  }\n\n  //fragColor.r += 0.001 * noise((pos - 0.5) * 0.1, iTime * 0.001);\n\n  // decay phase\n  if (fragColor.z > 70.0) {\n    fragColor.x = -noise(pos * iTime) * 0.3;\n    fragColor.z = fragColor.x;\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 381, 381, 635], [638, 638, 693, 693, 828]]}
{"id": "wd3fWM", "name": "Otra cabeza-simple-v2", "author": "jorge2017a1", "description": "Otra cabeza-simple", "tags": ["otracabezasimple"], "likes": 1, "viewed": 251, "published": 3, "date": "1605216963", "time_retrieved": "2024-07-30T20:35:35.481361", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.01\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sMin( float a, float b, float k )\n{\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\nfloat sMax(in float x, in float y, in float s)\n{\n    float b = clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (b - 1.0) * (b - 1.0);\n}\n\n\nvec3 HacerOjoConCabeza4en1(float sdcabeza,float sdPupila, float sdIris, float sdesclerotica, bool pblnCabeza )\n{\n    \n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    //sdescleroticaDer>sdIrisDer>sdPupilaDer  (eje x,y)\n    //sdPupilaDer>sdIrisDer>sdescleroticaDer ( eje z)\n    \n    float uniontdo;\n    uniontdo= sdcabeza;\n    uniontdo= unionSDF(uniontdo, sdPupila);\n    uniontdo= unionSDF(uniontdo, sdIris);\n    uniontdo= unionSDF(uniontdo, sdesclerotica);\n    \n    float interstdo;\n    interstdo=sdcabeza;\n    interstdo=intersectSDF(interstdo, sdPupila);\n    interstdo=intersectSDF(interstdo, sdIris); \n    interstdo=intersectSDF(interstdo, sdesclerotica);\n    \n    \n    float diftdo=sdcabeza;\n    diftdo=differenceSDF(diftdo,sdesclerotica);\n    diftdo=differenceSDF(diftdo, sdPupila);\n    diftdo=differenceSDF(diftdo, sdIris);\n    \n    float interAB=intersectSDF(sdIris, sdcabeza);\n    float interAC=intersectSDF(sdPupila, sdcabeza);\n    float interAD=intersectSDF(sdesclerotica, sdcabeza);\n    \n    if (pblnCabeza)    res =opU3(res, vec3(sdcabeza,16.0,MATERIAL_NO));    \n    res =opU3(res, vec3(interAD,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(interAB,4.0,MATERIAL_NO));\n    res =opU3(res, vec3(interAC,0.0,MATERIAL_NO)); \n    \n    return res;\n}\n   \n\n\n\nfloat nose(vec3 p)\n{\n    vec3 n;\n    n=p;\n    n.xz =rotatev2(p.xz, radians(45.0));    \n    float d  = sdRoundBox(n, vec3(0.45,2.0,0.45), .8); \n    \n    return d;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+35.0; //pared izq\n    float planeDist4 = 35.0-p.x;  //pared der\n    float planeDist5 = -p.z+45.0;  //pared frente\n    float planeDist6 = p.z+45.0;  //pared atras\n    \n    //res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist1,7.0,-1.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,3.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist5,6.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n  \n    p.y=p.y-5.0;\n \n    \n     float separacionOjoX=3.0;\n    float sdPupilaDer= sdCylinderXY(p- vec3( separacionOjoX,10.0,-10.0), vec2(0.5,4.0) );\n    float sdPupilaIzq= sdCylinderXY(p- vec3(-separacionOjoX,10.0,-10.0), vec2(0.5,4.0) );\n    \n    float sdIrisDer= sdCylinderXY(p- vec3( separacionOjoX,10.0, -10.0), vec2(1.0,3.0) );\n    float sdIrisIzq= sdCylinderXY(p- vec3(-separacionOjoX,10.0,-10.0), vec2(1.0,3.0) );\n \n    float sdescleroticaDer=sdEllipsoid(p-vec3(separacionOjoX,10.0,-10.0), vec3(2.5,1.8,3.0) );\n    float sdescleroticaIzq=sdEllipsoid(p-vec3(-separacionOjoX,10.0,-10.0), vec3(2.5,1.8,3.0) );\n    \n    \n    \n   \n    \n    float sdCabeza= sdEllipsoid(p-vec3(0.0,11.0,-14.0), vec3(8.0,11.0,6.0) );\n    vec3 resojoDer =HacerOjoConCabeza4en1(sdCabeza,sdPupilaDer, sdIrisDer, sdescleroticaDer, true);\n    vec3 resojoIzq =HacerOjoConCabeza4en1(sdCabeza,sdPupilaIzq, sdIrisIzq, sdescleroticaIzq,false);\n    res =opU3(res, resojoDer); \n    res =opU3(res, resojoIzq);     \n    \n  \n    float sdnariz= nose(p-vec3(0.0,8.0,-9.0));\n    res =opU3(res, vec3(sdnariz,16.0,MATERIAL_NO));     \n\n    \n    float sdcejaIzq= sdBox(p-vec3( 3.5,12.0,-8.0), vec3(1.5,0.2,3.0) );\n    float sdcejaDer= sdBox(p-vec3(-3.5,12.0,-8.0), vec3(1.5,0.2,3.0) );\n   \n  \tfloat interCejaIzq= intersectSDF(sdCabeza, sdcejaIzq);\n    float interCejaDer= intersectSDF(sdCabeza, sdcejaDer);\n    \n    res =opU3(res, vec3(interCejaIzq,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(interCejaDer,0.0,MATERIAL_NO)); \n    \n    \n    ///Boca\n    float sdBoca= sdBox(p-vec3( 0.0,4.5,-8.0), vec3(2.5,0.2,3.0) );\n    float interBoca= intersectSDF(sdCabeza, sdBoca);\n  \n    res =opU3(res, vec3(interBoca,2.0,MATERIAL_NO)); \n\n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n    \n    \n    float diff = dot(normal, l);\n    \n    //vec3 v = normalize( p - ro );\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n            \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(15.0, 10.0, -15.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -15.0, 16.0, 15.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n \n    \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0.,10.0+ radius, 0.0-10.0);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n  \n\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 3.0; // of radius of object\nconst float radius = 6.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x), cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3fWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 432, 432, 516], [517, 517, 563, 563, 650], [653, 653, 690, 690, 785], [786, 786, 825, 825, 920], [921, 921, 960, 960, 1055], [1056, 1056, 1095, 1095, 1190], [1192, 1236, 1283, 1283, 1310], [1312, 1312, 1355, 1355, 1382], [1384, 1384, 1432, 1432, 1460], [1508, 1573, 1607, 1607, 1705], [1706, 1706, 1740, 1740, 1832], [1833, 1833, 1867, 1867, 1959], [1960, 2000, 2034, 2034, 2131], [2135, 2135, 2172, 2172, 2255], [2257, 2257, 2334, 2334, 2469], [2471, 2471, 2512, 2512, 2605], [2606, 2606, 2647, 2647, 2734], [2735, 2735, 2783, 2783, 2884], [2887, 2887, 2999, 2999, 4142], [4150, 4150, 4170, 4170, 4313], [4316, 4356, 4381, 4381, 6970], [6975, 6975, 7061, 7061, 7828], [7834, 7885, 7909, 7909, 8097], [8098, 8161, 8194, 8194, 8658], [8660, 8714, 8750, 8750, 8984], [9042, 9042, 9091, 9091, 9313], [9314, 9348, 9428, 9428, 9705], [9802, 9802, 9895, 9895, 10151], [10154, 10203, 10260, 10260, 12285]]}
{"id": "WstBD4", "name": "Coiled 15 puzzle game", "author": "FabriceNeyret2", "description": "mouse control cam.      SPACE+click cell next to void tile to swap.    reset = new game.\n\nref: [url]https://www.youtube.com/watch?v=rfAEgxNEOrQ[/url]\n[img]https://i.imgur.com/H3bgCS7.png[/img]\n\nSomething suspicious in my camera geometry...\n", "tags": ["game", "cylinder", "short", "taquin", "reproduction", "15puzzle"], "likes": 14, "viewed": 533, "published": 3, "date": "1605212848", "time_retrieved": "2024-07-30T20:35:36.268258", "image_code": "// === manage display ==============================================================\n\nvec4 char(vec2 p, int c) {                     // === draw character   https://www.shadertoy.com/view/llySRh\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx, dFdy );\n}\n\nvoid mainImage(out vec4 O, vec2 U) {           // === display puzzle \n    cam0(iTime);                                                     // this stupidely can't be done in common\n    vec2 r = raytrace( cam1(U) );               \n    O-=O;\n    if ( r==vec2(0) ) return;                                        // no hit\n#define bord(d)  O += 1.5 - abs(d)/.03\n    float m = abs ( Amax(r) -2.06 );\n    if ( m <.04  && (r.y>-2. || r.x > -.95 )&& (r.y<2. || r.x < .95 ) )// draw border\n        { bord(m); return; }\n\n    // --- 15-puzzle space: display as usual -------------------------------------\n\n    vec2 P = floor(r+=2.), D;                                        // cell number\n // O = vec4((1.+P)/6.,0,0); return;\n    if      (P==vec2(0,-1)) P = vec2(3);                             // bridge\n    else if (P==vec2(3, 4)) P = vec2(0);\n    else if (P==vec2(1,-1)) bord(r.x-1.06);                          // draw bridge border\n    else if (P==vec2(2, 4)) bord(r.x-2.94);\n    int n = int( T1(P).x );                                          // tile id\n    float t = ( iTime - T1(P).z ) / .5, d = T1(P).w;\n    if ( t < 1. )                                                    // tile swap anip\n        D = vec2( mod(d,3.)-1., floor(d/3.)-1. ),                    //   slide dir\n        n = int( T1(P)[fract(r*D)[ D.x==0.? 1 : 0 ] > t ? 1 : 0 ] ), //   side-dependent id\n        r += (1.-t)* D;                                              //   slide\n    r = fract(r)*2. - 1.;                                            // pos in tile\n    float c = 0.;\n    if ( n> 0 ) \n        c = max( char(r+.5,48+n%10).x, n > 9 ? char(r+.5+vec2(.5,0),49).x : 0. ),\n        O +=   clamp(1.-( Amax(r) - .93 )/.05,0.,1.) * (1.-c)        // display id\n             * vec4(.5,.5,1,0) * _shad;                              // color & shading\n // if ( T(0).xy == P ) O.r++;                                       // cur tile in red\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === manage shape raytrace, used for rendering & picking ==========================\n\n#define T(U)      texelFetch(iChannel0, ivec2(U), 0 )\n#define T1(U)     texelFetch(iChannel1, ivec2(U), 0 )\n#define Amax(v)   max( abs(v).x, abs(v).y )\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                 // rotation                  \n#define R         iResolution\nvec2 CAM;                                                        // camera\n#define cam0(t)   CAM = length(iMouse.xy) > 10. ? T(8).xy -.5: vec2(8,6)/1e2*cos(t+vec2(0,11))\n#define cam1(U)   vec3( U+U, -3.5*R.y ) - R                      //  stupidely can't be done in raytrace\n\nvec3 _hit; float _shad;\nvec2 raytrace(vec3 U) {\n    vec3  p = vec3(0,0,50), D = normalize(U), q;                 // ray start & direction                             \n    vec2  M = 8.*CAM;                                            // stupidely can't call cam in common\n    \n        p.yz *= rot( .5 - M.y ), D.yz *= rot( .5 - M.y ),        // rotations\n        p.xz *= rot( 2. - M.x ), D.xz *= rot( 2. - M.x );\n    \n    // --- ray ( P = C+kD ) - cylinder (O,Z,r) intersection: ------------------\n    //    | OP - (OP.Z)Z | = r    |OP| - (OP.Z) = r -> second degree polynom in k\n    float a = 1. - D.z*D.z, b = dot(p,D) - p.z*D.z, c = dot(p,p) - p.z*p.z - 25.,\n          d = b*b - a*c, k, T=.925;\n\n    if ( d < 0. ) return vec2(0);                                // miss cylinder\n    \n#define getHit(sgn) {                                       \\\n      k = (-b sgn sqrt(d) ) / a;                            \\\n      q = p + k* D;                                         \\\n      s = 5.63* atan(q.y,q.x);   /* 4.77 */                 \\\n   /* r = vec2(s-q.z,s+q.z),             */                 \\\n      r = vec2(s,q.z)* mat2(cos(T+vec4(0,33,11,0))) *1.41,  \\\n      s = Amax(r);                                          \\\n      E = 6.28* 5.63* cos(T+vec2(0,11)) *1.41, /* bridge */ \\\n      s = min( s, Amax(r+E) );                              \\\n      s = min( s, Amax(r-E) );                              \\\n    }\n    float s; vec2 r,E;\n    getHit(-);                                                   // front\n    if ( s > 21. ) getHit(+);                                    // back\n    if ( s > 21. ) return vec2(0);                               // miss (sides)\n\n // q.xz  *= rot( -(2. - M.x) ), q.yz *= rot( -(.5 - M.y) );     // back to screen space\n // _hit = q;                                                    // return hit point and view-shading\n    _shad = abs( dot(q.xy,D.xy) / 5. );\n    return r/10.;                                                // coordinates on puzzle or 0\n}", "buffer_a_code": "// === manage camera and tile picking =========================================\n// (8,8)  xy : persistant normalized mouse.xy\n// (0,0)  xy : persistant clicked tile or -1.       w: currently clicked (down event)\n\n#define keyClicked(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define H(p)            fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U == vec2(9.5) ) { O = iMouse ; return; }              // memo mouse motion (for panning )\n    if ( U == vec2(8.5) ) { O = keyClicked(32) || T(9).z < 0. ? T(8) : T(8)+( iMouse - T(9) )/R.xyzz ; return; } // tune camera\n    if ( U != vec2(.5) )    discard;\n    if ( iFrame < 1 )     { O = vec4(-1); return; }             // init: no cell selected\n    bool demo = length(iMouse.xy)<10.  &&  iFrame%30 < 1 ;      // demo mode\n    if ( ! demo &&\n       ( ! keyClicked(32) || iMouse.z <= 0. )) { O = T(0); O.w = 0.; return; } // not clicking a tile\n    \n                                         // --- picking of tile clicked by mouse\n    cam0(iTime);                                                // this stupidely can't be done in common\n    vec2 r = demo ? 4.* H(iTime) - 2.\n                  : raytrace( cam1(iMouse.xy) ), a;             // picking at mouse pos\n    \n    O.xy = r==vec2(0) ? vec2(-1) : floor(r+2.);                 // return tile coord or -1\n // O.z  = 1. + O.x + 4.*O.y;                                   // tile id (unused)\n    O.w  = 1.;                                                  // currently clicked (down event)\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === manage usual 15 Puzzle game =====================================\n// 4x4 tiles (i,j)  x: cell id or 0   y: previous value  \n//                  z: time of click  w: move direction [-1,1] encoded as 0..8\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( max(U.x,U.y) > 4. ) discard;\n    O = T(U);                                              // restore state\n    U -= .5;\n    \n    if (iFrame < 1)                                        // initial set: shuffle \n        O.x = float( ( int( iDate.w + U.x + 4.*U.y )^11)*331 % 16 ), O.z = -9.; \n    \n    vec4 C = T1(0);                                        // clicked tile\n    if ( C.x < 0. || C.w < 1. ) return;                    // no one\n    \n    float n = T(C.xy).x;                                   // current tile id\n    vec2 A,D = vec2(0), E = vec2(1,0), S;\n    if      ( O.x == 0. ) {                                // we are on void tile \n        D = U - C.xy;                                      // if clicked tile is nearby (A.x+A.y=1)\n        if ( U==vec2(3) && C.xy==vec2(0) ) D = vec2(0,-1); //   bridge case\n        if ( U==vec2(0) && C.xy==vec2(3) ) D = vec2(0, 1);                        \n        S = vec2( n, 0 );                                  //   move C to void\n    }\n    else if ( O.x == n ) {                                 // we are on clicked tile\n        D.x =   U.x>0. && T(U-E   ).x==0. ? -1.            // if void tile is nearby (A.x+A.y=1)\n              : U.x<3. && T(U+E   ).x==0. ?  1. : 0.;\n        D.y =   U.y>0. && T(U-E.yx).x==0. ? -1.\n              : U.y<3. && T(U+E.yx).x==0. ?  1. : 0.;\n        if ( U==vec2(0) && T(3).x==0. ) D = vec2(0,-1);    //   bridge case\n        if ( U==vec2(3) && T(0).x==0. ) D = vec2(0, 1);                                \n        S = vec2( 0, n  );                                 //   move void to C \n    }\n    A = abs(D);\n    if  ( A.x+A.y==1. )                                    // move if nearby\n         D++, O = vec4( S, iTime, D.x+3.*D.y ); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 112, 194, 400], [402, 402, 438, 471, 2310]]}
{"id": "3scfD7", "name": "Even faster procedural ocean", "author": "jarble", "description": "This is a slightly improved version of [url=https://www.shadertoy.com/view/MdXyzX]\"Very fast procedural ocean\"[/url]. The precision of the rendering decreases as the distance from the camera increases.", "tags": ["waves", "sea", "water", "ocean", "seascape", "scape"], "likes": 105, "viewed": 4396, "published": 3, "date": "1605209929", "time_retrieved": "2024-07-30T20:35:37.028226", "image_code": "//afl_ext 2017-2019\n\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, Time);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    float eps = 0.01;\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\n        float dist_pos = distance(pos, camera);\n        if(h + eps*dist_pos > pos.y) {\n            return dist_pos;\n        }\n        pos += dir * (pos.y - h);\n        //eps *= 1.01;\n    }\n    return -1.0;\n}\n\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    float H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return (cross(normalize(a-vec3(pos.x - e, getwaves((pos.xy - ex.xy)*0.1, ITERATIONS_NORMAL) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwaves((pos.xy + ex.yx )* 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = (axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(Resolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\tsundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n\tfloat mymie = sundt * special_trick * 0.2;\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \t\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\n        //tonemapping\n    \tC = aces_tonemap(C);\n     \tfragColor = vec4( C,1.0);   \n        return;\n    }\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\n    //tonemapping\n    C = aces_tonemap(C);\n    \n\tfragColor = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 298, 298, 466], [468, 468, 514, 514, 1020], [1022, 1022, 1090, 1090, 1577], [1579, 1579, 1623, 1623, 1994], [1995, 1995, 2032, 2032, 2437], [2439, 2439, 2460, 2460, 2828], [2830, 2830, 2906, 2906, 2999], [3001, 3001, 3055, 3055, 3770], [3772, 3772, 3794, 3794, 3867], [3869, 3869, 3889, 3889, 3983], [3984, 3984, 4014, 4014, 4461], [4462, 4462, 4519, 4519, 5618]]}
{"id": "3s3BD7", "name": "Overlay Photoshop in Shaders", "author": "henrmota", "description": "Overlay like in photoshop;", "tags": ["overlay"], "likes": 4, "viewed": 681, "published": 3, "date": "1605204432", "time_retrieved": "2024-07-30T20:35:37.780215", "image_code": "vec4 overlay(vec4 target, vec4 blend) {\n    float gray = dot(target.xyz, vec3(0.21, 0.71, 0.07));\n    \n\treturn (gray > 0.5) ? (1. - (1.-2.*(gray-0.5)) * (1.-blend))\n\t: ((2.*gray) * blend);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = cos(iTime) * 0.5 + 0.5;\n    \n    // Time varying pixel color\n    vec4 col = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n\tvec4 text = texture(iChannel0, uv);\n    \n    vec4 target = text;\n    vec4 blend = col;\n                      \n    // Output to screen\n    fragColor = overlay(target, blend);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 194], [196, 196, 253, 303, 663]]}
{"id": "3s3BW7", "name": "Playing with 2d sdfs.", "author": "henrmota", "description": "Playing with sdf morphing", "tags": ["sdf"], "likes": 3, "viewed": 374, "published": 3, "date": "1605193786", "time_retrieved": "2024-07-30T20:35:38.528215", "image_code": "float circle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shade(float d) {\n\treturn clamp(-d * 500., 0., 1.);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\tfloat id = fract(sin(dot(floor(uv * 3.), vec2(145., 123.))) * 12345.) * 5. + 1.;\n    uv = fract(uv * 3.);\n    uv -= 0.5;\n    float dCircle = circle(uv, 0.5);\n    float dSquare = sdBox(uv, vec2(0.3));\n    \n    float t = sin(iTime * id) * 0.5 + 0.5;\n    \n    float ds = mix(dCircle, dSquare, t);\n  \n    \n    col += shade(ds);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 69], [71, 71, 100, 100, 180], [182, 182, 204, 204, 244], [246, 246, 303, 303, 753]]}
{"id": "WtXfzX", "name": "kundalinguini", "author": "xenn", "description": "propagation duration will vary. give it time", "tags": ["particles", "ca"], "likes": 15, "viewed": 459, "published": 3, "date": "1605183868", "time_retrieved": "2024-07-30T20:35:39.287186", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //border render\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n   \n    vec4 data = texel(ch0, pos);\n    particle P0 = getParticle(data, pos);\n\n    vec2 x0 = P0.X; //update position\n    //how much mass falls into this pixel\n    vec4 rho = vec4(P0.V, P0.M)*G((pos - x0)/0.75); \n    vec3 dx = vec3(-3., 0., 3.);\n \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.9, 1.);\n    // Output to screen\n    col.xyz = vec3(0.2*a); \n    col.xyz += 0.5 - 0.5*cos(8.*vec3(0.82,0.12,0.36)*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 0.5\n\n#define fluid_rho 0.2\n\n\n//mold stuff \n#define sense_ang sin(time*1.34)\n#define sense_dis 10.40*sin(time*01.1)\n#define sense_force 0.051\n#define trailing 0.0\n#define acceleration 0.0521\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.75*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.2333\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(0.0020*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [404, 404, 440, 440, 490], [492, 492, 508, 508, 536], [538, 538, 583, 583, 1438]]}
{"id": "wdtBDN", "name": "Desert Reflections 2", "author": "dr2", "description": "Desert reflections - modified to use polyhedra", "tags": ["landscape", "polyhedron", "sand"], "likes": 8, "viewed": 338, "published": 3, "date": "1605175035", "time_retrieved": "2024-07-30T20:35:40.217698", "image_code": "// \"Desert Reflections 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Desert reflections - modified to use polyhedra (with bits from \"Extreme Desert\",\n  \"Ozymandias Redux\" and \"Reflective Polyhedra\")\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, qHit, rPos, vc, vp[3];\nvec2 gId;\nfloat tCur, dstFar, hgSize, pType, sAng;\nint idObj;\nbool isOcc, isSh;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid PInit ()\n{\n  vec3 c;\n  float cp, sp;\n  cp = cos (pi / 5.);\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  vp[0] = vec3 (0., 0., 1.);\n  vp[1] = normalize (vec3 (sp, 0., 0.5));\n  vp[2] = normalize (vec3 (0., sp, cp));\n}\n\nfloat PolyhDf (vec3 p, float dMin)\n{ \n  vec3 q;\n  float d, cp, sp;\n  p /= 2.;\n  dMin /= 2.;\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  for (int j = 0; j < 5; j ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n  }\n  q = p - ((pType < 0.) ? vp[1] : vp[2]);\n  d = Minv3 (vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc))) - 0.05;\n  DMINQ (2);\n  d = Maxv3 (vec3 (dot (q, vp[0]), dot (q, vp[1]), dot (q, vp[2])));\n  DMINQ (3);\n  return 2. * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.4, 2.);\n    DMINQ (1);\n    q.y -= 3.8 + ((pType > 0.) ? 0.2 : 0.);\n    if (! isSh) d = PrSphDf (q, 2.1);\n    if (isSh || d < 0.1) {\n      q.xz = Rot2D (q.xz, sAng);\n      dMin = PolyhDf (q, dMin);\n    } else dMin = min (dMin, d);\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nvoid SetGrdConf ()\n{\n  float h;\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  h = Hashfv2 (19.1 * gId + 0.3);\n  isOcc = (h > 0.2);\n  pType = (h > 0.6) ? 1. : -1.;\n  sAng = 0.15 * pType * tCur;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.03, 2. * h);\n    if (h < 0.005) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac, nDotL;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj == 1) {\n    col = vec3 (0.7, 0.75, 0.8);\n    vn = VaryNf (16. * qHit, vn, 2. * dFac);\n  } else {\n    col = vec3 (0.9, 0.9, 1.);\n  }\n  nDotL = max (0., dot (vn, sunDir));\n  if (idObj == 2) nDotL *= nDotL;\n  col = col * (0.2 + 0.1 * max (0., - vn.y) + 0.8 * nDotL) +\n     0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.9, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.8 + 0.2 * smoothstep (0.4, 0.6, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  isSh = true;\n  sh = min (ObjSShadow (ro + 0.01 * vn, sunDir),\n     1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= (0.2 + 0.1 * vn.y + 0.7 * sh * max (0., dot (vn, sunDir))) * (0.7 + 0.3 * dFac);\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  PInit ();\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 3) {\n    isRef = true;\n    dstObjO = dstObj;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, zmFac, sunEl, sunAz, t, hSum, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  ro = TrackPath (t);\n  fpF = TrackPath (t + 1.);\n  fpB = TrackPath (t - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (t + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.002 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  zmFac = 3.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = flMat * (vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac)));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1002, 1002, 1017, 1017, 1239], [1241, 1241, 1277, 1277, 1804], [1806, 1806, 1828, 1828, 2243], [2245, 2245, 2268, 2268, 2524], [2526, 2526, 2546, 2546, 2824], [2826, 2826, 2859, 2859, 4132], [4134, 4134, 4155, 4155, 4410], [4412, 4412, 4449, 4449, 4879], [4881, 4881, 4915, 4915, 5395], [5397, 5397, 5419, 5419, 5558], [5560, 5560, 5585, 5585, 5964], [5966, 5966, 6010, 6010, 6209], [6211, 6211, 6233, 6233, 6327], [6329, 6329, 6361, 6361, 6691], [6693, 6693, 6739, 6739, 7314], [7316, 7316, 7364, 7364, 8394], [8396, 8396, 8431, 8431, 9147], [9149, 9149, 9180, 9180, 9449], [9451, 9451, 9477, 9477, 9590], [9592, 9592, 9648, 9648, 11210], [11212, 11212, 11245, 11245, 11272], [11274, 11274, 11316, 11316, 11367], [11369, 11369, 11391, 11391, 11429], [11431, 11431, 11453, 11453, 11491], [11493, 11493, 11517, 11517, 11747], [11749, 11749, 11773, 11773, 11833], [11835, 11835, 11865, 11865, 11978], [11980, 11980, 12016, 12016, 12222], [12256, 12256, 12280, 12280, 12410], [12412, 12412, 12436, 12436, 12496], [12498, 12498, 12523, 12523, 12709], [12711, 12711, 12732, 12732, 12887], [12889, 12889, 12918, 12918, 13130], [13132, 13132, 13171, 13171, 13351]]}
{"id": "wddfD4", "name": "Bytebeat synthesizer", "author": "jarble", "description": "This bytebeat music has an interesting harmony.", "tags": ["music", "bytebeat"], "likes": 4, "viewed": 301, "published": 3, "date": "1605161495", "time_retrieved": "2024-07-30T20:35:41.000604", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "common_code": "vec2 sound1(int t)\n{\n    //t += ((t/10))*10;\n    t = (t/(2))|(t/4)/((t*2)%16)|t/512;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    time *= 500.0;\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/10.0;\n}", "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time)/10.0;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "wstfD4", "name": "Alternate Rainbow", "author": "Plento", "description": "Electric tentacle? ", "tags": ["2d", "color"], "likes": 13, "viewed": 427, "published": 3, "date": "1605160795", "time_retrieved": "2024-07-30T20:35:41.850332", "image_code": "// Cole Peterson\n#define R iResolution\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec3 col = vec3(0);\n\n    float r = .47;\n    float n = 20.;\n    \n    for(float i = n; i > 0.; i--)\n    {\n        vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;;\n        uv *= (i*.007 + .2);\n        uv *= rot(i*.05);\n\t\tuv.x += iTime*.075;\n        if(iMouse.z>0.)uv-=m.x*.5;\n        vec2 id = floor(uv*8.);\n        \n        uv.y += sin(i*.5 + iTime*4. + id.y*345. + id.x*883.)*0.007;\n        uv.x += cos(i*.5 + iTime*4. + id.y*845. + id.x*383.)*0.007;\n        \n        vec2 ruv = fract(uv*8.)-.5;\n        id = floor(uv*8.);\n        \n        vec3 nc = .55+.3*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*0.05 + iTime*.6)*3.);\n        \n        float s = max(pow(dot(ruv, vec2(-.8, .5))*4.4, 4.0), 0.001);\n        nc *= abs(s)+.6;\n        nc *= ((n-i) / n);\n        \n    \tcol = mix(col, nc, smoothstep(r, r - .015, length(ruv)));\n        col *= 1.-smoothstep(0.01, 0.003, abs(length(ruv) - r+.005));\n        r -= .0215;\n    }\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 168], [170, 170, 211, 211, 1138]]}
{"id": "tstfD4", "name": "Line-Line Intersection", "author": "oneshade", "description": "I had some fun working out a line-line intersection formula today and made a shader to go with it. You can see (and interact with) it on desmos too if you would like. Desmos line-line intersection graph: https://www.desmos.com/calculator/o4acq0akw8", "tags": ["math", "lines", "intersection"], "likes": 4, "viewed": 644, "published": 3, "date": "1605157490", "time_retrieved": "2024-07-30T20:35:42.678119", "image_code": "float InfiniteLine(in vec2 p, in vec2 a, in vec2 b, in float thickness) {\n    vec2 pa = p - a, ba = b - a;\n    return smoothstep(thickness, 0.0, length(pa - ba * dot(pa, ba) / dot(ba, ba)));\n}\n\nfloat Point(in vec2 p, in vec2 o, in float r, in float softness) {\n    return smoothstep(softness, 0.0, length(p - o) - r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    // First line's control points:\n    vec2 a1 = vec2(cos(iTime * 0.3125), sin(iTime * 0.125)) * 0.5;\n    vec2 b1 = vec2(sin(iTime *  0.25), cos(iTime * 0.75)) * 0.5;\n\n    // Draw the first line's control points and the first line:\n    color += Point(uv, a1, 0.01, 0.01);\n    color += Point(uv, b1, 0.01, 0.01);\n\n    color += InfiniteLine(uv, a1, b1, 0.01);\n\n    // Second line's control points:\n    vec2 a2 = vec2(cos(iTime * 0.325), sin(iTime * 0.3125)) * 0.5;\n    vec2 b2 = vec2(sin(iTime * 0.325), cos(iTime *  0.125)) * 0.5;\n\n    // Draw the second line's control points and the second line:\n    color += Point(uv, a2, 0.01, 0.01);\n    color += Point(uv, b2, 0.01, 0.01);\n\n    color += InfiniteLine(uv, a2, b2, 0.01);\n\n    // Calculate their slopes and y-intercepts:\n    float deltaX1 = b1.x - a1.x;\n    float deltaX2 = b2.x - a2.x;\n\n    float slope1 = 1000000.0;\n    float slope2 = 1000000.0;\n\n    if (deltaX1 != 0.0) {\n        slope1 = (b1.y - a1.y) / deltaX1;\n    }\n\n    if (deltaX2 != 0.0) {\n        slope2 = (b2.y - a2.y) / deltaX2;\n    }\n\n    float yIntercept1 = a1.y - a1.x * slope1;\n    float yIntercept2 = a2.y - a2.x * slope2;\n\n    if (slope1 != slope2) {\n        // Calculate the intersection:\n        float intersectX = (yIntercept1 - yIntercept2) / (slope2 - slope1);\n        float intersectY = intersectX * slope1 + yIntercept1;\n\n        // Draw the intersection:\n        color += Point(uv, vec2(intersectX, intersectY), 0.025, 0.01);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 73, 73, 192], [194, 194, 260, 260, 319], [321, 321, 376, 376, 1979]]}
{"id": "wstfW4", "name": "Microscopic Gumdrop", "author": "Plento", "description": "This is what candy looks like under a microscope. Edit of my last shader: https://www.shadertoy.com/view/3s3BDN", "tags": ["2d", "color"], "likes": 8, "viewed": 331, "published": 3, "date": "1605147219", "time_retrieved": "2024-07-30T20:35:43.438088", "image_code": "// Fork of \"Party Hat Paradise\" by Plento. https://shadertoy.com/view/3s3BDN\n// 2020-11-12 01:39:10\n\n// Cole Peterson\n#define R iResolution\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n\n    if(iMouse.z > 0.) uv += m;\n    \n    float r = .5;\n    float n = 20.;\n    \n    //uv.x -= uv.y*uv.y * uv.x * 0.3;\n    //uv.y -= uv.x*uv.x * uv.y * 0.3;\n    \n    for(float i = 0.; i < n; i++)\n    {\n        uv.y += sin(i*0.5 + iTime*4.)*0.01;\n        uv.x += cos(i*0.5 + iTime*4.)*0.01;\n        \n        vec2 ruv = fract(uv*8.)-.5;\n        vec2 id = floor(uv*8.);\n        \n        vec3 nc = .8+.5*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*48.)*4.);\n        \n        float s = pow(dot(ruv, vec2(.5, .7))*3.8, 3.0);\n        nc += (.3+.4*cos(vec3(4.7,2.,8.4)*(id.x+id.y+i*38.))) * s;\n        nc *= (i / n);\n        \n    \tcol = mix(col, nc, smoothstep(r, r - .015, length(ruv)));\n        \n        uv *= (0.7 + cos(iTime*1.2)*0.324);\n        r -= 0.023;\n    }\n    col *= max(((1.-abs(uv.x*1.2)) * (1.-abs(uv.y*1.2))), 0.);\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 240, 240, 1140]]}
{"id": "tsdBW4", "name": "Adjustable Color Banding", "author": "oneshade", "description": "Simple adjustable color banding. I think that looks a lot more like toon shading now. Mouse x position controls the number of banding levels.", "tags": ["toon", "colorbanding"], "likes": 1, "viewed": 231, "published": 3, "date": "1605139509", "time_retrieved": "2024-07-30T20:35:44.192071", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse = iMouse.xy;\n    if (iMouse.z < 1.0) {\n        mouse = vec2(0.3 * iResolution.x, 0.0);\n    }\n\n    vec3 textureSample = texture(iChannel0, uv).rgb;\n    float colorSteps = mouse.x / iResolution.x * 10.0;\n    textureSample = normalize(textureSample) * (floor(length(textureSample) * colorSteps) / colorSteps);\n\n    fragColor = vec4(textureSample, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 464]]}
{"id": "wddBW4", "name": "recursive rectangle texture", "author": "mds2", "description": "riff on https://www.shadertoy.com/view/4lffWs inspired by http://www.algorithmic-worlds.net/blog/blog.php?Post=20110201", "tags": ["recursive", "feedback", "art"], "likes": 5, "viewed": 330, "published": 3, "date": "1605138987", "time_retrieved": "2024-07-30T20:35:44.944061", "image_code": "#define VIEW_RAW_BUFFER 0\n\nconst vec3 color1 = vec3(0.8, 0.6, 0.4);\nconst vec3 color2 = vec3(0.1, 0.2, 0.6);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#if VIEW_RAW_BUFFER\n    fragColor = texture(iChannel0, uv);\n#else\n    float val = step(0.1, length(texture(iChannel0, uv).rg));\n\tfragColor = vec4(mix(color1, color2, val), 1.0);\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    const float refresh_period = 15.0;\n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), sin(t),\n                          -sin(t), cos(t));\n    vec2 dir = step(vec2(0.98), texture(iChannel1, to_uv(rotator * p)).rg);\n    dir = vec2(step(dir.y, dir.x), step(dir.x, dir.y)) * dir;\n    \n    if (mod(iTime, refresh_period) > 0.5 * refresh_period && dot(dir, dir) < 0.5) {\n    \tvec2 raw_dir = texture(iChannel1, to_uv(rotator * p)).rg;\n        raw_dir = vec2(step(raw_dir.y, raw_dir.x), step(raw_dir.x, raw_dir.y)) * raw_dir;\n        if (raw_dir.r < texture(iChannel1, to_uv(rotator * p + vec2(0.0, 1.0))).r ||\n            raw_dir.r < texture(iChannel1, to_uv(rotator * p + vec2(1.0, 0.0))).r ||\n            raw_dir.r < texture(iChannel1, to_uv(rotator * p - vec2(0.0, 1.0))).r ||\n            raw_dir.r < texture(iChannel1, to_uv(rotator * p - vec2(1.0, 0.0))).r ) {\n            raw_dir.r = 0.0;\n        }\n        if (raw_dir.g < texture(iChannel1, to_uv(rotator * p + vec2(0.0, 1.0))).g ||\n            raw_dir.g < texture(iChannel1, to_uv(rotator * p + vec2(1.0, 0.0))).g ||\n            raw_dir.g < texture(iChannel1, to_uv(rotator * p - vec2(0.0, 1.0))).g ||\n            raw_dir.g < texture(iChannel1, to_uv(rotator * p - vec2(1.0, 0.0))).g ) {\n            raw_dir.g = 0.0;\n        }\n        \n        dir.rg = max(dir.rg, step(vec2(0.5), raw_dir));\n    }\n \n    if (mod(iTime, refresh_period) < 0.1) {\n      fragColor = vec4(dir, 0.0, 1.0);\n        return;\n    }\n   \n    if (dot(dir, dir) < 0.5) {\n\t    dir = step(vec2(0.9), texture(iChannel0, to_uv(p)).rg);\n    }\n     \n    if (dot(dir, dir) < 0.01) {\n    \tvec2 dir1 = vec2(1.0, 0.0);\n    \tvec2 dir2 = dir1.yx;\n        \n        \n    \tfloat val1 = max(abs(dot(dir1, fetch_dir(p + dir1))),\n                     \tabs(dot(dir1, fetch_dir(p - dir1))));\n        \n            \n    \tfloat val2 = max(abs(dot(dir2, fetch_dir(p + dir2))),\n        \t             abs(dot(dir2, fetch_dir(p - dir2))));\n        \n    \t\n        if (val1 > val2) {\n            val2 = 0.0;\n        } else {\n            val1 = 0.0;\n        }\n        \n        val1 = step(0.9, val1);\n        val2 = step(0.9, val2);\n        \n    \n    \tdir = mix(dir, dir1, val1);\n    \tdir = mix(dir, dir2, val2);\n    }\n    \n    dir = step(vec2(0.9), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n \n    fragColor = vec4(dir,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 167, 167, 396]]}
{"id": "3s3BDN", "name": "Party Hat Paradise", "author": "Plento", "description": "Shader", "tags": ["2d", "color"], "likes": 10, "viewed": 323, "published": 3, "date": "1605122998", "time_retrieved": "2024-07-30T20:35:45.694056", "image_code": "// Cole Peterson\n#define R iResolution\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n\t\n    vec3 col = vec3(0);\n\n    float r = .5;\n    float n = 20.;\n    \n    for(float i = 0.; i < n; i++)\n    {\n        uv.y += sin(i*0.5 + iTime*4.)*0.01;\n        uv.x += cos(i*0.5 + iTime*4.)*0.01;\n        \n        vec2 ruv = fract(uv*2.)-.5;\n        vec2 id = floor(uv*2.);\n        \n        vec3 nc = .8+.5*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*48.)*4.);\n        nc *= (i+0.7) / n;\n        \n    \tcol = mix(col, nc, smoothstep(r, r - .015, length(ruv)));\n        \n        uv *= 1.04;\n        r -= 0.023;\n    }\n    col *= ((1.-abs(uv.x*.3)) * (1.-abs(uv.y*.3)))*1.1;\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 81, 81, 707]]}
{"id": "WsdBD4", "name": "[jFig2020] Student-t NDF", "author": "H4w0", "description": "This is my submission to the jFig 2020 rendering contest. \nImplementing the Student-t normal distribution function from Ribardiere et al. (2017)\nAnd also a modified procedural solid phasor noise using a 3D simplex grid.", "tags": ["ndf", "phasor", "jfig", "studentt"], "likes": 7, "viewed": 437, "published": 3, "date": "1605115025", "time_retrieved": "2024-07-30T20:35:46.621576", "image_code": "//=======================================================\n//= [jFIG2020] Isotropic Student-t NDF\n//=======================================================\n//== Here is my humble submission to the jFig 2020 rendering contest.\n//== This shadertoy contains an implementation of an isotropic student-t normal distribution function (NDF for short).\n//== This NDF was introduced by Ribardiere et al. in 2017 in the following paper \n//== *- STD: Students t-Distribution of Slopes for Microfacet Based BSDFs\n//==\t(PROJECT PAGE : https://mribar03.bitbucket.io/projects/eg_2017/)\n//==\n//== By tuning the gamma parameter between 2.0 and +inf you can change the tail of the lobe.\n//== When gamma is equal to 2.0, the lobe is the same as a GGX.\n//== When gamma tends to infinity, the lobe tends to a Beckmann one.\n//==\n//== The sphere is procedurally textured using a modified solid phasor noise \n//== *- Procedural Phasor Noise (by Tricard and Efremov et al. 2019 (ARTICLE : https://hal.inria.fr/hal-02118508))\n//== I used a local random phase noise formulation which is based on a sum of cosines on a regular grid.\n//== As a grid I used a simplex grid to only sum 4 noise contributions at a position.\n//== To animate the procedural solid texture I modified a pulse with modulation using a cosine wave.\n//==\n//== I used the cubmap buffer to pre-render the scene without the sphere to add a fake reflection.\n//=======================================================\n//== Remarks :\n//== *- This WebGL implementation is not quite numerically stable depending on the gamma parameter\n//== \tso i clamped it to 10.\n//=======================================================\n//== Controls : \n//== *-\tThe mouse X axis controls the roughness of the isotropic microfacet NDF\n//== *- The mouse Y axis constrol the gamma parameters which is remap between 2.0 and 10.0\n//=======================================================\n//== NDF Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- NDFs are expressed using the slope distribution function P22\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Some equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//=======================================================\n//== I also used some code from :\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy (https://www.shadertoy.com/view/4sSSW3)\n//== *- @iq shaders\n//== \t- Intersectors ( Plane and Sphere )\n//== \t- HSV and HSL ( hsv2rgb from https://www.shadertoy.com/view/lsS3Wc)\n//== \t- Filtered Checkerboards (https://iquilezles.org/articles/checkerfiltering)\n//== *- Thibault Tricard phasor noise implementations (check https://www.shadertoy.com/user/ThibaultTricard)\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\nconst float metallic = 0.;\t\t// 0. or 1.\nconst float reflectance = 0.35; // [0.35;1]\nconst float MIN_GAMMA = 2.0;\t\nconst float MAX_GAMMA = 10.0;\t// Due to numerical issues 10 is the maximal gamma\n\nconst uint JFIGW = 32u;\nconst uint JFIGH = 18u;\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Student Distribution -----------------------------------------------------\nfloat p22_student_t_isotropic(float x, float y, float alpha, float gamma)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma = alpha * m_i_sqrt_2;\n    float two_sigma_sqr = sigma*sigma*2.f;\n    float alpha_sqr = alpha*alpha;\n\n    return(\n            ( pow(gamma - 1.,gamma)*pow(m_sqrt_2*sigma,2.*gamma-2.) )\n    / //-------------------------------------------------------------------\n        ( m_pi*pow( (gamma-1.)*two_sigma_sqr + x_sqr + y_sqr, gamma) )\n    );\n}\n\nfloat ndf_student_t_isotropic(vec3 omega_h, float alpha, float gamma)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float std_p22 = p22_student_t_isotropic(slope_x,slope_y,alpha,gamma);\n    return(\n                  std_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_student_t_isotropic(vec3 omega, float alpha, float gamma)\n{\n    float tan_theta  = tan_theta(omega);\n    if(tan_theta==0.) \n    {return 0.;}\n    \n    /* fixed mistake */\n    float root     = alpha * tan_theta;\n    float rootInv  = 1. / root;  \n    float lambda   = 0.; \n\n    float S1 = root * pow(gamma-1.+rootInv*rootInv , 1.5-gamma);\n    float S2 = F_21(rootInv)*F_22(gamma)*F_23(gamma)*F_24(rootInv);\n    float F1 = pow(gamma-1.,gamma) / (2.*gamma-3.);\n    float F2 = Gamma_Approx(gamma-0.5f) / (sqrt(m_pi)*Gamma_Approx(gamma));\n\n    lambda = (S1*F1 + S2*sqrt(gamma-1.))*F2 - 0.5f;\n\n    return( max(lambda,0.) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy)\n{\n   vec2  mouse = clamp(iMouse.xy / iResolution.xy ,0.,1.);\n   float roughness = remap(clamp( mouse.x , 0., 1. ) , 0.01, 1., 0.1, 0.5);\n   float gamma = remap(clamp( mouse.y , 0., 1. ) , 0.01, 1., MIN_GAMMA, MAX_GAMMA);\n    \n   vec3  color = get_background_color(rd);\n\n   int id = -1;\n   float tmin = 1e10;\n   float occlusion = 1.;\n   vec3 pos = vec3(0.);\n   vec3 nor = vec3(0.);\n   vec3 alb = vec3(0.5);\n\n   float plane_hit = plane_get_hit(ro,rd,PLANE);\n   if(plane_hit > 0.0)\n   {\n      \ttmin = plane_hit;\n      \tid = 0;\n      \tpos = ro+plane_hit*rd;\n      \tnor = PLANE.xyz;\n      \tocclusion = 1. - sphere_occlusion(pos,nor,SPHERE);\n\n      \tvec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n      \tvec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n      \tfloat checker = checkersGradBox( pos.xz, dpdx.xz, dpdy.xz );\n      \tcolor = render_plane(pos,nor,rd,vec3(checker),occlusion);\n\t}\n\n   float sphere_hit = sphere_get_hit(ro,rd,SPHERE);\n   if(sphere_hit> 0.0 && sphere_hit<tmin) \n   {\n      \tid = 1;\n      \ttmin = sphere_hit;\n      \tpos = ro + sphere_hit * rd;\n      \tnor = sphere_get_normal(pos,SPHERE);\n      \tocclusion = 0.5+0.5*nor.y;\n      \n      \t// now it's time to procedurally texturing the sphere\n       \n      \t// Using JFig logo as a mask\n      \tvec2 uv = vec2( 0.5 + atan(nor.x,nor.z)/m_2_pi , 0.5 - asin(-nor.y) / m_pi ); // Using sphere uv mapping (and reverse the normal y to flip the logo)\n      \tvec2 id = floor(uv*3.);\n       \tvec2 coords = fract(uv*3.) * vec2(JFIGW, JFIGH) * when_eq(id.y,1.);\n\n      \t// noise parameters \n      \tfloat pulse = 1.+cos(iTime);\n      \tvec2 freq = 2.5 + vec2(0,pulse);\n      \tvec2 orient = vec2(iTime,0.0);\n\n      \tfloat mask = smoothstep(0.0,1.0,0.5+0.3*cos(0.5*iTime));\n      \tif( jfig(uint(coords.x),uint(coords.y)) )\n      \t{\n        \tmask = 1.0;\n      \t}\n      \n       \tfloat noise = simplex_solid_random_phasor_noise( pos*5., 5, freq, orient, 1., 1.-mask);\n      \n      \n\t\talb = pow( hsv2rgb(vec3(0.5+0.5*cos(0.1*iTime),0.6,0.95)) , vec3(2.2));\n      \talb *= noise;\n      \n   }\n\n   if(id > 0)\n   {\n      \t// World Space \n      \tvec3 P = pos;\n      \tvec3 N = nor;   \n      \tvec3 L = get_light_direction();\n      \tvec3 V = -rd;\n      \tvec3 R = reflect(rd,nor);\n      \t// Tangent Space\n      \tmat3 TBN   = orthonormal_basis(N);\n      \tmat3 TBN_t = transpose(TBN);\n      \tvec3 wo = normalize(TBN_t * V);\n      \tvec3 wi = normalize(TBN_t * L);\n      \tvec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n      \tvec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)  \n\n      \tfloat wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n      \tfloat wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n      \n \t\t//-- Filament BRDF parametrization\n      \t//-- Single scattering\n      \t//-- diffuse lambertian term + specular term\n      \tfloat alpha = roughness*roughness;\n      \tvec3  base_color  = alb;\n      \tvec3  F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;    \n\t\tvec3  F = fresnel_schlick(wi_dot_wh,F0);\n      \n      \t//-- Sun Lighting\n      \tfloat lambda_wo = lambda_student_t_isotropic(wo,alpha,gamma);\n      \tfloat lambda_wi = lambda_student_t_isotropic(wi,alpha,gamma);\n      \tfloat D = ndf_student_t_isotropic(wh,alpha,gamma);\n      \tfloat G = 1. / (1. + lambda_wo + lambda_wi);    \n      \n      \tvec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ; \n      \tvec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n      \n      \tvec3 sun = wg_dot_wi * (diffuse_lambert + specular_microfacet);\n       \n      \t// fake ambiant term\n      \tcolor = 0.05*occlusion*alb;\n      \t// fake bounce shading term\n      \tcolor += F*m_i_pi*texture(iChannel0,N,alpha*20.).rgb;\n      \t// microfacet sun shading term\n      \tcolor += sun;  \n   \n   }\n   color = apply_fog(color,get_background_color(rd),tmin);\n   return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   float speed = 0.3*iTime;\n   float radius = 3.;\n   \n   vec3 ro = vec3( radius * cos(speed), 0.25 , radius * sin(speed) );\n   vec3 ta = vec3(0.,-0.25,0.);\n\n   vec2 p  = (2.*(fragCoord              )-iResolution.xy)/iResolution.y;\n   vec2 px = (2.*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n   vec2 py = (2.*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n\n   vec3 rd = compute_camera_ray_direction(p, ro, ta, 0.);\n   vec3 rdx = compute_camera_ray_direction(px, ro, ta, 0.);\n   vec3 rdy = compute_camera_ray_direction(py, ro, ta, 0.);\n\n   fragColor = vec4( render(ro,rd, rdx, rdy) , 1.);\n   fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Noise User Parameters ----------------------------------------------------------\nconst uint  LRPN_GLOBAL_SEED \t= 0u;\nconst int   LRPN_COSINES \t\t= 5;\nconst float LRPN_SCALE_FREQ \t= 10.;\nconst float LRPN_SCALE_SPACE \t= 1.;\nconst float LRPN_MAGNITUDE \t\t= 1.;\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359; \nconst float m_pi_2      = 1.5707963267; \nconst float m_2_pi      = 6.2831853071; \nconst float m_i_pi      = 0.31830988618; \nconst float m_sqrt_2    = 1.41421356237;\nconst float m_i_sqrt_2  = 0.70710678119; \n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;  \n\nconst bool  USE_DIFFUSE_TERM = true;\nconst vec4  SPHERE = vec4(0.,0.,0.,1.);\nconst vec4  PLANE  = vec4(0.,1.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-1.5,1.5,0.1));\nconst vec3  BACKGROUND_COLOR = vec3(0.5,0.6,1.0);\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat get_light_intensity()            { return LIGHT_INTENSITY; }\nvec3  get_light_direction()            { return LIGHT_DIRECTION; }\nvec3  get_background_color(in vec3 rd) { return BACKGROUND_COLOR; }\n\n//-----------------------------------------------------------------------------\n//-- Utils --------------------------------------------------------------------\nfloat remap(float v, float oldmin, float oldmax, float newmin, float newmax)\n{\n \treturn( newmin + (v-oldmin) * (newmax-newmin)/(oldmax-oldmin)  );   \n}\n\nfloat when_eq(float x,float y)\n{\n    return(1.0-abs(sign(x-y)));\n}\n\n// from iq's HSV and HSL (https://www.shadertoy.com/view/lsS3Wc)\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0.f, 1.f - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 1.f : clamp(w.x / sin_theta(w), -1.f, 1.f);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.f) ? 0.f : clamp(w.y / sin_theta(w), -1.f, 1.f);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n          \n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n   return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n// from @nimitz's \"Cheap orthonormal basis\" on Shadertoy (https://www.shadertoy.com/view/4sSSW3)\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n   vec3 oc = ro - sph.xyz;\n   float b = dot( oc, rd );\n   float c = dot( oc, oc ) - sph.w*sph.w;\n   float h = b*b - c;\n   if( h<0.0 ) return(-1.0);\n   h = sqrt( h );\n   return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n   return normalize(pos-sph.xyz);\n}\n\nfloat sphere_soft_shadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n   vec3 oc = ro - sph.xyz;\n   float b = dot( oc, rd );\n   float c = dot( oc, oc ) - sph.w*sph.w;\n   float h = b*b - c;\n   \n   float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n   float t = -b - sqrt( max(h,0.0) );\n   return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t ); \n} \n\nfloat sphere_occlusion(vec3 pos, vec3 nor, vec4 sph )\n{\n   vec3  di = sph.xyz - pos;\n   float l  = length(di);\n   float nl = dot(nor,di/l);\n   float h  = l/sph.w;\n   float h2 = h*h;\n   float k2 = 1.0 - h2*nl*nl;\n\n   float res = max(0.0,nl)/h2;\n   if( k2 > 0.0 ) // approx. for penetration\n   {\n      res = clamp(0.5*(nl*h+1.0)/h2,0.0,1.0);\n      res = sqrt( res*res*res );\n   }\n   return res;\n}\n\n//-----------------------------------------------------------------------------\n//-- Plane Intersection Functions --------------------------------------------\nfloat plane_get_hit(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n   return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\nvec3 plane_get_normal(in vec4 plane)\n{\n   return(plane.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Procedural Checkerboard --------------------------------------------------\n// from IQ's https://iquilezles.org/articles/checkerfiltering\nfloat checkers( in vec2 p )\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n//-----------------------------------------------------------------------------\n//-- Simple fog ---------------------------------------------------------------\nvec3 apply_fog(vec3 color, vec3 skycolor, float dist)\n{\n\treturn mix( color, skycolor, vec3( 1.0-exp( -0.0001*dist*dist*dist)) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Shading ------------------------------------------------------------------\nvec3 diffuse_shading_sky(in vec3 V, in vec3 N, in vec3 albedo)\n{\n   return clamp(dot(N,vec3(0.,1.,0.)),0.0,1.0)*m_i_pi*albedo*get_background_color(V);\n}\n\nvec3 diffuse_shading_sun(in vec3 V, in vec3 N, in vec3 L, in vec3 albedo)\n{\n   vec3 diffuse  = clamp( dot(N,L), 0.0, 1.0 ) * m_i_pi * albedo; \n   return diffuse;\n}\n\nvec3 render_plane(vec3 P, vec3 N, vec3 rd, vec3 alb, float occ)\n{\n\tvec3 L = get_light_direction();\n    vec3 color = 0.05*occ*alb;\n    color += diffuse_shading_sky(rd,N,alb) * sphere_soft_shadow( P+m_eps_4f*N, N, SPHERE, 1.0 );\n    color += diffuse_shading_sun(rd,N,L,alb) * sphere_soft_shadow( P+m_eps_4f*N, L, SPHERE, 2.0 );\n\treturn(color);\n}\n\n//-----------------------------------------------------------------------------\n//-- Student t utils ----------------------------------------------------------\nfloat abgam(float x)\n{\n  float gam0 = 1./ 12.;\n  float gam1 = 1./ 30.;\n  float gam2 = 53./ 210.;\n  float gam3 = 195./ 371.;\n  float gam4 = 22999./ 22737.;\n  float gam5 = 29944523./ 19733142.;\n  float gam6 = 109535241009./ 48264275462.;\n  float temp = 0.5*log(2.f*m_pi) - x + (x - 0.5)*log(x)\n    + gam0/(x + gam1/(x + gam2/(x + gam3/(x + gam4 /\n      (x + gam5/(x + gam6/x))))));\n\n  return temp;\n}\n\nfloat Gamma_Approx(float x)\n{\n  return( exp(abgam (x + 5.))/(x*(x + 1.)*(x + 2.)*(x + 3.)*(x + 4.)) );\n}\n\nfloat F_21(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n           (1.066*nu + 2.655*nu_2 + 4.892*nu_3)\n    / //---------------------------------------------------------------\n        ( 1.038 + 2.969*nu + 4.305*nu_2 + 4.418* nu_3)\n    ); \n}\n\nfloat F_24(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n          (6.537 + 6.074*nu - 0.623*nu_2 + 5.223*nu_3)\n    / //---------------------------------------------------------------\n          (6.538 + 6.103*nu - 3.218*nu_2 + 6.347*nu_3)\n    ); \n}\n\nfloat F_22(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (14.402 - 27.145*gamma + 20.574*gamma_2 - 2.745*gamma_3)\n    / //---------------------------------------------------------------\n        ( -30.612 + 86.567*gamma - 84.341*gamma_2 + 29.938* gamma_3)\n    ); \n}\n\nfloat F_23(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (-129.404 + 324.987*gamma - 299.305*gamma_2 + 93.268*gamma_3)\n    / //---------------------------------------------------------------\n          ( -92.609 + 256.006*gamma - 245.663*gamma_2 + 86.064* gamma_3)\n    ); \n}\n\n//----------------------------------------------------------------------------------\n// PRNG ----------------------------------------------------------------------------\n\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Galerne et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\nuint  wang_hash(uint seed)                                      {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)         {const uint period=1024u; uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  cell_seed(const in ivec3 c, const in uint offset)         {const uint period=1024u; uint s=(((((uint(c.z)%period)*period)+(uint(c.y)%period))*period)+(uint(c.x)%period))+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                      {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                          {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma){return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\n\n//-----------------------------------------------------------------------------\n//-- Simplex Solid LRPN Code --------------------------------------------------\nfloat gaussian_window_3D(in vec3 st, in float c, in float s)\n{\n   mat3 sig = mat3(s);\n   float body = -0.5*dot(st,inverse(sig)*st);\n   return c*exp(body);\n}\n\nvec2 local_random_phase_noise(\n    \tin ivec3 vertex_index,\n    \tin vec3  noise_coords,\n    \tin int   nof_cosines,\n    \tin vec2  range_frequency,\n        in vec2  range_orientation,\n    \tin float window_magni,\n    \tin float window_width\n\t)\n{\n   uint seed    = cell_seed(vertex_index,LRPN_GLOBAL_SEED);\n   uint prng    = wang_hash(seed);\n\n   vec2 sc = vec2(0.); \n   for(int k=0; k<nof_cosines; k++)\n   {\n      float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y); \t // pick a frequency \n      float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y); // pick an orientation\n      float ph = myrand_uniform_0_1(prng)*m_2_pi; // pick a phase (shift)\n  \n      float omega_r = fr;\n      float omega_t = or;\n      float omega_p = acos(myrand_uniform_0_1(prng)*2.-1.);\n      vec3 F = omega_r * vec3(cos(omega_t) * sin(omega_p), sin(omega_t) * sin(omega_p), cos(omega_p));\n      \n      sc.x +=  cos(m_2_pi* dot(F, noise_coords) + ph);\n      sc.y +=  sin(m_2_pi* dot(F, noise_coords) + ph);\n   }\n   return gaussian_window_3D(noise_coords,window_magni,window_width) * sc / float(nof_cosines);\n}\n\nfloat simplex_solid_random_phasor_noise(\n    \tin vec3  P, // Evaluation Point\n    \tin int   C, // Number of Cosines\n    \tin vec2  F, // Frequency Range (freq_min ; freq_max) \n    \tin vec2  O, // Orientation Range (theta_min ; theta_max)\n    \tin float K,  // Gaussian Window Magnitude\n      in float mask\n\t)\n{\n   const float F3 = 0.333333333; /* -> 1/3 */\n   const float G3 = 0.166666667; /* -> 1/6 : distance edge-to-edge of the simplex grid */\n   /* i think it should tend to 1/6*1/3 to reach zero at the width of the gaussian window (3*\\sigma ~ 0)*/\n   /* but i chose a narrower width because of some tetrahedral artefacts...*/\n   const float WW = 0.03;\n   \n   vec3 i = floor(P + (P.x + P.y + P.z) * F3);\n   vec3 d0 = P - (i - (i.x + i.y + i.z) * G3);\n   vec3 e = step(vec3(0.0), d0 - d0.yzx);\n   vec3 i1 = e * (1.0 - e.zxy);\n   vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n   \n   vec3 d1 = d0 - (i1 - 1. * G3);\n   vec3 d2 = d0 - (i2 - 2. * G3);\n   vec3 d3 = d0 - (1. - 3. * G3);   \n   \n   vec2 n0 = local_random_phase_noise(ivec3(i + 0.), d0, C, F, O, K, WW);\n   vec2 n1 = local_random_phase_noise(ivec3(i + i1), d1, C, F, O, K, WW);\n   vec2 n2 = local_random_phase_noise(ivec3(i + i2), d2, C, F, O, K, WW);\n   vec2 n3 = local_random_phase_noise(ivec3(i + 1.), d3, C, F, O, K, WW);\n   vec2 N = n0+n1+n2+n3;\n\n   float Phi = atan(N.y,N.x);\n   return( PWM(Phi,mask) );\n}\n\n/* Beware Neyret2 is watching you ! */", "cube_a_code": "//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n   vec2  mouse = clamp(iMouse.xy / iResolution.xy ,0.,1.);\n   float roughness = clamp( 0.01 + mouse.x , 0., 0.5 );\n   float gamma = 1.51 + clamp( 0.01 + mouse.y , 0., 1. )*5.;\n\n   //vec3 color = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n   vec3 color = get_background_color(rd);\n\n   int id = -1;\n   float tmin = 1e10;\n   float occlusion = 1.;\n   vec3 pos = vec3(0.);\n   vec3 nor = vec3(0.);\n   vec3 alb = vec3(0.5);\n\n   float plane_hit = plane_get_hit(ro,rd,PLANE);\n   if(plane_hit > 0.0)\n   {\n      tmin = plane_hit;\n      id = 1;\n      pos = ro+plane_hit*rd;\n      nor = PLANE.xyz;\n      float checker = checkers( pos.xz );\n      alb = vec3(checker);\n   }\n\n   if(id >= 0)\n   {\n      color = render_plane(pos,nor,rd,alb,occlusion);\n   }\n   color = apply_fog(color,get_background_color(rd),tmin);\n   return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainCubemap( out vec4 fragColor,  in vec2 fragCoord, \n                  in vec3  fragRayOri, in vec3 fragRayDir )\n{  \n  \tif(iFrame>1)\n   \t{\n       discard;\n   \t}\n    \n   fragColor = vec4( render(fragRayOri,fragRayDir) , 1.);\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3518, 3518, 3551, 3551, 3691], [3694, 3854, 3929, 3929, 4330], [4332, 4332, 4403, 4403, 4818], [4820, 4820, 4892, 4892, 5450], [5452, 5612, 5666, 5666, 5721], [5726, 5726, 5789, 5789, 9616], [9619, 9619, 9676, 9676, 10343]]}
{"id": "wdcczn", "name": "Sin transition", "author": "ElMehdiBouamama", "description": "Minimal code for a grid (Used for debugging purposes)", "tags": ["grid"], "likes": 2, "viewed": 289, "published": 3, "date": "1605110015", "time_retrieved": "2024-07-30T20:35:47.368578", "image_code": "#define grid_opacity 1.\n#define anti_aliasing 0.007\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\tuv *= 10.;\n    // Time varying pixel color\n    float distance = length(uv);\n    \n    float y = sin(iTime) * abs(distance * (uv.y + uv.y)) + cos(iTime);\n    float x = cos(iTime) * abs(distance * (uv.x + uv.x)) + sin(iTime);\n\tfloat angle = atan(atan(x),atan(y));\n    \n    float color = fract(atan(distance,angle));\n\tfloat colo = fract(fract(angle)*(uv.x-uv.y));\n    //color *= atan(colo);\n    vec3 col = vec3(color,0., .6) * 1.3;\n    // Output to screens\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 160, 711]]}
{"id": "wt2BDm", "name": "Face Shader", "author": "ElMehdiBouamama", "description": "Tile Shader ", "tags": ["bloomywavyproceduraltextureblackwhite"], "likes": 3, "viewed": 313, "published": 3, "date": "1605110009", "time_retrieved": "2024-07-30T20:35:48.154477", "image_code": "#define SCALE 3.\n#define TIMESCALE 1.\n\n#define ORANGE vec3(.9,.5,0.)\n#define WHITE_BLUE vec3(0.,.4,.9)\n#define PURPLE vec3(0.76,0.24,0.89)\n#define BLUE vec3(0.,0.,.8)\n#define BLACK vec3(0)\n#define WHITE vec3(.98)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = SCALE * (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0);\n    float g = -2.;\n    center.x+=sin(uv.y*g+iTime*TIMESCALE);\n    center.y+=cos(uv.x*g+iTime*TIMESCALE);\n    float d = distance(uv ,center);\n\tfloat k = abs(sin(d*6.14 - iTime*TIMESCALE));\n    k *= tanh(d/k)/tanh(k)/center.x/center.y;\n    vec3 col = mix(vec3(.83,.5,.4), WHITE, k);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2BDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 271, 271, 684]]}
{"id": "ws3cD2", "name": "Hallucinating pattern", "author": "z0rg", "description": "A random pattern for fun", "tags": ["shrooms"], "likes": 14, "viewed": 342, "published": 3, "date": "1605094740", "time_retrieved": "2024-07-30T20:35:48.904472", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat cir(vec2 p, float r)\n{\n  return length(p)-r;\n}\n\nvec3 rdr(vec2 uv)\n{\n  uv*=r2d(.1*iTime+length(uv)*.5);\n  vec3 col=vec3(0.);\n\n  float l = abs(sin(uv.y*30.+20.*sin(.5*iTime+uv.x*5.*length(uv*.2))))-2.3*(.1+.2*sin((uv.x+uv.y)*5.+iTime));\n\n  col = mix(col,vec3(1.),1.-sat(l));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  float dist = (sin(-iTime*5.+(uv.x+uv.y)*5.)*.5+1.)*0.08;\n\n  vec2 dir = normalize(vec2(1.));\n  vec3 col;\n  col.r = rdr(uv+dir*dist).r;\n  col.g = rdr(uv).g;\n  col.b = rdr(uv-dir*dist).b;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv =( fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n  uv*=3.5;\n\n  vec3 col = rdr2(uv);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cD2.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 446, 446, 521], [523, 523, 551, 551, 575], [577, 577, 596, 596, 817], [819, 819, 839, 839, 1042], [1044, 1044, 1101, 1101, 1232]]}
{"id": "wscfW4", "name": "Skylinear, a Skyline fork", "author": "UrbanClubProfessional", "description": "A remix/fork of \"Skyline\" by otaviogood.", "tags": ["procedural", "raymarch", "remix", "glitch", "green", "fork", "city", "weird", "skyline", "traffic"], "likes": 4, "viewed": 964, "published": 3, "date": "1605085500", "time_retrieved": "2024-07-30T20:35:49.920755", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 60.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 26.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 2.0;\n\n// Animation variables\nfloat fade = 2.0;\nvec3 sunDir;\nvec3 sunCol;\nfloat exposure = 2.0;\nvec3 skyCol, horizonCol;\n\n// other\nfloat marchCount = 0.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 47.0 + a.z * 621.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 47.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*20403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(sin(f)*204003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f)*vec2(20003.579, 47049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(20003.579, 47049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*243.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(sin(f)*204003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 47.0 + uv.z * 621.0;\n    return fract(sin(f)*210003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(4.0-3.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 2.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=4.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 2.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 2.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 2.0 - (dot(localRay, sunDir) * 0.6 + 0.6);\n\tfloat sunIntensity = 0.06 / dist;\n    sunIntensity += exp(-dist*250.0)*8000.0;\n\tsunIntensity = min(sunIntensity, 50000.0);\n\treturn sunCol * sunIntensity*0.035;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.57))*.55;\n    // make clouds - just a horizontal plane with noise\n    float n = noise2d(rayDir.xz/rayDir.y*2.0);\n    n += noise2d(rayDir.xz/rayDir.y*3.0)*0.6;\n    n += noise2d(rayDir.xz/rayDir.y*5.0)*0.35;\n    n += noise2d(rayDir.xz/rayDir.y*9.0)*0.225;\n    n = pow(abs(n), 4.0);\n    n = mix(n * 0.3, n, saturate(abs(rayDir.y * 9.0)));  // fade clouds in distance\n    finalColor = mix(finalColor, (vec3(2.0)+sunCol*20.0)*0.85*saturate((rayDir.y+0.3)*6.0), saturate(n*0.225));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir);\n    return finalColor;\n}\n\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\n{\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\n\n    // Make a skyscraper skyline reflection.\n    float radial = atan(rayDir.z, rayDir.x)*5.0;\n    float skyline = floor((sin(6.3456*radial) + sin(2.234*radial)+ sin(3.177*radial))*0.7);\n    radial *= 5.0;\n    skyline += floor((sin(6.0*radial) + sin(2.234*radial)+ sin(3.177*radial))*0.7)*0.2;\n    float mask = saturate((rayDir.y*9.0 - skyline-3.5+height)*34.0);\n    float vert = sign(sin(radial*42.0))*0.6+0.6;\n    float hor = sign(sin(rayDir.y*356.0))*0.6+0.6;\n    mask = saturate(mask + (2.0-hor*vert)*0.06);\n    finalColor = mix(finalColor * vec3(0.2,0.08,0.06), finalColor, mask);\n\n\treturn finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad)\n{\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nfloat Repeat(float a, float len)\n{\n    return mod(a, len) - 0.6 * len;\n}\n\n// Distance function that defines the car.\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\nvec2 Car(vec3 baseCenter, float unique)\n{\n    // bottom box\n    float car = sdBox(baseCenter + vec3(0.0, -0.009, 0.002), vec3(0.02, 0.00325, 0.0375));\n    // top box smooth blended\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.026, 0.009), vec3(0.006, 0.0006, 0.02)), -160.0);\n    // mirror the z axis to duplicate the cylinders for wheels\n    vec3 wMirror = baseCenter + vec3(0.0, -0.006, 0.0);\n    wMirror.z = abs(wMirror.z)-0.03;\n    float wheels = cylCap((wMirror).zyx, 0.005, 0.0235);\n    // Set materials\n    vec2 distAndMat = vec2(wheels, 4.0);\t// car wheels\n    // Car material is some big number that's unique to each car\n    // so I can have each car be a different color\n    distAndMat = matmin(distAndMat, vec2(car, 200000.0 + unique));\t// car\n    return distAndMat;\n}\n\n// How much space between voxel borders and geometry for voxel ray march optimization\nfloat voxelPad = 0.3;\n// p should be in [0..1] range on xz plane\n// pint is an integer pair saying which city block you are on\nvec2 CityBlock(vec3 p, vec2 pint)\n{\n    // Get random numbers for this block by hashing the city block variable\n    vec4 rand;\n    rand.xy = Hash22(pint);\n    rand.zw = Hash22(rand.xy);\n    vec2 rand2 = Hash22(rand.zw);\n\n    // Radius of the building\n    float baseRad = 0.2 + (rand.x) * 0.1;\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\n\n    // make position relative to the middle of the block\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\n    float height = rand.w*rand.z + 0.2; // height of first building block\n    // Make the city skyline higher in the middle of the city.\n    float downtown = saturate(5.0 / length(pint.xy));\n    height *= downtown;\n    height *= 2.5+(baseRad-0.25)*30.0;\n    height += 0.2;\t// minimum building height\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\n    height = floor(height*30.0)*0.06;\t// height is in floor units - each floor is 0.05 high.\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\n\n    // road\n    d = min(d, p.y);\n\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\n\n    // height of second building section\n    float height2 = max(0.0, rand.y * 3.0 - 2.0) * downtown;\n    height2 = floor(height2*30.0)*0.06;\t// floor units\n    rand2 = floor(rand2*30.0)*0.06;\t// floor units\n    // size pieces of building\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.5)));\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.5, height2 - rand2.x, baseRad)));\n    // second building section\n    if (rand2.y > 0.35)\n    {\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.9, height2, baseRad*0.9)));\n        // subtract off piece from top so it looks like there's a wall around the roof.\n        float topWidth = baseRad;\n        if (height2 > 0.0) topWidth = baseRad * 0.9;\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0225, 0.025, topWidth-0.0225)));\n    }\n    else\n    {\n        // Cylinder top section of building\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.9, height2));\n    }\n    // mini elevator shaft boxes on top of building\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.6)*baseRad, height+height2, (rand.y-0.2)*baseRad),\n                     vec3(baseRad*0.4*rand.z, 0.2*rand2.y, baseRad*0.4*rand2.x+0.035)));\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.6)*baseRad, height+height2, (rand2.y-0.6)*baseRad);\n    float big = sign(boxPos.x);\n    boxPos.x = abs(boxPos.x)-0.03 - baseRad*0.4*rand.w;\n\td = min(d, sdBox(boxPos,\n    vec3(baseRad*0.4*rand.w, 0.08*rand.y, baseRad*0.3*rand.x + big*0.035)));\n\n    // Put domes on some building tops for variety\n    if (rand.y < 0.05)\n    {\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.9);\n    }\n\n    //d = max(d, p.y);  // flatten the city for debugging cars\n\n    // Need to make a material variable.\n    vec2 distAndMat = vec2(d, 0.0);\n    // sidewalk box with material\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.45, 0.005, 0.45)), 2.0));\n\n    return distAndMat;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec2 DistanceToObject(vec3 p)\n{\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\n    vec3 rep = p;\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\n\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\n    // only want to do a single call to the car distance function for all the\n    // cars in the scene. And there's a lot of traffic!\n    vec3 p2 = p;\n    rep.xyz = p2;\n    float carTime = localTime*0.3;  // Speed of car driving\n    float crossStreet = 2.0;  // whether we are north/south or east/west\n    float repeatDist = 0.35;  // Car density bumper to bumper\n    // If we are going north/south instead of east/west (?) make cars that are\n    // stopped in the street so we don't have collisions.\n    if (abs(fract(rep.x)-0.6) < 0.45)\n    {\n        p2.x += 0.06;\n        p2.xz = p2.zx * vec2(-2.0,2.0);  // Rotate 90 degrees\n        rep.xz = p2.xz;\n        crossStreet = 0.0;\n        repeatDist = 0.2;  // Denser traffic on cross streets\n    }\n    \n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\n    rep.x = (rep.x*sign(rep.x))-0.10;\n    rep.z -= carTime * crossStreet;\t// make cars move\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\n    rep.x += (Hash11(uniqueID)*0.085-0.02);\t// nudge cars left and right to take both lanes\n    float frontBack = Hash11(uniqueID*1.087)*0.28-0.10;\n    frontBack *= sin(localTime*3.0 + uniqueID);\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\n    vec2 carDist = Car(rep, uniqueID); // car distance function\n\n    // Drop the cars in the scene with materials\n    distAndMat = matmin(distAndMat, carDist);\n\n    return distAndMat;\n}\n\n// This basically makes a procedural texture map for the sides of the buildings.\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\n{\n    vec3 hue = vec3(Hash21(block)*0.9, Hash21(block*8.89)*0.5, Hash21(block*47.89)*0.6);\n    texColor += hue*0.5;\n    texColor *= 0.85;\n    float window = 0.0;\n    window = max(window, mix(0.3, 2.0, floor(fract(pos.y*30.0-0.45)*3.0+0.2)));\n    if (pos.y < 0.06) window = 2.0;\n    float winWidth = Hash21(block*5.321)*3.0;\n    if ((winWidth < 2.3) && (winWidth >= 2.0)) winWidth = 2.3;\n    window = max(window, mix(0.3, 2.0, floor(fract(pos.x * 50.0+0.06)*winWidth)));\n    window = max(window, mix(0.3, 2.0, floor(fract(pos.z * 50.0+0.06)*winWidth)));\n    if (window < 0.6)\n    {\n        windowRef += 2.0;\n    }\n    window *= Hash21(block*2.123);\n    texColor *= window;\n\n    float wave = floor(sin((pos.y*50.0-0.2)*PI)*0.605-0.6)+2.0;\n    normal.y -= max(-2.0, min(2.0, -wave*0.6));\n    float pits = min(2.0, abs(sin((pos.z*90.0)*PI))*5.0)-2.0;\n    normal.z += pits*0.35;\n    pits = min(2.0, abs(sin((pos.x*90.0)*PI))*5.0)-2.0;\n    normal.x += pits*0.35;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    marchCount = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    sunCol = vec3(358.0, 448.0, 300.0) / 4555.0;\n\tsunDir = normalize(vec3(1.03, 2.0, 2.0));\n    horizonCol = vec3(2.0, 3.05, 0.95)*1.0;\n    skyCol = vec3(1.4,1.6,1.05);\n    exposure = 0.75;\n    fade = 2.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 3.0 - 2.0;\n    uv /= 3.0;  // zoom in\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,2,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=-iMouse.x/iResolution.x*PI*3.0;// + localTime * 0.05;\n\tfloat my=iMouse.y/iResolution.y*4.14*0.6 + PI/3.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;//7.35\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 24.0;\n    const float t3 = 34.0;\n    const float t4 = 48.0;\n    const float t5 = 66.0;\n    const float t6 = 68.0;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 16.0;\n    const float t6 = 18.0;*/\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    if (localTime < t1)\n    {\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(23.0, 4.3, -4.5);\n        camPos.x -= smoothstep(0.0, 2.0, alpha) * 5.8;\n        camUp=vec3(0,2,0);\n        camLookat=vec3(0,2.5,2.5);\n    } else if (localTime < t2)\n    {\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(36.0, 0.06+smoothstep(0.0, 2.0, alpha)*0.5, 3.0);\n        camPos.z -= alpha * 3.8;\n        camUp=vec3(0,2,0);\n        camLookat=vec3(camPos.x-0.4,-9.15,-50.0);\n        \n        sunDir = normalize(vec3(1.05, 0.7, 2.0));\n        sunCol = vec3(358.0, 448.0, 260.0) / 4555.0;\n        exposure *= 0.8;\n        skyCol *= 2.5;\n    } else if (localTime < t3)\n    {\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(22.0, 7.3, -0.6);\n        camPos.y -= alpha * 6.5;\n        camPos.x = cos(alpha*2.0) * 6.2;\n        camPos.z = sin(alpha*2.0) * 6.2;\n        camUp=normalize(vec3(0,2,-0.6 + alpha * 0.6));\n        camLookat=vec3(0,2.0,-0.6);\n    } else if (localTime < t4)\n    {\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(3.15-alpha*0.6, 0.03, -2.0-alpha*0.3);\n        camPos.y += smoothstep(0.0,2.0,alpha*alpha) * 4.4;\n        camUp=normalize(vec3(0,2,0.0));\n        camLookat=vec3(0,0.6+alpha,alpha*6.0);\n    } else if (localTime < t5)\n    {\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(-3.0, 2.3- alpha*2.2, -20.5-alpha*0.6);\n        camUp=normalize(vec3(0,2,0.0));\n        camLookat=vec3(-3.0,0.4+alpha,-0.0);\n        sunDir = normalize(vec3(0.6-alpha*0.7, 0.4-alpha*0.4, 2.0));\n        sunCol = vec3(358.0, 448.0, 70.0) / 4555.0;\n        localTime *= 26.0;\n        exposure *= 0.5;\n        horizonCol = vec3(0.6, 2.0, 0.45)*3.0;\n        skyCol = vec3(0.85,1.05,0.6);\n\n    } else if (localTime < t6)\n    {\n        fade = 0.0;\n        camPos = vec3(36.0, 200.0, 3.0);\n        camUp=vec3(0,2,0);\n        camLookat=vec3(0.4,0.25,0.0);\n    }\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distAndMat;  // Distance and material\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 55.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000725;\n\t// ray marching time\n    for (int i = 0; i < 350; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        marchCount+=2.0;\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // 2d voxel walk through the city blocks.\n        // The distance function is not continuous at city block boundaries,\n        // so we have to pause our ray march at each voxel boundary.\n        float walk = distAndMat.x;\n        float dx = -fract(pos.x);\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\n        float dz = -fract(pos.z);\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\n        walk = min(walk, nearestVoxel);\n\n        // move down the ray a safe amount\n        t += walk;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal*(1.0+t))) break;\n    }\n\n    // Ray trace a ground plane to infinity\n    float alpha = -camPos.y / rayVec.y;\n    if ((t > maxDepth) && (rayVec.y < -0.0))\n    {\n        pos.xz = camPos.xz + rayVec.xz * alpha;\n        pos.y = -0.0;\n        t = alpha;\n        distAndMat.y = 0.0;\n        distAndMat.x = 0.0;\n    }\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if ((t <= maxDepth) || (t == alpha))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 2.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0225).x*90.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.035).x*50.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.06).x*30.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.3).x*6.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.5).x*3.5);\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.6));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 2.0;\n        float iter = 0.02;\n        vec3 nudgePos = pos + normal*0.003;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 50; i++)\n        {\n            vec3 shadowPos = nudgePos + sunDir * iter;\n            float tempDist = DistanceToObject(shadowPos).x;\n\t        sunShadow *= saturate(tempDist*250.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n\n            float walk = tempDist;\n            float dx = -fract(shadowPos.x);\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\n            float dz = -fract(shadowPos.z);\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\n            nearestVoxel = max(0.3, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n            walk = min(walk, nearestVoxel);\n\n            iter += max(0.02, walk);\n            if (iter > 5.5) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*42.0);\n        n += noise(pos*74.0);\n        n += noise(pos*228.0);\n        n += noise(pos*356.0);\n        n += noise(pos*612.0);\n        n = mix(0.8, 1.05, n);\n\n        // ------ Calculate texture color  ------\n        vec2 block = floor(pos.xz);\n        vec3 texColor = vec3(1.05, 2.0, 0.2);\n        texColor *= 0.9;\n        float windowRef = 0.0;\n        // texture map the sides of buildings\n        if ((normal.y < 0.2) && (distAndMat.y == 0.0))\n        {\n            vec3 posdx = dFdx(pos);\n            vec3 posdy = dFdy(pos);\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*8.6543);\n\n            // Quincunx antialias the building texture and normal map.\n            // I guess procedural textures are hard to mipmap.\n            vec3 colTotal = vec3(0.0);\n            vec3 colTemp = texColor;\n            vec3 nTemp = vec3(0.0);\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\n            colTotal = colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.766, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.766 + posdy * 0.766, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdy * 0.766, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.433 + posdy * 0.433, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            texColor = colTotal * 0.3;\n            windowRef *= 0.3;\n\n            normal = normalize(normal + nTemp * 0.3);\n        }\n        else\n        {\n            // Draw the road\n            float xroad = abs(fract(pos.x+0.6)-0.6);\n            float zroad = abs(fract(pos.z+0.6)-0.6);\n            float road = saturate((min(xroad, zroad)-0.243)*580.0);\n            texColor *= 2.0-normal.y*1.05*Hash21(block*10.87)*road; // change rooftop color\n            texColor *= mix(0.2, 2.0, road);\n\n            // double yellow line in middle of road\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\n\n            // white dashed lines on road\n            float whiteLine = saturate(2.0-(min(xroad, zroad)-0.07)*580.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.066)*580.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*980.0);\n            whiteLine *= saturate(2.0-(fract(zroad*9.0)-0.6)*380.0);  // dotted line\n            whiteLine *= saturate(2.0-(fract(xroad*9.0)-0.6)*380.0);\n            texColor = mix(texColor, vec3(0.6), whiteLine);\n\n            whiteLine = saturate(2.0-(min(xroad, zroad)-0.21)*580.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.206)*580.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.07)*980.0);\n            texColor = mix(texColor, vec3(0.6), whiteLine);\n\n            // crosswalk\n            float crossWalk = saturate(3.0-(fract(xroad*60.0)-0.7)*480.0);\n            crossWalk *= saturate((zroad-0.35)*1080.0);\n            crossWalk *= saturate((-zroad+0.41)*1080.0)*(3.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.35), crossWalk);\n            crossWalk = saturate(2.0-(fract(zroad*50.0)-0.6)*380.0);\n            crossWalk *= saturate((xroad-0.25)*980.0);\n            crossWalk *= saturate((-xroad+0.31)*980.0)*(2.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.35), crossWalk);\n\n            {\n                // sidewalk cracks\n                float sidewalk = 2.0;\n                vec2 blockSize = vec2(200.0);\n                if (pos.y > 0.2) blockSize = vec2(20.0, 60);\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*900.0/blockSize.x));\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*900.0/blockSize.y));\n                sidewalk = saturate(mix(0.8, 2.0, sidewalk));\n                sidewalk = saturate((2.0-road) + sidewalk);\n                texColor *= sidewalk;\n            }\n        }\n        // Car tires are almost black to not call attention to their ugly.\n        if (distAndMat.y == 4.0)\n        {\n            texColor = vec3(0.06);\n        }\n\n        // apply noise\n        texColor *= vec3(2.0)*n*0.06;\n        texColor *= 0.8;\n        texColor = saturate(texColor);\n\n        float windowMask = 0.0;\n        if (distAndMat.y >= 200.0)\n        {\n            // car texture and windows\n            texColor = vec3(Hash11(distAndMat.y)*2.0, Hash11(distAndMat.y*9.765), Hash11(distAndMat.y*27.731))*0.2;\n            texColor = pow(abs(texColor), vec3(0.3));  // bias toward white\n            texColor = max(vec3(0.35), texColor);  // not too saturated color.\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\n            texColor *= Hash11(distAndMat.y*0.889) * 0.25;\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0275)*4800.0)-20.0);\n            vec2 dirNorm = abs(normalize(normal.xz));\n            float pillars = saturate(2.0-max(dirNorm.x, dirNorm.y));\n            pillars = pow(max(0.0, pillars-0.25), 0.225);\n            windowMask = max(windowMask, pillars);\n            texColor *= windowMask;\n        }\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(200.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*4.0 + ambientS) * 0.35;\n        // Add sky color with ambient acclusion\n        lightColor += (skyCol * saturate(normal.y *0.6+0.6))*pow(ambientAvg, 0.45)*3.5;\n        lightColor *= 5.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // Reflections for cars\n        if (distAndMat.y >= 200.0)\n        {\n            float yfade = max(0.02, min(2.0, ref.y*200.0));\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\n            yfade *= (saturate(2.0-abs(dFdx(windowMask)*dFdy(windowMask))*350.995));\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-2.5)*0.4*yfade*max(0.5,sunShadow);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.45)*0.25*max(0.3,sunShadow);\n        }\n        // reflections for building windows\n        if (windowRef != 0.0)\n        {\n            finalColor *= mix(2.0, 0.7, windowRef);\n            float yfade = max(0.02, min(2.0, ref.y*200.0));\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.6)*0.6*yfade*max(0.7,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.45)*0.25*max(0.35,sunShadow)*windowRef;\n        }\n        finalColor *= 0.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        vec3 rv2 = rayVec;\n        rv2.y *= saturate(sign(rv2.y));\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\n        fogColor = min(vec3(10.0), fogColor);\n        finalColor = mix(fogColor, finalColor, exp(-t*0.03));\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = vec3(marchCount)/255.0;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        finalColor = GetEnvMap(rayVec, sunDir);\n    }\n\n    // vignette?\n    finalColor *= vec3(2.0) * saturate(2.0 - length(uv/3.5));\n    finalColor *= 0.3*exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 2.0)*saturate(fade+0.3));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 4000.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 74.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(2.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 2.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 2.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 2.0 / 70.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*8.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 2.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 2.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 2.0)),2.0);\n}\n\n\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscfW4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1323, 1352, 1371, 1371, 1416], [1417, 1417, 1436, 1436, 1467], [1468, 1468, 1491, 1491, 1527], [1528, 1528, 1551, 1551, 1622], [1623, 1623, 1645, 1645, 1732], [1733, 1733, 1755, 1755, 1808], [1809, 1809, 1832, 1832, 1905], [1906, 1906, 1929, 1929, 2000], [2001, 2001, 2024, 2024, 2110], [2111, 2111, 2152, 2152, 2195], [2233, 2233, 2257, 2257, 2530], [2531, 2531, 2553, 2553, 3138], [3168, 3168, 3191, 3191, 3220], [3221, 3221, 3244, 3244, 3273], [3274, 3274, 3299, 3299, 3328], [3330, 3408, 3457, 3457, 3713], [3715, 3715, 3757, 3808, 4453], [4455, 4455, 4518, 4518, 5176], [5178, 5237, 5266, 5266, 5316], [5478, 5507, 5541, 5541, 5652], [5654, 5688, 5733, 5733, 5816], [5818, 5890, 5929, 5929, 5968], [5970, 5970, 6004, 6004, 6042], [6044, 6177, 6218, 6236, 6963], [7073, 7178, 7213, 7289, 10493], [10495, 10679, 10710, 10760, 12702], [12704, 12871, 12974, 12974, 13931], [13933, 14003, 14038, 14038, 32001], [33335, 33335, 33392, 33392, 34751]]}
{"id": "Wd3fWN", "name": "Starbox", "author": "xacer", "description": "3d normal map texture test", "tags": ["raymarching"], "likes": 1, "viewed": 304, "published": 3, "date": "1605063280", "time_retrieved": "2024-07-30T20:35:50.667758", "image_code": "\nconst int MAXSTEPS = 100;\n\nfloat map (in vec3 p) {\n\treturn length(p - clamp(p, -0.5, 0.5)) - 0.5;\n}\n\nvec3 surfaceNormal (in vec3 p) {\n\treturn normalize(p);\n}\n\nfloat march (in vec3 ro, in vec3 rd) {\n\tfloat t = 0.0;\n    for (int i = 0; i < MAXSTEPS; i ++) {\n    \tfloat d = map(ro + rd * t);\n        t += d;\n        if (d < 0.01) return t;\n    }\n    return -1.0;\n}\n\nvec3 noise3d (in vec3 pos) {\n    vec3 s = pos/2.0 +0.5;\n\tvec3 pos1 = texture(iChannel0, s.xy).rgb;\n    vec3 pos2 = texture(iChannel0, s.yz).rgb;\n    vec3 pos3 = texture(iChannel0, s.zx).rgb;\n    return pos1 * abs(pos.z) + pos2 * abs(pos.x) + pos3 * abs(pos.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 lightDirection = vec3(1.0, 0.0, 0.0);\n    float a = iTime+3.1415/2.0;\n    mat3 rotationMatrix = mat3(\n        cos(a), 0, -sin(a), 0, 1, 0, sin(a), 0, cos(a)\n    );\n    \n    vec3 cameraPosition = 3.0 * vec3(cos(iTime), 0, sin(iTime));\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.yy;\n    vec3 ray = normalize(vec3(uv.xy, 1.0)) * rotationMatrix;\n\t\n    float t = march(cameraPosition, ray);\n    \n    if (t < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n\t}\n    \n    vec3 hit = cameraPosition + ray * t;\n    \n\tvec3 nor = surfaceNormal(hit);\n    \n    float diffuse = max(-dot(nor, lightDirection), 0.0);\n    float specular = pow(max(-dot(reflect(ray, nor), lightDirection), 0.0), 32.0);\n    float light = diffuse * 0.6 + specular * 0.4;\n    light = 1.0;\n    vec3 tint = noise3d(nor);\n    \n    // Output to screen\n    fragColor = vec4(tint * light,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 51, 51, 100], [102, 102, 134, 134, 158], [160, 160, 198, 198, 362], [364, 364, 392, 392, 626], [628, 628, 685, 685, 1641]]}
{"id": "WscBD4", "name": "ACAB", "author": "lennyjpg", "description": "https://studiodumbar.com/work/dutch-police", "tags": ["lines", "stripes", "pattern", "angle"], "likes": 2, "viewed": 315, "published": 3, "date": "1605061831", "time_retrieved": "2024-07-30T20:35:51.414760", "image_code": "void mainImage( out vec4 o, in vec2 f )\n{\n    vec2 uv = f / iResolution.xy + vec2(iTime * -.2, -.5),\n        u = vec2(uv.x - uv.y * .6, uv.y);\n    float r = 5., k = fract(u.x * r);\n    \n   \n    if(uv.y < 0.){\n        k = uv.y < -.83 / r ? 0. : min(fract(uv.x * r), k);  \n    }\n    o = mix(vec4(1), vec4(0,.1,.6,1), round(k));\n    if(uv.y < 0.){\n        o = mix(o, vec4(.9,.3,.1,1), round(fract(u.x * r + .5)));\n    }\n    if(fract(u.x*0.5) < 0.35){\n         o = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 479]]}
{"id": "3dcBWN", "name": "disco morph (font morph remix)", "author": "UrbanClubProfessional", "description": "Remix of \"font morph\" by FabriceNeyret2. [url]https://www.shadertoy.com/view/ltcXzs[/url]", "tags": ["remix", "glitch", "font", "disco", "weird", "dance", "morphing", "party", "wild"], "likes": 1, "viewed": 686, "published": 3, "date": "1605057819", "time_retrieved": "2024-07-30T20:35:52.173731", "image_code": " // --- access to the image of ascii code c\nvec4 char(vec2 p, int C) {\n    if (p.x<0.|| p.x>2. || p.y<0.|| p.y>2.) return vec4(0,0,0,2e5);\n  //return texture   ( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) );\n  //return textureLod( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n  //                   log2(length(fwidth(p/16.*iResolution.xy))) );\n    return textureGrad( iChannel0, p/26. + fract( vec2(C, 25-C/26) / 26. ) , \n                       dFdx(p/26.),dFdy(p/26.) );\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\n// --- display int4\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.6,0), 55 ),\n        n = -n;\n\n    for (float i = 4.; i>=0.; i--) \n        n /= 20.,\n        v += char(p - vec2(.6*i,0), 58+ int(fract(n)*20.) );\n    return v;\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U /= iResolution.y;\n    float t = 4.*iTime;\n\n    O = char(U,int(t));     // try .xxxx for mask, .wwww for distance field.\n // return;                 // uncomment to just see the letter count.\n    \n    vec4 O2 = char(U,int(++t));\n    O = mix(O,O2,fract(t));             // linear morphing \n // O = sqrt(mix(O*O,O2*O2,fract(t)));  // quadratic morphing\n    \n    \n    O =  smoothstep(.6,.59,O.wwww)\n       * O.yzww;                        // comment for B&W\n\n  \n  U *= 9.; O+=pInt(U,t).xxxx;           // ascii code\n  U.x -=10.; \n  O += char(U,74+23   ).x; U.x-=.6;     // text\n  O += char(U,74+25+42).x; U.x-=.6;\n  O += char(U,74+28+42).x; U.x-=.6;\n  O += char(U,74+26+42).x; U.x-=.6;\n  O += char(U,74+ 9+42).x; U.x-=.6;\n  O += char(U,74+10+42).x; U.x-=.6;\n  O += char(U,74+24+42).x; U.x-=.6;\n  O += char(U,74+ 8+42).x; U.x-=.6;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 44, 70, 70, 669], [671, 691, 719, 719, 947], [949, 949, 988, 988, 1822]]}
{"id": "3d3BWN", "name": "Still playing marble", "author": "UrbanClubProfessional", "description": "Remix of \"Playing marble\" by guil.", "tags": ["3d", "fractal", "volumetric", "remix", "glitch", "green", "fork", "mirror", "weird", "marble"], "likes": 2, "viewed": 1240, "published": 3, "date": "1605056510", "time_retrieved": "2024-07-30T20:35:52.924723", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nfloat zoom=1.;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-2.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 20; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-29. * abs(dot(p,c)));\n        \n\t}\n\treturn res/3.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .03;\n    //float dt = .2 - .195*cos(iTime*.05);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    for( int i=0; i<74; i++ )\n\t{\n        t+=dt*exp(3.*c);\n        if(t>tminmax.y)break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(ro+t*rd);               \n        \n        col = 1.03*col+ .09*vec3(c*c, c, c*c*c);//green\t\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -2.0 + 3.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*4.14;\n    m-=.6;\n\n    // camera\n\n    vec3 ro = zoom*vec3(5.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.2*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,2.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,3.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm);\n    if (tmm.x<0.)col = texture(iChannel0, rd).rgb;\n    else {\n        vec3 nor=(ro+tmm.x*rd)/3.;\n        nor = reflect(rd, nor);        \n        float fre = pow(.6+ clamp(dot(nor,rd),0.0,2.0), 4. )*2.3;\n        col += texture(iChannel0, nor).rgb * fre;\n    \n    }\n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,2.);\n    fragColor = vec4( col, 2.0 );\n\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BWN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[136, 136, 166, 166, 221], [222, 222, 244, 244, 293], [296, 296, 315, 315, 362], [364, 364, 426, 426, 612], [614, 614, 636, 636, 855], [859, 859, 911, 911, 1367], [1370, 1370, 1427, 1427, 2455]]}
{"id": "tddfDH", "name": "Truchet breathing snake", "author": "maximus009", "description": "Simle truchet", "tags": ["truchet", "pattern"], "likes": 3, "viewed": 283, "published": 3, "date": "1605037449", "time_retrieved": "2024-07-30T20:35:53.695662", "image_code": "float Hash21(vec2 p) {\n    p = fract(p*vec2(265.21, 232.23));\n    p += dot(p, p+200.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    uv += iTime * 0.1;\n    uv *= 5.;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float width = .1*UV.y+0.01 + sin(iTime) * .04 + .05;\n    \n    float n = Hash21(id); // Random 0...1\n    \n    if (n<.5) gv.x *= -1.;\n    \n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    float dFlat = abs(abs(gv.x + gv.y)-.5);\n    float dCirc = length(cUv);\n    float d = dCirc;\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n    \n    float angle = atan(cUv.x, cUv.y);\n    float checker = mod(id.x + id.y, 2.)*2.-1.;\n    //col += n;\n    float flow = sin(iTime + angle * checker * 10.);\n    float x = fract(flow+angle);\n    float y = (d-(.5-width))/(2.*width);\n    y=abs(y-.5)*2.;\n    vec2 tUv = vec2(x,y);\n    col += texture(iChannel0, tUv *.04).rgb*mask;\n    //col += y*mask;\n    \n    //if (gv.x > .48 || gv.y > .48) col = vec3(1,0,0);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 117], [119, 119, 176, 176, 1185]]}
{"id": "wsdBDH", "name": "Sparking Julia", "author": "IWBTShyGuy", "description": "Sparking Julia", "tags": ["fractal", "julia"], "likes": 2, "viewed": 194, "published": 3, "date": "1605035065", "time_retrieved": "2024-07-30T20:35:54.451640", "image_code": "vec2 cmult(vec2 z, vec2 w) {\n\treturn vec2(\n\t\tz.x * w.x - z.y * w.y,\n\t\tz.x * w.y + z.y * w.x\n\t);\n}\n\nvec2 cpow(vec2 z, int n) {\n\tvec2 res = vec2(1.0);\n\tfor (int i = 0; i < n; i++)\n\t\tres = cmult(res, z);\n\treturn res;\n}\n\nfloat julia(vec2 z, vec2 c) {\n\tfloat res = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tz = cpow(z, 4) + c;\n\t\tif (length(z) > 10.0) break;\n\t\tres += exp(-19.0 * length(z));\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    vec2 centralizer = vec2(0.5 * asp, 0.5);\n\tvec2 z = 2.2 * (uv - centralizer);\n\tvec2 c = 0.625 * vec2(cos(iTime * 1.43), sin(iTime * 1.43));\n\tfloat res = julia(z, c);\n\tfragColor = vec4(res, res, res * res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 97], [99, 99, 125, 125, 215], [217, 217, 246, 246, 418], [420, 420, 477, 477, 781]]}
{"id": "tddBDH", "name": "215657845 ccolor", "author": "algoes", "description": "215657845ccolor", "tags": ["215657845ccolor"], "likes": 6, "viewed": 328, "published": 3, "date": "1605033575", "time_retrieved": "2024-07-30T20:35:55.297380", "image_code": "#define speed (20.2)\n#define k2PI (2.*3.14159265359)\n#define kStarDensity 0.0\n#define kMotionBlur 0.4\n#define kNumAngles 90. + sin(iTime)*30.\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = vec2(sin(iTime) / 5. + .5, sin (2. * iTime) + 0.5);\n    vec2 position = ( fragCoord.xy -  iResolution.xy*.5 ) / iResolution.x; // use this for mouse panning\n    position -= 0.5*(mouse - 0.5)* vec2 (2., iResolution.y / iResolution.x);\n    float A = atan(position.y,position.x);\n    float angle0 = A / k2PI;\n    float angle = fract(angle0 + .002*iTime);\n    float rad = .3*length(position);\n    float angleFract = fract(angle*kNumAngles);\n    float angleStep = floor(angle*kNumAngles);\n    float angleToRandZ = 10.*fract(angleStep*fract(angleStep*.7535)*45.1);\n    float angleSquareDist = fract(angleStep*fract(angleStep*.82657)*13.724);\n    float t = speed * iTime - angleToRandZ;\n    float angleDist = (angleSquareDist+0.1);\n    float adist = angleDist/rad*kStarDensity;\n    float dist = abs(fract((t*.1+adist))-.5);\n    float white1 = max(0.,1.0 - dist * 100.0 / (kMotionBlur*speed+adist));\n    float white2 = max(0.,(.5-.5*cos(k2PI * angleFract))*1./max(0.6,2.*adist*angleDist));\n    float white = white1*white2;\n    vec3 color;\n    color.r = .03*white1 + white*(0.3 + 5.0*angleDist);\n    color.b = white*(0.1 + .5*angleToRandZ);\n    color.g = 30.2*white;\n   \n    float nebD1 = 1.0/rad + 4.5*(1.0 + sin(1.1 + 3.0*A + 0.71*cos(2.0*A)));\n    float nebD2 = 1.0/rad + 3.7*(1.0 + sin(3.7 + 2.0*A + 0.46*sin(3.0*A)));\n    float R1 = 1.0 * rad * (1.0 + sin(0.3+3.0*A + 2.4 * cos(0.2+3.0*A)*sin(2.1+0.42*(nebD1+speed*iTime)) + sin(2.0*6.283*position.x) ));\n    float R2 = 1.0 * rad * (1.0 + sin(1.1+4.0*A + 3.2 * cos(0.7+4.0*A)*sin(1.7+0.27*(nebD2+speed*iTime)) + cos(3.0*6.283*position.y) ));\n    float P1 = 0.5 + .5*sin(5.7*position.x+.22*(speed*iTime));\n    float P2 = 0.5 + .5*sin(4.44*position.y+.17*(speed*iTime)) ;\n    color.r += 0.6*R1 + 0.3*R2 + 0.1*P1*P2 ;\n    color.b += 0.3*R1 + 0.8*R2 + .1*P2*R1;\n    color.g += 1.1*R1*R2*P2;\n    \n    \n    \n    fragColor = vec4( (color.grb+ vec3(texture(iChannel0, (fragCoord.xy / iResolution.xy))))/1.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 202, 202, 2173]]}
{"id": "WstBW8", "name": "Circular Mozaic", "author": "ManuManu", "description": "inspired from this tweet :\nhttps://twitter.com/IRCSS/status/1314521347133968385\n", "tags": ["imageeffect"], "likes": 8, "viewed": 344, "published": 3, "date": "1605012383", "time_retrieved": "2024-07-30T20:35:56.134142", "image_code": "\n#define MOVING_CENTER\n//#define DISCARD_ON_CONTRAST\n\nfloat hash21(vec2 p)\n{\n    float v = fract(sin( p.x*1234.68 + p.y * 98765.543)*753.159);\n    return v;\n}\n\nvec4 circularMosaic(in vec2 uv, vec2 Center, float band_size, float angle_nb, float deplacement )\n{\n    vec2 PtToCenter = uv - Center;\n    \n    float angle = atan( PtToCenter.y, PtToCenter.x );\n    float angle_step = floor(angle * angle_nb);\n\n    float radius = length( PtToCenter );\n    float radius_step = floor( radius * band_size );\n    \n    float randVal = hash21( vec2( radius_step, angle_step));\n    angle += randVal*deplacement;\n    \n    vec2 uvFromPolar = vec2( cos(angle),sin(angle)) * radius_step/band_size + Center;\n\n    vec2 realUv = uvFromPolar;\n\n    vec4 texColor = texture( iChannel0, realUv);\n\n    return  texColor;\n}\n\nvec4 circularMosaic2(in vec2 uv, vec2 Center, float band_size, float angle_nb, float deplacement )\n{\n    vec2 PtToCenter = uv - Center;\n    \n\n    float radius = length( PtToCenter );\n    float radius_step = floor( radius * band_size );\n\n    \n    \n    float randV = hash21( vec2( radius_step, 0.));\n    \n    float angle;\n    float angle_step;\n    \n    float randEffect = 10.;\n    \n    angle = atan( PtToCenter.y, PtToCenter.x ) + randV/randEffect;\n    angle_step = floor(angle * angle_nb) - randV/randEffect;\n\n    /*\n    angle = atan( PtToCenter.y, PtToCenter.x );\n    angle_step = floor(angle * angle_nb);\n    //*/\n    \n    vec2 tgtVect = vec2(-PtToCenter.y, PtToCenter.x);\n    \n    //angle += radius_step/10.*sin(iTime);\n    float randVal = hash21( vec2( radius_step, angle_step));\n    \n    vec2 uvFromPolar = vec2( cos(angle),sin(angle)) * radius_step/band_size + Center;\n    \n\tvec2 uvTgt = uvFromPolar + tgtVect * randVal * deplacement;\n    \n    vec4 texColor2 = texture( iChannel0, uvTgt);\n\n\n    return texColor2;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 Center = vec2( .25, .25 );\n    \n#ifdef MOVING_CENTER\n    float myTime = iTime * .1;\n    Center = vec2( .6 + .2 * cos(myTime), .4 + .3 * sin(myTime) );\n#endif // MOVING_CENTER    \n\n    float band_size = 50.;\n\tfloat angle_nb = 10.;\n    float deplacement = 0.01;\n\n    vec4 newColor = circularMosaic( uv, Center, band_size, angle_nb, deplacement);\n    vec4 realColor = texture( iChannel0, uv);\n    fragColor = newColor;\n#ifdef DISCARD_ON_CONTRAST\n    fragColor = realColor;\n    if ( distance( newColor, realColor ) < .45 )\n        fragColor = newColor;\n#endif // DISCARD_ON_CONTRAST\n        \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 158], [160, 160, 259, 259, 794], [796, 796, 896, 896, 1819], [1821, 1821, 1878, 1928, 2572]]}
{"id": "WdtBzn", "name": "Mirrored Polyhedron On Terrain", "author": "Shane", "description": "Using some cheap effects to produce a cliche outdoor geometric scene. In particular, texture precalculation and cheap single sample atmospheric scattering calculations.", "tags": ["terrain", "sky", "icosahedron", "atmosphere", "scatter", "polyhedron"], "likes": 72, "viewed": 2299, "published": 3, "date": "1605010980", "time_retrieved": "2024-07-30T20:35:57.351887", "image_code": "/*\n\n\tMirrored Polyhedron On Terrain\n\t------------------------------\n\n    I love looking at those simple but beautiful static geometric images that Blender \n    artists, and so forth, post on various forums. Obviously, we can't quite produce the \n    same in realtime, but it's actually pretty easy to emulate the spirit of the images. \n    This particular scene was easy to produce, and pretty cheap also.\n\n\tSince the sky takes up half the viewing space, I figured I'd better at least attempt\n\tto put a believable one in there. You'd be amazed at just how effective a simple blueish\n\tgradient can be at emulating atmospheric scattering, but sometimes it's not enough. \n    Physicists and graphics coders have some awesome routines out there, but codewise, it \n    tends to blow things out too much for a simple example. Therefore, I decided on a very \n    cheap scattering routine that does a pretty good job... provided you're not too picky. :)\n    There's a lot of cheap scattering code on Shadertoy, but I've based this particular one \n    on Bearwork's effective and easy to use \"Fast Atmospheric Scattering\" example; The link \n    is below, for anyone interested.\n\n\tThe default polyhedral object is a Pentakis icosahedron, which is built on Djinn Kahn's \n    framework -- I put it together in a hurry, so there'd be better ways to go about it,\n\tbut it does the job. There's also an option to replace it with a polyhedron built on \n    Knighty's framework -- For anyone interested, I provided a brief explanation inside \n\tthe \"map\" function as to how it works.\n\n\tBy the way, this example has been patched together from previous examples in a hurry,\n\tbut I'll tidy up the code and comments in due course.\n\t\n\n\n\tRelated examples:\n\n\t// Pretty cool. I'm going to post something along these at some stage.\n\tReflective Polyhedra - Dr2\n\thttps://www.shadertoy.com/view/3ljSDV\n\n    // A very efficient way to make some basic polyhedral examples. It's one \n    // thing understanding how space folding works, and another trying to calculate\n    // the initial vectors required to put it all together. Thankfully, Knighty has \n    // done all the hard work. :)\n    Polyhedras with control - knighty\n    https://www.shadertoy.com/view/MsKGzw\n\n    // With some tweaks, this does a great job at emulating scattering without\n    // having to drop a heap of code into your example.\n    Fast Atmospheric Scattering - bearworks\n    https://www.shadertoy.com/view/WtBXWw\n\n    // There's a lot of atmospheric scattering examples on here, but this is\n    // one of my favorite all rounders. I'd like to do an example with a tweaked\n    // version of this later.\n    Real-Time Atmospheric Scattering - rayferric\n    https://www.shadertoy.com/view/wllyW4\n\n    // I used a different, simpler model, but I like this approach.\n\tSimple atmospheric scattering - w23\n    https://www.shadertoy.com/view/XsKfWz\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 60.\n\n// The far plane would be about 6 kilometers away and the sun is about 150 million kilometers\n// away, so this would be the relative distance... Actually, I have no idea, but any large\n// number will do. :D\n#define FARSUN 1.5e9\n\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// The default is a Pentakis icosahedron, which is built on Djinn Kahn's framework. \n// Commenting it out will replace it with a polyhedron built on Knighty's framework.\n#define PENTAKIS_ICOSAHEDRON\n\n// Global distance marker: Used to soften things. \nfloat gT;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n/* \n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n*/\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec2 to vec2.\nvec2 hash22(vec2 p){\n\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    return p;\n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime, 6.2831853)); \n\t//p.xy = m * p.xy;//rotate gradient vector\n  \t//return p;\n}\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish. Smooth derivatives.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    return vec2(0);\n    //return vec2(cos(z*.18/1.)*2. - sin(z*.1/1.)*4., (sin(z*.12/1.)*3. - 1.)*0.);\n}\n\n\n// A 2D texture lookup: GPUs don't make it easy for you. If wrapping wasn't a concern,\n// you could get away with just one GPU-filtered filtered texel read. However, there\n// are seam line issues, which means you need to interpolate by hand, so to speak.\n// Thankfully, you can at least store the four neighboring values in one pixel channel,\n// so you're left with one texel read and some simple interpolation.\n//\n// By the way, I've included the standard noninterpolated option for comparisson.\nfloat txFace1(in samplerCube tx, in vec2 p){\n   \n    \n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    #if 0\n    \n    // The standard noninterpolated option. It's faster, but doesn't look very nice.\n    // You could change the texture filtering to \"mipmap,\" but that introduces seam\n    // lines at the borders -- which is fine, if they're out of site, but not when you\n    // want to wrap things, which is almost always.\n    return texture(tx, vec3(.5, uv.y, -uv.x)).x; \n    \n    #else\n    \n    // Smooth 2D texture interpolation using just one lookup. The pixels and\n    // its three neighbors are stored in each channel, then interpolated using\n    // the usual methods -- similar to the way in which smooth 2D noise is\n    // created.\n    vec4 p4 = texture(tx, vec3(.5, uv.y, -uv.x)); \n\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n    \n    // Returning the average of the neighboring pixels, for curiosity sake.\n    // Yeah, not great. :)\n    //return dot(p4, vec4(.25));\n    \n    #endif\n/*   \n    // Four texture looks ups. I realized later that I could precalculate all four of \n    // these, pack them into the individual channels of one pixel, then read them\n    // all back in one hit, which is much faster.\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    vec4 x = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 0)+ .5)/cubemapRes) - .5;\n    vec4 y = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(0, 1)+ .5)/cubemapRes) - .5;\n    vec4 z = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 1)+ .5)/cubemapRes) - .5;\n    vec4 w = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n\n    return mix(mix(x, y, p.x), mix(z, w, p.x), p.y);\n*/  \n    \n}\n\n// 2D Surface function.\nfloat surfFunc2D(in vec3 p){\n    \n     return txFace1(iChannel0, p.xz/16.);///(1. + gT*gT*.001);\n}\n\n \n\n// This is a trimmed down version of one of Gaz's clever routines. I find it a \n// lot cleaner than those functions full of a million trigonometric variables.\nvec3 rot3(in vec3 p, vec3 a, float t){\n\ta = normalize(a);\n\tvec3 q = cross(a, p), u = cross(q, a);\n    return mat3(u, q, a)*vec3(cos(t), sin(t), dot(p, a));\n}\n\n//////\n\n#ifdef PENTAKIS_ICOSAHEDRON\n\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\nconst float PHI = (1. + sqrt(5.))/2.; // 1.618\nconst float A = PHI/sqrt(1. + PHI*PHI); // .85064\nconst float B = 1./sqrt( 1. + PHI*PHI); // .5257\nconst float J = (PHI - 1.)/2.; // .309016994375\nconst float K = PHI/2.; // J + .5\nconst mat3 R0 = mat3(.5,  -K,   J,  K,  J, -.5,  J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5,  J, .5,   K, .5 , -K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K, .5, -K,  -J,  K ,  J, .5);\n\n// I wanted all vertices hardcoded. Everything's been projected to the\n// surface of a sphere.\nconst float size = 1.;\nconst vec3 v0 = (vec3(0, A, B))*size; // Already normalized.\nconst vec3 v1 = (vec3(B, 0, A))*size;\nconst vec3 v2 = (vec3(-B, 0, A))*size;\nconst vec3 e0 = normalize(mix(v0, v1, .5))*size;\nconst vec3 e1 = normalize(mix(v1, v2, .5))*size;\nconst vec3 e2 = normalize(mix(v2, v0, .5))*size;\n//const vec3 mid = normalize(vec3(0, A, B + A*2.))/3.; // (v0 + v1 + v2)/3.*size.\n\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p); \n    return abs(p);  \n} \n\n\n#else\n\n// Setup constants from Knighty's Polyhedras with control example, here:\n// https://www.shadertoy.com/view/MsKGzw\n//\n// By the way, the \"type\" variable can be changed to \"3\" and \"4,\" for other polyhedral arrangements.\nconst float type = 5., cospin = cos(3.14159265/type), scospin = sqrt(.75 - cospin*cospin);\nconst vec3 nc = vec3(-.5, -cospin, scospin); // 3rd folding plane. The two others are XZ and YZ planes.\nconst vec3 pab = vec3(0, 0, 1);\n\n#endif\n\n///////\n\n\n\n \n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\nfloat dot2( in vec3 v ) { return dot(v, v); }\n\n// IQ's 3D triangle routine, which you can find here:\n// Triangle - distance 3D  - https://www.shadertoy.com/view/4sXXRN\n//\nfloat udTriangle(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3)\n{\n     \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21, nor), p1)) + \n                  sign(dot(cross(v32, nor), p2)) + \n                  sign(dot(cross(v13, nor), p3))<2.) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21, p1)/dot2(v21),0., 1.) - p1), \n                  dot2(v32*clamp(dot(v32, p2)/dot2(v32),0., 1.) - p2) ), \n                  dot2(v13*clamp(dot(v13, p3)/dot2(v13),0., 1.) - p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor));\n \n     \n}\n\nvec3 moveBall(vec3 p){\n    \n    p -= vec3(0, 1, 0);\n    return rot3(p, vec3(3.14159/12., 3.14159/6., 0), iTime/2.);\n}\n\n\n// Rock and object ID holders.\nint rID = 0;\nint svRID;\nvec4 vRID;\nvec4 svVRID;\n\n// The desert scene. Adding a heightmap to an XZ plane. Not a complicated distance function. :)\nfloat map(vec3 p){\n \n    \n    // Retrieve the 2D surface value from a cube map face.\n    float sf2D = surfFunc2D(p);\n    \n     \n    // Path function. Not used here.\n    //vec2 pth = path(p.z); \n\n    \n    // Tunnel. Not used here.\n    //float tun = 1. - dist((p.xy - pth)*vec2(.7, 1));\n\n    // Mover the mirrored ball object.\n    vec3 q = moveBall(p);\n    \n     \n    // Terrain.\n    float ter = p.y - sf2D*.5;\n    \n    // Place a crater beneath the object.\n    vec3 q2 = p - vec3(0, 1, 0) - vec3(0, 5. - .55 - 1., 0);\n    ter = smax(ter, -(length(q2) - 5.), .5);\n    ter += (.0 - sf2D*.5); \n    \n    \n \n    // Hollowing the tunnel out of the terrain. Not used here.\n    //ter = smax(ter, tun, 3.);\n    \n    // The polyhedral object.\n        \n    // Face, line and vertex distances. \n    float face = 1e5, line = 1e5, vert = 1e5;\n\n \n    \n    #ifdef PENTAKIS_ICOSAHEDRON\n    \n        // A Pentakis icosahedron: Like an icosahedron, but with 80 sides.\n    \n        // Construct a regular 20 sided icosahedron, then use the vertices to \n        // subdivide into four extra triangles to produce an 80 sided Pentakis\n        // icosahedron. Subdivision is achieved by using the known triangle \n        // face vertex points to precalculate the edge points and triangle center \n        // via basic trigonometry. See e0, e1, e2 above.\n        //\n        // On a side note, I'd imagine there's a way to fold space directly into a \n        // Pentakis icosahedron, but I got lazy and took the slower subdivided \n        // icosahedron route. If anyone knows how to do it more directly, feel free \n        // to let me know.\n\n\n        // Local object cell coordinates.\n        vec3 objP = opIcosahedron(q);\n\n        // Vertices.\n        vert = min(vert, length(objP - v0) - .05); \n        vert = min(vert, length(objP - e0) - .05); \n\n        // Lines or edges.\n        line = min(line, sdCapsule(objP, v0, e0) - .02);\n        line = min(line, sdCapsule(objP, e0, e2) - .02);\n\n        float ndg = .97;\n\n        // Vertex triangle facets -- Due to the nature of folding space,\n        // all three of these are rendered simultaneously.\n        face = min(face, udTriangle(objP, v0*ndg, e0*ndg, e2*ndg) - .03);\n        // Middle face.\n        face = min(face, udTriangle(objP, e0*ndg, e1*ndg, e2*ndg) - .03);\n    \n    #else\n    \n        // The second polyhedral object option:\n        //\n        // This is an exert from Knighty's awesome Polyhedras with control example, here:\n        // https://www.shadertoy.com/view/MsKGzw\n        //\n        // Here's a very brief explanation: Folding space about various planes will produce various\n        // objects -- The simplest object would be a cube, where you're folding once about the YZ, XZ, \n        // and XY planes: p = abs(p); p -= vec3(a, b, c); dist = max(max(p.x, p.y), p.z);\n        //\n        // Things like icosahedrons require more folds and more advanced plane calculations, but the\n        // idea is the same. It's also possible to mix objects, which is what Knighty has cleverly \n        // and elegantly done here. In particular, a Triakis icosahedron (bas = vec3(1, 0, 0), an \n        // icosahedron (bas = vec3(0, 1, 0) and a dodecahedron (bas = vec3(0, 0, 1). Mixtures, like \n        // the default (bas = vec3(1), will give you a compounded mixture of three platonic solids, \n        // which each have their own names, but I'll leave you to investigate that. :)\n\n        // Setup: Folding plane calculation, etc. I've made some minor changes, but it's essesntially\n        // Knighty's original code.\n        //\n        // Animating through various platonic solid compounds.\n        //vec3 bas = vec3(sin(iTime/4.)*.5 + .5, cos(iTime*1.25/4.)*.5 + .5,  cos(iTime/1.25/4.)*.5 + .5);\n        // A nice blend of all three base solids.\n        const vec3 bas = vec3(1);\n\n        vec3 pbc = vec3(scospin, 0, .5); // No normalization so 'barycentric' coordinates work evenly.\n        vec3 pca = vec3(0, scospin, cospin);\n        //U, V and W are the 'barycentric' coordinates. Not sure if they are really barycentric...\n        vec3 pg = normalize(mat3(pab, pbc, pca)*bas); \n        // For slightly better DE. In reality it's not necesary to apply normalization. :) \n        pbc = normalize(pbc); pca = normalize(pca);\n        \n        p = q; // Initial coordinates set to the ball's position.\n\n        // Fold space.\n        for(int i = 0; i<5; i++){\n            p.xy = abs(p.xy); // Fold about xz and yz planes.\n            p -= 2.*min(dot(p, nc), 0.)*nc; // Fold about nc plane.\n        }\n\n        // Analogous to moving local space out to the surface.\n        p -= pg;\n\n        // Object face distance.\n        float d0 = dot(p, pab), d1 = dot(p, pbc), d2 = dot(p, pca);\n        face = max(max(d0, d1), d2);\n        //face -= abs((d0 + d1 + d2)/3. - face)*.25; // Subtle surface sparkle.\n\n        // Object line distance.\n        float dla = length(p - min(p.x, 0.)*vec3(1, 0, 0));\n        float dlb = length(p - min(p.y, 0.)*vec3(0, 1, 0));\n        float dlc = length(p - min(dot(p,nc), 0.)*nc);\n        line = min(min(dla, dlb), dlc) - .025;\n\n        // Vertices.\n        vert = length(p) - .05;\n    #endif\n \n   \n    \n    // Storing the terrain, line, face and vertex information.\n    vRID = vec4(ter, line, face, vert);\n\n    // Return the minimum distance.\n    return min(min(ter, line), min(face, vert));\n \n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<96; i++){\n    \n        h = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<DELTA*(t*.1 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        // Ray shortening isn't really needed here, so call me paranoid. :D\n        t += h*.9;\n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(0.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n  \n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    float n = 0.;\n \n    \n    // Rocks.\n    if(svRID == 0){\n        \n        p *= 4.;\n        n = surfFunc2D(p);\n        //n = mix(n, 1.-surfFunc2D(p*4.), .25);\n        //n = mix(n, surfFunc2D(p*12.), .1); \n    }\n    else{\n        \n        // Sand.\n        n = 1.;//sand(p.xz*1.25);\n        //n = mix(.5, n, smoothstep(0., bordW, (bordCol0Col1)));\n       \n/*       \n        // Sand pattern alternative.\n        p *= vec3(1.65, 2.2, 3.85)/1.25;\n        //float ns = n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n        float ns = n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n\n        // vec2 q = rot2(-3.14159/5.)*p.xz;\n        // float ns1 = grad(p.z*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // float ns2 = grad(q.y*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // ns = mix(ns1, ns2, ns);\n\n        ns = (1. - abs(smoothstep(0., 1., ns) - .5)*2.);\n        ns = mix(ns, smoothstep(0., 1., ns), .65);\n\n        // Use the height to taper off the sand edges, before returning.\n        //ns = ns*smoothstep(0., .2, p.y - .075);\n    \n\n        // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n        // formed in the distance. Simply lessen the value when it's further away. Most people would\n        // figure this out pretty quickly, but it took far too long before it hit me. :)\n        n = ns/(1. + gT*gT*.015);\n*/        \n        \n        \n    }\n    \n    \n    \n    \n    //return mix(min(n*n*2., 1.), surfFunc3D(p*2.), .35);\n    return n;//min(n*n*2., 1.);\n    \n    /*\n    // Obtaining some terrain samples in order to produce a gradient\n    // with which to distort the sand. Basically, it'll make it look\n    // like the underlying terrain it effecting the sand. The downside\n    // is the three extra taps per bump tap... Ouch. :) Actually, it's\n    // not that bad, but I might attempt to come up with a better way.\n    float n = txFace0(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = txFace0(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = txFace0(pz);\n    \n    // The wavy sand, that has been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)/.001*1.);\n    */\n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n   \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */ \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... \n    // Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .05, .5); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n \n\n\n \n// Krzysztof Knarkowicz's HDR color to LDR space using the ACES operator.\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve\n//\n// As mentioned on his blog, the following is roughly twice as strong as the \n// original, so needs to compensate. On a side note, Knarkowicz (user name) \n// has some awesome examples on Shadertoy, if you feel like looking them up. :)\n \nvec3 ACESFilm(in vec3 x){\n    // Different numbers to the original: They work here, but might not\n    // be suitable for other examples. Having said that, these numbers\n    // match more closely to Stephen Hill's original.\n    float tA = .6275, tB = .015, tC = .6075, tD = .295, tE = .14; // x *= .5;\n    //float tA = .9036, tB = .018, tC = .8748, tD = .354, tE = .14; // x *= .6;\n    return clamp((x*(tA*x + tB))/(x*(tC*x + tD) + tE), 0., 1.);\n}\n\n/*\n\n// I wrote a trimmed down single function version based on the following:\n//\n// Baking Lab by MJP and David Neubelt - http://mynameismjp.wordpress.com/\n// All code licensed under the MIT license.\n//\n// Originally written by Stephen Hill (@self_shadow).\n\nvec3 ACESFitted(vec3 col){\n    \n    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT.\n    const mat3 ACESIn = mat3(.59719, .35458, .04823, \n                             .07600, .90834, .01566, \n                             .02840, .13383, .83777);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB.\n\tconst mat3 ACESOut = mat3(1.60475, -.53108, -.07367, \n                              -.10208,  1.10813, -.00605, \n                              -.00327, -.07276,  1.07602);\n\n    col *= ACESIn;\n\n    // Apply RRT and ODT fit.\n    col = (col*(col + .0245786) - .000090537)/(col*(.983729*col + .432951) + .238081);\n\n    col *= ACESOut;\n\n    // Range: [0, 1].\n    return clamp(col, 0., 1.);\n}\n\n*/\n\n// Cheap sky function, which includes coloring via scattering and some simple clouds.\n// The cheap one sample atmospheric calculations are a reworking of Bearworks' \n// \"Fast Atmospheric Scattering example, here: https://www.shadertoy.com/view/WtBXWw\n//\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    \n    // Subtle, fake sky curvature: Defintiely not physically correct. In fact, you\n    // can take it out, if it doesn't sit right with you.\n    rd.z *= .95 + length(rd.xy)*.125;\n    rd = normalize(rd);\n\n    // The dot product of the incident ray and light (sun) direction, which is used\n    // to position the sun. Dot(a, b) happens to equal the cosine of the angle between \n    // the two vectors, which is required for various scattering formulae.\n    float sun = clamp(dot(rd, ld), 0., 1.);\n    \n\n    // Atmospheric scattering: Calculate the in-scattering and extinction, which\n    // is essentially the light added and light removed, then combine them to \n    // produce the sky color. This is a very much simplified one sample version, but\n    // it results in a blue looking sky, so it'll do.\n    \n    // In-scattering (Adds light) - Particles scattered into the line of sight.\n    // This determines how much light is accumulated by scattering.\n\n    // Out-scattering (Removes light) - Determines how much light is lost due to \n    // particles being scattered out of the line of sight.\n    \n    // Extinction: Total light removed via out-scattering or absorbtion.\n\n    \n    // The calculations focus on two different kinds of scattering, namely, Rayleight\n    // and Mie scattering. Directly from Wikipedia, here are the definitions:\n    \n    // Rayleigh scattering describes the elastic scattering of light by spheres that \n    // are much smaller than the wavelength of light.\n    vec3 Rayleigh = vec3(1);\n    \n    // Mie scattering occurs when the diameters of atmospheric particulates are similar \n    // to the wavelengths of the scattered light. Dust, pollen, smoke and microscopic \n    // water droplets that form clouds are common causes of Mie scattering.\n    vec3 Mie = vec3(1); \n \n\n    // Radiance: Red, green and blue spectral distribution.\n    //\n    // Scattering coefficients: Derived from the refractive index of air.\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1); // Rayleigh.\n    vec3 betaM = vec3(4e-2); // Mie.\n    // Other versions for a slightly different color.\n    //vec3 betaR = vec3(6.95e-2, 1.18e-1, 2.44e-1); // Rayleigh.\n    //vec3 betaM = vec3(4e-2);  // Mie.   \n  \n    // Optical depth -- Based on the zenith angle, which makes sense;\n    // More particle density in the lower atmosphere, and all that.\n    const float RayleighAtt = 1.;\n\tconst float MieAtt = 1.2; \n    float zAng = max(1e-6, rd.y);\n\n    // G is inversely proportional to the sun size.\n\tconst float g = .95; // .75, etc.\n    //\n    // Haze particles and Mie scattering: Henyey-Greenstein phase function.\n    Mie *= betaM/betaR/(4.*3.14159)*(1. - g*g)/pow(1. + g*g - 2.*g*sun, 1.5);\n\n    // In-scatter - Klassen's model.\n    vec3 inScatter = (Mie + Rayleigh)*(1. + sun*sun);\n    \n    // Light attenuation via extinction: More absorbtion occurs in the denser lower \n    // atmosphere, than the higher lighter one. If you look at the Rayleigh scattering \n    // coefficient, you'll see that more blue and green is taken out, so things appear \n    // redder when the sun appears in the lower atmosphere -- Like at the horizon, so \n    // no surprises there.\n    //\n    // Extinction, which is the combination of absorption and out scattering.\n    vec3 extinction = exp(-(betaR*RayleighAtt + betaM*MieAtt)/zAng);\n    \n    // Produce the sky.\n   \n    // Sky: Combine the incoming light with the extincted light to produce the sky color.\t\n    vec3 col = inScatter*(1. - extinction);\n          \n    // Sun.\n    col += vec3(1.6, 1.4, 1)*pow(sun, 350.)*extinction*.5;\n    \n    // Sun haze.\n    col += vec3(.8, .9, 1)*pow(sun, 2.)*extinction*.4;\n      \n    //col *= vec3(1., 1.1, 1.2)*.85; // Vibrancy tweak, or cheat. \n    \n  \n    // I'm pretty sure I'm not the only one who doesn't enjoy color space conversion,\n    // and the full gamut (pun intended) of less-than-helpful protracted contradictory \n    // articles that attempt to explain it all. :D\n    //\n    // Anyway, from what I understand, the calculations above are based on HDR figures, \n    // so we need to take them down to LDR (low dynamic range), or something... At the\n    // end of the day, this function will effect that, so it needs to be done. In fact, \n    // it's a rough conversion, but it's good enough for me. If you'd like expert \n    // analysis on this super boring subject, feel free to consult the experts. :D\n     \n    // Narkowicz's clever, much smaller approximation... which I've modified to make it \n    // match the original conversion below.\n    col = ACESFilm(col);\n    // The original function: I guess it's more accurate, but looks virtually the same \n    // in this particular case, so I don't see the need to use the extra code.\n    //col = ACESFitted(col);\n \n \n    // A simple way to place some clouds on a distant plane above the terrain -- \n    // Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon.\n\tif(t>0.) col = mix(col, vec3(2), smoothstep(.45, 1., fBm(2.*uv/SC))*\n                       smoothstep(.45, .65, rd.y*.5 + .5)*.4);        \n  \n    // Return the clamped sky color.\n    return clamp(col, 0., 1.);\n    \n} \n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// hash based 3d value noise\nvec4 hash41(vec4 p){\n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41(h), hash41(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(in vec3 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n3D(p*3.)*.57 + n3D(p*7.)*.28 + n3D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .115, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n3D(p*vec3(150., 150., 150.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.1), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n3D(p*8. + .5)*.7 + n3D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.     \n\tvec3 lookAt = vec3(-1, 1, 0); // Camera position, doubling as the ray origin.\n    vec3 ro = lookAt + vec3(sin(iTime/4.), .0, -4);  // \"Look At\" position.\n    \n    //vec3 lp = vec3(0, 0, ro.z + 8.);\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(0, 0, ro.z) + vec3(-FARSUN*.35, FARSUN*(sin(iTime)*.15*0. + .15), FARSUN);\n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n    //lp.xy += path(lp.z);\n \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/32.)*rd.xy;\n    \n    vec3 aCol = vec3(0);\n    \n   \n    vec3 cam = ro;\n    vec3 sp = ro; \n    \n    float alpha = 1.;\n    float gSh = 1.;\n    float objRef = 1.;\n    \n    for(int j = 0; j<PASSES; j++){\n\n        // Raymarching.\n        float t = trace(sp, rd);\n\n        gT = t;\n\n        svVRID = vRID;\n        svRID = vRID[0]<vRID[1] && vRID[0]<vRID[2] && vRID[0]<vRID[3]? 0 : \n                vRID[1]<vRID[2] && vRID[1]<vRID[3]? 1 : vRID[2]<vRID[3]? 2 : 3;\n\n\n        // Sky. Only retrieving a single color this time.\n        //vec3 sky = getSky(rd);\n\n        // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n        vec3 col = vec3(0);\n\n \n        \n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n\n        //float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n\n        // If we've hit the ground, color it up.\n        if (t < FAR){\n\n\n             \n            vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n            \n            \n         \n            // Light direction vector. From the sun to the surface point. We're not performing\n            // light distance attenuation, since it'll probably have minimal effect.\n            vec3 ld = lp - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist; // Normalize the light direct vector.\n\n            lDist /= FARSUN; // Scaling down the distance to something workable for calculations.\n            float atten = 1./(1. + lDist*lDist*.025);\n\n\n            // Texture scale factor.        \n            const float tSize = 1./8.;\n\n            // Extra shading in the sand crevices.\n            float bSurf = bumpSurf3D(sp);\n\n            vec3 oSn = sn;\n\n            //float bf = svRID == 0? .5 : .05;\n            sn = doBumpMap(sp, sn, .1/(1. + t*t*.001));\n\n  \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n\n            // Soft shadows and occlusion.\n            float sh = softShadow(sp, lp, sn, 8.); \n            float ao = calcAO(sp, sn); // Amb, 6.ient occlusion.\n\n\n            float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n            float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 32.); // Specular term.\n            float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n\n            // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n            // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n            // used to give a sandstone consistency... It \"kind of\" works.\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Dirt... or close enough.\n\n            // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n            // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n            float amb = ao*.25;\n\n \n            // 2D surface function.\n            float sf2D = surfFunc2D(sp);\n\n             // Terrain.\n            if(svRID==0){\n\n                // Coloring the soil.\n                col = min(vec3(1.2, .75, .5)*vec3(1, .9, .8), 1.);\n                \n                //vec3 colR = mix(vec3(1, .8, .5), vec3(.5, .25, .125), clamp((sp.y*1.5 + .5), 0., 1.));\n                //col = mix(col, colR, .5);\n                \n                col *= mix(vec3(1.5, 1, .8), 1./vec3(1.2, 1, .8), sf2D);\n                col = mix(col/vec3(1.1, 1, .9), col*vec3(1.1, 1, .9), abs(sn));\n                objRef = .0;\n\n            } \n\n            // Polyhedral lines.\n            if(svRID==1){\n                col = vec3(.2);\n                objRef = .25;\n                \n            } \n\n            // Polyhedral mirror faces.\n            if(svRID==2){\n                col = vec3(1);//vec3(1, .7, .3)*4.;\n                objRef = 1.;\n                \n            }           \n\n            // Polyhedral vertices.\n            if(svRID==3){\n                col = vec3(.1);\n                objRef = 1.;\n                \n            }\n            \n            // Finer details.\n            //col = mix(col/1.35, col*1.35, bSurf);\n\n            // Grungey overlay: Add more to the rock surface than the sand.\n            // Surface texel.\n            vec3 txP = sp;\n            if(svRID>0) txP = moveBall(txP);//rot3(txP - vec3(0, 1.25/2., 0), vec3(3.14159/6.), iTime/2.);\n            vec3 tx = GrungeTex(txP/4.);//*vec3(1.2, 1.15, 1.05);//\n            col = mix(col, col*tx*3., .5); \n\n            \n\n\n            // Combining all the terms from above. Some diffuse, some specular - both of which are\n            // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n            // good enough for the purposes of this demonstation.        \n            col = col*(dif + amb + vec3(1, .97, .92)*spe*fre2*1.);\n\n\n \n            \n            // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n            vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n            \n       \n            // Applying the shadows and ambient occlusion.\n            col = col*ao*atten*(sh + .25);\n            \n            // Sky reflection on the terrain. Considering this is a multiple reflection, I could\n            // literaaly reflect the sky. However, setting the terrain to no reflections and adding\n            // this looks roughly the same and is way, way cheaper.\n            if(svRID==0){\n                col += refSky*ao*atten*(sh + .75)*.05;\n            }\n            \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n\n        // Combine the scene with the sky.\n        vec3 sky = getSky(ro, rd,  normalize(lp - sp));\n        //sky = mix(sky, 1. - exp(-sky), .15);\n        //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n        col = mix(min(col, 1.), sky, smoothstep(0., .99, t/FAR)); // Linear fade. Much dustier.\n        \n        // Add the layer color to the overall total.\n        aCol += min(col, 1.)*alpha; \n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n\n    } \n    \n    // Greyish tone.\n    //col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    \n    \n    // Standard way to do a square vignette.\n    u = fragCoord/iResolution.xy;\n    aCol = min(aCol, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n  \n    // Done.\n\tfragColor = vec4(sqrt(clamp(aCol, 0., 1.)), 1);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec2 uv){\n    \n    // It's a 2D conversion, but we're using a 3D function with constant Z value.\n    vec3 p;\n    // Just choose any Z value you like. You could actually set \"p.z\" to any constant,\n    // or whatever, but I'm keeping things consistant.\n    p.z = floor(.0*cubemapRes.x)/cubemapRes.x; \n       \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n\n        // Since we're performing our own 2D interpolation, it makes sense to store\n        // neighboring values in the other pixel channels. It makes things slightly\n        // more confusing, but saves four texel lookups -- usually in the middel of\n        // a raymarching loop -- later on.\n        \n        // The neighboring position for each pixel channel.\n        p.xy = mod(floor(uv*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n         \n        // Layering in some noise as well. This is all precalculated, so speed isn't\n        // the primary concern... Compiler time still needs to be considered though.\n        gSc = vec3(4);\n        float res2 = n3DT(p*gSc);\n        gSc = vec3(8);\n        res2 = mix(res2, n3DT(p*gSc), .333);\n        gSc = vec3(16);\n        res2 = mix(res2, n3DT(p*gSc), .333/2.);\n        //gSc = vec3(32);\n        //res2 = mix(res2, n3DT(p*gSc), .333/4.);\n        gSc = vec3(64);\n        res2 = mix(res2, 1. - abs(.5 - n3DT(p*gSc))*2., .02);\n \n       \n\n        // Individual Voronoi cell scaling.\n        vec3 sc = vec3(1, 1, 1);\n        vec3 rotF = vec3(0); // Rotation factor.\n        \n        //sc += res2*.05;\n        \n        // Put whatever function you want here. In this case, it's Voronoi.\n        gSc = vec3(32);\n        vec3 v = Voronoi(p*gSc, sc, rotF, 1., 0);\n        float res = v.x;\n        gSc = vec3(64);\n        v = Voronoi(p*gSc, sc, rotF, 1., 0);\n        res = mix(res, v.x, .333);\n        gSc = vec3(256);\n        v = Voronoi(p*gSc, sc, rotF, 1., 0);\n        res = mix(res, mix(v.y - v.x, smoothstep(.1, 1., v.y - v.x), .5), .333/3.);\n        \n        \n        \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        \n        \n        \n        // Mix in the Voronoi and the noise.\n        col[i] = mix(res, res2, .9);\n        \n        \n        \n        gSc = vec3(4);\n        vec3 r3 = terrain(p.xy*gSc.xy + .5);\n        float res3 = smoothstep(0.1, 1., r3.x);\n        \n        col[i] = mix(res, res3, .9);\n\n    }\n    \n    return col;\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n} \n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n      \n        \n        /*\n        // Debug information for testing individual cubeface access.\n        if(faceID==0) col = vec4(0, 1, 0, 1);\n        else if(faceID==1) col = vec4(0, .5, 1, 1);\n        else if(faceID==2) col = vec4(1, 1, 0, 1);\n        else if(faceID==3) col = vec4(1, 0, 0, 1);\n        else if(faceID==4) col = vec4(.5, .5, .5, 1);\n        else col = vec4(1, 1, 1, 1);\n        */\n \n        \n        // Fill the second cube face with a custom 2D function... We're actually\n        // reusing a 3D function, but it's in slice form, which essentially makes\n        // it a 2D function.\n        if(faceID==1){\n\n            col = funcFace1(uv);\n            \n        } \n        \n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    else {\n        \t\n        // The cube faces have already been initialized with values, so from this point,\n        // read the values out... There's probably a way to bypass this by using the \n        // \"discard\" operation, but this isn't too expensive, so I'll leave it for now.\n        //col = tx(iChannel0, uv, faceID);\n        if(faceID == 1) col = tx1(iChannel0, uv);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\n\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\n/*\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n*/\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n// IQ's float to float hash.\nfloat hash11(float x){  return fract(sin(x)*43758.5453); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(57, 113, 27)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;  \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime)*.5; \n}\n*/\n\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    p = mod(p, vec4(gSc, gSc));\n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// David_Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p)\n{\n    p = mod(p, gSc);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x ^ q.y ^ q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2. * vec3(q) * (1. / float(0xffffffffU));\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n/*\n// vec2 to vec2 hash.\nvec2 hash22G(vec2 p) { \n\n    p = mod(p, gSc.xy);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime ); \n    \n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 n2D3G( in vec2 p )\n{\n   \n    vec2 i = floor( p );\n    vec2 f = p - i;\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash22G( i + vec2(0.0,0.0) );\n    vec2 gb = hash22G( i + vec2(1.0,0.0) );\n    vec2 gc = hash22G( i + vec2(0.0,1.0) );\n    vec2 gd = hash22G( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va))*.5 + .5;\n}\n*/\n\n// IQ's vec2 to float hash.\nfloat hash21T(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n\n// Value noise, and its analytical derivatives -- Courtesy of IQ.\nvec3 n2D3( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = x - p;\n    \n// cubic interpolation vs quintic interpolation\n#if 0 \n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    //vec2 ddu = 6.0 - 12.0*f;\n#else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    //vec2 ddu = 60.0*f*(1.0+f*(-3.0+2.0*f));\n#endif\n    \n\tfloat a = hash21T(p);//textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = hash21T(p+vec2(1,0));\n\tfloat c = hash21T(p+vec2(0,1));\n\tfloat d = hash21T(p+1.);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k4 =   a - b - c + d;\n\n\n    // value\n    float va = k0+k1*u.x+k2*u.y+k4*u.x*u.y;\n    // derivative                \n    vec2  de = du*(vec2(k1,k2)+k4*u.yx);\n    // hessian (second derivartive)\n   /* mat2  he = mat2( ddu.x*(k1 + k4*u.y),   \n                     du.x*k4*du.y,\n                     du.y*k4*du.x,\n                     ddu.y*(k2 + k4*u.x) );*/\n    \n    return vec3(va,de);\n\n}\n\n// The terrain function. All layers are wrapped.\nvec3 terrain(vec2 p){\n \n    // Result, amplitude and sum.\n    float res = 0., a = 1., sum = 0.;\n    vec2 dfn = vec2(0); // Gradient.\n    vec3 fn; // Function.\n \n    for (int i=0; i<5; i++){\n        fn = n2D3(p); // Function.\n        dfn += fn.yz; // Gradient.\n        // Tempering the layers with the gradient.\n        res += fn.x*a/(1. + dot(dfn, dfn)*.5); //(1.-abs(fn.x - .5)*2.)\n        //p = mat2(1.6,-1.2,1.2,1.6)*p; // r2(3.14159/7.5)*p*2.; //\n        p *= 2.;// Increasing frequency.\n        gSc = min(gSc*2., 1024.); // Wrapping the increased frequency.\n        sum += a; // Sum total. ///(1. + dot(dfn, dfn)*.5);\n        a *= .5; // Decreasing the amplitude.\n    }\n     \n    res /= sum; // Height value.\n    \n    //res = res*.5 + .5;\n\n    \n    return vec3(res, dfn.xy);\n    \n}\n\n\n\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n\nivec4 gID;\n\n// Distance metric: Put whatever you want here.\nfloat distMetric(vec3 p, vec3 b, int id){\n    \n    \n    if(id==0){\n    \treturn (dot(p, p));///2.; // Sphere squared.\n    }\n    else {\n        \n        //float d2 = sBoxS(p.xy, b.xy, 0.);\n        float d2 = sdHexagon(p.xy, min(b.x, b.y));\n        return opExtrusion(d2, p.z, b.z);\n\n        \n        //return (dot(p, p));\n        //return length(p); // Standard spherical Euclidean distance.\n\n        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.\n\n        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);\n        //return max(max(p.x, p.y), p.z); // Triangular.\n\n        // Uncomment this for all metrics below.\n        p = abs(p) - b;\n        \n        \n        //p = (p + p.yzx)*.7071;\n        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)\n\n\n        return max(max(p.x, p.y), p.z); // Cube.\n        //return (p.x + p.y + p.z)*.5;//7735; // Octahedron.\n\n        //p = p*.8660254 + p.yzx*.5;\n        //return max(max(p.x, p.y), p.z); // Hex.\n\n/*        \n        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.\n        //float taper = p.y + .5; // Original.\n        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.\n\n        p = abs(p)*2.;\n        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.\n\n        float shape = max(max(p.x, p.y), p.z); // Square.\n        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.\n        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n        //float shape = length(p); // Circle.\n        //float shape = dot(p, p); // Circle squared.\n\n\n        //shape = (shape - .125)/(1. - .125);\n        //shape = smoothstep(0., 1., shape);\n\n\n        //return shape;\n        return max(shape, taper);\n*/\n    }\n    \n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if\" statements.\n//\nvec3 Voronoi(in vec3 q, in vec3 sc, in vec3 rotF, float offsF, int id){\n    \n    \n\t//const vec3 sc = vec3(1, 2, 1);\n    gSc /= sc;\n \tvec3 d = vec3(1e5); // 1.4, etc.\n    \n    float r;\n    \n    // Widen or tighten the grid coverage, depending on the situation. Note the huge (5x5x5 tap) \n    // spread. That's to cover the third order distances. In a lot of cases, (3x3x3) is enough,\n    // but in some, 64 taps (4x4x4), or even more, might be necessary.\n    //\n    // Either way, this is fine for static imagery, but needs to be reined in for realtime use.\n    for(int z = -2; z <= 2; z++){ \n        for(int y = -2; y <= 2; y++){ \n            for(int x =-2; x <= 2; x++){\n\n                vec3 cntr = vec3(x, y, z) - .5;\n                vec3 p = q;\n\t\t\t\tvec3 ip = floor(p/sc) + .5; \n                p -= (ip + cntr)*sc;\n                ip += cntr;\n                \n                // Random position and rotation vectors.\n                vec3 rndP = hash33(ip + 5.);\n                vec3 rndR = hash33(ip + 7.)*6.2831*rotF;\n\n                // Rotate.\n                p = rot(rndR)*p;\n                //p.xy *= rot2(rndR.x);\n                //p.yz *= rot2(rndR.y);\n                //p.zx *= rot2(rndR.z);\n               \n                // Postional offset.\n                p -= rndP*offsF*sc;\n                \n                \n                // Scale -- Redundant here.\n\t\t\t\tvec3 b = sc/2.*vec3(1, 1, 1);\n                // Distance metric.\n                r = distMetric(p, b, id);\n\n                // 1st, 2nd and 3rd nearest distance metrics.\n                d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n                d.y = max(d.x, min(d.y, r)); // 2nd.\n                d.x = min(d.x, r);//smin(d.x, r, .2); // Closest.\n                \n                // Redundant break in an attempt to ensure no unrolling.\n                // No idea whether it works or not.\n                if(d.x>1e5) break; \n\n            }\n        }\n    }\n\n    \n    return min(d, 1.);\n    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3737, 3817, 3865, 3865, 4406], [4650, 4892, 4912, 4912, 5258], [5260, 5558, 5583, 5675, 7117], [7119, 7142, 7163, 7163, 7242], [7245, 7348, 7370, 7370, 7476], [7479, 7976, 8020, 8020, 9758], [9760, 9784, 9812, 9812, 9882], [9887, 10046, 10084, 10084, 10203], [12101, 12197, 12237, 12237, 12379], [12381, 12381, 12406, 12406, 12426], [12428, 12552, 12617, 12617, 13293], [13295, 13295, 13317, 13317, 13412], [13495, 13591, 13609, 13675, 18958], [18962, 18983, 19019, 19019, 19531], [20014, 20114, 20148, 20148, 20330], [20335, 20362, 20391, 20391, 22613], [22615, 22806, 22863, 22964, 23949], [23953, 24105, 24141, 24141, 24389], [24391, 24582, 24634, 24759, 26070], [26470, 26470, 26495, 26692, 26916], [27856, 28110, 28149, 28301, 33493], [33497, 33523, 33555, 33555, 33619], [33621, 33650, 33670, 33670, 33709], [33711, 33779, 33797, 33797, 34116], [34118, 34378, 34404, 34477, 35229], [35233, 35233, 35289, 35318, 44179]]}
{"id": "3stBDH", "name": "Emerald retrowave clip", "author": "z0rg", "description": "Visuals inspired by https://www.youtube.com/watch?v=Jrb5PqiDMSY\nSong is https://www.youtube.com/watch?v=Pum5IuGtWbc\nVideo can be found here https://youtu.be/RLAqQn2vqcM\n", "tags": ["synth", "chill", "retrowave", "system96", "lucyindisguise"], "likes": 16, "viewed": 679, "published": 3, "date": "1605008645", "time_retrieved": "2024-07-30T20:35:58.203608", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nvec3 pink = (vec3(255, 59, 98)/255.);\nvec3 blue = vec3(59, 154, 255)/255.;\nmat2 r2d(float a) { float ca = cos(a), sa = sin(a); return mat2(ca, sa, -sa, ca);}\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n\nfloat sdLoz(vec2 uv, float sz)\n{\n    return lenny(uv)-sz;\n}\n\nfloat sdSqr(vec2 uv, vec2 sz)\n{\n    vec2 q = abs(uv)-sz;\n    return max(q.x,q.y);\n}\n\nfloat bars(vec2 uv)\n{\n    vec2 ouv = uv;\n    float rep = 0.08;\n\tfloat idx = float(int((uv.x+rep*.5)/rep));\n    uv.x = mod(uv.x+rep*.5, rep)-rep*.5;\n    float h = texelFetch(iChannel0, ivec2(int((idx+8.5)*7.), 0), 0).x;\n    float sqr = sdSqr(uv, vec2(.00001,.1+.2*h));\n    return max(sqr, -(abs(uv.y)-.05));\n}\n\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\nvec3 rdrPix(vec2 uv)\n{\n    vec3 col;\n    uv = myPixel(uv, 0.1);\n    float beat = texelFetch(iChannel0, ivec2(25,0),0).x;\n    float patt = sin((55.*(abs(uv.x)+beat*.05+uv.y)-iTime*10.)*(1.+abs(uv.y)*.01));\n    col = mix(col, vec3(.5,.2,.9), sat((patt-.99)*iResolution.x));\n    col += (vec3(.2,.7,.3))*0.+blue*(sat((patt-.5)*.5));\n    return col;\n}\n\nvec3 rdrLoz(vec2 uv)\n{\n    vec2 ouv = uv;\n    uv *= 15.;\n    uv = myPixel(uv, 0.025);\n    uv.y += sin(uv.x*5.+iTime)*.5;\n    vec3 col;\n    vec3 a = vec3(255,98,14)/255.;\n    vec3 b = vec3(255,239,88)/255.;\n    vec3 c = vec3(91,222,150)/255.;\n    if (uv.y < 0.)\n        col = mix(b, c, sat(abs(uv.y)));\n    else\n        col = mix(b, a, sat(uv.y));\n    float f = iResolution.x/10.;\n    float sz = .99;\n    col *= 1.-sat((sin(ouv.x*f)-sz)*iResolution.x*.1);\n    col *= .5+1.-sat((sin(ouv.y*f)-sz)*iResolution.x*.1);\n    return col;\n    \n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    // Back bars\n    vec2 uvBar = uv;\n    uvBar.x += -sign(uvBar.x)*pow(sat(abs(uvBar.x)), .2)*abs(uvBar.y);\n    float bar = bars(uvBar);\n    col = mix(col, vec3(1.), 1.-sat(bar*iResolution.x));\n\n    col += (vec3(255, 59, 216)/255.)*pow((1.-sat(bar*1.)), 10.)*.5;\n    col += mix(pink, blue, pow(sat(abs(uv.y*5.)),5.))*pow((1.-sat(bar*5.)), 20.);\n    col *= (uv.y < 0. ? 1.-abs(uv.y*5.) : 1.0);\n    \n    vec2 uvLz = uv;\n    float lz = sdLoz(uvLz, .15);\n    \n    \n    vec3 pixCol = rdrPix(uv);\n    col += pixCol*(1.-sat(lz*2.))*texelFetch(iChannel0, ivec2(25,0),0).x;\n    \n\tcol = mix(col, col+rdrLoz(uv), 1.-sat(lz*iResolution.x*.01));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\tuv *= 1.5;\n    uv *= sin(iTime*.4)*.2+.8;\n\n    vec3 col = rdr(uv);\n\n\tcol = pow(col, vec3(mix(.45,1.45,sat(lenny(uv)))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24533, "src": "https://soundcloud.com/systemninesix/emerald-w-lucy-in-disguise", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBDH.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[504, 504, 523, 523, 586], [588, 588, 610, 610, 644], [646, 646, 678, 678, 705], [707, 707, 738, 738, 790], [792, 792, 813, 813, 1100], [1102, 1102, 1135, 1135, 1223], [1225, 1225, 1247, 1247, 1571], [1573, 1573, 1595, 1595, 2108], [2110, 2110, 2129, 2129, 2805], [2807, 2807, 2864, 2864, 3085]]}
{"id": "wdGcWc", "name": "mass_spring_system_2", "author": "balkhan", "description": "masses with a big masses at the begin and at the end. \nkeyboard arrows (right and left) moove top node, space reset position. \ntrying to make a collision with a circle and the borders but it made the rope go berserk after some time so I clamped velocity. ", "tags": ["2d", "springs"], "likes": 10, "viewed": 470, "published": 3, "date": "1605003939", "time_retrieved": "2024-07-30T20:35:58.988510", "image_code": "// Fork of \"mass_spring_system_1\" by balkhan. https://shadertoy.com/view/tsGyzt\n// 2020-10-28 12:56:32\n\n// Fork of \"mass_spring_system_0\" by balkhan. https://shadertoy.com/view/3ljXDm\n// 2020-10-23 13:40:46\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2 rotate(vec2 v, float alpha);\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness);\nfloat mlength(vec2 p) {vec2 a = abs(p); return max(a.x, a.y);}\nfloat cube(vec2 p, vec2 d, vec2 l) {vec2 a = abs(p-d)-l; return max(a.x, a.y);}\n#define SHOW_LINES\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = 1.*(f.xy-.5*R) / R.y;\n    vec3 idl;\n    float ma,md = 1e5;\n    o -= o;\n    \n    for( float i = .0; i < NUM; i++)\n    {\n        vec2 cd = vec2(floor((i)/NUM) , mod(i, NUM) );\n        ma = 1.*texture(iChannel0, (cd+vec2(.0, NUM+.5))/R).x;//+.0*(cd.x <= .0 ? 1. : .0)*.0+(cd.y <= .0 ? 2. : .0)*.0;\n        vec2 pos = texture(iChannel0, cd/R).xy-vec2(.125,.0);//-vec2((cd.x <= 0. ? .125:.0), (cd.y <= 0. ? .125:.0) );\n        float bl = (i == NUM-1. || i == .0 ? 0. : 0.)*1e5+length(u - pos*SC)-(.0075*ma);\n    \tmd = min(md,\n                 bl\n                 );\n        if ( md == bl && md < (0.005))\n        {\n        \tidl.x = i*1.1+1.57+.0*floor(iTime);\n            vec2 R1 = iChannelResolution[1].xy;\n            idl.x += smoothstep(.55, .5, texture(iChannel1, (i == NUM-1.?vec2(.01, .0275):32./R1)+.5*(u-pos*SC -vec2(-20./8.-1.0*cd.y/64.+3./8., -9./8.+.0) )/(ma/8.+0.) ).w);\n        }\n        #ifdef SHOW_LINES\n        vec2 apos = texture(iChannel0, vec2(cd.x+0., cd.y-1.)/R ).xy-vec2((cd.x <= 0. ? .125:.0), (cd.y-1. <= 0. ? .125:.0) );\n        float l0 = 1.-(line(apos*SC, pos*SC, u, 0.005) );\n        \t\t        md = min(md,\n\t\t                 l0\n                        );\n        #endif\n        if (md < 0.001)\n            break;\n    }\n    #ifdef SHOW_LINES\n    if (f.x < 1./SC && f.y < NUM*2./SC) // pos and mass displayed bottom left\n\to.xyz += (texelFetch(iChannel0, ivec2(f.xy*SC), 0).xyz/3.)+.5*(f.y <= NUM/SC?1.:.0);\n    else\n    #endif\n    {\n        float cbd = max(\n             cube(u,vec2(-.0250,.365), vec2(.6, .07)*1.0+.0*vec2(480., 31.5)/R )\n                 ,\n             -cube(u,vec2(-.0250,.365), vec2(.55, .065)*1.0+.0*vec2(440., 29.25)/R )\n                 );\n        cbd = min(cbd, \n                  length(u-vec2(.25, .0)*SC)-.05\n                  );\n    md = min(md,\n             cbd\n             \n            );\n    idl.x = (md == cbd ?0.25:idl.x)*1.0;\n    o.xyz += .25+.75*vec3(smoothstep( 0.0125, 0.01125, md))*1.0*abs(sin( idl.x*3.+.5*vec3(0.50, 1., 2.) +1.570+.0 ) );\n    }\n    //o = texture(iChannel0, vec2(1.0, 0.)+.0*f/R);\n}\n\nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\t\n\tfloat dx = 0.0;\n\tif(p.x<0.0)\n\t\tdx = abs(p.x);\n\telse if(p.x>length(lineVector))\n\t\tdx = abs(p.x) - length(lineVector);\n\t\t\n\treturn ( thickness/(dx+abs(p.y)) );\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* BUFFER A : 2D Particle System\n*/\n\n\n// for reading clarity's sake, not rly useful\nstruct\tparticle\n{\n    vec2\tpos; // position\n    vec2\tacc; // acceleration\n    vec2\tvit; // velocity\n    float\tma;  // mass\n};\n\n#define Gr vec2(.0+0.*sin(iTime), -.98)\n#define DIST .05\n    //.025*.1\n#define WALLS\n\n    void\tinit_pos(inout vec2 pos, vec2 ij)\n{\n    pos.x = .75+1.0*(-.25+1.0*(NUM-ij.y)*DIST)-.5*NUM*DIST;\n    pos.y = .5*NUM*DIST*57.*.0+.0*ij.y*DIST+.4150*NUM*DIST*.0+1.45;\n}\n\nvoid\tinit(inout particle part, vec2 f)\n{\n    part.acc = vec2(0.);\n\tpart.vit.xy = vec2(0.);\n    init_pos(part.pos, f);\n    part.ma = ( !(f.y >= NUM*2.-1.) && f.y >= NUM*2.-(NUM-1.) ? 0. : 1.0)*7.+1.;\n}\n\nvec2 DistanceConstraint(vec2 x, vec2 x2, float restlength, float stiffness)\n{\n    vec2 delta = x2 -x;\n    float deltalength = length(delta);\n    float diff = (deltalength-restlength) /deltalength;\n    return delta*stiffness*diff;\n}\n\nvec2 summ_current_minus_rest_spring_len(vec2 f, vec2 R, particle parts)\n{\n    vec2 summ_pos = vec2(.0);    \n    vec2 fpos = texture(iChannel0, (f+vec2(0., 0.))/R.xy ).xy;\n    float xrest = 1.;\n    for(float i = 0.; i <= 2.; i++)\n    {\n        vec2 cd = vec2(.0, i-1.);\n        vec2 idf = f + cd;\n        if(idf.x < .0 || idf.x > NUM || idf.y < .0 || idf.y > NUM)\n            continue;\n        if (cd.y == 0.)\n            continue;\n        float ma = texture(iChannel0, (f+cd+vec2(.0, NUM) )/R).x;\n            xrest = DIST;\n       \tcd = texture(iChannel0, (f+cd)/R.xy ).xy; // need a vec2, reusing cd var\n            summ_pos += DistanceConstraint(fpos, cd, xrest*1., 6.*.0+1.0*8./(abs(ma-parts.ma)*.25+1.)+.0 );\n    }\n\treturn summ_pos/2.;\n}\n\nvoid collision(vec2 f, vec2 R, inout particle parts)\n{\n    vec2 np = parts.pos + parts.vit;\n    vec2 cp = vec2(.45, .0);\n    vec2 dd = np -cp;\n\tif (length(dd) < .25+parts.ma/24.)\n    {\n        //parts.vit *= -.95;\n        parts.acc *= -.75;\n        parts.vit *= -1./(length(dd)+.505);\n    }\n\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    bool reinit = false;\n    particle parts;\n    vec4\ttexture_buff;\n    vec2\tR = iResolution.xy;\n    //o -= o;\n    o = vec4(0.);\n    if (f.x == iResolution.x-0.5) // reserve last x line for keyboard input memory\n    {\n        if (float(iFrame) <= 10.)\n\t    {\n\t        o.xy = vec2(0.);\n\t        return;\n        }\n        o.xy = texture(iChannel0, vec2(1., .0)).xy*.975;\n        o.x += texelFetch( iChannel1, ivec2(KEY_RIGHT,0),0 ).x*.0625*iTimeDelta;\n        o.x -= texelFetch( iChannel1, ivec2(KEY_LEFT,0),0 ).x*.0625*iTimeDelta;\n        //o.y += texelFetch( iChannel1, ivec2(KEY_UP,0),0 ).x*.0625*iTimeDelta;\n        //o.y -= texelFetch( iChannel1, ivec2(KEY_DOWN,0),0 ).x*.0625*iTimeDelta;\n        return;\n    }\n    if (f.x == iResolution.x-1.5)\n    {\n        o.xy = R.xy;// stock resolution inside to check against new resolutions\n        return;\n    }\n    if (f.x > 1. || f.y > NUM+NUM)\n        discard;\n    float kb = texelFetch( iChannel1, ivec2(32,0),0 ).x; // check for space pressed\n    // reset all parameters on space or resolution change\n    if (float(iFrame) <= 10. || kb > .0 || texelFetch(iChannel0, ivec2(vec2(R.x-1.5,.0) ), 0).xy!=R.xy)\n    {\n\t\tinit(parts, f);\n\t    o.xy += parts.pos;\n\t\to.zw += parts.vit;\n        if (f.y > NUM)\n        {\n            o -= o;\n        \to.x = parts.ma;\n        }\n        return;\n    }\n    \n    if (f.y > NUM)\n    {\n        o = -o;\n        o.x = texture(iChannel0, f/R ).x;\n        return;\n    }\n    parts.ma = texture(iChannel0, (f+vec2(.0, NUM) )/R).x;\n    texture_buff = texture(iChannel0, f/R.xy ).xyzw;\n    parts.pos = texture_buff.xy;\n  \tparts.vit = texture_buff.zw;\n    if (f.y >= NUM-1.5 && (f.x <= 1. || f.x >= NUM-1.5 )) // last node need to moove only from keyboard\n    {\n        vec2 moove = texture(iChannel0, vec2(1., .0)).xy;\n        o = vec4(clamp(parts.pos+moove,vec2(-2.), vec2( 2.) ), .0, .0);\n        return;\n    }\n    parts.acc = \n            parts.ma*Gr*iTimeDelta*.05\n            +\n            summ_current_minus_rest_spring_len(f, R, parts)*iTimeDelta\n            ;\n//    parts.acc = clamp(parts.acc, -.015*.0125, .015*.0125); // too groovy\n    #ifdef WALLS\n    if(parts.pos.y + parts.vit.y*1.0 < -1.5)\n    {\n        parts.pos.y = -1.5;parts.vit.y = .0*.95*abs(parts.vit.y);\n    }\n    if(parts.pos.x + parts.vit.x < -3.)\n        parts.vit.x = .0*.95*abs(parts.vit.x);\n    if(parts.pos.x + parts.vit.x > 3.5)\n        parts.vit.x = .0*-.95*abs(parts.vit.x);\n    #endif\n    collision(f, R, parts);\n    parts.vit.xy += parts.acc.xy;\n\tparts.pos.xy += parts.vit.xy;\n\t    \to.xy += parts.pos.xy;\n\t\t\to.zw += parts.vit.xy;\n    o.zw = clamp(o.zw, -.015, .015); // velocity clamp avoid most explosive behavior\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define NUM 100.\n\n#define SC .25", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[412, 412, 435, 435, 474], [475, 475, 511, 511, 554], [2722, 2722, 2756, 2756, 2877], [2879, 2879, 2934, 2934, 3206]]}
{"id": "3ddfWH", "name": "Shape functions", "author": "iY0Yi", "description": "Shape function collection.", "tags": ["1d", "shapefunction"], "likes": 8, "viewed": 434, "published": 3, "date": "1604998295", "time_retrieved": "2024-07-30T20:35:59.808318", "image_code": "#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\n//#define UNSIGNED\n#define TICKNESS .005\nfloat SCALE = 0.; vec2 P; vec3 col;\n\nvec3 graph(float v, vec3 color){\n    float res =abs(P.y-v);\n    \n    //https://iquilezles.org/articles/distance\n    //https://www.shadertoy.com/view/MdfGWn\n    float e = 2./iResolution.y;\n    float g = length(vec2(dFdx(res),dFdy(res)))/e;\n    res /= g;\n    \n    res = sms(SCALE*e+TICKNESS, SCALE*e+TICKNESS*1.5, res);\n    res += texture(iChannel0, P).r*.25;\n    return saturate(res+color);\n}\n\nvoid Paper(){\n    P*=SCALE*2.;\n\n    #define PAPER vec3(1,.95,.9)*.8\n    #define GUIDE vec3(.1,.2,.25)*1.7\n    float ZERO = .003*SCALE;\n    float ONE = .01*SCALE;\n    float TEN = .1*SCALE;\n    col=PAPER;\n    col*=1.-(sms(1.-ONE,1.,abs(u2s(mod(P.x,1.0))))+sms(1.-ONE,1.,abs(u2s(mod(P.y*iResolution.y/iResolution.x,1.0)))))*0.75*GUIDE;\n    col*=1.-(sms(1.-TEN,1.,u2s(mod(P.x*10.0,1.0)))+sms(1.-TEN,1.,abs(u2s(mod(P.y*10.0*iResolution.y/iResolution.x,1.0)))))*0.5*GUIDE;\n    col*=1.-(P.x<ZERO&&P.x>=-ZERO?1.0:0.0)*GUIDE;\n    col*=1.-(P.y*iResolution.y/iResolution.x<0.003*SCALE&&P.y>=-0.003*SCALE?1.0:0.0)*GUIDE;\n    P.y*=iResolution.y/iResolution.x;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    P=(uv-0.5)*2.0;\n    \n#ifdef UNSIGNED\n    P+=.9;\n#endif\n    \n    // Scaling\n    SCALE = 2.;\n    \n    if(iMouse.z>0.)\n    {\n    \tP-=(iMouse.xy/iResolution.xy)*2.-1.;\n    }\n    \n    \n    \n    // Paper\n    Paper();\n    if(texture(iChannel0, uv*10.).g>.8){fragColor=vec4(pow(col, vec3(.45)), 1.); return;}\n    \n#ifdef UNSIGNED\n    if(P.x<.0 || P.y<0.){fragColor=vec4(pow(col, vec3(.45)), 1.); return;}\n#endif\n    \n\t// Markers: 8 colors\n    #define RED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n    #define GREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n    #define PURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n    #define YELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n    #define ORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n    #define COBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n    #define BLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n    #define BLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n    \n    // Graph\n\tif(P.x<mod(iTime,5.*SCALE)-2.*SCALE)\n    {\n        col *= graph(sin(P.x*TAU/CYCLE), RED);\n        col *= graph(swTri(P.x), GREEN);\n        col *= graph(swSaw(P.x), PURPLE);\n        col *= graph(swSqr(P.x), YELLOW);\n        col *= graph(uwTri(P.x), ORANGE);\n        col *= graph(swQuartic(P.x), COBALT);\n        col *= graph(swCubic(P.x), BLUE);\n        col *= graph(uwCubic(P.x), BLACK);\n    }\n\t    \n    fragColor=vec4(pow(col, vec3(.45)), 1.);\n}", "image_inputs": [], "common_code": "// Constants\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define SQRT2 1.41421356237\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(v) ((v)*.5+.5)\n#define u2s(v) ((v-.5)*2.)\n\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 70], [71, 71, 92, 92, 142], [143, 143, 164, 164, 202], [203, 203, 224, 224, 267], [269, 269, 290, 290, 318], [319, 319, 340, 340, 368], [369, 369, 390, 390, 418], [419, 419, 440, 440, 468], [470, 470, 497, 497, 536], [537, 537, 560, 560, 595], [596, 596, 621, 621, 658], [659, 659, 683, 683, 719], [720, 720, 749, 749, 790], [791, 791, 817, 817, 855], [856, 856, 881, 881, 918], [919, 919, 941, 941, 975], [976, 976, 1000, 1000, 1036], [1038, 1038, 1065, 1065, 1099], [1100, 1100, 1123, 1123, 1153], [1154, 1154, 1179, 1179, 1211], [1212, 1212, 1236, 1236, 1267], [1268, 1268, 1297, 1297, 1333], [1334, 1334, 1360, 1360, 1393], [1394, 1394, 1419, 1419, 1451], [1452, 1452, 1474, 1474, 1503], [1504, 1504, 1528, 1528, 1559], [1640, 1640, 1672, 1672, 2031], [2033, 2033, 2046, 2046, 2681], [2683, 2683, 2739, 2739, 4089]]}
{"id": "WdtBWH", "name": "Loudspeakerian Lawn", "author": "UrbanClubProfessional", "description": "Remix of \"Sirenian Dawn\" by nimitz.", "tags": ["planet", "fog", "remix", "glitch", "green", "mars", "aa", "weird", "atmosphere", "dawn"], "likes": 1, "viewed": 1092, "published": 3, "date": "1604987393", "time_retrieved": "2024-07-30T20:36:00.676996", "image_code": "// Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\n\n\tThings of interest in this shader:\n\t\t-A technique I call \"relaxation marching\", see march() function\n\t\t-A buffer based technique for anti-alisaing\n\t\t-Cheap and smooth procedural starfield\n\t\t-Non-constant fog from iq\n\t\t-Completely faked atmosphere :)\n\t\t-Terrain based on noise derivatives\n*/\n\n/*\n\tMore about the antialiasing:\n\t\tThe fragments with high enough iteration count/distance ratio \n\t\tget blended with the past frame, I tried a few different \n\t\tinput for the blend trigger: distance delta, color delta, \n\t\tnormal delta, scene curvature.  But none of them provides \n\t\tgood enough info about the problem areas to allow for proper\n\t\tantialiasing without making the whole scene blurry.\n\t\t\n\t\tOn the other hand iteration count (modulated by a power\n\t\tof distance) does a pretty good job without requiring to\n\t\tstore past frame info in the alpha channel (which can then\n\t\tbe used for something else, nothing in this case)\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 2.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 100\n#define FAR 500.\n#define time iTime\n\nconst vec3 lgt = vec3(-.623, .51, -.847);\nmat2 m2 = mat2( 0.90,  0.70, -0.70,  0.90 );\n\n//form iq, see: https://iquilezles.org/articles/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(4.0-3.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.6,0.6))/356.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(2.5,0.6))/356.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.6,2.5))/356.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(2.5,2.5))/356.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 2.;\n\tvec2  d = vec2(0.0);\n    float scl = 3.95;\n    float zscl = -.5;\n    float zz = 6.;\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.6,2.5,n.yz);\n        zz -= -1.;\n        rz += z*n.x/(dot(d,d)+.95);\n        z *= zscl;\n        zscl *= .9;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(2.5,-.6,rz)+.85;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    return p.y-(terrain(p.zx*0.08))*3.7-2.;\n}\n\n/*\tThe idea is simple, as the ray gets further from the eye, I increase \n\tthe step size of the raymarching and lower the target precision, \n\tthis allows for better performance with virtually no loss in visual quality. */\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\n{\n    float t = 0.;\n    float d = map(rd*t+ro);\n    float precis = 0.0002;\n    for (int i=0;i<=ITR;i++)\n    {\n        if (abs(d) < precis || t > FAR) break;\n        precis = t*0.0002;\n        float rl = max(t*0.03,2.);\n        t += d*rl;\n        d = map(rd*t+ro)*0.8;\n        itrc++;\n    }\n\n    return t;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 normal(in vec3 p, in float ds)\n{  \n    vec2 e = vec2(-2., 2.)*0.0006*pow(ds,2.);\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat noise(in vec2 x){return texture(iChannel0, x*.02).x;}\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=.6;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i<4.;i++ )\n\t{\n        rz+= (sin(noise(p)*6.)*0.6+0.6) *z;\n\t\tz *= 0.6;\n\t\tp = p*3.;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec2 p){ return fbm(p*4.); }\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(0.006*ds,0);\n    float n0 = bnoise(p.zx);\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 2., bnoise(p.zx+e.yx)-n0)/e.x*0.035;\n    d -= n*dot(n,d);\n    n = normalize(n-d);\n    return n;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-2., 2.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .25/e.y *(t1 + t2 + t3 + t4 - 5. * map(p));\n}\n\n//Based on: https://iquilezles.org/articles/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\n{\n    vec3 pos = ro + rd*ds;\n    float mx = (fbm(pos.zx*0.2-time*0.06)-0.6)*.3;\n    \n    const float b= 2.;\n    float den = 0.4*exp(-ro.y*b)*(2.0-exp( -ds*rd.y*b ))/rd.y;\n    float sdt = max(dot(rd, lgt), 0.);\n    vec3  fogColor  = mix(vec3(0.6,1.3,0.25)*2.2, vec3(0.1,0.7,0.55)*1.3, pow(sdt,3.0)+mx*0.6);\n    return mix( col, fogColor, clamp(den + mx,0.,2.) );\n}\n\nfloat linstep(in float mn, in float mx, in float x){\n\treturn clamp((x - mn)/(mx - mn), 0., 1.4);\n}\n\n//Complete hack, but looks good enough :)\nvec3 scatter(vec3 ro, vec3 rd)\n{   \n    float sd= max(dot(lgt, rd)*0.4+0.4,0.);\n    float dtp = 23.-(ro + rd*(FAR)).y*4.5;\n    float hori = (linstep(-1700., 0.0, dtp) - linstep(21., 600., dtp))*0.9;\n    hori *= pow(sd,.04);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 300.)*vec3(0.2, 0.9,  0.6)*4.;\n    col += pow(hori, 35.)* vec3(0.2, 0.6,  0.35)*.4;\n    col += pow(hori, 8.)* vec3(0.2, 0.5, 0.35)*.9;\n    \n    return col;\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(474761393U, 768265263U, 2103515245U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 4U));\n    return vec3(p^(p >> 26U))*(2.0/vec3(0x89abcdefU));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.9;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.25*res))-0.6;\n        vec3 id = floor(p*(.25*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.7,length(q));\n        c2 *= step(rn.x,.0006+i*i*0.002);\n        c += c2*(mix(vec3(2.0,0.59,0.2),vec3(0.85,1.0,2.),rn.y)*0.35+0.85);\n        p *= 2.4;\n    }\n    return c*c*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.6;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.6;\n    mo = (mo==vec2(-.6))?mo=vec2(-.3,0.4):mo;\n    mo.x *= 2.2;\n    mo -= vec2(2.2,-0.2);\n\tmo.x *= iResolution.x/iResolution.y;\n    mo.x += sin(time*0.25)*0.3;\n\t\n    vec3 ro = vec3(750., sin(time*0.3)*0.35+20.,-time);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.6+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+2.5708),0.,sin(mo.x+2.5708)));\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right + p.y*up)*2.05 + eye);\n    rd.y += abs(p.x*p.x*0.025);\n    rd = normalize(rd);\n\t\n    float count = 0.;\n\tfloat rz = march(ro,rd, count);\n    \n    vec3 scatt = scatter(ro, rd);\n    \n    vec3 bg = stars(rd)*(2.0-clamp(dot(scatt, vec3(2.3)),0.,2.));\n    vec3 col = bg;\n    \n    vec3 pos = ro+rz*rd;\n    vec3 nor= normal( pos, rz );\n    if ( rz < FAR )\n    {\n        nor = bump(pos,nor,rz);\n        float amb = clamp( 0.6+0.6*nor.y, 0.0, 2.0 );\n        float dif = clamp( dot( nor, lgt ), 0.0, 2.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 2.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 2.0 ),600.);\n        float fre = pow( clamp(2.0+dot(nor,rd),0.0,2.0), 3.0 );\n        vec3 brdf = 2.*amb*vec3(0.20,0.21,0.22);\n        brdf += bac*vec3(0.25,0.06,0.05);\n        brdf += 3.3*dif*vec3(1.0,0.5,0.35);\n        col = vec3(0.15,0.15,0.2);\n        float crv = curv(pos, 3.)*2.;\n        float crv2 = curv(pos, .5)*3.5;\n        \n        col += clamp(crv*1.0,-2.,2.)*vec3(0.35,.7,.6);\n        col = col*brdf + col*spe*.2 +.2*fre*col;\n        col *= crv*1.1+1.1;\n        col *= crv2*0.9+0.9;\n    }\n\t\n    col = fog(ro, rd, col, rz);\n    col = mix(col,bg,smoothstep(FAR-250., FAR, rz));\n    col += scatt;\n    \n    col = pow( col, vec3(.83,0.9,0.9) );\n    col = mix(col, smoothstep(0.,2.0,col), 1.0);\n    col *= pow( 26.0*q.x*q.y*(1.1-q.x)*(2.0-q.y), 0.2)*1.0+0.2;\n    \n    vec4 past = texture(iChannel1, q);\n    float tOver = clamp(iTimeDelta-(2./70.),0.,2.);\n    \n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\n    if (count/pow(rz, 0.75) > 4.3) col = mix(col, past.rgb, clamp(0.95-iTimeDelta*8.,0.,2.));\n    \n\tfragColor = vec4(col, 2.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBWH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1208, 1208, 1265, 1265, 1344]]}
{"id": "WddfW8", "name": "For rentacat45", "author": "Arseny", "description": "Hap brth", "tags": ["2d", "relax"], "likes": 3, "viewed": 262, "published": 3, "date": "1604980838", "time_retrieved": "2024-07-30T20:36:01.532708", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 blend(vec4 a, vec4 b){\n    return vec4(mix(a.rgb, b.rgb, clamp(-b.a, 0., 1.)), min(b.a, a.a));\n}\n\nvec4 cloud(vec2 uv, float seed){\n    uv.x *= mix(0.9, 1.1, hash12(vec2(seed, 0.)));\n    uv.y *= mix(0.9, 1.1, hash12(vec2(seed, -1.)));\n    float d = 0.;\n    d = sdSegment(\n        uv, vec2(-1., 0.), vec2(1., 0.)\n    ) - 0.25;\n    vec2 c1 = vec2(\n        mix(\n            -0.65, -0.55, \n            hash12(\n                vec2(seed, 1.)\n            )\n        ), \n        mix(\n            0.3, 0.45, \n            hash12(\n                vec2(seed, 2.)\n            )\n        )\n    );\n    d = min(d, length(uv - c1) - mix(0.35, 0.45, hash12(vec2(seed, 3.))));\n    vec2 c2 = vec2(\n        mix(\n            -0.1, 0.1, \n            hash12(\n                vec2(seed, 4.)\n            )\n        ), \n        mix(\n            0.45, 0.55, \n            hash12(\n                vec2(seed, 5.)\n            )\n        )\n    );\n    d = min(d, length(uv - c2) - mix(0.6, 0.7, hash12(vec2(seed, 6.))));\n    vec2 c3 = vec2(\n        mix(\n            0.5, 0.6, \n            hash12(\n                vec2(seed, 7.)\n            )\n        ), \n        mix(\n            0.3, 0.4, \n            hash12(\n                vec2(seed, 8.)\n            )\n        )\n    );\n    d = min(d, length(uv - c3) - mix(0.4, 0.5, hash12(vec2(seed, 9.))));\n    return vec4(1., 1., 1., d * 20.);\n}\n\nvec4 clouds(vec2 uv){\n    uv /= 1.2;\n    vec2 lv = uv;\n    vec2 rep = vec2(4., 2.);\n    vec2 id = floor(vec2(uv.x / 5. + iTime / 4. * floor(uv.y / 2. + 1.), uv.y / 2.));\n    id.y = floor(uv.y / rep.y) * rep.y;\n    uv.x -= (2. - id.y / 10.) * iTime;\n    id.x = floor(uv.x / rep.x) * rep.x;\n    \n    lv = uv - id;\n    lv.x -= 2.5;\n    lv.y -= 1.;\n    lv.x -= mix(-0.5, 0.5, hash12(id));\n    lv.y -= mix(-.8, .2, hash12(id));\n    return cloud(lv * 1.5, hash12(id)) * step(0., uv.y);\n    return vec4(lv, 0., step(0., uv.y) * -1.);\n}\n\nvec2 strangeTrans1(vec2 uv){\n\tvec2 lv = uv;\n    lv.y += 4.2;\n    lv.x += 1.;\n    lv.y -= pow(lv.x / 6., 2.);\n    return lv;\n}\n\nvec2 strangeTrans2(vec2 uv){\n    vec2 lv = uv;\n    lv.y += 3.8;\n    lv.x -= 1.;\n    lv.y -= pow(lv.x / 5.8, 2.);\n    return lv;\n}\n\nvec4 wires(vec2 uv){\n    vec2 lv = uv;\n    vec4 ans = vec4(0., 0., 0., 0.);\n    lv = uv - vec2(0., 0.7);\n    float d = sdSegment(lv, vec2(-7., -7), vec2(-7., -3.)) - 0.1;\n    d = min(d, sdSegment(lv, vec2(-8., -3.5), vec2(-6., -3.)) - 0.07);\n    d = min(d, sdSegment(lv, vec2(-6.5, -3.12), vec2(-7., -3.9)) - 0.07);\n    \n    \n    \n    vec4 pole1 = vec4(0.64, 0.43, 0.39, d * 30.);\n    lv = uv - vec2(0., 0.7);\n    d = sdSegment(lv, vec2(7., -7), vec2(7., -3.)) - 0.1;\n    d = min(d, sdSegment(lv, vec2(6., -3.5), vec2(8., -3.)) - 0.07);\n    //d = min(d, sdSegment(lv, vec2(6., -4.), vec2(8., -3.5)) - 0.07);\n    d = min(d, sdSegment(lv, vec2(7.5, -3.12), vec2(7., -3.9)) - 0.07);\n    vec4 pole2 = vec4(0.64, 0.43, 0.39, d * 30.);\n    \n    ans = blend(ans, pole1);\n    \n    lv = strangeTrans1(uv);\n    d = sdSegment(lv, vec2(-7., 0.), vec2(7., 0.)) - 0.05;\n    /*lv = uv;\n    lv.y += 3.8;\n    lv.x -= 1.;\n    lv.y -= pow(lv.x / 5.8, 2.);*/\n    lv = strangeTrans2(uv);\n    d = min(d, sdSegment(lv, vec2(-7., 0.), vec2(7., 0.)) - 0.05);\n    vec4 wire = vec4(0., 0., 0., d * 20.);\n    ans = blend(ans, wire);\n    \n    ans = blend(ans, pole2);\n    \n    return ans;\n}\n\nvec4 pigeon(vec2 uv){\n    uv -= vec2(0.3, 1.2);\n    float d = sdSegment(uv, vec2(0., -0.2), vec2(0., -1.)) - 0.22;\n    d = min(d, sdSegment(uv, vec2(-0.5, -1.), vec2(0., -1.)) - 0.32);\n    vec4 ans = vec4(0.47, 0.51, 0.72, d * 40.);\n    ans = blend(ans, vec4(0.37, 0.41, 0.62, 40. * (sdSegment(uv, vec2(-0.7, -0.85), vec2(-.1, -0.8)) - 0.2)));\n    \n    ans = blend(ans, vec4(0.37, 0.41, 0.62, 40. * (sdSegment(uv, vec2(0.15, -0.3), vec2(0.25, -0.3)) - 0.05)));\n    \n    ans = blend(ans, vec4(1., 1., 1., 40. * (length(uv / vec2(1., 0.7) - vec2(0., -0.23)) - 0.1)));\n    return ans;\n}\n\nvec4 pigeons(){\n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 10.;\n    \n    vec4 res = vec4(0., 0.8, 0.9, 1.);\n    //res = blend(res, cloud(uv, iTime));\n    res = blend(res, clouds(uv));\n    res = blend(res, wires(uv));\n\t//res = blend(res, pigeon(uv));\n    //uv.y += iTime;\n    \n    vec2 sh = mix(vec2(10., -5.), vec2(-5., 0.), min(iTime / 5., 1.));\n    //vec2 sh = vec2(iTime, -3.);\n    \n    //res = blend(res, pigeon(strangeTrans1( uv ) + sh ));\n    for (float i = 0.; i < 8.; ++i){\n        //float iter = floor(iTime / 5. / 3.);\n        float t_ = iTime / 8. - hash12(vec2(i * i)) / 3.;\n        float t = fract(t_ / 5. + i / 8.) * 6.;\n        float id = floor(t_ / 5. + i / 8.);\n        vec2 b = vec2(13., mix(-3., -5., hash12(vec2(i * 1.413, id))));\n        vec2 m = vec2(mix(6., -5., hash12(vec2(i * 35.4, id))), 0.);\n        vec2 e = vec2(-13., mix(-3., -5., hash12(vec2(i * 43.4, id))));\n        float leaveT = mix(2., 3., hash12(vec2(i * 153.4, id)));\n        sh = mix( mix(b, m, clamp(t, 0., 1.)), mix(m, e, clamp(t, leaveT, leaveT + 1.) - leaveT), step(leaveT, t)  );\n        \n        res = blend(res, pigeon(\n            mix(strangeTrans1( uv ), strangeTrans2( uv ), \n                step(0.5, hash12(vec2(i * 123.4, id)))\n            ) + sh \n        ));\n    }\n    \n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = res;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 63, 63, 213], [215, 265, 317, 317, 436], [438, 438, 465, 465, 539], [541, 541, 573, 573, 1789], [1791, 1791, 1812, 1812, 2319], [2321, 2321, 2349, 2349, 2446], [2448, 2448, 2476, 2476, 2577], [2579, 2579, 2599, 2599, 3740], [3742, 3742, 3763, 3763, 4325], [4327, 4327, 4342, 4342, 4365], [4367, 4367, 4424, 4474, 5843]]}
{"id": "WstfD8", "name": "XDoG", "author": "between", "description": "Gaussian Filter use the code from: https://www.shadertoy.com/view/ltScRG\nthe XDoG Filter come from: XDoG: An eXtended difference-of-Gaussians compendium including advanced image stylization", "tags": ["dog", "xdog"], "likes": 4, "viewed": 472, "published": 3, "date": "1604977554", "time_retrieved": "2024-07-30T20:36:02.365481", "image_code": "    const int samples = 35,\n              LOD = 2,    // gaussian done on MIPmap at scale LOD\n        sLOD = 1 << LOD;  // tile size = 2^LOD\n    const float sigma = float(samples) * .25;\n    // used in grayScale\n    const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    float gaussian(vec2 i) { return exp(-.5 * dot(i /= sigma, i)) / (6.28 * sigma * sigma); }\n\n    vec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n        vec4 O = vec4(0);\n        int s = samples / sLOD;\n\n        for (int i = 0; i < s * s; i++) {\n            vec2 d = vec2(i % s, i / s) * float(sLOD) - float(samples) / 2.;\n            vec4 temp = textureLod(sp, U + scale * d, float(LOD));\n            O += vec4(gaussian(d) * temp);\n        }\n\n        return O / O.a;\n    }\n\n    // XDoG parameters\n    const float Epsilon = 0.01;\n    const float Phi = 200.0;\n    const float Sigma = 0.2;\n    const float k = 1.5;\n    const float p = 0.97;\n\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n\n        // Two Gaussian blur\n        vec3 blurImage1 = blur(iChannel0, uv, vec2(k * Sigma / iResolution)).rgb;\n        vec3 blurImage2 = blur(iChannel0, uv, vec2(Sigma / iResolution)).rgb;\n        blurImage1 = vec3((blurImage1 * W).g);\n        blurImage2 = vec3((blurImage2 * W).g);\n        float diff = blurImage1.r  - p * blurImage2.r;\n\n        if (diff < Epsilon) {\n            diff = 0.0;\n        } else {\n            diff = 0.5 + tanh(Phi * diff);\n        }\n\n        // XDoG\n        fragColor = vec4(vec3(13.0 * (diff)), 1.0);\n\n        // Just DoG\n        // fragColor = vec4(20.0*(blurImage1-blurImage2),1.0);\n    }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 296, 296, 361], [367, 367, 412, 412, 741], [912, 912, 967, 1021, 1690]]}
{"id": "WsdfW8", "name": "Sine Wave Curve Fitting", "author": "oneshade", "description": "Fitting a sine wave between sets of points to create a nice curvy shape.", "tags": ["wave", "sine", "curve", "curvefitting"], "likes": 11, "viewed": 347, "published": 3, "date": "1604968669", "time_retrieved": "2024-07-30T20:36:03.214212", "image_code": "// Fits half of a sine wave between two points:\nfloat curve(in vec2 p, in vec2 a, in vec2 b, in float thickness) {\n    if (min(a.x, b.x) < p.x && p.x <= max(a.x, b.x)) {\n        float sine = sin(((p.x - a.x) / (b.x - a.x) * 2.0 - 1.0) * 1.5707963267);\n        float cy = a.y + (0.5 + 0.5 * sine) * (b.y - a.y);\n        return smoothstep(thickness, 0.0, abs(p.y - cy));\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float color = 0.0;\n    vec2[5] points;\n\n    // Calculate points' positions based on the time and draw them:\n    for (int i=0; i < points.length(); i++) {\n        points[i] = vec2(i - points.length() / 2, sin(float(i) - iTime) * (mod(float(i), 2.0) * 2.0 - 1.0));\n        color += smoothstep(0.05, 0.0, length(uv - points[i]) - 0.1);\n    }\n\n    // Draw a curve between pairs of points:\n    for (int i=1; i < points.length(); i++) {\n        color += curve(uv, points[i - 1], points[i], 0.05);\n    }\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 114, 114, 393]]}
{"id": "wdcfDH", "name": "Lego Junkbot", "author": "1j01", "description": "Based on https://www.shadertoy.com/view/MsB3zK\n[mouse drag] - camera position\n#define ANTIALIASING - Activate antialiasing (line 6 of Buffer A tab)\n\nAlso check out my playable HTML5 Junkbot remake:\nhttps://github.com/1j01/janitorial-android", "tags": ["raymarching", "trash", "distancefunction", "robot", "lego", "legoman", "minifig", "junkbot", "recycling"], "likes": 17, "viewed": 521, "published": 3, "date": "1604965743", "time_retrieved": "2024-07-30T20:36:04.232490", "image_code": "// See \"Buffer A\" tab for main code, info, and configuration\n//\n// This shader is a postprocessing step that adds a tilt-shift defocus effect,\n// based on the color (RGB) and depth information stored in the alpha channel.\n//\n// https://en.wikipedia.org/wiki/Depth_of_field\n\n\n\n\n// Created by sebastien durand - 05/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//---------------------------------------------------\n// The depth of field process:\n// For each of the neighboring pixels, the algorithm calculates if the\n// reconstructed 3D point of a pixel is effectively in the\n// 3D cone (circle) of confusion of the pixel. Otherwise it is ignored.\n// This avoids artfacts on the edges of objects.\n// The valid neighboring pixels are averaged together.\n//\n// Inspired by Dave Hoskins bokeh disc [https://www.shadertoy.com/view/4d2Xzw]\n//---------------------------------------------------\n\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float fov = 12.;\nconst float aperture = 1.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA = 2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec2 res;\n    \n\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * res.x/res.y,  (2.* q.y - 1.), fov));\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2./iResolution.y) * (1.+t));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n\tvec4 colMain = texture(tex, uv);\n    \n    const float amount = 1.;\n    \n    float rad = min(.3, coc(abs(colMain.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n    \n    float r=1.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    \n\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    \n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<120;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        \n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n    \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    \n    res = iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.xy)*6.28;\n    vec3 ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y));\n\n    float fdist = length(ro);//; 64.;\n    \n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor=vec4(dof(iChannel0,uv,fdist),2.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n}\n\n\n#endif", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24528, "src": "https://soundcloud.com/user455094288/junkbot-undercover-theme", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Lego Junkbot by Isaiah Odhner - 2020-11-9\n// Based on \"Go Go LegoMan !\" by sebastien durand - 01/2014\n// https://www.shadertoy.com/view/MsB3zK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define ANTIALIASING\nconst float AA = 3.; // Anti-Aliasing Level (uncomment #define ANTIALIASING to use)\n\n//#define DYNAMIC_WRAP_INTERVAL\n//#define RUBBISH\n//#define DEBUG_RECYCLING_SYMBOL\n\n// Possible Improvements:\n// - Get brick proportions just right; I think the sloped brick is a little too tall, and maybe the square brick is a little short?\n// - Add rubbish in bins. Work started - uncomment #define RUBBISH to see.\n// - It would be nice if the ground was made of lego.\n// - Prevent feet clipping into ground when walking.\n// - Also the animation could be a lot more dynamic,\n//   by bending the legs like in Junkbot and other lego video games / animations,\n//   maybe moving junkbot forward relative to the camera for part of the walk cycle.\n//   Note that texturing the legs currently duplicates code for rotation based on the animation.\n// - Better camera control\n// - Of course other elements from the game could be added, even interactivity.\n\n#define TAO 6.28318530718\n#define NB_ITER 120\n#define MAX_DIST 400.\n#define PRECISION .002\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst vec2 \n    V01 = vec2(0,1),\n    Ve = vec2(.001,0),\n    leg1 = vec2(0,-.1),\n    leg2 = vec2(0,-.8),\n    hand2 = vec2(-.1,.25);\t\n\nconst vec3\n    bhat = vec3(.47*4.*.392,.14,.45),\n    bbody = vec3(.47*4.*.392,.14*3.,.45*2.),\n    bbody1 = vec3(.75,.6,1.),\n    v0 = vec3(0),\n    body0 = vec3(0,-.15,0),\n    head0 = vec3(0,body0.y-1.05,0),\n    hat0 = vec3(0,head0.y-.77,0),\n    middle1 = vec3(0,.44,0),\n    middle2 = vec3(.65,.1,.325),\n    middle3 = vec3(.76,0,0),\n    arm0 = vec3(.7,-.55,0),\n    hand0 = vec3(.4,1.,.5),\n    arm1 = vec3(-.25,-.5,0),\n    arm2 = vec3(-.4,-1.,-.5),\n    hand1 = vec3(.02,.15,0);\n\nconst vec3 recycling_bin_offset =\n    #ifdef DYNAMIC_WRAP_INTERVAL\n    vec3(1., 0., 0.)\n    #else\n    vec3(-1., 0., -.5)\n    #endif\n    ;\n\nconst lowp float \n    legh = 1., \n    lege=.34, \n    legx=.31, \n    handa = -.7;\n//face_a = 1.1;\n//face_r = 27.;\n\nconst float \n    face_x = 30.,    //27.*0.453596121, //face_r*cos(a); // precalcul\n    face_y = -27.*0.89120736; //face_r*sin(a); // precalcul\n\n// Global variables\nfloat time;\nvec3 sunLight, deltaMan;//, armn;\n//mat2 handmat;\nvec2 fCoord;\nint scene;\nfloat anim;\n\n#ifdef DYNAMIC_WRAP_INTERVAL\n    float wrapInterval;\n#else\n    #define wrapInterval 5.\n#endif\n\n\nfloat hash( const in vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hashsym( const in vec3 p ) {\n    return hash(p) * 2.0 - 1.0;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n        ?\n        min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(dc,nor),pc)) +\n         sign(dot(cross(ad,nor),pd))<3.0)\n        ?\n        min( min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n            dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat udQuad( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{\n    // TODO: delete me, use sdBox\n    return udQuad( vec3(p, 0), vec3(a, 0), vec3(b, 0), vec3(c, 0), vec3(d, 0) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n// h = .5, //  half of height\n// r1 = 1., //main rayon\n// r2 = .2, // top border\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float\n        a = abs(p.y)-(h-r2),\n        b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hat(in vec3 p) {\n    // yellow topper\n\n    vec3 vd = abs(p) - bbody1;\n    p.x = abs(p.x);\n    float d = length(max(abs(p)-bhat,0.0));//-.05;\n    return max(abs(p.z)-.392, d);\n}\n\nfloat head(in vec3 p) {\n    // orange sloped brick\n\n    vec3 vd = abs(p) - bbody1;\n    vd.z -= 0.16;\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.z = -p.z;\n    p.z -= .392;\n    p.y *= 4.6;\n    d = max(dot(p.zy, vec2(.5, .08))-.25,d);\n    return max(abs(p.z)-2.*.392, d);\n}\n\nfloat body(in vec3 p) {\n    // orange square brick\n\n    vec3 vd = abs(p) - bbody1;\n    p.x = abs(p.x);\n    p.z += .392;\n    float d = length(max(abs(p)-bbody,0.0))-.025;\n    return max(abs(p.z)-2.*.392, d);\n}\n\nfloat faceSticker(in vec3 p) {\n    // sticker thickness is needed especially in scene where body rotates,\n    // to avoid the face going black or darkening when it should actually get lighter (when facing into the light more)\n    float stickerThickness = .03;\n    float width = 4.0*.392 - stickerThickness * 2. - .05;\n    float height = 1.1 - stickerThickness * 2.;\n    vec3 offset = vec3(width/2., 0.4, 1.2 - stickerThickness);\n    return udQuad(p+offset,\n                  vec3(0., 0., 0.),\n                  vec3(0., height, 0.),\n                  vec3(width, height, 0.),\n                  vec3(width, 0., 0.)\n                 ) - stickerThickness;\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg1)-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg2)-.24));\n    return max(-d2,d);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\nivec2 getId(in vec3 p) {\n    return ivec2(\n        (wrapInterval*100.+p.x)/wrapInterval,\n        (wrapInterval*100.+p.z)/wrapInterval\n    )-100;\n}\n\nvec2 legoman(in vec3 p, in ivec2 id) {\n\n    float a, bodyA;\n    vec3 p0 = p;\n    float sa,ca;//, anim=0.;\n\n    if (scene!=1) {\n        anim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n    } else { // walking\n        anim = (p0.x<0.?1.:-1.)*cos(6.*iTime-4.);\n    }\n\n    if (scene==1) {\n        p += deltaMan;\n    }\n    else if(scene==2) {\n        bodyA = .12*anim;\n        R(p.yz, -bodyA);\n    }\n\n    vec2 dHat = vec2(hat(p+hat0),0.);\n    vec2 dHead = vec2(head(p+head0),1.);\n    vec2 dBody = vec2(body(p+body0),2.);\n    vec2 dFaceSticker = vec2(faceSticker(p+body0),2.);\n\n    float middle = length(max(abs(p+middle1)- middle2,0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+middle3,.06,.39,.02));\n    vec2 dMiddle = vec2(middle,3.);   \n    p.x = -abs(p.x);\n\n    vec3 p1 = p;\n    p1.y +=.77;\n\n    if (scene==1) { // id.x==0 && id.y==0) {\n        R(p1.yz, .4*anim); \n    } else if (scene == 2) {\n        R(p1.yz, 2.*bodyA); \n    }\n\n    vec2 dLeg = vec2(leg(p1+vec3(.38,.77-.77,0)),4.);\n\n    p += arm0;\n\n    if (scene!=0 || id.x==0 && id.y==0) {\n        R(p.yz, .5 - anim);\n    }\n\n    //vec2 dArm = vec2(arm(p),5.);\n    //vec2 dHand = vec2(hand(p+hand0),6.);\n\n    return minObj(\n        minObj(\n            minObj(\n                minObj(\n                    minObj(\n                        dBody,\n                        dFaceSticker\n                    ),\n                    dHead\n                ),\n                dHat\n            ),\n            dMiddle\n        ),\n        dLeg\n    );\n}\n\nfloat recycling_bin(in vec3 pos, ivec2 id) {\n    vec3 q = pos - vec3(-1.0,0.0,1.0);\n    float d = onion( sdCappedCylinder( q, vec2(0.6,1.8) ), 0.05);\n    d = max( d, pos.y ); // cut off top\n\n    // add papers (debris, rubbish, trash, refuse)\n    #ifdef RUBBISH\n    float paperThickness = 0.02;\n    for (float i = 0.; i < 5.; i += 1.) {\n        d = min(d,\n                udQuad(\n                    q - vec3(\n                        hashsym(vec3(i, id)) * 0.1,\n                        hashsym(vec3(i+30., id)) * 0.1 - 0.2,\n                        hashsym(vec3(i+60., id)) * 0.1\n                    ),\n                    vec3(hashsym(vec3(i+0.1, id)), hashsym(vec3(i+0.2, id)), hashsym(vec3(i+0.3, id))) * 0.4,\n                    vec3(hashsym(vec3(i+0.4, id))*0.1, hashsym(vec3(i+0.5, id)), hashsym(vec3(i+0.6, id))) * 0.4,\n                    vec3(hashsym(vec3(i+0.7, id))*0.1, hashsym(vec3(i-0.1, id))*0.1, hashsym(vec3(i-0.2, id))) * 0.4,\n                    vec3(hashsym(vec3(i-0.3, id)), hashsym(vec3(i-0.4, id))*0.1, hashsym(vec3(i-0.5, id))) * 0.4\n                ) - paperThickness\n               );\n    }\n    #endif\n    \n    return d;\n}\n\nvec2 DE(in vec3 p) {\n    ivec2 id = getId(p);\n    p.xz = mod(p.xz, wrapInterval)-0.5*wrapInterval;\n    vec2 obj = minObj(legoman(p, id), vec2(p.y+1.93,10.));\n    if (hash(vec3(id, 0.)) < 0.2 && scene != 1) {\n        obj = minObj(obj, vec2(recycling_bin(p + recycling_bin_offset, id), 333.));\n    }\n    return obj;\n}\n\n\nvec3 Normal(in vec3 p, in vec3 ray, in float t) {\n    float pitch = .2 * t / iResolution.x;\n\n\n    vec2 d = vec2(-1,1) * pitch;\n\n    vec3 p0 = p+d.xxx; // tetrahedral offsets\n    vec3 p1 = p+d.xyy;\n    vec3 p2 = p+d.yxy;\n    vec3 p3 = p+d.yyx;\n\n    float f0 = DE(p0).x;\n    float f1 = DE(p1).x;\n    float f2 = DE(p2).x;\n    float f3 = DE(p3).x;\n\n    vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n    //return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n    return normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0, h, t = mint+.1*hash(ro+rd);\n    for( int i=0; i<48; i++ ) {\n        //  if (t < maxt) {\n        h = DE( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += .1;\n        //  }\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\nfloat recycling_symbol(in vec2 p, bool reverse_arrow_direction) {\n    p *= 100.;\n    // this offset is for junkbot's benefit, could be factored out\n    p.x += 35.;\n    p.y -= 15.;\n    \n    if (reverse_arrow_direction) {\n        p.xy = p.yx;   \n    }\n\n    // flip depending on quadrant\n    if (p.x < 0.) {\n        if (p.y < 0.) {\n            p.x = -p.x;\n        } else {\n            p.xy = p.yx;\n        }\n    } else if (p.y < 0.) {\n        p.xy = p.yx;\n        p.x = -p.x;\n        p.y = -p.y;\n    } else {\n    \tp.y = -p.y;\n    }\n\n    const vec2 arrow_point = vec2(0., -30.); // tip\n    const float arrow_head_width = 30.; // width at base\n    const float arrow_head_length = 15.; // tip to base distance\n    const float arrow_shaft_width = 14.; // line thickness\n    const float arrow_shaft_1_length = 19.5; // length of line adjacent to arrow head\n    const float arrow_shaft_2_length = 32.; // length of tail line (away from arrow head)\n    const vec2 arrow_base_point = vec2(arrow_point.x + arrow_head_length, arrow_point.y);\n    const vec2 arrow_elbow_point = arrow_base_point + vec2(arrow_shaft_1_length, 0.);\n\n    float d = min(\n        sdTriangle(p,\n                   arrow_point,\n                   arrow_base_point + vec2(0, -arrow_head_width/2.),\n                   arrow_base_point + vec2(0, arrow_head_width/2.)\n                  ),\n        min(\n            sdBox(\n                p - arrow_base_point - vec2(arrow_shaft_1_length/2., 0.),\n                vec2(arrow_shaft_1_length/2., arrow_shaft_width/2.)\n            ),\n            sdBox(\n                p - arrow_elbow_point - vec2(\n                    arrow_shaft_1_length/2. - arrow_shaft_width,\n                    arrow_shaft_2_length/2. - arrow_shaft_width/2.\n                ),\n                vec2(arrow_shaft_width/2., arrow_shaft_2_length/2.)\n            )\n        )\n    );\n    \n    #ifdef DEBUG_RECYCLING_SYMBOL\n    const float debug_grid_thickness = 0.5;\n    const float debug_grid_interval = 5.;\n    if (\n        mod(p.x + debug_grid_thickness/2., debug_grid_interval) < debug_grid_thickness ||\n        mod(p.y + debug_grid_thickness/2., debug_grid_interval) < debug_grid_thickness\n    ) {\n        d /= 10.;\n    }\n    #endif\n    \n    return d;\n}\n\nvec3 getTexture(in vec3 p, in float m) {\n    ivec2 id = getId(p);\n\n    vec3 p0 = p;\n    p.xz = mod(p.xz, wrapInterval)-0.5*wrapInterval;\n\n    if (m != 333.) {\n        if (scene==1) {\n            p += deltaMan;\n        } else if (scene == 2) {\n\n            float anim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n\n            float bodyA = .12*anim;\n            float sa=sin(bodyA); \n            float ca=cos(bodyA);\n            p.yz *= mat2(ca, -sa, sa, ca);\n        }\n    }\n    vec3 c;   \n\n    if (m==1. || m==2.) {\n        // head or body (orange bricks)\n        c = vec3(1.,.5,0.);\n\n        // Draw blinds/grate/breadbox texture\n        vec2 p2 = p.xy;\n        p2.y -= 1.46;\n        p2 *= 100.;\n        float px = abs(p2.x);\n        float e = 4.-.08*px;\n        float v =\n            p.y < 1.73 && p.y > 0.95 && p.x > -0.5 && p.x < 0.5 ?\n            mod(p.y+.1, .15) * mod(e, 5.) * 15.\n            : 5000.; // ~infinity\n        v = clamp(v, 0., 1.);\n        c = mix(vec3(.3, .1, 0.), c, v);\n\n        float g = mod(iTime, TAO*3.);\n        //if (id.x==0 && id.y==0 && g > 2.5*TAO) {\n        //    R(p.xz, -.8*cos(2.*g+1.57));\n        //}\n        if (p.z<-1.1) {\n            // Draw face\n            vec2 p2 = p.xy;\n            p2.y -= 0.4;\n            p2 *= 100.;\n            float mouth_y = -0.;\n            float mouth_thickness = 2.;\n            float mouth_width = 40.;\n            float eye_spacing = face_x;\n            float eye_y = -face_y*1.1;\n            float eye_gaze_x = -7.;\n            if (id.x==0 && id.y==0 && g > 2.5*TAO) {\n                eye_gaze_x = -7. * cos(2.*g+1.57);\n            }\n            float px = abs(p2.x);\n            float e = 4.-.08*px;\n            float vw = // distance to white\n                // whites of the eyes\n                abs(p2.y-eye_y) < 5. ? \n                length(vec2(px,p2.y)-vec2(eye_spacing,eye_y))-5.8*e\n                : 5000.; // ~infinity \n            vw = clamp(vw, 0., 1.);\n            float pupil_x = abs(p2.x + eye_gaze_x);\n            float vb = // distance to black\n                // mouth\n                (px<mouth_width && abs(p2.y-mouth_y)<mouth_thickness) ? 0. :\n            // pupils\n            abs(p2.y-eye_y) < 5. ? \n                length(vec2(pupil_x,p2.y)-vec2(eye_spacing-5.5,eye_y))-5.8\n                : 5000.; // ~infinity \n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(2), c, vw);\n            c = mix(vec3(0), c, vb);\n        } else {\n            // Draw recycling symbol\n            float vb = recycling_symbol(p.zy, p.x < 0.);\n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(.6, .2, 0.), c, vb);\n        }\n    } else if (m==10.) {\n        // ground\n        if (scene!=1) time = 0.;\n        float d = .3*sin(2.2+time);\n        c = vec3(.75-.25*(mod(floor(p0.x),2.)+mod(floor(p0.z+d-time*.18),2.)));\n        //c = vec3(.5+.5*smin(mod(floor(p0.x),2.),mod(floor(p0.z+d-time*.18),2.),1.));\n    } else if(m == 3.) {\n        // pants crotch/hinge\n        c = vec3(.6,.6,.6);\n        //} else if(m == 6.) {\n        // hands, I guess\n        //c = vec3(1.,1.,0);\n    } else if(m == 4.) {\n        // legs\n        c = vec3(.6,.6,.6);\n\n        vec2 p2 = p.zy * 100.;\n\n        //float vg = mod(distance(p2, vec2(0., -80.)), 16.) - 4.;\n        vec2 center = vec2(0., -80.); // center of rotation of hinge joint\n\n        // rotate around center\n        p2 -= center;\n        if (scene == 1) {\n            R(p2, -.4*anim);\n        }else if (scene == 2) {\n            R(p2, -.25*anim);\n        }\n        p2 += center;\n\n        float dist_to_center = distance(p2, center);\n        // using onion technique described here https://iquilezles.org/articles/distfunctions\n        float vg = abs(abs(dist_to_center - 13.) - 5.) - 2.;\n\n        vg = min(vg,\n                 udQuad(p2,\n                        center + vec2(-2., -85.),\n                        center + vec2(+2., -85.),\n                        center + vec2(+2., -20.),\n                        center + vec2(-2., -20.)\n                       )\n                );\n        float flare_width = 5.;\n        float flare_length = 6.;\n        for (float i = 0.; i < 4.; i+=1.) {\n            vg = min(vg,\n                     udQuad(p2,\n                            center + vec2(-flare_length, -85.+flare_width*(i*2.+1.)),\n                            center + vec2(+flare_length, -85.+flare_width*(i*2.+1.)),\n                            center + vec2(+flare_length, -85.+flare_width*(i*2.+0.)),\n                            center + vec2(-flare_length, -85.+flare_width*(i*2.+0.))\n                           )\n                    );\n        }\n        vg = clamp(vg, 0., 1.);\n        c = mix(vec3(.2, .2, .2), c, vg);\n    } else if(m == 0.) {\n        c = vec3(1.2,1.2,0); // hat (yellow topper)\n    } else if(m == 333.) {\n        c = vec3(0.,0.,1.); // recycling bin (blue and white)\n\n        vec3 p2 = p + recycling_bin_offset;\n        if (length(p2.xz + vec2(1., -1.)) < .55) {\n            // inside + rubbish\n            c = vec3(1.);\n        } else {\n            float vb = recycling_symbol(p2.zy + vec2(-1.3, 1.), true);\n            vb = clamp(vb, 0., 1.);\n            c = mix(vec3(1.), c, vb);\n        }\n    } else {\n        c = vec3(1);\n    }\n    if (m==10. || !(id.x==0 && id.y==0)) {\n        // black & white\n        float a = (c.r+c.g+c.b)*.33;\n        c = vec3(1.,.95,.85)*a;\n    }\n\n    return c;\n}\n\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float m) {\n    vec3  col = getTexture(p, m),\n        nor = Normal(p, rd, t);\n    float sh = 1.,\n        ao = calcAO(p, nor ),\n        amb = clamp(.5+.5*nor.y, .0, 1.),\n        dif = clamp(dot( nor, sunLight ), 0., 1.),\n        bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n    if( dif>.02 ) { sh = softshadow( p, sunLight, .02, 10., 12.); dif *= (.1+sh); }\n\n    vec3 brdf = vec3(0.0);\n    brdf += .2*ao*amb*vec3(0.10,0.11,0.13);\n    brdf += .2*ao*bac*vec3(0.15);\n    brdf += 1.2*dif*vec3(1.,.9,.7);\n\n    float pp = /*1.1**/clamp( dot(reflect(rd,nor), sunLight ), 0.0, 1.);\n    float spe = 1.2*sh*pow(pp,16.0);\n    float fre = .2*ao*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    col = col*(brdf + spe) + .2*fre*(0.5+0.5*col);\n    return col;\n}\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n        rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return lookat(cp-ro, V01.xyx)*normalize(vec3(((iMouse.z > 0. ? 1. : 2.)*fCoord-iResolution.xy)/iResolution.y, 12.0));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    #ifdef DEBUG_RECYCLING_SYMBOL\n    float vb = recycling_symbol(fragCoord.xy/iResolution.y - vec2(1.2, 0.35), iMouse.z < 0.);\n    vb = clamp(vb, 0., 1.);\n    fragColor = mix(vec4(1.), vec4(0.,0.,1.,1.), vb);\n    return;\n    #endif\n\n    // - Precalculate global variables ------------------------------\n    time = 3.14+12.*iTime;\n    sunLight = normalize(vec3(-10.25,30.33,-7.7));\n    deltaMan = vec3(0,.05*sin(1.72+time),0);\n    //armn = normalize(arm2 - arm1);\n    //handmat = mat2(cos(handa), -sin(handa), sin(handa), cos(handa));\n\n    float tAnim = mod(iTime, 3.14*9.);  \n    scene = tAnim > 3.14*9. ? 1:\n    tAnim > 3.14*7. ? 2:\n    tAnim > 3.14*6. ? 0 : 1;\n    // The way the wrapping works, objects can't be near the boundary without artifacts,\n    // and the animations aren't continuous anyways,\n    // so space things out more while showing recycling bins\n    // and hide recycling bins during the walking animation\n    // (also avoiding animating the bins moving along the ground)\n    #ifdef DYNAMIC_WRAP_INTERVAL\n        wrapInterval = scene == 1 ? 5. : 10.;\n    #endif\n\n\n    //------------------------------------------------------------\n\n    vec2 \n        obj, \n        mouse = (iMouse.xy/iResolution.xy)*6.28,\n        q = fragCoord.xy/iResolution.xy;\n\n    vec3 \n        ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y)),\n        rd, cp = V01.xxx;\n\n    vec3 ctot = vec3(0);\n    float ttot = 0.;\n\n    #ifdef ANTIALIASING \n    for (float i=0.;i<AA;i++) \n    {\n        fCoord = fragCoord.xy+.4*vec2(cos(6.28*i/AA),sin(6.28*i/AA));\t\n        //   \tfCoord = fragCoord.xy+.5*mod(vec2(iFrame/2, iFrame),2.);\t\n        #else\n        fCoord = fragCoord.xy;\n        #endif\n        // Camera origin (o) and direction (d)\n        rd = RD(ro, cp);\n\n        // Ray marching\n        float m=0.;\n        float t=0.,d=1.;\n\n        for(int i=0;i<NB_ITER;i++){\n            if (abs(d)<PRECISION || t>MAX_DIST) break;\n            obj = DE(ro+rd*t);\n            t+=d=obj.x *.85;\n            if (abs(d)<PRECISION) {\n                m=obj.y;\n            }\n        }\n\n        // Render colors\n        if(t<MAX_DIST){// if we hit a surface color it\n            ctot += Render(ro + rd*t, rd,t, m);\n            ttot += t;\n        }\n        #ifdef ANTIALIASING \t\t\n    }\n    ctot /= AA;\n    ttot /= AA;\n    #endif \n    ctot = pow(ctot, vec3(.6));\n    ctot *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .11); // vignetting\n    fragColor = vec4(ctot,ttot);\n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": []}
{"id": "tscBDH", "name": "Logarithmic Spiral Center", "author": "tdhooper", "description": "Finding the center of a spiral formed by recursively applying a TRS matrix", "tags": ["spiral", "logarithmic"], "likes": 23, "viewed": 724, "published": 3, "date": "1604963428", "time_retrieved": "2024-07-30T20:36:05.077231", "image_code": "/*\n\n    Logarithmic Spiral Center\n    -------------------------\n\n\tThis finds your final position when recursively applying a\n\ttranslation rotation scale matrix, but without doing the\n    actual recursion.\n\n\tSee also the 3d version:\n\thttps://www.shadertoy.com/view/wslyzH\n\n\n\tMETHOD:\n\n\tIt looks at the triangle formed by the first two points and\n\tthe center of the spiral, then calculates the center from known\n\tside and angle relations...\n\n\n\n               4---3\n              /     \\\n             5  x    \\\n              \\_/     2\n                     /\n                    /  \n                   /   \n        0---------1 \n\n\n    triangles formed by first three points and the spiral center:       \n\n\n                x_    \n               /| ```-2\n             /` |    /\n           /`    |  /  \n         /`      | /   \n        0---------1 \n\n\n    note that the segment angle is the same as the iteration rotation:\n\n\n                x_    \n               /| ```-2\n             /`y|    /\n           /`    |  /  \n         /`      | /y \n        0---------1 - - - -\n\n\n\tand that the adjacent sides are related by the iteration scale (s):\n\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`      | \n        0---------1\n\t\t\t c\n\n\t\tb = a * s\n\n\n    side c is given by law of cosines:\n\n    \tc = sqrt(a^2 + b^2 - 2 * a * b * cos(y))\n\n\n   \tsubstituting a * s for b:\n\n\t\tc = sqrt(a^2 + (a * s)^2 - 2 * a * (a * s) * cos(y))\n\n\n    solve for a:\n    https://www.wolframalpha.com/widgets/view.jsp?id=c778a2d8bf30ef1d3c2d6bc5696defad\n\t\n\t\ta = c / sqrt(s^2 - 2 * s * cos(y) + 1)\n\n\n\tand get b:\n\t\n\t\tb = a * s;\n\n\n    find opposite angle to side b using sine law:\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`k     | \n        0---------1\n\t\t\t c\n\n        k = a * sin(b * sin(y) / c);\n\n\n\tfind center using side a and angle k...\n\t\n\n*/\n\nvec2 spiralCenter(vec2 translation, float rotation, float scale) {\n\t// find sides and angles of segment triangle\n    float c = length(translation);\n\tfloat a = c / sqrt((scale * scale) - 2. * scale * cos(rotation) + 1.);\n\tfloat b = a * scale;\n\tfloat k = asin(b * sin(-rotation) / c);\n    // add angle from translation and calculate center\n    k += atan(translation.x, translation.y);\n    vec2 center = vec2(sin(k), cos(k)) * a;\n  \treturn center;\n}\n\n\n// shortened version from FabriceNeyret2\n// https://www.shadertoy.com/view/WdVczz\n// I'd like to explain this, but I don't know the steps taken\nvec2 spiralCenter2(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat3 translateM(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rotateM(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scaleM(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nmat3 trsMatrix(vec2 translation, float rotation, float scale) {\n\treturn scaleM(vec2(scale)) * rotateM(rotation) * translateM(translation);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\n\n\n// Drawing\n// --------------------------------------------------------\n\nvec3 col;\n\nvoid draw(float d, vec4 c) {\n    d /= fwidth(d);\n    d = clamp(d, 0., 1.);\n    d = 1. - d;\n    d *= c.a;\n    col = mix(col, c.rgb, d);\n}\n\nvoid draw(float d, vec3 c) {\n\tdraw(d, vec4(c, 1));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n// Demo\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n\n    p -= vec2(-1,0);\n    \n    col = vec3(.014,.01,.02);\n    \n    float beat = sin(iTime) * .5 + .5;\n    float beat2 = sin(iTime / 2.) * .5 + .5;\n    \n    \n    // Translation, rotation, scale for each iteration\n    \n    float a = mix(PI / 2., -PI / 2., beat) * (beat2) + PI / 2.;\n  \tvec2 trs = vec2(sin(a), cos(a)) * mix(.75, .4, beat2);\n    float rot = mix(1., -1., beat);\n    float scl = mix(.5, .99, beat2);\n    \n    if (iMouse.z > 0.) {\n    \tvec2 m = (-iResolution.xy + 2.*iMouse.xy)/iResolution.y;\n    \tm -= vec2(-1,0);\n        trs = vec2(.5,0);\n        vec2 pt = m - trs;\n        rot = atan(pt.y, pt.x);\n        scl = length(pt) / length(trs);\n    }\n\n    \n    // Calculate center\n    \n    vec2 center = spiralCenter(trs, rot, scl);    \n\n    \n    // Draw spiral\n    \n    mat3 mat = trsMatrix(trs, rot, scl);\n    mat3 compound = mat;   \n    vec2 pt = vec2(0);\n    vec2 lastPt = pt;\n    \n    int n = 20;\n    for (int i = 0; i < n; i++) {\n        \n        float t = float(i) / float(n);\n        t = pow(t, .5);\n        float fade = smoothstep(1., .75, t);\n\n        draw(line(p, center, pt) - .0025, vec4(1, 1, 1, .1 * fade));\n        draw(length(p - pt) - .015, vec4(0,.33,.33, fade));\n        draw(line(p, lastPt, pt) - .01, vec4(0,.33,.33, .2 * fade));\n        \n        lastPt = pt;\n        pt = mul(vec2(0), compound);\n        compound = mat * compound;\n    }\n    \n    \n    // Draw center\n\n    draw(length(p - center) - .03, vec3(1));\t\n    \n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1891, 1891, 1957, 2003, 2337], [2340, 2484, 2551, 2551, 2747], [2832, 2832, 2857, 2857, 2904], [2906, 2906, 2929, 2929, 2993], [2995, 2995, 3016, 3016, 3063], [3065, 3065, 3128, 3128, 3205], [3207, 3207, 3233, 3233, 3266], [3353, 3353, 3381, 3381, 3489], [3491, 3491, 3519, 3519, 3543], [3545, 3545, 3581, 3581, 3700], [3795, 3795, 3852, 3852, 5428]]}
{"id": "ts3BDH", "name": "simulation of photoshop glitch", "author": "morisil", "description": "https://www.instagram.com/kinky_glitches/\n", "tags": ["camera", "glitch"], "likes": 4, "viewed": 676, "published": 3, "date": "1604959312", "time_retrieved": "2024-07-30T20:36:05.994777", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nconst float LOW_LUMA = .3;\nconst float HIGH_LUMA = .7;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = floor(iTime);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mirrorUv = vec2(1. - uv.x, uv.y);\n    vec3 cameraColor = texture(iChannel0, mirrorUv).rgb;\n    float luma = cameraColor.r; // maybe should be more sophisticated\n    vec3 color;\n    if (luma < LOW_LUMA || luma > HIGH_LUMA) {\n        float index = mod(fragCoord.y, 8.);\n        if (index < 2.) {\n            color = vec3(0.);\n        } else {\n            color = vec3(\n                random(fragCoord.xy + time),\n                random(fragCoord.xy + 100. + time),\n                random(fragCoord.xy + 200. + time)\n            );\n        }\n    } else {\n        color = cameraColor;\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3BDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 99], [157, 157, 212, 212, 918]]}
{"id": "wscBWH", "name": "Melting fractal", "author": "makio135", "description": "Raymarching based on iq template\nPlaying with folding space", "tags": ["raymarching"], "likes": 26, "viewed": 768, "published": 3, "date": "1604955949", "time_retrieved": "2024-07-30T20:36:06.857471", "image_code": "//#define u_resolution iResolution\n//#define u_time iTime\n\n#define AA 1\n\n#define MIN_DIST 0.001\n#define MAX_DIST 50.\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if(k < 0.0) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 opSymXYZ(vec3 p) {\n    p = abs(p);\n    return p;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvoid mengerFold(inout vec3 z) {\n    float a = min(z.x - z.y, 0.0);\n    z.x -= a;\n    z.y += a;\n    a = min(z.x - z.z, 0.0);\n    z.x -= a;\n    z.z += a;\n    a = min(z.y - z.z, 0.0);\n    z.y -= a;\n    z.z += a;\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n    z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n\nfloat glow = 0.;\nvec2 sceneSDF(vec3 p) {\n    float t = iTime * .1;\n    t = easeInOutQuad(mod(t, 1.));\n    vec2 d = vec2(10e5, 0);\n\n    for(int i = 0; i < 5; i++) {\n        p = opSymXYZ(p);\n        mengerFold(p);\n        boxFold(p, vec3(.5));\n        p.x -= .2;\n        p *= rotate3D(t * TAU, vec3(1, 1, 0));\n        p *= .95;\n        p *= rotate3D(-t * TAU, vec3(0, 1, 1));\n\n        float dd = sdRoundCone(p, 1.6, .1, 1.6);\n        if(i == 3) glow += 0.006 / (0.01 + dd * dd * 5.) / (float(AA * AA) * 10.);\n    }\n    d = opUnion(d, vec2(sdBox(p, vec3(.8, .1, .1)), 2.));\n\n    return d;\n}\n\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n\n    #if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n    #endif\n\n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = sceneSDF(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n    // epsilon = a small number\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy).x + \n        e.yyx * sceneSDF(pos + e.yyx).x + \n        e.yxy * sceneSDF(pos + e.yxy).x + \n        e.xxx * sceneSDF(pos + e.xxx).x\n    );\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = sceneSDF(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor); // reflected ray\n\n    // material\n    vec3 col = vec3(202, 82, 68)/255.;\n\n    // lighting        \n    float occ = calcAO(pos, nor); // ambient occlusion\n    vec3 lig = normalize(vec3(-0.4, 0.7, -0.6)); // sunlight\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0); // ambient light\n    float dif = clamp(dot(nor, lig), 0.0, 1.0); // diffuse reflection from sunlight\n    // backlight\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y); // dome light\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0); // fresnel\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0); // specular reflection\n\n    dif *= softshadow(pos, lig, 0.02, 2.5);\n    dom *= softshadow(pos, ref, 0.02, 2.5);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 2.00 * spe * vec3(1.00, 0.90, 0.70) * dif;\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col = col * lin;\n\n    return col;\n}\n\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n    // cast ray to nearest object\n    vec2 res = castRay(ro, rd);\n    float distance = res.x; // distance\n    float materialID = res.y; // material ID\n\n    vec3 col = vec3(0.6 - length((gl_FragCoord.xy - iResolution.xy / 2.) / iResolution.x));;\n        if(materialID > 0.0) {\n            vec3 pos = ro + distance * rd;\n            col = computeColor(ro, rd, pos, distance, materialID);\n        }\n    return vec3(clamp(col, 0.0, 1.0));\n}\nvoid init() {}\n\nvec3 effect(vec3 c) {\n    c += glow * vec3(242, 223, 126)/255.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Ray Origin)\\t\n    vec3 ro = vec3(-5, 2.5, -6) * 2.2 * rotate3D(iTime * .05 * TAU, vec3(0, 1, 0));\n    vec3 ta = vec3(0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 color = vec3(0.0);\n\n    #if AA>1\n    for(int m = 0; m < AA; m++)\n        for(int n = 0; n < AA; n++) {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n            #else\n            vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n            #endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\\t\n            vec3 col = render(ro, rd);\n\n            color += col;\n            #if AA>1\n        }\n    color /= float(AA*AA);\n    #endif\n\n    color = effect(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 207, 207, 364], [366, 366, 428, 428, 699], [701, 701, 736, 736, 762], [764, 764, 796, 796, 832], [834, 834, 857, 857, 889], [891, 891, 921, 921, 1051], [1053, 1092, 1130, 1130, 1539], [1541, 1541, 1572, 1572, 1751], [1753, 1753, 1789, 1789, 1838], [2431, 2474, 2524, 2524, 2710], [2712, 2886, 2924, 2924, 3547], [3550, 3773, 3845, 3845, 4117], [4119, 4197, 4227, 4259, 4508], [4510, 4570, 4610, 4610, 4916], [4919, 4919, 4984, 4984, 6235], [6238, 6313, 6350, 6385, 6788], [6789, 6789, 6802, 6802, 6803], [6805, 6805, 6826, 6826, 6884]]}
{"id": "tscfW8", "name": "Tractrix", "author": "oneshade", "description": "Animation of a tractrix or \"curve of pursuit.\"", "tags": ["curve", "tractrix", "pursuit"], "likes": 2, "viewed": 126, "published": 3, "date": "1604935995", "time_retrieved": "2024-07-30T20:36:07.690244", "image_code": "float line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return smoothstep(2.0 / iResolution.y, 0.0, length(pa - ba * h) - 0.005);\n}\n\nfloat circle(in vec2 p, in vec2 o, in float r) {\n    return smoothstep(2.0 / iResolution.y, 0.0, length(p - o) - r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (float i=0.0; i < 1.1; i += 0.1) {\n        float tractrixLine = line(uv, vec2(0.0, 1.0 - i), vec2(i, 0.0));\n        color += tractrixLine;\n    }\n\n    vec2 pursueePos = vec2(fract(0.25 * iTime), 0.0);\n    vec2 pursuerPos = mix(vec2(0.0, 1.0 - pursueePos.x), pursueePos, pursueePos.x);\n\n    float pursuitLine = line(uv, pursueePos, pursuerPos);\n    float pursuee = circle(uv, pursueePos, 0.04);\n    float pursuer = circle(uv, pursuerPos, 0.04);\n\n    color = pursuitLine > 0.0 ? vec3(0.0, pursuitLine, 0.0) : color;\n    color = pursuee > 0.0 ? vec3(0.0, 0.0, pursuee) : color;\n    color = pursuer > 0.0 ? vec3(pursuer, 0.0, 0.0) : color;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 216], [218, 218, 266, 266, 336], [338, 338, 393, 393, 1152]]}
{"id": "tdtBDr", "name": "raton-miki", "author": "jorge2017a1", "description": "raton-miki", "tags": ["ratonmiki"], "likes": 1, "viewed": 240, "published": 3, "date": "1604935754", "time_retrieved": "2024-07-30T20:36:08.733455", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n//#define MIN_DIST 0.001\n#define MIN_DIST 0.01\n#define EPSILON 0.01\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\nvec3 HacerPielCara(vec3 p, vec3 pCabeza)\n{\n\n    vec3 res;\n    \n    res = vec3(9999.0, -1.0,-1.0);\n    res = pCabeza;\n    \n    float sdPielDer= sdEllipsoid(p-  vec3(2.0,10.0,-9.0), vec3(4.0,4.0,1.5) );\n    float sdPielIzq= sdEllipsoid(p- vec3(-2.0,10.0,-9.0), vec3(4.0,4.0,1.5) );\n    \n    float distCabeza=pCabeza.x;\n    //--------\n    \n    float  sU= unionSDF(sdPielDer, sdPielIzq);\n  \tfloat difsu;\n    //restar Iris hoyo\n\tdifsu= differenceSDF(distCabeza, sdPielIzq);\n    difsu= differenceSDF(difsu, sdPielDer);\n    \n     //sumar Iris hoyo\n    \n    float InterOjoIrisIzq=intersectSDF(distCabeza,sdPielDer);\n    float InterOjoIrisDer=intersectSDF(distCabeza,sdPielIzq);    \n    \n    float pt1=mod(iTime, 2.0);\n    float pt2=mod(pt1, 1.0);\n        \n    if (pt2<pt1)\n \t{       \n    res=opU3(res, vec3(InterOjoIrisIzq,19.0,-1.0));\n    res=opU3(res, vec3(InterOjoIrisDer,19.0,-1.0));\n\t}else\n    {       \n    res=opU3(res, vec3(InterOjoIrisIzq,11.0,-1.0));\n    res=opU3(res, vec3(InterOjoIrisDer,11.0,-1.0));\n\t}\n        \n    return res;   \n} \n\n\n\nvec3 HacerOjoMickeyV2(vec3 p,vec3 Pcabeza)\n{\n\n    vec3 res;\n    \n    //res = vec3(9999.0, -1.0,-1.0);\n    res=Pcabeza;\n    float distCabeza;\n    float posOjo=4.0*abs(sin(iTime));\n    float sdOjoDer= sdEllipsoid(p- vec3(2.0,10.5,-9.0), vec3(1.5,3.0,1.5) );\n    float sdOjoIzq= sdEllipsoid(p- vec3(-2.0,10.5,-9.0), vec3(1.5,3.0,1.5) );\n    \n    float sdIrisDer= sdEllipsoid(p- vec3(2.0,9.0+posOjo,-10.0), vec3(0.5,1.0,1.5) );\n    float sdIrisIzq= sdEllipsoid(p- vec3(-2.0,9.0+posOjo,-10.0), vec3(0.5,1.0,1.5) );\n    \n    float  sU= unionSDF(sdOjoIzq, sdOjoDer);\n  \n    //restar Iris hoyo\n\tsU= differenceSDF(sU, sdIrisIzq);\n    sU= differenceSDF(sU, sdIrisDer);\n    \n    \n     //sumar Iris hoyo\n    \n    float InterOjoIrisIzq=intersectSDF(sdOjoIzq,sdIrisIzq);\n    float InterOjoIrisDer=intersectSDF(sdOjoDer,sdIrisDer);\n    \n    \n   \n    res=opU3(res, vec3(sU,1.0,-1.0));\n    res=opU3(res, vec3(InterOjoIrisIzq,0.0,-1.0));\n    res=opU3(res, vec3(InterOjoIrisDer,0.0,-1.0));\n    \n  \n    \n    return res;\n}\n    \n\n\n\nvec3 UnirCabezayOjo(vec3 p, vec3 pOjo )\n{\n\t vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float sdCabeza= sdSphere( p-vec3(0.0,10.0,0.0), 10.0 );\n    vec3 rescabezaMat=vec3(sdCabeza, 11,-1.0);\n   \n    \n    float DifCabezaOjo= differenceSDF(sdCabeza, pOjo.x-0.2);\n    float InterCabezaOjo=intersectSDF(sdCabeza, pOjo.x);\n    \n    res=opU3(res, vec3(DifCabezaOjo, 11,-1.0));\n    res=opU3(res, vec3(InterCabezaOjo, pOjo.y, pOjo.z));\n   \n    return res;\n}\n\n\n\nvec3 BocaSonrisa(vec3 p)\n{\n \tvec3 res = vec3(9999.0, -1.0,-1.0);\n    float largo1=6.0;\n    float largo2=largo1-0.5;\n    float largo3bx=largo1+0.9;\n        \n    float sdcy1= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(largo1,3.0) );\n    float sdcy2= sdCylinderXY(p-vec3(-0.7,-1.5,0.0), vec2(largo2,3.5) );\n    float sdb1= sdBox(p-vec3(0.0,0.5,0.0), vec3(largo3bx,3.0,3.6));   \n    float dif; \n    dif= differenceSDF(sdcy1, sdcy2); \n    dif= differenceSDF(dif, sdb1); \n    res =opU3(res, vec3(dif,0.0,MATERIAL_NO));        \n    \n    \n    return res;\n}\n\n    \n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n \tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n \n    p.y=p.y-5.0;\n \n  \n    float sdCabeza= sdSphere( p-vec3(0.0,10.0,0.0), 10.0 );\n    float sdOrejaIzq= sdEllipsoid(p- vec3( 7.0,18.0,-6.0), vec3(5.0,5.0,2.5) );\n    float sdOrejaDer= sdEllipsoid(p- vec3(-7.0,18.0,-6.0), vec3(5.0,5.0,2.5) );\n\t\n    ///nariz\n    float sdNarizA= sdEllipsoid(p- vec3(0.0,6.0,-9.0), vec3(4.0,2.0,2.5) );\n    float sdNarizB= sdEllipsoid(p- vec3(0.0,6.0,-12.0), vec3(2.0,1.5,1.5) );\n    \n    \n    float sUnionCabeza;\n    sUnionCabeza=sdCabeza;\n    \n    res =opU3(res, vec3(sUnionCabeza,11.0,-1)); \n\tres= HacerPielCara(p, res);\n\tvec3 resOjo= HacerOjoMickeyV2( p,res);\n    res= UnirCabezayOjo( p, resOjo );\n    \n    \n    res =opU3(res, vec3(sdNarizB,2.0,-1)); \n    \n    res =opU3(res, vec3(sdOrejaIzq,11.0,-1)); \n    res =opU3(res, vec3(sdOrejaDer,11.0,-1)); \n    \n    \n    res =opU3(res, vec3(sdNarizA,11.0,-1)); \n    \n    \n    \n     sdCabeza=res.x;\n    vec3 rBoca=BocaSonrisa(p-vec3(0.5,9.0,-5.0));\n    float boca=rBoca.x;\n    float difCabezaboca= differenceSDF(sdCabeza, boca);   \n    float intersecionCabezaBoca= intersectSDF(sdCabeza,boca);\n    res =opU3(res, vec3(intersecionCabezaBoca,0.0,MATERIAL_NO)); \n    \n    \n    \n    ///plano\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); \n    \n    \n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n   \n    \n    float diff = dot(normal, l);\n    \n    //vec3 v = normalize( p - ro );\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        \n        if(dO>MAX_DIST )\n        {\t\n          break;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n        \n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\treturn vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    \n  \n     ///--------------- por spalmer rotacion orbital\n    ///---------------\n    vec2 R = iResolution.xy;\n    vec2 M = iMouse.xy;\n     M.y = M.y+1.0;\n    vec2 q = StoQ(   fragCoord, R);\n    vec2 m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.0)\n  \n        m = vec2(.2 + .1*iTime,-.015); // unattended, mouse in bottom left corner?\n    \n    \n    vec3 object_pos = vec3(0., radius, 0.);\n        \n    vec3 camera_dir = OrbitCamera(m);\n    vec3 camera_pos = object_pos - orbit_scale * radius * camera_dir; // LookAt\n    \n    \n\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n\n    \n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = PI/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n    vec3 ro = camera_pos;\n    vec3 rd = normalize(cam * vd); // view ray\n    //-------------------\n    \n    \n   \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\n///----------Orbit Camera\n///---------https://www.shadertoy.com/view/WlVGD1\n///----------Creditos de : spalmer en 2020-01-12\n///--------------------------------------------INICIO\nconst float orbit_scale = 4.0; // of radius of object\nconst float radius = 9.0; // of object resting on ground to examine\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y; \n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x), cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * PI, 1.));\n} \n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 425, 461, 461, 482], [485, 485, 517, 517, 601], [603, 603, 642, 642, 737], [738, 738, 777, 777, 872], [873, 873, 912, 912, 1007], [1009, 1053, 1100, 1100, 1127], [1129, 1129, 1172, 1172, 1199], [1201, 1201, 1249, 1249, 1277], [1325, 1350, 1384, 1384, 1482], [1483, 1483, 1517, 1517, 1609], [1610, 1610, 1644, 1644, 1736], [1737, 1777, 1811, 1811, 1908], [1911, 1911, 1948, 1948, 2031], [2035, 2035, 2077, 2077, 3071], [3076, 3076, 3120, 3120, 4077], [4086, 4086, 4127, 4127, 4545], [4549, 4549, 4575, 4575, 5095], [5102, 5142, 5167, 5167, 6518], [6523, 6523, 6609, 6609, 7375], [7381, 7432, 7456, 7456, 7644], [7645, 7708, 7741, 7741, 8326], [8328, 8382, 8418, 8418, 8652], [8709, 8709, 8758, 8758, 8980], [8981, 9015, 9095, 9095, 9372], [9416, 9467, 9514, 9514, 10422], [10476, 10476, 10569, 10569, 10991], [10996, 11045, 11102, 11102, 13142]]}
{"id": "Wd3fDH", "name": "Ekranoplan", "author": "dr2", "description": "The \"Caspian Sea Monster\" - an unsuccessful ocean skimmer", "tags": ["ocean", "aircraft", "flight", "wake"], "likes": 24, "viewed": 511, "published": 3, "date": "1604928349", "time_retrieved": "2024-07-30T20:36:09.729791", "image_code": "// \"Ekranoplan\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, flyPos, flyVel;\nfloat tCur, dstFar, flyRol, tDor, wkFac;\nint idObj;\nconst int idFus = 1, idCkp = 2, idEng = 3, idHul = 4, idWngT = 5, idWngM = 6, idTail = 7,\n   idFlt = 8, idESup = 9, idTCap = 10, idCov = 11, idMis = 12, idSil = 13;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, s, de, dc;\n  dMin = dstFar;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  r = 1.;\n  if (q.z < -0.5) {\n    s = q.z + 0.5;\n    s *= s;\n    r *= 1. - 0.025 * s;\n    q.y -= 0.015 * s;\n  } else if (q.z > 2.5) {\n    s = q.z - 2.5;\n    s *= s;\n    r *= 1. - 0.04 * s;\n    q.y -= -0.02 * s;\n  }\n  d = PrCapsDf (q, r, 6.);\n  q = p;\n  dc = (tDor < 0.4) ? dstFar : PrBoxDf (q - vec3 (0., 0.8, -0.5), vec3 (0.35, 0.5, 1.));\n  d = max (d, - dc);\n  DMINQ (idFus);\n  q = p;\n  q.yz -= vec2 (0.6, -0.5);\n  d = PrRoundBoxDf (q, vec3 (0.35, 0.2, 1.2), 0.3);\n  d = max (d, - dc);\n  DMINQ (idCov);\n  s = smoothstep (0.2, 0.3, abs (tDor - 0.7));\n  q = p;\n  q.yz -= vec2 (0.6, -0.4);\n  d = PrCylDf (q.xzy, 0.08, 0.3 + 0.6 * (1. - s));\n  DMINQ (idSil);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 1.4 - 0.5 * s, -0.5);\n  q.yz = Rot2D (q.yz, 0.1 * pi * (1. - s));\n  d = max (PrCapsDf (q, 0.12, 0.8), -0.8 - q.z);\n  DMINQ (idMis);\n  q = p;\n  q.yz -= vec2 (0.5, 3.2);\n  d = PrCapsDf (q, 0.5, 1.);\n  DMINQ (idCkp);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 2.1) - 0.5);\n  q -= vec3 (0.25, 0.22, 4.);\n  r = 0.22 * (1. - 0.2 * q.z * q.z);\n  de = PrCapsDf (q, r, 0.7);\n  d = SmoothMax (abs (de) - 0.02, abs (q.z) - 0.8, 0.02);\n  d = min (d, PrCapsDf (q + vec3 (0., 0., -0.05), 0.125, 0.65));\n  DMINQ (idEng);\n  q = p;\n  q.yz -= vec2 (0.22, 4.);\n  r = 0.1 * (1. - 3. * q.z * q.z);\n  d = max (PrRoundBoxDf (q, vec3 (2.9, r, 0.5), 0.1), - de);\n  DMINQ (idESup);\n  q = p;\n  q.yz -= vec2 (-0.4, 0.5 + 0.1 * abs (q.x));\n  r = 0.05 * (1. - 0.3 * q.z * q.z);\n  d = PrRoundBoxDf (q, vec3 (5., r, 1.7 - 0.1 * abs (q.x)), 0.02);\n  DMINQ (idWngM);\n  q.x = abs (q.x) - 5.;\n  s = q.z * q.z;\n  q.y -= -0.15 + 0.03 * s;\n  d = PrCapsDf (q, 0.3 - 0.05 * s, 1.5);\n  DMINQ (idFlt);\n  q = p;\n  q.yz -= vec2 (1.5, -5.);\n  q.z -= -0.1 * q.y;\n  r = 0.1 * (1. - 1.4 * q.z * q.z - 0.3 * q.y);\n  d = PrRoundBoxDf (q, vec3 (r, 1., 0.8 - 0.1 * q.y), 0.02);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 1.7, -4.6);\n  r = 0.22 * (1. - 0.2 * q.z * q.z);\n  de = PrCapsDf (q, r, 0.7);\n  d = SmoothMax (abs (de) - 0.02, abs (q.z) - 0.8, 0.02);\n  d = min (d, PrCapsDf (q + vec3 (0., 0., -0.05), 0.125, 0.65));\n  DMINQ (idEng);  \n  q = p;\n  q.yz -= vec2 (1.7, -4.8);\n  d = max (PrRoundBoxDf (q, vec3 (0.3, 0.02, 0.5), 0.02), - de);\n  DMINQ (idESup);  \n  q = p;\n  q.yz -= vec2 (2.5, -5.1) + vec2 (0.1, -0.2) * abs (q.x);\n  r = 0.05;\n  s = q.z - 0.1;\n  r *= 1. - 1.5 * s * s - 0.1 * abs (q.x);\n  d = PrRoundBoxDf (q, vec3 (4., r, 0.7 - 0.05 * abs (q.x)), 0.02);\n  DMINQ (idWngT);\n  q = p;\n  q.yz -= vec2 (2.5, -4.9);\n  s = q.z - 0.4;\n  r = 0.2 * (1. - 0.4 * s * s);\n  d = PrCapsDf (q, r, 1.);\n  DMINQ (idTCap);\n  q = p;\n  q.z -= 2.5;\n  r = 0.7;\n  if (q.z > 0.) {\n    s = q.z * q.z;\n    r *= 1. - 0.1 * s;\n  } else {\n    s = 0.;\n    r *= 1. - 0.01 * q.z * q.z;\n  }\n  q.y -= -1. + 0.025 * s;\n  r *= 1. + 0.2 * q.y;\n  d = PrRoundBoxDf (q, vec3 (r, 0.5 - 0.05 * s, 5. + 0.2 * q.y), 0.05);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -0.5);\n  d = SmoothMax (d, 0.5 - length (q.xy), 0.05);\n  DMINQ (idHul);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, -0.3, 6.);\n  d = PrCapsDf (q, 0.03, 0.5);\n  DMINQ (idSil);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, t, tw, cs;\n  float wFreq, wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 0.6;\n  wAmp = 0.1;\n  tw = 0.5 * tCur * vec2 (1., -1.);\n  q = p;\n  q += flyVel.xz * tCur;\n  h = 0.;\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q *= qRot;\n    t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  h += 0.3 * wkFac * (1. - smoothstep (0.3, 1.5, length (vec2 (abs (p.x) - 1.3, 0.1 * p.y + 1.1))));\n  return h * (1. - smoothstep (0.5, 1., d / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz, s)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz, d) - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, col4S;\n  vec2 w;\n  float s;\n  w = vec2 (0.);\n  if (idObj == idCov || idObj == idWngT || idObj == idWngM || idObj == idESup) w = qHit.xz;\n  else if (idObj == idFus || idObj == idCkp || idObj == idEng || idObj == idTCap || idObj == idFlt)\n     w = vec2 (4. * atan (qHit.y, - qHit.x) / (2. * pi), qHit.z);\n  else if (idObj == idTail) w = qHit.yz;\n  col4 = vec4 (0.9, 0.93, 0.9, 0.2);\n  if (w.x != 0.) col4 *= 0.9 + 0.1 * smoothstep (0., 0.05, abs (Fbm2 (11. + 2. * w) - 0.4) - 0.05);\n  col4S = vec4 (0., 0., 1., 0.2);\n  if (idObj == idFus) {\n    if (length (vec2 (0.9 * (qHit.y - 0.45), abs (abs (qHit.z + 0.6) - 2.4) - 0.25)) < 0.12) {\n      col4 = vec4 (0., 0., 0., -2.);\n    } else {\n      col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (qHit.y + 0.1) - 0.02));\n      col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (PrRoundBox2Df (vec2 (qHit.y - 0.35,\n         abs (qHit.z - 0.1) - 2.4), vec2 (0.25, 0.1), 0.05)));\n      col4 *= 0.3 + 0.7 * step (0.2, PrBox2Df (qHit.xz - vec2 (0., -0.5), vec2 (0.35, 1.2)));\n    }\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.73 && qHit.y < 0.43 && min (min (abs (abs (qHit.y - 0.34) - 0.08),\n       abs (abs (qHit.z - 0.9) - 0.15)), abs (abs (qHit.x) - 0.16)) > 0.014) col4 = vec4 (0., 0., 0., -2.);\n  } else if (idObj == idCov) {\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (qHit.x) - 0.175, qHit.z),\n       vec2 (0.175, 1.))));\n  } else if (idObj == idEng) {\n    col4 = mix (vec4 (1., 0., 0., 0.2), col4, smoothstep (0., 0.02, abs (qHit.z - 0.8) - 0.05));\n    if (abs (qHit.z) < 0.78 && length (qHit.xy) < 0.17) {\n      if (qHit.z < 0.) col4 = vec4 (1., 1., 0., 0.2);\n      if (abs (qHit.z - 0.05) < 0.78) col4 *= 0.7 + 0.3 * sin (8. * atan (qHit.y, - qHit.x) +\n         2. * pi * mod (16. * tCur, 1.));\n    }\n  } else if (idObj == idWngT) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (abs (abs (qHit.x) - 3.7) - 0.1) - 0.02));\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 2.2) - 0.6,\n       qHit.z + 0.6), vec2 (0.55, 0.3))));\n  } else if (idObj == idWngM) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (abs (abs (qHit.x) - 4.5) - 0.1) - 0.02));\n    if (qHit.y > 0.) col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (qHit.x) - 3.,\n       qHit.z + 0.09 * abs (qHit.x) + 0.2), vec2 (1., 0.2))));\n  } else if (idObj == idTail) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (qHit.y - 0.6) - 0.02));\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (qHit.y + 0.1, qHit.z + 0.75),\n       vec2 (0.5, 0.3))));\n  } else if (idObj == idTCap) {\n    if (qHit.z > 0.9) col4 = col4S;\n  } else if (idObj == idHul) {\n    col4 = mix (vec4 (0., 0.5, 0., 0.2) * (0.8 + 0.2 * Noisefv2 (16. * qHit.yz)),\n       col4 * (0.93 + 0.07 * sin (128. * sin (qHit.y))), smoothstep (0., 0.01, qHit.y - 0.5));\n  } else if (idObj == idFlt) {\n    col4 = mix (vec4 (0., 0.5, 0., 0.2) * (0.8 + 0.2 * Noisefv2 (16. * qHit.yz)),\n       col4, smoothstep (0., 0.01, qHit.y + 0.05));\n  } else if (idObj == idMis) {\n    col4 = vec4 (0.9, 0.5, 0.2, 0.2) * (0.5 + 0.5 * smoothstep (0.01, 0.03,\n       abs (abs (abs (qHit.z) - 0.6) - 0.03)));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (2. * h, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.4, 1.) + 0.2 * pow (1. - max (rd.y, 0.), 5.),\n     vec3 (0.85), clamp (3. * (1.5 * Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz +\n     0.5 * tCur)) - 0.1) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, row, rdw, watCol;\n  float dstObj, dstWat, f, sh, hw;\n  bool waterRefl;\n  flyVel = vec3 (0., 0., 5.);\n  flyRol = 0.005 * pi * sin (0.1 * pi * tCur);\n  wkFac = 1. - smoothstep (0.5, 1.1, flyPos.y - 1.1);\n  tDor = mod (0.1 * tCur, 1.);\n  dstObj = ObjRay (ro, rd);\n  dstWat = WaveRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    row = ro;\n    rdw = rd;\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    if (col4.a >= 0.) {\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (vn.y, 0.) + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = mix (vec3 (0.2, 0.3, 0.2), SkyCol (ro, reflect (rd, vn)), 0.5);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    f = (1. - smoothstep (0.1, 1.5, length (vec2 (0.3 * row.x, 0.06 * row.z + 1.)))) * wkFac;\n    vnw = VaryNf (row + flyVel * tCur, vnw, 1. + 5. * f);\n    watCol = mix (vec3 (0.1, 0.35, 0.4), vec3 (0.1, 0.35, 0.25),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * (row.xz + flyVel.xz * tCur)))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.8 * col, 0.2 + 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (1.) * (0.7 + 0.3 * Fbm2 (64. * (row.xz + flyVel.xz * tCur))), f);\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.6, 0.95, dstWat / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  } else {\n    az += 0.025 * pi * tCur;\n    el -= 0.05 * pi * sin (0.04 * pi * tCur);\n  }\n  el = clamp (el, 0.07 * pi, 0.3 * pi);\n  flyPos = vec3 (0., 1.9 - 0.8 * cos (0.05 * pi * tCur), 0.);\n  ro = 22. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.).xzy;\n  vuMat = DirVuMat (normalize (flyPos - ro));\n  zmFac = 4.;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.4 * pi * sin (0.02 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1053, 1053, 1075, 1075, 4290], [4292, 4292, 4325, 4325, 4509], [4511, 4511, 4532, 4532, 4787], [4789, 4789, 4821, 4821, 5495], [5497, 5497, 5531, 5531, 6034], [6036, 6036, 6067, 6067, 6239], [6241, 6241, 6259, 6259, 9484], [9486, 9486, 9523, 9523, 9768], [9770, 9770, 9802, 9802, 10037], [10039, 10039, 10074, 10074, 11823], [11825, 11825, 11881, 11881, 13173], [13175, 13175, 13207, 13207, 13307], [13309, 13309, 13355, 13355, 13402], [13404, 13404, 13437, 13437, 13526], [13528, 13528, 13575, 13575, 13622], [13624, 13624, 13666, 13666, 13717], [13719, 13719, 13762, 13762, 13835], [13837, 13837, 13882, 13882, 13985], [13987, 13987, 14032, 14032, 14070], [14072, 14072, 14097, 14097, 14266], [14268, 14268, 14298, 14298, 14411], [14445, 14445, 14469, 14469, 14599], [14601, 14601, 14625, 14625, 14688], [14690, 14690, 14715, 14715, 14901], [14903, 14903, 14928, 14928, 15265], [15267, 15267, 15288, 15288, 15443], [15445, 15445, 15474, 15474, 15686], [15688, 15688, 15727, 15727, 15907]]}
{"id": "3d3BW8", "name": "Meecarlo's RayMarching Test ", "author": "Meecarlo", "description": "test", "tags": ["raymarching"], "likes": 1, "viewed": 536, "published": 3, "date": "1604918073", "time_retrieved": "2024-07-30T20:36:10.570543", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat GetDist(vec3 p){\n\tvec4 s = vec4 (0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist=p.y;\n    \n    float d = min(sphereDist,planeDist);\n    return d;\n    \n\n\n}\n\n\nfloat raymarching(vec3 ro, vec3 rd){\n\tfloat dO=0.;\n        \n        for(int i=0; i<MAX_STEPS;i++){\n        \tvec3 p = ro + rd*dO;\n            float dS = GetDist(p);\n            dO +=dS;\n            if (dO>MAX_DIST || dS<SURF_DIST) break;\n        \n        \n        }\n        \n    return dO;\n\n\n\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d- vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xy += vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    \n    float d =  raymarching(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif *=.1;\n    \n    return dif;\n\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro =vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    \n\tfloat d=raymarching(ro,rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n   \n    \n    fragColor = vec4(col,1.0);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 90, 90, 262], [265, 265, 301, 301, 558], [560, 560, 583, 583, 769], [771, 771, 794, 794, 1104], [1108, 1108, 1164, 1164, 1498]]}
{"id": "3dcBD8", "name": "cohomology fractals", "author": "FabriceNeyret2", "description": "WIP.    Porting [url] https://henryseg.github.io/cohomology_fractals/[/url]\n\nDon't assume I understand anything :-)\nCan't recover correct parameters for now to reproduce the nice demo.", "tags": ["fractals", "cohomology"], "likes": 9, "viewed": 362, "published": 3, "date": "1604911911", "time_retrieved": "2024-07-30T20:36:11.588821", "image_code": "// https://henryseg.github.io/cohomology_fractals/\n// https://github.com/henryseg/cohomology_fractals/blob/master/shaders/fragment.glsl\n\n\n// --- trying to translate Uniform data from json presets\n// data entry \"m004\" in https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n// for arrays. chance tuning for other parameters\n\n#define zoomFactor exp2(3.*sin(.3*iTime))\n\nfloat          fov = 1.4, // no effect ?\n    //  zoomFactor = 1.,\n    clippingRadius = 4.,\n    liftsThickness = .1,\n     currentWeight = 13.,\n           maxDist = 100.,\n     edgeThickness = 1e-3,\n          contrast = 2.;\n\nint         tetNum = 0,\n          maxSteps = 100,\n     subpixelCount = 1,  // AA\n   perspectiveType = 1,  // 0,1\n          viewMode = 0,  // 0,1,2\n   multiScreenShot = 0;\n\nmat4  currentBoost = mat4(1); // no effect ?\nbool    normalised = true;\n\n vec2 tile = vec2(1),   // no effect ?\n  numTiles = vec2(10);  // no effect ?\n\n#define N 8  \nvec4 planes[N] =    vec4[N] ( vec4( 0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438), \n                              vec4( 0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386), \n                              vec4( -0.8660254037844394, 0.4999999999999991, 0.0, 0.0), \n                              vec4( 0.0, -1.0, 0.0, 0.0), \n                              vec4( 0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387), \n                              vec4( 0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387), \n                              vec4( -0.8660254037844387, 0.49999999999999994, 0.0, 0.0), \n                              vec4(0.0, -1.0, 0.0, 0.0)\n                            );\nint otherTetNums[N]       = int[N] (1, 1, 1, 1, 0, 0, 0, 0);\nint entering_face_nums[N] = int[N] (0, 2, 1, 3, 0, 2, 1, 3); \nfloat weights[N]        = float[N] (0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5); // ???\nmat4 SO31tsfms[N] = mat4[N] ( mat4( -0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999), \n                              mat4( 1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998), \n                              mat4( 2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5), \n                              mat4( -1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999), \n                              mat4( 1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0), \n                              mat4( 1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5)\n                            );\n\n// data entry \"m004\" from https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n/* \"entering_face_nums\": [0, 2, 1, 3, 0, 2, 1, 3], \n\"flat_geometries\": [\n    [\"(0, 0)\", [\n        [0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438], \n        [0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386], \n        [-0.8660254037844394, 0.4999999999999991, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0], \n        [0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387], \n        [0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387], \n        [-0.8660254037844387, 0.49999999999999994, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0]\n    ], [\n        [-0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999], \n        [1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998], \n        [2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5], \n        [-1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999], \n        [1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0], \n        [1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5]\n]]], \n??? \"flat_cohom_classes\": [[ [-1, 0, -1, 0], \n                             [0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5] ]], \n\"other_tet_nums\": [1, 1, 1, 1, 0, 0, 0, 0]\n*/\n\nfloat gradientThreshholds[5] = float[5] ( .1,.3,.6,.8, .9 );\n   const vec3 C = vec3(1,0,0);      // green red  black  blue  white\n   vec3 gradientColours[5] = vec3[5] ( C.yxz, C, C.zzz, C.yzx, C.xxx );\n// #define C(p) pow( .8*vec3(.6,.8,1), vec3(p) )\n// vec3 gradientColours[5] = vec3[5] ( C(0), C(1), C(2), C(3), C(4) );\n\n// --------------------------------------------------------------------\n\n\n\n// inf             1\n//   v0 -------- v2\n//    | `.    .' |\n//    |   `. '   |\n//    |   . `.   |\n//    | .'    `. |\n//   v3 -------- v1\n// z               0\n\nfloat R31_dot(vec4 u, vec4 v){\n  return u.x*v.x + u.y*v.y + u.z*v.z - u.w*v.w; // Lorentz Dot\n}\n\nfloat R31_norm_inv(vec4 v){\n  return inversesqrt(abs(R31_dot(v,v)));\n}\n\nvec4 R31_normalise(vec4 v){\n  return v*R31_norm_inv(v);\n}\n\nfloat geodesicParameterPlanes(vec4 samplePoint, vec4 dualPoint1, vec4 dualPoint2){\n  // \"distance\" from a geodesic defined by two (assumed perpendicular) geodesic planes, this is not quite distance, need to asinh(sqrt( result ))\n  float dot1 = -R31_dot(samplePoint, dualPoint1);\n  vec4 dualPointPerp = R31_normalise(dualPoint2 - R31_dot(dualPoint1, dualPoint2) * dualPoint1); // should be precalculated if this is a main feature\n  float dot2 = -R31_dot(samplePoint, dualPointPerp);\n  // float dot3 = -R31_dot(dualPoint1, dualPoint2);\n  return dot1*dot1 + dot2*dot2;\n  // return dot1*dot1 * (1.0 + dot3*dot3) + dot2*dot2 + 2.0*dot1*dot2*dot3;\n}\n\nfloat triangleBdryParam(vec4 samplePoint, int tetNum, int exit_face){\n  vec4 exit_dual_point = planes[4*tetNum + exit_face];\n  float smallest_p = 100000000.0;\n  for(int face=0; face<4; face++){\n      if(face != exit_face){  // find p when we hit that face\n          int index = 4*tetNum + face;\n          float new_p = geodesicParameterPlanes(samplePoint, exit_dual_point, planes[index]);\n          if(new_p < smallest_p){\n            smallest_p = new_p;\n          }   \n      }\n  }\n  return smallest_p;\n}\n\n/// --- Ray-trace code --- ///\n\n  float hyp_dist(vec4 u, vec4 v){\n    float bUV = -R31_dot(u,v);\n    if (bUV < 1.0) {return 0.0;}\n    else {return acosh(bUV);}  \n  } \n\nfloat param_to_isect_line_with_plane(vec4 line_start, vec4 line_dir, vec4 plane){\n    float denom = R31_dot(plane, line_dir);\n    if(denom == 0.0){ return 200000000.0; }  // bigger than the initial smallest_p value we will accept\n    /// solve: R31_dot(plane, line_start + p * line_dir) = 0\n    ///        R31_dot(plane, line_start) + p * R31_dot(plane, line_dir) = 0\n    return (-R31_dot(plane, line_start)) / denom;\n  }\n\nvec4 ray_trace_through_hyperboloid_tet(vec4 init_pos, vec4 init_dir, int tetNum, int entry_face, out int exit_face){\n    ///Given shape of a tet and a ray, find where the ray exits and through which face\n    float smallest_p = 100000000.0;\n    for(int face=0; face<4; face++){\n        if(face != entry_face){  // find p when we hit that face\n            int index = 4*tetNum + face;\n            if(R31_dot(init_dir, planes[index]) > 0.0){ \n                float p = param_to_isect_line_with_plane(init_pos, init_dir, planes[index]);\n                // if ((-10000.0 <= p) && (p < smallest_p)) {\n                if (p < smallest_p) {  \n                    /// negative values are ok if we have to go backwards a little to get through the face we are a little the wrong side of\n                    /// Although this can apparently get caught in infinite loops in an edge\n\n                    /// if we are on an edge then we don't in fact move as we go through this tet: t = 0.0\n                    /// also allow tiny negative values, which will come up from floating point errors. \n                    /// surface normals check should ensure that even in this case we make progress through \n                    /// the triangles around an edge\n                    smallest_p = p;\n                    exit_face = face;\n                }\n            }\n        }\n    }\n    return R31_normalise( init_pos + smallest_p * init_dir );\n}\n\nfloat ray_trace(vec4 init_pt, vec4 init_dir, float dist_to_go, int tetNum, float inputWeight){\n    int return_type = 0;\n    if(viewMode == 0){ return_type = 0; } // total_face_weight\n    else if(viewMode == 1){ return_type = 1; } // distance\n    else if(viewMode == 2){ return_type = 2; } // tet number\n    int entry_face = -1;   /// starts off with no entry face\n    int exit_face = -1;\n    float total_face_weight = inputWeight;\n    vec4 new_pt;\n    int index;\n    mat4 tsfm;\n    vec4 new_dir;\n    for(int i=0; i<maxSteps; i++){\n      new_pt = ray_trace_through_hyperboloid_tet(init_pt, init_dir, tetNum, entry_face, exit_face);\n      dist_to_go -= hyp_dist(init_pt, new_pt);\n      if (dist_to_go <= 0.0){ dist_to_go = 0.0; break; }\n      if(edgeThickness > 0.00001){\n        if(triangleBdryParam(new_pt, tetNum, exit_face) < edgeThickness){ break; }}\n        // in fact pow(sinh(radius in hyperbolic units),2.0). However, sinh^2 is monotonic for \n        // positive values so we get correct behaviour by comparing without the sinh^2. \n      index = 4*tetNum + exit_face;\n      total_face_weight += weights[ index ]; \n      if(liftsThickness > 0.0){  // here we detect and draw elevations\n        if( ( total_face_weight <= liftsThickness && liftsThickness < inputWeight ) || // see elevations from behind\n                  ( inputWeight < 0.0001          &&         0.0001 < total_face_weight ) ||  // see elevations from in front // cannot make this too close to 0.0 or we get floating point issues from different sums of weights\n            ( 0.0001 < inputWeight && inputWeight <= liftsThickness && inputWeight != total_face_weight) // see elevations from in between\n                  ) { \n          return_type = 1; \n          break; \n        } \n      }             \n      entry_face = entering_face_nums[ index ];\n      tsfm = SO31tsfms[ index ];\n      tetNum = otherTetNums[ index ];\n\n      new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt; // orthonormal decomp, no normalisation yet\n      init_pt = new_pt * tsfm;  \n      init_dir = R31_normalise( new_dir * tsfm ); \n    }\n    if(return_type == 0){ return total_face_weight; } // Cohomology\n    else if(return_type == 1){ return 0.5*maxDist - dist_to_go; } // Colour by Distance\n    else { return float(tetNum);} // Colour by tetrahedron number\n}\n\n/// --- Graph-trace code --- ///\n\nfloat amountOutsideTetrahedron(vec4 v, int tetNum, out int biggest_face) {\n  float biggest_amount = -100000.0;\n  float amount;\n  for(int i = 0; i < 4; i++){\n    amount = R31_dot( v, planes[4*tetNum + i] );\n    if( amount > biggest_amount ){\n      biggest_amount = amount;\n      biggest_face = i;\n    }\n  }\n  return biggest_amount; \n}\n\nvec4 pointOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*cosh(dist) + dir*sinh(dist);\n}\n\nvec4 tangentOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*sinh(dist) + dir*cosh(dist);\n}\n\nfloat graph_trace(inout vec4 goal_pt, inout int tetNum, out mat4 tsfm){ // tsfm is matrix to send goal_pt to its image in the tetrahedron coordinates it is in\n  // similar function to ray_trace, but different algorithm\n  float total_face_weight = 0.0;\n  int entry_face = -1;\n  int index;\n  int biggest_face;\n  tsfm = mat4(1.0);\n  for(int i=0; i<maxSteps; i++){\n      if ( amountOutsideTetrahedron(goal_pt, tetNum, biggest_face) > 0.0 && biggest_face != entry_face ){ //0.0000001\n        index = 4*tetNum + biggest_face;\n        entry_face = entering_face_nums[ index ];\n        tetNum = otherTetNums[ index ];\n        // if(viewMode == 2) { total_face_weight += abs(weights[ index ]); } // translucent surface: all weights positive\n        // else { \n        total_face_weight += weights[ index ]; \n        goal_pt *= SO31tsfms[ index ];\n        tsfm *= SO31tsfms[ index ];\n        // if (R31_dot(goal_pt, goal_pt) > -0.5){ return -1000.0; } // errors accumulate and we get junk!\n      }\n      else{ break; }\n    }\n    return total_face_weight;\n  }\n\n/// --- Colour gradient code --- ///\n\nint find_band(float t, float threshholds[5]){\n    for(int j=1;j<4;j++){\n        if(t < threshholds[j]){return j;}\n    }\n    return 4;\n}\nvec4 general_gradient(float t, float threshholds[5], vec3 colours[5]){\n    int i = find_band(t, threshholds);\n    return vec4( mix(colours[i-1], colours[i],(t - threshholds[i-1])/(threshholds[i] - threshholds[i-1]) ), 1.0);\n}\n\n/// --- Ray init pt and directions code --- ///\n\nvec4 get_ray_pos_dir_material(vec2 xy, out vec4 ray_dir){ \n    float z = 0.5/tan(radians(fov*0.5));\n    ray_dir = R31_normalise(vec4(xy,-z,0.0));\n    return vec4(0.0,0.0,0.0,1.0);\n}\n\nvec4 get_ray_pos_dir_ideal(vec2 xy, out vec4 ray_dir){ \n    float foo = 0.5*dot(xy, xy);\n    vec4 ray_pt = vec4(xy, foo, foo + 1.0);   // parabolic transformation magic by Saul\n    ray_dir = vec4(xy, foo - 1.0, foo);\n    return ray_pt;\n}\n\nvec4 get_ray_pos_dir_hyperideal(vec2 xy, out vec4 ray_dir, out bool background){ \n    vec4 ray_pt = R31_normalise(vec4(2.0 * xy,0.0,1.0));\n    if (R31_dot(ray_pt, ray_pt) < 0.0){\n      ray_dir = vec4(0.0,0.0,-1.0,0.0);\n      background = false;\n    }\n    else{\n      ray_dir = vec4(0.0,0.0,0.0,0.0);\n      ray_pt = vec4(0.0,0.0,0.0,1.0);  // avoid jank\n      background = true;\n    }\n    return ray_pt;\n}\n\n//new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt;\n\nfloat get_signed_count(vec2 xy){\n  vec4 init_pt;\n  vec4 init_dir;\n  float weight = 0.0;\n  bool background = false;\n  mat4 tsfm = mat4(1.0);\n  int currentTetNum = tetNum;  // gets modified inside graph_trace\n  if(perspectiveType == 0){ init_pt = get_ray_pos_dir_material(xy, init_dir); }\n  else if(perspectiveType == 1){ init_pt = get_ray_pos_dir_ideal(xy, init_dir); }\n  else{ init_pt = get_ray_pos_dir_hyperideal(xy, init_dir, background); }\n  init_pt *= currentBoost;\n  init_dir *= currentBoost; \n  vec4 new_init_pt = pointOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_dir = tangentOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_pt = new_init_pt;\n  weight = graph_trace(init_pt, currentTetNum, tsfm);  // get us to the tetrahedron containing init_pt. \n  // init_pt *= tsfm;  // the point gets moved back in graph_trace\n  init_dir *= tsfm;  // move the direction back to here\n  if (background){ return 0.0; }\n  else{ return ray_trace(init_pt, init_dir, maxDist, currentTetNum, currentWeight + weight); }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n  xy *= zoomFactor;\n  if(multiScreenShot == 1){  // Return multiple 4096x4096 screenshots that can be combined in, e.g. Photoshop.\n    // Here screenResolution is really tileResolution;\n    xy = (xy + tile - 0.5*(numTiles - vec2(1.0,1.0))) / numTiles.x;\n  }\n\n  float total_weight = 0.0;\n  for(int i=0; i<subpixelCount; i++){\n    for(int j=0; j<subpixelCount; j++){\n      vec2 offset = ( (float(1+2*i), float(1+2*j))/float(2*subpixelCount) - vec2(0.5,0.5) ) / iResolution.x;\n      total_weight += get_signed_count(xy + offset);\n    }\n  }\n  float weight = total_weight/float(subpixelCount*subpixelCount); // average over all subpixels\n\n  if(normalised){ weight /= sqrt(maxDist); }\n\n  weight = contrast * weight;\n\n\n  // linear\n  // float minW = -31.75;\n  // float maxW = 32.25;\n\n  // float minW = -63.75;\n  // float maxW = 64.25;\n\n  // float minW = -127.75;\n  // float maxW = 128.25;\n\n  // weight = (weight - minW)/(maxW - minW);\n\n  // arctan\n  // weight = 0.5 + atan(0.3 * weight)/PI;  // between 0.0 and 1.0\n  \n  // faster than atan, similar\n  weight = 0.5 + 0.5*weight/(abs(weight) + 1.0);  \n  \n  fragColor = general_gradient(weight, gradientThreshholds, gradientColours);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7959, 7959, 7989, 7989, 8054], [8056, 8056, 8083, 8083, 8126], [8128, 8128, 8155, 8155, 8185], [8187, 8187, 8269, 8415, 8830], [8832, 8832, 8901, 8901, 9336], [9372, 9372, 9403, 9403, 9503], [9506, 9506, 9587, 9587, 9927], [9929, 9929, 10045, 10132, 11358], [11360, 11360, 11454, 11454, 13675], [13711, 13711, 13785, 13785, 14044], [14046, 14046, 14099, 14099, 14143], [14145, 14145, 14200, 14200, 14244], [14246, 14246, 14317, 14464, 15294], [15334, 15334, 15379, 15379, 15469], [15470, 15470, 15540, 15540, 15695], [15746, 15746, 15803, 15803, 15927], [15929, 15929, 15983, 15983, 16166], [16168, 16168, 16248, 16248, 16572], [16634, 16634, 16666, 16666, 17655]]}
{"id": "tddfDr", "name": "Fractal space station", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tdcfRN]\"Sci-fi city\"[/url] fractal.\nUse the mouse to look around.", "tags": ["fractal"], "likes": 3, "viewed": 318, "published": 3, "date": "1604896473", "time_retrieved": "2024-07-30T20:36:12.427578", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/2.0;\n    int iters = 1;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 5) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-0.1,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n        if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/2*2*2*2*2*2))*(t>>(4+((t/(4096)))))|(t>>(8+(t/(131072))))|t>>4|t/3/4096|t/2/4096;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 4000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1)+p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 1; i1 < 5; i1++){\n    \tfloat p1 = planet_surface(p*i,i)/(i);\n        result = max(result, -p1);\n        i *= -5.0;\n        if(i1 == iters) break;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,5);\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/2.0;\n    int iters = 1;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 5) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y))).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-0.1,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 dmap = depth_map(fragCoord);\n    float l0 = length(eye-dmap);\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n    float dist = sceneSDF(eye);\n    float l2;\n    if(l0 > .1 && l1 > 0.0){\n        l2 = max(log(l0/16.0),0.0);\n    }\n    else{\n        l2 = l0;\n    }\n    \n    dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    fragColor = vec4(p, min(0.0,abs(l0-dist)*.9));\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 574, 574, 1020], [1036, 1036, 1063, 1063, 1212], [1214, 1214, 1271, 1271, 1969]]}
{"id": "tddfDn", "name": "cherry blossom tree 2", "author": "jemappelle", "description": "testing fft implementation, using uniforms through api", "tags": ["test"], "likes": 2, "viewed": 327, "published": 3, "date": "1604875988", "time_retrieved": "2024-07-30T20:36:13.282293", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2.*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.1, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8)) * abs(sdCappedTorus(d, vec2(midFreqFFT,0.4), midFreqFFT/3., 0.4));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,zMotion,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,shapeColour));\n    \n    //Sound test\n    //float fft = texture(iChannel0, vec2(uv.x,uv.y)).x;\n    \n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n  \tfor(float i = 0.; i < 15.; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \t//p += env * sin(rd-ro/50.);\n    \t//p += env - (sin(env+ro/100.)+atan(ro+rd));\n        sin(p += env - (sin(env+ro/100.)+atan(rd))) + atan(rd-ro/50.);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.1;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.1;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = sin(smoothstep(0.05, 0.9,length(uv.y/(circle*midFreqFFT))));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        //color = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n        \n        //Colour with uniform\n        //color = mix(vec3(highFreqFFT-sin(verLine/cos(circle/(shading*2.)))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(lowFreqFFT/4.,0.0,midFreqFFT/4.), \n        //            mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n    \t\n        color = mix(vec3(0.05-sin(verLine*cos(circle/(verLine*uv.y*abs(shading))))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(0.0,0.05,lowFreqFFT/sin(verLine-sin(circle-(iTime*uv.x*abs(uv.y))))/4.), \n        mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n        \n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n        color = vec3(circle - verLine+shading) - vec3(0.9,0.9,0.9);\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.6,0.1,0.1), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.1) + vec4((color * circle / 1.5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 140, 140, 160], [162, 162, 203, 203, 222], [224, 224, 266, 266, 308], [310, 310, 340, 370, 395], [397, 397, 450, 450, 513], [516, 516, 586, 586, 720], [722, 722, 740, 740, 918], [920, 920, 944, 944, 1111], [1113, 1113, 1170, 1217, 3628]]}
{"id": "3dtfDr", "name": "Folie Ocean", "author": "liamegan", "description": "Experimenting with 3tap 1-dimensional tiling.", "tags": ["ocean", "tiling", "3tap"], "likes": 8, "viewed": 420, "published": 3, "date": "1604860247", "time_retrieved": "2024-07-30T20:36:14.061210", "image_code": "vec2 getScreenSpace(vec2 co, vec2 res) {\n    vec2 uv = (co - 0.5 * res) / min(res.y, res.x);\n\n    return uv;\n}\n\nvec3 randcol(float i) {\n    i = fract(i/4.);\n    if(i < .25) {\n      return vec3(0,0,.5);\n    } else if(i < .5) {\n      return vec3(0,.2,.5);\n    } else if(i < .75) {\n      return vec3(0,.1,.4);\n    } else {\n      return vec3(0,.3,.6);\n    }\n}\n\nvec2 hash12(float i) {\n    return texture(iChannel0, vec2(i/126., 0.), -10.).xy*.6+.01;\n}\n\n#define PI 3.14159265359\n\nfloat t = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace(fragCoord, iResolution.xy);\n    \n    t = iTime - 1000.;\n    \n    uv.y += sin(t*.2);\n    \n    uv *= 15. + cos(t*.2)*5.;\n    \n    vec2 guv = vec2(uv.x, fract(uv.y));\n    float id = floor(uv.y);\n    \n    vec3 col = vec3(1);\n    \n    for(float i = -2.; i < 1.; i++) {\n      vec2 suv = guv + vec2(0., i);\n      vec2 suv1 = guv + vec2(0., i-1.);\n      \n      float sid = id - i;\n      float sid1 = id - i - 1.;\n      \n      vec2 hash = hash12(sid);\n      vec2 hash1 = hash12(sid1);\n      \n      vec2 p = suv - vec2(t*hash1.x, 0.);\n      \n      suv.x += t*10.*(hash.x*hash.x);\n      suv1.x += t*10.*(hash1.x*hash1.x);\n      \n      float wave = sin(suv.x + sid) + cos(suv.x * hash.y) * (hash.y*10.);\n      float wave1 = sin(suv1.x + sid1) + cos(suv1.x * hash1.y) * (hash1.y*10.);\n      \n      p = vec2(length(p*.02), ((p.y) + wave * .1));\n      \n      float sfield = (suv.y + wave * .1);\n      float sfield1 = (suv.y + wave1 * .1);\n      \n      float mask = smoothstep(.5, -.2, sfield);\n      \n      // vec4 tex = texture(iChannel1, p, -10.);\n      vec4 tex = vec4(abs(sin(p.y*20.*length(hash)) + cos(p.x * 5. * hash1.y))*.3+.5);\n      \n      col = mix(col, (randcol(sid)+.2) * tex.gbr * (suv.y * .5 + .3 + smoothstep(-1., -.3, sfield1)), mask);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 110], [112, 112, 135, 135, 355], [357, 357, 379, 379, 446], [489, 489, 546, 546, 1853]]}
{"id": "WsdBDr", "name": "red cubes", "author": "algoes", "description": "red cubes", "tags": ["redcubes"], "likes": 7, "viewed": 351, "published": 3, "date": "1604859861", "time_retrieved": "2024-07-30T20:36:15.108411", "image_code": "/*\n    Original shader by Shane here: https://www.shadertoy.com/view/4dt3zn\n\tI just added some audio-awareness (cube's size following the fft frenquencies)\n*/\n\n/*\n\tRaymarched Reflections\n\t----------------------\n\n\tA very basic demonstration of raymarching a distance field with reflections \n\tand reasonably passable shadows. Definitely not cutting edge, but hopefully, \n\tinteresting to anyone who isn't quite familiar with the process.\n\n\tReflections are pretty easy: Raymarch to the hit point, then obtain the color \n\tat that point. Continue on from the hit point in the direction of the reflected \n\tray until you reach a new hit point. Obtain the color at the new point, then\n\tadd a portion of it to your original color. Repeat the process.\n\n\tUnfortunately, the extra work can slow things down, especially when you apply\n\tshadows, which is probably why you don't see too many shadowed,\treflected \n\texamples. However, for relatively simple distance fields, it's pretty doable.\n\n\tIt was tempting to do this up, but I figured a simpler example would be more\n\thelpful. Take away the rambling comments, and there isn't a great deal of code.\n\tI'll post a more sophisticated one later.\n\n    // Reasonably simple examples featuring reflection:\n\n    To the road of ribbon - XT95\n    https://www.shadertoy.com/view/MsfGzr\n\n    704.2 - PauloFalcao\n    https://www.shadertoy.com/view/Xdj3Dt\n\n    // Reflections and refraction. Really cool.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n\n*/\n\n#define FAR 30.\n\n// Distance function. This one is pretty simple. I chose rounded\n// spherical boxes, because they're cheap and they display the \n// reflections reasonably well.\nfloat map(vec3 p)\n{\n    \n    // Positioning the rounded cubes a little off center, in order\n    // to break up the space a little.\n    //\n    // \"floor(p)\" represents a unique number (ID) for each cube \n    // (based on its unique position). Take that number and produce \n    // a randomized 3D offset, then add it to it's regular position. \n    // Simple.\n    float n = sin(dot(floor(p), vec3(7, 157, 113)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16-.08;\n    \n    // Repeat factor. If irregularity isn't your thing, you can get \n    // rid of \"rnd\" to line things up again.\n    p = fract(p + rnd) - .5;\n    \n    float eq = texture(iChannel0, vec2(fract(n), 0.25)).r;\n    float boxsize = 0.1 + eq * 0.6;\n    \n    // Rounded spherical boxes. The following is made up, but kind of\n    // makes sense. Box, minus a bit of sphericalness, gives you a \n    // rounded box.\n    p = abs(p); \n    return max(p.x, max(p.y, p.z)) - boxsize + dot(p, p)*.5;\n    \n    //return length(p) - 0.225; // Just spheres.\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break; // Normally just \"d<.0025\"        \n        \n        t += d*.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0025 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .005;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n        //if (h<0.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + 0.25, 1.5); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0035, -0.0035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n// Alternating the cube colors in a 3D checkered arrangement.\n// You could just return a single color, if you wanted, but I\n// thought I'd mix things up a bit.\n//\n// Color scheme mildly influenced by: Sound Experiment 3 - aiekick\n// https://www.shadertoy.com/view/Ml2XWt\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n    \n    // \"floor(p)\" is analogous to a unique ID - based on position.\n    // This could be stepped, but it's more intuitive this way.\n    if(fract(dot(floor(p), vec3(.5))) > 0.001) col = vec3(4, 0, 0);\n    \n    return col;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist*0.2 + lDist*lDist*0.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1., .6, .2)*spec*2.) * atten;\n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself, at this point. :)\n    float cs = cos(iTime * 0.25), si = sin(iTime * 0.25);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., iTime*1.5);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 1., -.5);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n    // Fog based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR);\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! - Better call the shadow police. :)\n    float sh = softShadow(ro, lp, 16.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add is up to you, but I'm going with 35 percent.\n    sceneColor += doColor(ro, rd, sn, lp)*.35;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    // Technically, it should be applied on the reflection pass too, but it's not that\n    // noticeable, in this case.\n    sceneColor = mix(sceneColor, vec3(0), fog); \n    \n    \n   \n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1519, 1680, 1699, 2036, 2696], [2698, 2731, 2761, 2761, 3038], [3040, 3450, 3483, 3483, 3679], [3682, 3897, 3941, 4058, 5361], [5755, 5827, 5855, 5971, 6167], [6169, 6440, 6468, 6468, 6729], [6731, 6873, 6934, 6934, 7854], [7856, 7856, 7912, 7940, 11971]]}
{"id": "WddfWn", "name": "Voronoi Animation", "author": "IWBTShyGuy", "description": "Realtime voronoi diagram animation", "tags": ["voronoi"], "likes": 2, "viewed": 168, "published": 3, "date": "1604857752", "time_retrieved": "2024-07-30T20:36:15.926224", "image_code": "const int M = 5;\nconst int N = 6;\n\nconst float WPOINT_RADIUS = 0.015;\n\nconst vec2 gen = vec2(114.514, 1919.810);\nfloat rand(vec2 c) {\n    return fract(gen.x * sin(c.x * gen.y + c.y));\n}\n\nvec3 get_color(vec2 uv) {\n    return 0.5 + 0.5 * cos(uv.xyx + iTime + vec3(0.3, 1.7, 3.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    vec2 uv = fragCoord / iResolution[min_idx];\n\n    float min_dist = 10.0;\n    vec2 res;\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 lat = vec2(\n                float(i + 1) / float(M + 1),\n                float(j + 1) / float(N + 1)\n            );\n            vec2 velo = vec2(rand(lat), rand(lat.yx)) - 0.2;\n            vec2 point = fract(iTime * velo * 0.5 / aspect_vec) * aspect_vec;\n            float dist = distance(uv, point);\n            if (dist < WPOINT_RADIUS && cos(iTime / 3.0) > 0.0) {\n                fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n                return;\n            }\n            if (min_dist > dist) {\n                min_dist = dist;\n                res = lat;\n            }\n        }\n    }\n    \n    fragColor = vec4(get_color(res), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 133, 133, 185], [187, 187, 212, 212, 280], [282, 282, 339, 339, 1344]]}
{"id": "3stBWn", "name": "Waved Julia Animation", "author": "IWBTShyGuy", "description": "Waved Julia Animation", "tags": ["fractal"], "likes": 5, "viewed": 186, "published": 3, "date": "1604857229", "time_retrieved": "2024-07-30T20:36:16.677216", "image_code": "float basis0(float t) {\n    return clamp(1.0 - 3.0 * t / 2.0, 0.0, 1.0);\n}\nfloat basis1(float t) {\n    return clamp(3.0 / 2.0 * (t - 1.0) + 1.0, 0.0, 1.0);\n}\n\nvec3 color_vec(float t) {\n\treturn vec3(\n\t\tbasis0(t),\n\t\t1.0 - basis0(t) - basis1(t),\n\t\tbasis1(t)\n\t);\n}\n\nvec3 color_result(vec2 uv) {\n\tfloat u = (cos(iTime) + 1.0) / 2.0;\n\tfloat v = (sin(iTime) + 1.0) / 2.0;\n\tvec3 color0 = (1.0 - u) * (1.0 - v) * color_vec(uv[0]);\n\tvec3 color1 = (1.0 - u) * v * color_vec(1.0 - uv[0]);\n\tvec3 color2 = u * (1.0 - v) * color_vec(uv[1]);\n\tvec3 color3 = u * v * color_vec(uv[1]);\n\treturn color0 + color1 + color2 + color3;\n}\n\nint in_julia(vec2 z, vec2 c) {\n\tfor (int i = 0; i < 100; i++) {\n\t\tz = vec2(\n            z.x * z.x - z.y * z.y + c.x,\n            2.0 * z.x * z.y + c.y\n        );\n\t\tif (length(z) > 10.0) return i;\n\t}\n\treturn 100;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    vec2 centralizer = vec2(0.5 * asp, 0.5);\n    vec2 centralized = uv - centralizer;\n    float displacer = sin(10.0 * (length(centralized) * 5.0 - iTime * 0.63));\n    uv = centralized * (1.0 + 0.1 * displacer) + centralizer;\n\tvec2 z = 3.0 * (uv - centralizer);\n\tvec2 c = 0.625 * vec2(cos(iTime * 1.43), sin(iTime * 1.43));\n\tint k = in_julia(z, c);\n    if (k < 100) {\n        float ratio = float(k) / 10.0;\n        fragColor = vec4(ratio * color_result(uv.yx), 1.0);\n    }\n\telse fragColor = vec4(color_result(uv), 1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 74], [75, 75, 98, 98, 157], [159, 159, 184, 184, 260], [262, 262, 290, 290, 611], [613, 613, 643, 643, 826], [828, 828, 885, 885, 1495]]}
{"id": "WsdBWr", "name": "signs", "author": "algoes", "description": "yellow signs", "tags": ["yellowsigns"], "likes": 1, "viewed": 241, "published": 3, "date": "1604851807", "time_retrieved": "2024-07-30T20:36:17.424218", "image_code": "float alterDistance(vec2 v1, vec2 v2, float strength, float speed) \n{\n  return sin(dot(normalize(v1), normalize(v2)) * strength + speed * iTime) / 100.0;\n}\n\nfloat alterDistance(vec2 uv, vec2 center) \n{\n  vec2 diff = center - uv;\n  float len = length(diff);\n\n  len += alterDistance(diff, vec2(0.0, 1.0), 10.0, 2.0);\n  len -= alterDistance(diff, vec2(1.0, 0.0), 10.0, 2.0);\n\n  return len;\n}\n\nfloat limit(float x, float min, float max)\n{\n    if (x < min)\n        x = 0.0;\n    \n    if (x > max)\n        x = 1.0;\n    \n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec4 color = texture(iChannel0, uv);\n    \n\tvec2 center = vec2(10.5, .5); \n    \n    vec2 p = ceil(uv * 300.0) / 300.0;\n\t\n\tfloat d = alterDistance(center, p);\n    \n    vec4 pink = vec4(1, 1.0, 0, 1.0) * 1.75;\n    \n    float t = iTime * 0.1;\n    \n    float cloud = texture(iChannel1, p +  vec2(t, t)).r;\n    float cloud2 = texture(iChannel1, 0.5 * p + vec2(t, -t)).r;\n    \n    cloud = mix(cloud, cloud2, 0.5);\n        \n    float r1 = 0.2;\n    float r2 = 0.225;\n    float r3 = 0.25;\n    \n    if (d <= r1)\n    {\n        fragColor = color;\n    }\n    else if (d <= r2)\n    {\n        fragColor = pink;\n    }\n    else if (d <= r3)\n    {\n        float nd = (d - r2) / (r3 - r2); \n    \tfragColor = limit(cloud, 0.3, mix(0.3, 0.4, nd)) * pink;\n    }\n    else\n    {\n    \tfragColor = limit(cloud, 0.3, 0.4) * pink;\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 155], [157, 157, 201, 201, 388], [390, 390, 434, 434, 528], [530, 530, 587, 587, 1441]]}
{"id": "WdtfDn", "name": "random convex hull", "author": "_A_", "description": "experiments with shape generation", "tags": ["3d"], "likes": 12, "viewed": 445, "published": 3, "date": "1604840471", "time_retrieved": "2024-07-30T20:36:18.184187", "image_code": "\nfloat SDF (const float3 pos)\n{\n\tint\t\t\tbase_seed\t= int(iTime * 0.25);\n\tfloat\t\tfactor\t\t= Clamp( Fract(iTime * 0.25) * 2.0, 0.0, 1.0 );\n\tconst int\tplane_count\t= 16;\n\n\tfloat\tdist[2];\n\tfor (int j = 0; j < 2; ++j)\n\t{\n\t\tfloat\tmd\t\t= -1.0e+10;\n\t\tint\t\tseed\t= base_seed + j;\n\n\t\tfor (int i = 0; i < plane_count; ++i)\n\t\t{\n\t\t\tint\t\tface\t= (i + seed) % 6;\n\t\t\tfloat2\tscoord\t= DHash21( float(i)*51.85 + float(seed)*2.0 );\n\t\t\tfloat\tradius\t= 1.0 + DHash11( float(i)*9.361 + float(seed)*3.94521 ) * 0.5;\n\t\t\tfloat3\tnorm\t= Normalize( CM_TangentialSC_Forward( scoord, face ));\n\t\t\tfloat3\tplane\t= radius * norm;\n\n\t\t\tmd = Max( md, SDF_Plane( plane, pos ));\n\t\t}\n\t\n\t\tmd = Max( md, Length( pos ) - 3.0);\n\t\tdist[j] = md;\n\t}\n\n\treturn Lerp(dist[0], dist[1], factor);\n}\n\nfloat SDFScene (float3 pos)\n{\n    pos = pos - float3(0.0, 0.0, 5.0);\n\tpos = SDF_Rotate( pos, QRotationY( iTime*0.3 ));\n\treturn SDF( pos );\n}\n\nGEN_SDF_NORMAL_FN2( SDFNormal, SDFScene, )\n\n\nfloat4 TraceRay (Ray ray)\n{\n\tconst int\tmax_iter\t= 256;\n\tconst float\tmin_dist\t= 0.00625f;\n\tconst float\tmax_dist\t= 100.0;\n\n\tint i = 0;\n\tfor (; i < max_iter; ++i)\n\t{\n\t\tfloat\tdist = SDFScene( ray.pos );\n\t\t\n\t\tRay_Move( ray, dist );\n\n\t\tif ( Abs(dist) < min_dist || ray.t > max_dist )\n\t\t\tbreak;\n\t}\n\n\tif ( ray.t > max_dist )\n\t\treturn float4(0.0, 0.0, 0.3, 1.0);\n\n\tfloat3\tnorm\t\t= SDFNormal( ray.pos );\n\tfloat3\tlight_dir\t= -ray.dir;\n\n\tfloat\tshading = Dot( norm, light_dir );\n\treturn float4( shading );\n}\n//-----------------------------------------------------------------------------\n\n\nvoid mainVR (out float4 fragColor, in float2 fragCoord, in float3 fragRayOri, in float3 fragRayDir)\n{\n\tRay\tray = Ray_Create( fragRayOri, fragRayDir, 0.1 );\n\n\tfragColor = TraceRay( ray );\n}\n\nvoid mainImage (out float4 fragColor, in float2 fragCoord)\n{\n    Ray ray = Ray_FromScreen( vec3(0.0, 0.0, 30.0), QIdentity(), radians(90.0), 0.1, int2(iResolution.xy), int2(gl_FragCoord.xy) );\n    \n\tfragColor = TraceRay( ray );\n}\n", "image_inputs": [], "common_code": "\n#define float2\t\tvec2\n#define float3\t\tvec3\n#define float4\t\tvec4\n#define float2x2\tmat2x2\n#define float3x3\tmat3x3\n#define float4x4\tmat4x4\n\n#define int2\t\tivec2\n#define int3\t\tivec3\n#define int4\t\tivec4\n\n\n#define Any\t\t\t\tany\n#define All\t\t\t\tall\n#define Abs\t\t\t\tabs\n#define ACos\t\t\tacos\n#define ASin\t\t\tasin\n#define ASinH\t\t\tasinh\n#define ACosH\t\t\tacosh\n#define ATan\t\t\tatan\t\t\t// result in range [-Pi...+Pi]\n#define BitScanReverse\tfindMSB\n#define BitScanForward\tfindLSB\n#define ATanH\t\t\tatanh\n#define Clamp\t\t\tclamp\n#define Ceil\t\t\tceil\n#define Cos\t\t\t\tcos\n#define CosH\t\t\tcosh\n#define Cross\t\t\tcross\n#define Distance\t\tdistance\n#define Dot\t\t\t\tdot\n#define Exp\t\t\t\texp\n#define Exp2\t\t\texp2\n#define Fract\t\t\tfract\n#define Floor\t\t\tfloor\n#define IsNaN\t\t\tisnan\n#define IsInfinity\t\tisinf\n#define IsFinite( x )\t(! IsInfinity( x ) && ! IsNaN( x ))\n#define InvSqrt\t\t\tinversesqrt\n#define IntLog2\t\t\tBitScanReverse\n#define Length\t\t\tlength\n#define Lerp\t\t\tmix\n#define Ln\t\t\t\tlog\n#define Log2\t\t\tlog2\n#define Log( x, base )\t(Ln(x) / Ln(base))\n#define Log10( x )\t\t(Ln(x) * 0.4342944819032518)\n#define Min\t\t\t\tmin\n#define Max\t\t\t\tmax\n#define Mod\t\t\t\tmod\n#define MatInverse\t\tinverse\n#define MatTranspose\ttranspose\n#define Normalize\t\tnormalize\n#define Pow\t\t\t\tpow\n#define Round\t\t\tround\n#define Reflect\t\t\treflect\n#define Refract\t\t\trefract\n#define Step\t\t\tstep\n#define SmoothStep\t\tsmoothstep\n#define Saturate( x )\tclamp( x, 0.0, 1.0 )\n#define Sqrt\t\t\tsqrt\n#define Sin\t\t\t\tsin\n#define SinH\t\t\tsinh\n#define SignOrZero\t\tsign\n#define Tan\t\t\t\ttan\n#define TanH\t\t\ttanh\n#define Trunc\t\t\ttrunc\n#define ToUNorm( x )\t((x) * 0.5 + 0.5)\n#define ToSNorm( x )\t((x) * 2.0 - 1.0)\n//----------------------------------------------\n\n\nstruct quat\n{\n\tfloat4\tdata;\n};\n    \nquat  QIdentity ()\n{\n\tquat\tret;\n\tret.data = float4( 0.0, 0.0, 0.0, 1.0 );\n\treturn ret;\n}\n\nfloat3  QMul (const quat left, const float3 right)\n{\n\tfloat3\tq\t= left.data.xyz;\n\tfloat3\tuv\t= Cross( q, right );\n\tfloat3\tuuv\t= Cross( q, uv );\n\n\treturn right + ((uv * left.data.w) + uuv) * 2.0;\n}\n\nquat  QInverse (const quat q)\n{\n\tquat\tret;\n\tret.data.xyz = -q.data.xyz;\n\tret.data.w   = q.data.w;\n\treturn ret;\n}\n\nquat  QRotationY (const float angleRad)\n{\n\tquat\tq;\n\tfloat\ta = angleRad * 0.5;\n\n\tq.data = float4( 0.0, Sin(a), 0.0, Cos(a) );\n\treturn q;\n}\n//----------------------------------------------\n\n\nstruct Ray\n{\n\tfloat3\torigin;\t\t// camera (eye, light, ...) position\n\tfloat3\tdir;\t\t// normalized direction\n\tfloat3\tpos;\t\t// current position\n\tfloat\tt;\n};\n\nRay\t\tRay_Create (const float3 origin, const float3 direction, const float tmin)\n{\n\tRay\tresult;\n\tresult.origin\t= origin;\n\tresult.t\t\t= tmin;\n\tresult.dir\t\t= direction;\n\tresult.pos\t\t= origin + direction * tmin;\n\treturn result;\n}\n\nRay\t\tRay_FromScreen (const float3 origin, const quat rotation, const float fovX, const float nearPlane,\n\t\t\t\t\t\tconst int2 screenSize, const int2 screenCoord)\n{\n\tfloat2\tscr_size\t= float2(screenSize);\n\tfloat2\tcoord\t\t= float2(screenCoord);\n\n\tfloat\tratio\t\t= scr_size.y / scr_size.x;\n\tfloat \tfovY \t\t= fovX * ratio;\n\tfloat2 \tscale\t\t= nearPlane / Cos( float2(fovX, fovY) * 0.5 );\n\tfloat2 \tuv \t\t\t= (coord - scr_size * 0.5) / (scr_size.x * 0.5) * scale;\n\n\tRay\tray;\n\tray.origin\t= origin;\n\tray.dir\t\t= Normalize( QMul( rotation, Normalize( float3(uv.x, uv.y, -0.5) )));\n\tray.pos\t\t= origin + ray.dir * nearPlane;\n\tray.t\t\t= nearPlane;\n\n\treturn ray;\n}\n\nvoid\tRay_Move (inout Ray ray, const float length)\n{\n\tray.t   += length;\n\tray.pos  = ray.origin + ray.dir * ray.t;\n}\n//----------------------------------------------\n\n\nfloat4 _DHashScale ()  { return float4( 0.1031, 0.1030, 0.0973, 0.1099 ); }\n\nfloat DHash11 (const float p)\n{\n\tfloat3 p3 = Fract( float3(p) * _DHashScale().x );\n\tp3 += Dot( p3, p3.yzx + 19.19 );\n\treturn Fract( (p3.x + p3.y) * p3.z );\n}\n\nfloat2 DHash21 (const float p)\n{\n\tfloat3 p3 = Fract( float3(p) * _DHashScale().xyz );\n\tp3 += Dot( p3, p3.yzx + 19.19 );\n\treturn Fract( (p3.xx + p3.yz) * p3.zy );\n}\n//----------------------------------------------\n\n\nfloat3  CM_RotateVec (const float3 c, const int face)\n{\n\tswitch ( face )\n\t{\n\t\tcase 0 : return float3( c.z,  c.y, -c.x);\t// X+\n\t\tcase 1 : return float3(-c.z,  c.y,  c.x);\t// X-\n\t\tcase 2 : return float3( c.x, -c.z,  c.y);\t// Y+\n\t\tcase 3 : return float3( c.x,  c.z, -c.y);\t// Y-\n\t\tcase 4 : return float3( c.x,  c.y,  c.z);\t// Z+\n\t\tcase 5 : return float3(-c.x,  c.y, -c.z);\t// Z-\n\t}\n\treturn float3(0.0);\n}\n\nfloat3  CM_TangentialSC_Forward (const float2 snormCoord, const int face)\n{\n\tconst float\twarp_theta\t\t= 0.868734829276;\n\tconst float\ttan_warp_theta\t= 1.182286685546; //tan( warp_theta );\n\tfloat2\t\tcoord\t\t\t= Tan( warp_theta * snormCoord ) / tan_warp_theta;\n\n\treturn Normalize( CM_RotateVec( float3(coord.x, coord.y, 1.0), face ));\n}\n//----------------------------------------------\n\n\nfloat SDF_Plane (const float3 planePos, const float3 pos)\n{\n\tfloat3\tv = -planePos;\n\tfloat\td = Length( v );\n\treturn Dot( v / d, pos ) - d;\n}\n\nfloat3 SDF_Rotate (const float3 position, const quat q)\n{\n\treturn QMul( QInverse( q ), position );\n}\n\n\n#define GEN_SDF_NORMAL_FN( _fnName_, _sdf_, _field_ )                          \\\n\tfloat3 _fnName_ (const float3 pos)                                         \\\n\t{                                                                          \\\n\t\tconst float2\teps  = float2( 0.001, 0.0 );                           \\\n\t\tfloat3\t\t\tnorm = float3(                                         \\\n\t\t\t_sdf_( pos + eps.xyy ) _field_ - _sdf_( pos - eps.xyy ) _field_,   \\\n\t\t\t_sdf_( pos + eps.yxy ) _field_ - _sdf_( pos - eps.yxy ) _field_,   \\\n\t\t\t_sdf_( pos + eps.yyx ) _field_ - _sdf_( pos - eps.yyx ) _field_ ); \\\n\t\treturn Normalize( norm );                                              \\\n\t}\n\n#define GEN_SDF_NORMAL_FN2( _fnName_, _sdf_, _field_ )  \\\n\tfloat3 _fnName_ (const float3 pos)                  \\\n\t{                                                   \\\n\t\tconst float\t\th\t = 0.001;                   \\\n\t\tconst float2\tk\t = float2(1,-1);            \\\n\t\tfloat3\t\t\tnorm = float3(                  \\\n\t\t\tk.xyy * _sdf_( pos + k.xyy * h ) _field_ +  \\\n\t\t\tk.yyx * _sdf_( pos + k.yyx * h ) _field_ +  \\\n\t\t\tk.yxy * _sdf_( pos + k.yxy * h ) _field_ +  \\\n\t\t\tk.xxx * _sdf_( pos + k.xxx * h ) _field_ ); \\\n\t\treturn Normalize( norm );                       \\\n\t}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 736], [738, 738, 767, 767, 878], [1691, 1691, 1751, 1751, 1920]]}
{"id": "3ddBDn", "name": "AA for still images", "author": "iY0Yi", "description": "Simple anti-aliasing for still images.\nThis is a common technique in path tracing implementations.\nIt's very easy to implement and provides perfect anti-aliasing.\nLook at line 355 of BufA, and BufB.\nFullscreen is the best way to see the effect.", "tags": ["antialiasing", "aa"], "likes": 35, "viewed": 1286, "published": 3, "date": "1604835594", "time_retrieved": "2024-07-30T20:36:19.116693", "image_code": "\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(.9));\n    col = ACESFilm(col);\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n\n#define AMB_COL vec3(1., 0.7717, 0.6500)\n#define AMB_STRENGTH 0.9100\n#define FOG_COL vec3(1., 0.7717, 0.6500)\n#define FOG_START 0.5740\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "// \"init\": initialize camera and lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\nvec3  sdLight001_dir;\nvec3  sdLight001_col;\nfloat sdLight001_clip_start;\nfloat sdLight001_clip_end;\nfloat sdLight001_softness;\n#define L0_dir sdLight001_dir\n#define L0_col sdLight001_col\n#define L0_str sdLight001_clip_start\n#define L0_end sdLight001_clip_end\n#define L0_sft sdLight001_softness\nvec3  sdLight002_dir;\nvec3  sdLight002_col;\nfloat sdLight002_clip_start;\nfloat sdLight002_clip_end;\nfloat sdLight002_softness;\n#define L1_dir sdLight002_dir\n#define L1_col sdLight002_col\n#define L1_str sdLight002_clip_start\n#define L1_end sdLight002_clip_end\n#define L1_sft sdLight002_softness\n\nvoid init()\n{\n\tCamera_pos = vec3(-0.0913, 38.7396, 4.6344);\n\tCamera_quat = vec4(0.0205, 0.7140, 0.6996, 0.0200);\n\tCamera_fov = 0.1974;\n\tsdLight001_dir = normalize(vec3(-0.0538, 0.6674, 0.7427));\n\tsdLight001_col = vec3(1., 0.9681, 0.8761);\n\tsdLight001_clip_start = 0.0050;\n\tsdLight001_clip_end = 50.;\n\tsdLight001_softness = 2.2260;\n\tsdLight002_dir = normalize(vec3(0.0538, -0.6674, -0.7427));\n\tsdLight002_col = vec3(0.1523, 0.1523, 0.1523);\n\tsdLight002_clip_start = 0.0500;\n\tsdLight002_clip_end = 30.;\n\tsdLight002_softness = 50.;\n\n}\n\nvec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n    vec3 dir = quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Camera_pos.xzy;\n    float fov = Camera_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per)\n{\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_001 vec3(0.6415, 0.6584, 0.7382)\n#define MAT_002 vec3(0.9627, 0.8670, 0.7296)\n#define MAT_003 vec3(0.5510, 0.9288, 0.9146)\n#define MAT_004 vec3(0.8725, 0.6954, 0.7670)\n#define MAT_005 vec3(0.9622, 0.9396, 0.2231)\n#define MAT_006 vec3(0.9991, 1.0000, 0.8002)\n#define MAT_007 vec3(0.5713, 0.8689, 0.6389)\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\n\td = sdBox(p+vec3(1.5245, -9.0242, 0.6086), vec3(1., 1., 1.))-0.0100;\n\tres = v4OpUnion(vec4(d, MAT_004), res);\n\n\td = sdCappedTorus(rot(p+vec3(3.9270, -5.4430, -1.0193), vec3(1.5708, 0., 0.)), vec2(5.3682, 0.0245), 3.1413);\n\tres = v4OpUnion(vec4(d, MAT_007), res);\n\n\td = sdCapsule(p+vec3(-1.5767, -6.2993, -0.6990), 2.0201, 0.);\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-0.5540, -4.9952, -2.5487), vec3(-0.0330, 0.0176, 0.6502)), 0.0125, 6.1996), d, 0.2800);\n\tres = v4OpUnionSmooth(vec4(d, MAT_006), res, 0.4000);\n\n\td = sdConeSection(p+vec3(5.0217, -5.8192, -0.8244), 1.1768, 1.5291, 0.)-0.0100;\n\tres = v4OpUnion(vec4(d, MAT_003), res);\n\n\td = sdEllipsoid(p+vec3(7.7937, -3.2336, 1.0291), vec3(1.1783, 1.1783, 1.1783));\n\tres = v4OpUnionSmooth(vec4(d, MAT_002), res, 0.0100);\n\n\td = sdPlane(p);\n\tres = v4OpUnionSmooth(vec4(d, MAT_001), res, 0.0100);\n\n\td = sdSphere(p+vec3(-3.8602, -3.7245, 0.8280), 1.);\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 0.0100);\n\n\td = sdEllipsoid(rot(p+vec3(-1.6491, -3.7357, -0.7067), vec3(0., 3.1416, 0.)), vec3(0.3514, 0.3514, 0.3514));\n\tres = v4OpUnionSmooth(vec4(d, MAT_005), res, 0.8072);\n\n\td = sdEllipsoid(p+vec3(4.1916, -3.8762, -2.3231), vec3(0.0480, 0.0480, 0.0480));\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(4.1916, -4.3946, -2.3231), vec3(0.0480, 0.0480, 0.0480)), d, 0.5279);\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.0216, -4.2403, 0.2753), vec3(0.5796, 0.5796, 0.5796)), d, 1.8479);\n\tres = v4OpUnionSmooth(vec4(d, MAT_003), res, 0.5279);\n\n\td = sdEllipsoid(rot(p+vec3(1.3863, -4.7328, -1.8904), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.7026, 0.7026, 0.7026));\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 2.0786);\n\n\td = sdEllipsoid(rot(p+vec3(-2.8616, -2.8558, -0.9923), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.5893, 0.5893, 0.5893));\n\tres = v4OpUnionSmooth(vec4(d, MAT_003), res, 1.5842);\n\n\td = sdEllipsoid(rot(p+vec3(0.7289, -2.3445, -2.7742), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.2146, 0.2146, 0.2146));\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 1.2901);\n\n    return res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    int i = 0;\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n        res = min( res, k*h/t);\n        t += h;\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 50.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\nfloat ref(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 1.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=AMB_COL;\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir));\n        float shadow = shadow(p+offset, n);\n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, .5);\n        ao += ambientOcclusion(p, n, .5, .5);\n        ao += ambientOcclusion(p, n, 2., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\n        col = shadeLight1;\n        col *= shadow;\n        col+= shadeLight2*ao;\n        col+= AMB_COL*ao*AMB_STRENGTH*(1.-ref(p, n, L0_dir)*.5);\n        col*= base_col;\n        col = mix(col, col+L0_col, specular(p, n, L0_dir)*shadow*1.);\n        col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, 3.5)));\n    }\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n    init();\n    camera(uv);\n    render();\n\n    fragColor = vec4(col, 1.);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "// AA: Mix a new color with the average color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 new = texture(iChannel0, uv);\n    \n    if(iFrame==0){\n        fragColor = new;\n        return;\n    }\n    \n    vec4 ave = texture(iChannel1, uv);\n    fragColor = mix(new, ave, .99);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 163], [165, 165, 222, 222, 397]]}
{"id": "WstBWn", "name": "starfield + dark dust 3", "author": "FabriceNeyret2", "description": "With even better physics (sensor PSF) en deep sky.\n#if 0 line 29 to hide stars cross.\nmouse control.\nuse texture RGB as local coordinate of sphere in each voxel (I should either visit neighbor voxels or avoid voxel margin to not have truncated spheres).\n", "tags": ["raymarching", "volume", "spectrum", "galaxy", "nebula", "starfield", "astrophysics", "dust", "astronomy", "psf", "bokglobules"], "likes": 50, "viewed": 1668, "published": 3, "date": "1604826529", "time_retrieved": "2024-07-30T20:36:19.954453", "image_code": "// variant of https://shadertoy.com/view/wscfDr\n// #if 0/1 line 29 to hide/see stars cross.\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float d,l, I;\n    vec3  R = iResolution, \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),                          // ray direction\n          p = 2./R, L; \n    vec4  r, T = vec4(1), \n          C = exp(-.5*vec4(1,2,4,0)),                                         // dark dust unit transparency\n          S = vec4(.4,.6,1,0);                                                // star color\n    O-=O;\n    p.xy *= rot( .5+6.*M.y), D.xy *= rot( .5+6.*M.y);                         // camera move \n    p.xz *= rot( 2.-6.*M.x), D.xz *= rot( 2.-6.*M.x);\n    p.xy += cos( iTime + vec2(0,11)) - 2.*iTime;\n    \n    for ( float i=1.; i < 150.; i++,  p += D ) {                              // volume ray-casting\n        r = texture( iChannel0, (floor(p)+.5)/32. );                          // per voxel 4 random floats\n        // NB: we should either visit neighbor cells or avoid cell margins, but cut spheres are rare\n        L = fract(p) - r.rgb ;                                                // distance to sphere in voxel\n        d = -dot(L,D);            // distance ray-sphere: d/dl ( || P+l.D - C || )  = 2l + 2 (CP.D)\n        if (// r.a > .9 &&        // less blue-noise more white noise. but strange artifact\n            i>0. || d > 0.)                                                   // for not seeing in our back ;-)\n#define PSF(L) ( l = i/length(L) ,  min( 1e9, l*l*l ) ) // light on sensor = Istar * 1/d * 1/pixeldist = Istar * d/dist, cf https://www.shadertoy.com/results?query=star+psf\n            I = PSF( L += d*D ),                                              // L= point on the ray that is closest to sphere\n#if 1                             // 1 to see star cross\n            L.xz *= rot( -(2.-6.*M.x) ), L.xy *= rot( -(.5+6.*M.y) );         // back to screen-space\n            I +=  .3* PSF( L.xy * vec2(10,.2) ),\n            I +=  .3* PSF( L.xy * vec2(.2,10) ),\n#endif\n            O += T *   S * I/(i*i);                                           // blend to final color                     \n\n        l = max(0., 3.*texture( iChannel0, p/128. ).a -2.);                   // random density dark dust transparency\n        T *= pow(C, vec4(l));                                                 // cumul opacity\n    }\n    O = pow(  9e-7* O, vec4(1./2.2) );                                        // exposure + to sRGB\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "wscfDr", "name": "starfield + dark dust 2", "author": "FabriceNeyret2", "description": "With better physics (sensor PSF).\n#if 1 line 28 to see stars cross.\n\nmouse control.\nuse texture RGB as local coordinate of sphere in each voxel.\nNB: I should either visit neighbor voxels or avoid voxel margin to not have truncated spheres.\n", "tags": ["raymarching", "volume", "spectrum", "starfield", "astrophysics", "dust", "psf"], "likes": 15, "viewed": 568, "published": 3, "date": "1604824763", "time_retrieved": "2024-07-30T20:36:20.701456", "image_code": "// variant of  https://shadertoy.com/view/tscfDr\n\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float d,l, I;\n    vec3  R = iResolution, \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),                          // ray direction\n          p = 2./R, L; \n    vec4  r, T = vec4(1), \n          C = exp(-.5*vec4(1,2,4,0)),                                         // dark dust unit transparency\n          S = vec4(.4,.6,1,0);                                                // star color\n    O-=O;\n    p.xy *= rot( .5+6.*M.y), D.xy *= rot( .5+6.*M.y);                         // camera move \n    p.xz *= rot( 2.-6.*M.x), D.xz *= rot( 2.-6.*M.x);\n    p.xy += cos( iTime + vec2(0,11)) - 2.*iTime;\n    \n    for ( float i=1.; i < 50.; i++,  p += D ) {                               // volume ray-casting\n        r = texture( iChannel0, (floor(p)+.5)/32. );\n         \n        L = fract(p) - r.rgb ;                                                // distance to sphere in voxel\n        d = -dot(L,D);            // distance ray-sphere: d/dl ( || P+l.D - C || )  = 2l + 2 (CP.D)\n        if (// r.a > .9 &&        // less blue-noise more white noise. but strange artifact\n            i>0. || d > 0.)\n            l = length(L += d*D), // L= point on the ray that is closest to sphere\n            I = 1./(l*l*l),       // light on sensor = Istar * 1/d * 1/pixeldist = Istar * d/dist, cf https://www.shadertoy.com/results?query=star+psf\n#if 0                             // 1 to see star cross\n            L.xz *= rot( -(2.-6.*M.x) ), L.xy *= rot( -(.5+6.*M.y) );\n            l =  length(L.xy * vec2(10,.2)),I += .3/(l*l*l),\n            l =  length(L.xy * vec2(.2,10)),I += .3/(l*l*l),\n#endif\n            O += T * S *i *I;                                                 // blend to final color                     \n\n         T *= pow(C, vec4( max(0., 3.*texture( iChannel0, p/128. ).a -2.) )); // cumul random density dark dust transparency\n    }\n    O = pow(  3e-7* O, vec4(1./2.2) );                                        // exposure + to sRGB\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "tscfDr", "name": "starfield + dark dust", "author": "FabriceNeyret2", "description": "mouse control\n\nuse texture RGB as local coordinate of sphere in each voxel.\nNB: I should either visit neighbor voxels or avoid voxel margin to not have truncated spheres.", "tags": ["raymarching", "volume", "starfield", "short"], "likes": 11, "viewed": 558, "published": 3, "date": "1604822760", "time_retrieved": "2024-07-30T20:36:21.453446", "image_code": "// variant of \"starfield 2\" by FabriceNeyret2. https://shadertoy.com/view/WstBR7\n\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                           // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float d;\n    vec3  R = iResolution, \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),                       // ray direction\n          p = 2./R, S; \n    vec4  r, T = vec4(1), C = exp(-.2*vec4(1,2,4,0));                      // C = dark dust unit opacity\n    O-=O;\n    p.xy *= rot( .5+6.*M.y), D.xy *= rot( .5+6.*M.y);                      // camera move \n    p.xz *= rot( 2.-6.*M.x), D.xz *= rot( 2.-6.*M.x);\n    p.xy += cos( iTime + vec2(0,11)) - iTime;\n    \n    for ( float i=0.; i < 50.; i++,  p += D ) {                            // volume ray-casting\n        r = texture( iChannel0, (floor(p)+.5)/32. );\n         \n        S = fract(p) - r.rgb ;                                             // distance to sphere in voxel\n        d = -dot(S,D);       // distance ray-sphere: d/dl ( || P+l.D - C || )  = 2l + 2 (CP.D)\n        if (i>0. || d > 0.)\n            S += d*D,        // point on the ray that is closest to sphere\n        //  O += 3e-4 / dot(S,S)                                           // addition variant\n            O += T * clamp(1.- 1e3* dot(S,S), 0.,1. );                     // blend\n\n         T *= pow(C, vec4( max(0., 3.*texture( iChannel0, p/128. ).a -2.) )); // random density dark dust opacity\n    }\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 225, 225, 1554]]}
{"id": "tscBDr", "name": "mirror face", "author": "mds2", "description": "realtime riff on https://srl.org/karen/faceflipper/ff.html\n\ndrag mouse to drag mirror point.  Move your face to get the mirror stuff right.", "tags": ["simple", "experiment", "webcam", "mirror", "face"], "likes": 2, "viewed": 455, "published": 3, "date": "1604814571", "time_retrieved": "2024-07-30T20:36:22.289211", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 mouse_uv = iMouse.xy/iResolution.xy;\n    \n    uv.x = mouse_uv.x + abs(uv.x - mouse_uv.x);\n\n    // Output to screen\n    fragColor = texture(iChannel0, vec2(1.0 - uv.x, uv.y));\n    \n    if (abs(fragCoord.x - iMouse.x) < 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 440]]}
{"id": "td3BDn", "name": "geometric pattern 001", "author": "catafest", "description": "a simple geometric pattern with sin , dot and iMouse", "tags": ["sin", "dot", "geometricpattern", "imouse"], "likes": 0, "viewed": 431, "published": 3, "date": "1604782999", "time_retrieved": "2024-07-30T20:36:23.037211", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a = fragCoord/iResolution.x;\n    vec2 b = fragCoord/iResolution.y;\n    // iMouse get position of mouse , move mouse into are of shader\n    //float sin_dot = sin(dot(1.0/a*iMouse.x,1.0/b*iMouse.y));\n    float sin_dot = sin(dot(a*iMouse.x,b*iMouse.y));\n    fragColor = vec4(sin_dot);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3BDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 350]]}
{"id": "3s3BDr", "name": "Costas8 LUT-texture #0", "author": "ollj", "description": "Using a texture buffer to store more (recursively useful) costas arrays\nIdeally this becomes a512x512 or 1024x1024 texture of greater utility (of making procgen hashes/noises/melodies) than any other (static but faster for being static) noisy texutre.", "tags": ["noise", "fft", "gradient", "dither", "derivative", "fourier", "distribution", "dft", "dft", "laplachian", "costasarray", "patternfree", "unniquederivati"], "likes": 1, "viewed": 359, "published": 3, "date": "1604767261", "time_retrieved": "2024-07-30T20:36:24.094384", "image_code": "//i forgot, it only stores 8 bit per .rgb so values>255 must be split\n//and i fail at buffering and reading values\n//well that was a nice day ofclassifying costasArrays...\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n   ;fragColor=texture(iChannel3,(fragCoord+.5)/iResolution.xy)\n    ;return\n    \n        \n        //remember the ealsy exit here!!!\n        \n        \n    ;vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n//end of signal inspector\n\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 40\n    \n#define animatePaletteSpeed .9\n\n//tile sizes\n//int gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\nint gpo(int i\n){int p[]=int[arrLen](2,3,5,7,11,13,17,19,23,29,31,37,41,47,53,59,61,67,71,79,101,107,137,149,167\n                 ,179,191,197,227,239,241,269,281,311,347,359,419,431,461,487)\n ;i=clamp(i,0,39);//worksafing, clamp faster than mod\n ;return p[i];}\n  \n//int gpo(int a){int b[arrLen]=int[arrLen](2,3,5,7,11,13,17,79,101,239,241,269,281,487);return b[a];}\n\n/*\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n //return texture((vec2(p,a)+.1)/iResolution.xy.xy)\n    ;}\n    /*\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs:\n\n/**/\n    \n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4\t\tgood\n\n\n/*\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/\n           // ;}}}\n            \n            \n\n\n\n\n/*\n\n#define EL ;}else\n#define I0 if((y&1)>0)\n#define I1 if((y&2)>0)\n#define I2 if((y&4)>0)\n#define I3 if((y&8)>0)\n#define I4 if((y&16)>0)\n#define I5 if((y&32)>0)\n#define I20 I2{I1{I0\n#define I30 I3{I20\n#define I40 I4{I30\n\nfloat gca(int x,int y\n){    I5{I40{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}EL{I30{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n;}}}}}EL{I40{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}EL{I30{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n  ;}}}EL{I20{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}EL{I1{I0{\n          EL{\n     ;}EL{I0{\n          EL{\n ;}}}}}}\n return 1.;}\n              \n              /**/", "buffer_d_code": "/*\ntodo\n- maybe expand qhite square to 1024x1024 (and include up to 2x as many primes, each in over 2x as long lists)\n- fill the inner bkack area with costas arrays (quite big gaps still)\n- make use of the unused whiteSpace in the square (this will add non-prime lists)\n\n*/\n\n//return lenggth of Nth costas array (that has a prime length AND a good entry)\n/*\n//return Nth prime by index 0->2,1->3 2->5,... 95-> 499\nint prime94to499(int i\n){int p[]=int[95](2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97\n                ,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191\n                ,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283\n                ,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401\n                ,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499)\n ;i=clamp(i,0,94);//worksafing, clamp faster than mod\n ;return p[i];}*/\n\n//DSS means, it is a DumbSubSet of the above, just because we do not know ALL costasArrays of a given size (except for s sizes up to 32)\n//which leaves many primes having null, or only very few (and way too bad for this recursive-noise/dither/hash utility)\nint primeDss94to499(int i){return gpo(i);}\n\n#define EL ;}else\n#define I0 if((y&1)>0)\n#define I1 if((y&2)>0)\n#define I2 if((y&4)>0)\n#define I3 if((y&8)>0)\n#define I4 if((y&16)>0)\n#define I5 if((y&32)>0)\n#define I20 I2{I1{I0\n#define I30 I3{I20\n#define I40 I4{I30\nint gca(int x,int y,bool r\n){int p=x\n ;    I5{I40{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n ;}}EL{I1{I0{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n  ;}}}EL{I20{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\t\treturn 1\n ;}}EL{I1{I0{\t\treturn 1\n          EL{\t\treturn 1\n     ;}EL{I0{\t\treturn 1\n          EL{\treturn 1\t\n ;}}}}EL{I30{\treturn 1\t\n          EL{return 1\t\t\n     ;}EL{I0{return 1\t\t\n          EL{return 1\t\t\n ;}}EL{I1{I0{return 1\t\t\n          EL{return 1\t\n     ;}EL{I0{return 1\t\n          EL{return 1\t\n  ;}}}EL{I20{int c[]=int[487](\t229,422,169,459,328,204,107,57,121,133,426,144,190,39,257,428,191,348,136,223,362,418,456,374,87,161,278,453,199,300,396,451,308,198,314,339,434,390,14,263,193,137,98,113,282,341,391,440,431,63,154,336,370,394,351,450,8,321,101,318,185,196,50,313,67,296,65,337,295,433,155,183,287,195,99,481,317,157,288,139,114,202,468,106,128,212,25,179,232,368,293,393,432,465,389,381,439,43,75,254,59,134,462,222,448,84,7,325,290,115,342,383,44,81,110,416,274,455,301,353,9,291,284,392,264,350,224,85,166,160,365,303,10,102,437,19,42,403,80,332,214,180,379,12,438,262,430,349,464,449,217,307,187,51,71,237,78,410,331,130,26,249,171,329,470,129,176,475,3,272,163,454,484,373,226,167,269,458,88,142,399,189,72,347,61,463,153,388,182,13,17,260,41,429,74,62,207,34,29,358,385,82,215,6,306,320,197,482,299,372,352,86,326,141,203,220,151,447,387,216,380,104,20,127,240,175,243,246,1,423,271,89,279,310,315,297,156,371,266,225,419,486,227,487,421,228,270,376,162,304,323,319,289,100,283,436,15,261,259,192,258,146,40,125,402,239,411,472,177,247,231,170,356,117,384,405,333,27,233,357,344,45,255,123,427,401,73,79,253,109,122,478,91,311,69,66,236,443,209,30,119,406,132,250,461,205,152,33,335,234,294,442,64,35,235,345,77,60,252,206,58,408,251,330,108,213,415,5,164,324,159,140,277,398,309,52,68,444,36,359,46,111,479,281,316,435,184,18,148,126,55,211,120,414,477,273,280,200,340,467,382,21,404,412,131,476,425,90,400,53,238,210,174,24,474,248,424,460,143,221,96,361,112,275,201,397,219,188,95,38,47,124,92,54,445,31,386,334,181,369,286,265,138,363,276,302,452,322,483,158,267,364,457,354,327,116,469,22,241,473,245,2,230,377,367,11,285,16,194,147,49,93,70,37,346,256,135,145,97,48,480,312,298,338,395,466,218,105,150,56,32,407,28,172,118,23,413,178,4,378,305,103,186,149,94,446,360,83,417,165,485,268,420,375,168,366,355,292,343,441,76,208,409,173,471,242,244\t);if(r)return c[(487-p)%487];return c[p%487];\t//\t0\t\tthe only one\n          EL{return 461\t//\t461\n     ;}EL{I0{return 431\t//\t431\n          EL{return 419\t//\t419\n ;}}EL{I1{I0{return 359\t//\t359\n          EL{return 347\t//\t347\n     ;}EL{I0{return 311\t//\t311\n          EL{int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n;}}}}}EL{I40{int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n          EL{int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n     ;}EL{I0{int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n          EL{return 227\t//\t227\n ;}}EL{I1{I0{return 197\t//\t197\n          EL{return 191\t//\t191\n     ;}EL{I0{return 179\t//\t179\n          EL{return 167\t//\t167\n  ;}}}EL{I20{return 149\t//\t149\n          EL{return 137\t//\t137\n     ;}EL{I0{return 107\t//\t107\n          EL{int c[]=int[101](\t4,87,64,53,97,24,7,75,9,67,41,42,38,54,93,40,46,22,15,43,34,70,29,90,52,101,8,71,25,3,91,48,14,47,18,31,82,84,76,5,83,80,92,44,30,86,68,37,58,77,1,99,16,39,50,6,79,96,28,94,36,62,61,65,49,10,63,57,81,88,60,69,33,74,13,51,2,95,32,78,100,12,55,89,56,85,72,21,19,27,98,20,23,11,59,73,17,35,66,45,26\t);if(r)return c[(101-p)%101];return c[p%101];\t//\t41\t\tgood very\n ;}}EL{I1{I0{int c[]=int[79](\t5,8,15,47,41,24,36,18,45,10,76,61,32,13,43,71,63,72,44,70,28,25,33,54,22,78,55,69,12,30,64,77,68,35,34,23,48,65,16,40,3,39,9,51,49,37,57,53,27,60,29,73,46,56,67,6,52,31,21,50,11,26,4,79,38,75,1,17,19,20,42,2,7,62,66,59,14,74,58\t);if(r)return c[(79-p)%79];return c[p%79];\t//\t13\t\tgood best\n          EL{return 71\t//\t71\n     ;}EL{I0{return 67\t//\t67\n          EL{return 61\t//\t61\n ;}}}}EL{I30{return 59\t//\t59\n          EL{return 53\t//\t53\n     ;}EL{I0{return 47\t//\t47\n          EL{return 41\t//\t41\n ;}}EL{I1{I0{return 37\t//\t37\n          EL{return 31\t//\t31\n     ;}EL{I0{return 29\t//\t29\n          EL{return 23\t//\t23\n  ;}}}EL{I20{int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];//is too symmetrical\n          EL{int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n     ;}EL{I0{int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n          EL{int c[]=int[11](0,4,10,7,8,2,1,9,5,3,6      );if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n ;}}EL{I1{I0{int c[]=int[ 7](1,4,5,3,0,6,2               );if(r)return c[( 7-p)% 7];return c[p% 7];\t//\t22\t\tgood very\n          EL{int c[]=int[ 5](1,2,4,0,3                   );if(r)return c[( 5-p)% 5];return c[p% 5];\t//\t4\t\tgood\n     ;}EL{I0{int c[]=int[ 3](0,2,1                       );if(r)return c[( 3-p)% 3];return c[p% 3];\t//0 no choice\n          EL{int c[]=int[ 2](1,0                         );if(r)return c[( 2-p)% 2];return c[p% 2];\t//0 no choice           \n ;}}}}}}\n return 0;}\n              \n\n//return value of costas array (of prime length) at position.x primeIndex.y\nvec3 bufferCostas(vec2 a\n){if(max(a.x,a.y)>511.)return vec3(0.);\n ;ivec2 u=ivec2(a)\n ;//int p=prime94to499(u.y);\n ;int p=primeDss94to499(u.y);\n ;if(u.y>39||u.x>=p)return vec3(1);\n ;ivec3 b=ivec3(gca(u.x,u.y,true),0,0);\n ;b.z=(b.x&255     )    //8 lowest bits\n ;b.y=(b.x&65280   )/256//8 next bits\n ;b.x=(b.x&16711680)/256/256//8 highest bits\n ;return vec3(b.zyx)/255.\n ;}\n\nvoid mainImage(out vec4 O,vec2 u\n){\n ;vec3 c=bufferCostas(u);\n ;O=vec4(c,1.);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n ;vec3 f=texture(iChannel3,(vec2(p,a))/iResolution.xy).zyx;\n //;if(f>0.9)return 9999\n //;return int(f*float(gpo(a)))\n    \n ;ivec3 b=ivec3(f*255.);\n ;b.x+=b.y*256+b.z*256*256\n ;return b.x\n //;b.z=(b.x&255     )    //8 lowest bits\n //;b.y=(b.x&65280   )>> 8//8 next bits\n //;b.x=(b.x&16711680)>>16//8 highest bits\n //;return vec3(b)/255.\n    \n ;}\n\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n //;if(c==9999)return 0;//catches empty entries\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/4)%(per);\n ;return r;}\n\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n\n ;float r=0.;\n    \n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[40](\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,\n  1.,1.,1.,1.,1.,1.,1.,1.,1.,1.)\n     \n //;float f[]=float[arrLen](1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.)\n     \n    // float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=f//float[7](1.,2.,4.,8.,16.,32.,0.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=f//float[7](64.,32.,16.,8.,4.,2.,0.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<40;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);\n }    \n;for(int i=0;i<40;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat\n }\n    \n    ;float s=0.;\n    ;int ass=8\n  // for(int i=0;i<2;i++ \n   ;for(int i=0;i<40+1;i++\n\n       ){  \n       \n       if(\n           i==7\n           //i==20\n          // i==21\n       //    i<8\n       ){\n       s+=f[i]\n        ;r+=float(Cs(u,i,iFrame))/float(gpo(i))*f[i];\n           ;}}\n    \n //;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[0];\n //;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n// ;u=u.yx//addition, to make half of the arrays diagonally flipped\n //;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n //;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n //;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n //;u=u.yx//addition, to make half of the arrays diagonally flipped\n //;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n //;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n     \n    \n ;float a=r/s//(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n ;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*.3)*.5+.5;}\n ;//u*=2.2\n ;u/=2.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}\n\n\n\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    //return wrap(p,iFrame,iTime);\n    //return fract(p.x-p.y);\n    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n    /**/\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n   // p *= globalScale;\n    \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime,iMouse/iResolution.xyxy));\n    /*\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    */\n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "WdcfWr", "name": "Audiorays", "author": "paniq", "description": "sampling the contents of a texture with a lissajous curve and playing it as audio.", "tags": ["audio", "sampling", "lissajous"], "likes": 10, "viewed": 497, "published": 3, "date": "1604758811", "time_retrieved": "2024-07-30T20:36:25.122635", "image_code": "//////////////////////////////////////////////////////////\n\nvoid paint() {\n    float t = iTime;\n\n    set_source_rgb(0.0, 0.0, 0.0);\n    clear();\n    \n    rectangle(-1.0,-1.0,2.0,2.0);\n    set_source_rgb(vec3(sample_field(iChannel0, get_origin() * 0.5 + 0.5).x * 0.5 + 0.5));\n\tfill_preserve();    \n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0));\n    stroke();\n    \n    vec2 p, p2;\n    example_audioray(iChannel0, t - 1.0/60.0, p);\n    example_audioray(iChannel0, t + 1.0/60.0, p2);\n    move_to(p*2.0 - 1.0);\n    line_to(p2*2.0 - 1.0);\n    stroke();\n    circle(p*2.0 - 1.0, 0.01);\n    fill();\n    \n\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 lissajous(float t, float phi, float a, float b) {\n    return vec2(\n        sin(a * t + phi),\n        sin(b * t)\n        );\n}\n\nvec2 sample_field(sampler2D image, vec2 p) {\n    p = mod(p, vec2(1.0));\n\treturn vec2(textureLod(image, p, 0.0).r * 2.0 - 1.0);\n}\n\nvec2 audioray(sampler2D image, vec2 rd, float t, out vec2 p) {\n    p = mod((rd * t), vec2(1.0));\n\treturn sample_field(image, p);\n}\n\nvec2 example_audioray(sampler2D image, float t, out vec2 p) {\n    p = lissajous(t, 0.785398, 11.0, 10.0) * 0.5 + 0.5;\n\treturn sample_field(image, p);\n}\n\n\n//////////////////////////////////////////////////////////\n\n\n// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "vec2 mainSound( in int samp, float time )\n{\n    vec2 p;\n    return vec2(example_audioray(iChannel0, time, p));\n}", "sound_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 74, 74, 609], [671, 671, 728, 728, 814]]}
{"id": "3s3BWr", "name": "Google TurboColormap dimmed", "author": "morisil", "description": "Check out: https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\n\nFor comparison: https://www.shadertoy.com/view/tddBR7\n\nhttps://shadertoy.com/view/Wd3BWr\n", "tags": ["color", "gradient", "turbocolormap"], "likes": 7, "viewed": 471, "published": 3, "date": "1604751380", "time_retrieved": "2024-07-30T20:36:26.006273", "image_code": "// Fork of \"Google TurboColormap color study\" by morisil. https://shadertoy.com/view/Wd3BWr\n// 2020-11-07 12:07:43\n\n// Fork of \"Google TurboColormap grad. study\" by morisil. https://shadertoy.com/view/3dcfDn\n// 2020-11-07 12:04:55\n\n// Fork of \"spectral_zucconi6 gradient study\" by morisil. https://shadertoy.com/view/wsdBR7\n// 2020-11-07 10:50:52\n\n// Fork of \"spectral_zucconi6 color study\" by morisil. https://shadertoy.com/view/tddBR7\n// 2020-11-07 01:33:41\n\nfloat dim(float x) {\n\treturn -4. * pow(x - .5, 2.) + 1.;    \n}\n\nvec3 dimmedTurbo(float x) {\n    return TurboColormap(x) * dim(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 color = mix(\n        dimmedTurbo(mod(uv.x - iTime * .04, 1.)),\n        dimmedTurbo(1. - mod(uv.x + iTime * .15, 1.)),\n        uv.y\n    );\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "// Copyright 2019 Google LLC.\n// SPDX-License-Identifier: Apache-2.0\n\n// Polynomial approximation in GLSL for the Turbo colormap\n// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n\n// Authors:\n//   Colormap Design: Anton Mikhailov (mikhailov@google.com)\n//   GLSL Approximation: Ruofei Du (ruofei@google.com)\n\n\nfloat saturate (float x) {\n    return min(1.0, max(0.0,x));\n}\n\nvec3 TurboColormap(in float x) {\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n  \n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n  );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 461, 481, 481, 523], [525, 525, 552, 552, 592], [594, 594, 649, 649, 870]]}
{"id": "Wd3BWr", "name": "Google TurboColormap color study", "author": "morisil", "description": "Check out: https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\n\nFor comparison: https://www.shadertoy.com/view/tddBR7\n", "tags": ["color", "gradient", "turbocolormap"], "likes": 0, "viewed": 403, "published": 3, "date": "1604750770", "time_retrieved": "2024-07-30T20:36:26.850017", "image_code": "// Fork of \"Google TurboColormap grad. study\" by morisil. https://shadertoy.com/view/3dcfDn\n// 2020-11-07 12:04:55\n\n// Fork of \"spectral_zucconi6 gradient study\" by morisil. https://shadertoy.com/view/wsdBR7\n// 2020-11-07 10:50:52\n\n// Fork of \"spectral_zucconi6 color study\" by morisil. https://shadertoy.com/view/tddBR7\n// 2020-11-07 01:33:41\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 color = mix(\n        TurboColormap(mod(uv.x - iTime * .04, 1.)),\n        TurboColormap(1. - mod(uv.x + iTime * .15, 1.)),\n        uv.y\n    );\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "// Copyright 2019 Google LLC.\n// SPDX-License-Identifier: Apache-2.0\n\n// Polynomial approximation in GLSL for the Turbo colormap\n// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n\n// Authors:\n//   Colormap Design: Anton Mikhailov (mikhailov@google.com)\n//   GLSL Approximation: Ruofei Du (ruofei@google.com)\n\n\nfloat saturate (float x) {\n    return min(1.0, max(0.0,x));\n}\n\nvec3 TurboColormap(in float x) {\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n  \n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n  );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 345, 400, 400, 625]]}
{"id": "WdcfDn", "name": "Fyords", "author": "dyla", "description": "Inspired mainly by iq's Elevated intro and his blog (https://iquilezles.org), I spent a few hours on this \"hello, world\" terrain marching attempt. Use the mouse to explore in MODE 0, or fly above the terrain in MODE 1.", "tags": ["procedural", "reflection", "ray", "terrain", "water", "marching", "mountains", "marcher"], "likes": 9, "viewed": 491, "published": 3, "date": "1604746556", "time_retrieved": "2024-07-30T20:36:27.676806", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) - 0.5;\n}\n\nfloat fprand(vec2 uv, float f){\n    vec2 sp = uv*f;\n    vec2 isp = floor(sp);\n    vec2 fsp = fract(sp);\n    \n    float a = prand(isp+0.5);\n    float b = prand(isp+0.5+vec2(1.0,0.0));\n    float c = prand(isp+0.5+vec2(0.0,1.0));    \n    float d = prand(isp+0.5+vec2(1.0,1.0));\n    float wx = smoothstep(0.0, 1.0, fsp.x);\n    float wy = smoothstep(0.0, 1.0, fsp.y);\n    return mix(mix(a,b,wx), mix(c,d,wx), wy);\n    \n}\n\nfloat perlin(vec2 uv, int octaves, float f0, float fmul, float v0, float vmul){\n    float val = 0.0;\n    float frq = f0;\n    float wei = v0;\n    \n    for (int i=0; i<octaves; i++) {\n        val += wei * fprand(uv, frq);\n        frq *= fmul;\n        wei *= vmul;\n    }\n    \n    return val;\n}\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    int octaves = 6;\n    float f0 = 0.35;\n    float fmul = 2.2;\n    float v0 = 2.5;\n    float vmul = 0.4;\n    return perlin(uv, octaves, f0, fmul, v0, vmul);\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 432, 432, 517], [519, 519, 550, 550, 934], [936, 936, 1015, 1015, 1226], [1299, 1299, 1337, 1337, 1497], [1499, 1499, 1532, 1532, 1752], [1754, 1754, 1792, 1792, 2019], [2021, 2021, 2059, 2059, 2283], [2285, 2285, 2314, 2314, 2409], [2411, 2411, 2448, 2448, 2507], [2510, 2578, 2597, 2597, 2636], [2638, 2638, 2658, 2658, 2734], [2736, 2736, 2755, 2755, 2794], [2796, 2796, 2853, 2853, 3088], [3090, 3090, 3125, 3125, 3519], [3521, 3521, 3575, 3575, 4241], [4244, 4244, 4296, 4296, 4731], [4733, 4733, 4790, 4790, 5981]]}
{"id": "3dcfDn", "name": "Google TurboColormap grad. study", "author": "morisil", "description": "Check out: https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html\n", "tags": ["color", "gradient", "turbocolormap"], "likes": 1, "viewed": 360, "published": 3, "date": "1604746522", "time_retrieved": "2024-07-30T20:36:28.427798", "image_code": "// Fork of \"spectral_zucconi6 gradient study\" by morisil. https://shadertoy.com/view/wsdBR7\n// 2020-11-07 10:50:52\n\n// Fork of \"spectral_zucconi6 color study\" by morisil. https://shadertoy.com/view/tddBR7\n// 2020-11-07 01:33:41\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 color = mix(\n        TurboColormap(mod(iTime * .055, 1.)),\n        TurboColormap(mod(- iTime * .07, 1.)),\n        uv.y\n    );\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "// Copyright 2019 Google LLC.\n// SPDX-License-Identifier: Apache-2.0\n\n// Polynomial approximation in GLSL for the Turbo colormap\n// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n\n// Authors:\n//   Colormap Design: Anton Mikhailov (mikhailov@google.com)\n//   GLSL Approximation: Ruofei Du (ruofei@google.com)\n\n\nfloat saturate (float x) {\n    return min(1.0, max(0.0,x));\n}\n\nvec3 TurboColormap(in float x) {\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n  \n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n    dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n  );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 284, 284, 493]]}
{"id": "WdtfR7", "name": "Crullers", "author": "Catzpaw", "description": "SDF returns material id", "tags": ["raymarching"], "likes": 14, "viewed": 432, "published": 3, "date": "1604744083", "time_retrieved": "2024-07-30T20:36:29.228657", "image_code": "//--- Crullers\n// by Catzpaw 2020\n\n#define ITER 128\n#define EPS 1e-4\n#define NEAR 0.5\n#define FAR 15.0\n\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//COLOR ADJUSTMENT\nconst mat3 rgb2yc = mat3(.299,.587,.114,.595716,-.274453,-.321263,.211456,-.522591,.311135);\nconst mat3 yc2rgb = mat3(1.,.9563,.6210,1.,-.2721,-.6474,1.,-1.1070,1.7046);\nvec3 adjust(vec3 c,float h,float s){\n\tc*=rgb2yc;\n    h=atan(c.z,c.y)+h;\n    s=length(c.yz)*s;\n    return vec3(c.r,cos(h)*s,sin(h)*s)*yc2rgb;\n}\n\n//LIGHT COLOR\nvec3 lcol,scol;\n\n//BUMP MAP\nfloat bump(vec3 p){\n    float b=clamp(max(abs(sin(p.x*p.y*3.14)),abs(sin(p.z*8.))),.98,1.)-.98;\n\treturn b*1.5;\n}\n\n//SDF WITH MATERIAL ID\nfloat sdiTwistedRing(vec3 p,out int id){\n    p.xz*=rot(iTime*.6);\n    p=vec3(length(p.xz)-2.5,p.y,atan(p.x,p.z));\n    float b=bump(p);\n    p.xy*=rot(p.z*8.);\n\tfloat d1=length(p.xy+vec2(0, .2))+b-.99,\n          d2=length(p.xy+vec2(0,-.2))+b-.99;\n    id=abs(d1)<abs(d2)?0:2;\n    id+=b>.0?0:1;\n    return min(d1,d2);\n}\n\n//SCENE\nfloat map(vec3 p,out int id){\n\tint i1,i2;\n    p.yz*=rot(iTime*.5);\n    float d1=sdiTwistedRing(p    +vec3(-1.25,0,0),i1),\n          d2=sdiTwistedRing(p.xzy+vec3( 1.25,0,0),i2);\n    id=abs(d1)<abs(d2)?i1:3+i2;\n    return min(d1,d2);\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    int z;\n    return normalize(e.xxx*map(p+e.xxx*EPS,z)+e.xyy*map(p+e.xyy*EPS,z)+\n                     e.yxy*map(p+e.yxy*EPS,z)+e.yyx*map(p+e.yyx*EPS,z));\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out int id,out vec3 p,out vec3 n){\n    float t=NEAR,d;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p,id);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,1.)*d*.5+d*.5;\n    }\n    n=normal(p);\n    return min(t,FAR);\n}\n\n//AMBIENT OCCULUSION\nfloat ao(vec3 p,vec3 no){\n\tfloat o=2.,s=.5;int z;\n    for(float i=1.;i<5.;i++){float r=.3*i;o+=(map(no*r+p,z)-r)*s;s*=.5;}\n    return clamp(o*.5,0.,1.);\n}\n\n//SOFT SHADOW\nfloat shadow(vec3 p,vec3 ld){\n\tfloat o=2.,s=1.;int z;\n    for(float i=1.;i<4.;i++){float r=1.5*i;o+=(map(-ld*r+p,z)-r)*s;s*=.5;}\n    return clamp(o,0.,1.);\n}\n\n//CUBEMAPS\nvec3 cubemap(vec3 d){\n\treturn mix(texture(iChannel0,d).rgb,texture(iChannel1,d).rgb,\n               clamp(cos(iTime*.2)*20.+.5,0.,1.));\n}\n\n//REFLECTION\nvec3 reflection(vec3 p,vec3 rd,vec3 n){\n    //find the reflected surface\n    int id;\n    rd=reflect(rd,n);\n    float d,t=.2;\n    for(int i=ZERO;i<ITER;i++){\n        d=map(rd*t+p,id);\n        if(d<EPS||d>4.)break;\n        t+=d;\n    }\n    if(d<EPS){\n        //found\n        vec3 c=hsv(float(id)*.2+iTime*.04,.2,1.);\n        if(id%3<1){\n            //the surface is non-metal\n\t    \treturn c*.4;\n        }else{\n            //the surface is metal\n\t\t    n=normal(p+rd*t);\n\t    \treturn c*adjust(pow(cubemap(reflect(rd,n)),vec3(2.)),.0,.1)*2.;\n        }\n    }else{\n        //not found\n        return adjust(pow(cubemap(rd),vec3(4.)),.0,.2)*16.;\n    }\n}\n\n//MATERIAL\nvec3 material(int id,vec3 p,vec3 rd,vec3 n){\n\n    //normalized light direction\n    vec3 ld=vec3(0,-1,0);\n\n    //non-metal(10% mirror) or metal(100% mirror)\n    vec3 m=reflection(p,rd,n);\n    vec3 c=id%3<1?.9+m*.1:m;\n\n    //light and shadow\n    c*=lcol*max(dot(reflect(ld,n),-rd),0.)*shadow(p,ld)+scol*.4;\n\n    //surface color with AO\n    c*=hsv(float(id)*.2+iTime*.04,.2,ao(p,n));\t\n\n    return c;\n}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA SETUP\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),\n         ro=vec3(0,sin(iTime*.32)*.3,-6.5+cos(iTime*.6)*.5),\n         rd=normalize(vec3(uv,.5));\n    mat2 r=rot(sin(iTime*.32)*.5);\n    ro.yz*=r;\n    rd.yz*=r;\n    ro.xz*=rot(iTime*.3);\n    rd.xz*=rot(iTime*.3+sin(iTime*.6+3.14)*.15);\n\n    //GET SURFACE AND MATERIAL ID\n    int  id;\n    float t=trace(ro,rd,id,p,n);\n\n    //SHADING\n    if(t>12.){\n        //background\n        c=cubemap(rd);\n    }else{\n        //light color from background\n        lcol=cubemap(vec3(0,-1,0))+.2;\n        //shadow color from background\n        scol=cubemap(vec3(0,1,0))*.4+.2;\n        //get surface color\n\t    c=material(id,p,rd,n);\n    }\n    fragColor=vec4(c,1);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 150, 150, 197], [198, 198, 232, 232, 309], [500, 500, 536, 536, 642], [675, 686, 705, 705, 798], [800, 823, 863, 863, 1138], [1140, 1148, 1177, 1177, 1381], [1383, 1392, 1412, 1412, 1599], [1601, 1615, 1677, 1677, 1886], [1888, 1909, 1934, 1934, 2063], [2065, 2079, 2108, 2108, 2236], [2238, 2249, 2270, 2270, 2386], [2388, 2401, 2440, 2473, 3045], [3047, 3058, 3102, 3136, 3456], [3458, 3465, 3522, 3541, 4269]]}
{"id": "wddBRM", "name": "cellular automaton", "author": "Dragonpeak", "description": "Game of life. Edit the rules through the \"BORN\" & \"SURVIVE\" arrays in common.\nAlso available is speed, scale and grid line size.", "tags": ["2d", "life", "cellularautomaton", "gol"], "likes": 31, "viewed": 672, "published": 3, "date": "1604740526", "time_retrieved": "2024-07-30T20:36:30.124262", "image_code": "\nfloat march_shadow(vec2 pos)\n{\n\tfloat MAX_DIST = 5./iResolution.x;\n    const float STEP_SIZE = 0.0001;\n    const vec2 dir = normalize(vec2(0.2, 0.2));\n\n    float dist = 0.;\n    while(dist < MAX_DIST)\n    {\n        vec2 p = pos+dir*dist;\n        float t = texture(iChannel1, p).x;\n\t\tif(t >= 1.)\n        {\n\n\t\t\tbreak;\n            \n        }\n        dist += STEP_SIZE;\n        \n    }\n    \n    return (dist/MAX_DIST);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord+iTime*20.;\n    vec2 uv = pos/iResolution.xy;\n\n    \n    int cell = int(texture(iChannel1, uv*SCALE).x);\n    vec3 col = vec3(.8);\n    if(cell >= 1)\n    {\n\t\tcol = mix(vec3(0.95), vec3(.7, 0.1, 0.2)*1.4, 1.-min(float(cell)/6., 1.));\n    }\n    \n    float grid = step(1.-GRID_SIZE, fract((pos.x-0.5)*SCALE));\n    grid += step(1.-GRID_SIZE, fract((pos.y-0.5)*SCALE));\n   \tgrid = min(grid, 1.);\n    if(grid == 1.)\n    {\n    \tcol = vec3(0.9);\n    }\n    if(cell <= 0)\n    {\n\t\tfloat shadow = march_shadow(uv*SCALE);\n    \tcol *= min(shadow+0.3, 1.);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float SCALE = .1;\nfloat SPEED = 4.;\nfloat GRID_SIZE = 0.15;\n\nint BORN[] = int[](3);\nint SURVIVE[] = int[](2,3);\n\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}", "buffer_b_code": "\nvec2 offsets[] = vec2[](\n    vec2(0, 1),\n    vec2(1, 0),\n    vec2(0, -1),\n    vec2(-1, 0),\n    vec2(1, 1),\n    vec2(-1, 1),\n    vec2(-1, -1),\n    vec2(1, -1));\n\n    \nint get_total(vec2 pos)\n{\n\tint tot = 0;\n    for(int i = 0; i < 8; i++)\n    {\n\t\ttot += min(int(texture(iChannel1, (pos+offsets[i])/iResolution.xy).x), 1);\n    }\n    return tot;\n}\n\nint get_new_state(int current, int total)\n{\n    int new = 0;\n    \n    if(current <= 0)\n    {\n\t\tfor(int i = 0; i < BORN.length(); i++)\n        {\n\t\t\tif(total == BORN[i])\n            {\n             \tnew = 1;   \n            }\n        }\n    }\n    else\n    {\n\t\tfor(int i = 0; i < SURVIVE.length(); i++)\n        {\n\t\t\tif(total == SURVIVE[i])\n            {\n             \tnew = current + 1;   \n            }\n        }\n    }\n\treturn new;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame < 5)\n    {\n\t\tfragColor = min(floor(vec4(rand2(floor(fragCoord))+0.2)), 1.);\n    }\n    else\n    {\n        if(mod(float(iFrame), SPEED) == 0.)\n        {\n\t\t\tfragColor = vec4(get_new_state(int(texture(iChannel1, uv)), get_total(fragCoord)));\n        }\n        else\n        {\n\t\t\tfragColor = texture(iChannel1, uv);\n        }\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 415], [417, 417, 474, 474, 1079]]}
{"id": "tstfz7", "name": "Aliasing / Point sampling", "author": "python273", "description": "---", "tags": ["aliasing"], "likes": 2, "viewed": 330, "published": 3, "date": "1604727721", "time_retrieved": "2024-07-30T20:36:31.016876", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n    coord *= iTime / 100.0;\n    float x = coord.x;\n    float y = coord.y;\n\n    float c = mod(x*x + y*y, 1.0);\n\n    fragColor = vec4(c, c, c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 265]]}
{"id": "tstBR7", "name": "Ray Marching Primitive Shapes", "author": "yonng", "description": "Refer to the great tutorial: https://www.youtube.com/watch?v=Ff0jJyyiVyw&pbjreload=101\n\nI organized the codes from the above tutorial and made a little extension.", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 286, "published": 3, "date": "1604723044", "time_retrieved": "2024-07-30T20:36:31.861617", "image_code": "\n\n//make sure avoid negative components -> obtain the distance\nfloat sdfBox(vec3 p, vec3 center,vec3 len )  //center of the box\n{\n     return length(max(abs(p-center)-len,0.));   //3 components of len are identical. For example, vec3(0.5)\n      \n}\n\n\n// cylidner with two cap, trick is to define the y component\n// to make caps, consider the interior points\nfloat sdfCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap) /dot(ab,ab);\n    \n    vec3 c = a+t*ab;\n    float x = length(p-c) - r;   // for the side part -> x\n    float y = (abs(t- 0.5) -0.5) * length (ab);\n    float e = length(max(vec2(x,y),0.));\n    \n    float i = min(max(x,y),0.);  //to make is a little smooth appearance\n    \n    return e+i;\n    \n}\n\n// torus on the xz plane\nfloat sdfTorus(vec3 p, vec3 center, vec2 r)   //r is for the two radiuses\n{\n     p -=center;  //remap the center from the (0,0,0)\n     float x = length(p.xz) - r.x;\n     return length(vec2(x, p.y)) - r.y;    //r.y is \n    \t\n}\n\nfloat sdfCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n      vec3 ab = b-a;\n      vec3 ap = p -a;\n      \n      float t = dot(ab, ap) / dot(ab, ab);   //use dot to find the segment index for the capsule\n      t = clamp (t,0., 1.);\n      \n      vec3 c = a+t*ab;\n      float d = length(p-c) - radius;\n      return d;\n}\n\n\nfloat sdfSphere(vec3 p, vec4 center)\n{\n      return length(p - center.xyz) - center.w;   //w is the radius   \n}\n\nfloat sdfScene(vec3 p)  // simple way calculate the distance using ray marching\n{\n     vec4 s = vec4(0,3,6,1);   //the last 1 is for radius, the first three are the coordinates of the circle\n     float spheresdf = sdfSphere(p,s);\n    \n     float capsulesdf = sdfCapsule(p,vec3(0,.3,6),vec3(0,2,6),.2);\n     \n     float planesdf = p.y;   //for the plane, plane's height is at 1 \n     float torussdf = sdfTorus(p,vec3(0,0.5,7), vec2(1.58,.2));\n     float boxsdf = sdfBox(p,vec3(-3,0.5,6),vec3(0.5));  //0.5 above the ground, and 6 depth\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,0.5,4.9),vec3(0.5)));\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,1.5,5.5),vec3(0.5)));\n    \n     float cysdf = sdfCylinder(p, vec3(2,.5,4),vec3(2,.5,6),.2);\n     cysdf =min(cysdf,sdfCylinder(p, vec3(2.5,.5,4),vec3(2.5,.5,6),.2));\n         \n     float d = min(capsulesdf, planesdf);\n     d = min(d,torussdf);\n     d = min(d, boxsdf);\n     d = min(d, cysdf);\n     return d;\n    \n}\n\n#define MAX_STEPS 100    \n#define MAX_DIST 100.   \n#define SURF_DIST .01\n\n//float and int\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat d0=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n       vec3 p = ro + rd*d0;\n       float ds = sdfScene(p);   \n       d0+=ds;\n       // to long or to small -> break\n       if(d0>MAX_DIST||ds<SURF_DIST) break;\n        \n    }\n    \n    return d0;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = sdfScene(p);\n    vec2 e = vec2(.001,0);  //delta e\n    vec3 n= d - vec3(sdfScene(p-e.xyy),\n                   sdfScene(p-e.yxy),\n                   sdfScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));  //light moves aro  und\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l)*0.5+0.5,0.,1.);\n    \n    //utilize the idea of shadowmap to generate the light\n    //if the distance can't reach the light then in shadow\n    float d = RayMarch(p+n*SURF_DIST*2.,l); //from the plane a little bit\n    if(d<length(lightPos - p)&& p.y<0.1) dif*=.2;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,3,0);\n    //-.2 make the camera looks down a little bit\n    vec3 rd= normalize(vec3(uv.x,uv.y-.4,1));  //rd equals every point on the screen\n    \n    float d = RayMarch(ro, rd);\n    //d /=6.;\n    vec3 p = ro+rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    //col = GetNormal(p);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 63, 129, 129, 247], [250, 357, 409, 409, 770], [772, 797, 872, 872, 1022], [1024, 1024, 1080, 1080, 1341], [1344, 1344, 1382, 1382, 1455], [1457, 1457, 1538, 1538, 2413], [2506, 2506, 2540, 2540, 2791], [2792, 2792, 2816, 2816, 3030], [3032, 3032, 3056, 3056, 3543], [3545, 3545, 3602, 3652, 4140]]}
{"id": "tsdfR7", "name": "Porous volcanic rock", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wstfR4]\"city flight\"[/url] animation.\nUse the  mouse to look around.", "tags": ["fractal", "terrain", "cave", "rock", "volcanic"], "likes": 6, "viewed": 362, "published": 3, "date": "1604717402", "time_retrieved": "2024-07-30T20:36:32.908817", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p /= 10.0;\n    p = sin(p/10.0)*5.0;\t\n    return sin((vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/5.0+vec3(.5);\n}\n\nvec3 sky_color(vec3 p)\n{\n    p *= 10.0;\n    return sin((vec3(sin(p.x/3.0),0.0,sin(p.z/7.0))));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-1,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color(sin(worldDir/2.0+iTime/4.0)),0);\n\t\treturn;\n    }\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t*(t>>12)|(t>>6)|t/4|t/1024);\n    //t = (t*(t>>(12+t>>12))|(t>>(6))|t/(4+t>>4)|t/(6+t>>6)|t/1024);\n    //t = (t>>(6+(t/(6))%6)|t/1024);\n\n    \n    \n    //t = t*(((t)>>(12))|(t>>(4))|t/(4)|t/1024);\n    //t = (t|(t>>(6+t/6))|t/(2+t/6>>4)|t/(6+t/6>>6)|t/1024);\n    //t = (t*(t>>(12+t>>12))|(t>>(6+t*12>>6))|t/(4+t*4>>4)|t/(6+t*6>>6)|t/1024);\n\n\n\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\n/*\nvec2 sound1(int t)\n{\n    int t1 = (t/12/1024)%2+(t/13/1024)%3;\n    t = (t*(t>>12|t>>13)|t>>(5+t1)|t/4|t/1024);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n*/\n\nvec2 mainSound( in int samp,float time){\n    time *= 5000.0;\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 2.0;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define image_scale 8.0\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n\tp = (sin(sin(p1+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= -scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n    \t//p += mod(sin(p/i),i);\n        float p1 = planet_surface(p*i,i)/(i);\n\t\tresult = max(result+p.y/abs(i*i) - p1, -p1);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p /= 10.0;\n    p = sin(p/10.0)*5.0;\t\n    return sin((vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/5.0+vec3(.5);\n}\n\nvec3 sky_color(vec3 p)\n{\n    p *= 10.0;\n    return sin((vec3(sin(p.x/3.0),0.0,sin(p.z/7.0))));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-1,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0)-1.0, cos(iTime*speed/10.0)*3.14), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec4 dmap = depth_map(fragCoord);\n    float l0 = length(eye-dmap.xyz); //distance to point in last frame\n    float l1 = dmap.w; //difference between points in consecutive frames\n    \n    float l2;\n    if(l1 >= 1.0){\n        //l2 = max(log(l0)/2.0,0.0);\n        l2 = 0.0;\n    }\n    else{\n        l2 = l0;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, min(0.0,(l0-dist)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 105, 237], [239, 239, 263, 263, 335], [337, 758, 849, 849, 1161], [1176, 1430, 1495, 1495, 1627], [1629, 1718, 1750, 1750, 1940], [1942, 2434, 2574, 2574, 3184], [3186, 3556, 3641, 3641, 4056], [4058, 4385, 4434, 4469, 4600], [4602, 4602, 4629, 4629, 4778], [4780, 4780, 4837, 4837, 5804]]}
{"id": "wsdBR7", "name": "spectral_zucconi6 gradient study", "author": "morisil", "description": "Check out: https://www.shadertoy.com/view/ls2Bz1\n", "tags": ["color", "gradient", "spectral", "zucconi"], "likes": 2, "viewed": 314, "published": 3, "date": "1604713137", "time_retrieved": "2024-07-30T20:36:33.669783", "image_code": "// Fork of \"spectral_zucconi6 color study\" by morisil. https://shadertoy.com/view/tddBR7\n// 2020-11-07 01:33:41\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 color = mix(\n        spectral_zucconi6(mod(iTime * .055, 1.)),\n        spectral_zucconi6(mod(- iTime * .07, 1.)),\n        uv.y\n    );\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 168, 168, 385]]}
{"id": "tddBR7", "name": "spectral_zucconi6 color study", "author": "morisil", "description": "Check out: https://www.shadertoy.com/view/ls2Bz1\n", "tags": ["color", "spectral", "zucconi"], "likes": 5, "viewed": 371, "published": 3, "date": "1604711279", "time_retrieved": "2024-07-30T20:36:34.514524", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 color = mix(\n        spectral_zucconi6(mod(uv.x - iTime * .04, 1.)),\n        spectral_zucconi6(1. - mod(uv.x + iTime * .15, 1.)),\n        uv.y\n    );\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 288]]}
{"id": "wddfzM", "name": "diwali on the styx", "author": "gurumatcha", "description": "Study of river hydrology using iq's domain warping technique. Mouse stills the current.", "tags": ["warp"], "likes": 5, "viewed": 570, "published": 3, "date": "1604706553", "time_retrieved": "2024-07-30T20:36:35.298428", "image_code": "    // book of shaders random from fbm chapter\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n    }\n    // Quilez's 2D simplex noise https://www.shadertoy.com/view/Msf3WH\n    // originally had issue with tiling, but Mike Bostock's sketch and the book of shaders chapter on noise helped me figure it out\n    // https://observablehq.com/@mbostock/domain-warping\n    vec2 hash( vec2 p ) // replace this by something better\n    {\n        p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    float noise( in vec2 p )\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2  i = floor( p + (p.x+p.y)*K1 );\n        vec2  a = p - i + (i.x+i.y)*K2;\n        float m = step(a.y,a.x);\n        vec2  o = vec2(m,1.0-m);\n        vec2  b = a - o + K2;\n        vec2  c = a - 1.0 + 2.0*K2;\n        vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot( n, vec3(70.0) );\n    }\n        #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st);\n            st *= 2.;\n            amplitude *= .5;\n        }\n        return value;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \tfloat aspect = iResolution.x/iResolution.y;\n        st.x *= iResolution.x/iResolution.y;\n        vec3 color = vec3(0.0);\n        // determines size\n        vec2 p = st*3.;\n        // river flow strength\n        \n    \n    \tvec2 m = iMouse.xy/iResolution.xy;\n        m.x *= aspect;\n        float turbulence = smoothstep(0.,.2,distance(m,st));\n    \tp.x += iTime * 0.01 * turbulence;\n    \n        // quilez does fbm( p + fbm(p)) notated as fbm(q+r), I expand the r to be r = fbm(p + s)\n        // I add terms to modify q,r,s\n        // these are nested functions so the order magnitude needs to be different\n        // t2 modulates the rivers velocity, here it's slightly against the river flow strength, almost 0\n        // originally t values had an additional trig term, but alas performance\n\n        // undercurrent relative velocity\n        float t1 = iTime * -0.05;\n        // river relative velocity\n        float t2 = iTime * 0.01;\n        // pollution relative velocity\n        float t3 = iTime * 0.1;\n        vec2 q = p + t1;\n        float s = fbm(p + t3);\n        float r = fbm(p + t2 + s)* turbulence;\n        // so this is where is ressembles the canonical quilez technique\n        color += fbm(q + r);\n        // bump up brightness a smidgen\n        color += 0.15;\n        color.r +=  s + 0.05;\n        // note that r here isn't red, it's river as modulated by undercurrent\n        color.b += r + 0.3;\n        // pollution as opposite of undercurrent color (couldnt use q without more operations)\n        color.g += s/2.5;\n        fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 51, 78, 78, 176], [181, 441, 502, 502, 635], [640, 640, 670, 670, 1205], [1236, 1236, 1260, 1286, 1588], [1590, 1590, 1647, 1647, 3267]]}
{"id": "wdtfzM", "name": "Binaryual starry", "author": "UrbanClubProfessional", "description": "Remix of \"Binary star\" by Duke.\n\"Press 1-2-3 to zoom in and zoom out.\" - Duke", "tags": ["binary", "sun", "star", "space", "remix", "glitch", "blackhole", "weird", "physics", "singularity"], "likes": 1, "viewed": 403, "published": 3, "date": "1604704192", "time_retrieved": "2024-07-30T20:36:36.060391", "image_code": "// \"Binary star\"\n// I have long wanted to do something like that. \n// Raymarcher based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define DITHERING\n\n#define pi 4.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float KEY_1 = 59.5/356.0;\nconst float KEY_2 = 60.5/356.0;\nconst float KEY_3 = 61.5/356.0;\n\nconst float spin_speed=0.8;\nmat2 Spin(float angle){\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n//-------------------------Noise--------------------------\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(4.0-3.0*p);\n    vec2 uv = (ip.xy+vec2(47.0,27.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.6)/356.0, -200.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.07125)*.67 + pn(p*.225)*.38 + pn(p*.35)*.35;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.223,vec2(22.9898,88.233))) * 53758.5453);\n}\n\n//-------------------------Disk---------------------------\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 2.0/9.0 );\n}\n\nfloat Disk( vec3 p, vec3 t )\n{\n    R(p.yz, -0.35*pi*3.);\n    vec2 q = vec2(length2(p.xz)-t.x,p.y*0.6);\n    return max(length8(q)-t.y, abs(p.y) - t.z);\n}\n\n//-------------------------Star---------------------------\n// adaptation of \"Pyroclastic sun\" https://www.shadertoy.com/view/XtlXR2\n// Noise Settings\n#define NoiseSteps 5\n#define NoiseAmplitude 0.09\n#define NoiseFrequency 58.0\n  \nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n    float value = 0.0;\n    float cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n    float fade;\n    float fOut = minFreq;\n    for(int i=NoiseSteps ; i>=0 ; i--)\n    {\n      if(fOut >= 0.6 * cutoff) break;\n      fOut *= 3.0;\n      value += abs(pn(position * fOut))/fOut;\n    }\n    fade = clamp(3.0 * (cutoff-fOut)/cutoff, 0.0, 2.0);\n    value += fade * abs(fpn(position * fOut))/fOut;\n    return 2.0-value;\n}\n\nfloat SphereDist(vec3 position, vec3 rposition, float radius)\n{\n    return length(position - rposition) - radius;\n}\n\nfloat Star(vec3 position, vec3 rotdir, vec3 rposition, float radius)\n{\n    float distance;\n    float t=spin_speed*iTime;\n    float noise = Turbulence(vec3(Spin(t*0.35+rotdir.y*.91)*rotdir.zx*60.,rotdir.y*60.+t), 0.2, 2.5, 0.04) * NoiseAmplitude;\n    noise = clamp((abs(noise)),0.0,2.0);\n    distance = SphereDist(position, rposition, radius) - noise;\n    return distance;//noise;\n}\n\n//-------------------------Vortex-------------------------\n// this part from \"Tornado 1\" https://www.shadertoy.com/view/4tSSDK\nfloat ridged(float f){\n\treturn 2.0-3.0*abs(f);\n}\n\nfloat Vortex(vec3 q) // the isosurface shape function, the surface is at o(q)=0\n{\n    q.y += -200.;\n    q.x += 55.;\n    float h = 90.0;\n\tfloat t=spin_speed*iTime;\n    //q.z=abs(q.z);\n\tif(q.y<0.0) return length(q)-6.75;\n    vec3 spin_pos=vec3(Spin(t-sqrt(q.y))*q.xz,q.y-t*6.0);\n\tfloat zcurve=pow(q.y,2.5)*0.04;\n\tfloat v=abs(length(q.xz)-zcurve)-6.5-clamp(zcurve*0.3,0.2,2.0)*pn(spin_pos*vec3(0.2,0.2,0.2))*6.0;\n\t//v=v-ridged(pn(vec3(Spin(t*1.5+0.1*q.y)*q.xz,q.y-t*4.0)*0.3))*1.2;\n\treturn max(v, q.y - h);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.6 + 0.6*(b-a)/k, 0.0, 2.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//-------------------------Map----------------------------\nfloat map(vec3 p) {\n    \n    float t=spin_speed*iTime;\n    \n    R(p.xy, pi*iTime*0.03);\n    \n    float d1 = Star(p,p,vec3(-2.0,7.5,0.0),3.5);\n    float d2 = Vortex(p/0.03)*0.03;\n    float d3 = Disk(p,vec3(2.0,1.08,0.422)) + fpn(vec3(Spin(t*0.225+p.z*.90)*p.xy*90.,p.z*50.-t)*7.0) * 0.645;\n    float d4 = Star(p,p.yzx,vec3(0.0,0.0,0.0),0.06)*.9;\n\n    return smin(smin(d2,smin(d3,d4,0.95),2.0),d1,2.5);\n\n}\n\n//-------------------------Color---------------------------\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 2500. + 2400.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(8.4, 6.6, 5.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(6.0)) * (exp(2.43876719683e5/(T*L))-2.0);\n    return 1.0-exp(-6e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n//-------------------------Main---------------------------\n// main part from \"Fiery Spikeball\" https://www.shadertoy.com/view/4lBXzy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   float key = 0.0;\n    key += 0.8*texture(iChannel1, vec2(KEY_1,0.35)).x;\n    key += 0.8*texture(iChannel1, vec2(KEY_2,0.35)).x;\n    key += 0.8*texture(iChannel1, vec2(KEY_3,0.35)).x;\n   \n    // p: position on the ray\n    // rd: direction of the ray\n    vec3 rd = normalize(vec3((gl_FragCoord.xy-0.6*iResolution.xy)/iResolution.y, 0.75));\n   \n    vec3 ro = vec3(0., 0., -21.+key*4.8);\n    \n    R(rd.yz, -iMouse.y*0.02*pi*3.);\n    R(rd.xz, iMouse.x*0.02*pi*3.);\n    R(ro.yz, -iMouse.y*0.02*pi*3.);\n    R(ro.xz, iMouse.x*0.02*pi*3.);\n    \n    // mouse control zoom \n    //vec3 ro = vec3(0., 0., -11.0 + iMouse.y * 0.038);\n    //R(rd.yz, -0.0*0.01*pi*2.);\n\t//R(rd.xz, iMouse.x*0.01*pi*2.);\n    //R(ro.yz, -0.0*0.01*pi*2.);\n\t//R(ro.xz, iMouse.x*0.01*pi*2.);\n    \n    // ld, td: local, total density \n    // w: weighting factor\n    float ld=0., td=0., w;\n\n    // t: length of the ray\n    // d: distance function\n    float d=2., t=0.;\n   \n    // Distance threshold.\n    const float h = 0.2;\n   \n    // total color\n    vec3 tc = vec3(0.);\n   \n    #ifdef DITHERING\n    vec2 pos = ( fragCoord.xy / iResolution.xy );\n    vec2 seed = pos + fract(iTime);\n    //t=(1.+0.2*rand(seed*vec2(1)));\n    #endif\n\t\n    // rm loop\n    for (int i=0; i<58; i++) {\n\n      // Loop break conditions. \n      if(td>(2.-2./300.) || d<0.002*t || t>32.) break;\n\n      // evaluate distance function\n      d = map(ro+t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      // const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (2. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 2./60.;  // Different weight distribution.\n      td += w + 2./300.;\n       \n\t  #ifdef DITHERING \n      d=abs(d)*(.9+0.38*rand(seed*vec2(i)));\n      #endif \n       \n      // enforce minimum stepsize\n      d = max(d, 0.05); \n      \n      // step forward\n      t += d*0.6;\n   \n    }\n\n    // Fire palette.\n    tc = firePalette(tc.x);\n\n    // stars background\n    if (ld<=0.002) {\n   \t  vec3 stars = vec3(pn(rd*400.0)*0.6+0.6);\n      vec3 col = vec3(0.0);\n      col = mix(col, vec3(0.9,1.0,2.0), smoothstep(1.05, 0.2, stars)*clamp(dot(vec3(0.0),rd)+0.85,0.0,2.0));\n      col = clamp(col, 0.0, 2.0);\n      tc += col; \n    }\n\n    fragColor = vec4(tc, 2.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[439, 439, 462, 462, 524], [526, 599, 622, 622, 835], [837, 844, 863, 863, 927], [929, 929, 949, 1020, 1091], [1153, 1153, 1178, 1178, 1215], [1217, 1217, 1242, 1242, 1307], [1309, 1309, 1339, 1339, 1461], [1693, 1693, 1770, 1770, 2173], [2175, 2175, 2238, 2238, 2290], [2292, 2292, 2362, 2362, 2673], [2675, 2802, 2824, 2824, 2850], [2852, 2852, 2933, 2933, 3357], [3359, 3359, 3400, 3400, 3489], [3491, 3550, 3569, 3569, 3953], [3955, 4085, 4111, 4111, 4435], [4437, 4570, 4627, 4627, 6935]]}
{"id": "3stBz7", "name": "Costas7 70.468.464.254.443.709^2", "author": "ollj", "description": "Mouse.xy blends waveleng-mixing\nCostas-Array is most equi-distributed non-0 derivatives(is pattern-free)\n\nparents:\n-[url=https://www.shadertoy.com/view/llKyWc]fft canvas[/url]\n-[url=https://www.shadertoy.com/view/Ws3BzH]Costas to weight-noise[/url] ", "tags": ["noise", "fft", "gradient", "dither", "poisson", "fourier", "distribution", "dft", "dft", "laplachian", "galois", "costasarray", "patternfree", "pqfm", "unniquedt"], "likes": 6, "viewed": 558, "published": 3, "date": "1604685014", "time_retrieved": "2024-07-30T20:36:37.022818", "image_code": "//all costasArray Code is in the commonTab.\n//Image+buffA+buffb are EXCLUSIVELY the 2d-FFT signal-instepctor.\n\n\n/*\n\nMouse.x blends etween 2 different weighting-sets\nsmall mouse.x emphasize shorter wavelengths (blueer noise) == smaller costas arrays\nlarge mouse.x emphasize longer  wavelengths (blueer noise) == larger  costas arrays\n\n(note, that i chose the shorter costas arrays poorly, resulting in diabonal bamnding, this is easily fixed)\n\n\n//self   :   https://www.shadertoy.com/view/3stBz7   Costas7\n//parent0:   https://www.shadertoy.com/view/Ws3BzH   Costas6\n//parentC:   https://www.shadertoy.com/view/llKyWc   Fourier Analysis Canvas\n//parent1:   https://www.shadertoy.com/view/tstBRr   Costas5 ?\n//parent2:   https://www.shadertoy.com/view/Wsdfzr   Costas4 ?\n//parent3:   https://www.shadertoy.com/view/tdjfzR   Costas3 ?\n\nCostas7 only differs in Costas6 in having larger costasArrays in it\nand no (diagonal mirror) symmetric ones.\nthis should fix some issues.\nbut sorting the bad from the good (in larger arrays) takes a while.\nits lists of 1000 of lines.\nand this one has the best 4 of those costasArray lines of many.\nin sizes  (239..281) (known costas arrays of prime number size only)\n\nthis uses 2 iterations (quasi recursive) costas lookups\n, to shuffle a linear offset band into a decently \"noisy\" 2d testure\nbased on a single costas array\n\nWe use 4 layers of tiles, of prime number size, to get a large LCM==LeastCommonMultiple permuted period.\n\n------- todo, implement function that takes seesaw and outputs triangleWave.\n\nby using costas arrays of the prime number sizes:\n239,241,269,281, that define 4 overlapping modulo tiles, that share no coprimes,\nwe get a permuted tile size==period of \n 239*241*269*281 \n=70.468.464.254.443.709\nthat needs 60 bits to store as unsigned int\nand thats its period over 3 domains (x,y,time)\n\nhaving 4 long costas arrays in a per pixel coded buffer is slow\nthis would be faster in a TEXTURE \nor BufferC, but then its limited to 768 pixels of preview space (or less when zoomed)\n\n\n\ni suspected, that the FFT of this would\n- look circular\n- approach something, that looks like its source (being its own semi-FFT) (as a costas arrayrepeats no differentials)\n- have NO case of a differential of 0, anywhere (therefore a STRONG SLIM black cross in the FFT exists)\n\n\n/**/\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.525,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        //;amp=amp+1./3.\n        //;if(amp>1.)amp-=1.\n        //;col=rainbow(amp)\n        \n            ;col=mix(vec3(amp),blackbodyLike(amp*2.-.5),vec3(.2));\n        \n        //col = vec3(amp);\n    ;}\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        \n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//set to  iResolution.x/2.\n//#define lazyGradient 350.\n\n//smaller number for faster palette-animation\n//a gre3yscale pallete, the size of each period\n//, cycle-animates every Nth frame\n// 1 => 1-palette-loop-steps per  1 frame\n// 2 => 1-palette-loop-steps per  2 frames\n//30 => 1-palette-loop-steps per 30 frames\n#define FramesPerPaletteAnimation 1\n\n\n//if(mouse is up) simulate a mouse on autopilot, that moves around at this speed.\n//values larger than 0 will automatically explore different period-blends\n#define AutopilotSpeed 0.\n\n//this uses 7 costas arrays of prime-sizes\n// 241,239,281,269,19,17,13  (the LCM is 1.8e+13 decimals long)\n// 4 large and 3 small prime are a pretty BAD mix here, lacks in-betweens\n//choise made in favor of having \n//, short periods for bluer-noise AND larger primes for longer periods\n//, and do contrast between long and hsort periods more\n\n//a simple lesosn here is;\n//the smallest-used-primes must be further away\n//from each other than minimally possible, or you just amplify emergent-patterns (small coprimes are noticably too small)\n\n\n#define v0 float\n#define v2 vec3 \n#define pi acos(-1.)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.) \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n\nvec3 blackbodyLike(float T){\n ;vec3 c=rainbow(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n //;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n ;return c;\n}\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n//end of signal inspector (global parameters)\n//\n//start of costas array:\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 7\n\n\n/*  //simpler idea outdated\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/      \n\n//gpo() returns sizes of used tiles (of costas arrays in them) by index a.\n//this is also a list of used frequencies in terms of how blue your noise is.\n//values share no prime factors to maximize the permuted period\nint gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs (alternative arrays)\n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4 good\n/**/\n;}}}\n\n\n//cs() does 2 iterations over getCostasOf()\n//a 1d costas array (==list) is usually shown as square of binary tiles.\n//but i need a 2d heightmap and not a 1d heightmap.\n//but a 2d costasArray (for a 2d heightmap) is useless here\n//(because it has elements that are NaN (==mod(a,0) )\n//because 3d costas arrays are MUCH trickier to calculate (and usually kept secret)\n//we instead do 2 iterations over a 1d costasArray, to get a PSEUDO-2d-costasArray\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //integer modulo (tile to positive infinity)\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/FramesPerPaletteAnimation)%(per); //iFrame for color-paletter-cycling\n ;return r;}\n\n\n//biased mixing of multiple modulo tiles (that are set by Cs(parameter) )\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n ;float r=0.;\n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=float[7](1.,2.,4.,8.,16.,32.,64.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=float[7](64.,32.,16.,8.,4.,2.,1.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<7;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);//mix blue and yellow over mouse.x\n }    \n;for(int i=0;i<7;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat==grainier over m.y\n      //flatter is worse for longer periods\n      //flatter looks better for longer periods\n      //flatter hides the repetive-tiling of short periods more.\n      //flatter looks smoother, while still having local peaks.\n      //flatter looks more repetitive, the longer the mixed periods are.\n\n }\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n    \n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n #ifdef lazyGradient\n ;a-=float(u.x)/lazyGradient\n #endif\n;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*AutopilotSpeed)*.5+.5;}//autopilot-mouse\n ;//u*=2.2\n ;u/=2.5 //hacky zoom to nicely match the 2d FourierTransform\n //;float g=(sqrt(5.)*.5+.5)\n //;float speed=.00003 //to move uv-.xy  of noise move noise over time\n //;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //while its color palette cycles.\n ;ivec2 scroll=ivec2(0); //to move uv-.xy  of noise move noise over time\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}", "buffer_a_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n        \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime,iMouse/iResolution.xyxy));\n\n    //;col=mix(vec3(col),blackbodyLike(col.x*2.5),vec3(.3));\n    //col=rainbow(col.x);\n    \n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "3dtBR7", "name": "Round painting effect", "author": "ophiase", "description": "An attemp to reproduce this kind of visual :\nhttps://twitter.com/VisuallySt/status/1314514705222955008/photo/1", "tags": ["effectuv"], "likes": 9, "viewed": 575, "published": 3, "date": "1604683915", "time_retrieved": "2024-07-30T20:36:37.794754", "image_code": "#define PI 3.14159265359\n\n\n//////////////////////////////\n/// RANDOM FUNCTIONS\nconst uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fractNoise( in vec2 uv )\n{\n    float f = 0.0;\n    \n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    \n    return f;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/////////////////////////////////\n// EFFECT\n\nfloat getAngle(vec2 v)\n{\n    float angle = acos(v.x);\n    if (v.y < 0.0) return -angle;\n\treturn angle;\n}\n\nfloat d_angle(float a, float b)\n{\n    float d1 = abs( mod(a + PI, 2.0 * PI) - mod(b + PI, 2.0 * PI) );\n    float d2 = abs( a - b );\n    return min(d1,d2);\n}\n\nvec2 effect (vec2 uv, vec2 center)\n{\n    vec2 relPos = uv - center;\n    \n    float a  = 700.0;\n    int   b  = 15;\n    float c  = 0.07;\n    \n    float module  = length(relPos);// * (1. + (fractNoise((vec2(334.,15.) + relPos)*10.)*.005) );\n    \n    float angle   = getAngle(relPos/module);\n    \n    module += (fractNoise((vec2(334.,15.) + relPos)*50.)*.002);\n    module = float(floor(module*a)/a);\n    module += (noise((vec2(3324.,125.) + relPos)*30.)*.0000001);\n    \n    ////////////////////////////////////\n    float seed = rand(vec2(module) + center);\n    \n    int nExt = int(floor(seed * 20.0 * module))*b;\n    \n    float nearExtPos = rand( vec2(seed*100.,-1.*20.) ) * 2. * PI;\n    for (int i = 0; i < nExt; i++)\n    {\n        float currentExtPos = rand( vec2(seed*100.,float(i)*20.) ) * 2.*PI;\n        if (d_angle(currentExtPos, angle) < d_angle(nearExtPos, angle))\n        \tnearExtPos = currentExtPos;\n    }\n    \n    //////\n    \n    float curSize = rand( vec2(nearExtPos*293.) ) * c / module;\n    if (d_angle(nearExtPos, angle)  < curSize) \n        angle = nearExtPos;\n    \n         \n    ///////////////////////////////\n    \n    angle = mod(angle, 2.*PI);\n         \n    return center + (module * vec2(cos(angle), sin(angle)));\n}\n\n\n////////////////////////\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 center = vec2(iMouse)/vec2(iResolution.x);\n    center.y *= 1.0;\n    \n    // PROCESS\n    uv = effect(uv, center);\n    \n    // OUTPUT\n    \n    //vec3 col = vec3(uv, 0.);\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 228, 248, 248, 352], [354, 354, 380, 380, 674], [676, 676, 708, 708, 960], [962, 962, 982, 982, 1054], [1101, 1101, 1125, 1125, 1205], [1207, 1207, 1240, 1240, 1363], [1365, 1365, 1401, 1401, 2597], [2634, 2634, 2691, 2741, 3034]]}
{"id": "3ddfR7", "name": "Plane Ray Tracing", "author": "henrmota", "description": "Tracing a plane, very new to this, so feel free to comment for improvements.", "tags": ["raytracing"], "likes": 0, "viewed": 310, "published": 3, "date": "1604682313", "time_retrieved": "2024-07-30T20:36:38.624535", "image_code": "#define MAX_STEPS 100.\n\nfloat remap01(float a, float b, float value) {\n\treturn (value - a)/(b - a);    \n}\n\nvec3 walkInRd(vec3 ro, vec3 rd, float t) { \n\treturn ro + rd * t;    \n}\n\nfloat sphereDist(vec3 ro, vec3 rd, vec3 s) {\n\tvec3 ros = s-ro;\n    float scalar = dot(rd, ros);\n    vec3 p = walkInRd(ro, rd, scalar);\n    \n    return length(s-p) - 0.1; \n}\n\n// (k-p).n = 0 <> n.k = n.p <> n.(ro + rd*t) = n.p <> n.rd*t = n.p - n.ro <> t = (n.p - n.ro) / n.rd;\nfloat planeDist(vec3 ro, vec3 rd, vec3 planePoint, vec3 normal) {\n    planePoint = planePoint-ro;\n    normal = normalize(normal);\n    \n    float t = (dot(planePoint, normal)-dot(ro, normal)) / dot(rd, normal);\n    \n    return t < 0. ? MAX_STEPS + 1. : t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0. , 0., 0.);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    \n \tfloat d = planeDist(ro, rd, vec3(0, -1.,0), vec3(cos(iTime), 1., 0.));\n    col += step(remap01(0., MAX_STEPS, d), 1.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 70, 70, 105], [107, 107, 149, 149, 177], [179, 179, 223, 223, 351], [353, 455, 520, 520, 711], [713, 713, 770, 770, 1091]]}
{"id": "WstBR7", "name": "starfield 2", "author": "FabriceNeyret2", "description": "mouse control\n\nuse texture RGB as local coordinate of sphere in each voxel.\nNB: I should either visit neighbor voxels or avoid voxel margin to not have truncated spheres.\nUncomment last for colors ( + del prev ; )", "tags": ["raymarching", "volume", "starfield", "short"], "likes": 13, "viewed": 610, "published": 3, "date": "1604679060", "time_retrieved": "2024-07-30T20:36:39.486231", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                           // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float d;\n    vec3  R = iResolution, \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),                       // ray direction\n          p = 2./R, C; \n    O-=O;\n    p.xy *= rot( .5+6.*M.y), D.xy *= rot( .5+6.*M.y);                      // camera move \n    p.xz *= rot( 2.-6.*M.x), D.xz *= rot( 2.-6.*M.x);\n    p.xy += cos( iTime + vec2(0,11)) - iTime;\n    \n    for ( float i=0.; i < 50.; i++,  p += D ) {                            // volume ray-casting\n        vec4 T = texture( iChannel0, p/32. );\n        C = fract(p) - T.rgb ;                                             // distance to sphere in voxel\n        d = -dot(C,D);       // distance ray-sphere: d/dl ( || P+l.D - C || )  = 2l + 2 (CP.D)\n        if (i>0. || d > 0.)\n            C += d*D,        // point on the ray that is closest to sphere\n        //  O += 3e-4 / dot(C,C)                                           // addition variant\n            O += (1.-O)* clamp(1.- 1e3* dot(C,C), 0.,1. )                  // blend\n                       * exp2(-.05*i);                                     // fog\n                    // * ( .6 + .6 * cos( 6.3*T.w  + vec4(0,23,21,0)  ) ); // color version\n    }\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 1409]]}
{"id": "WdtBR7", "name": "HypnoSpiral", "author": "Windless", "description": "forget all those 10.000 LoC shaders. Do shaders that FitsInATweet \\o/\n\nHypnoSpiral, because there isn't enough spiral-themed shaders.", "tags": ["fitsinatweet"], "likes": 2, "viewed": 338, "published": 3, "date": "1604677693", "time_retrieved": "2024-07-30T20:36:40.360893", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 uv=fragCoord/iResolution.xy-0.5;uv.x*=16./9.;\nfloat a=atan(uv.x,uv.y)*6.+cos(iTime)/1.5;float l=length(uv)*25.-1.5*iTime;\nfloat b=pow(1.+cos(l+a),100.);float c=pow(1.+cos(l-a),100.);\nfragColor=vec4(1.-min(b,c),b,c,1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 279]]}
{"id": "3ddfzM", "name": "rgb=hex(x^2+y^2)", "author": "python273", "description": "Source: https://habr.com/ru/post/526776/", "tags": ["weird"], "likes": 6, "viewed": 687, "published": 3, "date": "1604676612", "time_retrieved": "2024-07-30T20:36:41.211618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n    // coord *= iTime / 10.0;\n    int x = int(coord.x);\n    int y = int(coord.y);\n\n    int a = x*x + y*y;\n\n    // WARNING: flashing\n    // a += int(iTime * 1000.0);\n    // a -= int(iTime * 1000.0);\n\n    // emulating JS: a.toString(16) + \"0\".repeat(6 - a.toString(16).length)\n    if (a < 0x100000) a = a << 4;\n    if (a < 0x100000) a = a << 4;\n    if (a < 0x100000) a = a << 4;\n    if (a < 0x100000) a = a << 4;\n    if (a < 0x100000) a = a << 4;\n\n    fragColor = vec4(\n        float((a >> 16) & 255) / 255.0,\n        float((a >>  8) & 255) / 255.0,\n        float((a >>  0) & 255) / 255.0,\n        1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 725]]}
{"id": "WdtBzM", "name": "RGB blue noise dithering", "author": "koiava", "description": "tiny example showing blue noise dithering for RGB input :)", "tags": ["dither", "bluenoise"], "likes": 7, "viewed": 605, "published": 3, "date": "1604669579", "time_retrieved": "2024-07-30T20:36:41.992530", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 img = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n    vec2 bn_res = iChannelResolution[0].xy;\n    vec4 bn = texture( iChannel0, mod(fragCoord, bn_res) / bn_res);\n    bn = pow(bn, vec4(0.45)); // gamma\n    fragColor = vec4(step(bn.xyz, img),1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 320]]}
{"id": "td3fz7", "name": "neon_heart", "author": "skerys", "description": "First experiment of using raymarching to create something pleasant looking.\nWildly unoptimized :)", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 377, "published": 3, "date": "1604666942", "time_retrieved": "2024-07-30T20:36:42.754493", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 10000.0\n#define SURFACE_DISTANCE 0.01\n#define EPSILON 0.01\n\nconst float PI = 3.14159265359;\nconst float deg2rad = 0.0174532925;\n\nmat2 rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotatePointUnityEuler(vec3 p, float x, float y, float z){\n\tp.xz *= rot(deg2rad * y);\n    p.zy *= rot(deg2rad * x);    \n    p.yx *= rot(deg2rad * z);\n    \n    return p;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sin01(float a)\n{\n    float b = sin(a*5.0) / 2.0 + 0.5;\n    return b*b;\n}\n\nfloat sin02(float a)\n{\n    float b = sin(a) / 2.0 + 0.5;\n    return b*b*b*b*b*b*b;\n}\n\nfloat sin03(float a)\n{\n    return sin(a) / 2.0 + 0.5;\n}\n\n\nfloat displacement(vec3 p)\n{\n    return sin(5.0 * p.x + 4.0*iTime)*sin(5.0 * p.y + 4.0*iTime)*sin(5.0 * p.z + 4.0*iTime);\n}\n\nfloat distanceToScene(vec3 p)\n{\n    //Main sphere\n    vec4 mainSphere = vec4(0.07*sin01(iTime), -0.07*sin01(iTime), 0, 0.5 + 0.075*sin01(iTime));\n    float shape1 = sdSphere(p - mainSphere.xyz, mainSphere.w);\n    \n    //vec3 cylinderRightPos = vec3(0);\n    vec3 cylinderRightPos = vec3(0.227, 0.432, 0.099);\n    float cylinderRightRadius = 0.1 - 0.015 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float cylinderRightHeight = 0.5;\n    \n    vec3 bp = p - cylinderRightPos;    \n    bp = rotatePointUnityEuler(bp, 58.423, 2.507, -22.109);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderRightRadius,0.1, cylinderRightHeight), 0.25);\n    \n    vec3 cylinderSmallPos = vec3(-0.1, 0.831, 0.568);\n    float cylinderSmallRadius = 0.075 - 0.01 * sin02((iTime + PI/4.0 - 0.1)*5.0);\n    float cylinderSmallHeight = 0.555;\n    \n    bp = p - cylinderSmallPos;\n    bp = rotatePointUnityEuler(bp, 65.568, -113.973, -41.671);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderSmallRadius,0.1, cylinderSmallHeight), 0.1);\n    \n    vec3 smallSpherePos = vec3(0.25 + 0.075*sin01(iTime - .03), -0.35 - 0.075*sin01(iTime - .03), -0.177 -  0.075*sin01(iTime - .03));\n    \n    bp = p - smallSpherePos;\n    bp = rotatePointUnityEuler(bp, -47.688, 23.452, 43.371);\n    \n    shape1 = smin(shape1, sdSphere(bp, 0.2  + 0.1*sin01(iTime - .03)), 0.3);\n    \n    vec3 anglePos = vec3(-0.108, 0.206, 0.137);\n    vec3 anglePos2 = vec3(0.218, 0.186, 0.259);\n    \n    bp = p - anglePos;\n    bp = rotatePointUnityEuler(bp, 10.428, 6.331, 42.379);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    bp = p - anglePos2;\n    bp = rotatePointUnityEuler(bp, -41.338, -20.374, -74.936);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    vec3 torusPos = vec3(0.228, 0.706, 0.503);\n    vec2 torusRadii = vec2(0.38, 0.18);\n    \n    bp = p - torusPos;\n    bp = rotatePointUnityEuler(bp, 22.816, 25.841, -106.461);\n    bp.y *= 1.0 - 0.05 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n    bp.z *= 1.0 + 0.1 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n        \n    float shape2 = sdTorus(bp, torusRadii);\n    \n    vec3 valveAPos = vec3(0.22, 1.024, 0.343);\n    vec3 valveBPos = vec3(0.317, 1.041, 0.478);\n    vec3 valveCPos = vec3(0.386, 0.991, 0.636);\n        \n    float valveRadius = 0.05;\n    float valveHeight = 0.4;\n    \n    bp = p - valveAPos;\n    bp = rotatePointUnityEuler(bp, -25.892, 30.911, -21.724);\n    \n    shape2 = smin(shape2, max(abs(sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight)) - 0.01, bp.y - 0.3), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, -6.346, 25.177, -22.851);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, 16.24, 18.123, -27.795);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    vec3 cylinderLeftPos = vec3(-0.255 + 0.03 * sin02((iTime + PI/4.0 - 0.2)*5.0), 0.075, 0.273);\n    float cylinderLeftRadius = 0.075;\n    float cylinderLeftHeight = 0.8;\n    bp = p - cylinderLeftPos;\n    \n    float k = 0.05 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float c = cos(k*bp.y);\n    float s = sin(k*bp.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    float shape3 = sdRoundedCylinder(bp, cylinderLeftRadius, 0.0, cylinderLeftHeight);\n    \n    vec3 cylinderLeftSmall1Pos = vec3(-0.308 -0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.085, 0.273);\n    float cylinderLeftSmall1Radius = 0.075;\n    float cylinderLeftSmall1Height = 0.25;\n    \n    bp = p - cylinderLeftSmall1Pos;\n    \n    k = -0.3 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    c = cos(k*bp.y);\n    s = sin(k*bp.y);\n    m = mat2(c, -s, s, c);\n    q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    bp = rotatePointUnityEuler(bp, 0.0, 0.0, 13.068);\n    \n    shape3 = min(shape3, sdRoundedCylinder(bp, cylinderLeftSmall1Radius,0.0, cylinderLeftSmall1Height));\n    \n    vec3 cylinderLeftSmall2Pos = vec3(-0.188-0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.157, 0.257);\n    float cylinderLeftSmall2Radius = 0.075;\n    float cylinderLeftSmall2Height = 0.2;\n    \n    bp = p - cylinderLeftSmall2Pos;\n    bp = rotatePointUnityEuler(bp, -25.213, 22.086, -51.354);\n    \n    shape3 = smin(shape3, max(abs(sdRoundedCylinder(bp, cylinderLeftSmall2Radius,0.0, cylinderLeftSmall2Height)) - 0.02, bp.y - 0.14), 0.01);\n    \n    float dist = min(shape1, shape2);\n    dist = min(dist, shape3);\n    \n    dist += displacement(p) * 0.01;\n    \n    return dist;\n    \n}\n\nconst float NOISE_GRANULARITY = 255.0/255.0;\nfloat random(vec2 coords) {\n\treturn fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)\n{\n    float d = 0.0;\n    float iter = 0.0;\n    for(int i = 0; i < MAX_STEPS && d < MAX_DISTANCE; i++)\n    {\n        iter += 1.0;\n        vec3 p = ro + rd * d;\n        float dist = distanceToScene(p);\n        d += 0.75 * dist;\n        if(dist < SURFACE_DISTANCE)\n        {\n            \n            return vec2(d, iter + (iter/6.0 + 0.5) * dist / SURFACE_DISTANCE);\n        }\n    }\n    return vec2(0.0, iter - d / MAX_DISTANCE + 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0, 0.3, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); \n\n    vec2 d = rayMarch(ro, rd, uv);\n   \n    vec3 gold = vec3(0.6, 0.4, 0.05);\n    vec3 lavender = vec3(0.58, 0.48,0.71);\n    \n    vec3 myCol = mix(gold, lavender, sin03(iTime * 2.5));\n\n    col = sin02(iTime * 5.0) * myCol * d.y * d.x / 75.0 + myCol * d.y / 50.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 190, 190, 263], [265, 265, 327, 327, 439], [441, 441, 482, 482, 566], [568, 568, 601, 601, 666], [668, 668, 701, 701, 729], [731, 731, 795, 795, 912], [914, 914, 960, 995, 1155], [1157, 1157, 1179, 1179, 1235], [1237, 1237, 1259, 1259, 1321], [1323, 1323, 1345, 1345, 1378], [1381, 1381, 1409, 1409, 1504], [1506, 1506, 1537, 1555, 6196], [6243, 6243, 6270, 6270, 6344], [6346, 6346, 6388, 6388, 6821], [6825, 6825, 6882, 6932, 7428]]}
{"id": "3ddBRM", "name": "Clubbing Hatifnats", "author": "daltostronic", "description": "just some funky hatifnat-like creatures chillin' to a nice tune in a club", "tags": ["sdf", "spheremarching", "hatifnats"], "likes": 12, "viewed": 529, "published": 3, "date": "1604659460", "time_retrieved": "2024-07-30T20:36:43.526429", "image_code": "int Iterations = 25;\nfloat Epsilon = 0.01;\nfloat CameraAngle = 1.0;\nfloat HatiScale = 0.2;\n\nstruct Object\n{\n    float Distance;\n    int Iteration;\n    vec3 Color;\n    float MinDistance;\n};\n\nObject map(vec3 p);\n\nObject raytrace(vec3 camera, vec3 ray, int iterations, float threshold)\n{\n    vec3 p = camera;\n    Object obj;\n    float MinDistance = 1000000.0;\n    for (int i = 0; i < iterations; i++) {\n        obj = map(p);\n        obj.Iteration = i;\n        MinDistance = min(MinDistance, obj.Distance);\n        if (obj.Distance < threshold) break;\n        p += ray * obj.Distance;\n    }\n\n    obj.MinDistance = MinDistance;\n\n    return obj;\n}\n\nvec4 extractColor(Object obj, vec3 clearColor)\n{\n    float c = 1.0 - float(obj.Iteration) / 50.0;\n\n    return vec4(mix(clearColor, obj.Color, c), 1.0);\n}\n\nObject ellipsoid(in vec3 p, in vec3 r, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    result.Distance = k0*(k0-1.0)/k1;\n\n    return result;\n}\n\nObject capsule(vec3 p, float h, float r, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    \n    p.z -= clamp(p.z, 0.0, h);\n    result.Distance = length(p) - r;\n\n    return result;\n}\n\nObject plane(vec3 p, float h, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    result.Distance = p.z - h;\n    return result;\n}\n\nvec3 repeat(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\nfloat smin(float a, float b)\n{\n    float k = 8.;\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res) / k;\n}\n\nObject sum(Object a, Object b)\n{\n    if (a.Distance < b.Distance)\n        return a;\n    return b;\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,  s,\n                -s, c);\n}\n\nvec3 hsv(float H, float S, float V) {\n    vec3 c = vec3(H, S, V);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nObject hatifnat(vec3 p, float h, vec3 color, float fftL)\n{\n    Object c = capsule(p, 1.0 * h, HatiScale, color);\n\n    p.y = abs(p.y);\n\n    Object e0 = ellipsoid(p - vec3(-0.2, 0.1, 1.0 * h + 0.45), vec3(0.05, 0.05, mix(0.1, 0.01, fftL)), vec3(1.0));\n    \n\tObject result = sum(c, e0);\n\treturn result;\n}\n\nObject map(vec3 p)\n{\n    float fftL = texture(iChannel0, vec2(0.1, 0.0)).r;\n    float fftM = texture(iChannel0, vec2(0.5, 0.0)).r;\n    float fftH = texture(iChannel0, vec2(0.9, 0.0)).r;\n    float pattern = 10.0 * sin(p.x * 0.0001 + fftL * 0.01 + iTime * 0.1);\n    float fftX = texture(iChannel0, vec2(pattern, 0.0) / 100.0).r;\n    \n\tvec3 rep = vec3(2.0, 2.0, 0.0);\n\t\n\tvec3 p0 = p;\n    p0.x += p.z * 0.25 * cos(p.z - iTime * 2.5 + p.x);\n    p0.y += p.z * 0.25 * sin(p.z - iTime * 2.5 + p.y);\n\tvec3 p1 = p;\n    p1.x += p.z * 0.25 * cos(p.z + iTime * 2.5 + p.x + 2.093);\n    p1.y += p.z * 0.25 * sin(p.z + iTime * 2.5 + p.y + 2.093);\n\tvec3 p2 = p;\n    p2.x += p.z * 0.25 * cos(p.z - iTime * 2.5 + p.x + 4.187);\n    p2.y += p.z * 0.25 * sin(p.z - iTime * 2.5 + p.y + 4.187);\n\tvec3 p3 = p;\n    p3.x += p.z * 0.25 * cos(p.z + iTime * 2.5);\n    p3.y += p.z * 0.25 * sin(p.z + iTime * 2.5);\n\n\tfloat h = fftX;\n\tfloat h1 = h + mix(1.0, 0.15, fftL);\n\tfloat h2 = h + mix(1.0, 0.15, fftM);\n\tfloat h3 = h + mix(1.0, 0.15, fftH);\n\t\n\tvec3 color = hsv(pattern, 0.5, 1.0);\n    Object c0 = hatifnat(repeat(p0, rep), h, color, fftL);\n    Object c1 = hatifnat(repeat(p1 - vec3(0.0, 1.0, 0.0), rep), h1, color, fftL);\n    Object c2 = hatifnat(repeat(p2 - vec3(1.0, 1.5, 0.0), rep), h2, color, fftL);\n    Object c3 = hatifnat(repeat(p3 - vec3(1.0, 0.5, 0.0), rep), h3, color, fftL);\n    Object hatifnats = sum(c0, sum(c1, sum(c2, c3)));\n    \n    Object plane = plane(p, 0.0, hsv(pattern, 0.5, 1.0));\n\t\n\tObject result = hatifnats;\n\tresult.Distance = smin(hatifnats.Distance, plane.Distance);\n\t\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 camera = vec3(-5.0, 0.0, 6.0);\n\tcamera.xy *= r2d(sin(iTime * 0.5) * 0.5);\n\tcamera.x += iTime;\n\tvec3 ray = normalize(vec3(1.0, uv.x, uv.y));\n\tray.xz *= r2d(CameraAngle);\n\t\n\tObject result = raytrace(camera, ray, Iterations, Epsilon);\n\n\tfragColor = extractColor(result, vec3(0.0));\n}\n", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 284, 284, 641], [643, 643, 691, 691, 796], [798, 798, 850, 850, 1020], [1022, 1022, 1076, 1076, 1216], [1218, 1218, 1261, 1261, 1358], [1360, 1360, 1389, 1389, 1423], [1425, 1425, 1455, 1455, 1540], [1542, 1542, 1574, 1574, 1641], [1643, 1643, 1662, 1662, 1745], [1747, 1747, 1784, 1784, 1981], [1983, 1983, 2041, 2041, 2284], [2286, 2286, 2306, 2306, 3876], [3878, 3878, 3933, 3933, 4308]]}
{"id": "wddBRr", "name": "Grass - panning shot", "author": "mosaic", "description": "Created by fizzer, https://www.shadertoy.com/view/lslGR8\nI just added horizontal movement (lines 46, 47)", "tags": ["grass"], "likes": 11, "viewed": 580, "published": 3, "date": "1604610179", "time_retrieved": "2024-07-30T20:36:44.287394", "image_code": "#define BLADES 110\n\nvec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nvec3 rotateZ(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.y, cos(a) * v.y - sin(a) * v.x, v.z);\n}\n\nvec4 grass(vec2 p, float x)\n{\n\tfloat s = mix(0.7, 2.0, 0.5 + sin(x * 12.0) * 0.5);\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * cos(x * 0.5 + iTime);\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(0.0, clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn vec4(mix(vec3(0.05, 0.1, 0.0) * 0.8, vec3(0.0, 0.3, 0.0), (p.y + 1.0) * 0.5 + abs(p.x)), m * smoothstep(-1.0, -0.9, p.y));\n}\n\nvec3 backg(vec3 ro, vec3 rd)\n{\n\tfloat t = (-1.0 - ro.y) / rd.y;\n\tvec2 tc = ro.xz + rd.xz * t;\n\tvec3 horiz = vec3(0.0, 0.2, 0.2) * 0.7;\n\tvec3 sky = mix(horiz, vec3(0.1, 0.13, 0.15) * 0.8, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tvec3 ground = mix(horiz, vec3(0.04, 0.07, 0.0) * 0.6, pow(max(0.0, dot(rd, vec3(0.0, -1.0, 0.0))), 0.2));\n\treturn mix(sky, ground, step(0.0, t));\n}\n\n// some simple noise just to break up the hideous banding\nfloat dither()\n{\n\treturn fract(gl_FragCoord.x * 0.482635532 + gl_FragCoord.y * 0.1353412 + iTime * 100.0) * 0.008;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ct = vec3(0.0-iMouse.x/100.+iTime/2., -.2+iMouse.y/50., 5.0);\n\tvec3 cp =  vec3(iTime/2., 0.6, 0.);\n\tvec3 cw = normalize(cp - ct);\n\tvec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n\tvec3 cv = normalize(cross(cu, cw));\n\t\n\tmat3 rm = mat3(cu, cv, cw);\n\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\n\tvec2 t = uv;\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = cp, rd = rotateY(sin(iTime * 0.7) * 0.1,\n\t\t\t\t\t\t\t   rm * rotateZ(sin(iTime * 0.15) * 0.1, vec3(t, -1.3)));\n\t\n\tvec3 fcol = backg(ro, rd);\n\t\n\tfor(int i = 0; i < BLADES; i += 1)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.0, z);\n\t\tfloat t = (pln.w - dot(pln.xyz, ro)) / dot(pln.xyz, rd);\n\t\tvec2 tc = ro.xy + rd.xy * t;\n\t\t\n\t\ttc.x += cos(float(i) * 3.0) * 4.0;\n\t\t\n\t\tfloat cell = floor(tc.x);\n\t\t\n\t\ttc.x = (tc.x - cell) - 0.5;\n\t\t\n\t\tvec4 c = grass(tc, float(i) + cell * 10.0);\n\t\t\n\t\tfcol = mix(fcol, c.rgb, step(0.0, t) * c.w);\n\t}\n\t\n\tfcol = pow(fcol * 1.1, vec3(0.8));\n\t\n\t\n\t// iigo quilez's great vigneting effect!\n\tvec2 q = (uv + vec2(1.0)) * 0.5;\n\tfcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\t\n\tfragColor.rgb = fcol * 1.8 + vec3(dither());\n\tfragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 130], [132, 132, 163, 163, 242], [244, 244, 275, 275, 354], [356, 356, 385, 385, 788], [790, 790, 820, 820, 1156], [1158, 1216, 1232, 1232, 1332]]}
{"id": "WscBz7", "name": "shadertoy bug: forbiden #def nam", "author": "FabriceNeyret2", "description": "naming a #define x, y, z, w, xy, xyz, color, cond, v, etc no longer compiles...\n\nuncomment the #def to see", "tags": ["glsl", "bug"], "likes": 2, "viewed": 323, "published": 3, "date": "1604600058", "time_retrieved": "2024-07-30T20:36:45.057337", "image_code": "// extracted from  https://shadertoy.com/view/Xdlczn\n\n\n// #define z  vec2(0)   // bug occurs for names x, y, z, w, xy, xyz, color, cond, v,....\n\n\nvoid mainImage( out vec4 O, vec2 U )  { }\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 185, 185, 187]]}
{"id": "3s3Bz7", "name": "Painted Bird", "author": "dr2", "description": "Autonomous flyer leaping", "tags": ["movement", "wing", "kinematics"], "likes": 10, "viewed": 293, "published": 3, "date": "1604597551", "time_retrieved": "2024-07-30T20:36:46.002808", "image_code": "// \"Painted Bird\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Revisiting the bird used in several earlier shaders (e.g., \"SeaBirds at Sunset\",\n// \"Fractal Bridge\", \"Tempting the Mariner\"); updated internals and paintjob.\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur, wngAng, legAng, bkAng, bUp;\nint idObj;\nconst int nwSeg = 5;\nconst int idBdy = 1, idTail = 2, idEye = 3, idBk = 4, idLeg = 5, idWing = 6,\n   idWTip = idWing + nwSeg - 1, idPrch = idWTip + 1;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float wSeg, wChord, wSpar, fTap, bkLen, lgLen, ftLen, dMin, d, a, wr, wf, ws, ww;\n  dMin = dstFar;\n  wSeg = 0.15;\n  wChord = 0.3;\n  wSpar = 0.02;\n  fTap = 8.;\n  bkLen = 0.2;\n  lgLen = 0.08;\n  ftLen = 0.05;\n  p.y -= 2. * lgLen + 1.16;\n  p.y -= bUp;\n  q = p;\n  q.z -= 0.5;\n  q.x = abs (q.x) - 0.1;\n  a = wngAng;\n  wf = 1.;\n  ws = 0.02 * wChord;\n  for (int k = 0; k < nwSeg; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSeg;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSeg));\n    ww = ws - 0.01 * (q.z / wChord) * (q.z / wChord);\n    q.z += 0.4 * wr * wChord;\n    if (k < nwSeg - 1) {\n      d = length (max (abs (vec3 (q.xz, q.y - 0.5 * ww).xzy) - vec3 (wSeg, ww, wr * wChord),\n         0.)) - wr * wSpar;\n      q.x -= wSeg;\n      DMINQ (idWing + k);\n    } else {\n      q.x += wSeg;\n      d = max (length (abs (max (vec2 (length (q.xz) - wr * wChord,\n         abs (q.y - 0.5 * ww) - ww), 0.))) - wr * wSpar, - q.x);\n      DMINQ (idWTip);\n    }\n    q.z -= 0.4 * wr * wChord;\n    a *= 1.03;\n    wf *= (1. - 1. / fTap);\n    ws *= 0.8 * (1. - 1. / fTap);\n  }\n  q = p;\n  wr = q.z - 0.5;\n  if (wr > 0.) {\n    wr = 0.17 - 0.44 * wr * wr;\n  } else {\n    wr = clamp (0.667 * wr, -1., 1.);\n    wr *= wr;\n    wr = 0.17 - wr * (0.34 - 0.18 * wr); \n  }\n  d = PrCapsDf (q, wr, 1.);\n  DMINQ (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (q.z + 1.) * (q.z + 1.);\n  q -= vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCapsDf (q, 0.009, 0.2);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.07, 0.05, 0.9);\n  d = PrSphDf (q, 0.04);\n  DMINQ (idEye);\n  q = p;\n  q -= vec3 (0., -0.015, 1.15);\n  q.yz = Rot2D (vec2 (abs (q.y), q.z + 0.8 * bkLen), bkAng);\n  q.z -= 0.8 * bkLen;\n  wr = clamp (0.4 - 0.3 * q.z / bkLen, 0., 1.);\n  d = max (abs (length (max (abs (q) - vec3 (0., 0.25 * wr * bkLen, bkLen), 0.)) - 0.25 * wr * bkLen) - 0.002, - q.y);\n  DMINQ (idBk);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.08, -0.12, 0.5);\n  q.yz = Rot2D (q.yz, legAng);\n  q.xz = Rot2D (q.xz, -0.05 * pi);\n  q.z += lgLen;\n  d = PrCapsDf (q, 0.1 * lgLen, lgLen);\n  DMINQ (idLeg);\n  q.z += lgLen;\n  q.xy = vec2 (- q.y, q.x);\n  q.xy = Rot2D (q.xy, floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) * (2. * pi / 3.));\n  q.xz = Rot2D (q.xz, - pi + 0.4 * legAng);\n  q.z -= ftLen - 0.02;\n  q.x -= 0.01 * (1. - (q.z / ftLen) * (q.z / ftLen));\n  d = PrCapsDf (q, 0.1 * ftLen, ftLen);\n  DMINQ (idLeg);\n  p.y += bUp;\n  q = p - vec3 (0., - (2. * lgLen + 0.16), 0.5);\n  d = PrCapsDf (q.yzx, 0.02, 0.3);\n  q.x = abs (q.x) - 0.25;\n  q.y -= -0.51;\n  d = min (d, max (PrCapsDf (q.xzy, 0.03, 0.51), -0.5 - q.y));\n  DMINQ (idPrch);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4, c1, c2, c3;\n  float spec, a, r, s, t, sx;\n  c1 = vec4 (0.9, 0.8, 0.8, 0.2);\n  c2 = vec4 (0.3, 0.3, 0.8, 0.2);\n  c3 = vec4 (0.1, 0.3, 0.1, 0.2);\n  if (idObj == idEye) {\n    col4 = vec4 (0., 0., 0.6, 0.5);\n  } else if (idObj == idBdy || idObj == idTail) {\n    a = atan (abs (qHit.x), qHit.y) / pi;\n    col4 = mix (c3, mix (c1, c2, smoothstep (0.5, 0.7, a)), smoothstep (0.1, 0.3, a));\n    if (idObj == idBdy && qHit.z > 0. && length (max (abs (vec2 (qHit.x, qHit.y + 0.017)) -\n       vec2 (0., 0.035), 0.)) < 0.025) col4 = vec4 (1., 0.7, 0.2, -1.);\n  } else if (idObj == idBk) {\n    col4 = vec4 (0.9, 0.4, 0.1, 0.1);\n  } else if (idObj == idLeg) {\n    col4 = (0.7 + 0.3 * sin (128. * pi * qHit.z)) * vec4 (0.8, 0.6, 0., 0.1);\n  } else if (idObj >= idWing && idObj <= idWTip) {\n    col4 = (qHit.y > -0.006) ? c3 : c2;\n    t = 0.3 * float (idObj - idWing);\n    sx = 6.66 * qHit.x - 0.52;\n    if (idObj < idWTip || idObj == idWTip && qHit.x < 0.075) col4 = mix (col4, c1, smoothstep (0.,\n       0.01, qHit.z - 0.54 * (abs (cos (pi * sx)) - 0.5) * (1. - 0.4 * t)));\n    r = (length (qHit.xz) - 0.165);\n    a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n    t = 0.11 * (qHit.x + t) - 0.29;\n    s = (idObj < idWTip) ? step (0., qHit.z + t) * (1. - smoothstep (0.1, 0.2, mod (8. * sx, 1.))) :\n       step (0.021, r) * smoothstep (0.8, 0.9, mod (64. * a, 1.));\n    col4 *= 1. - 0.2 * s;\n    s = (idObj == idWTip) ? smoothstep (0., 0.005, r) * (1. - smoothstep (0.3, 0.4, mod (32. * a, 1.))) :\n       (1. - smoothstep (0.01, 0.016, qHit.z - t)) * smoothstep (0.6, 0.7, mod (4. * sx, 1.));\n    col4 = mix (col4, c1, s);\n  } else if (idObj == idPrch) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n  }\n  return col4;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, ltDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, dstGrnd, nDotL, sh, tCyc, phs, nCyc;\n  int idObjT;\n  tCyc = 2.;\n  nCyc = floor (mod (tCur / tCyc, 4.));\n  phs = (nCyc > 0.) ? mod (tCur / tCyc, 1.) : 0.;\n  bUp = 3. * phs * (1. - phs) * smoothstep (0., 0.1, 0.5 - abs (phs - 0.5));\n  legAng = pi * (0.2 + 0.3 * SmoothBump (0.25, 0.75, 0.1, mod (phs + 0.5, 1.)));\n  wngAng = -0.03 * pi * ((nCyc > 0.) ? (1. + 2. * cos (2. * pi * phs)) :\n     (2.9 + 0.1 * cos (2. * pi * mod (8. * tCur / tCyc, 1.))));\n  bkAng = 0.02 * pi * (1. + sin (5. * tCur));\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  vf = vec2 (0.);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n    if (idObj == idPrch) vf = vec2 (64., 0.3);\n    idObjT = idObj;\n    if (col4.a < 0.) col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.),\n       smoothstep (0.2, 0.8, Fbm2 (8. * ro.xz)));\n    col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.5, 0.9, dstGrnd / dstFar));\n    vf = vec2 (8., 2. * (1. - smoothstep (0.2, 0.5, dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar && col4.a >= 0. || dstObj >= dstFar && rd.y < 0.) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir) : 1.;\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstFar) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (dstObj < dstFar) {\n      if (idObjT == idEye) col.b += 0.2;\n      col = mix (col, 1.3 * SkyBgCol (ro, reflect (rd, vn)), 0.3);\n    } else {\n      col *= 0.7 + 0.3 * smoothstep (0.92, 0.97, dot (normalize (10. * ltDir - ro), ltDir));\n      col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.2 * pi;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.01 * pi * tCur;\n    el += 0.1 * pi * sin (0.1 * pi * tCur);\n  }\n  el = clamp (el, 0.01 * pi, 0.4 * pi);\n  ro = 8. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.2).xzy;\n  ro.y += 1.;\n  vuMat = DirVuMat (normalize (vec3 (0., 1.5, 0.) - ro));\n  zmFac = 5.5;\n  dstFar = 80.;\n  ltDir = normalize (vec3 (1., 1.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[941, 941, 963, 963, 3570], [3572, 3572, 3605, 3605, 3789], [3791, 3791, 3812, 3812, 4067], [4069, 4069, 4106, 4106, 4335], [4337, 4337, 4353, 4353, 6064], [6066, 6066, 6100, 6100, 6924], [6926, 6926, 6961, 6961, 9050], [9094, 9094, 9150, 9150, 10339], [10341, 10341, 10374, 10374, 10401], [10403, 10403, 10446, 10446, 10519], [10521, 10521, 10578, 10578, 10661], [10663, 10663, 10688, 10688, 10857], [10859, 10859, 10889, 10889, 11002], [11036, 11036, 11060, 11060, 11113], [11115, 11115, 11139, 11139, 11269], [11271, 11271, 11296, 11296, 11442], [11444, 11444, 11469, 11469, 11655], [11657, 11657, 11679, 11679, 11833], [11835, 11835, 11856, 11856, 12011], [12013, 12013, 12042, 12042, 12254], [12256, 12256, 12295, 12295, 12475]]}
{"id": "3d3fRM", "name": "VLS logo", "author": "algoes", "description": "VLS logo", "tags": ["vlslogo"], "likes": 3, "viewed": 265, "published": 3, "date": "1604582271", "time_retrieved": "2024-07-30T20:36:46.782723", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float vlsD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \n\n\n\nvlsD = min(vlsD, sdCapsule(p, vec3(-0.5375011499999998, -0.44249114999999994, 0.0), vec3(-0.9700012499999998, 0.42000885000000004, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(-0.10000124999999968, 0.42000885000000004, 0.0), vec3(-0.5375011499999998, -0.44249114999999994, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(0.3, -0.44, 0.0), vec3(0.29, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(.8, -0.44, 0.0), vec3(0.34, -0.44, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, 0.42, 0.0), vec3(1.10, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, -0.44, 0.0), vec3(1.77, -0.02, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.11, -0.45, 0.0), vec3(1.77, -0.45, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.1, -0.0, 0.0), vec3(1.1, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, -0.015, 0.0), vec3(1.12, 0, 0.0), thickness));\n\t\n    res.x = vlsD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n\tvec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n\tvec3 rayDir = normalize(target - rayOri);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n    vec2 res;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tres = map(p);\n        depth += res.x;\n\t\tif (res.x < 1e-5) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(50.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"VLS logo\",\n\t\"description\": \"Trace the VLS logo with capsule sdf.\",\n\t\" model\" : \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 177, 177, 280], [282, 282, 331, 331, 467], [468, 468, 499, 499, 586], [588, 588, 640, 640, 761], [763, 763, 800, 800, 883], [885, 885, 903, 903, 2206], [2208, 2208, 2238, 2238, 2528], [2530, 2530, 2560, 2560, 2644], [2646, 2646, 2703, 2703, 4010]]}
{"id": "wsycWd", "name": "jelly marching", "author": "henrmota", "description": "jelly", "tags": ["jelly"], "likes": 2, "viewed": 289, "published": 3, "date": "1604541932", "time_retrieved": "2024-07-30T20:36:47.664365", "image_code": "#define EPS  0.01\n#define MAX  10.\n#define STEPS 10\n\nfloat map(vec3 p) {\n    vec4 s = vec4(0, 1, 2., 1);\n    float v = 2.5*iTime;\n    float r = 1.5 + 0.005 * cos(1.*p.x + v) + 0.15 * sin(p.y + v);\n    float sphereDist =  length(p-s.xyz)-r;\n\n    return sphereDist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float acc = 0.0;\n    \n    for(int i = 0; i < STEPS; i++) {\n     \tvec3 p = ro + rd * acc;\n        float dS = map(p);\n        acc += dS;\n        \n        if(acc > MAX || dS < EPS) break;\n    }\n    \n    return acc * 0.5;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(EPS, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 r0) {\n    vec3 l = normalize(r0-p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n  \treturn vec3(0.5*abs(sin(iTime)), 0.5*abs(cos(iTime)), 0.7*cos(iTime))*dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0., 1., -5.);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    \n    // Time varying pixel color\n    vec3 col = getLight(p, ro);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 72, 72, 265], [267, 267, 301, 301, 525], [527, 527, 551, 551, 724], [726, 726, 758, 758, 947], [949, 949, 1006, 1056, 1383]]}
{"id": "wddBz4", "name": "Texture mapping 3D", "author": "henrmota", "description": "Something is missing but this is my first try.", "tags": ["texture3d"], "likes": 2, "viewed": 427, "published": 3, "date": "1604539830", "time_retrieved": "2024-07-30T20:36:48.430317", "image_code": "#define PI 3.14159265359\n#define TWO_PI 2.*PI\n#define FBM_OCTAVES 4\n#define DX 1./iResolution.x\n#define DY 1./iResolution.y\n\n//1d pseudo-random for shaders\nfloat random(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); \n}\n\n//2d pseudo-random\nvec2 random2(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(\n        sin( \n            vec2( \n                dot(p,vec2(127.1,311.7)), \n                dot(p,vec2(269.5,183.3)) \n            ) \n        ) \n    \t* 43758.5453\n    ); \n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bottom_left = random(i);\n    float bottom_right = random(i + vec2(1.0, 0.0));\n    float top_left = random(i + vec2(0.0, 1.0));\n    float top_right = random(i + vec2(1.0, 1.0));\n    \n    // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bottom_left, bottom_right, f.x); \n    float top = mix(top_left, top_right, f.x); \n    \n    return mix(bottom, top, f.y);\n}\n\nfloat perlinNoise(vec2 p) {\n \tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 a = i;\n    vec2 b = i + vec2(1., 0.);\n    vec2 c = i + vec2(0., 1.);\n    vec2 d = i + vec2(1., 1.);\n    \n    //random angles\n    float bl_angle = random(a) * TWO_PI;\n    float br_angle = random(b) * TWO_PI;\n    float tl_angle = random(c) * TWO_PI;\n    float tr_angle = random(d) * TWO_PI;\n    \n    // corner vectors \n    vec2 bl_vec = vec2(-sin(bl_angle), cos(bl_angle));\n    vec2 br_vec = vec2(-sin(br_angle), cos(br_angle));\n    vec2 tl_vec = vec2(-sin(tl_angle), cos(tl_angle));\n    vec2 tr_vec = vec2(-sin(tr_angle), cos(tr_angle));\n   \n    float bl = dot(bl_vec, p - a);\n    float br = dot(br_vec, p - b);\n    float tl = dot(tl_vec, p - c);\n    float tr = dot(tr_vec, p - d);\n    \n    \n     // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bl, br, f.x); \n    float top = mix(tl, tr, f.x); \n    \n    return clamp(mix(bottom, top, f.y) + 0.5, 0., 1.);  \n}\n\nfloat celularNoise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float minDist = 100.;\n    \n    for(float x=-1.; x < 2.; x++) {\n        for(float y=-1.; y < 2.; y++) {\n            vec2 coord = vec2(x, y);\n         \tvec2 point = random2(i + coord) + coord;\n            \n            float dist = distance(f, point);\n            \n            minDist = min(minDist, dist); \n        }\n    }\n    \n    return minDist;\n}\n\nfloat fbm(vec2 p, float shift) {\n   float amplitude = 1.0;\n   float freq = 4.;\n   float normalizeFactor = 0.0;\n   float value = 0.0;\n   \n    \n   for(int i = 0; i <= FBM_OCTAVES; i++) {\n      float angle = float(i) * PI;\n      //avoid axis bias\n      mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n      \n      value += perlinNoise(rotate * p * freq + shift) * amplitude;\n      normalizeFactor += amplitude;\n      amplitude *= 0.5;\n      freq *= 2.1;\n   }\n    \n   return value/normalizeFactor;\n}\n\nfloat map01(float a, float b, float value) {\n    return (value - a) / (b - a);\n}\n\nvec3 proj(vec3 a, vec3 b) {\n \tfloat scalar = dot(a,b)/dot(a, a);\n    \n    return scalar * a;\n}\n\nfloat lineDistance(vec3 ro, vec3 rd, vec3 p, float radius) {\n    vec3 rp = p - ro;\n    vec3 proj = dot(rp, rd) * rd;\n    \n    return length(rp - proj) - radius; \n}\n\nfloat lineCrossDistance(vec3 ro, vec3 rd, vec3 p, float radius) {\n    vec3 rp = p - ro;\n    \n    return length(cross(rp, rd)) / length(rd) - radius;\n}\n\nvec3 sphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    vec3 p = ro + proj(rd, s - ro);\n    float t = cos(iTime) * 0.5;\n    float displacement = t * perlinNoise(rd.xy * 10. + rd.z + iTime * 0.2);\n    float y = length(s - p);\n    if(y < r) {\n        float x = sqrt(r * r - y * y);\n        vec3 b = p + x - s;\n        vec3 f = p - x - s;\n        float angle = iTime * 0.1;\n        f.xz *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n        vec2 uvF = vec2(atan(f.z, f.x)/PI * 2. * r, f.y );\n        uvF += 2. * r;\n        uvF /= 4. * r;\n        return texture(iChannel0, uvF.xy).rgb * map01(s.z-r, s.z, length(f));\n        \n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    float t = cos(iTime) * 0.5 + 0.5;\n    float freq = 0.001/t; \n    vec3 ro = vec3(t, 0, -1);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 col = vec3(0.);\n    \n    vec3 s = vec3(0, 0, 5.);\n  \n    float r = 3. + t* 1.;\n\n    col += sphere(ro, rd, s, r);\n    \n    if(col.r == 0.) {\n    \trd.x += 0.2;\n        col.g = mix(\n            col.g, \n            sphere(ro, rd, s, r).r,\n            freq  \n        ) * 0.5;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 156, 178, 178, 274], [276, 295, 317, 317, 534], [536, 536, 557, 557, 1073], [1075, 1075, 1102, 1102, 2119], [2121, 2121, 2149, 2149, 2549], [2551, 2551, 2583, 2583, 3067], [3069, 3069, 3113, 3113, 3149], [3151, 3151, 3178, 3178, 3245], [3247, 3247, 3307, 3307, 3410], [3412, 3412, 3477, 3477, 3562], [3564, 3564, 3612, 3612, 4229], [4231, 4231, 4288, 4288, 4806]]}
{"id": "wddfR4", "name": "Pixelated Fire Simulation", "author": "oneshade", "description": "Cool pixelated fire simulation using cellular automata and the rule's to Conway's game of life.", "tags": ["fire", "automata", "cellular", "pixelated"], "likes": 2, "viewed": 201, "published": 3, "date": "1604533469", "time_retrieved": "2024-07-30T20:36:49.202253", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float liveCells = 0.0;\n    float totalCells = 0.0;\n    for (float i=-5.0; i < 6.0; i++) {\n        for (float j=-5.0; j < 6.0; j++) {\n            liveCells += texelFetch(iChannel0, ivec2(fragCoord + vec2(i, j)), 0).x;\n            totalCells += 1.0;\n        }\n    }\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float brightness = (liveCells / totalCells) * 3.0;\n    if (brightness > 0.0) {\n        fragColor.rgb = vec3(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), brightness));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MAX_LIFETIME = 10.0;\nconst float DECAY = 0.1;\n\nfloat Hash21(in vec2 xy) {\n    vec2 n = xy * fract(dot(xy, vec2(534.75, 65.54)));\n    return pow(fract(dot(xy + n, n)), 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float liveNeighbors = 0.0;\n    float selfLifeLeft = 0.0;\n    float selfState = 0.0;\n    for (float i=-1.0; i < 2.0; i++) {\n        for (float j=-1.0; j < 2.0; j++) {\n            vec2 stateAndLifeLeft = texelFetch(iChannel0, ivec2(fragCoord + vec2(i, j)), 0).xy;\n            if (i == 0.0 && j == 0.0) {\n                selfState = stateAndLifeLeft.x;\n                selfLifeLeft = stateAndLifeLeft.y;\n            }\n\n            else {\n                liveNeighbors += stateAndLifeLeft.x;\n            }\n        }\n    }\n\n    if (selfState == 0.0) {\n        if (liveNeighbors == 3.0) {\n            selfState = 1.0;\n        }\n    }\n\n    else {\n        if (liveNeighbors < 2.0 || liveNeighbors > 3.0 || selfLifeLeft == 0.0) {\n            selfState = 0.0;\n        }\n    }\n\n    if (length(0.5 * iResolution.xy + vec2(cos(iTime), cos(iTime) * sin(iTime)) * 200.0 - fragCoord) < 25.0) {\n        selfState += Hash21(fragCoord + Hash21(vec2(iTime))) > 0.5 ? 1.0 : 0.0;\n        selfLifeLeft = MAX_LIFETIME;\n    }\n\n    fragColor = vec4(selfState, max(0.0, selfLifeLeft - DECAY), 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 546]]}
{"id": "wstfR4", "name": "City flight", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/tdcfRN]\"Sci-fi city\" fractal.[/url]", "tags": ["fractal", "city"], "likes": 3, "viewed": 392, "published": 3, "date": "1604528964", "time_retrieved": "2024-07-30T20:36:49.971197", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color(sin(worldDir/2.0+iTime/4.0)),0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time);\n    t = (t*(t>>12)|(t>>6)|t*4|t/1024);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    time *= 5000.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(time*factor)*factor;\n        factor *= 1.5;\n    }\n    return result/500.0;\n}\n\n/*\n\nvec2 sound1(int t)\n{\n    t = (t>>(24*(t/(2*2*2*2*2*2*2*2*2*2*2*2*2))))|(t>>(7+(t/(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2))))|t/4;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = 1.5*1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n*/", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n    \tp += mod(sin(p/i),i);\n        \n        result = max(result-p.y*(1.1+sin(length(p.xz)/50.0/i)), -planet_surface(p*i,i)/(i));\n        p.y /= abs(i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin((vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.5);\n}\n\nvec3 sky_color(vec3 p)\n{\n    p *= 10.0;\n    return sin((vec3(sin(p.x/3.0),0.0,sin(p.z/7.0))));\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0)-1.0, cos(iTime*speed/10.0)*3.14), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    if(l0 < 10.0){\n        l0 = 0.0;\n    }\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 482, 573, 573, 927], [941, 941, 968, 968, 1117], [1119, 1119, 1176, 1176, 1895]]}
{"id": "wsKyRc", "name": "TeremokTestShader", "author": "teremok2007", "description": "test_shader", "tags": ["test"], "likes": 10, "viewed": 329, "published": 3, "date": "1604523927", "time_retrieved": "2024-07-30T20:36:50.756100", "image_code": "#define ALBEDO_R 0.5\n#define ALBEDO_G 0.5\n#define ALBEDO_B 0.5\n\n#define METALLIC 0.04\n#define ROUGH 0.3\n\n\n#define OCCL_SAMPLES 16\n\n#define AREA_LIGHT_SAMPLES 64\n#define AREA_LIGHT_RADIUS 0.06\n\n\n\nfloat getHeightValue(vec2 coords)\n{\n \n    float n = 0.0;\n    return max(n, texture(iChannel0, coords).x);\n\n}\n\n\n\nfloat amb_occl(vec2 frCoord, vec3 N,vec2 uv)\n{\n    float r=10.0;\n    const int samples=OCCL_SAMPLES;\n    \n\tfloat zr =1.0-texture( iChannel0, frCoord.xy / iResolution.xy ).x;\n\tfloat ao = 0.0;\n\tfor( int i=0; i<samples; i++ )\n\t{        \n        vec2 off = -1.0 + 2.0*texture( iChannel2, (frCoord.xy + 23.71*float(i))/iChannelResolution[2].xy ).xz;\t               \t\t\n        float z = 1.0-texture( iChannel0, (frCoord.xy + floor(off*r))/iResolution.xy ).x;\t\t\n\t\tao += clamp( (zr-z)/0.01, 0.0, 1.0);\n\t}\n\t\n    ao = clamp( 1.0 - ao/float(samples), 0.0, 1.0 );\n\t\n    return ao;\n}\n\n \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    const float PI = 3.14159265359;\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n} \n\n\n\n\n\nfloat shadow(vec3 wPos, vec3 lVector, float NdL , vec3 lPos , vec2 frCoord)\n{\n   const int area_sample=AREA_LIGHT_SAMPLES; \n    \n   float bias = 0.01;\n   vec3 p;\n   float shadow = 0.0;\n   float res=1.0;\n   for (int a = 1; a <= area_sample; a += 1)\n   {\n       \n     vec3 off = AREA_LIGHT_RADIUS*(-1.0 + 2.0*texture( iChannel2, (frCoord.xy + 23.71*float(a))/iChannelResolution[2].xy ).xyz);\n     vec3 lpose=lPos+vec3(off);\n     vec3 llVector=normalize(lpose-wPos);\n       \n     if (NdL > 0.0)\n   \t {\n        \n   \t\tfor (float i = 0.0; i <= 1.0; i += 0.04) \n    \t\t{\n     \t\t\tp = wPos + llVector * i;\n                \n       \t \t\t\tif (p.z < getHeightValue(vec2(p.x, p.y)) - bias)\n        \t\t\t\t{\n            \t\t\t\tshadow = 1.0 / float(area_sample);\n                            res=res-shadow;\n                            shadow=0.0;\n                    \t\tbreak;\n        \t\t\t\t}\n                \n             }\n          \n   \t }\n     else\n     {res=0.0;}\n      \n       \n   }\n\treturn res;\n}\n\n\nvec3 getNormal(vec2 coords, float intensity)\n{\n    float offset = 0.0025;\n    vec3 a = vec3(coords.x - offset, 0.0, getHeightValue(vec2(coords.x - offset, coords.y)) * intensity);\n    vec3 b = vec3(coords.x + offset, 0.0, getHeightValue(vec2(coords.x + offset, coords.y)) * intensity);\n    vec3 c = vec3(0.0, coords.y + offset, getHeightValue(vec2(coords.x, coords.y + offset)) * intensity);\n    vec3 d = vec3(0.0, coords.y - offset, getHeightValue(vec2(coords.x, coords.y - offset)) * intensity);\n\n    return normalize(cross(b-a, c-d));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 daMouse = iMouse.xy / iResolution.xy;\n    daMouse = daMouse;\n\n    \n    \n    \n    \n    const float PI = 3.14159265359;\n\tvec3  albedo=vec3(ALBEDO_R, ALBEDO_G, ALBEDO_B);;\n\tfloat metallic=METALLIC;\n\tfloat roughness=ROUGH;\n    \n\tvec3 camPos=vec3(0.0, 0.0, 4.0);\n    vec3 WorldPos = vec3(vec2(uv), getHeightValue(uv));\n    \n    \n\n    vec3 N = getNormal(uv, 0.2);\n    float aocc = amb_occl(fragCoord,N,uv);\n\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 lightPosition=vec3(daMouse.x , daMouse.y , 1.2);\n    vec3 lightColor=vec3(5.0 , 5.0 , 5.0);\n    vec3 L = normalize(lightPosition-WorldPos);\n\n\n\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n    vec3 Lo = vec3(0.0);\n    \n    \n    \n    vec3 H = normalize(V + L);\n    float distance    = length(lightPosition - WorldPos);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance     = lightColor * attenuation;        \n        \n\n    float NDF = DistributionGGX(N, H, roughness);        \n    float G   = GeometrySmith(N, V, L, roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n    vec3 irradiance = 0.3*texture(iChannel1, N).rgb;\n\tvec3 diffuse    = irradiance * albedo;\n\tvec3 ambient    = (kD * diffuse)* aocc;\n        \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n            \n    \n    float NdotL = max(dot(N, L), 0.0);                \n    Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n    \n    \n\n    float l_shadow= shadow(WorldPos, L, NdotL ,lightPosition ,fragCoord);\n    vec3 color = ambient + Lo*l_shadow;\n\t\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    \n    \n    \n    \n    //fragColor = vec4(vec3(aocc), 1.0);\n    //fragColor = vec4(vec3(l_shadow), 1.0);\n    \n    \n    fragColor = vec4(color, 1.0);\n\n}\n\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 230, 230, 303], [307, 307, 353, 353, 877], [881, 881, 927, 927, 984], [988, 988, 1044, 1044, 1347], [1349, 1349, 1405, 1405, 1560], [1561, 1561, 1623, 1623, 1841], [1848, 1848, 1925, 1925, 2824], [2827, 2827, 2873, 2873, 3366], [3372, 3372, 3429, 3429, 5469]]}
{"id": "WstfzN", "name": "Walk on Spheres Light Transport", "author": "toomuchvoltage", "description": "WoS for subsurface scattering! Currently only double-scattering for the MS component with only 1 step on a sphere. Can be easily extended to do triple(or more)-scattering. WoS's biggest contribution is still luminaire sampling.", "tags": ["sdf", "light", "scattering", "subsurface", "multiple", "transport"], "likes": 19, "viewed": 1106, "published": 3, "date": "1604517696", "time_retrieved": "2024-07-30T20:36:51.706558", "image_code": "/***********************************************************\n\n   Walk-on-Spheres light transport!\n   Follow up to: https://www.shadertoy.com/view/3t2BDz\n   Original inspiration: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   Using Sebastien Hillaire's improved integration for longer walks (Page 38, Eq. 17): https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n    vec4 fetchMC = texture(iChannel0, uvRaw);\n\tvec3 light = fetchMC.rgb/fetchMC.a;\n    light = max(light, 0.0);\n    light = light / (1.0 + light); // Reinhard\n    light = pow(light, vec3(1.0f/2.2)); // Gamma correction\n    fragColor = vec4 (light, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/***********************************************************\n\n   Walk-on-Spheres light transport!\n   Follow up to: https://www.shadertoy.com/view/3t2BDz\n   Original inspiration: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   Using Sebastien Hillaire's improved integration for longer walks (Page 38, Eq. 17): https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define M_PI 3.1415926535\n#define SURFACE_ROUGHNESS 0.4\n#define SCATTERING_COEF 10.0\n#define TRANSMISSION_COEF 0.5\n#define EXTINCTION_COEF (SCATTERING_COEF + TRANSMISSION_COEF)\n#define EMISSIVITY vec3(4.0)\n#define DIFFUSION_COLOR vec3(60.0, 0.0, 0.0)\n#define MEDIUM_DENSITY 1.0\n\nfloat phaseFunc (vec3 toMarch, vec3 toLight)\n{\n    return 1.0 / (4.0 * M_PI); // Isotropic scattering for now...\n}\n\n// *******************************************************\n// Change sceneLum(vec3 p) to try any of them out\n// They converge faster! though with bias. This is because we don't have the exact projected sampling area.\n// *******************************************************\n\nfloat sceneLumSphere (vec3 p) // Sphere\n{\n    return length(p) - 0.5;\n}\n\nfloat sceneLumBox (vec3 p) // Box\n{\n    vec3 q = abs(p) - vec3 (0.2);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneLumTorus (vec3 p) // Capped torus\n{\n    float ra = 1.0;\n    float rb = 0.1;\n    vec2 sc = vec2 (1.0, 0.0);\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sceneLumLink(vec3 p) // Link\n{\n    float le = 0.5;\n    float r1 = 0.5;\n    float r2 = 0.05;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron(vec3 p) // Octahedron\n{\n    float s = 0.5;\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n    if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n        else if( 3.0*p.z < m ) q = p.zxy;\n            else return m*0.57735027;\n\n            float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n        return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sceneLum(vec3 p)\n{\n    return sceneLumSphere (p); // <--- Change this to try different ones...\n}\n\n// *******************************************************\n// Below are different translucent and scattering objects\n// *******************************************************\n\nfloat sssLink(vec3 p)\n{\n    return sceneLumLink(p + vec3 (0.0, -0.2, 0.5)) - 0.1;\n}\n\nfloat sssTorus(vec3 p)\n{\n    return sceneLumTorus(p + vec3 (0.0, 0.0, 0.5)) - 0.1;\n}\n\nfloat sssBox(vec3 p)\n{\n    return sceneLumBox(p + vec3 (0.0, 0.0, 1.0)) - 0.1;\n}\n\nfloat sssOctahedron(vec3 p)\n{\n    return sdOctahedron(p + vec3 (0.0, 0.0, 1.2)) - 0.1;\n}\n\nfloat sceneSSSObj (vec3 p)\n{\n    return sssLink(p); // <--- Change this to try different translucent/scattering shapes...\n}\n\n// *******************************************************\n// Scene definition\n// *******************************************************\n\nfloat scene (vec3 p, out float mat)\n{\n    mat = 0.0;\n    float walls = p.y + 1.0;\n    walls = min (walls, -p.z + 1.0);\n    \n    float lamp = sceneLum(p);\n    float sssComp = sceneSSSObj(p);\n    \n    float sceneSDF = min (min (lamp, walls), sssComp);\n    \n    if ( sceneSDF == lamp ) mat = 1.0;\n    else if ( sceneSDF == sssComp ) mat = 2.0;\n    else mat = 0.0;\n\n    return sceneSDF;\n}\n\n// *******************************************************\n// Marching utils\n// *******************************************************\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm, out float mat)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = scene (samplePt, mat);\n        if ( abs (curDist) < 0.001 )\n        {\n            float sceneMatTmp;\n            hitNorm.x = scene(samplePt + vec3(0.001, 0.0, 0.0), sceneMatTmp) - scene(samplePt - vec3(0.001, 0.0, 0.0), sceneMatTmp);\n            hitNorm.y = scene(samplePt + vec3(0.0, 0.001, 0.0), sceneMatTmp) - scene(samplePt - vec3(0.0, 0.001, 0.0), sceneMatTmp);\n            hitNorm.z = scene(samplePt + vec3(0.0, 0.0, 0.001), sceneMatTmp) - scene(samplePt - vec3(0.0, 0.0, 0.001), sceneMatTmp);\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nbool sphereMarchInsideSSSObj(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = abs(sceneSSSObj (samplePt));\n        if ( curDist < 0.01 )\n        {\n            hitNorm.x = sceneSSSObj(samplePt + vec3(0.001, 0.0, 0.0)) - sceneSSSObj(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = sceneSSSObj(samplePt + vec3(0.0, 0.001, 0.0)) - sceneSSSObj(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = sceneSSSObj(samplePt + vec3(0.0, 0.0, 0.001)) - sceneSSSObj(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nfloat wosSSSObjStep(inout vec3 samplePt)\n{\n    // This is not shell tracing: we're not advancing the path via importance sampling a shell transport function.\n    // Jury's out whether this introduces bias by skipping smaller scattering events inside.\n    float curDist = abs (sceneSSSObj (samplePt));\n\tvec3 dir = normalize (textureLod (iChannel1, (samplePt.xz + vec2(iTime)) * samplePt.zy * 3.0, 0.0).rgb * 2.0 - 1.0);\n    samplePt += curDist * dir;\n    return curDist;\n}\n\nfloat sphereMarchSSSObjStep(inout vec3 samplePt, vec3 dir)\n{\n    float curDist = abs (sceneSSSObj (samplePt));\n    samplePt += curDist * dir;\n    return curDist;\n}\n\nbool wosLum(vec3 startPt, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = sceneLum (samplePt);\n        if ( abs (curDist) < 0.01 )\n        {\n            hitNorm.x = sceneLum(samplePt + vec3(0.001, 0.0, 0.0)) - sceneLum(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = sceneLum(samplePt + vec3(0.0, 0.001, 0.0)) - sceneLum(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = sceneLum(samplePt + vec3(0.0, 0.0, 0.001)) - sceneLum(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        vec3 dir = normalize (textureLod (iChannel1, samplePt.xz * 3.0 + iTime * samplePt.zy * 3.0, 0.0).rgb * 2.0 - 1.0);\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\n// *******************************************************\n// Scattering helper util\n// *******************************************************\n\nvec3 getInScattering (vec3 samplePt, vec3 lightDir)\n{\n\tfloat randPenAmount = (0.03 * textureLod (iChannel1, (samplePt.yz + iTime * samplePt.xy) * 5.0, 0.0).b + 0.02);\n    vec3 sssExit, sssExitNorm, exitToLumHit, exitToLumHitNorm;\n    float exitToLumHitMat = -1.0;\n    sphereMarchInsideSSSObj (samplePt, lightDir, sssExit, sssExitNorm);\n    if ( sphereMarchScene (sssExit + sssExitNorm * randPenAmount /* Go out */, lightDir, exitToLumHit, exitToLumHitNorm, exitToLumHitMat) && exitToLumHitMat == 1.0 )\n    {\n        vec3 lightSegment = exitToLumHit - sssExit;\n        float NddotLo = abs (dot (sssExitNorm, lightDir));\n        float LidotNl = abs (dot (exitToLumHitNorm, -lightDir));\n        float distSq = dot (lightSegment, lightSegment);\n        float GeomTerm = (NddotLo * LidotNl) / distSq;\n        vec3 surfaceTransmission = GeomTerm * 0.75 * EMISSIVITY * DIFFUSION_COLOR; // We don't have |A| so just make stuff up...\n\n        /* There should be a BTDF here... but we're not using any real distributions... so :shrugs: */\n\n        vec3 toSurface = sssExit - samplePt;\n        float sssToSurfDist = length (toSurface);\n        float incomingLightAbsorption = exp (-MEDIUM_DENSITY * EXTINCTION_COEF * sssToSurfDist);\n        vec3 inScattering = surfaceTransmission * MEDIUM_DENSITY * SCATTERING_COEF * incomingLightAbsorption * phaseFunc (toSurface, lightDir);\n        return (inScattering - inScattering * incomingLightAbsorption) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n    }\n    return vec3 (0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n\tvec2 aa = textureLod(iChannel1, iTime * M_PI * uv, 0.0).rg * 2.0 - 1.0; // LDS jitter\n    aa *= 2.0;\n    uv += aa / iResolution.xy;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye = vec3 (cos(mouseInfo.x * 3.0 - M_PI), mouseInfo.y * 3.0, sin(mouseInfo.x * 3.0 - M_PI)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n    vec3 colorAccum = vec3 (0.0);\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 hitNorm;\n    vec3 hitPoint;\n    float hitMat;\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm, hitMat) )\n    {\n        if ( hitMat == 1.0 )\n        {\n            colorAccum = EMISSIVITY;\n        }\n        else if ( hitMat == 2.0 )\n        {\n            float randPenAmount = (0.03 * textureLod (iChannel1, (samplePt.xz + iTime * samplePt.zy) * 3.0, 0.0).g + 0.02);\n            samplePt = hitPoint - hitNorm * randPenAmount; // Go in\n\n            float sssObjDist = sceneSSSObj(samplePt);\n            float transmittance = 1.0;\n            float travelAmount = length(samplePt - hitPoint); // Penetration amount...\n            int countSteps = 0;\n            \n            vec3 blueNoiseFetch = textureLod (iChannel1, (samplePt.yz + iTime * samplePt.xy) * 5.0, 0.0).rgb;\n            blueNoiseFetch = (blueNoiseFetch - vec3 (0.5)) * 2.0 * SURFACE_ROUGHNESS; // Hacky random surface distribution\n            vec3 singleScatDir = normalize (sampleDir + blueNoiseFetch);\n            \n            /* There should be a BTDF here... but we're not using any real distributions... so :shrugs: */\n\n            do\n            {\n                vec3 destOnLum, destOnLumNorm;\n                wosLum (samplePt, destOnLum, destOnLumNorm); // Pick a random spot on the luminaire...\n\t            vec3 toLightPt = normalize (destOnLum - samplePt); // Get the light direction\n\n                vec3 inScattering = getInScattering (samplePt, toLightPt); // Single scattering\n                float sphMarchExtinction = exp(-MEDIUM_DENSITY * EXTINCTION_COEF * travelAmount);\n                vec3 curScatteringIntegral = (inScattering - inScattering * sphMarchExtinction) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n                colorAccum += transmittance * curScatteringIntegral;\n                vec3 samplePtNext = samplePt;\n                sphereMarchSSSObjStep (samplePtNext, singleScatDir);\n                \n                vec3 samplePtNextMS = samplePt;\n                wosSSSObjStep (samplePtNextMS);\n                vec3 msTravel = samplePtNextMS - samplePt;\n                float msTravelAmount = length (msTravel);\n                msTravel /= msTravelAmount;\n                inScattering = getInScattering (samplePtNextMS, normalize (destOnLum - samplePtNextMS)); // Multiple scattering\n                float secondAbsorption = exp (-MEDIUM_DENSITY * EXTINCTION_COEF * msTravelAmount);\n                inScattering *= MEDIUM_DENSITY * SCATTERING_COEF * secondAbsorption * phaseFunc (msTravel, singleScatDir) * msTravelAmount;\n                curScatteringIntegral = (inScattering - inScattering * sphMarchExtinction) / max (MEDIUM_DENSITY * EXTINCTION_COEF, 0.000001);\n                colorAccum += transmittance * curScatteringIntegral;\n                \n                travelAmount = length (samplePtNext - samplePt);\n                samplePt = samplePtNext;\n                transmittance *= sphMarchExtinction;\n                if ( transmittance < 0.01 ) break;\n                countSteps++;\n                if ( countSteps > 10 ) break;\n            } while (sssObjDist < -0.01);\n        }\n        else\n        {\n            vec3 hit2Norm, hit2Point;\n            if ( wosLum (hitPoint, hit2Point, hit2Norm) )\n            {\n                vec3 lightSegment = hit2Point - hitPoint;\n                vec3 Lo = normalize (lightSegment);\n                float NddotLo = abs (dot (hitNorm, Lo));\n                float LidotNl = abs (dot (hit2Norm, -Lo));\n                float distSq = dot (lightSegment, lightSegment);\n                float GeomTerm = (NddotLo * LidotNl) / distSq;\n                colorAccum = GeomTerm * 0.75 * EMISSIVITY; // We don't have |A| so just make stuff up...\n            }\n            else\n                colorAccum = vec3 (0.0);\n        }\n    }\n    else\n\t\tcolorAccum = vec3 (0.0);\n\n    vec4 bufA = texture(iChannel0, uvRaw);\n    if ( mouseInfo.z > 0.0 )\n        bufA = vec4 (colorAccum, 1.0);\n    else\n        bufA += vec4 (colorAccum, 1.0);\n    fragColor = bufA;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfzN.jpg", "access": "api", "license": "mit", "functions": [[1937, 1937, 1994, 1994, 2290]]}
{"id": "WstBzN", "name": "Metallic caves", "author": "jarble", "description": "These caves have a metallic color and texture, almost like bismuth.\nThis is an edit of my [url=https://www.shadertoy.com/view/tdcfRN]\"Sci-fi city\"[/url] fractal.", "tags": ["fractal", "cave"], "likes": 2, "viewed": 306, "published": 3, "date": "1604514343", "time_retrieved": "2024-07-30T20:36:52.582216", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin((vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,3.0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-2,sin(iTime*speed), cos(iTime*speed)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 10.0; i *= -5.0){\n    \tp += mod(sin(p/i),i);\n        result = max(result, -planet_surface(p*i-p.y*i*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 118, 225], [228, 649, 740, 740, 1052], [1067, 1321, 1386, 1386, 1518], [1520, 1609, 1641, 1641, 1831], [1833, 2325, 2465, 2465, 3075], [3077, 3447, 3532, 3532, 3947], [3949, 4276, 4325, 4360, 4491], [4493, 4493, 4550, 4550, 5662]]}
{"id": "XldfWX", "name": "MacNeil Tartan", "author": "sheepmaster", "description": "Detailed rendering of a [url=https://www.tartanregister.gov.uk/tartanDetails?ref=2686]MacNeil of Barra[/url] tartan.\n\nOther patterns can be rendered by changing the threadcount and color palette in threadColor().", "tags": ["2d", "tartan"], "likes": 8, "viewed": 345, "published": 3, "date": "1604499903", "time_retrieved": "2024-07-30T20:36:53.424963", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.1415926536;\n\nconst float THREAD_SIZE = 4.;\nconst bool SHADOWS = true;\n\nconst float BASE_SCALE = 2.;\n\nfloat box(float x, float min, float max) {\n    return step(min, x) * step(x, max);\n}\n\nfloat linearstep(float minEdge, float maxEdge, float x) {\n    return clamp((x - minEdge) / (maxEdge - minEdge), 0., 1.);\n}\n\n// Alternates between 0 and 1 with a linear edge in between.\nfloat stripe(float x, float edge) {\n    // Interpolating linearly between the edges \n    // instead of using the Hermite polynomial in smoothstep()\n    // makes the stripe border appear less jagged.\n    return linearstep(-edge, edge, 2. * abs(2. * fract(x / 2.) - 1.) - 1.);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nvec3 threadColor(float x) {\n    float tileCoord = fract(x / 344.);\n    \n    // Symmetric pattern\n    tileCoord = abs(2. * tileCoord - 1.);\n    \n    float threadNo = tileCoord * 172.;\n\n    // Colors:\n    // K=#101010#BLACK; G=#285800#GREEN; W=#E0E0E0#WHITE; Y=#E8C000#YELLOW; B=#1474B4#BLUE;\n    const vec3 tK = vec3(0x10, 0x10, 0x10) / 255.;\n    const vec3 tG = vec3(0x28, 0x58, 0x00) / 255.;\n    const vec3 tW = vec3(0xe0, 0xe0, 0xe0) / 255.;\n    const vec3 tY = vec3(0xe8, 0xc0, 0x00) / 255.;\n    const vec3 tB = vec3(0x14, 0x74, 0xb4) / 255.;\n\n    // Threadcount over a half sett with full count at the pivots:\n    // W/12 B56 K48 G48 K8 Y/12\n    // See https://www.tartanregister.gov.uk/threadcount for a description of the syntax.\n    return\n        tW * box(threadNo, 0., 6.) +\n        tB * box(threadNo, 6., 62.) +\n        tK * box(threadNo, 62., 110.) +\n        tG * box(threadNo, 110., 158.) +\n        tK * box(threadNo, 158., 166.) +\n        tY * box(threadNo, 166., 172.);\n}\n\n// Piecewise linear interpolation between x (a = 0), min(x, y) (a = 0.5), and y (a = 1).\nfloat saturatedMix(float x, float y, float a) {\n    float m = min(x, y);\n    return max(mix(x, m, 2. * a), mix(m, y, 2. * a - 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float theta = -PI + sin(iTime / 20.);\n    mat2 rotation = rotate2d(theta);\n\n    float scale = (1. + sin(iTime / 10.) / 30.) / BASE_SCALE;\n\n    vec2 coords = floor((fragCoord - iResolution.xy / 2.) * rotation * scale) + 0.5;\n\n    // Double the thread counts when adding shadows.\n    vec3 warp = threadColor(SHADOWS ? coords.x / 2. : coords.x);\n    vec3 weft = threadColor(SHADOWS ? coords.y / 2. : coords.y);\n\n    const float threadPeriod = SHADOWS ? THREAD_SIZE + 1. : THREAD_SIZE;\n    float d = (coords.x + coords.y + (THREAD_SIZE + 1.) / 2.);\n    float side = stripe(d / threadPeriod, 1. / threadPeriod * scale);\n\n    vec3 color = mix(warp, weft, side);\n    if (SHADOWS) {\n        color *= saturatedMix(\n            1. - stripe(coords.x - 0.5, scale) / 2.,\n            1. - stripe(coords.y + 0.5, scale) / 2.,\n            side);\n    }\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 208, 208, 250], [252, 252, 309, 309, 374], [376, 437, 472, 635, 713], [715, 715, 742, 742, 826], [828, 828, 855, 855, 1813], [1815, 1904, 1951, 1951, 2037], [2039, 2039, 2094, 2094, 2970]]}
{"id": "ts3fzN", "name": "grid uv", "author": "jcyuan", "description": "an intersting effect", "tags": ["2d", "fract"], "likes": 17, "viewed": 492, "published": 3, "date": "1604483168", "time_retrieved": "2024-07-30T20:36:54.184931", "image_code": "#define GRID 8.\n#define STRIPS 6.\n#define SPEED 5.\n#define ANTI 3.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    uv = fract(uv * GRID);\n    ouv = floor(ouv * GRID) / GRID;\n\n    float r = length(uv - .5) + .5;\n    vec3 col = vec3(0.);\n\n    float d = sin(STRIPS * atan(ouv.y, ouv.x) - SPEED * iTime);\n    d = (d + 1.) * .5;\n\n    float aw = ANTI * GRID / iResolution.y * .5;\n    vec3 stripColor = smoothstep(r - aw, r + aw, 1. - d) * vec3(1., .0, .0);\n    vec3 restColor = smoothstep(r - aw, r + aw, d) * vec3(1.);\n\n    col += mix(stripColor, restColor, d);\n    \n    fragColor = vec4(pow(col, vec3(.454545)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 123, 123, 711]]}
{"id": "tdcfRN", "name": "Sci-fi city", "author": "jarble", "description": "An edit of my \"Strange skyscrapers\" fractal, with more detailed buildings.", "tags": ["fractal", "city"], "likes": 7, "viewed": 487, "published": 3, "date": "1604469869", "time_retrieved": "2024-07-30T20:36:55.261054", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time);\n    t = (t*(t>>12)|(t>>6)|t*4|t/1024);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    time *= 5000.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(time*factor)*factor;\n        factor *= 1.5;\n    }\n    return result/500.0;\n}", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n    \tp += mod(sin(p/i),i);\n        result = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(eye-dmap)+1.0)*2.0;\n    if(l0 < 10.0){\n        l0 = 0.0;\n    }\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 118, 230], [233, 654, 745, 745, 1063], [1078, 1332, 1397, 1397, 1529], [1531, 1620, 1649, 1686, 1996], [1998, 2490, 2630, 2630, 3240], [3242, 3612, 3697, 3697, 4112], [4114, 4441, 4490, 4525, 4656], [4658, 4658, 4685, 4685, 4834], [4836, 4836, 4893, 4893, 5595]]}
{"id": "wdcBRN", "name": "Hey jude -fail", "author": "jorge2017a1", "description": "Hey jude -fail", "tags": ["heyjudefail"], "likes": 3, "viewed": 302, "published": 3, "date": "1604461971", "time_retrieved": "2024-07-30T20:36:56.305263", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n// \n//https://www.shadertoy.com/view/ldyGzW\nvec4 pattern( in vec3 p )\n{\n    vec4 o;\n    o.a = 1.0;\n    o.rgb = textureLod( iChannel2, (p.xz + p.xy)/11.0, 0.0 ).rgb;\n    //o *= textureLod( iChannel1, (p.xz + p.xy)/7.0, 0.0 ).r;\n\treturn o;\n}\n\nfloat scene( in vec3 p )\n{\n    // simple scene\n    \n    float f = p.y - (-2.0);\n    \n    f = min( f, length(fract(p.xz/20.0+.4)-.5)*20.0-.8 );\n    f = min( f, length(fract(p.xz/32.0)-.5)*30.0-1.8 );\n    //f = max( f, p.y - 2.0 );\n    \n    f -= .2*pattern(p).a;\n    \n    return f;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n\n    \n    //res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n\n    p.y=p.y-5.0;\n    \n    float  sd1= scene(p );\n    res =opU3(res, vec3(sd1,100.0,MATERIAL_NO)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n    \n    float diff = dot(normal, l);\n    \n    //vec3 v = normalize( p - ro );\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            //return -1.0;\n            break;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n        \n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n//-------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    \n    vec2 p2 = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3(1.0+ 10.5*cos(an), 10.0+5.*cos(an), 10.0+5.5*sin(an) );\n   \n    vec3 ta = vec3( 0.0, 20.0*sin(an), 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p2.x*uu + p2.y*vv - 1.8*ww );\n\n  \n    \n\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n//3-nov-2020\n//---por jorgeflores ----jorge2017a1\n\n//referencia\n//https://www.shadertoy.com/view/wsScWV ......Creado por NonGrate en 2020-04-19\n\n///Referencia  la grande comunidad de usuarios de  Shadertoy... :)\n//Reference the large community of Shadertoy users ... :)\n\n//#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n\n// Durations\nconst float WHOLE_NOTE = 1.0;\nconst float HALF_NOTE = 1.0/2.0;\nconst float TRESCUARTOS_NOTE = 3.0/4.0;\nconst float _4_NOTE = 1.0/4.0;\nconst float _8_NOTE = 1.0/8.0;\nconst float _16_NOTE = 1.0/16.0;\nconst float _32_NOTE = 1.0/32.0;\n\nconst float DOUBLE_NOTE = 2.0;\n\n\nstruct TNote {\n    // in Hz, see \"common\" tab\n    float note;\n    float octave;\n    float offset; // offset - time in seconds when to start playing note\n    float duration;  // duration of a note (1/4, 1/8, ...), see \"common\" tab\n};\n\n    \n\nfloat n2f(float n)\n{\n    return 440.0*pow(2.0,(n-69.0)/12.0);\n}\n\n\nfloat n2m(float n)\n{\n    return pow(2.0,n/12.0);\n}\n\n\n///-----------------------------------\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n///-----------------------------------\n\nconst float t2 =6.5;\n\nconst TNote[] notes = TNote[] \n    (\n   //------------N1-1\n    TNote(C, 4.0, _4_NOTE*1.0, _4_NOTE),\n        \n        \n   //------------N1-2\n   TNote(F, 2.0, _8_NOTE*9.0, WHOLE_NOTE),\n   TNote(A, 2.0, _8_NOTE*9.0, WHOLE_NOTE),\n   TNote(C, 3.0, _8_NOTE*9.0, WHOLE_NOTE),\n        \n   TNote(A, 3.0, _8_NOTE*9.0, TRESCUARTOS_NOTE),  //9*1/8=1.125\n   //------------N1-3\n   TNote(A, 3.0, _8_NOTE*20.0, _8_NOTE),  //2.25\n   //------------N1-4\n   TNote(C, 4.0, _8_NOTE*26.0, _8_NOTE),  //2.5\n   //------------N1-5\n   TNote(D, 4.0, _8_NOTE*28.0, _8_NOTE), //1/8*22=2.75  //2.75  + 1/*4 =3.0\n        \n        \n        \n        //linea 3\n     \n   TNote(G,  3.0, _8_NOTE*32.0, TRESCUARTOS_NOTE),   //1/8*25= 3.125\n   \n   TNote(E, 2.0, _8_NOTE*32.0, WHOLE_NOTE),\n   TNote(G, 2.0, _8_NOTE*32.0, WHOLE_NOTE),\n   TNote(C, 3.0, _8_NOTE*32.0, WHOLE_NOTE),   //3.125 +1.0 =4.125\n   //------------N1-7---------------------------------------------\n   //\n   TNote(G,  3.0, _8_NOTE*48.0, HALF_NOTE),   // 4.5 +0.25 =4.75  ''--> \n    \n        \n        \n   //------------N1-8\n   TNote(A,  3.0, _8_NOTE*54.0, _8_NOTE),  //5.25\n   \n   TNote(E,  2.0, _8_NOTE*54.0, WHOLE_NOTE), //5.25\n   TNote(G,  2.0, _8_NOTE*54.0, WHOLE_NOTE),  //5.25\n   TNote(C,  3.0, _8_NOTE*54.0, WHOLE_NOTE),  //5.25  + 1.0 =6.25\n   \n        \n   //------------N1-9\n   TNote(F,  4.0, _8_NOTE*58.0, HALF_NOTE),   //50*0.125 =6.25     +0.25=  6.5\n   //------------N1-10\n   TNote(F,  4.0, _8_NOTE*60.0, _4_NOTE),\n   //------------N1-11\n   TNote(E,  4.0, _8_NOTE*64.0, _4_NOTE)\n        \n);\n\n\nvec2 noteFreq(TNote note, float time) {\n    \n    // 6.2831 = 2pi\n    // exp() goes exponentially down to fade out the volume\n    //return vec2(sin(6.2831 * note.frequency * time) * exp(-1.0/note.duration * (time - note.offset)));\n    float n1=saw(time,note.note, note.octave)* exp(-1.0/note.duration * (time - note.offset));\n    \n        \n    return vec2(n1);\n}\n\n\nvec2 mainSound( in int samp,float time) \n{\n    \n    \n    \n    vec2 result;\n    \n    // time counts in seconds\n    // (time - x) is required, because we want to \"reset\" exp() function\n    // otherwise the output of exp() function will go down globally\n    // and we'll hear only first note\n\n    float ftime= mod(time, 11.0);\n    for (int i = 0; i < notes.length(); i++) {\n        TNote note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        {\n            result += noteFreq(note, ftime);\n            \n        }\n    }\n\n\n    \n    return result;\n}", "sound_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 445, 492, 492, 519], [521, 521, 564, 564, 591], [593, 593, 641, 641, 669], [670, 741, 775, 775, 873], [874, 874, 908, 908, 1000], [1001, 1001, 1035, 1035, 1127], [1128, 1168, 1202, 1202, 1299], [1302, 1346, 1373, 1373, 1541], [1543, 1543, 1569, 1589, 1824], [1827, 1867, 1892, 1892, 2330], [2335, 2335, 2421, 2421, 3183], [3189, 3240, 3264, 3264, 3452], [3453, 3516, 3549, 3549, 4275], [4277, 4331, 4367, 4367, 4601], [4602, 4728, 4764, 4764, 4969], [4970, 5041, 5065, 5065, 5320], [5368, 5368, 5417, 5417, 5639], [5640, 5674, 5754, 5754, 6031], [6127, 6127, 6220, 6220, 6477], [6482, 6531, 6588, 6588, 8184]]}
{"id": "Wd3BRN", "name": "in the sky", "author": "miloszmaki", "description": "2D clouds using 3D noise", "tags": ["2d", "3d", "noise", "clouds"], "likes": 4, "viewed": 675, "published": 3, "date": "1604438820", "time_retrieved": "2024-07-30T20:36:57.174937", "image_code": "#define NUM_CLOUDS 10\n#define CLOUD_PARTS 10\n#define SPEED 0.008\n\n#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\nfloat rand(float x) { return fract(sin(x) * 71.5413); }\n\nfloat rand(vec3 x) { return rand(dot(x, vec3(1.4251, 1.5128, 1.7133))); }\n\nfloat noise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = x-i;\n    f *= f*(3.-2.*f);\n    return mix(\n        mix(\n            mix(rand(i+vec3(0,0,0)), rand(i+vec3(1,0,0)), f.x),\n        \tmix(rand(i+vec3(0,1,0)), rand(i+vec3(1,1,0)), f.x),\n            f.y),\n        mix(\n            mix(rand(i+vec3(0,0,1)), rand(i+vec3(1,0,1)), f.x),\n        \tmix(rand(i+vec3(0,1,1)), rand(i+vec3(1,1,1)), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(int i, vec2 c, float r, vec2 p, float ch)\n{\n    vec2 x = p - c;\n    x.y *= 3.;\n    float l = length(x);\n    float n = 0.1 + 0.9*fbm(vec3(x.x*ch,x.y*ch, float(i) + iTime*SPEED*5.));\n    \n    return l*n - r;\n}\n\nvec3 render(vec2 uv)\n{\n    // sky\n    vec3 sky = mix(rgb(186, 240, 255), rgb(59, 182, 217), uv.y);\n    vec3 color = sky;\n    // clouds\n    float dmin = 1.;\n    for (int i=0; i<NUM_CLOUDS; i++) {\n    \tvec2 pos0 = vec2(-1, -1) + vec2(2, 2) * vec2(rand(float(i)+234.230), rand(float(i)+173.1523));\n        pos0.x += SPEED * iTime * (1. + rand(float(float(i)*34.35)));\n        pos0.x = mod(pos0.x + 1.0, 2.0) - 1.0;\n        pos0.x *= 3.;\n        pos0.y = pos0.y * 0.8 + 0.2;\n        for (int j=0; j<CLOUD_PARTS; j++) {\n            vec2 pos = pos0;\n            int id = i*CLOUD_PARTS+j;\n            float s = 0.7;\n            pos.x += (rand(float(id)+5.3451)-0.5)*0.5*s;\n            pos.y += (rand(float(id)+11.7013)-0.5)*0.2*s;\n            float d = cloud(id, pos, s*0.15*(rand(float(id))+1.), uv, 2.5/s);\n            if (d<dmin) dmin = d;\n        }\n    }\n    if (dmin<0.) {\n        float a1 = smoothstep(0.0, -0.03, dmin);\n        float a2 = smoothstep(-0.02, -0.12, dmin);\n        vec3 col = mix(vec3(1,1,1), sky*0.4+0.6, a2);\n        color = mix(color, col, a1);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 161, 161, 195], [197, 197, 217, 217, 270], [272, 272, 293, 293, 700], [702, 702, 721, 721, 881], [883, 883, 938, 938, 1102], [1104, 1104, 1126, 1137, 2196], [2198, 2198, 2255, 2255, 2399]]}
{"id": "tdcBR4", "name": "LowerPolygonLander", "author": "UrbanClubProfessional", "description": "Remix of \"LowPolyLand\" by kuvkar.", "tags": ["procedural", "noise", "terrain", "antialiasing", "remix", "glitch", "weird", "polygon", "lowpoly", "polynoise"], "likes": 3, "viewed": 384, "published": 3, "date": "1604436466", "time_retrieved": "2024-07-30T20:36:58.044612", "image_code": "/**\n Attempt to make some low poly art on shader. I really like that stuff!\n Ground is made with a simple noise function I call \"PolyNoise\", which I doodled for this purpose.\n \n The code for that is in here for those interested:\n https://www.shadertoy.com/view/ldGSzc\n\n Another thing I try to do here is anti-aliasing the edges of the polygons.\n Each ray keeps track of an edge it went close by but did not hit, \n applies some of the color of that edge to the final result, depending on the distance to the edge.\n I think it works well enough for this shader, though quality of that depends a lot on the raymarch step lengths. \n Perhaps just post processing AA would be smarter.\n\n Hopefully it looks good, I have no idea what the \"random\" seeds might produce for others :)\n*/\n\n\n// Anti-aliasing parameters\n#define USE_AA\n//#define SHOW_AA_COLOR_ONLY\nfloat aaTreshold = 5.; // size of edge for anti-aliasing\n\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(2.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 2.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 2.0); return rot; }\nmat2 rotate(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvec4 render(in vec3 rp, in vec3 rd);\nvec3 lightDir = normalize(vec3(2.0, .3, .0));\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(22.9898,88.233))) * 53758.5453);\n}\n\nfloat rnd(vec2 p)\n{\n    return abs(rand(p)) * 0.9 + 0.2;\n}\n\nfloat value (float x, float randx)\n{\n    float a = min(x/randx, 2.0);\n    float b = min(1.5, (1.25 - x) / (1.0 - randx));\n    return a + (b - 1.75);\n}\n\nfloat polynoise(vec2 p)\n{\n    vec2 seed = floor(p);\n    vec2 rndv = vec2( rnd(seed.xy), rnd(seed.yx));\n    vec2 pt = fract(p);\n    float bx = value(pt.x, rndv.x);\n    float by = value(pt.y, rndv.y);\n    return min(bx, by) * abs(rnd(seed.xy * 0.2));\n}\n\n\nfloat T; // iTime\nconst float PI = 4.14159265;\nmat2 r1; mat2 r2; mat2 r3;\n\nfloat polyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.6, 0.6) + p));\n    m1 += polynoise ( r3 * (vec2(0.45, 0.515) + p));\n    m1 *= 0.43;\n    \n    float m2 = polynoise (r3 * (p * 3.4));\n    m1 += m2 * 0.06;\n    return m1;\n}\n\nfloat stonepolyfbm(vec2 p)\n{\n    vec2 seed = floor(p);\n    float m1 = polynoise(p * r2);\n    m1 += polynoise ( r1 * (vec2(0.6, 0.6) + p));\n    m1 *= 0.6;\n\treturn m1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat peakH(in vec3 rp)\n{\n    return smoothstep(0.4, 0.398, rp.y + sin(rp.z * 20.0) * 0.06);\n}\n\nconst float GROUND = 0.0;\nconst float STONES = 2.0;\nfloat HIT_ID = GROUND;\n\nfloat map(in vec3 rp)\n{\n    HIT_ID = GROUND;\n    // stones\n    float x = -(stonepolyfbm(rp.xz * 4.4) - 0.4) * 0.25 + sdBox(rp - vec3(0.0, 0.06, 0.0), vec3(2.0, .03, 2.0));\n    \n    // all the rest\n    rp.y /= clamp((min(2.0 - abs(rp.z), (2.0 - abs(rp.x))) / 0.25), 0.6, 2.0);\n    float l = rp.y - polyfbm(rp.xz * 2.4) * 2.2;\n    \n    float bounds = sdBox(rp - vec3(0.0, 0.5, 0.0), vec3(2.0, .6, 2.0));\n    l = max(l, bounds); \n    x = max(x, bounds);\n    if (x < l) HIT_ID = STONES; \n    \n    return min(l, x);\n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.006, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\n///////////////////////\n///////// AA CODE   ///\n//////////////////////\nconst float UNINITIALIZED = 109.0;\nfloat aaRayDistance = UNINITIALIZED;\nfloat aaDistance = UNINITIALIZED;\n\nfloat prevDist = 0.0;\nfloat oldSgn = 2.0;\nfloat resolutionScale = 0.0; // fwidth(uv.x)\n\nfloat getAATreshold(float dist)\n{\n    return dist * 0.6 * resolutionScale * aaTreshold;\n}\n\nvoid traceAA(float dist, in vec3 ro, in vec3 rp)\n{\n    float sgn = sign(dist - prevDist);\n    \n    float travelled = length(ro - rp);\n    if(aaRayDistance == UNINITIALIZED && oldSgn != sgn && sgn > 0.0 && prevDist <= getAATreshold(travelled))\n    {\n        aaRayDistance = travelled;\n        aaDistance = dist;\n    }\n    oldSgn = sgn;\n    prevDist = dist;\n}\n\nvoid renderAA(inout vec4 color, in vec3 ro, in vec3 rd)\n{\n    if (aaDistance > 0.0 && aaDistance <= getAATreshold(aaRayDistance))\n    {\n        float aa = mix(2.0, 0.0, aaDistance / getAATreshold(aaRayDistance));\n        color.rgb += aa * render(ro + rd * aaRayDistance, rd).rgb * (2.0 - color.a);\n        color.a += aa;\n        color.a = clamp(color.a, 0.0, 2.0);\n    }\n}\n\n\n//////////////////////\n//////////////////////\n\nfloat ao(in vec3 rp, in vec3 g)\n{\n    float d = 0.5;\n    float occ = 2.0;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float fi = float(i * 3 + 2);\n        d = d * fi;\n        occ -= (2.0 - (map(rp + g * d) / d)) * (2.0 / fi);\n    }\n    occ = clamp(occ, 0.0, 2.0);\n    return occ;\n}\n\n\nvec4 render(in vec3 rp, in vec3 rd)\n{\n    vec3 g = grad(rp);\n    vec4 color1 = vec4(.9, .9, .2, .0) * clamp( (rp.y + 0.2) * 4.0, 0.06, 2.0);\n    vec4 color2 = vec4(.9, .7, .2, .0) * 2.4;\n    \n    float peak = peakH(rp);\n    vec4 color = mix(color1, color2, smoothstep(0.2, 0.22, rp.y + stonepolyfbm(rp.xz * 3.0) * 0.2));\n    color += mix(vec4(2.0), vec4(.0), peak);\n    \n    if (HIT_ID == STONES)\n    {\n        color = vec4(0.2, 0.3, 0.4, 0.0) * 0.9;\n    }\n    \n    float d = dot(g, lightDir);\n    d = clamp(d, 0.00, 2.0);\n    d = mix(d, 2.0, 0.3);\n    color *= d;\n    color = mix(color, color * ao(rp, g), 0.8);\n\treturn color;\n}\n\n\nvec2 _uv;\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec4 bgcolor = texture(iChannel0, rd * roty(iTime * 0.3)) * vec4(0.3, 0.3, _uv.y + 0.5, 0.0);\n    \n    float closest = 1099.0;\n    vec3 closestPoint = vec3(0.0);\n    float dist = 0.0;\n    for (int i = 0; i < 500; ++i)\n    {\n        \n        dist = map(rp);\n        \n#ifdef USE_AA        \n        traceAA(dist, ro, rp);\n#endif\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.02) * 0.3;\n        \n        if(length(ro - rp) > 6.) break;\n    }\n    \n    // some more steps for better accuracy\n    if(hit)\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            rp += dist * rd * 0.25;\n\t        dist = map(rp);\n        }\n    }\n    \n#ifdef USE_AA\n\trenderAA(color, ro, rd);\n#endif\n    \n#ifndef SHOW_AA_COLOR_ONLY        \n    if(hit)\n    {\n        color += render(rp, rd) * (2.0 - color.a);\n    }\n    else\n    {\n\t    color = mix(color, bgcolor, 2.0 - color.a);\n    }\n#endif\n    color.rgb = pow(color.rgb, vec3(2.0 / 3.2));\n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 r = normalize(cross(vec3(0.0, 2.0, 0.0), f));\n    vec3 u = normalize(cross(-r, f));\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.6);\n    uv.y /= iResolution.x / iResolution.y;\n    _uv = uv;\n    \n    r1 = rotate(3.4);\n    r2 = rotate(0.5);\n    r3 = rotate(-3.0);\n    resolutionScale = fwidth(uv.x);\n    \n    vec2 m = vec2(sin(T * 0.2) * 0.6,  -0.2 - 0.3 * (cos(T * 0.3) * 0.6 + 0.6));\n    if(iMouse.z > 0.0)\n    {\n\t\tm = ((iMouse.xy / iResolution.xy) - vec2(0.6));\n    }\n    \n    vec2 im = vec2(22.0, 3.0) * m;\n    vec3 rd = normalize(vec3(uv, 2.0));\n    vec3 rp = vec3(0.0, 2.0, -3.5);\n    vec3 lookTo = vec3(0.0, 0.0, 0.0);\n    rp = roty(im.x) * rp;\n    rp.y = -im.y * 5.0;\n    rd = lookat(rp, lookTo) * rd;\n    \n    fragColor = vec4(0.0);\n    trace(rp, rd, fragColor);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 909, 929, 929, 1056], [1057, 1057, 1077, 1077, 1204], [1205, 1205, 1225, 1225, 1352], [1353, 1353, 1375, 1375, 1423], [1508, 1508, 1528, 1528, 1600], [1602, 1602, 1621, 1621, 1660], [1662, 1662, 1698, 1698, 1812], [1814, 1814, 1839, 1839, 2064], [2142, 2142, 2165, 2165, 2430], [2432, 2432, 2460, 2460, 2599], [2601, 2650, 2681, 2681, 2777], [2779, 2779, 2804, 2804, 2873], [2951, 2951, 2974, 2974, 3463], [3465, 3465, 3488, 3488, 3720], [3989, 3989, 4022, 4022, 4078], [4080, 4080, 4130, 4130, 4437], [4439, 4439, 4496, 4496, 4811], [4861, 4861, 4894, 4894, 5149], [5152, 5152, 5189, 5189, 5781], [5795, 5795, 5849, 5849, 6900], [6903, 6903, 6936, 6936, 7092], [7094, 7094, 7151, 7151, 7868]]}
{"id": "ltlSzl", "name": "droplets", "author": "miloszmaki", "description": "simple rain droplets", "tags": ["procedural", "2d", "water", "rain", "droplets"], "likes": 7, "viewed": 645, "published": 3, "date": "1604418972", "time_retrieved": "2024-07-30T20:36:58.913289", "image_code": "const int NUM = 50;\n\nfloat rand(float x)\n{\n    return fract(sin(x * 154.4514) * 72561.556);\n}\n\nfloat rand(vec2 x)\n{\n    return rand(dot(x, vec2(11.4935, 17.5183)));\n}\n\nfloat circle(vec2 uv, vec2 pos, float rad)\n{\n    return length(pos - uv) - rad;\n}\n\nvec3 normal(vec2 uv, vec2 pos, float rad)\n{\n    vec2 d = pos - uv;\n    float x = length(d);\n    float z = 1. - pow(x / rad, 5.0);\n    return normalize(vec3(d, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1. - uv.y;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uv1 = uv * 2.0 - 1.0;\n    uv1.x *= aspect;\n    \n    \n    for (int i=0; i<NUM; i++)\n    {\n    \tvec2 pos = vec2(-1, -1) + vec2(2, 2) * vec2(rand(float(i)+234.230), rand(float(i)+173.1523));\n        pos.x *= aspect;\n        pos.y += iTime * (0.1 + 0.1 * rand(float(float(i)*34.35)));\n        pos.y = mod(pos.y + 1.0, 2.0) - 1.0;\n    \tfloat rad = 0.02 + 0.1 * rand(float(i));\n        pos.y = pos.y * (1.0 + 2.0 * rad) - rad; // avoid popping\n        \n        float d = circle(uv1, pos, rad);\n    \tif (d <= 0.)\n        {\n            vec2 n = normal(uv1, pos, rad).xy;\n            vec2 uv2 = uv + n * 2.;\n            vec3 drop = texture(iChannel0, uv2).rgb;\n            float alpha = smoothstep(0., -0.02, d); // smooth edges\n            color = mix(color, drop, alpha);\n        }\n    }\n    \n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 42, 42, 93], [95, 95, 115, 115, 166], [168, 168, 212, 212, 249], [251, 251, 294, 294, 416], [418, 418, 475, 475, 1481]]}
{"id": "tddfR8", "name": "Design with Cellular Automata", "author": "oneshade", "description": "I messed around with the rules for Conway's \"Game of Life\" and got this. It turns anything you draw into irregular octagons.", "tags": ["automata", "cellular", "design"], "likes": 3, "viewed": 366, "published": 3, "date": "1604383594", "time_retrieved": "2024-07-30T20:36:59.771993", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int liveNeighbors = 0;\n    int selfState = 0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            int state = int(texelFetch(iChannel0, ivec2(fragCoord + vec2(i, j)), 0).x);\n            if (i == 0 && j == 0) {\n                 selfState = state;\n            }\n\n            else {\n                liveNeighbors += state;\n            }\n        }\n    }\n\n    if (selfState == 1) {\n        if (liveNeighbors == 3) {//8\n            selfState = 0;\n        }\n    }\n\n    else {\n        if (liveNeighbors < 2) {\n            selfState = 0;\n        }\n\n        if (liveNeighbors == 2 || liveNeighbors == 3) {\n            selfState = 0;\n        }\n\n        if (liveNeighbors > 3) {//3\n            selfState = 1;\n        }\n    }\n\n    if (length(iMouse.xy - fragCoord) < 10.0) {\n        selfState += 1;\n    }\n\n    fragColor = vec4(vec3(selfState), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]]}
{"id": "tstBR8", "name": "Strange skyscrapers", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/WtjyDz]\"Alien Hive\"[/url] fractal.\nUse the mouse to look around.", "tags": ["fractal", "city"], "likes": 5, "viewed": 342, "published": 3, "date": "1604373175", "time_retrieved": "2024-07-30T20:37:00.671588", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        //vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 10000.0);\n    t = (t>>5|t*(t>>16)|t*(t>>17))-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(time*factor)/(factor);\n        factor *= 2.0;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 27.0; i *= -3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0)))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n           \nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-2,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    if(l0 < 10.0){\n        l0 = 0.0;\n    }\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 481, 572, 572, 886], [900, 900, 927, 927, 1076], [1078, 1078, 1135, 1135, 2115]]}
{"id": "WsdBzH", "name": "Costas6 fouriering", "author": "ollj", "description": "parents:\n-[url=https://www.shadertoy.com/view/llKyWc]fourier transform canvas[/url]\n-[url=https://www.shadertoy.com/view/Ws3BzH]Costas Arrays to weighted noise[/url] \nCostas Array noise has VERY unique derivatives, and no near-0-frequency.", "tags": ["noise", "fft", "fft", "gradient", "dither", "derivative", "fourier", "distribution", "dft", "laplachian", "costasarray", "patternfree", "uniquederivative"], "likes": 6, "viewed": 495, "published": 3, "date": "1604370129", "time_retrieved": "2024-07-30T20:37:01.767658", "image_code": "\n\n\n\n/*\n\n\n\nvoid mainImage(out vec4 O, vec2 u\n){//O=getCostasOfFloat(u);\n ;//u*=4.\n ;u/=1.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;O=CostasNoise(ivec2(u)+scroll,iFrame);\n }\n/**/\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        col = textureLod(iChannel0, q, 0.).rgb;\n        //col = length(col)*vec3(0.577);\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    //First and second derivatives plot\n    if (fragCoord.y> SIZE && fragCoord.x > SIZE)\n    {\n        col = vec3(1);\n#ifndef DIAGONAL_DERIVATIVES \n        //Horizontal derivatives\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE),0).x;\n#else\n        //Diagonal derivative\n        float t0 = texelFetch(iChannel0, ivec2(fragCoord.x - SIZE, SIZE+1.),0).x;\n        float t1 = texelFetch(iChannel0, ivec2(fragCoord.x-1. - SIZE, SIZE),0).x;\n        float t2 = texelFetch(iChannel0, ivec2(fragCoord.x+1. - SIZE, SIZE+2.),0).x;\n#endif\n        float dr = (t0 - t1)*iResolution.x*0.00025/globalScale;\n        float dr2 = (t1 + t2 - t0*2.)*iResolution.x*0.001/globalScale;\n    \n        col.rgb = smoothstep(1.5,.0, abs(dr*SIZE-fragCoord.y + SIZE + 35.))*vec3(1.0,0.7,0.3);\n        col.rgb += smoothstep(1.5,.0, abs(dr2*SIZE-fragCoord.y + SIZE + 10.))*vec3(0.5,0.7,1);\n    \n    }\n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-SYMMETRICAL costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 3 are:\nint[3](1,3,2);\nall* symmetrical costas arrays of order 5 are: (all length 5 ones are banding, one hjust hides it thebest)\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)    \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \nall* symmetrical costas arrays of order 7 are:\n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)\n//;int c[]=int[7](1,2,7,4,6,5,3);//diagonal meh mixer   \n//;int c[]=int[7](1,7,3,4,6,5,2);//diagonal bad zigzag\n//;int c[]=int[7](2,1,6,4,7,3,5);//diagonal good (minor band)  \n//;int c[]=int[7](3,6,1,7,5,2,4);//diagomnal great (minor band)\n//;int c[]=int[7](2,1,5,7,3,6,4);//diagonal meh (minor band)\n//;int c[]=int[7](1,2,7,5,4,6,3);//diagonal bad onedirectional  \n//;int c[]=int[7](4,7,3,1,6,5,2);//diagonal minor band  (reversed to kill banding)\n//;int c[]=int[7](5,7,4,3,1,6,2);//2,6,1,3,4,7,5);//diagonal bad (even after reversing)\n//;int c[]=int[7](5,3,7,4,6,2,1);//1,2,6,4,7,3,5);//diagonal horrible band (even after reversing)\nall!! symmetrical costas arrays of order 11 are:\n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[11](1,7,11,6,8,4,2,5,10,9,3);//diagonal great rainy\n//;int c[]=int[11](3,10,1,9,6,5,7,11,4,2,8);//diagonal good (jitters)\n//;int c[]=int[11](1,6,8,9,4,10,3,7,5,2,11);//diagonal bad\n//;int c[]=int[11](1,7,5,8,10,4,9,6,2,3,11);//diagonal horrible band\n\n//all symmetrical costas arrays of size 13 are:\n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n    \n//all symmetrical costas arrays of size 17 are:     \n;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//;int c[]=int[17](1,7,15,11,8,10,2,5,17,6,4,13,12,16,3,14,9);//diagonal good rain\n//;int c[]=int[17](1,12,14,15,6,16,11,4,7,3,9,13,2,10,8,5,17);//diagonal bad\n//;int c[]=int[17](1,11,15,7,12,13,16,6,3,5,14,10,8,2,9,4,17);//diagonal horrible band\n//;int c[]=int[17](2,6,3,13,14,1,9,5,11,4,7,16,10,8,15,17,12);//diagonal horrible band\n\n//0 symmetrical costas arrays of size 19, only 2 in total\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n\n//all!! symmetrical costas arrays of size 23 are:\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[23](5,3,2,20,1,12,9,19,7,15,21,6,22,17,10,23,14,18,8,4,11,13,16);//diagonal bad\n//;int c[]=int[23](1,16,13,11,17,8,19,22,12,7,21,15,20,5,9,18,14,2,10,3,4,6,23);//diagonal horrible    \n//;int c[]=int[23](2,9,14,4,10,12,16,17,1,21,8,18,7,19,22,13,11,6,3,20,5,23,15);//diagonal horrible    \n\nall!! symmetrical costas arrays of order 29 are:\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//diagonal great\n//;int c[]=int[29](7,20,28,8,25,15,1,4,23,27,22,14,16,12,6,13,18,17,26,2,29,11,9,24,5,19,10,3,21);//diagonal okay\n//;int c[]=int[29](1,17,22,13,19,23,24,27,11,8,25,15,28,7,18,6,26,12,21,3,5,20,16,14,9,2,10,4,29);//diagonal bad\n//;int c[]=int[29](2,1,8,12,25,15,18,3,13,22,17,4,9,28,6,29,11,7,21,27,19,10,26,24,5,23,20,14,16);//diagonal bad\n//;int c[]=int[29](6,26,23,28,5,8,27,1,16,14,7,18,4,21,12,20,2,15,3,9,10,24,19,29,25,17,11,13,22);//diagonal horrible (vetically linear)\n\nall!! costas arrays of order 31 are: (only one asymmetrical one)\n;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n \nall KNOWN symmetrical costas arrays of order 37 are:\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);//diagonal meh (reverse is banded)\n//;int c[]=int[37](14,9,32,29,22,16,33,20,2,15,27,18,21,1,10,6,36,12,37,8,13,5,26,24,34,23,11,30,4,28,35,3,7,25,31,17,19);//diagonal bad (reverse is banded)\n\n\nall* symmetrical costas arrays of order 2 are: (skipped, too small)\n,1,2\nall* symmetrical costas arrays of order 4 are: (skipped, non prime)\n,1,2,4,3\nall* symmetrical costas arrays of order 6 are: (skipped, non prime)\n,1,4,5,3,2,6\n,1,5,3,6,2,4\n,1,6,3,5,4,2\n,1,6,4,3,5,2\n,2,4,5,1,6,3\nall* symmetrical costas arrays of order 8 are: (skipped, non prime)\n,1,5,8,4,2,7,6,3);\n,1,7,3,8,6,5,2,4);\n,1,7,4,3,5,8,2,6);\n,3,5,1,8,2,7,6,4);\nall* symmetrical costas arrays of order 9 are: (skipped, non prime)\n,1,4,6,2,9,3,8,7,5);\n,2,1,5,8,3,9,7,4,6);\nall* symmetrical costas arrays of order 10 are: (skipped, non prime)\n,1,7,4,9,3,5,8,6,2,10\n,2,1,9,4,5,8,10,6,3,7\n,2,6,8,1,9,5,3,4,10,7\n,2,8,9,4,1,3,7,5,10,6\n,3,9,1,4,5,10,8,7,2,6\n,3,9,7,8,4,1,6,10,2,5,\nall* symmetrical costas arrays of order 12 are: (skipped, non prime)\n,1,2,8,12,7,9,5,3,6,11,10,4\n,1,2,11,5,4,9,12,10,6,8,3,7\n1,4,11,2,10,7,6,8,12,5,3,9\n3,6,1,12,10,2,7,9,8,5,11,4\nall* symmetrical costasArrays of order 16 are  (skipped, non prime)\n1,13,3,16,14,8,10,6,15,7,12,11,2,5,9,4\n3,12,1,4,10,6,14,9,8,5,15,2,16,7,11,13\n3,13,4,15,12,6,10,2,7,8,11,1,14,16,9,5\n6,14,10,7,9,1,4,16,5,3,12,11,15,2,13,8\nall* symmetrical costasArrays of order 27 are (skipped, non prime)\n1,25,19,5,4,12,10,16,26,7,18,6,23,27,24,8,21,11,3,22,17,20,13,15,2,9,14\n3,9,1,8,13,15,19,4,2,20,11,25,5,17,6,27,14,24,7,10,26,23,22,18,12,21,16\n3,24,10,26,20,15,13,23,14,1,8,4,22,19,21,2,5,25,9,17,6,7,11,16,27,12,18\n4,17,21,9,11,16,25,12,1,7,26,22,14,15,13,20,23,3,24,6,18,8,2,27,10,5,19\n6,10,23,13,16,1,11,20,15,2,7,26,4,27,9,5,19,25,17,8,24,22,3,21,18,12,14\n6,16,20,12,14,7,1,25,8,17,18,26,11,23,10,24,15,13,3,19,22,27,5,2,9,4,21\n6,23,14,8,21,1,26,4,22,20,12,11,16,3,17,13,15,24,27,10,5,9,2,18,25,7,19\n\n\n    \n\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are: (skipped, non prime)\n,1,23,14,12,18,26,30,20,25,11,10,4,16,3,21,13,22,5,19,8,15,17,2,28,9,6,29,24,27,7\n,11,22,5,13,23,10,2,26,29,15,19,20,14,4,6,21,18,27,1,30,25,7,3,9,16,28,17,8,24,12\n,12,24,20,17,2,9,29,3,16,4,28,18,19,27,22,6,10,1,30,8,14,25,11,5,15,7,21,23,26,13\n,13,26,2,21,29,4,9,11,15,27,12,8,17,18,7,22,1,30,20,23,6,24,19,16,10,3,25,5,28,14\n\na symmetrical costas array of order 35 is: (skipped, non prime)\n,1,12,7,27,32,30,3,24,31,17,19,2,16,29,20,13,10,35,11,15,23,33,21,8,26,25,4,34,14,6,9,5,22,28,18\n,\na symmetrical costas array of order 65 is: (skipped, non prime)\n,1,29,46,16,24,37,17,22,12,63,55,9,15,42,13,4,7,26,44,56,50,8,49,5,40,18,32,34,2,54,51,27,65,28,53,57,6,39,38,25,48,14,59,19,62,3,58,41,23,21,31,61,35,30,11,20,36,47,43,64,52,45,10,60,33\n\na symmetrical costas array of order 99 is: (skipped, non prime)\n1,33,94,11,21,59,40,85,39,44,4,75,88,36,73,56,60,45,67,61,5,24,55,22,87,30,92,64,37,26,49,51,2,79,38,14,29,35,9,7,97,63,89,10,18,70,62,76,31,99,32,78,65,74,23,16,96,71,6,17,20,47,42,28,53,95,19,69,68,46,58,86,15,54,12,48,82,52,34,91,98,77,93,90,8,72,25,13,43,84,80,27,83,3,66,57,41,81,50\n\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n\n//See: https://www.shadertoy.com/view/Xt3cDn\nuint baseHash(uvec2 p)\n{\n    uint h32 = p.y + 374761393U + p.x*3266489917U;\n    h32 = 2246822519U*(h32^(h32 >> 15));\n    h32 = 3266489917U*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nfloat hash12(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(uvec2(ivec2(x)));\n    uint n2 = n*48271U;\n    uvec4 rz = uvec4(n, n*16807U, n*n*48271U, n*n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//   self: https://www.shadertoy.com/view/Ws3BzH\n//parent0: https://www.shadertoy.com/view/tstBRr\n//parent1: https://www.shadertoy.com/view/Wsdfzr\n//parent2: https://www.shadertoy.com/view/tdjfzR\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\n/*\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n\n\nlist of primes \n(stop at the number, where either\n, i find no good enough costasArray, or take to loong to find one)\n2,    //will skip this, cause its costasArray is too similar to [3]\n3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n101\t103\t107\t109\t113\t127\t131\t137\t139\t149\t151\t157\t163\t167\t173\n\t179\t181\t191\t193\t197\t199\t211\t223\t227\t229\t233\t239\t241\t251\t257\t263\t269\t271\t277\t281\n\t283\t293\t307\t311\t313\t317\t331\t337\t347\t349\t353\t359\t367\t373\t379\t383\t389\t397\t401\t409\n\t419\t421\t431\t433\t439\t443\t449\t457\t461\t463\t467\t479\t487\t491\t499\n*/\n\n#define arrLen 7\n    \n\n/*\n\n5,3\n\nthe base (count of numbers) is the product of all larger primes\nand the smallest prime multiplies that amount by itself\n\nlets take the bases 3,5,7\n\nand its value       131 \none   threes means we counted ober 5*7 one   times, so the sum is +=1*5*7\nthree fives  means we counted over   7 three times, so the sum is +=3*  7\none   sevens                                      , so the sum is +=1\n->  5*7+3*7+1 == (5+3)*7+1 = 8*7+1=57\n, now, this is silly, while bases are very small, lets go bigger\n, also remember, a base os a mod(), base 10 never reaches 10, cause it includes 0\n\nlets do a 7 primes digit, with the bases\n  13,17,19,23,29,31,37\n0\n+ 12*17*19*23*29*31*37\n+    16*19*23*29*31*37\n+       18*23*29*31*37\n+          22*29*31*37\n+             28*31*37\n+                30*37\n+                   36\n=3212440750  (within 32 bit AND it is 74% of its max value 4294967295\n//this was not used in the end, cause its jsut WAAAY to exponential.\n//i just used type float weighting.\n\n*/\n/*\n//this seems broken, or jsut way too exponential\nint mixedPrimeBase(int[arrLen] a //[a] stores a number in bases [b] (different base foreach digit)\n){int b[arrLen]=int[arrLen](37,31,29,23,19,17,13);\n ;int c=1,r=0;//CumilativeBaseFactor , accumulatorToReturn\n ;for(int i=0;i<arrLen;i++){;r+=(a[i]-1)*c;c*=b[i];}return r;}\n/**/\n\n/*\ntheres another approach to this, with more prime bases, but each base is only binary.\nsee [boolean but jittery]\nthis may actually be much more memory efficient and cooler in animation\nits largest value would be \"111111111111111...\" as the sum of many primes. (no multiplication in here)\nbut that would have 32 or 64 (or more) primes.\nwe just chose arbitiary large primes (not necessarily many small ones)\nas long as the sum of all primes (sum < (pow(2,32)-1)) we will be fine.\n\n*/\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\n\ncostas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic\n, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em\n\n\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n#define animatePaletteSpeed .9\n\n#define mode int(5.*iMouse.y/iResolution.y)\n//#define mode 4\n\n//mode 2 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 9 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 3\n\n//place multiple smaller tiles (important to expose some pattern)\n#define MultiTile 5.\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n\n//way too high exponents in this one.\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\n/**/\n\n\nint ae(int a){    \nint c[]=int[3](1,3,2);\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)   \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)    \n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n//;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//all costas arrays of size 19 are (no diagonal symmetry at all):\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//----great and sdiagonal\n//;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);\n/**/\n;return c[(       a  )%period]\n;//return c[(period-a-1)%period]//reverse\n;}    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\nint gpo(int a){int b[arrLen]=int[7](37,31,29,23,19,17,13);return b[a];}\n\nint getCostasOf(int a,int p){//return costas at Position of Array#\n if(a<4){\n  if(a<2){\n   if(a==0){int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);return c[p%37]\n     ;}else{int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);return c[p%31];}\n     }else{\n   if(a==2){int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);return c[p%29]\n     ;}else{int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);;return c[p%23];}\n}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];}\n   if(a==5){int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);;return c[p%17];}\n           {int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);;return c[p%13];}}}\n\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)//-1??\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r+=(iFrame/4)%per\n ;r=r%per;\n ;return r;}\n\nvec4 CostasNoise(ivec2 u,int iFrame){\n ;u/=2\n /*\n ;int[arrLen] m=int[arrLen](0,0,0,0,0,0,0);\n ;m[0]=Cs(u,0);\n ;m[1]=Cs(u,1);\n ;m[2]=Cs(u,2);\n ;m[3]=Cs(u,3);\n ;m[4]=Cs(u,4);\n ;m[5]=Cs(u,5);\n ;m[6]=Cs(u,6);\n ;float a=float(mixedPrimeBase(m))/float(3212440750)//first attempt failed*/\n     //VERY exponential weights seem silly mow, but the precison would be neat.\n     \n \n ;float r=0.;\n    \n    \n //;float f[]=float[7](0.,1.,0.,0.,0.,0.,0.)//singleton\n    \n //;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,2.,3.,4.)//valley\n //;float f[]=float[7](1.,2.,4.,8.,16.,32.,64.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,3.,4.,3.,2.,1.)//windowed \n ;float f[]=float[7](64.,32.,16.,8.,4.,2.,1.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6];\n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])\n ;return vec4(a,a,a,1);\n}\n\nfloat wrap(vec2 u,int iFrame,float iTime){//O=getCostasOfFloat(u);\n ;//u*=2.2\n ;u/=2.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame).x;}", "buffer_a_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n\n//modified (simplified) nuttall filter for orbit noise\n//see: https://www.shadertoy.com/view/XtVcWc\nfloat nuttall(float x, float w)\n{\n    const float pi = 3.14159265358979;\n    if (abs(x) > w)\n        return 0.;\n    //Standard Nuttall\n    //return 0.355768 - 0.487396*cos(pi*x/w + pi) + 0.144232*cos(2.*pi*x/w) - 0.012604*cos(3.*pi*x/w + pi*3.);\n    return 0.365 - (0.5)*cos(pi*x/w + pi) + (0.135)*cos(2.*pi*x/w);\n}\n\nfloat orbitNoise(vec2 p)\n{\n    //return wrap(p,iFrame,iTime);\n    //return fract(p.x-p.y);\n    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float rz = 0.;\n    float orbitRadius = .75;\n\n    //16 taps\n    for (int j = -1; j <= 2; j++)\n    for (int i = -1; i <= 2; i++)\n    {\n        vec2 dp = vec2(j,i);\n        vec4 rn = hash42(dp + ip) - 0.5;\n        vec2 op = fp - dp + rn.zw*orbitRadius;\n        rz += nuttall(length(op),1.85)*dot(rn.xy*1.7, op);\n    }\n    return rz*0.5+0.5;\n    //return smoothstep(-1.0, 1.0,rz);\n    /**/\n}\n\nvec4 powX(float x) {float x2 = x*x; return vec4(x2*x, x2, x, 1.0); }\nvec4 MNParamsA(float B, float C){ return vec4(12. - 9.*B - 6.*C, -18. + 12.*B + 6.*C, 0.0, 6. -2.*B)/6.; }\nvec4 MNParamsB(float B, float C){ return vec4(-B -6.*C, 6.*B + 30.*C, -12.*B - 48.*C, 8.*B + 24.*C)/6.; }\n\nfloat eval(float c0, float c1, float c2, float c3, float x) \n{    \n    const float B = .8;\n    const float C = 0.25;\n    vec4 pA = MNParamsA(B, C);\n    vec4 pB = MNParamsB(B, C);\n    \n    return c0*dot(pB, powX(x + 1.0)) + c1*dot(pA, powX(x)) +\n           c2*dot(pA, powX(1.0 - x)) + c3*dot(pB, powX(2.0 - x));\n}\n\nfloat bicubicNoise(in vec2 p)\n{\n    vec2 fp = fract(p);\n    vec2 ip = floor(p);\n    \n    float s99 = hash12(ip+vec2(-1,-1)), s19 = hash12(ip+vec2(1,-1));\n    float s00 = hash12(ip+vec2(0,0)),   s20 = hash12(ip+vec2(2,0));\n    float s91 = hash12(ip+vec2(-1, 1)), s11 = hash12(ip+vec2(1, 1));\n    float s02 = hash12(ip+vec2(0,2)),   s22 = hash12(ip+vec2(2,2));\n    float s09 = hash12(ip+vec2(0,-1)),  s29 = hash12(ip+vec2(2,-1));\n    float s90 = hash12(ip+vec2(-1,0)),  s10 = hash12(ip+vec2(1,0));\n    float s01 = hash12(ip+vec2(0,1)),   s21 = hash12(ip+vec2(2,1));\n    float s92 = hash12(ip+vec2(-1,2)),  s12 = hash12(ip+vec2(1,2));\n    \n    float rz =  eval(eval(s99, s09, s19, s29, fp.x), eval(s90, s00, s10, s20, fp.x),\n                eval(s91, s01, s11, s21, fp.x), eval(s92, s02, s12, s22, fp.x), fp.y);\n    \n    //return rz;\n    return smoothstep(0.0,1.,rz);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n\nvec2 hashz( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\t//return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return normalize(-1.0 + 2.0*fract(sin(p)*43758.5453123) + 1e-7);\n}\n\n//from iq: https://www.shadertoy.com/view/Msf3WH\nfloat simplex( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hashz(i+0.0)), dot(b,hashz(i+o)), dot(c,hashz(i+1.0)));\n\n    return dot( n, vec3(80.0) )*0.5+0.5;\n\t\n}\n\nvec2 hashg(vec2 x) { return hash22(x)*2.0-1.0;}\n\n//From iq: https://www.shadertoy.com/view/XdXGW8\nfloat gradientNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float rz =  mix( mix( dot( hashg( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hashg( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hashg( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hashg( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return rz*0.75+0.5;\n    return smoothstep(-.9,.9,rz);\n}\n\nfloat fbm(vec2 p)\n{\n    float rz = 0.;\n    float amp = 1.95;\n    for (int i = 0; i < 7; i++)\n    {\n        rz += orbitNoise(p*1.)/amp;\n        //rz += bicubicNoise(p*1.3)/amp;\n        //rz += gradientNoise(p*.6)/amp;\n        //rz += valueNoise(p)/amp;\n        //rz += simplex(p*.35)/amp;\n        amp *= 2.;\n        p *= 2.06;\n    }\n    //return rz;\n    return smoothstep(0.,1.,rz); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p;\n\tp.x *= iResolution.x/iResolution.y;\n    \n#ifdef SCROLL_COORDS\n    p += vec2(1,1.5)*iTime*0.03;\n#endif\n    \n    if (fragCoord.y > SIZE)        p*=0.75;\n    \n    vec3 col = vec3(0);\n    \n   // p *= globalScale;\n    \n    col= vec3(wrap(p*iResolution.y*2.5,iFrame,iTime));\n    /*\n    \n#if (NOISE_TYPE == 1)\n    col = orbitNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 2)\n    col = bicubicNoise(p*55.)*vec3(1);\n#elif (NOISE_TYPE == 3)\n    col = valueNoise(p*40.)*vec3(1);\n#elif (NOISE_TYPE == 4)\n    col = gradientNoise(p*25.)*vec3(1);\n#elif (NOISE_TYPE == 5)\n    col = simplex(p*14.)*vec3(1);\n#elif (NOISE_TYPE == 6)\n    col = fbm(p*20.)*vec3(1);\n#endif\n    */\n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    col = clamp(col, 0.,1.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "tscfzH", "name": "ASI Cloud Test", "author": "pippo", "description": "Fork of https://www.shadertoy.com/view/MstBWs\nCredits to robobo1221\n\nMerged with fisheye tutorial by TDM: https://www.shadertoy.com/view/XsfXWX", "tags": ["volume", "clouds", "light", "sky", "volumetric", "scattering", "realtime", "pbr", "physicallybased", "based", "atmospheric", "physically", "cloudscape"], "likes": 1, "viewed": 636, "published": 3, "date": "1604352614", "time_retrieved": "2024-07-30T20:37:02.815855", "image_code": "// Fork of \"Real time PBR Volumetric Clouds\" by robobo1221. https://shadertoy.com/view/MstBWs\n// 2020-11-02 19:24:26\n\n/*\nReal time PBR Volumetric Clouds by robobo1221.\nSingle scattering\nAlso includes volumetric light.\nhttp://shadertoy.com/user/robobo1221\n\nFirst ever somewhat PBR effect I decided to work on.\nIt uses the same algorithm to calculate the worldPosition as in: https://www.shadertoy.com/view/lstfR7\n\nFeel free to fork and edit it. (Credit me please.)\nHope you enjoy!\n*/\n\n#define VOLUMETRIC_LIGHT\n//#define SPHERICAL_PROJECTION\n\n#define cameraMode 1 \t\t\t\t\t//1 is free rotation, 2 is still camera but free sun rotation\n\n#define cloudSpeed 0.05\n#define cloudHeight 1600.0\n#define cloudThickness 500.0\n#define cloudDensity 0.03\n\n#define fogDensity 0.00001\n\n#define volumetricCloudSteps 16\t\t\t//Higher is a better result with rendering of clouds.\n#define volumetricLightSteps 8\t\t\t//Higher is a better result with rendering of volumetric light.\n\n#define cloudShadowingSteps 12\t\t\t//Higher is a better result with shading on clouds.\n#define volumetricLightShadowSteps 4\t//Higher is a better result with shading on volumetric light from clouds\n\n#define rayleighCoeff (vec3(0.27, 0.5, 1.0) * 1e-5)\t//Not really correct\n#define mieCoeff vec3(0.5e-6)\t\t\t\t\t\t//Not really correct\n\nconst float sunBrightness = 3.0;\n\n#define earthRadius 6371000.0\n\n//////////////////////////////////////////////////////////////////\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\nvec2 rsi(vec3 position, vec3 direction, float radius) {\n    float PoD = dot(position, direction);\n    float radiusSquared = radius * radius;\n\n    float delta = PoD * PoD + radiusSquared - dot(position, position);\n    if (delta < 0.0) return vec2(-1.0);\n          delta = sqrt(delta);\n\n    return -PoD + vec2(-delta, delta);\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define bayer32(a)  (bayer16(.5*(a))*.25+bayer2(a))\n#define bayer64(a)  (bayer32(.5*(a))*.25+bayer2(a))\n#define bayer128(a) (bayer64(.5*(a))*.25+bayer2(a))\n\n//////////////////////////////////////////////////////////////////\n\n#define cloudMinHeight cloudHeight\n#define cloudMaxHeight (cloudThickness + cloudMinHeight)\n\n#define sunPosition vec3(1.0, 1.0, 0.0)\n\nconst float pi = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\nconst float rLOG2 = 1.0 / log(2.0);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n\n\n/////////////////////////////////////\n// fisheye from TDM: https://www.shadertoy.com/view/XsfXWX\nvec3 getFishEye(vec2 uv, float level) {\n    float len = length(uv);\n    float a = len * level;\n    return vec3(uv / len * sin(a), -cos(a));\n}\n/////////////////////////////////////\n\nstruct positionStruct\n{\n\tvec2 texcoord;\n    vec2 mousecoord;\n    vec3 worldPosition;\n    vec3 worldVector;\n    vec3 sunVector;\n} pos;\n\nvec3 sphereToCart(vec3 sphere) {\n    vec2 c = cos(sphere.xy);\n    vec2 s = sin(sphere.xy);\n    \n    return sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p)\n{\n\tp = p * 2.0 - 1.0;\n    \n    vec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n    \n    #ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n    \n    return worldSpacePosition;\n}\n\nvoid gatherPositions(inout positionStruct pos, vec2 fragCoord, vec2 mouseCoord, vec2 screenResolution)\n{\n\tpos.texcoord = fragCoord / screenResolution;\n    pos.mousecoord = mouseCoord / screenResolution;\n    \n    pos.mousecoord = pos.mousecoord.x < 0.001 ? vec2(0.4, 0.64) : pos.mousecoord;\n    pos.mousecoord = vec2(0.25, 0.5);\n    vec2 rotationAngle = radians(vec2(360.0, 180.0) * pos.mousecoord - vec2(0.0, 0.0));\n    //rotationAngle = radians(vec2(0.0, -90.0));\n    mat3 rotateH = rotationMatrix(vec3(0.0, 1.0, 0.0), rotationAngle.x);\n    mat3 rotateV = rotationMatrix(vec3(1.0, 0.0, 0.0), -rotationAngle.y);\n    \n    pos.worldPosition = calculateWorldSpacePosition(pos.texcoord);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    pos.worldPosition = getFishEye(uv, 1.6);\n    \n    if (cameraMode == 1) {\n    \tpos.worldPosition = rotateH * (rotateV * pos.worldPosition);\n        // Sun position\n    \tpos.sunVector = normalize(sunPosition);\n    }\n    if (cameraMode == 2) {\n    \tpos.sunVector = normalize(calculateWorldSpacePosition(pos.mousecoord));\n    }\n    \n    pos.worldVector = normalize(pos.worldPosition);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define d0(x) (abs(x) + 1e-8)\n#define d02(x) (abs(x) + 1e-3)\n\nconst vec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessH(float depth){\n   \t\n    depth = depth * 2.0 + 0.1;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n    \n\treturn 100000.0 * depth;   \n}\n\nfloat calcParticleThicknessConst(const float depth){\n    \n\treturn 100000.0 / max(depth * 2.0 - 0.01, 0.01);   \n}\n\nfloat rayleighPhase(float x){\n\treturn 0.375 * (1.0 + x*x);\n}\n\nfloat hgPhase(float x, float g)\n{\n    float g2 = g*g;\n\treturn 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*x, -1.5));\n}\n\nfloat miePhaseSky(float x, float depth)\n{\n \treturn hgPhase(x, exp2(-0.000003 * depth));\n}\n\nfloat powder(float od)\n{\n\treturn 1.0 - exp2(-od * 2.0);\n}\n\nfloat calculateScatterIntergral(float opticalDepth, float coeff){\n    float a = -coeff * rLOG2;\n    float b = -1.0 / coeff;\n    float c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\nvec3 calculateScatterIntergral(float opticalDepth, vec3 coeff){\n    vec3 a = -coeff * rLOG2;\n    vec3 b = -1.0 / coeff;\n    vec3 c =  1.0 / coeff;\n\n    return exp2(a * opticalDepth) * b + c;\n}\n\n\nvec3 calcAtmosphericScatter(positionStruct pos, out vec3 absorbLight){\n    const float ln2 = log(2.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    float uDotW = dot(vec3(0.0, 1.0, 0.0), pos.worldVector);\n    \n\tfloat opticalDepth = calcParticleThickness(uDotW);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n         absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \t \n    vec3 absorbSun = abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhaseSky(lDotW, opticalDepth);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(lDotW);\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    vec3 sunSpot = smoothstep(0.9999, 0.99993, lDotW) * absorbView * sunBrightness;\n    \n    return (scatterSun * absorbSun + sunSpot) * sunBrightness;\n}\n\nvec3 calcAtmosphericScatterTop(positionStruct pos){\n    const float ln2 = log(2.0);\n    \n    float lDotU = dot(pos.sunVector, vec3(0.0, 1.0, 0.0));\n    \n\tfloat opticalDepth = calcParticleThicknessConst(1.0);\n    float opticalDepthLight = calcParticleThickness(lDotU);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = d02(absorbLight - absorbView) / d02((scatterLight - scatterView) * ln2);\n    \n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * 0.25;\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * 0.375;\n    \n    vec3 scatterSun = mieScatter + rayleighScatter;\n    \n    return (scatterSun * absorbSun) * sunBrightness;\n}\n\nfloat Get3DNoise(vec3 pos) \n{\n    float p = floor(pos.z);\n    float f = pos.z - p;\n    \n    const float invNoiseRes = 1.0 / 64.0;\n    \n    float zStretch = 17.0 * invNoiseRes;\n    \n    vec2 coord = pos.xy * invNoiseRes + (p * zStretch);\n    \n    vec2 noise = vec2(texture(iChannel0, coord).x,\n\t\t\t\t\t  texture(iChannel0, coord + zStretch).x);\n    \n    return mix(noise.x, noise.y, f);\n}\n\nfloat getClouds(vec3 p)\n{\n    p = vec3(p.x, length(p + vec3(0.0, earthRadius, 0.0)) - earthRadius, p.z);\n    \n    if (p.y < cloudMinHeight || p.y > cloudMaxHeight)\n        return 0.0;\n    \n    float time = iTime * cloudSpeed;\n    vec3 movement = vec3(time, 0.0, time);\n    \n    vec3 cloudCoord = (p * 0.001) + movement;\n    \n\tfloat noise = Get3DNoise(cloudCoord) * 0.5;\n    \t  noise += Get3DNoise(cloudCoord * 2.0 + movement) * 0.25;\n    \t  noise += Get3DNoise(cloudCoord * 7.0 - movement) * 0.125;\n    \t  noise += Get3DNoise((cloudCoord + movement) * 16.0) * 0.0625;\n    \n    const float top = 0.004;\n    const float bottom = 0.01;\n    \n    float horizonHeight = p.y - cloudMinHeight;\n    float treshHold = (1.0 - exp2(-bottom * horizonHeight)) * exp2(-top * horizonHeight);\n    \n    float clouds = smoothstep(0.55, 0.6, noise);\n          clouds *= treshHold;\n    \n    return clouds * cloudDensity;\n}\n    \nfloat getCloudShadow(vec3 p, positionStruct pos)\n{\n\tconst int steps = volumetricLightShadowSteps;\n    float rSteps = cloudThickness / float(steps) / abs(pos.sunVector.y);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = pos.sunVector * (cloudMinHeight - p.y) / pos.sunVector.y + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat getSunVisibility(vec3 p, positionStruct pos)\n{\n\tconst int steps = cloudShadowingSteps;\n    const float rSteps = cloudThickness / float(steps);\n    \n    vec3 increment = pos.sunVector * rSteps;\n    vec3 position = increment * 0.5 + p;\n    \n    float transmittance = 0.0;\n    \n    for (int i = 0; i < steps; i++, position += increment)\n    {\n\t\ttransmittance += getClouds(position);\n    }\n    \n    return exp2(-transmittance * rSteps);\n}\n\nfloat phase2Lobes(float x)\n{\n    const float m = 0.6;\n    const float gm = 0.8;\n    \n\tfloat lobe1 = hgPhase(x, 0.8 * gm);\n    float lobe2 = hgPhase(x, -0.5 * gm);\n    \n    return mix(lobe2, lobe1, m);\n}\n\nvec3 getVolumetricCloudsScattering(float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n    float beersPowder = powder(opticalDepth * log(2.0));\n    \n\tvec3 sunlighting = (sunColor * getSunVisibility(p, pos) * beersPowder) * phase * hPi * sunBrightness;\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nfloat getHeightFogOD(float height)\n{\n\tconst float falloff = 0.001;\n    \n    return exp2(-height * falloff) * fogDensity;\n}\n\nvec3 getVolumetricLightScattering(float opticalDepth, float phase, vec3 p, vec3 sunColor, vec3 skyLight, positionStruct pos)\n{\n    float intergal = calculateScatterIntergral(opticalDepth, 1.11);\n    \n\tvec3 sunlighting = sunColor * phase * hPi * sunBrightness;\n         sunlighting *= getCloudShadow(p, pos);\n    vec3 skylighting = skyLight * 0.25 * rPi;\n    \n    return (sunlighting + skylighting) * intergal * pi;\n}\n\nvec3 calculateVolumetricLight(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n    #ifndef VOLUMETRIC_LIGHT\n    \treturn color;\n    #endif\n    \n\tconst int steps = volumetricLightSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    vec3 increment = pos.worldVector * cloudMinHeight / clamp(pos.worldVector.y, 0.1, 1.0) * iSteps;\n    vec3 rayPosition = increment * dither;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = hgPhase(lDotW, 0.8);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, rayPosition += increment)\n    {\n        float opticalDepth = getHeightFogOD(rayPosition.y) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricLightScattering(opticalDepth, phase, rayPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return color * transmittance + scattering;\n}\n\nvec3 calculateVolumetricClouds(positionStruct pos, vec3 color, float dither, vec3 sunColor)\n{\n\tconst int steps = volumetricCloudSteps;\n    const float iSteps = 1.0 / float(steps);\n    \n    //if (pos.worldVector.y < 0.0)\n     //   return color;\n    \n    float bottomSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMinHeight).y;\n    float topSphere = rsi(vec3(0.0, 1.0, 0.0) * earthRadius, pos.worldVector, earthRadius + cloudMaxHeight).y;\n    \n    vec3 startPosition = pos.worldVector * bottomSphere;\n    vec3 endPosition = pos.worldVector * topSphere;\n    \n    vec3 increment = (endPosition - startPosition) * iSteps;\n    vec3 cloudPosition = increment * dither + startPosition;\n    \n    float stepLength = length(increment);\n    \n    vec3 scattering = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float lDotW = dot(pos.sunVector, pos.worldVector);\n    float phase = phase2Lobes(lDotW);\n    \n    vec3 skyLight = calcAtmosphericScatterTop(pos);\n    \n    for (int i = 0; i < steps; i++, cloudPosition += increment)\n    {\n        float opticalDepth = getClouds(cloudPosition) * stepLength;\n        \n        if (opticalDepth <= 0.0)\n            continue;\n        \n\t\tscattering += getVolumetricCloudsScattering(opticalDepth, phase, cloudPosition, sunColor, skyLight, pos) * transmittance;\n        transmittance *= exp2(-opticalDepth);\n    }\n    \n    return mix(color * transmittance + scattering, color, clamp(length(startPosition) * 0.00001, 0.0, 1.0));\n}\n\nvec3 robobo1221Tonemap(vec3 color)\n{\n    #define rTOperator(x) (x / sqrt(x*x+1.0))\n\n    float l = length(color);\n\n    color = mix(color, color * 0.5, l / (l+1.0));\n    color = rTOperator(color);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gatherPositions(pos, fragCoord, iMouse.xy, iResolution.xy);\n    if(pos.worldPosition.y < 0.0) {\n\n            // Transparent pixel if ray direction is not valid for screen coordinates\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n            return;\n    }\n    float dither = bayer16(fragCoord);\n    \n    vec3 lightAbsorb = vec3(0.0);\n\n    vec3 color = vec3(0.0);\n         color = calcAtmosphericScatter(pos, lightAbsorb);\n         color = calculateVolumetricClouds(pos, color, dither, lightAbsorb);\n         //color = calculateVolumetricLight(pos, color, dither, lightAbsorb);\n         color = pow(color, vec3(1.0 / 2.2));\n         color = robobo1221Tonemap(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1410, 1410, 1431, 1431, 1500], [1502, 1502, 1557, 1557, 1827], [2494, 2494, 2539, 2539, 3073], [3076, 3173, 3212, 3212, 3314], [3489, 3489, 3521, 3521, 3641], [3643, 3643, 3685, 3685, 3923], [3925, 3925, 4029, 4029, 5113], [5313, 5313, 5351, 5351, 5376], [5378, 5378, 5415, 5415, 5455], [5457, 5457, 5498, 5498, 5626], [5628, 5628, 5670, 5670, 5804], [5806, 5806, 5858, 5858, 5918], [5920, 5920, 5949, 5949, 5980], [5982, 5982, 6015, 6015, 6098], [6100, 6100, 6141, 6141, 6189], [6191, 6191, 6215, 6215, 6248], [6250, 6250, 6315, 6315, 6447], [6449, 6449, 6512, 6512, 6641], [6644, 6644, 6714, 6714, 7792], [7794, 7794, 7845, 7845, 8667], [8669, 8669, 8698, 8698, 9053], [9055, 9055, 9080, 9080, 9956], [9962, 9962, 10012, 10012, 10465], [10467, 10467, 10519, 10519, 10907], [10909, 10909, 10937, 10937, 11111], [11113, 11113, 11240, 11240, 11587], [11589, 11589, 11625, 11625, 11711], [11713, 11713, 11839, 11839, 12129], [12131, 12131, 12223, 12223, 13245], [13247, 13247, 13340, 13340, 14740], [14742, 14742, 14778, 14778, 14957], [14959, 14959, 15016, 15016, 15723]]}
{"id": "WddfR8", "name": "Swirly Spinner", "author": "UrbanClubProfessional", "description": "Remix of \"Swirl Spin\" by TekF.", "tags": ["2d", "swirl", "remix", "psychedelic", "glitch", "disco", "weird", "spin", "psychadelic"], "likes": 1, "viewed": 403, "published": 3, "date": "1604351042", "time_retrieved": "2024-07-30T20:37:03.722431", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    f = pow(texture(iChannel0, g / iResolution.xy),vec4(2.0/3.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    fragColor = texture(iChannel0, (floor( (fragCoord*.98 + iResolution.xy*.01 + (fragCoord-iResolution.xy/2.).yx*vec2(-.03,.03)) )+.5) / iResolution.xy);\n    fragColor = texture(iChannel0, (fragCoord*1.08 + iResolution.xy*.02 + (fragCoord-iResolution.xy/3.).yx*vec2(-.04,.04)) / iResolution.xy);\n    \n    float t = iTime*.6;\n\n    vec4 col = vec4(sin(t*vec3(23,21,27))*.6+.6,2);\n    float idx = .0+2.0*smoothstep( 7., 30., length( fragCoord - sin(vec2(21,23)*t)*70. - iResolution.xy/3. ) );\n    fragColor = mix( col, fragColor, idx );\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 110]]}
{"id": "wdcBzH", "name": "Smooth grey gradient no banding", "author": "wheybags", "description": "Smooth gradient at the top, naive banded at the bottom.\nI figured a super simple appoach like this would probably work to remove banding, but I didn't find anyone talking about it when I went looking. So I figured I'd just try it in shadertoy.", "tags": ["banding", "grayscale", "gradient", "gray", "grey", "colorbanding"], "likes": 2, "viewed": 370, "published": 3, "date": "1604342532", "time_retrieved": "2024-07-30T20:37:04.552212", "image_code": "float noise_scale = 0.003173828125;\n\n// Python code to find noise_scale. Binary searches for an optimal value.\n// Biased towards smaller numbers when the input looks good.\n// Checking values is done by a human. Loop until you get bored.\n/*\ndef get_direction(val):\n    d = \"\"\n    while d != \"b\" and d != \"n\" and d != \"g\":\n        d = input(\"How is {}? [b]andy/[n]oisy/[g]ood: \".format(val))\n\n    return d\n\nlower = 0 \nupper = 1 \n\nbest = None\n\nwhile True:\n    val = lower + (upper - lower) / 2 \n\n    direction = get_direction(val)\n    if direction == \"b\":\n        lower = val \n    else:\n        upper = val \n\n    if direction == \"g\":\n        best = val\n\n    \n    print(\"Range: {}-{}, best: {}\".format(lower, upper, best))\n*/\n\n\n// Extremely primitive rand function https://stackoverflow.com/a/4275343/681026\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n   \tfloat val = uv.x;\n    \n    // Scale the randomness to range across zero, so we don't change the overall tone on average\n    float val_with_noise = clamp(val + rand(uv)*noise_scale - noise_scale/2.0, 0.0, 1.0);\n    \n    float useVal = uv.y < 0.5 ? val : val_with_noise;\n    \n    \n    float distFromCentre = 0.5 - uv.y;\n    fragColor = abs(distFromCentre) < 0.001 ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(useVal, useVal, useVal, 1.0);\n    \n    // Quantise to 8-bit so the original error is visible even if you're using a hdr screen.\n    // I don't actually know if shadertoy uses floating point render targets, so I just put this\n    // in just in case. Can't test since I don't have a HDR screen.\n    fragColor = vec4(ivec4(fragColor*vec4(255.0, 255.0, 255.0, 255.0))) / vec4(255.0, 255.0, 255.0, 255.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[724, 804, 825, 825, 897], [900, 900, 957, 957, 1801]]}
{"id": "Ws3BzH", "name": "Costas5 MixedPrimeBase * pqfm", "author": "ollj", "description": "theres diagonal banding, and i do fourier analysis here to try to adress that:\nhttps://www.shadertoy.com/view/WsdBzH", "tags": ["noise", "dither", "bluenoise", "costas", "costasarray", "patternfree"], "likes": 3, "viewed": 373, "published": 3, "date": "1604334545", "time_retrieved": "2024-07-30T20:37:05.575476", "image_code": "//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animateable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//   self: https://www.shadertoy.com/view/Ws3BzH\n//parent0: https://www.shadertoy.com/view/tstBRr\n//parent1: https://www.shadertoy.com/view/Wsdfzr\n//parent2: https://www.shadertoy.com/view/tdjfzR\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\n/*\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n\n\nlist of primes \n(stop at the number, where either\n, i find no good enough costasArray, or take to loong to find one)\n2,    //will skip this, cause its costasArray is too similar to [3]\n3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n101\t103\t107\t109\t113\t127\t131\t137\t139\t149\t151\t157\t163\t167\t173\n\t179\t181\t191\t193\t197\t199\t211\t223\t227\t229\t233\t239\t241\t251\t257\t263\t269\t271\t277\t281\n\t283\t293\t307\t311\t313\t317\t331\t337\t347\t349\t353\t359\t367\t373\t379\t383\t389\t397\t401\t409\n\t419\t421\t431\t433\t439\t443\t449\t457\t461\t463\t467\t479\t487\t491\t499\n*/\n\n\n    \n\n/*\n\n5,3\n\nthe base (count of numbers) is the product of all larger primes\nand the smallest prime multiplies that amount by itself\n\nlets take the bases 3,5,7\n\nand its value       131 \none   threes means we counted ober 5*7 one   times, so the sum is +=1*5*7\nthree fives  means we counted over   7 three times, so the sum is +=3*  7\none   sevens                                      , so the sum is +=1\n->  5*7+3*7+1 == (5+3)*7+1 = 8*7+1=57\n, now, this is silly, while bases are very small, lets go bigger\n, also remember, a base os a mod(), base 10 never reaches 10, cause it includes 0\n\nlets do a 7 primes digit, with the bases\n3, 5, 7, 11, 13, 17, 19, \nand its\n2  3  3  9   8   0    11\n\nthe sum is\n0\n+ 2*5* 7* 11* 13* 17* 19\n+   3* 7* 11* 13* 17* 19\n+      3* 11* 13* 17* 19\n+          9* 13* 17* 19\n+              8* 17* 19\n+                  0* 19\n+                     11\n=4382152\n\n\n\n\n//lets see how many bits we need for the largest value of N primes, and stay below 32 bits.\n\n3, 5, 7, 11, 13, 17, 19, 23\n0\n+ 3*5* 7* 11* 13* 17* 19*23\n+   4* 7* 11* 13* 17* 19*23\n+      6* 11* 13* 17* 19*23\n+         10* 13* 17* 19*23\n+             12* 17* 19*23\n+                 16* 19*23\n+                     18*23\n+                        22\n=148728579 (still < 32^2-1 bit range)\n\n3, 5, 7, 11, 13, 17, 19, 23,29\n0\n+ 3*5* 7* 11* 13* 17* 19*23*29\n+   4* 7* 11* 13* 17* 19*23*29\n+      6* 11* 13* 17* 19*23*29\n+         10* 13* 17* 19*23*29\n+             12* 17* 19*23*29\n+                 16* 19*23*29\n+                     18*23*29\n+                        22*29\n+                           28\n4313128819(needs 33 bits)\n\nin retrospect, lets also ditch the 3 and 5, and get the 31 instead\n 7, 11,13,17,19,23,29,31\n0\n+ 6*11*13*17*19*23*29*31\n+   10*13*17*19*23*29*31\n+      12*17*19*23*29*31\n+         16*19*23*29*31\n+            18*23*29*31\n+               22*29*31\n+                  28*31\n+                     30\n6685349670 (needs 33 bits), ditch 7 and 11, take in 37\n\n\n  13,17,19,23,29,31,37\n0\n+ 12*17*19*23*29*31*37\n+    16*19*23*29*31*37\n+       18*23*29*31*37\n+          22*29*31*37\n+             28*31*37\n+                30*37\n+                   36\n=3212440750  (within 32 bit AND it is 74% of its max value 4294967295\n*/\n\n#define arrLen 7\nint mixedPrimeBase(int[arrLen] a //[a] stores a number in bases [b] (different base foreach digit)\n){int b[arrLen]=int[arrLen](37,31,29,23,19,17,13);\n ;int c=1,r=0;//CumilativeBaseFactor , accumulatorToReturn\n ;for(int i=0;i<arrLen;i++){;r+=(a[i]-1)*c;c*=b[i];}return r;}\n\n/*\ntheres another approach to this, with more prime bases, but each base is only binary.\nsee [boolean but jittery]\nthis may actually be much more memory efficient and cooler in animation\nits largest value would be \"111111111111111...\" as the sum of many primes. (no multiplication in here)\nbut that would have 32 or 64 (or more) primes.\nwe just chose arbitiary large primes (not necessarily many small ones)\nas long as the sum of all primes (sum < (pow(2,32)-1)) we will be fine.\n\n*/\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\n\ncostas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic\n, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em\n\n\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n#define animatePaletteSpeed .9\n\n#define mode int(5.*iMouse.y/iResolution.y)\n//#define mode 4\n\n//mode 2 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 9 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 3\n\n//place multiple smaller tiles (important to expose some pattern)\n#define MultiTile 5.\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n\n//way too high exponents in this one.\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\n/**/\n\n\nint ae(int a){    \nint c[]=int[3](1,3,2);\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)   \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)    \n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n//;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//all costas arrays of size 19 are (no diagonal symmetry at all):\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//----great and sdiagonal\n//;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);\n/**/\n;return c[(       a  )%period]\n;//return c[(period-a-1)%period]//reverse\n;}    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\nint gpo(int a){int b[arrLen]=int[7](37,31,29,23,19,17,13);return b[a];}\n\nint getCostasOf(int a,int p){//return costas at Position of Array#\n if(a<4){\n  if(a<2){\n   if(a==0){int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);return c[p%37]\n     ;}else{int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);return c[p%31];}\n     }else{\n   if(a==2){int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);return c[p%29]\n     ;}else{int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);;return c[p%23];}\n}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);return c[p%19];}\n   if(a==5){int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);;return c[p%17];}\n           {int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);;return c[p%13];}}}\n\nint Cs(ivec2 u,int a){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //tile to positive infinity\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)//-1??\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r+=(iFrame/4)%per\n ;r=r%per;\n ;return r;}\n\nvec4 CostasNoise(ivec2 u){\n ;u/=2\n /*\n ;int[arrLen] m=int[arrLen](0,0,0,0,0,0,0);\n ;m[0]=Cs(u,0);\n ;m[1]=Cs(u,1);\n ;m[2]=Cs(u,2);\n ;m[3]=Cs(u,3);\n ;m[4]=Cs(u,4);\n ;m[5]=Cs(u,5);\n ;m[6]=Cs(u,6);\n ;float a=float(mixedPrimeBase(m))/float(3212440750)//first attempt failed*/\n     //VERY exponential weights seem silly mow, but the precison would be neat.\n     \n \n ;float r=0.;\n ;float f[]=float[7](1.,2.,3.,2.,.4,.5,.6)//weights (should be exponential)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;r+=float(Cs(u,0))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,1))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,2))/float(gpo(2))*f[2];\n ;r+=float(Cs(u,3))/float(gpo(3))*f[3];\n ;r+=float(Cs(u,4))/float(gpo(4))*f[4];\n ;r+=float(Cs(u,5))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6))/float(gpo(6))*f[6];\n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])\n ;return vec4(a,a,a,1);\n}\n\n/*\nvec4 getCostasOfFloat(vec2 u //parent main function as backup subroutine\n){//u=u.yx\n ;int m=mode\n ;if (m==4)m=int(iTime+2.)%3;  \n ;if(m==0)m=2 ;else if (m==2)m=0 //swap mode 0 and 2\n ;vec3 c=vec3(0)\n ;ivec2 U=ivec2(MultiTile*u*float(period)/iResolution.y)\n ;if(u.x<float(period-1)*zoom\n   &&u.y<float(period-1)*zoom //if not the blue part\n ){\n  #ifdef MultiTile\n  ;U=U%period\n  #endif\n  ;//U=U.yx                          //sqivel domains\n  //;u*=float(period)/iResolution.y\n  ;//if(u.x<2.)c=vec3(1);\n  ;float f=0.\n  ;int a=0\n  ;if(m==0         //the [period-] is just for symmetry, actually optional\n  ){if(ae(U.y)==period-U.x)a=period/2;//black or grey  \n  }else{\n   ;a=ae(U.y)+(U.x)       \n   //[period-] is just for symmetry, actually optional\n   ;a=period-a%period   //;if(a>period)a-=period //single overflow   (no mod needed) \n   ;if(m>1\n   ){a=ae(a)//+(U.y)     //+1 ae() recursion the +=y just removes symmetry, is semi arbitiary naoise\n    ;a+=ae(period-1)\n    ;a=a%period;}}\n  ;f=float(a)/float(period) \n      \n  #ifdef animatePaletteSpeed\n  ;if(m!=0){f-=fract(iTime*animatePaletteSpeed)////cos(iTime)*.5+.5\n   ;if(f<0.)f+=1.;}\n  #endif\n  ;c=mix(vec3(f,f,f),mix(vec3(0,.4,1),vec3(1,.4,0),f),iMouse.x/iResolution.x)\n ;}\n //below code highlights lower right triangle points green \n //IFF they have a diagonal mirror\n ;if(period-U.x-1>U.y\n    ){if(ae(U.y)==period-U.x\n     ){if(ae((period-U.x-1))==U.y+1)\n         c+=vec3(0,1,0);}}//bottom left mirroreds marked white\n  //IFF they have a diagonal mirror\n ;if(U.x<U.y\n    ){\n     ;if(ae(U.y)==period-U.x\n     ){\n     if(ae(U.x)==period-U.y)\n         c+=vec3(0,1,0);}}//top left mirroreds marked white /**/\n// ;return vec4(c,1);}\n\nvoid mainImage(out vec4 O, vec2 u\n){//O=getCostasOfFloat(u);\n ;//u*=4.\n ;u/=1.5\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;O=CostasNoise(ivec2(u)+scroll);\n }", "image_inputs": [], "common_code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-SYMMETRICAL costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 3 are:\nint[3](1,3,2);\nall* symmetrical costas arrays of order 5 are: (all length 5 ones are banding, one hjust hides it thebest)\n//;int c[]=int[5](3,5,1,4,2);//LEAST NOTICEABLE diagonal banding (also in reverse)    \n//int c[]=int[5](5,2,4,3,1);//diagonal banding (also in reverse)   \nall* symmetrical costas arrays of order 7 are:\n//;int c[]=int[7](3,7,1,4,6,5,2);//diagonal great (reversed to kill banding)\n//;int c[]=int[7](1,2,7,4,6,5,3);//diagonal meh mixer   \n//;int c[]=int[7](1,7,3,4,6,5,2);//diagonal bad zigzag\n//;int c[]=int[7](2,1,6,4,7,3,5);//diagonal good (minor band)  \n//;int c[]=int[7](3,6,1,7,5,2,4);//diagomnal great (minor band)\n//;int c[]=int[7](2,1,5,7,3,6,4);//diagonal meh (minor band)\n//;int c[]=int[7](1,2,7,5,4,6,3);//diagonal bad onedirectional  \n//;int c[]=int[7](4,7,3,1,6,5,2);//diagonal minor band  (reversed to kill banding)\n//;int c[]=int[7](5,7,4,3,1,6,2);//2,6,1,3,4,7,5);//diagonal bad (even after reversing)\n//;int c[]=int[7](5,3,7,4,6,2,1);//1,2,6,4,7,3,5);//diagonal horrible band (even after reversing)\nall!! symmetrical costas arrays of order 11 are:\n//;int c[]=int[11](1,10,4,3,8,11,9,5,7,2,6);//diagonal great    \n//;int c[]=int[11](1,7,11,6,8,4,2,5,10,9,3);//diagonal great rainy\n//;int c[]=int[11](3,10,1,9,6,5,7,11,4,2,8);//diagonal good (jitters)\n//;int c[]=int[11](1,6,8,9,4,10,3,7,5,2,11);//diagonal bad\n//;int c[]=int[11](1,7,5,8,10,4,9,6,2,3,11);//diagonal horrible band\n\n//all symmetrical costas arrays of size 13 are:\n//;int c[]=int[13](1,10,3,9,6,5,7,12,4,2,13,8,11);//diagonal good\n    \n//all symmetrical costas arrays of size 17 are:     \n;int c[]=int[17](2,1,15,7,5,11,4,16,13,17,6,14,9,12,3,8,10);//diagonal great\n//;int c[]=int[17](1,7,15,11,8,10,2,5,17,6,4,13,12,16,3,14,9);//diagonal good rain\n//;int c[]=int[17](1,12,14,15,6,16,11,4,7,3,9,13,2,10,8,5,17);//diagonal bad\n//;int c[]=int[17](1,11,15,7,12,13,16,6,3,5,14,10,8,2,9,4,17);//diagonal horrible band\n//;int c[]=int[17](2,6,3,13,14,1,9,5,11,4,7,16,10,8,15,17,12);//diagonal horrible band\n\n//0 symmetrical costas arrays of size 19, only 2 in total\n//;int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);//meh\n//;int c[]=int[19](1,13,12,18,11,15,17,7,10,5,14,19,16,8,6,2,9,3,4);//bad\n\n//all!! symmetrical costas arrays of size 23 are:\n//;int c[]=int[23](1,15,10,4,5,12,21,23,11,3,9,6,14,13,2,19,22,18,16,20,7,17,8);//diagonal meh\n//;int c[]=int[23](5,3,2,20,1,12,9,19,7,15,21,6,22,17,10,23,14,18,8,4,11,13,16);//diagonal bad\n//;int c[]=int[23](1,16,13,11,17,8,19,22,12,7,21,15,20,5,9,18,14,2,10,3,4,6,23);//diagonal horrible    \n//;int c[]=int[23](2,9,14,4,10,12,16,17,1,21,8,18,7,19,22,13,11,6,3,20,5,23,15);//diagonal horrible    \n\nall!! symmetrical costas arrays of order 29 are:\n//;int c[]=int[29](3,11,1,10,25,19,14,16,20,4,2,15,27,7,12,8,29,18,6,9,26,23,22,28,5,21,13,24,17);//diagonal great\n//;int c[]=int[29](7,20,28,8,25,15,1,4,23,27,22,14,16,12,6,13,18,17,26,2,29,11,9,24,5,19,10,3,21);//diagonal okay\n//;int c[]=int[29](1,17,22,13,19,23,24,27,11,8,25,15,28,7,18,6,26,12,21,3,5,20,16,14,9,2,10,4,29);//diagonal bad\n//;int c[]=int[29](2,1,8,12,25,15,18,3,13,22,17,4,9,28,6,29,11,7,21,27,19,10,26,24,5,23,20,14,16);//diagonal bad\n//;int c[]=int[29](6,26,23,28,5,8,27,1,16,14,7,18,4,21,12,20,2,15,3,9,10,24,19,29,25,17,11,13,22);//diagonal horrible (vetically linear)\n\nall!! costas arrays of order 31 are: (only one asymmetrical one)\n;int c[]=int[31](1,28,20,27,17,18,21,30,26,14,9,25,11,31,29,23,5,13,6,16,15,12,3,7,19,24,8,22,2,4,10);//\n \nall KNOWN symmetrical costas arrays of order 37 are:\n//;int c[]=int[37](19,21,35,31,28,11,36,18,33,22,6,37,17,20,29,23,13,8,1,14,2,10,16,27,34,26,24,5,15,32,4,30,9,25,3,7,12);//diagonal meh (reverse is banded)\n//;int c[]=int[37](14,9,32,29,22,16,33,20,2,15,27,18,21,1,10,6,36,12,37,8,13,5,26,24,34,23,11,30,4,28,35,3,7,25,31,17,19);//diagonal bad (reverse is banded)\n\n\nall* symmetrical costas arrays of order 2 are: (skipped, too small)\n,1,2\nall* symmetrical costas arrays of order 4 are: (skipped, non prime)\n,1,2,4,3\nall* symmetrical costas arrays of order 6 are: (skipped, non prime)\n,1,4,5,3,2,6\n,1,5,3,6,2,4\n,1,6,3,5,4,2\n,1,6,4,3,5,2\n,2,4,5,1,6,3\nall* symmetrical costas arrays of order 8 are: (skipped, non prime)\n,1,5,8,4,2,7,6,3);\n,1,7,3,8,6,5,2,4);\n,1,7,4,3,5,8,2,6);\n,3,5,1,8,2,7,6,4);\nall* symmetrical costas arrays of order 9 are: (skipped, non prime)\n,1,4,6,2,9,3,8,7,5);\n,2,1,5,8,3,9,7,4,6);\nall* symmetrical costas arrays of order 10 are: (skipped, non prime)\n,1,7,4,9,3,5,8,6,2,10\n,2,1,9,4,5,8,10,6,3,7\n,2,6,8,1,9,5,3,4,10,7\n,2,8,9,4,1,3,7,5,10,6\n,3,9,1,4,5,10,8,7,2,6\n,3,9,7,8,4,1,6,10,2,5,\nall* symmetrical costas arrays of order 12 are: (skipped, non prime)\n,1,2,8,12,7,9,5,3,6,11,10,4\n,1,2,11,5,4,9,12,10,6,8,3,7\n1,4,11,2,10,7,6,8,12,5,3,9\n3,6,1,12,10,2,7,9,8,5,11,4\nall* symmetrical costasArrays of order 16 are  (skipped, non prime)\n1,13,3,16,14,8,10,6,15,7,12,11,2,5,9,4\n3,12,1,4,10,6,14,9,8,5,15,2,16,7,11,13\n3,13,4,15,12,6,10,2,7,8,11,1,14,16,9,5\n6,14,10,7,9,1,4,16,5,3,12,11,15,2,13,8\nall* symmetrical costasArrays of order 27 are (skipped, non prime)\n1,25,19,5,4,12,10,16,26,7,18,6,23,27,24,8,21,11,3,22,17,20,13,15,2,9,14\n3,9,1,8,13,15,19,4,2,20,11,25,5,17,6,27,14,24,7,10,26,23,22,18,12,21,16\n3,24,10,26,20,15,13,23,14,1,8,4,22,19,21,2,5,25,9,17,6,7,11,16,27,12,18\n4,17,21,9,11,16,25,12,1,7,26,22,14,15,13,20,23,3,24,6,18,8,2,27,10,5,19\n6,10,23,13,16,1,11,20,15,2,7,26,4,27,9,5,19,25,17,8,24,22,3,21,18,12,14\n6,16,20,12,14,7,1,25,8,17,18,26,11,23,10,24,15,13,3,19,22,27,5,2,9,4,21\n6,23,14,8,21,1,26,4,22,20,12,11,16,3,17,13,15,24,27,10,5,9,2,18,25,7,19\n\n\n    \n\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are: (skipped, non prime)\n,1,23,14,12,18,26,30,20,25,11,10,4,16,3,21,13,22,5,19,8,15,17,2,28,9,6,29,24,27,7\n,11,22,5,13,23,10,2,26,29,15,19,20,14,4,6,21,18,27,1,30,25,7,3,9,16,28,17,8,24,12\n,12,24,20,17,2,9,29,3,16,4,28,18,19,27,22,6,10,1,30,8,14,25,11,5,15,7,21,23,26,13\n,13,26,2,21,29,4,9,11,15,27,12,8,17,18,7,22,1,30,20,23,6,24,19,16,10,3,25,5,28,14\n\na symmetrical costas array of order 35 is: (skipped, non prime)\n,1,12,7,27,32,30,3,24,31,17,19,2,16,29,20,13,10,35,11,15,23,33,21,8,26,25,4,34,14,6,9,5,22,28,18\n,\na symmetrical costas array of order 65 is: (skipped, non prime)\n,1,29,46,16,24,37,17,22,12,63,55,9,15,42,13,4,7,26,44,56,50,8,49,5,40,18,32,34,2,54,51,27,65,28,53,57,6,39,38,25,48,14,59,19,62,3,58,41,23,21,31,61,35,30,11,20,36,47,43,64,52,45,10,60,33\n\na symmetrical costas array of order 99 is: (skipped, non prime)\n1,33,94,11,21,59,40,85,39,44,4,75,88,36,73,56,60,45,67,61,5,24,55,22,87,30,92,64,37,26,49,51,2,79,38,14,29,35,9,7,97,63,89,10,18,70,62,76,31,99,32,78,65,74,23,16,96,71,6,17,20,47,42,28,53,95,19,69,68,46,58,86,15,54,12,48,82,52,34,91,98,77,93,90,8,72,25,13,43,84,80,27,83,3,66,57,41,81,50\n\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8684, 8684, 8698, 8698, 9914], [10346, 10346, 10361, 10361, 10417], [10419, 10419, 10448, 10485, 11293], [11295, 11295, 11317, 11317, 11808], [11810, 11810, 11836, 11836, 12904], [14596, 14596, 14632, 14656, 15095]]}
{"id": "wscBz8", "name": "Sine Ripples", "author": "oneshade", "description": "A shader I did for fun after I saw one of the Coding Train's challenge's.", "tags": ["ripples", "sinewave"], "likes": 7, "viewed": 221, "published": 3, "date": "1604332182", "time_retrieved": "2024-07-30T20:37:06.439167", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    uv *= 15.0;\n\n    float size = 0.25 + 0.25 * sin(length(floor(uv) * 0.5) - iTime);\n    color += smoothstep(0.1, 0.0, length(fract(uv) - 0.5) - size);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 349]]}
{"id": "tscBz8", "name": "Smooth Union Inclusive of Colors", "author": "oneshade", "description": "An experiment with blending colors alongside SDFs. I solved the shading issue. It had to do with the colors not being clamped (the pow function was the culprit).", "tags": ["raymarching", "colors", "smoothunion"], "likes": 57, "viewed": 1765, "published": 3, "date": "1604331776", "time_retrieved": "2024-07-30T20:37:07.292885", "image_code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n\nI've replaced the sdCuboid() and sdCylinder() distance functions with the exact ones\nfrom Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions)\nfor nicer blending.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface SmoothUnion(in Surface surface1, in Surface surface2, in float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (surface2.signedDistance - surface1.signedDistance) / smoothness, 0.0, 1.0);\n    return Surface(mix(surface2.ambientColor, surface1.ambientColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.diffuseColor, surface1.diffuseColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.specularColor, surface1.specularColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.shininess, surface1.shininess, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.signedDistance, surface1.signedDistance, interpolation) - smoothness * interpolation * (1.0 - interpolation));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec4 metashapeInfo1 = vec4(vec2(sin(iTime * 0.75), cos(iTime * 1.0)) * 200.0, 0.0, 80.0);\n    vec4 metashapeInfo2 = vec4(vec2(cos(iTime * 1.0), cos(iTime * 1.25)) * 200.0, 0.0, 100.0);\n    vec4 metashapeInfo3 = vec4(vec2(sin(iTime * 1.25), cos(iTime * 0.5)) * 200.0, 0.0, 120.0);\n\n    Surface metashape1 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(1.0, 0.0, 0.0),\n                                 vec3(1.0, 1.0, 1.0), 8.0,\n                                 sdCuboid(Rotate(Translate(p, metashapeInfo1.xyz), vec3(0.0, 0.0, iTime * 40.0)), 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w) - 10.0);\n\n    Surface metashape2 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.0, 1.0, 0.0),\n                                 vec3(1.0, 1.0, 1.0), 64.0,\n                                 sdCylinder(Rotate(Translate(p, metashapeInfo2.xyz), vec3(0.0, 0.0, iTime * -20.0)), 2.0 * metashapeInfo2.w, metashapeInfo2.w) - 10.0);\n\n    Surface metashape3 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.0, 0.0, 1.0),\n                                 vec3(0.0, 0.0, 0.0), 0.0,\n                                 sdSphere(Translate(p, metashapeInfo3.xyz), metashapeInfo3.w));\n\n    return SmoothUnion(metashape1, SmoothUnion(metashape2, metashape3, 70.0), 70.0);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n    return illuminationAmbient + illuminationDiffuse + illuminationSpecular;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, ray, normal);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(Ray(rayOrigin, rayDirection));\n    fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1106, 1143, 1206, 1206, 1319], [1321, 1321, 1374, 1374, 1496], [1498, 1498, 1537, 1537, 1565], [1567, 1615, 1699, 1699, 2525], [2527, 2547, 2585, 2585, 2605], [2607, 2607, 2642, 2642, 3253], [3255, 3282, 3311, 3311, 4647], [4649, 4698, 4731, 4731, 5151], [5153, 5208, 5275, 5275, 5809], [5811, 5832, 5859, 5859, 6525], [6527, 6560, 6615, 6615, 6989]]}
{"id": "WstfRr", "name": "[]Flythrough", "author": "Catzpaw", "description": "Full screen recommended.", "tags": ["raymarching", "music"], "likes": 43, "viewed": 1477, "published": 3, "date": "1604309595", "time_retrieved": "2024-07-30T20:37:08.292213", "image_code": "//--- Flythrough\n// by Catzpaw 2020\n\n#define ITER 192\n#define EPS 1e-5\n#define NEAR 0.0\n#define FAR 120.0\n\n// \"Log-Bisection Tracing\" by Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat trace(vec3 ro,vec3 rd,out float n){\n    float t=NEAR,lt=t;\n    vec3 p=ro+rd*t;\n    float d=map(p);\n    bool s=d>0.?true:false;\n    bool b=false;\n    for(int i=ZERO;i<ITER;i++){\n        if(abs(d)<EPS*t||t>FAR)break;            \n       \tif((d>0.)!=s){b=true;break;}\n        lt=t;\n        t+=d>.5?d*.5:log(abs(d)+1.);\n        p=ro+rd*t;\n       \td=map(p);\n       \tn+=.6;\n    }\n    if(b){\n        float m=0.;\n        p=ro+lt*rd;\n        s=map(p)>0.?true:false;;\n        for(int i=ZERO;i<6;i++){ \n            m=(lt+t)*.5;\n            p=ro+rd*m;\n            d=map(p);\n            if(abs(d)<EPS*t)break;\n            (d<0.)==s?t=m:lt=m;\n        }\n        t=(lt+t)*.5;\n    }\n    return t;\n}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 rd=vec3(uv,-.4);\n\tfloat z=-(iTime+CUE)*2.2;\n\tvec3 ro=camPath(z);\n\tvec3 cr=normalize(camPath(z-2.5)-camPath(z-3.));\n\trd.xz*=rot(cr.x*1.8);\n\trd.yz*=rot(cr.y*1.5);\n\tfloat n=0.,v=trace(ro+vec3(0,-0.2,0),rd,n)/FAR;n/=float(ITER);\n\tfragColor=vec4(mix(hsv(1.-n,1.-n,v),vec3(1),n),v);\n}\n\n//VR\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir){\n    vec2 uv=(fragCoord.xy-vec2(.25,.5)*iResolution.xy)/iResolution.y;\n\tfloat z=-(iTime+CUE)*2.2;\n    vec3 rd=fragRayDir;\n\tvec3 ro=camPath(z)+fragRayOri;\n\tvec3 cr=normalize(camPath(z-2.5)-camPath(z-3.));\n\trd.xz*=rot(cr.x*1.8);\n\trd.yz*=rot(cr.y*1.5);\n\tfloat n=0.,v=trace(ro+vec3(0,-0.2,0),rd,n)/FAR;n/=float(ITER);\n\tfragColor=vec4(mix(hsv(1.-n,1.-n,v),vec3(1),n),1);\n}\n\n", "image_inputs": [], "sound_code": "//--- Flythrough\n// by Catzpaw 2020\n\n//Sound:music & SFX\n\nconst bool enableDroneSound=true;\nconst bool enableMusic=true;\n\n//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=8.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=92.;\nconst float noteseed=31.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=10;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x10000000u,0x10000000u,0x10000000u,0x10000000u,  //10-13 chord\n    0x180BA008u,0x10000000u,0x10000000u,0x10000000u,  //14-17 bass\n    0x150A150Au,0x10000000u,0x10000000u,0x10000000u,  //18-1B power sd\n    0xB9B9B9B9u,0xB9B9B9B9u,0xB9B9B9B9u,0xB9B9B9B9u); //1C-1F bd+hh\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11000118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11188118u,\n    0x11000118u,0x11000118u,0x11000118u,0x11000118u);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u,\n    0x11000114u,0x11000114u,0x11000114u,0x11000114u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000110u,0x11000510u,0x11000710u,0x11000312u,\n    0x11000110u,0x11000510u,0x11000210u,0x11000613u,\n    0x11000110u,0x11000510u,0x11000710u,0x11000312u,\n    0x11000110u,0x11000510u,0x11000210u,0x11000613u);\nconst uint[16] seq5=uint[]( //backing\n    0x1100010cu,0x1100050cu,0x1100070cu,0x130d830eu,\n    0x1100010cu,0x1100050cu,0x1100020cu,0x160d860fu,\n    0x1100010du,0x1100050cu,0x1100070du,0x130d830eu,\n    0x1100010du,0x1100050cu,0x1100020du,0x160d860fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000101u,0x11000502u,0x11000703u,0x11000304u,\n    0x11000101u,0x11000502u,0x11000203u,0x11000605u,\n    0x11000106u,0x11000507u,0x11000708u,0x11000309u,\n    0x11000106u,0x11000507u,0x1100020Au,0x1100060Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//\"FLYTHROUGH\" INSTRUMENTS\nfloat powersd(float x){return osc_nesnoise(x,11);}\nfloat lowsd(float x){return osc_nesnoise(x,13);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise powersd,lowsd\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?powersd(n.x)*.7:0.;\n    o+=(n.y==2.)?lowsd(n.x)*.3:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+48.03)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+48.02)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+48.01)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 synth\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+48.05)*n.x,n.x)*.2:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 bell\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+60.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    o+=  track1(t,l,s); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s); //TRACK 2 bassdrum,lowconga,hiconga\n    o+=  track3(t,l,s); //TRACK 3 bass\n    o+=  track4(t,l,s); //TRACK 4 chord\n    o+=  track5(t,l,s); //TRACK 5 backing\n    o+=  track6(t,l,s); //TRACK 6 melody\n}\n\n//DRONE SOUND\nvec2 drone(float x,float p,float s){\n    float fl=freq(70.01+s)*mod(x,.055),fr=freq(70.03+s)*mod(x,.054);\n    x=fract(x*5.)*.2;\n    float vl=.15-smoothstep(-1.,0.,p-1.)*.15,vr=smoothstep(0.,1.,p+1.)*.15;\n\treturn vec2((osc_duty(fl,.7)+osc_duty(fl*.5,.7)+osc_nesnoise(x,8))*vl,\n                (osc_duty(fr,.7)+osc_duty(fl*.5,.7)+osc_nesnoise(x,8))*vr);\n}\nvoid droneSound(float x,float t,inout vec2 o){\n    vec3 ro=camPath(t)+vec3(0,-.2,0),rd=vec3(0,0,-.5);\n\tvec3 cr=normalize(camPath(t-2.5)-camPath(t-3.));\n    float s=length(camPath(t-2.)-camPath(t-3.))*2.;\n    float d=0.;\n    //x=fract(x*8.)*.125;\n    o+=drone(x,0.,s);\n    vec3 sd=vec3(-.5,-.1,-.5);\n\tsd.xz*=rot(cr.x*1.8);\n\tsd.yz*=rot(cr.y*1.5);\n    d=abs(map(ro+sd)*10.);\n    o+=drone(x,-0.8,s+s)/max(d,1.);\n    sd=vec3(.5,-.1,-.5);\n\tsd.xz*=rot(cr.x*1.8);\n\tsd.yz*=rot(cr.y*1.5);\n    d=abs(map(ro+sd)*10.);\n    o+=drone(x,0.8,s+s)/max(d,1.);\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    6\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.8\n#define DELAY_TIME      0.15\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    if(enableDroneSound)droneSound(time,-(time+CUE)*2.2,o);\n    time-=start*60./bpm;\n    if(time>=0. && enableMusic){\n    \trender(time,l,o,true);\n    \tfor(int i=0;i<DELAY_REPEAT;i++){\n    \t    time-=r;\n    \t    if(time<0.)continue;\n    \t    vec2 a=vec2(0);\n    \t    render(time,l,a,false);\n    \t    d*=DELAY_FEEDBACK;\n    \t    r+=DELAY_TIME;\n    \t    o+=a*d;\n    \t}\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n\n", "sound_inputs": [], "common_code": "//--- Flythrough\n// by Catzpaw 2020\n\n//Common:scene SDF for Image & Sound\n\n#define CUE 0.\n\n#define OCT 4\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nfloat sdCube(vec3 p,float s){p=abs(p)-s;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.)-.03;}\nfloat sdCubeField(vec3 p,float s,float i){p=mod(p,i)-i*.5;return sdCube(p,s);}\nfloat sdBeam(vec3 p,float s){p=abs(p)-s;return length(max(p.xy,0.))+min(max(p.x,p.y),0.)-.03;}\nvec3 camPath(float t){\n\treturn vec3(sin(t*.131)*5.+sin(t*.197)*5.+sin(t*.32)*3.,sin(t*.107)*4.+sin(t*.104)*4.+sin(t*.317)*3.,t);\n}\nfloat map(vec3 p){\n\tfloat d=0.,ld=0.,s=1.;\n\tfloat t=min(sdBeam(p-camPath(p.z),.5),sdBeam(p-camPath(p.z+60.),1.5));\n          t=min(t,sdBeam(p-camPath(p.z+280.),4.));\n\tld=max(-sdCubeField(p+15.,4.95,30.),d);\n\tfor(int i=0;i<OCT;i++){\n\t\tvec3 q=vec3(sin(s*180.)*50.,sin(s*190.)*50.,sin(s*154.)*50.);\n\t\td=max(-sdCubeField(p+q,s*.3,s),ld);\n\t\tld=d;s*=1.;p*=s*vec3(0.801,1.003,0.901);\n\t}\n\td=max(-t,d);\n\treturn d;\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 185, 226, 226, 871], [873, 880, 936, 936, 1275], [1277, 1282, 1370, 1370, 1737]]}
{"id": "Ws3fR8", "name": "Fractal jungle", "author": "jarble", "description": "This is an another edit of my [url=https://www.shadertoy.com/view/WdGyDc]\"Rainbow shards\"[/url] fractal.", "tags": ["fractal", "jungle", "rainforest"], "likes": 5, "viewed": 355, "published": 3, "date": "1604283798", "time_retrieved": "2024-07-30T20:37:09.166874", "image_code": "\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c1 = 3.0;\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(-iTime+sin(t1/c1),sin(t1/c1)*c1,cos(t1/c1)*c1);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length((sin(p.yzx))-(cos(p))))-2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 40.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 16.0; i*= 2.0){\n        float i1 = i*i;\n        p += (sin(p.yzx/i1)+cos(p.yzx/i1))*(i1);\n    \tresult = max(sceneSDF1(p*i1)/i1,-result);\n    }\n    return -(result-.06)*2.0;\n}\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/sin(p3.zyx))/2.0;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_a_code": "\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    \n    float c1 = 3.0;\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(-iTime+sin(t1/c1),sin(t1/c1)*c1,cos(t1/c1)*c1);\n    const float speed = .1;\n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-1,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(1.0+length(eye-dmap));\n    if(l0 < 5.0){\n        l0 = 0.0;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 423, 514, 514, 832], [847, 847, 874, 874, 1023], [1025, 1025, 1082, 1082, 1755]]}
{"id": "tstBRr", "name": "Costas4 PaletteAnimated", "author": "ollj", "description": "mouse.y sets hue\nmouse.y sets a mode\nthe \"animation\" jreally ust \"cycles the color palette\", and each pixel basically has 1 static palette color.\n\nneeds to be in fullscreen for large [MultiTile] values", "tags": ["noise", "dither", "bluenoise", "costas", "costasarray", "patternfree"], "likes": 0, "viewed": 298, "published": 3, "date": "1604273720", "time_retrieved": "2024-07-30T20:37:10.204101", "image_code": "//     parent: https://www.shadertoy.com/view/Wsdfzr\n//grandparent: https://www.shadertoy.com/view/tdjfzR\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\n\ncostas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic\n, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em\n\n\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n#define animatePaletteSpeed .9\n\n#define mode int(5.*iMouse.y/iResolution.y)\n//#define mode 4\n\n//mode 2 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 9 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 256\n\n//place multiple smaller tiles (important to expose some pattern)\n#define MultiTile 3.\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n#define base2 base1  //trying otherbases\n\n\n\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n/**/\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\nint ae(int a){\n ;//return (a*5)%period         //linear *5 debug\n ;//return costas3(a,base1)-1;    //works up to (2,29) with type float.\n ;//but seriously, use other LUTs:\n     \n ;//int c[]=int[16](3,13,4,15,12,6,10,2,7,8,11,1,14,16,9,5);//diagonal mirr \n ;//int c[] = int[16](6,14,10,7,9,1,4,16,5,3,12,11,15,2,13,8);//diagonal mirr\n //;int c[] = int[16](3,12,1,4,10,6,14,9,8,5,15,2,16,7,11,13);//diagonal mirr\n\n\n /*\n ;int c[] = int[256](1,17,140,33,222,156,40,49,23,238,109,172,143,56,105,65,41,39,224\n                    ,254,179,125,53,188,187,159,162,72,11,121,103,81,248,57,5,55,234\n                    ,240,26,14,82,195,102,141,244,69,32,204,79,203,180,175,84,178,74\n                    ,88,107,27,19,137,239,119,62,97,108,8,77,73,192,21,130,71,229,250\n                    ,70,256,148,42,243,30,45,98,38,211,6,118,150,157,99,4,182,85,242\n                    ,48,189,220,174,95,131,219,186,196,36,191,144,100,214,194,138,90\n                    ,117,104,215,123,18,43,165,35,80,153,217,255,221,135,152,78,252\n                    ,113,241,124,206,24,7,93,127,89,25,208,163,37,171,146,251,87,232\n                    ,245,218,10,66,86,228,16,63,164,68,58,91,3,223,46,92,61,176,114\n                    ,213,54,132,227,29,22,246,134,83,166,226,173,158,115,170,20,128\n                    ,198,122,101,199,2,149,64,201,205,136,236,225,190,247,111,9,147\n                    ,155,235,216,202,50,212,47,52,75,207,76,160,197,116,13,230,67\n                    ,210,142,154,112,106,183,133,185,120,209,231,249,139,200,34,31,59\n                    ,60,181,253,51,126,96,167,169,193,233,184,15,44,237,110,151,177\n                    ,168,28,94,161,12,145,129);//slithly erratic, slicgtly arcing\n/**/\n\n     /*\n ;int c[]  = int[256](\n    \n    \n\n);*/\n     \n;int c[]  = int[256]( 1,49,162,97,152,210,118,145,67,200,69,2,171,166,57,193,121,115,158,248,23,117,157,50,47,219,228,214,31,105,51,241,230,169,13,163,188,206,76,40,244,71,48,165,218,205,94,98,235,95,26,11,250,20,220,6,63,79,55,153,203,99,184,33,66,22,229,217,62,61,132,211,173,236,208,254,186,124,215,88,133,36,112,119,16,96,192,213,39,10,32,253,212,142,53,146,8,27,135,143,44,74,106,59,174,42,128,68,156,12,93,54,131,111,52,127,237,103,238,201,137,251,149,147,198,232,242,81,209,114,104,70,19,21,123,9,73,110,231,109,255,180,239,3,182,221,140,28,196,256,170,46,187,234,202,172,15,7,155,136,18,181,14,84,125,160,138,167,85,64,224,144,247,240,164,5,216,87,252,58,126,80,108,45,83,4,189,190,89,101,150,194,161,56,227,75,25,183,207,191,134,92,148,122,139,154,223,107,226,222,77,90,37,176,199,116,168,204,78,60,35,141,41,102,113,179,233,159,86,100,91,175,178,29,245,151,120,30,243,249,65,185,38,43,130,197,72,195,17,246,82,24,225,34,177,129\n );//very nice (apparent rotations are neat)\n//;int c[]  =  int[256](  65,113,50,161,8,98,70,209,35,56,197,146,11,118,249,1,57,83,238,104,55,245,157,194,207,59,20,166,191,41,19,49,182,105,13,131,108,30,252,152,36,103,32,37,234,205,174,242,75,255,42,107,10,68,140,214,223,239,87,89,43,67,40,97,210,230,101,153,142,61,180,179,173,156,192,78,202,44,247,200,5,84,96,151,256,80,176,85,71,26,16,253,4,222,181,34,120,123,167,47,220,90,122,155,254,58,112,116,76,188,93,6,99,15,100,31,237,135,62,137,73,91,21,115,150,88,130,145,17,2,216,22,243,149,219,201,9,190,7,109,159,228,143,227,134,221,60,204,244,240,186,126,27,250,218,92,175,39,251,248,162,53,94,132,125,144,154,199,213,48,208,128,23,224,212,133,72,119,172,74,206,64,28,45,51,52,189,14,25,229,102,82,225,168,195,171,217,215,111,95,86,12,196,138,235,170,127,203,114,46,77,106,165,160,231,164,24,124,158,236,3,141,233,54,177,147,169,63,38,148,187,79,66,29,117,183,232,110,211,185,129,121,246,139,18,69,184,163,81,198,226,136,33,178,241,193\n//);//super swirly \n//;int c[]  = int[256]( 1,113,78,225,140,190,146,81,155,252,245,46,227,2,217,193,25,11,154,108,223,101,109,158,23,83,232,114,71,73,203,49,66,137,29,123,224,10,48,220,184,79,68,213,38,221,90,14,35,135,102,195,198,88,128,226,231,183,127,185,131,59,44,161,110,178,21,249,186,141,8,235,61,80,100,122,134,160,159,76,53,40,132,191,164,180,148,69,175,150,116,77,24,202,37,126,60,147,143,247,144,214,118,51,106,54,84,200,64,240,45,82,219,87,248,39,125,239,170,41,233,243,5,171,162,156,94,17,145,222,28,34,43,133,115,105,169,42,111,253,167,120,215,91,210,173,112,192,72,212,182,234,179,246,86,16,119,15,19,188,254,165,74,152,205,244,22,47,197,20,52,36,63,4,168,181,204,31,32,6,250,228,208,189,107,136,13,58,121,149,50,238,33,172,187,3,57,255,55,103,98,256,216,70,67,230,7,163,142,218,93,166,85,196,207,56,92,176,138,96,251,157,9,194,177,75,201,199,242,104,211,151,30,237,229,95,236,26,139,153,65,89,130,99,174,117,124,27,209,18,62,12,97,206,241,129\n     //);//good shuffle\n\n//below ones seem to be worse in tiles:\n//;int c[]  = int[256]( 1,113,254,225,92,110,2,81,251,204,181,222,195,114,89,193,153,107,138,60,255,37,173,78,183,51,248,226,231,201,43,49,178,9,93,219,112,250,192,172,200,111,148,149,86,29,74,190,3,39,150,163,246,104,16,82,135,87,159,57,99,155,252,161,30,34,213,121,170,205,24,75,125,224,180,106,182,48,191,28,245,56,212,223,244,4,228,5,207,198,196,141,40,186,229,46,12,115,175,151,32,6,166,19,90,102,164,216,208,128,109,194,59,247,8,199,189,15,154,169,105,211,197,11,18,108,14,17,145,142,236,146,139,69,83,233,41,26,143,61,71,136,119,187,66,237,256,80,88,36,230,218,147,38,134,160,23,47,243,140,174,101,58,168,13,68,70,79,133,100,132,116,95,84,184,117,156,63,176,54,234,52,96,253,203,152,77,42,249,85,162,158,33,124,27,227,185,31,215,7,210,144,232,118,35,22,167,131,62,202,157,214,21,20,239,72,44,64,122,240,91,221,137,50,177,171,73,103,98,120,179,55,206,45,165,127,188,10,235,25,65,217,242,67,94,53,76,123,209,130,238,220,97,126,241,129\n//); //has a thin dominand line\n//;int c[]  = int[256]( 1,49,210,97,232,2,102,145,163,24,5,50,139,150,185,193,249,211,14,72,55,53,221,98,207,187,116,198,191,233,147,241,214,41,77,3,204,62,92,120,132,103,256,101,138,13,206,146,203,255,202,235,170,164,236,246,223,239,87,25,171,195,8,33,114,6,165,89,174,125,20,51,237,252,160,110,106,140,247,168,69,180,64,151,224,48,144,149,71,186,240,61,100,254,245,194,88,251,167,47,60,250,26,27,30,218,80,212,172,28,157,38,227,15,196,31,45,135,94,73,9,219,85,243,182,56,34,81,209,162,184,54,115,213,91,137,201,222,7,173,159,68,143,99,166,29,156,44,84,208,90,158,155,154,122,188,175,39,123,216,66,117,126,228,189,112,58,199,21,16,176,96,23,192,52,197,40,119,12,234,238,32,124,109,179,148,253,46,217,37,134,242,161,136,67,43,153,215,111,95,118,108,36,42,107,74,127,75,18,78,141,10,229,128,231,4,248,220,190,76,131,205,169,86,113,19,105,63,70,244,59,79,226,93,181,183,200,142,83,121,65,57,22,11,178,133,152,35,17,230,130,104,225,82,177\n//,129);//slightly irritaiting erratic\n    //;int c[]  = int[256](34,18,71,2,21,55,107,242,108,5,118,39,116,91,58,226,122,92,51,245,144,102,46,23,8,100,145,75,184,42,28,210,155,106,94,76,201,35,153,229,225,128,13,86,95,30,243,7,180,248,159,84,255,129,105,59,88,168,48,26,20,12,181,194,103,139,150,90,83,78,177,60,126,185,45,19,191,137,80,213,182,209,77,112,109,253,221,70,224,79,189,14,65,227,38,247,69,164,192,232,249,143,47,68,131,239,157,113,41,89,238,43,172,72,33,152,190,32,195,10,202,4,6,252,251,165,215,178,50,87,37,123,124,134,132,74,138,67,160,62,24,161,200,44,171,110,217,169,241,29,111,3,196,175,15,121,104,64,36,197,119,166,99,193,142,61,207,96,198,93,125,237,240,205,81,54,85,208,9,63,147,173,57,254,188,49,206,211,218,22,11,231,66,53,140,148,154,176,40,216,187,233,1,127,212,31,120,52,135,115,158,223,214,141,256,97,101,25,163,73,204,222,234,27,82,156,170,56,203,17,228,136,151,174,230,16,117,179,220,250,98,186,219,244,167,246,133,236,114,235,183,149,130,199,146\n//              ,162);//notable zigZagging\n//;int c[]  = int[256](63,239,216,159,30,136,12,79,113,206,99,56,153,188,183,255,247,33,244,126,165,19,251,232,253,73,10,108,109,103,225,175,252,167,235,209,34,164,50,46,154,85,246,195,80,171,180,152,217,173,144,249,112,186,66,28,141,29,197,23,185,145,62,95,120,172,3,87,148,155,170,129,139,210,150,84,48,226,101,222,163,74,54,5,214,166,6,115,53,256,102,91,122,100,211,72,14,137,149,93,18,64,96,169,132,32,198,106,2,242,187,204,177,61,218,205,203,117,196,199,135,105,51,65,220,238,168,15,143,40,110,92,193,179,233,7,71,68,245,75,77,90,189,49,76,59,114,130,234,70,160,4,41,224,192,146,221,21,9,142,200,83,228,250,219,230,128,181,243,134,38,86,133,182,202,35,94,229,98,176,212,22,82,11,1,42,27,20,215,131,44,248,223,190,17,57,151,69,157,13,156,194,58,240,121,16,45,89,24,52,43,208,67,118,213,26,174,178,36,162,81,107,39,124,47,97,231,237,236,138,201,125,104,123,147,37,254,116,161,119,127,55,60,25,184,227,78,241,207,140,8,158,31,88,111\n//                     ,191);//not soo good, [notable arc]\n//;int c[]  =  int[256](34,50,29,66,15,45,121,82,24,31,78,61,16,137,10,98,202,40,177,47,116,94,150,77,252,32,19,153,76,26,104,114,73,218,102,56,219,193,11,63,195,132,23,110,5,166,241,93,208,12,197,48,101,35,59,169,172,92,212,42,112,120,111,130,253,89,46,234,145,118,243,72,70,235,247,209,165,27,180,79,14,211,215,148,183,39,71,126,36,21,103,182,99,1,158,109,223,224,68,28,171,213,53,64,97,117,135,51,123,75,214,185,216,188,131,108,6,228,33,58,122,128,190,136,233,127,141,146,18,13,255,105,8,62,256,250,186,161,100,134,236,3,60,88,57,86,203,251,179,7,245,225,192,181,85,43,156,196,96,95,237,30,129,227,54,231,149,164,254,199,167,55,20,87,83,142,207,52,155,37,81,119,107,198,200,115,246,17,106,174,217,125,2,239,248,240,170,84,220,44,41,187,163,229,176,69,140,80,221,113,38,133,238,151,4,67,191,139,65,91,184,230,90,201,242,232,154,204,25,147,160,124,205,22,222,244,175,49,168,74,226,138,9,144,189,206,159,152,210,249,173,143,194,157,178\n//                      ,162); //medium useful [mild snake]\n//;int c[]  = int[256]( 1,17,12,33,94,28,168,49,23,110,109,44,143,184,105,65,41,39,96,126,179,125,53,60,187,159,34,200,11,121,103,81,120,57,5,55,106,112,154,142,210,195,230,141,116,69,160,76,79,203,52,175,212,50,202,216,107,27,19,137,239,119,190,97,236,136,77,73,64,21,2,71,229,122,198,128,20,170,243,158,45,226,166,211,134,246,22,157,99,132,54,85,114,176,189,92,46,95,131,219,58,68,164,191,16,228,86,66,10,218,117,232,215,123,146,43,165,35,208,153,217,255,221,135,24,206,124,113,241,252,78,152,7,93,127,89,25,80,163,37,171,18,251,87,104,245,90,138,194,214,100,144,63,36,196,186,91,3,223,174,220,61,48,242,213,182,4,227,29,150,118,6,83,38,98,173,30,115,42,148,256,70,250,101,199,130,149,192,201,205,8,108,225,62,247,111,9,147,155,235,88,74,178,84,47,180,75,207,204,32,197,244,13,102,67,82,14,26,240,234,183,133,185,248,209,231,249,139,72,162,31,59,188,181,253,51,254,224,167,169,193,233,56,15,172,237,238,151,177,40,156,222,161,140,145,129\n//);//terrible\n//;int c[]  =  int[256](34,50,61,66,239,77,25,82,88,255,206,93,80,41,10,98,202,104,81,15,52,222,22,109,188,96,115,57,12,26,168,114,233,218,230,120,59,97,107,31,35,68,247,238,37,38,145,125,16,204,229,112,133,131,155,73,108,28,148,42,176,184,79,130,29,249,174,234,49,246,83,136,198,75,215,113,197,123,116,47,142,51,183,84,151,7,39,254,228,53,71,54,195,161,30,141,191,32,4,220,11,245,85,128,1,149,103,147,219,171,86,89,24,124,227,44,134,164,193,58,122,192,62,200,137,95,173,146,18,45,223,9,72,190,64,250,186,65,36,6,172,99,252,152,217,214,43,91,19,231,21,129,256,213,117,139,92,132,160,63,13,158,33,67,182,199,181,100,126,167,135,23,212,55,179,14,175,244,251,69,241,87,203,70,8,211,118,177,106,46,121,157,2,207,56,48,170,20,156,236,201,27,3,5,240,101,76,144,253,17,166,165,110,119,196,163,159,235,225,187,248,102,90,105,242,40,154,140,185,243,224,60,237,150,94,180,143,209,232,74,226,138,169,208,221,78,127,216,210,153,205,111,194,189,178\n//,162);//close to worst [snake like]\n//;int c[]  =  int[256]( 1,17,28,33,206,44,248,49,55,222,173,60,47,8,233,65,169,71,48,238,19,189,245,76,155,63,82,24,235,249,135,81,200,185,197,87,26,64,74,254,2,35,214,205,4,5,112,92,239,171,196,79,100,98,122,40,75,251,115,9,143,151,46,97,252,216,141,201,16,213,50,103,165,42,182,80,164,90,83,14,109,18,150,51,118,230,6,221,195,20,38,21,162,128,253,108,158,255,227,187,234,212,52,95,224,116,70,114,186,138,53,56,247,91,194,11,101,131,160,25,89,159,29,167,104,62,140,113,241,12,190,232,39,157,31,217,153,32,3,229,139,66,219,119,184,181,10,58,242,198,244,96,223,180,84,106,59,99,127,30,236,125,256,34,149,166,148,67,93,134,102,246,179,22,146,237,142,211,218,36,208,54,170,37,231,178,85,144,73,13,88,124,225,174,23,15,137,243,123,203,168,250,226,228,207,68,43,111,220,240,133,132,77,86,163,130,126,202,192,154,215,69,57,72,209,7,121,107,152,210,191,27,204,117,61,147,110,176,199,41,193,105,136,175,188,45,94,183,177,120,172,78,161,156,145,129\n//);//bad\n//;int c[]  =  int[256]( 1,17,44,33,62,60,72,49,87,78,237,76,207,88,105,65,41,103,256,94,115,253,181,92,123,223,130,104,203,121,167,81,24,57,133,119,202,16,250,110,50,131,198,13,148,197,64,108,143,139,84,239,244,146,42,120,43,219,211,137,47,183,158,97,12,40,205,73,224,149,98,135,101,218,166,32,52,10,179,126,173,66,134,147,102,214,246,29,35,164,22,213,210,80,61,124,14,159,67,155,154,100,196,255,176,4,54,162,106,58,245,136,23,59,242,235,37,227,112,153,217,63,93,199,184,174,156,113,241,28,46,56,71,221,191,89,25,240,99,165,107,114,187,151,8,117,186,234,34,182,132,48,127,68,228,26,27,195,31,142,252,189,208,82,85,150,36,163,157,118,86,230,19,6,194,45,254,51,138,180,160,38,90,229,7,226,21,96,201,77,168,140,225,30,55,175,9,83,91,171,248,170,18,116,111,212,11,15,236,192,69,20,141,70,3,178,238,122,144,74,247,5,185,152,209,39,249,75,232,2,95,251,220,53,125,243,222,128,231,169,193,233,216,79,204,109,206,215,177,200,188,190,161,172,145,129\n//);//worst\n     \n \n    \n/**/\n;//return c[(       a  )%period]\n;return c[(period-a-1)%period]//reverse\n;}\n    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\nbool isDiagMirr0(){  //return if ae(ae(i))=i foreach i == ae() is its own inverse.\n for(int i=0;i<period;i++\n ){int b=ae(i)\n  ;if(b>i)continue//we only check lower left half + diagonalLine\n  ;//if(b==i)//any point on diagonal line is automatically is true, no need to test\n  ;if(ae(b)!=i)return false;     \n ;}return true;}\n//below is mirrored test of above\nbool isDiagMirr1(){  //return if ae(ae(i))=i foreach i == ae() is its own inverse.\n for(int i=0;i<period;i++\n ){int b=ae(period-i)\n  ;if(b>i)continue//we only check lower left half + diagonalLine\n  ;//if(b==i)//any point on diagonal line is automatically is true, no need to test\n  ;if(ae(period-b)!=i)return false;     \n ;}return true;}\n\nvoid mainImage(out vec4 O, vec2 u\n){//u=u.yx\n ;int m=mode\n ;if (m==4)m=int(iTime+2.)%3;  \n ;if(m==0)m=2 ;else if (m==2)m=0 //swap mode 0 and 2\n ;vec3 c=vec3(0)\n ;ivec2 U=ivec2(MultiTile*u*float(period)/iResolution.y)\n ;if(u.x<float(period-1)*zoom\n   &&u.y<float(period-1)*zoom //if not the blue part\n ){\n  #ifdef MultiTile\n  ;U=U%period\n  #endif\n  ;//U=U.yx                          //sqivel domains\n  //;u*=float(period)/iResolution.y\n  ;//if(u.x<2.)c=vec3(1);\n  ;float f=0.\n  ;int a=0\n  ;if(m==0\n         //the [period-] is just for symmetry, actually optional\n  ){if(ae(U.y)==period-U.x)a=period;//black or white  \n  }else{\n   ;a=ae(U.y)+(U.x)       \n   //[period-] is just for symmetry, actually optional\n   ;a=period-a%period   //;if(a>period)a-=period //single overflow   (no mod needed) \n   ;if(m>1\n   ){a=ae(a)//+(U.y)     //+1 ae() recursion the +=y just removes symmetry, is semi arbitiary naoise\n    ;a+=ae(period-1)\n    ;a=a%period;}}\n  ;f=float(a)/float(period) \n      \n  #ifdef animatePaletteSpeed\n  ;if(m!=0){f-=fract(iTime*animatePaletteSpeed)////cos(iTime)*.5+.5\n            ;if(f<0.)f+=1.;}\n  #endif\n  ;c=mix(vec3(f,f,f),mix(vec3(0,.4,1),vec3(1,.4,0),f),iMouse.x/iResolution.x)\n ;}\n\n    \n /*\n //below code highlights lower right triangle points green \n //IFF they have a diagonal mirror\n ;if(period-U.x-1>U.y\n    ){if(ae(U.y)==period-U.x\n     ){if(ae((period-U.x-1))==U.y+1)\n         c+=vec3(1,0,1);}}//bottom left mirroreds marked white\n    \n  //IFF they have a diagonal mirror\n ;if(U.x<U.y\n    ){\n     ;if(ae(U.y)==period-U.x\n     ){\n     if(ae(U.x)==period-U.y)\n         c+=vec3(1,1,1);}}//top left mirroreds marked white\n    */\n ;O=vec4(c,1)\n ;}", "image_inputs": [], "common_code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-SYMMETRICAL costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 2 are:\n\t1\t2\nall* symmetrical costas arrays of order 3 are:\n\t1\t3\t2\nall* symmetrical costas arrays of order 4 are:\n\t1\t2\t4\t3\nall* symmetrical costas arrays of order 5 are:\n\t1\t3\t4\t2\t5                          <---- demoed \n\t2\t4\t1\t5\t3\nall* symmetrical costas arrays of order 6 are:\n\t1\t4\t5\t3\t2\t6\n\t1\t5\t3\t6\t2\t4\n\t1\t6\t3\t5\t4\t2\n\t1\t6\t4\t3\t5\t2\n\t2\t4\t5\t1\t6\t3\nall* symmetrical costas arrays of order 7 are:\n\t1\t2\t6\t4\t7\t3\t5\n\t1\t2\t7\t4\t6\t5\t3\n\t1\t2\t7\t5\t4\t6\t3\n\t1\t7\t3\t4\t6\t5\t2\n\t2\t1\t5\t7\t3\t6\t4\n\t2\t1\t6\t4\t7\t3\t5\n\t2\t5\t6\t1\t3\t7\t4\n\t2\t5\t6\t4\t1\t7\t3\n\t2\t6\t1\t3\t4\t7\t5\n\t3\t6\t1\t7\t5\t2\t4\nall* symmetrical costas arrays of order 8 are:\n\t1\t5\t8\t4\t2\t7\t6\t3\n\t1\t7\t3\t8\t6\t5\t2\t4\n\t1\t7\t4\t3\t5\t8\t2\t6\n\t3\t5\t1\t8\t2\t7\t6\t4\nall* symmetrical costas arrays of order 9 are:\n\t1\t4\t6\t2\t9\t3\t8\t7\t5\n\t2\t1\t5\t8\t3\t9\t7\t4\t6\nall* symmetrical costas arrays of order 10 are:\n\t1\t7\t4\t9\t3\t5\t8\t6\t2\t10\n\t2\t1\t9\t4\t5\t8\t10\t6\t3\t7\n\t2\t6\t8\t1\t9\t5\t3\t4\t10\t7\n\t2\t8\t9\t4\t1\t3\t7\t5\t10\t6\n\t3\t9\t1\t4\t5\t10\t8\t7\t2\t6\n\t3\t9\t7\t8\t4\t1\t6\t10\t2\t5\t\nall* symmetrical costas arrays of order 11 are:\n\t1\t6\t8\t9\t4\t10\t3\t7\t5\t2\t11\n\t1\t7\t5\t8\t10\t4\t9\t6\t2\t3\t11\n\t1\t7\t11\t6\t8\t4\t2\t5\t10\t9\t3\n\t1\t10\t4\t3\t8\t11\t9\t5\t7\t2\t6\n\t3\t10\t1\t9\t6\t5\t7\t11\t4\t2\t8\nall* symmetrical costas arrays of order 12 are:\n\t1\t2\t8\t12\t7\t9\t5\t3\t6\t11\t10\t4\n\t1\t2\t11\t5\t4\t9\t12\t10\t6\t8\t3\t7\n\t1\t4\t11\t2\t10\t7\t6\t8\t12\t5\t3\t9\n\t3\t6\t1\t12\t10\t2\t7\t9\t8\t5\t11\t4\n\nall* symmetrical costasArrays of order 16 are\n\t1\t13\t3\t16\t14\t8\t10\t6\t15\t7\t12\t11\t2\t5\t9\t4\n\t3\t12\t1\t4\t10\t6\t14\t9\t8\t5\t15\t2\t16\t7\t11\t13\n\t3\t13\t4\t15\t12\t6\t10\t2\t7\t8\t11\t1\t14\t16\t9\t5\n\t6\t14\t10\t7\t9\t1\t4\t16\t5\t3\t12\t11\t15\t2\t13\t8\n\nall* symmetrical costasArrays of order 27 are\n\t1\t25\t19\t5\t4\t12\t10\t16\t26\t7\t18\t6\t23\t27\t24\t8\t21\t11\t3\t22\t17\t20\t13\t15\t2\t9\t14\n\t3\t9\t1\t8\t13\t15\t19\t4\t2\t20\t11\t25\t5\t17\t6\t27\t14\t24\t7\t10\t26\t23\t22\t18\t12\t21\t16\n\t3\t24\t10\t26\t20\t15\t13\t23\t14\t1\t8\t4\t22\t19\t21\t2\t5\t25\t9\t17\t6\t7\t11\t16\t27\t12\t18\n\t4\t17\t21\t9\t11\t16\t25\t12\t1\t7\t26\t22\t14\t15\t13\t20\t23\t3\t24\t6\t18\t8\t2\t27\t10\t5\t19\n\t6\t10\t23\t13\t16\t1\t11\t20\t15\t2\t7\t26\t4\t27\t9\t5\t19\t25\t17\t8\t24\t22\t3\t21\t18\t12\t14\n\t6\t16\t20\t12\t14\t7\t1\t25\t8\t17\t18\t26\t11\t23\t10\t24\t15\t13\t3\t19\t22\t27\t5\t2\t9\t4\t21\n\t6\t23\t14\t8\t21\t1\t26\t4\t22\t20\t12\t11\t16\t3\t17\t13\t15\t24\t27\t10\t5\t9\t2\t18\t25\t7\t19\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are:\n\t1\t23\t14\t12\t18\t26\t30\t20\t25\t11\t10\t4\t16\t3\t21\t13\t22\t5\t19\t8\t15\t17\t2\t28\t9\t6\t29\t24\t27\t7\n\t11\t22\t5\t13\t23\t10\t2\t26\t29\t15\t19\t20\t14\t4\t6\t21\t18\t27\t1\t30\t25\t7\t3\t9\t16\t28\t17\t8\t24\t12\n\t12\t24\t20\t17\t2\t9\t29\t3\t16\t4\t28\t18\t19\t27\t22\t6\t10\t1\t30\t8\t14\t25\t11\t5\t15\t7\t21\t23\t26\t13\n\t13\t26\t2\t21\t29\t4\t9\t11\t15\t27\t12\t8\t17\t18\t7\t22\t1\t30\t20\t23\t6\t24\t19\t16\t10\t3\t25\t5\t28\t14\n\na symmetrical costas array of order 35 is:\n\t1\t12\t7\t27\t32\t30\t3\t24\t31\t17\t19\t2\t16\t29\t20\t13\t10\t35\t11\t15\t23\t33\t21\t8\t26\t25\t4\t34\t14\t6\t9\t5\t22\t28\t18\n\t\na symmetrical costas array of order 65 is:\n\t1\t29\t46\t16\t24\t37\t17\t22\t12\t63\t55\t9\t15\t42\t13\t4\t7\t26\t44\t56\t50\t8\t49\t5\t40\t18\t32\t34\t2\t54\t51\t27\t65\t28\t53\t57\t6\t39\t38\t25\t48\t14\t59\t19\t62\t3\t58\t41\t23\t21\t31\t61\t35\t30\t11\t20\t36\t47\t43\t64\t52\t45\t10\t60\t33\n\na symmetrical costas array of order 99 is:\n1\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3481, 3585, 3599, 3599, 17123], [17556, 17556, 17575, 17638, 17879], [17880, 17914, 17933, 17996, 18251]]}
{"id": "WdyyWd", "name": "Doot Doot", "author": "Shapkofil", "description": "Making a doot field i guess\nyoutube vid showcase: [video]https://youtu.be/_WDsGupdeL4[/video]", "tags": ["halloween", "gpusound", "mrskeletal", "dootdoot"], "likes": 3, "viewed": 323, "published": 3, "date": "1604267055", "time_retrieved": "2024-07-30T20:37:11.089733", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int power = int(iTime/period);\n    uv = mod(uv*float(1<<power),1.0);\n    \n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float sigmoid(float x)\n{\n    return 1.0 / (1.0 + exp(-x));\n}\n\nfloat smoothed_sawtooth(float d, float x)\n{\n    return (1.0 - 2.0 * acos(d * -cos(x / 2.0)) / pi) * (2.0 *  atan(sin(x / 2.0) / (1.0 - d)) / pi);\n}\n\nfloat trumpet(float t, float f)\n{\n    // Sound starts with sine which turns into (smoothed) sawtooth.\n    return smoothed_sawtooth(0.95 * sigmoid(t), f * t);\n}\n\n#define sw(freq) trumpet(time, freq)\n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    vec2 amp = doot_doot_gen(time);\n    amp *= 1.1*ceil(time/period);\n    vec2 doot1 = vec2( sw(1160.0) * amp.x);\n    vec2 doot2 = vec2( sw(1480.0) * amp.y);\n    \n    return doot1 + doot2;\n    //return vec2(amp.x+amp.y);\n}", "sound_inputs": [], "buffer_a_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 36;\nvec2[] points = vec2[](\n    vec2(0.15604078965517243,0.006952005245901639),\n    vec2(0.32516884137931035,0.009793744262295083),\n    vec2(0.4561191379310345,0.1933462393442623),\n    vec2(0.47910444827586207,0.32490575409836064),\n    vec2(0.44083172413793104,0.3615969180327869),\n    vec2(0.36398189655172414,0.33533137704918037),\n    vec2(0.35815955172413794,0.23650780327868856),\n    vec2(0.4379587586206896,0.20692787213114758),\n    vec2(0.44928834482758623,0.29642963934426236),\n    vec2(0.4184613793103448,0.3387371803278689),\n    vec2(0.24744845172413796,0.39635101639344267),\n    vec2(0.1870086379310345,0.4062724590163935),\n    vec2(0.16284365862068967,0.3071456918032787),\n    vec2(0.2646114137931035,0.2890036491803279),\n    vec2(0.28749012413793107,0.371974131147541),\n    vec2(0.441803,0.3709476721311476),\n    vec2(0.4452385172413793,0.4970127540983607),\n    vec2(0.47387834482758623,0.5541454098360656),\n    vec2(0.4985668275862069,0.48326540983606564),\n    vec2(0.6566372413793103,0.6022237049180329),\n    vec2(0.6406144137931035,0.6310666885245904),\n    vec2(0.7040961379310345,0.6674860327868855),\n    vec2(0.8457785862068965,0.6441119672131149),\n    vec2(0.9539346206896551,0.745187704918033),\n    vec2(0.8865772068965515,0.9323457377049182),\n    vec2(0.6883219310344826,0.9618828852459018),\n    vec2(0.6139840344827585,0.8737540327868855),\n    vec2(0.6284143103448274,0.7487036721311477),\n    vec2(0.4333702758620688,0.5798480000000003),\n    vec2(0.3237771793103446,0.5974329508196723),\n    vec2(0.2202485827586205,0.5254885573770494),\n    vec2(0.18859653448275843,0.5003934754098363),\n    vec2(0.15468172413793085,0.4297871475409838),\n    vec2(0.09884780344827568,0.4146684262295084),\n    vec2(0.10784707241379292,0.3700899344262297),\n    vec2(0.04969448620689637,0.32742981967213136)\n    );\n\n\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(uv.x, 1.0- uv.y);\n    \n    vec2 doot_doot = doot_doot_gen(iTime) * vec2(1.0, -1.0);\n    for(int i=21; i<=27; i++)\n        points[i] += doot_doot/50.0;\n    \n    float iter = floor(iTime/period) + 1.0;\n    fragColor = vec4(1.0-abs(sdPoly(points,uv))*(200.0/iter));\n}", "buffer_a_inputs": [], "common_code": "float doot_width = 10.0;\nfloat basepower = 1.0;\nfloat sred = 0.8;\nfloat offset = 1.0;\nfloat soffset = 0.21;\n\nfloat period = 2.6;\n\n#define pi 3.1415926\n\nfloat doot_gen(float x)\n{\n    return max(-pow(doot_width*x, 16.0) + basepower, 0.0);\n}\n\nvec2 doot_doot_gen(float x)\n{\n    x = mod(x, period);\n    return vec2(doot_gen(x - offset), sred*doot_gen(x - soffset - offset));\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 217]]}
{"id": "Wsdfzr", "name": "Costas3 (semi)aperiodic dither", "author": "ollj", "description": "costas arrays are pattern free==aperiodic\n3d costas arrays are impractival (too large LUT)\nbut a self recursed 2d costas array is still semi-aperiodic, great for dithering (in theory)\nsome of them still compress nicely due to meta-patterns between 2 of em", "tags": ["noise", "dither", "bluenoise", "costas", "costasarray", "patternfree"], "likes": 3, "viewed": 328, "published": 3, "date": "1604253897", "time_retrieved": "2024-07-30T20:37:12.163861", "image_code": "//self: https://www.shadertoy.com/view/Wsdfzr\n//parent: https://www.shadertoy.com/view/tdjfzR\n\n//todo, 2d fourier transform\n\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n/*\ncostas array [mode==0] is pattern free \nin short, it is an extension to the \"place the most exclusive queens on a checkerboard\"\n- BUT where even ALL XY-differentials between any 2 tokens must be unique (on a torus repetition)\nThis is (in theory) ideal for dithering\n(or as a basis for a music scmapler, that just has to add local arbitiary (strided) repetitions)\n\nThe [mode==1] greyscaling gradient is BASIC (and too much of a pattern)\n\nIt can easily be more distorted\n, by applying a second greyscaling-recursionpass [mode==2] of a costas array \n\nIf that is the same CostasArray over itself, it is only SEMI-pattern-free\n, even that but likely still good enough.\n\nTo turn this into (any amount of) (pattern free) BLUE (noise)\n,simply mix(a,b,0.75) 2 of these, where the scale.xy of one of CostasArray [a] \nis an interger multiple of the scale of the scale.xy of CostasArray [b]\n(and make sure, that both costas arrays are also costas-arrays over a tiled neighborhood)\n\nalso see [worlds ugliest music]==  https://www.youtube.com/watch?v=RENk9PK06AQ\n*/\n\n\n#define mode 4\n//mode 0 shows costas array as boolean dots\n//mode 1 shows it as linear fade gradient\n//mode 2 suffles the gradeitn by the same costas array\n//- this looks fine for most costas arrays, though its only semi-pattern.free\n//I assume mode 2 fails on SIMPLE costas3() costas arrays (that compress more than a LUT)\n//it sure looked nicer on my LUT arrays.\n//mode 4 cycles trhough all modes\n\n#define period 256\n\n//scale by period\n#define zoom (min(iResolution.x,iResolution.y)/float(period-1))\n//pixel perfect, but only in preview\n//#define zoom 1.\n\n/*  //mathematical construction of a costas array list quickly hits limits of 32bit int\n    //therefore this segment is quite limited in its utility, and therefore commented out\n\n#define base1 2\n//the  (pase,period) pairs -> (3,5) (3,7) (5,7) make costas arrays\n//the  (pase,period) pairs (2,11) (2,13) (2,29) look a lot like they make costas arrays\n//(5,9) (7 11)\n//the function below fails for too large [#] values\n//it breaks for period>=37 (overflow or low float precision?)\n#define base2 base1  //trying otherbases\n\n\n\nint poi(int a,int b){//integer pow(a,b) as loop is slow but more precise\n ;//b=abs(b) //imply b>-1\n ;int r=a;for(int i=0;i<b;i++){r*=a;}return r;}\nint costas3(int x,int b\n){//return int(round(pow(float(b),float(x)+1.)))%int(period)//round() is essential on type float\n ;return poi(int(b),int(x))%period //type int has larger range, but type int exp() is silly\n ;}\n\n/**/\n\n//return entry [a] of CostasArray list\n//return entry a of array (is a heightmap-like wrapper function)\nint ae(int a){\n ;//return (a*5)%period         //linear *5 debug\n ;//return costas3(a,base1)-1;    //works up to (2,29) with type float.\n ;//but seriously, use other LUTs:\n ;int c[] = int[256](1,17,140,33,222,156,40,49,23,238,109,172,143,56,105,65,41,39,224\n                    ,254,179,125,53,188,187,159,162,72,11,121,103,81,248,57,5,55,234\n                    ,240,26,14,82,195,102,141,244,69,32,204,79,203,180,175,84,178,74\n                    ,88,107,27,19,137,239,119,62,97,108,8,77,73,192,21,130,71,229,250\n                    ,70,256,148,42,243,30,45,98,38,211,6,118,150,157,99,4,182,85,242\n                    ,48,189,220,174,95,131,219,186,196,36,191,144,100,214,194,138,90\n                    ,117,104,215,123,18,43,165,35,80,153,217,255,221,135,152,78,252\n                    ,113,241,124,206,24,7,93,127,89,25,208,163,37,171,146,251,87,232\n                    ,245,218,10,66,86,228,16,63,164,68,58,91,3,223,46,92,61,176,114\n                    ,213,54,132,227,29,22,246,134,83,166,226,173,158,115,170,20,128\n                    ,198,122,101,199,2,149,64,201,205,136,236,225,190,247,111,9,147\n                    ,155,235,216,202,50,212,47,52,75,207,76,160,197,116,13,230,67\n                    ,210,142,154,112,106,183,133,185,120,209,231,249,139,200,34,31,59\n                    ,60,181,253,51,126,96,167,169,193,233,184,15,44,237,110,151,177\n                    ,168,28,94,161,12,145,129);\n ;return c[a%period];}\n    //i admit, its quite the LUT\n    //but give it a try, because it should be VERY aperiodic, in theory, great for dithering\n    //\n    //sources:\n    //http://jameskbeard.com/jameskbeard/Files.html#CostasArrays\n    //in above link, scroll down to \"Orders 201 through 300\" or \"Orders 476 through 500\"\n    //\n    //https://ieee-dataport.org/open-access/costas-arrays-and-enumeration-order-1030\n    //in above link, login is needed\n\n\n\nvoid mainImage(out vec4 O, vec2 u\n){//u=u.yx\n ;int m=mode\n ;if (m==4)m=int(iTime+2.)%3;  \n ;vec3 c=vec3(0)\n ;if(u.x<float(period-1)*zoom\n   &&u.y<float(period-1)*zoom //if not the blue part\n ){ivec2 U=ivec2(u*float(period)/iResolution.y)\n  ;//U=U.yx                          //sqivel domains\n  //;u*=float(period)/iResolution.y\n  ;//if(u.x<2.)c=vec3(1);\n  ;float f=0.\n  ;int a=0\n  ;if(m==0\n  ){if(ae(U.x)==U.y)a=period;//black or white\n  }else{\n   ;a=ae(U.x)+(U.y)                      //linear gradient\n   ;a=a%period//;if(a>period)a-=period //single overflow   (no mod needed) \n   ;if(m>1\n   ){a=ae(a)+(U.y)     //+1 ae() recursion  //the U.y seems important, may even try U.x\n    ;a=a%period;}}\n  ;f=float(a)/float(period) \n  ;c=vec3(f)\n  ;}else c=vec3(0,0,1);\n ;O=vec4(c,1)\n ;}", "image_inputs": [], "common_code": "/*\nselection of some costasArrays\npersonally i only care for diagonal-mirror-symmetrical costasArrays, because these compress a lot better.\n\nall* symmetrical costas arrays of order 2 are:\n\t1\t2\nall* symmetrical costas arrays of order 3 are:\n\t1\t3\t2\nall* symmetrical costas arrays of order 4 are:\n\t1\t2\t4\t3\nall* symmetrical costas arrays of order 5 are:\n\t1\t3\t4\t2\t5                          <---- demoed \n\t2\t4\t1\t5\t3\nall* symmetrical costas arrays of order 6 are:\n\t1\t4\t5\t3\t2\t6\n\t1\t5\t3\t6\t2\t4\n\t1\t6\t3\t5\t4\t2\n\t1\t6\t4\t3\t5\t2\n\t2\t4\t5\t1\t6\t3\nall* symmetrical costas arrays of order 7 are:\n\t1\t2\t6\t4\t7\t3\t5\n\t1\t2\t7\t4\t6\t5\t3\n\t1\t2\t7\t5\t4\t6\t3\n\t1\t7\t3\t4\t6\t5\t2\n\t2\t1\t5\t7\t3\t6\t4\n\t2\t1\t6\t4\t7\t3\t5\n\t2\t5\t6\t1\t3\t7\t4\n\t2\t5\t6\t4\t1\t7\t3\n\t2\t6\t1\t3\t4\t7\t5\n\t3\t6\t1\t7\t5\t2\t4\nall* symmetrical costas arrays of order 8 are:\n\t1\t5\t8\t4\t2\t7\t6\t3\n\t1\t7\t3\t8\t6\t5\t2\t4\n\t1\t7\t4\t3\t5\t8\t2\t6\n\t3\t5\t1\t8\t2\t7\t6\t4\nall* symmetrical costas arrays of order 9 are:\n\t1\t4\t6\t2\t9\t3\t8\t7\t5\n\t2\t1\t5\t8\t3\t9\t7\t4\t6\nall* symmetrical costas arrays of order 10 are:\n\t1\t7\t4\t9\t3\t5\t8\t6\t2\t10\n\t2\t1\t9\t4\t5\t8\t10\t6\t3\t7\n\t2\t6\t8\t1\t9\t5\t3\t4\t10\t7\n\t2\t8\t9\t4\t1\t3\t7\t5\t10\t6\n\t3\t9\t1\t4\t5\t10\t8\t7\t2\t6\n\t3\t9\t7\t8\t4\t1\t6\t10\t2\t5\t\nall* symmetrical costas arrays of order 11 are:\n\t1\t6\t8\t9\t4\t10\t3\t7\t5\t2\t11\n\t1\t7\t5\t8\t10\t4\t9\t6\t2\t3\t11\n\t1\t7\t11\t6\t8\t4\t2\t5\t10\t9\t3\n\t1\t10\t4\t3\t8\t11\t9\t5\t7\t2\t6\n\t3\t10\t1\t9\t6\t5\t7\t11\t4\t2\t8\nall* symmetrical costas arrays of order 12 are:\n\t1\t2\t8\t12\t7\t9\t5\t3\t6\t11\t10\t4\n\t1\t2\t11\t5\t4\t9\t12\t10\t6\t8\t3\t7\n\t1\t4\t11\t2\t10\t7\t6\t8\t12\t5\t3\t9\n\t3\t6\t1\t12\t10\t2\t7\t9\t8\t5\t11\t4\n\nall* symmetrical costasArrays of order 16 are\n\t1\t13\t3\t16\t14\t8\t10\t6\t15\t7\t12\t11\t2\t5\t9\t4\n\t3\t12\t1\t4\t10\t6\t14\t9\t8\t5\t15\t2\t16\t7\t11\t13\n\t3\t13\t4\t15\t12\t6\t10\t2\t7\t8\t11\t1\t14\t16\t9\t5\n\t6\t14\t10\t7\t9\t1\t4\t16\t5\t3\t12\t11\t15\t2\t13\t8\n\nall* symmetrical costasArrays of order 27 are\n\t1\t25\t19\t5\t4\t12\t10\t16\t26\t7\t18\t6\t23\t27\t24\t8\t21\t11\t3\t22\t17\t20\t13\t15\t2\t9\t14\n\t3\t9\t1\t8\t13\t15\t19\t4\t2\t20\t11\t25\t5\t17\t6\t27\t14\t24\t7\t10\t26\t23\t22\t18\t12\t21\t16\n\t3\t24\t10\t26\t20\t15\t13\t23\t14\t1\t8\t4\t22\t19\t21\t2\t5\t25\t9\t17\t6\t7\t11\t16\t27\t12\t18\n\t4\t17\t21\t9\t11\t16\t25\t12\t1\t7\t26\t22\t14\t15\t13\t20\t23\t3\t24\t6\t18\t8\t2\t27\t10\t5\t19\n\t6\t10\t23\t13\t16\t1\t11\t20\t15\t2\t7\t26\t4\t27\t9\t5\t19\t25\t17\t8\t24\t22\t3\t21\t18\t12\t14\n\t6\t16\t20\t12\t14\t7\t1\t25\t8\t17\t18\t26\t11\t23\t10\t24\t15\t13\t3\t19\t22\t27\t5\t2\t9\t4\t21\n\t6\t23\t14\t8\t21\t1\t26\t4\t22\t20\t12\t11\t16\t3\t17\t13\t15\t24\t27\t10\t5\t9\t2\t18\t25\t7\t19\n\n[*]== there are more than these BUT these extra costas-arrays are just a few SPECIFIC diagonal offsets \n(aslong the mirror axis) of the ones that are listed.\nand theres always the 4 axisAligned mirrors of g-symmetry.\n\nsome symmetrical costasArrays f order 30 are:\n\t1\t23\t14\t12\t18\t26\t30\t20\t25\t11\t10\t4\t16\t3\t21\t13\t22\t5\t19\t8\t15\t17\t2\t28\t9\t6\t29\t24\t27\t7\n\t11\t22\t5\t13\t23\t10\t2\t26\t29\t15\t19\t20\t14\t4\t6\t21\t18\t27\t1\t30\t25\t7\t3\t9\t16\t28\t17\t8\t24\t12\n\t12\t24\t20\t17\t2\t9\t29\t3\t16\t4\t28\t18\t19\t27\t22\t6\t10\t1\t30\t8\t14\t25\t11\t5\t15\t7\t21\t23\t26\t13\n\t13\t26\t2\t21\t29\t4\t9\t11\t15\t27\t12\t8\t17\t18\t7\t22\t1\t30\t20\t23\t6\t24\t19\t16\t10\t3\t25\t5\t28\t14\n\na symmetrical costas array of order 35 is:\n\t1\t12\t7\t27\t32\t30\t3\t24\t31\t17\t19\t2\t16\t29\t20\t13\t10\t35\t11\t15\t23\t33\t21\t8\t26\t25\t4\t34\t14\t6\t9\t5\t22\t28\t18\n\t\na symmetrical costas array of order 65 is:\n\t1\t29\t46\t16\t24\t37\t17\t22\t12\t63\t55\t9\t15\t42\t13\t4\t7\t26\t44\t56\t50\t8\t49\t5\t40\t18\t32\t34\t2\t54\t51\t27\t65\t28\t53\t57\t6\t39\t38\t25\t48\t14\t59\t19\t62\t3\t58\t41\t23\t21\t31\t61\t35\t30\t11\t20\t36\t47\t43\t64\t52\t45\t10\t60\t33\n\na symmetrical costas array of order 99 is:\n1\t33\t94\t11\t21\t59\t40\t85\t39\t44\t4\t75\t88\t36\t73\t56\t60\t45\t67\t61\t5\t24\t55\t22\t87\t30\t92\t64\t37\t26\t49\t51\t2\t79\t38\t14\t29\t35\t9\t7\t97\t63\t89\t10\t18\t70\t62\t76\t31\t99\t32\t78\t65\t74\t23\t16\t96\t71\t6\t17\t20\t47\t42\t28\t53\t95\t19\t69\t68\t46\t58\t86\t15\t54\t12\t48\t82\t52\t34\t91\t98\t77\t93\t90\t8\t72\t25\t13\t43\t84\t80\t27\t83\t3\t66\t57\t41\t81\t50\n\n/**/\n\n/*\n\n//for compatibility with old opengl versions \n//(and to make arrays forksafe)\n//define shitty array struct\n//, with get()set()wrappers and constant array length code.\n//maxlen 27 ceashes too many tested environments (this first version is a bit shitty, too)\n#define maxLen 26\nstruct arr{int a[maxLen];int len;};\nvoid setN(inout arr u,int n,int s){n=clamp(n,1,maxLen);u.len=max(u.len,n);u.a[n-1]=s;}\nint  getN(arr u,int n){return u.a[clamp(n-1,0,u.len-1)];}//worksafing clamp()is faster than mod()\narr  newA(){arr r; r.len=1; r.a[0]=0;return r;}\n\n\n//modify setArray()to set the size of the array \n//AND the height of its pixels (last parameter)\n//theres only 1 pixel per column (later ones overwrite earlier ones)\n//any 2 pixels in the same line will be marked in white\n//where this is found ONCE (is not a CostasArray in that case)\narr setArray(){ //this could be read from a vertex buffer.\n ;arr a=newA()\n ;setN(a,1,1)\n ;setN(a,2,3)\n ;setN(a,3,4)\n ;setN(a,4,2)\n ;setN(a,5,5)\n\n//slow checker if an \n//struct arr{int a[maxLen];int len;}; \n//is a costasArray: https://www.shadertoy.com/view/tdjXWh\n//return array type[arr] as list of differentials of [a] with indexDistance [d]=[0<d<a.len]\narr strideDiff(arr a,int d\n){arr r=newA()\n ;for(int i=1;i<maxLen;i++\n ){setN(r,i,getN(a,i)-getN(a,i+d))\n  ;if (i+d>=a.len)break;}\n ;return r;}\n//getDupeEntry;\n//return pointers to the first 2 found duplicate entries in [a], comparing from a[0] till a[l].\n//if (there are no duplicate entry in [a] till entry a[l] )return ivec2(-1,-1)\nivec2 getDupeEntryS(ivec2 r,arr a,int i,int j\n){for(i=1;i<j;i++){if(getN(a,i)==getN(a,j))return ivec2(i,j);}\n ;return r;}\nivec2 getDupeEntry(arr a\n){ivec2 r=ivec2(-1,-1)//default state of [no dupes found]\n ;for(int i=0;i<maxLen-1;i++\n ){if(i==a.len)return r\n  ;r=getDupeEntryS(r,a,i,a.len-i)\n ;}return r;}\n//return if [a] is a [costas array] of order [a.len]\nivec3 isCostas(arr a\n){for(int i=1;i<=a.len;i++\n ){ivec2 dupes=getDupeEntry(strideDiff(a,i))\n  ;if(dupes.x!=-1)return ivec3(dupes,i);//return 2 indexes of found duplicate differential and dx\n  ;}\n ;return ivec3(-1,-1,-1);}//case of no dupes AND all in bounds == is costas Array\n\n/**/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsdfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2933, 3037, 3051, 3051, 4464], [4899, 4899, 4935, 4943, 5680]]}
{"id": "wsVcWd", "name": "State of the art", "author": "xjorma", "description": "My tribute to the \"State of the art\" by Spaceballs\n1st place at \"The Party\" 1992\nhttps://www.youtube.com/watch?v=89wq5EoXy-0\nMusic by Travolta.\n\nThanks Nicholas FitzRoy-Dale for the animation! https://github.com/nfd/sota/tree/master/shapes", "tags": ["2d", "demoscene", "amiga", "demo", "animation", "vector", "vector", "dance", "reproduction", "spaceballs", "stateoftheart", "sota"], "likes": 53, "viewed": 4987, "published": 3, "date": "1604247074", "time_retrieved": "2024-07-30T20:37:13.242976", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\n\nvec4 Load(in int vtxIdx, in int frame, in sampler2D s)\n{\n\treturn texelFetch(s, ivec2(vtxIdx, frame), 0);\n}\n\n// By IQ https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2[maxVert] v, in vec2 p, in int num )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nvec4 sdPoly(in vec2 p, in int frame, in sampler2D s, in int nbPt, in int stride)\n{\n    vec4 o;\n    for(int j = 0; j < 4; j++)\n    {\n\t    vec2[maxVert] v;\n        for(int i = 0; i < stride; i++)\n        {\n            vec4 lv = Load(i, (3 - j) * 3, s);\n            v[i*2 + 0] = (lv.xy - 127.) / 95. + vec2(0,0.1);\n            v[i*2 + 1] = (lv.zw - 127.) / 95. + vec2(0,0.1);\n        }\n        o[j] = sdPoly(v, p, nbPt);\n    }\n    return o;\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(3. / iResolution.y, 0., v);\n}\n\nfloat triangleSignal(float x, float f)\n{\n    f = 1. / f;\n    return (abs((f * x - 4. * floor(0.25 * f * x)) - 2.) - 1.) / f;\n}\n\nvec3 circle(in vec2 p, in float tp, in float tc)\n{\n    float v0 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.5 + 1.2), sin(tp * 0.7 + 3.2))), 0.01));\n    float v1 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.6 + 0.3), sin(tp * 0.83 + 2.7))), 0.01));\n    vec3 cb = vec3(sin(tc * 0.41 + 1.3),sin(tc * 0.52 + 2.4), sin(tc * 0.57 + 1.25)) / 2. + 0.5;\n    vec3 c0 = vec3(sin(tc * 0.37 + 2.7),sin(tc * 0.39 + 3.9), sin(tc * 0.29 + 5.36)) / 2. + 0.5;;\n    vec3 c1 = vec3(sin(tc * 0.39 + 1.6),sin(tc * 0.43 + 4.5), sin(tc * 0.47 + 6.23)) / 2. + 0.5;;\n    return mix(mix(cb, c0, v0), c1, v1);\n}\n\nvec3 noisyCircle(in vec2 p, in float t)\n{\n    float h = hash13(vec3(floor(p * 100.),floor(t * 10.))); \n    vec3 cb = vec3(sin(t * 0.28 + 5.3),sin(t * 0.48 + 2.4), sin(t * 0.43 + 2.25)) / 2. + 0.5;\n    vec3 c0 = vec3(sin(t * 0.31 + 2.7),sin(t * 0.58 + 3.9), sin(t * 0.47 + 4.36)) / 2. + 0.5;\n    float v = distFilter(triangleSignal(length(p) - iTime, 0.1) - 0.05);\n    return vec3(h * v > 0.5?  cb : c0);\n}\n\nfloat seqLength = 2.f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tseqId = floor(iTime / seqLength);\n    int\t\tselect;\n\n    // Select Shape\n    select = int(hash12(vec2(seqId, 0.)) * 3.);  \n    vec4 shapeDist;\n    switch (select)\n    {\n        case 0:\n            shapeDist = sdPoly(p, iFrame % 13, iChannel1, AnbVertices, Astride);\n            break;\n        case 1:\n            shapeDist = sdPoly(p, iFrame % 13, iChannel2, BnbVertices, Bstride);\n            break;\n        case 2:\n            shapeDist = sdPoly(p, iFrame % 13, iChannel3, CnbVertices, Cstride);\n            break;\n    }\n    // select Shape Effect\n    float shapeMask;\n    select = int(hash12(vec2(seqId, 1.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            shapeMask = distFilter(shapeDist.x);\n            break;\n        case 1:\n            shapeMask = distFilter(abs(shapeDist.x) - 0.01);\n            break;\n        case 2:\n            shapeMask = max(distFilter(shapeDist.x), max(distFilter(shapeDist.y) * 0.75, max(distFilter(shapeDist.z) * 0.50, distFilter(shapeDist.w) * 0.25)));\n            break;\n    }\n    // Select backgroud\n    vec3 backCol;\n    select = int(hash12(vec2(seqId, 2.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            backCol = circle(p, iTime, iTime);\n            break;\n        case 1:\n            backCol = 0.5 + 0.5*cos(iTime + p.xyx + vec3(0,2,4));\n            break;\n        case 2:\n            backCol = noisyCircle(p, iTime);\n            break;        \n    }\n    // Select foreground\n    vec3 foreCol;\n    select = int(hash12(vec2(seqId, 3.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            foreCol = vec3(0);\n            break;\n        case 1:\n            foreCol = vec3(1);\n            break;\n        case 2:\n            foreCol = circle(p, iTime, iTime + 22.3);\n            break;        \n    }\n\n    vec3 col = mix(backCol, foreCol, shapeMask);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24416, "src": "https://soundcloud.com/david-gallardo-492062428/state-of-the-art", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const uint vertices[338] = uint[](\n0xa10d9c28U, 0x973c954aU, 0x90569d7bU, 0xa372b950U, 0xd44fd850U, 0xe556ec5fU, 0xe461cf5aU, 0xc559b867U, 0xa39893aeU, 0x96b99bc1U, 0x95cc89d9U, 0x72d96acbU, 0x65bc73abU, 0x61a855a2U, 0x3b9b2fb3U, 0x25b71eb9U, 0x11b60fb1U, 0x12af17adU, 0x1ead27a6U, 0x2e8e5d8dU, 0x60735d54U, 0x56485135U, 0x4c1e4a0dU, 0x6d0d7215U, 0x77217a17U, 0x7c0e00d9U, \n0xa70da52aU, 0xa743a555U, 0xb077b98cU, 0xcc9cd494U, 0xdc91df89U, 0xe185e388U, 0xea90e89fU, 0xd7a8bfadU, 0xaab1a1b7U, 0x9fbf9ec9U, 0x9ad286d9U, 0x78d570ccU, 0x6ec278b7U, 0x7bad74a2U, 0x65965183U, 0x4587379aU, 0x3aab39b5U, 0x34b72eacU, 0x2c9d308fU, 0x48715d79U, 0x72747167U, 0x6a515e3cU, 0x5521510dU, 0x720d7617U, 0x7f23821aU, 0x860d00d9U, \n0xab0da330U, 0xa2489e54U, 0x9b689d86U, 0xa69ebdabU, 0xcbb0cea8U, 0xca9ecf96U, 0xd89bdaaaU, 0xd9bbcec3U, 0xadb78cb0U, 0x8bbb91c4U, 0x91ca85d9U, 0x66d95fd3U, 0x5bcc6cb3U, 0x6fa858a0U, 0x5097476eU, 0x36631e62U, 0x1c6b1279U, 0x0e760d6aU, 0x12592b55U, 0x4d5b627aU, 0x6b626653U, 0x5d44592fU, 0x571b5b0dU, 0x7a0d7a13U, 0x81238618U, 0x880d00d9U, \n0xb00da430U, 0x9d40964eU, 0x8e5e8b7eU, 0x938dba88U, 0xc48fcca6U, 0xd4a4d7a2U, 0xe2a4d6acU, 0xc7aeb997U, 0xa19b83a8U, 0x85b98fc1U, 0x89c883d9U, 0x66d961cfU, 0x5bc865b2U, 0x63ac51a4U, 0x459a377fU, 0x286d1656U, 0x0e44033cU, 0x03320a34U, 0x15402654U, 0x3e6f4d7bU, 0x5b615d54U, 0x5d445b33U, 0x581a590dU, 0x810d8012U, 0x81208715U, 0x890d00d9U, \n0xa50d9d29U, 0x99378c50U, 0x845a8779U, 0x8e7fb16bU, 0xd278da7cU, 0xdc80de8fU, 0xda95d495U, 0xcf80b179U, 0x999187a7U, 0x86b595c0U, 0x8dcb83d9U, 0x66d961cfU, 0x5bc865b2U, 0x5faf4faaU, 0x41a13095U, 0x1a8d037dU, 0x0074005dU, 0x03510851U, 0x0e5e096fU, 0x3286488aU, 0x54605752U, 0x4f444b30U, 0x4a194d0dU, 0x740d7517U, 0x77237a1bU, 0x800d00d9U, \n0x9b0d9429U, 0x903b8b4fU, 0x845a897aU, 0x917dac57U, 0xc94fd84fU, 0xe058e366U, 0xdd6dd156U, 0xc45baf6eU, 0x9e928eacU, 0x94c29bc8U, 0x8fd18ed9U, 0x6cd96aceU, 0x64c76db3U, 0x60b650b7U, 0x45b835baU, 0x1eba06aaU, 0x00930485U, 0x0b850a99U, 0x1ba924adU, 0x3ea85196U, 0x50624f54U, 0x4b484538U, 0x431c460dU, 0x680d6715U, 0x6b277418U, 0x780e00d9U, \n0x9b0d9429U, 0x923c9048U, 0x8a579578U, 0x9b77ad51U, 0xd047da48U, 0xe74fec5bU, 0xe45ed052U, 0xc356b463U, 0xa19590abU, 0x96b99ec3U, 0x94ca8cd6U, 0x74d76cc8U, 0x65bc73abU, 0x62ad54acU, 0x41ad30b6U, 0x20bd10b9U, 0x05b503aeU, 0x06ac0baeU, 0x15b122acU, 0x359e5894U, 0x5b725852U, 0x50444a33U, 0x471c450dU, 0x690d6b16U, 0x6f217316U, 0x760d00d9U, \n0x9c0d9d2fU, 0x9b469b56U, 0xa064ab79U, 0xbb84d083U, 0xe07cde69U, 0xe162e765U, 0xeb7ae986U, 0xdb8ac792U, 0xaf9d99adU, 0x9fb1a6c0U, 0x9cca99d7U, 0x7ed772c8U, 0x70bb7cb0U, 0x7ca86ea0U, 0x63994e8fU, 0x3f9b37a3U, 0x38b536c1U, 0x2fc42ab8U, 0x2aa73293U, 0x477d6a89U, 0x6e696457U, 0x5947522eU, 0x4d174b0dU, 0x6b0d6b12U, 0x76207917U, 0x7b0d00d9U, \n0xa50da330U, 0xa2489e54U, 0xa464a77cU, 0xaf97bfa3U, 0xcda6d3a6U, 0xd19ad892U, 0xe097e1aeU, 0xdfb8d0bbU, 0xb1b494afU, 0x92b799c2U, 0x93cb8cd8U, 0x6fd869ceU, 0x63c870afU, 0x73a66ba2U, 0x60984670U, 0x3973257dU, 0x268d2199U, 0x1b981889U, 0x19782d68U, 0x4b5d6d7eU, 0x6e636653U, 0x5d44572eU, 0x5319530dU, 0x710d7214U, 0x7c268018U, 0x830d00d9U, \n0xb00da731U, 0xa3449c51U, 0x95619082U, 0x9998c29fU, 0xc4a1cba8U, 0xd4a4d7a2U, 0xdda5cfbdU, 0xc4bfb7a9U, 0xa3a985aeU, 0x85b98fc2U, 0x8bc983d9U, 0x66d95bd3U, 0x59c768b3U, 0x67ab54a5U, 0x4a973973U, 0x295f1f4fU, 0x12490746U, 0x073e1238U, 0x20422e4dU, 0x4263527bU, 0x60606453U, 0x5f435c31U, 0x5b1b5b0dU, 0x810d8012U, 0x83248916U, 0x8f0d00d9U, \n0xa90da02bU, 0x9b388d4fU, 0x885b8979U, 0x9184b475U, 0xca84d48fU, 0xd794db98U, 0xe0a3daa7U, 0xd39eb685U, 0x999184a5U, 0x86b591bdU, 0x89c883d9U, 0x66d961cfU, 0x5bc865b2U, 0x61ac50a4U, 0x459a348bU, 0x227c0e6bU, 0x06600156U, 0x05400837U, 0x10450e59U, 0x3a794980U, 0x575f5752U, 0x55415430U, 0x521b520dU, 0x7a0d7a17U, 0x7b1f8313U, 0x830d00d9U, \n0xa10d9a2bU, 0x923a8b4fU, 0x845a8879U, 0x917daf63U, 0xd062d967U, 0xdb75db7cU, 0xd67dd37dU, 0xcd6bb271U, 0x99918babU, 0x90bb98c8U, 0x8dd08ed9U, 0x69d967cfU, 0x62c66bb6U, 0x5eb151b1U, 0x44ad38acU, 0x1aa50092U, 0x0086006dU, 0x04700574U, 0x0a880e91U, 0x3e964c8fU, 0x50625355U, 0x4f4b4938U, 0x461b460dU, 0x6c0d6d14U, 0x6f27761aU, 0x800d00d9U, \n0x9b0d9429U, 0x903b8b4aU, 0x84579378U, 0x9777ac54U, 0xcd44da46U, 0xe74beb58U, 0xe25ad14eU, 0xc356b162U, 0x9e928eacU, 0x95c09bc6U, 0x8fd18cd6U, 0x70d86cc8U, 0x66c06db0U, 0x62b14eb3U, 0x43b632bdU, 0x20bd0fb1U, 0x07a50399U, 0x09910c9dU, 0x19ad23b1U, 0x3ea85796U, 0x53625154U, 0x4b484538U, 0x431c430dU, 0x640d6715U, 0x6c237016U, 0x730d00d9U);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Astride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % AnbFrames) * Astride];\n    vec4 v0 = vec4(vec2(cv0>>24, (cv0>>16)&255U),vec2((cv0>>8)&255U, (cv0)&255U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % AnbFrames) * Astride];\n    vec4 v1 = vec4(vec2(cv1>>24, (cv1>>16)&255U),vec2((cv1>>8)&255U, (cv1)&255U));\n    vec4 v = mix(v0, v1, fract(frame));\n    fragColor = v;\n}\n", "buffer_a_inputs": [], "common_code": "const int maxVert = 56;\n\nconst int AnbFrames = 13;\nconst int AnbVertices = 51;\nconst int Astride = 26;\n\nconst int BnbFrames = 10;\nconst int BnbVertices = 52;\nconst int Bstride = 26;\n\nconst int CnbFrames = 8;\nconst int CnbVertices = 55;\nconst int Cstride = 28;\n\n\n// From https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_b_code": "const uint vertices[260] = uint[](\n0x440d4d2aU, 0x59496662U, 0x716c7675U, 0x6d846b88U, 0x5960545fU, 0x31862a8cU, 0x148d1390U, 0x18942b93U, 0x348e4879U, 0x50785692U, 0x5dac68bcU, 0x66c45dd0U, 0x5ad75ad9U, 0x8bd98cd4U, 0x8cd29bd6U, 0xafd9b4d9U, 0xb9d9bed9U, 0xc2d9cdd9U, 0xd5d9c8cfU, 0xb1bdacb5U, 0xa87aa369U, 0xa45fac42U, 0xb61dba0dU, 0x990d8e1fU, 0x81397e39U, 0x7122630dU, \n0x440d4d29U, 0x5848655bU, 0x726a7573U, 0x707b6b7fU, 0x56594f59U, 0x2c7e2586U, 0x1688128bU, 0x178e298cU, 0x33814e6cU, 0x51765791U, 0x5fa968bcU, 0x62c05fd0U, 0x5dd85ad9U, 0x8bd98bd7U, 0x8cce8fc7U, 0xb1ccc2d0U, 0xc3d4c2d9U, 0xc2d9cdd9U, 0xd5d9d8c5U, 0xb6b0aca9U, 0xab7aa767U, 0xa65fa945U, 0xa929b30dU, 0x8b0d861bU, 0x81297a2eU, 0x7020630dU, \n0x440d4d29U, 0x5947655dU, 0x726a7573U, 0x6a88648bU, 0x4c664265U, 0x2f7f1e98U, 0x0e97089aU, 0x0d9c219dU, 0x35874276U, 0x497f5196U, 0x5dab6cc0U, 0x63c662d0U, 0x61d662d9U, 0x8bd98bd7U, 0x8cce90caU, 0xb6c6ccc4U, 0xd0d3d4d9U, 0xd7d9dbd9U, 0xdfd9dab2U, 0xb2acaaaaU, 0xa97ba569U, 0xa261a741U, 0xac27b30dU, 0x900d881bU, 0x822a7c32U, 0x6f21630dU, \n0x490d4e29U, 0x56495e63U, 0x69746682U, 0x5ea158a0U, 0x438c3785U, 0x2f8916b6U, 0x0ebc00c0U, 0x04c317c0U, 0x25ad329bU, 0x389847a9U, 0x54b85ac2U, 0x5ec967cfU, 0x69d46bd9U, 0x8bd98bd7U, 0x93d79ad6U, 0xb6c5cdb8U, 0xe4d4ead7U, 0xfdd7ffd4U, 0xecced5a6U, 0xc9a4a5b4U, 0xa1849f76U, 0xa461ab40U, 0xb025b50dU, 0x9a0d9120U, 0x853b8140U, 0x6c22630dU, \n0x490d4e29U, 0x56495e63U, 0x64756386U, 0x53ad4eb1U, 0x29a71da3U, 0x17a913b1U, 0x10bd0cd9U, 0x13d917d9U, 0x1bc71ebeU, 0x25b72fb9U, 0x36be3cc3U, 0x50d255d7U, 0x61d96bd9U, 0x8bd98bd7U, 0x93d79ad6U, 0xb4b6c7a7U, 0xe7bdf1beU, 0xffbbfeb7U, 0xf4b8c594U, 0xbb959db1U, 0x988d997bU, 0xa461ab40U, 0xb327ba0dU, 0x9e0d9622U, 0x8a3b8345U, 0x6e22680dU, \n0x490d5528U, 0x5b485e63U, 0x61735983U, 0x4fab48b2U, 0x29b61bb7U, 0x13bc0fc1U, 0x0fcb11d9U, 0x15d91ed9U, 0x20ca25c7U, 0x2ac731c7U, 0x37c849cbU, 0x50d056d5U, 0x61d96bd9U, 0x85d98bd8U, 0x91cd97c7U, 0xb692c695U, 0xe0a0e99fU, 0xf995f992U, 0xe596b57eU, 0xab829798U, 0x9482997bU, 0xa660b140U, 0xb828c00eU, 0x9e0d9622U, 0x8f358940U, 0x781f6e0dU, \n0x500d5721U, 0x5d306050U, 0x6363587bU, 0x499f40afU, 0x2bb722bbU, 0x19c117c5U, 0x14cc16d2U, 0x1ad929d9U, 0x29d12bccU, 0x2dcb31c9U, 0x37c84ac5U, 0x5dc761ccU, 0x61d996d9U, 0x95d191c7U, 0x94b39eaaU, 0xaa77c27cU, 0xd083d981U, 0xec73eb6fU, 0xd679a364U, 0x9b6c977dU, 0x926c9f67U, 0xa65cb140U, 0xb928c20dU, 0xa30da016U, 0x96269130U, 0x7e1c760eU, \n0x4c0d5421U, 0x5a345e48U, 0x63635a7cU, 0x499f40afU, 0x2bb722bbU, 0x19be14c4U, 0x15cc16d2U, 0x1ad929d9U, 0x26d127ccU, 0x28ca2fc8U, 0x37c84bc6U, 0x60c964ceU, 0x61d996d9U, 0x95d18fc7U, 0x96b7a0acU, 0xaf85b77eU, 0xce86da8aU, 0xe98be786U, 0xd884b26bU, 0xa870978aU, 0x91739d68U, 0xa55cb140U, 0xb928c20dU, 0x9e0d981dU, 0x93298a30U, 0x791c730dU, \n0x480d5026U, 0x553f5a5aU, 0x646c5b9dU, 0x55b541b2U, 0x2db120b0U, 0x1bb515c4U, 0x13cc12d4U, 0x12d921d9U, 0x23d125ccU, 0x27c32ec3U, 0x39c549cbU, 0x52d059d8U, 0x5dd996d9U, 0x95d19ec8U, 0xa7c5b5b3U, 0xc49fcc9eU, 0xe9bdefc9U, 0xf6c6f8bfU, 0xf0b8d38eU, 0xc58aa1a5U, 0x9778a068U, 0xa55cad3fU, 0xb424b80dU, 0x9e0d971aU, 0x91268542U, 0x75276a0fU, \n0x480d5026U, 0x553f5965U, 0x677d66a4U, 0x5fb546a6U, 0x359a2e9bU, 0x1bb515c4U, 0x10cf04d3U, 0x02d712d5U, 0x16cf1cc9U, 0x27bb30b1U, 0x36ae4cc3U, 0x54cd5bd6U, 0x5dd99fd9U, 0xa5d7b2d0U, 0xbaccc9c4U, 0xd6bfdec3U, 0xe1cfe4d9U, 0xead9f1d9U, 0xe7b9e3b1U, 0xddacb2b6U, 0x9c79a069U, 0xa45da650U, 0xab28b30dU, 0x980d9517U, 0x8f237c43U, 0x6e28610dU);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Bstride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % BnbFrames) * Bstride];\n    vec4 v0 = vec4(vec2(cv0>>24, (cv0>>16)&255U),vec2((cv0>>8)&255U, (cv0)&255U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % BnbFrames) * Bstride];\n    vec4 v1 = vec4(vec2(cv1>>24, (cv1>>16)&255U),vec2((cv1>>8)&255U, (cv1)&255U));\n    vec4 v = mix(v0, v1, fract(frame));\n    fragColor = v;\n}\n", "buffer_b_inputs": [], "buffer_c_code": "const uint vertices[224] = uint[](\n0x610d6016U, 0x58205016U, 0x4c0d360dU, 0x35263a3eU, 0x404f456bU, 0x428734a4U, 0x2dc12dd2U, 0x2ed82dd9U, 0x30d935d9U, 0x34d135caU, 0x3ab7479eU, 0x519655a5U, 0x5baf61b3U, 0x6bb171abU, 0x749d7495U, 0x728b7686U, 0x7d838981U, 0x9a81a285U, 0xa492a59cU, 0xa3a3a5adU, 0xaaadada6U, 0xae96ab85U, 0xa67b9e76U, 0x95738372U, 0x776f6e65U, 0x6c517036U, 0x742d791fU, 0x7d0d00d9U, \n0x650d6414U, 0x5b205215U, 0x4d0d360dU, 0x35203a3eU, 0x404f456bU, 0x428733a3U, 0x2dc12ed2U, 0x30d82dd9U, 0x30d938d9U, 0x36d137c8U, 0x3ab7479eU, 0x519655a5U, 0x5baf61b3U, 0x6bb171abU, 0x749d7499U, 0x718f7a8eU, 0x808d8d8dU, 0x9994a499U, 0xa5a2a5a9U, 0xa1b19dbcU, 0xa1bca7baU, 0xae98aa8fU, 0xa0899684U, 0x8e7f857aU, 0x7f75746bU, 0x70507236U, 0x772e7d1fU, 0x810d00d9U, \n0x620d6116U, 0x5b285018U, 0x4d0d360dU, 0x35203a3eU, 0x4457496dU, 0x43892f9eU, 0x25b028c3U, 0x30d333d5U, 0x39d340cdU, 0x3ec636c6U, 0x33af3fa1U, 0x4f9851a9U, 0x54b65bbcU, 0x67bb6fb5U, 0x72a9729fU, 0x71937893U, 0x7e958d9bU, 0x97a09faaU, 0xa2b4a2baU, 0x99c297caU, 0x9dcca7c6U, 0xabafa7a0U, 0x9e96948eU, 0x8a878180U, 0x7d79776eU, 0x7251723cU, 0x77307b1fU, 0x7d0d00d9U, \n0x620d6016U, 0x5a2a5019U, 0x4d0d360dU, 0x35213a3eU, 0x495d4b6eU, 0x43872e97U, 0x23a228bcU, 0x33cc39ceU, 0x41ca46c2U, 0x43bc36c1U, 0x31a53d9dU, 0x4d984fabU, 0x51b959c0U, 0x65c06ebaU, 0x71af71a3U, 0x71977697U, 0x7c9a89a2U, 0x92a898b3U, 0x9cbe9dc4U, 0x95ce95d3U, 0x9cd6a4ccU, 0xa5baa1aaU, 0x999d9094U, 0x888b8181U, 0x7e7a7a6fU, 0x7551733fU, 0x77317a1fU, 0x7c0d00d9U, \n0x650d6016U, 0x58285118U, 0x4f0d360dU, 0x35233b3eU, 0x4d634c6eU, 0x4283308eU, 0x25972ebcU, 0x39c43fc3U, 0x47bd48b8U, 0x45b238b7U, 0x339b4293U, 0x4c954fabU, 0x51b959c0U, 0x65c06ebaU, 0x71af71a5U, 0x729a749aU, 0x7a9e81a4U, 0x8aac90b5U, 0x92bf96c8U, 0x95d496d9U, 0x9ed99fccU, 0x9dba97aeU, 0x909d8a96U, 0x888b847fU, 0x80767d6dU, 0x7750753fU, 0x77317b1fU, 0x7c0d00d9U, \n0x630d6019U, 0x59285119U, 0x4c0d360dU, 0x36243e3dU, 0x4d5e4c6cU, 0x45793183U, 0x26892eb0U, 0x39bb3fbcU, 0x46b948b6U, 0x45b138b1U, 0x348f408cU, 0x4a934ca5U, 0x51b45cbaU, 0x65ba6db6U, 0x73ab73a3U, 0x7298759aU, 0x7a9e81a4U, 0x86ae8ab9U, 0x8bc28ecaU, 0x8ed48ed9U, 0x98d998ceU, 0x96c092b4U, 0x8d9f8a96U, 0x888b867fU, 0x84758067U, 0x7a557644U, 0x77317b1fU, 0x7c0d00d9U, \n0x640d601aU, 0x5a275119U, 0x4b0d340dU, 0x3723413cU, 0x4f595166U, 0x4b6f2f7bU, 0x27812ea6U, 0x3ab440b6U, 0x46b648b3U, 0x44ae38a9U, 0x35863f85U, 0x49914ca2U, 0x53b05db5U, 0x65b56cb1U, 0x73a974a2U, 0x7399769bU, 0x7b9d7fa5U, 0x81af84bcU, 0x85c487cbU, 0x89d489d9U, 0x93d993d0U, 0x91c38eb7U, 0x8ba18998U, 0x888b877eU, 0x86748365U, 0x7e577746U, 0x77327b1fU, 0x7e0d00d9U, \n0x670d611aU, 0x5c255119U, 0x4b0d320dU, 0x3720443cU, 0x53535b5eU, 0x54662b76U, 0x277d309fU, 0x3bae42b2U, 0x48b249b0U, 0x42a838a1U, 0x3580417eU, 0x489050a1U, 0x55ac5cafU, 0x64af6aadU, 0x70a873a2U, 0x759c779cU, 0x7b9d7ca6U, 0x7daf80bdU, 0x81c483ccU, 0x85d486d9U, 0x91d990d2U, 0x8dc58cb8U, 0x89a3889aU, 0x888b877eU, 0x86748665U, 0x82577945U, 0x78327c1fU, 0x820d00d9U);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    frame = (sin(frame) + 1.) * 3.5;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Cstride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % CnbFrames) * Cstride];\n    vec4 v0 = vec4(vec2(cv0>>24, (cv0>>16)&255U),vec2((cv0>>8)&255U, (cv0)&255U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % CnbFrames) * Cstride];\n    vec4 v1 = vec4(vec2(cv1>>24, (cv1>>16)&255U),vec2((cv1>>8)&255U, (cv1)&255U));\n    vec4 v = mix(v0, v1, fract(frame));\n    //vec4 v = v0;\n    fragColor = v;\n}\n", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[113, 113, 138, 138, 157], [158, 158, 198, 198, 230], [233, 233, 289, 289, 339], [1405, 1405, 1432, 1432, 1484], [1486, 1486, 1526, 1526, 1612], [1614, 1614, 1664, 1664, 2219], [2221, 2221, 2262, 2262, 2626], [2652, 2652, 2709, 2709, 4630]]}
{"id": "tdtBRn", "name": "Yet another fractal tunnel", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3s3Bzn]\"Broken chains\"[/url] fractal.\nUse the mouse to look around.", "tags": ["fractal", "tunnel"], "likes": 4, "viewed": 452, "published": 3, "date": "1604246114", "time_retrieved": "2024-07-30T20:37:14.088714", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)/(2.0+cos(p)))-.6);\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result = -sceneSDF1(p);\n    //float result;\n    for(float i = 3.0; i < 81.0; i *= 3.0){\n        result = min(-result, sceneSDF1(p/i)*i);\n    }\n    return -result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 30.0;\n    return sin(vec3(sceneSDF1(p/7.0),sceneSDF1(p/11.0),sceneSDF1(p/13.0)));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    vec3 eye = vec3(iTime*100.0,0,0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 2000.0);\n    //t = t % 15000;\n    t = (t%(9))-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 9; i++){\n        result += sound1(factor);\n        //result /= factor;\n    }\n    return result/10.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 489, 514, 514, 565], [567, 567, 590, 590, 762], [764, 764, 792, 792, 885], [887, 1308, 1399, 1399, 1713], [1728, 1982, 2047, 2047, 2179], [2181, 2270, 2302, 2302, 2492], [2494, 2986, 3126, 3126, 3716], [3718, 4088, 4173, 4173, 4931], [4933, 5260, 5309, 5344, 5475], [5477, 5477, 5534, 5534, 6523]]}
{"id": "3ddfzr", "name": "smooth dot background", "author": "oatmealine", "description": "i don't remember any of how this was written so i am sorry if the code is completely incomprehensible", "tags": ["2d", "simple", "abstract", "background"], "likes": 0, "viewed": 148, "published": 3, "date": "1604243954", "time_retrieved": "2024-07-30T20:37:14.932459", "image_code": "vec3 background(vec2 uv) {\n    vec2 bguv = uv+.01*sin(209.*uv);\n    return vec3(.2,.2,.3) * (mod(bguv.y+bguv.x*.3*cos(iTime+bguv.y*6.),(-bguv.x)*.7)*.9+.95);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(background(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 159], [161, 161, 216, 216, 363]]}
{"id": "WdtBRr", "name": "spectral color shift with depth", "author": "FabriceNeyret2", "description": "Sphere material transmittance = 2 peaks of different values, which are thus extinguished differently with depth. \nWeights are accounted for approximating larger lobes. ( cf lines #92,93 ).\n\n[url]https://en.wikipedia.org/wiki/Dichromatism[/url]", "tags": ["wavelength", "cie", "xyzcolorspace", "metamerism", "dichromatism"], "likes": 3, "viewed": 445, "published": 3, "date": "1604227518", "time_retrieved": "2024-07-30T20:37:15.771216", "image_code": "// perceived colors: from https://www.shadertoy.com/view/llKSDz\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\n\n// Spectrum to xyz approx function from Sloan\n// Inputs:  Wavelength in nanometers\n\n#define G(t)                         exp(-.5* (t)*(t) ) \n#define bislope( wave, w, l, r )  ( wave - w ) * ( wave < w ? l : r )\n\nfloat xFit_1931( float wave )\n{\n    return    .362*G( bislope( wave,442.0, .0624 , .0374 ) ) \n           + 1.056*G( bislope( wave,599.8, .0264 , .0323 ) )\n           -  .065*G( bislope( wave,501.1, .0490 , .0382 ) );\n}\nfloat yFit_1931( float wave )\n{\n    return    .821*G( bislope( wave,568.8, .0213 , .0247 ) ) \n            + .286*G( bislope( wave,530.9, .0613 , .0322 ) );\n}\nfloat zFit_1931( float wave )\n{\n    return   1.217*G( bislope( wave,437.,  .0845 , .0278 ) ) \n            + .681*G( bislope( wave,459.,  .0385 , .0725 ) );\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n    \nvec3 xyzToRgb(vec3 XYZ)\n{\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\n#define SPECTRUM_START 360\n#define SPECTRUM_BIN   43\n#define SPECTRUM_STEP  10\n\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \n\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \n// intersect the intersection point may be stored in the floats i_x and i_y.\n\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    vec2 s1 = p1-p0, s2 = p3-p2;\n\n    float d = cross2(s1,s2),\n          s = cross2(s1, p0-p2) / d,\n          t = cross2(s2, p0-p2) / d;\n\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\n         ? p0 + t*s1    // Collision detected\n         : p0;\n}\n\nvec3 constrainXYZToSRGBGamut(vec3 col)\n{\n    vec2 xy = col.xy / (col.x + col.y + col.z);\n    \n    vec2 red   = vec2(0.64,   0.33  ),\n         green = vec2(0.3,    0.6   ),\n         blue  = vec2(0.15,   0.06  ),\n         white = vec2(0.3127, 0.3290);\n    \n    const float desaturationAmount = 0.1;\n    xy = mix(xy, white, desaturationAmount);\n    \n    xy = intersectSegment(xy, white, red,   green);\n    xy = intersectSegment(xy, white, green, blue );\n    xy = intersectSegment(xy, white, blue,  red  );\n    \n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\n}\n\n#define spectral2rgb(l)  .35* xyzToRgb( constrainXYZToSRGBGamut( xyzFit_1931( l ) ) )\n\n\nvoid mainImage( out vec4 O,  vec2 u ) // =================================================\n{\n   vec2 R = iResolution.xy,\n        U = ( 2.*u - R ) / R.y;\n    O-=O;\n    float r = length(U), z;\n\n    if (false)                                             // test: perceived range of colors\n        O.rgb = spectral2rgb( 400. + 350.*u.x/R.x );       // wavelength in nm\n    else \n        if ( r < 1. )  {                                   // render transparent dichromatic sphere\n        z = 6.*sqrt(1.-r*r);\n        O.rgb =   4.* pow(.58,z) * spectral2rgb( 550. )    // wavelength in nm\n                + 1.* pow(1. ,z) * spectral2rgb( 650. );\n    }\n    \n    if (U.y < 0. ) {                                       // bottom: show chrominance\n        O -= min(O.r, min(O.g,O.b));\n        O.rgb /= length(O+1e-5);\n    }\n    \n    U=u/R; z = 6.*U.y;                                     // left: peaks intensity with depth\n#define S(v)  max(0., 1. - R.y* abs( v - U.x) )\n    O.g += S( 4.* pow(.58,z)*.05 );\n    O.r += S( 1.* pow(1. ,z)*.05 );\n\n    O = vec4( pow (O, vec4(1./2.2) ) );                    // gamma correction \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 386, 386, 573], [574, 574, 605, 605, 731], [732, 732, 763, 763, 889], [969, 969, 994, 994, 1154], [1236, 1236, 1266, 1266, 1294], [1452, 1452, 1511, 1511, 1764], [1766, 1766, 1806, 1806, 2331], [2421, 2421, 2513, 2513, 3537]]}
{"id": "ws3fRn", "name": "origami tuto (first steps)", "author": "FabriceNeyret2", "description": "mouse control 3D\n\n10 first steps of the crane origami ( indeed, common with many others).", "tags": ["raytracing", "folding", "paper", "short", "origami", "origami", "crane"], "likes": 7, "viewed": 410, "published": 3, "date": "1604222968", "time_retrieved": "2024-07-30T20:37:16.649867", "image_code": "vec3 point[9];                                                            // list of points\nvec2    uv[9];                                                            // list of uv attributes\nivec3  tri[8];                                                            // list of triangle\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                          // --- 2D rotation         \n\nmat3 rot3( vec3 v, float a )                                              // --- 3D rotation around axe\n{\n    v = normalize(v);\n    float s = sin(a), c = cos(a), ic = 1. - c;\n                                                 //    / cross( mat3(1) , v )\n    return mat3(c) + ic * outerProduct(v,v) - s * mat3(   0 ,  v.z, -v.y,\n                                                        -v.z,   0 ,  v.x,\n                                                         v.y, -v.x,   0    );\n//  return mat3( v.x*v.x*ic +   c  ,  v.y*v.x*ic - s*v.z,   v.z*v.x*ic + s*v.y,\n//               v.x*v.y*ic + s*v.z,  v.y*v.y*ic +   c  ,   v.z*v.y*ic - s*v.x,\n//               v.x*v.z*ic - s*v.y,  v.y*v.z*ic + s*v.x,   v.z*v.z*ic +   c    );\n}\n\n#define fan(p,n)  for( int k=0; k<n; k++ )       \\\n                      tri[k] = ivec3( p, L[k], L[(k+1)%8] );              // --- set triangles: fan around pivot p\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = mod(iTime, 17.) -2., \n          T = mod(t,2.)*1.4-.4; T = clamp( min(T,2.4-T), 0.,1.);  // ------ prepare geometry ------\n    int s; vec3 Z = vec3(0,0,1.4), P, m;\n    if (t<0.) T=0.;\n    if (t<7.) {                                                           // === phases 1.a-e ===\n        for( int k=0; k<9; k++ )                                          // --- set coordinates\n            s = sign(k-4), P = vec3( k%3-1, k/3-1, 0 ),\n            point[k] = t< 1. ? P * rot3( vec3(1, 1,0),-3.14*T*sign(P.y-P.x) ) // 1.ab: 2 diagonal pre-folds\n                     : t< 2. ? P * rot3( vec3(1,-1,0),-3.14*T*sign(P.y+P.x) )\n                     : t< 3. ? P * rot3( vec3(0,-1,0), 3.14*T* P.x )          // 1.cd: 2 median pre-folds\n                     : t< 4. ? P * rot3( vec3(1, 0,0), 3.14*T* P.y )          \n                     : mix( P,                                            // init pos\n                            k==4 ? vec3(0) : k%2<1 ? Z : .5*vec3(s,s,1.4),// folds-collapse pos\n                            T ),                                          // 1.e: morphing between those.\n            uv[k] = abs(P.xy);                                            // uv attribute\n        int L[8] = int[]( 0,1,2, 5, 8,7,6, 3 );                           // fan indices\n        fan(4,8);                                                         // --- set triangles\n    } \n      else {                                                              // === phase 2.ab ===\n        if (t>13.) T=1.;\n        for( int k=0; k<9; k++ )                                          // --- set coordinates\n            s = sign(k-4), P = .5*vec3(s,s,1.4), m = P*.59, // 2-sqrt2 \n            P = k==0||k==8 ? m : k==4 ? vec3(0) : k%2<1 ? Z : P,          // init pos\n            s = sign(abs(k-4)-2),\n            point[k] = t < 10. ? k%2 < 1 ? P\n                                 : Z + ( P - Z )  * rot3(  m - Z  , 3.14*(1.-T) * float(s) ) // 2.a: rotation around 4 side folds\n                               : k == 4  ? m  - m * rot3( vec3(1,1,0), -3.1*T ) // 2.b: rotation around top fold\n                                 : k%2 < 1 ? P : vec3( 0, .001*float(s), m.z ),\n            uv[k] = abs( vec2(-P.x,P.z*.7) * mat2(1,-1,1,1) );            // uv attribute\n        int L[7] = int []( 1, 3,0,4,8,7, 5 );                             // fan indices\n        fan(6,6);                                                         // --- set triangles\n        tri[0].z = 0; tri[5].y = 8;                                       // fix 2 rear wings\n        tri[2].z = 8; tri[3].x = 0;                                       // swap faces to allow 2.b rotation\n    }\n                                                                  // ------ ray-trace geometry ------\n    vec3  R = iResolution,\n          M = ( length(iMouse.xy) > 10. ? iMouse.xyz/R -.5\n                                        : vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0))-.3\n              ) * -6. ,\n          D = normalize(vec3( U+U, -5.*R.y ) - R ),                       // ray direction\n          p = vec3(0,-.5,5), F,r, A,B,C;   \n    D.yz *= rot(M.y),   p.yz *= rot(M.y),                                 // camera rotations\n    D.xy *= rot(M.x),   p.xy *= rot(M.x);\n\n    int f=-1; float z=99.; // ,S, s=1.;\n // for( ; s > -2.; s-=2., D.xy*=s, p.xy*=s ) {                           // add symmetric shape\n    for ( int k=0; k<8; k++ ) {                                           // --- test all triangles for intersection\n        ivec3 T = tri[k];\n        A = point[T.x], B = point[T.y], C = point[T.z];\n        r = inverse(mat3(B-A,C-A,-D)) * ( p-A );                          // intersection r = (u,v,z)\n        if ( r.z>0. && r.x>0. && r.x <1. && r.y>0. && r.y <1. && r.x+r.y < 1. ) // hit \n            if (r.z < z ) z = r.z, F=r, f=k; //, S=s;                           // get closest\n    } //}\n\n    O -= O;\n    if (z < 99.) {                                                        // --- hit: compute pixel color\n        ivec3 T = tri[f];\n        A = point[T.x], B = point[T.y], C = point[T.z];\n        U = uv[T.x]*(1.-F.x-F.y) + F.x * uv[T.y] + F.y * uv[T.z];         // reconstruct uv attribute\n        O = texture(iChannel0, U )                                        // texturing\n           * ( .5 + abs( dot( normalize(cross(B-A,C-A)), vec3(0,1,2))) ); // Lambert shading\n    }                                                   //      S\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3fRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 389, 494, 494, 1112]]}
{"id": "wdcfzr", "name": "Flowing metal", "author": "jarble", "description": "These jets of molten metal are flying everywhere!\nThis is based on my [url=https://www.shadertoy.com/view/WdGyDc]\"Rainbow shards\"[/url] fractal.", "tags": ["fractal", "fluid", "metal"], "likes": 4, "viewed": 414, "published": 3, "date": "1604196716", "time_retrieved": "2024-07-30T20:37:17.515552", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(abs(sin(p.yzx))-abs(cos(p))))-1.0;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 40.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 8.0; i*= -2.0){\n        float i1 = i*i;\n        float i2 = i1*5.0;\n        p += (sin((p.yzx+iTime/i2)/i1)+cos((p.yzx+iTime/i2)/i1))*i1;\n    \tresult += sceneSDF1(p*i1)/i1;\n    }\n    return -(result-.1)*2.0;\n}\n\nvec3 surface_color(vec3 p3)\n{\n    //p3 *= 10.0;\n    p3 = vec3(sceneSDF(p3/7.0),sceneSDF(p3/11.0),sceneSDF(p3/13.0));\n    //surface color\n    return sin((p3+.2)/p3.zyx)/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    \n    float c1 = 3.0;\n    float t1 = 0.0;\n    vec3 eye = vec3(sin(t1/c1),sin(t1/c1)*c1,cos(t1/c1)*c1);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 491, 516, 516, 572], [574, 574, 597, 597, 878], [880, 880, 909, 927, 1054], [1056, 1477, 1568, 1568, 1874], [1889, 2143, 2208, 2208, 2340], [2342, 2431, 2460, 2460, 2770], [2772, 3264, 3404, 3404, 3994], [3996, 4366, 4451, 4451, 5209], [5211, 5538, 5587, 5622, 5753], [5755, 5755, 5812, 5812, 6873]]}
