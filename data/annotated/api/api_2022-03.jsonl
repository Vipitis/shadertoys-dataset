{"id": "sllcD2", "name": "06 The simplest 3D ", "author": "ccc9527", "description": "3D Circle", "tags": ["3d"], "likes": 0, "viewed": 206, "published": 3, "date": "1648756568", "time_retrieved": "2024-07-30T16:55:58.383915", "image_code": "//I learn from The Art of Code's videos\n//https://www.youtube.com/watch?v=PBxuVlp7nuM\n//计算观察点p到射线的距离，射线原点ro，射线方向rd。\n//两个向量叉乘得到的向量长度是这两个向量组成平行四边形的面积，面积又等于底乘高\nfloat DistLine(vec3 ro,vec3 rd,vec3 p)//Distance To Line\n{\n    return length(cross(p-ro,rd))/length(rd);\n}\n//绘制点函数,射线原点ro，射线方向rd,点p为点位置\nfloat DrawPoint(vec3 ro,vec3 rd,vec3 p)\n{\n    float d = DistLine(ro,rd,p);\n    d = smoothstep(0.06,0.04,d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //将uv移动屏幕中心并且xy都除以屏幕高\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //射线原点,初始为(0.0,0.0,-3.0),绕y轴逆时针旋转\n    vec3 ro = vec3(3.0*sin(iTime),0.0,-3.0*cos(iTime));\n    \n    //求摄像机的三个基向量\n    vec3 lookat = vec3(0.0);//看向的点,屏幕中心点\n    vec3 forward = normalize(lookat-ro);//归一化向前向量\n    vec3 right = cross(vec3(0.0,1.0,0.0),forward);//根据向前向量和(0,1,0)叉乘求向右向量\n    vec3 up = cross(forward,right);//根据向右向量和forward求向上向量\n    \n    //射线原点不变,增大zoom,屏幕中心点后移,视野变小,物体变大\n    float zoom = 1.0;\n    vec3 center = ro+forward*zoom;//屏幕中心点\n    vec3 i = center+right*uv.x+up*uv.y;//屏幕上的每个点i\n    \n    vec3 rd = i-ro;//射线方向\n    \n    float t = iTime;\n    float d = 0.0;\n    \n    d += DrawPoint(ro,rd,vec3(-1.0, -1.0, -1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3( 1.0, -1.0, -1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3( 1.0,  1.0, -1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3(-1.0,  1.0, -1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3(-1.0, -1.0,  1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3( 1.0, -1.0,  1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3( 1.0,  1.0,  1.0)/2.0);\n    d += DrawPoint(ro,rd,vec3(-1.0,  1.0,  1.0)/2.0);\n    \n    fragColor = vec4(vec3(d),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 277, 335, 335, 383], [384, 451, 492, 492, 574], [576, 576, 633, 689, 2009]]}
{"id": "7tlcDj", "name": "Fractal knots 16", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 2, "viewed": 287, "published": 3, "date": "1648748241", "time_retrieved": "2024-07-30T16:55:59.124934", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale)-.5)-ceil(a.y/2.)/4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*4.*4.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float p1 = 1.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            uv /= scale;\n            //uv += ceil(t2*2.)/2.; //lace pattern\n\n            uv += vec2(1.);\n            //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n            t2 = p1*triangle_wave(uv.yx-.5,1.5);\n            t3 = -p1*triangle_wave(uv,1.5);\n            uv.yx = (t2+t3);\n            p1 *= -1.;\n        }\n        \n        //col.x = abs(col.x-.5);\n        col.x = 1.-min(uv.y+uv.x+col.x,col.x)*2.;\n        //col.x = min(uv.y-uv.x+col.x,col.x*2.);\n        \n        //uv.x *= -1.;\n        col = abs(col.yzx-vec3(1.5-col.x))/2.;\n        //col = abs(col.yzx+vec3(col.x)*2.)/3.;\n\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 174], [176, 176, 233, 233, 1361]]}
{"id": "stscWj", "name": "Noise Levels", "author": "byt3_m3chanic", "description": "Noise Levels / Stepped noise with some fancy scrollers - totally Cheating by just using color / distance gets crunchy.. ", "tags": ["raymarching", "noise"], "likes": 14, "viewed": 319, "published": 3, "date": "1648745723", "time_retrieved": "2024-07-30T16:55:59.865952", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Noise Levels / Stepped noise with some fancy scrollers\n    3/31/22 | @byt3_m3chanic\n    \n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\n#define SCALE       .5\n#define MHEIGHT     4.0\n#define SHEIGHT     .25\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( hash21( i + vec2(0,0) ), \n                     hash21( i + vec2(1,0) ), u.x),\n                mix( hash21( i + vec2(0,1) ), \n                     hash21( i + vec2(1,1) ), u.x), u.y);\n}\n\n//@iq smooth union\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// cheap hight map\nfloat height_map(vec2 p) {\n    float height = noise(p * SCALE) * MHEIGHT;\n    height = floor(height / SHEIGHT) * SHEIGHT;\n    return height;\n}\n\nfloat time,clr;\nmat2 rx,ry;\n\nvec2 map (in vec3 p) {\n\n    p.xz+=T*.5;\n    vec2 res = vec2(100.,-1.);\n\tfloat height = height_map(p.xz);\n    clr=height;\n    float d = (p.y+3.)-height;\n    if(d<res.x) res = vec2(d*.5,2.);\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t, float md){\n    t*=md;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m) {\n    vec3 n = normal(p,d,1.);\n    vec3 lpos = vec3(-6,10,6);\n    clr-=.5;\n    vec3 c = vec3(1.-(clr*.5),0,(clr*.6));\n    vec3 l = normalize(lpos-p);\n\n    //@Shane\n    float shdw = 1.0;\n    for( float t=.01;t<14.; ) {\n        float h = map(p + l*t).x;\n        if( h<.0001 ) { shdw = 0.; break; }\n        shdw = min(shdw, 24.*h/t);\n        t += h * .95;\n        if( shdw<.0001 || t>42. ) break;\n    }\n    \n    return mix(c,c*shdw,.75);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n    vec3 C=vec3(.0);\n\n    float z = M.xy == vec2(0) ? 0. : -(M.y/R.y * 6. - 3.) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    \n    float zoom = 10.+z;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    if(uv.y<.4&&uv.y>-.4){\n\n        rx = rot(-.785);\n        ry = rot(-.785+y);\n        ro.yz*=rx;ro.xz*=ry;\n        rd.yz*=rx;rd.xz*=ry;\n\n        vec3 p = ro;\n        for(int i=0;i<125;i++) {\n            vec2 ray = map(p);\n\n            float d = i<32?ray.x*.5:ray.x;\n            float m = ray.y;\n\n            p += rd * d;\n            if (d*d < 1e-8) {\n                C=shade(p,rd,d,ray.y);\n                break;\n            }\n            if(distance(p,rd)>75.) { break; }\n        }\n\n    }else{ \n\n        uv.x+=uv.y>.0?T*.5:-T*.5;\n        float px = fwidth(uv.x);\n        \n        vec2 f = fract(uv*55.)-.5;\n        vec2 fid = floor(uv*55.)+.5;\n\n        float ht = noise(fid+T*.25);\n\n        vec3 ledh=vec3(1,0,0);\n        vec3 ledc=vec3(0,0,1);\n        ht*=.85;\n\n        float ff = box(f,vec2(.3,.3))-.075;\n        ff=smoothstep(.075+px,-px,ff);\n\n        float avg = (fid.y*.1)+3.;\n        float avx = (fid.y*.1)-2.3; \n\n        if(ht>avg&&ht<avg+.1) C=mix(C,ledh,ff);\n        if(ht>avx&&ht<avx+.1) C=mix(C,ledh,ff);\n\n        if(ht>avg+.25&&ht<avg+1.1) C=mix(C,ledc,ff);\n        if(ht>avx+.25&&ht<avx+1.1) C=mix(C,ledc,ff);\n\n    } \n    \n    C = pow(C,vec3(0.4545) );\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stscWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[462, 462, 481, 481, 526], [527, 527, 549, 549, 607], [609, 609, 635, 635, 916], [918, 937, 964, 964, 1050], [1051, 1051, 1086, 1086, 1166], [1167, 1186, 1212, 1212, 1328], [1359, 1359, 1381, 1381, 1570], [1572, 1572, 1611, 1611, 1798], [1800, 1800, 1847, 1847, 2282], [2284, 2284, 2325, 2325, 3807]]}
{"id": "slscWj", "name": "Nautilus at Sunset", "author": "dr2", "description": "Our favorite submarine", "tags": ["sunset", "refraction", "water", "ocean", "submarine", "nautilus"], "likes": 18, "viewed": 358, "published": 3, "date": "1648745561", "time_retrieved": "2024-07-30T16:56:00.791478", "image_code": "// \"Nautilus at Sunset\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Based on \"Nautilus Submerging\"; others in series listed in \"Nautilus Egg\" (7dj3Wz).)\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir;\nfloat dstFar, tCur, sbLen, sbDepth, prpRot;\nint idObj;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = 2. * mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.025 * tCur);\n  wAmp = 1.;\n  h = 0.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = Noisev2v4 (t4);\n    t4 = abs (sin (t4 + 2. * t.xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz) / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  p.y -= sbDepth;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p, vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p.y -= sbDepth;\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.4, 0.4, 0.5, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.5, 0.5, 0.7, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.7, 0.5, 0.2, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.7, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.2, -1.);\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjP;\n  idObjP = idObj;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjP;\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p.y -= sbDepth;\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col, p;\n  float ds, fd, att, attSum, sd, a;\n  a = atan (rd.z, rd.x) + 0.005 * tCur;\n  if (rd.y < 0.015 * Fbm1 (32. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.3, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.4 * Fbm2 (64. * vec2 (a, rd.y)));\n  } else {\n    p = ((200. - ro.y) / rd.y) * rd;\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz = p.xz * fd + 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    for (float j = 0.; j < 4.; j ++) {\n      attSum += Fbm2 (p.xz + (1. + j * ds) * fd * sunDir.xz);\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    col = mix (vec3 (0.5, 0.75, 1.), mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1),\n       0.25 + 0.75 * sd), exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = VAR_ZERO + 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.1 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roc, row, vnw, rdo, rdd, colUw, vnb;\n  vec2 lbDist;\n  float dstObj, dstWat, dstDom, sh, foamFac, eta, atFac, s, h;\n  bool hitWat, unWat;\n  eta = 1.33;\n  atFac = 5.;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  dstDom = 5.;\n  roc = ro + dstDom * rd;\n  rdo = rd;\n  dstObj = ObjRay (ro, rd);\n  unWat = (roc.y < WaveHt (roc.xz));\n  dstWat = dstDom + WaveRay (roc, rd, (! unWat ? 1. : -1.));\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, vn);\n    sh = unWat ? 1. : ObjSShadow (ro, sunDir);\n    h = WaveHt (ro.xz) - ro.y;\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.3 + 0.1 * max (vn.y, 0.) +\n         0.2 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n         0.7 * sh * max (0., max (dot (vn, sunDir), 0.))) + \n         col4.a * step (0.95, sh) * vec3 (1., 0.9, 0.5) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n      if (unWat) col += 0.2 * TurbLt (0.1 * ro, abs (vn), 0.3 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (0., 0.1, vn.y);\n      else col *= 0.6 + 0.4 * (1. - smoothstep (1., 4., h));\n    } else col = col4.rgb;\n    col *= mix (vec3 (1.), vec3 (0.7, 0.9, 1.), (unWat ? 1. : smoothstep (0., 0.1, h)));\n  } else {\n    col = (hitWat == unWat) ? SkyHrzCol (ro, rd) : SeaFloorCol (rd);\n  }\n  if (! unWat) {\n    if (hitWat) {\n      col = mix (col, 0.8 * SkyHrzCol (row, reflect (rdo, vnw)), pow (1. - abs (dot (rdo, vnw)), 5.));\n      s = Fbm3 (128. * row);\n      foamFac = pow (smoothstep (0., 1., WaveHt (row.xz) - 0.6) + 0.008 * s, 8.);\n      col = mix (col, vec3 (1.), foamFac);\n      col = mix (col, 0.9 * SkyHrzCol (ro, rdo), smoothstep (0.2, 0.5, dstWat / dstFar));\n    }\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) {\n      col = mix (colUw, col, min (1., exp (1. - atFac * dstObj / dstFar)));\n    } else if (dstWat < dstFar) {\n      col = (rd.y > 0.) ? mix (colUw, col, exp (- atFac * dstWat / dstFar)) : colUw;\n    } else col = colUw;\n  }\n  if (sbDepth < -2. && unWat) {\n    lbDist = LBeamRay (roc, rdo);\n    vnb = LBeamNf (roc + lbDist.x * rdo);\n    if (lbDist.x < min (dstObj, dstFar))\n       col = mix (col, vec3 (0.6, 0.6, 0.7), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowExScene (vec2 uv, float pRad)\n{\n  vec3 col, svn;\n  vec2 uvr;\n  float cRad, r, a;\n  cRad = length (uv) - pRad - 0.1;\n  svn = normalize (vec3 (normalize (uv) * SmoothBump (0., 0.03, 0.005,\n     abs (abs (cRad) - 0.1)) * sign (cRad), -1.));\n  a = 2. * pi * floor (12. * atan (uv.y, - uv.x) / (2. * pi) + 0.5) / 12.;\n  uvr = Rot2D (uv, a) + vec2 (pRad + 0.1, 0.);\n  r = length (uvr);\n  if (r < 0.06) {\n    col = vec3 (0.6, 0.5, 0.1);\n    svn = normalize (vec3 (Rot2D (uvr, - a) * smoothstep (0., 0.06, r) / r, -1.));\n  } else {\n    col = vec3 (0.5, 0.5, 0.2);\n    svn = VaryNf (64. * vec3 (uv, 1.), svn, 0.5);\n  }\n  col *= 0.2 + 0.8 * max (dot (svn, normalize (vec3 (1., 1., -1.))), 0.);\n  r = min (abs (max (PrBox2Df (uvr, vec2 (0.035)), PrBox2Df (Rot2D (uvr, pi / 4.), vec2 (0.035))) -\n     0.005), min (PrBox2Df (uvr, vec2 (0.02, 0.)), PrBox2Df(uvr, vec2 (0., 0.02))));\n  r = min (r, abs (length (uvr) - 0.06));\n  col = mix (col * (0.1 + 0.9 * smoothstep (0., 0.004, r)),\n     vec3 (0.15, 0.2, 0.15) * (0.8 + 0.2 * Fbm2 (128. * uv)), step (0.1, cRad));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, pRad;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pRad = 0.85;\n  if (length (uv) < pRad) {\n    az = 0.7 * pi;\n    el = 0.05 * pi;\n    if (mPtr.z > 0.) {\n      az += 0.5 * pi * mPtr.x;\n      el += 0.4 * pi * mPtr.y;\n    }\n    az += 0.05 * pi * (SmoothBump (0.25, 0.75, 0.2, mod (0.005 * tCur, 1.)) - 0.5);\n    el += 0.2 * pi * (SmoothBump (0.25, 0.75, 0.2, mod (0.012 * tCur, 1.)) - 0.5);\n    az = clamp (az, 0.55 * pi, 0.9 * pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 3.2;\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -40.);\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n    sbDepth = -4. + 4. * sin (0.05 * pi * tCur);\n    ro.y += sbDepth;\n    vuPos = ro;\n    sunDir = normalize (vec3 (0., 0.1, -1.));\n    sunDir.xz = Rot2D (sunDir.xz, az - 0.4 * pi);\n    dstFar = 300.;\n    col = ShowScene (ro, rd);\n  } else {\n    col = ShowExScene (uv, pRad);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slscWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1134, 1134, 1157, 1157, 1729], [1731, 1731, 1774, 1774, 2311], [2313, 2313, 2344, 2344, 2507], [2509, 2509, 2531, 2531, 5430], [5432, 5432, 5465, 5465, 5648], [5650, 5650, 5671, 5671, 5926], [5928, 5928, 5959, 5959, 8443], [8445, 8445, 8482, 8482, 8760], [8762, 8762, 8785, 8785, 9095], [9097, 9097, 9131, 9131, 9353], [9355, 9355, 9378, 9378, 9637], [9639, 9639, 9674, 9674, 10877], [10879, 10879, 10907, 10907, 11026], [11028, 11028, 11068, 11068, 11539], [11541, 11541, 11564, 11564, 11917], [11919, 11919, 11954, 11954, 14632], [14634, 14634, 14674, 14674, 15710], [15712, 15712, 15765, 15765, 16896], [16898, 16898, 16931, 16931, 17020], [17022, 17022, 17068, 17068, 17115], [17117, 17117, 17150, 17150, 17177], [17179, 17179, 17221, 17221, 17272], [17274, 17274, 17333, 17333, 17423], [17425, 17425, 17478, 17478, 17539], [17541, 17541, 17571, 17571, 17684], [17686, 17686, 17722, 17722, 17928], [17930, 17930, 17987, 17987, 18070], [18104, 18104, 18128, 18128, 18181], [18183, 18183, 18207, 18207, 18319], [18321, 18321, 18345, 18345, 18408], [18410, 18410, 18434, 18434, 18577], [18579, 18579, 18604, 18604, 18750], [18752, 18752, 18777, 18777, 18963], [18965, 18965, 18990, 18990, 19215], [19217, 19217, 19242, 19242, 19579], [19581, 19581, 19603, 19603, 19758], [19760, 19760, 19781, 19781, 19936], [19938, 19938, 19959, 19959, 20114], [20116, 20116, 20145, 20145, 20357], [20359, 20359, 20398, 20398, 20655]]}
{"id": "NlXcD2", "name": "Simple Clover Path", "author": "SnoopethDuckDuck", "description": "Example using this function (sort of):\nhttps://www.desmos.com/calculator/vvlvvxr7yi\n\nI'm sure it could be condensed a bit", "tags": ["cellularautomata"], "likes": 4, "viewed": 242, "published": 3, "date": "1648734792", "time_retrieved": "2024-07-30T16:56:01.534491", "image_code": "vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = texelFetch( iChannel0, ivec2(fragCoord), 0 ).x;\n    vec3 e = vec3(0.5);\n    vec3 col = x * pal(0.15 + x, e, e, e, 0.2 * vec3(0,1,2)/3.);\n    col = sqrt(col);\n    col = vec3(1,0.8,0.8) - col;\n\n    // Visual of function on graph\n    // (if I wasn't lazy I'd do a y axis too + track particles motion with both axes)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.;\n    float s = step(uv.y + 1., 0.5 * fn(uv.x + 0.1 * iTime));\n    col += 0.08 * s;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).rgb;\n\n    float t = 0.1 * iTime;\n    \n    // Is more correct without smoothstep\n    // (smoothstep doesnt smooth [0,0.5] lines or [0.5,1] lines properly)\n    vec2 p = 0.6 * vec2(smoothstep(0., 1., fn(t)), \n                        smoothstep(0., 1., fn(t + 0.25)));\n    //p = 0.6 * vec2(fn(t), fn(t+0.25));\n    p -= 0.3;\n\n    float d = length(uv - p);\n    float s = 0.1 * exp(2.5 - 50. * d);\n    \n    col *= 0.99;\n    col += s;\n    col = clamp(col, 0., 1.);\n\n    fragColor = vec4( col, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Click through each value here:\n// https://www.desmos.com/calculator/vvlvvxr7yi\nfloat fn(float x) {\n    // Restrict to [0,1] interval\n    float f = fract(x);\n    \n    // Triangle wave\n    float g = 2. * abs(f - 0.5);\n    \n    // Path of a square equation\n    float h = 2. * clamp(g, 0.25 ,0.75) - 0.5;\n    \n    // Use k for reflecting parts in y = 0.5\n    float k = step(0.5, f); //f for clover, h for in-out\n    \n    // Little square path equation\n    float l = min(0.5, 1. - 2. * abs(h - 0.5));\n    \n    // Triangles\n    float s = max(0., 0.5 - 4. * abs(fract(2. * x - 0.5) -0.5));\n    \n    // Flip half of little square equation, looks like a jagged h\n    float j = mix(l, 1. - l, k);\n    \n    // Remove triangles from j where j=1, add triangles where j=0\n    return abs(j - s);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 109], [111, 111, 168, 168, 691]]}
{"id": "7lXcW2", "name": "TP-3", "author": "valentinCuzin", "description": "my second project", "tags": ["texture", "shader", "marble", "woods"], "likes": 2, "viewed": 248, "published": 3, "date": "1648714196", "time_retrieved": "2024-07-30T16:56:02.459019", "image_code": "// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\n    vec3 c;\n    float s;\n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n\nfloat Turbulence(vec3 p,float coef, int detail,float longueurOnde){// somme de bruits \n    float somme;\n    for(int i = 0; i<detail; i++){//boucle pour calculer la somme de bruit\n        somme = somme + coef*Noise(p/longueurOnde);\n        coef = coef / 2.0;\n        longueurOnde = longueurOnde / 2.0;\n    }\n    return somme;\n}\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nV Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return V(dot((p-o),n),index);\n}\n\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n// Différence\n// a,b : les deux distance de la fonction SDF des deux object\nfloat Differance(float a, float b){\n    return max(a, -b);\n}\n\nmat2 Rotation(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersection(Cube(p,c,r*0.75,index),Sphere(p,c,r,index));\n}\n\nfloat cylinder (vec3 a, vec3 b, float r, vec3 p)\n{\n    float aq = dot((p-a),(b-a)/length(b-a));\n    float l = sqrt(dot(p-a,p-a)- aq*aq);\n    return l-r;\n}\n\n//cylindrefini\n// p : point\n// r : rayon\n// t : taille du cylindre\nfloat CylindreFini(vec3 p, float r, float t)\n{\n    float cylindreInf = cylinder(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, t), r, p);\n    float demiCylindreInf1 = Differance(cylindreInf, Plane( p, vec3(0.0, 0.0, -1.0) , vec3(0.0, 0.0, t+1.0))); \n    float demiCylindreInf2 = Differance(cylindreInf, Plane( p, vec3(0.0 ,0.0 ,1.0) , vec3(0.0,0.0,1.0) ));\n    return Intersection(demiCylindreInf1, demiCylindreInf2);\n    \n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),1);\n  vec3 pTurbul=p; \n  u=Union(u,Dice(p,vec3( 0.0, 10.0, 2.0),4.0,4));\n  pTurbul.x = p.x + Turbulence(p, 0.4, 3, 1.0);\n  pTurbul.y = p.y + Turbulence(p, 0.4,3,1.0);\n  V tronc= V(CylindreFini(pTurbul, 4.0, 5.0),0);\n  u=Union(u,tronc);\n  pTurbul = p + Turbulence(p, 0.5, 3, 1.0); \n  u=Union(u,Dice(pTurbul,vec3( -10.0, 0.0, 2.0),4.0,2));\n  u=Union(u,Dice(p,vec3( 10.0, 0.0, 2.0),4.0,3));\n \n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps*2; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v)/2.0;//complexité augmenter par la précission\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.35,0.45,0.695),vec3(0.352,0.397,0.695), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n\n\nint convert(float a){\n    if(a<0.0){\n        a= a-1.0;\n    }\n    return int(a);\n}\n\nT uniforme(vec3 c, float s){\n    return T(c,s); //retourne une texture uniforme en fonction d'une couleur et d'une reflexion spéculaire\n}\n\nT Damier(in vec3 p, T a, T b){\n    int x = convert(p.x);//convertion en entier\n    int y = convert(p.y);//correction partie entière des valeurs négatifs pour evité le cas de int(0.4)=int(-0.4)\n    int z = convert(p.z);\n        if( (x+y+z)%2 == 0 ){//modulo 2 pour faire 2 cas: coordonées paire, coordonées impaire\n        return a;//couleur 1\n    }else{\n        return b;//couleur 2\n    }   \n}\n\nT bois(in vec3 p, T a, T b, float E, float bruit){\n    p = p + bruit*Noise(p)*(p/E);//perturbation de p en fonction de l'indice bruit et de la longeur d'onde E\n    float d = length(p.xy);//calcul de la distance pour créer les cercles\n    float v = 0.5*cos(d*E) + 1.0;//utilisation de cos pour interpoler les deux couleurs quand v=1 couleur a quand v= 0 couleur b\n    return T( (a.c*v + b.c*(1.0-v)), (a.s*v + b.s*(1.0-v)) );//vrai interpolation de la couleur mais aussi de l'indice spéculaire\n}\n\nT marbre_veineux(in vec3 p, T a, T b){\n    p = p + Turbulence(p,3.0,10,3.0);//perturbation grande de p avec valeur imposer \n    /* utilisation de tangente: fonction qui à pour valeurs interdites pi/2 \n    et qui varie entre -infini et +infini décrit des droites vertical donc parfait pour faire des veines\n    apliquer à x mais peut aussi s'appliquer à y et z\n    \n    p.x multiplier par 2 car ogmentation du nombre de ligne\n    tangente multiplier par 5 pour grossir les veines\n    \n    l'utilisation de tangente est très performante car de complexiter 10 appliquer qu'une fois \n    en comparaison de de ((1.0+cos(x))/2)⁴ ou de l'utilisation d'un plan\n    \n    critiquable car si l'objet est en coordonnée x<0 les couleurs s'inverse entre la veine et le fond\n\n    */\n    float t = tan(p.x*2.)*5.;\n    vec3 veine = vec3(p.x+t,p.yz);\n    if(veine.x<0.) return a;//couleur veine\n    else return b;//couleur fond\n    /*autre possibilité explorer\n    t = ((1.0+cos(t))/2.0)*((1.0+cos(t))/2.0)*((1.0+cos(t))/2.0)*((1.0+cos(t))/2.0);\n    T couleurFinal = T( (a.c*t + b.c*(0.6-t)), (a.s*t + b.s*(1.0-t)));\n    return couleurFinal;\n    */\n}\n\nT marbre(in vec3 p, T a, T b){\n    p = p + Turbulence(p,9.0,10,2.0);//perturbation grande de p avec valeur imposer pour que ça ressemble à du marbre\n    float t = cos(p.x);//utile pour l'interpolation des deux couleur entre 1 et moins 1\n    return T( (a.c*t + b.c*(0.6-t)), (a.s*t + b.s*(1.0-t)));//interpolation des deux couleurs\n}\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0){\n        return bois(p, T(vec3(0.87, 0.72, 0.53),0.0), T(vec3(0.54, 0.27, 0.07),0.0), 6.0, 0.1);\n    }\n    else if (vp.i==1)\n    {\n        return marbre(p, T(vec3(0.6,0.7,0.65), 0.1), T(vec3(0.8,0.9,0.85), 0.4));\n    }\n    else if (vp.i==2)\n    {\n        vec3 pT = p + Turbulence(p, 0.6, 3, 1.0);\n        return Damier(pT, T(vec3(0.0,0.0,0.0),1.0), T(vec3(1.0,1.0,1.0),0.0));\n    }\n    else if (vp.i==3)\n    {\n        return marbre_veineux(p, T(vec3(1,0.9,0.), 0.9), T(vec3(0.2,0.2,0.2), 0.1));\n    }\n    else if (vp.i==4)\n    {\n        return uniforme(vec3(0.6,0.6,1.),14.0);\n        \n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 20.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n    l.xy=l.xy*Rotation(0.3*iTime);//la lune tourne\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.1*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.2  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),8.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 499, 518, 758], [760, 813, 857, 857, 892], [894, 945, 986, 986, 1091], [1093, 1161, 1204, 1204, 1240], [1242, 1242, 1279, 1279, 1306], [1308, 1396, 1414, 1414, 1509], [1510, 1510, 1540, 1540, 1563], [1565, 1670, 1695, 1695, 1802], [1803, 1803, 1840, 1840, 1863], [1865, 1942, 1977, 1977, 2002], [2004, 2004, 2028, 2028, 2104], [2106, 2157, 2198, 2198, 2267], [2269, 2269, 2319, 2319, 2423], [2425, 2492, 2538, 2538, 2905], [2907, 2953, 2971, 2971, 3439], [3549, 3589, 3620, 3620, 3863], [3865, 3995, 4060, 4060, 4515], [4517, 4558, 4583, 4583, 4659], [4662, 4681, 4709, 4727, 4987], [5093, 5093, 5114, 5114, 5174], [5176, 5176, 5204, 5204, 5314], [5316, 5316, 5346, 5346, 5714], [5716, 5716, 5766, 5766, 6212], [6214, 6214, 6252, 6252, 7355], [7357, 7357, 7387, 7387, 7691], [7693, 7740, 7770, 7770, 8402], [8404, 8467, 8503, 8503, 8628], [8630, 8711, 8747, 8767, 9345], [9663, 9758, 9797, 9822, 10246], [10249, 10258, 10305, 10334, 11035]]}
{"id": "7tXyW2", "name": "test348295764839275432", "author": "neotenomie", "description": "test", "tags": ["3d", "particles", "musicvisualizer", "trails", "multipass"], "likes": 3, "viewed": 501, "published": 3, "date": "1648711267", "time_retrieved": "2024-07-30T16:56:03.325702", "image_code": "// Homecomputer by nimitz 2016 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Code is in the other tabs:\n//Buf A = Velocity and position handling\n//Buf B = Rendering\n//Buf C = Soundcloud filtering and propagation\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec3 col = texture(iChannel0, q).rgb;\n    col *= sin(gl_FragCoord.y*350.+time)*0.04+1.;//Scanlines\n    col *= sin(gl_FragCoord.x*350.+time)*0.04+1.;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.35+0.65; //Vign\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Homecomputer by nimitz 2016 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Velocity handling\n\n#define time iTime\n\nvec3 hash3(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.1);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z))-0.5;\n}\n\nvec3 update(in vec3 vel, vec3 pos, in float id)\n{\n    vec4 sndNFO = texture(iChannel2, vec2(0.75, 0.25));\n    float R = 1.5;\n    const float r = .5;\n    float t= time*2.+id*8.;\n    float d= 5.;\n    \n    float x = ((R-r)*cos(t-time*0.1) + d*cos((R-r)/r*t));\n    float y = ((R-r)*sin(t) - d*sin((R-r)/r*t));\n    \n    vel = mix(vel, vec3(x*1.2,y,sin(time*12.6+id*50. + sndNFO.z*10.)*7.)*5. +hash3(vel*10.+time*0.2)*7., 1.);\n    \n    //vel.z += sin(time*sndNFO.z)*50.;\n    //vel.z += sin(time + sndNFO.z*70.)*10.;\n    //vel.z += sin(time)*30.*sndNFO.x;\n    \n    return vel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q-0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy-0.5;\n    \n    float dt = iTimeDelta;\n    \n    vec4 col= vec4(0);\n    \n    vec2 w = 1./iResolution.xy;\n    \n    vec3 pos = texture(iChannel0, vec2(q.x,100.*w)).xyz;\n    vec3 velo = texture(iChannel0, vec2(q.x,0.0)).xyz;\n    velo = update(velo, pos, q.x);\n    \n    if (fragCoord.y < 30.)\n    {\n    \tcol.rgb = velo;\n    }\n    else\n    {\n        pos += velo*0.002;\n        col.rgb = pos;\n    }\n\t\n    if (iFrame < 5) \n    {\n        if (fragCoord.y < 30.)\n        \tcol = ((texture(iChannel1, q*1.9))-.5)*vec4(0.,0.,0.,0.);\n        else\n        {\n            col = vec4(.0,-.7,0,0);\n        }\n    }\n    \n    \n    if (mod(float(iFrame), 300.) == 0. && fragCoord.y > 30.)\n    {\n        col = vec4(.0,-.2, -0.,0);\n    }\n    \n    col.a = q.x;\n    \n\tfragColor = col;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Homecomputer by nimitz 2016 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Rendering\n\n/*\n\tThis buffer renders each particles\n\tmultiple times per frame to allow particles\n\tto move more than one pixel per frame while still\n\tleaving a solid trail.\n*/\n\n#define time iTime\nconst int numParticles = 100;\nconst int stepsPerFrame = 9;\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat mag(vec3 p){return dot(p,p);}\n\nvec4 drawParticles(in vec3 ro, in vec3 rd, in float ints)\n{\n    vec4 rez = vec4(0);\n    vec2 w = 1./iResolution.xy;\n    \n    for (int i = 0; i < numParticles; i++)\n    {\n        vec3 pos = texture(iChannel0, vec2(i,100.0)*w).rgb;\n        vec3 vel = texture(iChannel0, vec2(i,0.0)*w).rgb;\n        \n        float st = sin(time*0.6);\n        \n        for(int j = 0; j < stepsPerFrame; j++)\n        {\n            float d = mag((ro + rd*dot(pos.xyz - ro, rd)) - pos.xyz);\n            d *= 1000.;\n            d = 2./(pow(d,1.+ sin(time*0.6)*0.15)+1.5);\n            d *= (st+4.)*.8;\n\n            rez.rgb += d*(sin(vec3(.7,2.0,2.5)+float(i)*.015 + time*0.3 + vec3(5,1,6))*0.45+0.55)*0.005;\n            \n            pos.xyz += vel*0.002*1.5;\n        }\n    }\n    \n    return rez;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(0.,0.,2.7);\n    vec3 rd = normalize(vec3(p,-.5));\n    \n    vec3 sndNFO = texture(iChannel2, vec2(0.65, 0.1)).zwx + vec3(-.5, -0.1, -0.0);\n    \n    vec4 cola = drawParticles(ro, rd, sndNFO.y)*10.;\n    if (mod(time+q.x*.15+q.y*0.15,28.) < 14.)cola = vec4(.9,.95,1.,1.)-cola*.9; //Invert colors\n    \n    vec2 mv = vec2(pow(sndNFO.z,2.)*0.05,sndNFO.x*.95);\n    mv *= mm2(time*1.);\n    \n    vec4 colb = texture(iChannel1, q+mv);\n    //vec4 colb = texture(iChannel1, q);\n    \n    vec4 col = mix(cola, colb, 0.91);\n    if (iFrame < 5) col = vec4(0);\n    \n\tfragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Homecomputer by nimitz 2016 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n \tThe goal of this Buffer is to prepare\n\tthe sound data so that it can be used \n\tby the other buffers\n\n\tData output:\n\tx = fft\n\ty = waveform\n\tz = filtered waveform\n\tw = filtered fft summed over many bands\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    float fft  = texture( iChannel1, vec2(q.x,0.25) ).x;\n\tfloat nwave = texture( iChannel1, vec2(q.x,0.75) ).x;\n    \n    float owave = texture( iChannel0, vec2(q.x,0.25) ).z;\n    float offt  = texture( iChannel0, vec2(q.x,0.25) ).w;\n    \n    \n    float fwave = mix(nwave,owave, 0.85);\n    \n    \n    /*\n        get fft sum over many bands, this will allow\n\t\tto ge tthe current \"intensity\" of a track\n\t*/\n    float nfft = 0.;\n    for (float i = 0.; i < 1.; i += 0.05)\n    {\n        nfft += texture( iChannel1, vec2(i,0.25) ).x; \n    }\n    nfft = clamp(nfft/30.,0.,1.);\n    \n    float ffts = mix(nfft, offt, 0.8);\n    \n    if (iFrame < 5) \n    {\n        fft = 0.;\n        fwave= .5;\n        ffts = 0.;\n    }\n    \n    fragColor = vec4(fft, nwave, fwave, ffts);\n}", "buffer_c_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXyW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[347, 347, 404, 404, 701]]}
{"id": "slfcDj", "name": "Day Deux - Lambmeow", "author": "lambmeow", "description": "doing a lot of new stuff here\n\ninspiration: https://twitter.com/y2k_aesthetic/status/1448866886922366982", "tags": ["sdf", "shading", "numbers", "two", "daily"], "likes": 2, "viewed": 185, "published": 3, "date": "1648709981", "time_retrieved": "2024-07-30T16:56:04.127558", "image_code": "#define PI 3.14159265359\nfloat bb(vec2 p, vec2 b)\n{ \n    vec2 q = abs(p) - b;\n    \n    return length(max(q, 0.)) + min(max(q.x,q.y),0.);\n}\n\nfloat tws(vec2 p)\n{\n    float res = bb(p, vec2(0.5));\n    res = max(-bb(p + vec2(0.13, -0.2), vec2(0.45, .06)), res);\n    res = max(-bb(p + vec2(-0.13, 0.2), vec2(0.45, .06)), res);\n\n    return res;\n}\n\nfloat ss(vec3 p)\n{\n    p = p/atan(iTime);\n    p.x += iTime;\n    p.x = mod(p.x + .75,1.5) - .75;\n    //get 2d\n    float tw = tws(p.xy);\n    \n    \n    //extrusion\n    vec2 w = vec2(tw, abs(p.z) - ( .5));\n    float res = min(max(w.x,w.y),0.) + length(max(w,0.));\n    return res - 0.02;\n}\nvec3 nn(vec3 value)\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * ss(value+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\nmat3 la(vec3 ro, vec3 ll, vec3 up)\n{\n    vec3 ww = normalize(ll - ro);\n    vec3 uu = normalize(cross(ww, normalize(up)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    return mat3(uu, vv, ww);\n}\n\nfloat ggx(float ndv,float r)\n{\n    float rr = r + 1.;\n    float s = (rr *rr)/8.;\n    return ndv / (ndv * (1. - s) + s);\n}\n\nfloat gSmth(float ndv, float ndl, float r)\n{\n    \n    return ggx(ndv, r) * ggx(ndl, r);\n}\n\nvec3 fsnl(float dl, vec3 F0)\n{\n    return F0 + (1. -F0) * pow(1. - dl, 5.);\n}\n\nfloat rt(vec3 ro, vec3 rd, inout vec3 p)\n{\n    float ll = 0., dd = 0.;\n        \n    \n    for(int i = 0 ; i < 255; i ++)\n    {\n         p = ro + rd * ll; \n         dd = ss(p)*atan(iTime);\n         ll += dd;\n         \n         if(dd < 0.001 || ll > 100.)\n             break;\n    }\n    \n    return dd;\n}\n\nfloat nd(vec3 d, vec3 l)\n{\n    return max(dot(d,l),.0);\n}\n//lighting from https://learnopengl.com/PBR/Lighting\nvec4 gc(vec3 p, vec3 n, float dd, vec3 rd, vec2 u)\n{\n    vec3 al = vec3(1,0,0);\n    float met = 1.;\n    float r = .1;\n    \n    dd = max(1.- dd, 0.);\n    vec3 l = normalize(vec3(sin(iTime) * 3., -cos(iTime) , 1));\n    vec3 v = -rd;\n    vec3 h = normalize(v + l);\n    float ndh = nd(n,h);\n    float ndl = nd(n , l);\n    float ndv = nd(n, v);\n    \n    vec3 bg = vec3(0,0,1) * (1.5 - u.y);\n    if(dd > 0.01)\n    {\n    vec3 f = mix(bg, pow(al , vec3(2.2)), met);\n    float nf = ggx(ndh, r);\n    float g =gSmth(ndv , ndl,r);\n    vec3 fs = fsnl(nd(h, v), f);\n    vec3 kd = vec3(1.) - fs;\n    kd *= 1.- met;\n    \n    vec3 nu = nf * g * f;\n    float de = 4. * ndv * ndl;\n    vec3 sp = nu / max(de, 0.001);\n    \n    return vec4(bg*0.1,1.) + vec4(1. * (kd * pow(al, vec3(2.2)) / PI + sp) * (ndl) ,1);\n    }\n    else\n    {\n    return vec4(bg, 1.);\n    }\n}\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\n    vec2 r = iResolution.xy, u = (2. * f  -r)/r.y;\n    vec3 ro = vec3(-.7 * cos(iTime) , sin(iTime) * 0.4,4), rd = normalize(vec3(u, 2.)), p;\n    float dd = 0.;\n    rd *= la(ro, vec3(0), vec3(0,1,sin(iTime) *0.01));\n    vec3 rf = rd, rfo = ro;\n    float d = rt(ro,rd, p);\n    vec3 op = p;\n    \n    for(int i = 0; i < 2; i ++)\n    {\n        dd = rt(rfo, rf, p);\n        if(dd > 0.01)\n            break;\n        \n        rf = reflect(rd, nn(p));\n        rfo = p +0.01;\n    }\n    \n    c = mix(gc(p, nn(p),d, rd, u), gc(rfo, nn(rfo), dd, rf,  u),0.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 51, 51, 138], [140, 140, 159, 159, 340], [342, 342, 360, 360, 626], [627, 627, 648, 648, 850], [853, 853, 889, 889, 1050], [1052, 1052, 1082, 1082, 1173], [1175, 1175, 1219, 1219, 1264], [1266, 1266, 1296, 1296, 1343], [1345, 1345, 1387, 1387, 1645], [1647, 1647, 1673, 1673, 1704], [1705, 1758, 1810, 1810, 2601], [2602, 2602, 2643, 2643, 3195]]}
{"id": "7lfyDj", "name": "Fractal knots 15", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 3, "viewed": 244, "published": 3, "date": "1648706644", "time_retrieved": "2024-07-30T16:56:04.960331", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*4.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float p1 = 1.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += (t2.yx);\n            \n            //uv += fract(uv.x/2.)/8.; //a more interesting quilt pattern\n            \n            //uv += .5+ceil(t2.x*2.)/2.; //flower pattern\n            uv /= scale;\n            //uv.x += sign(uv.x)/2.;\n            //uv.y += sign(uv.y)/2.;\n            //uv += p1/2.; //makes a flower lace pattern\n            uv += vec2(1.); //this also makes an interesting pattern\n            //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n            t2 = p1*triangle_wave(uv.yx-.5,1.5);\n            t3 = -p1*triangle_wave(uv,1.5);\n            uv.yx = (t2+t3);\n            p1 *= -1.;\n        }\n        float s1 = 2.;\n        col.x = 1.-min(uv.y+uv.x+col.x,col.x)*s1;\n        //col.x = min(uv.y-uv.x+col.x,col.x*2.);\n        \n        //uv.x *= -1.;\n        col = abs(col.yzx-vec3(1.5-col.x))/s1;\n        //col = abs(col.yzx+vec3(col.x)*2.)/3.;\n\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1455]]}
{"id": "fdXXDn", "name": "Shaderdoodle II", "author": "oneshade", "description": "Random doodling with rotation.", "tags": ["doodle", "rotation", "parametric"], "likes": 10, "viewed": 187, "published": 3, "date": "1648692699", "time_retrieved": "2024-07-30T16:56:05.762187", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float unit = 3.0 / iResolution.y;\n\n    float curTime = float(iFrame) * dt;\n\n    vec2 linkOrigin = vec2(0.0);\n    for (int link=0; link < LINKS; link++) {\n        vec3 curLink = getLink(link);\n        float curAngle = curLink.y * curTime + curLink.x;\n        vec2 linkEnd = linkOrigin + vec2(cos(curAngle), sin(curAngle)) * curLink.z;\n        fragColor.rgb += smoothstep(unit, 0.0, sdLine(uv, linkOrigin, linkEnd));\n        linkOrigin = linkEnd;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float unit = 2.0 / iResolution.y;\n\n    float curTime = float(iFrame) * dt;\n    float prevTime = curTime - dt;\n\n    vec2 prevPos = vec2(0.0);\n    vec2 curPos = vec2(0.0);\n    for (int link=0; link < LINKS; link++) {\n        vec3 curLink = getLink(link);\n\n        float prevAngle = curLink.y * prevTime + curLink.x;\n        prevPos += vec2(cos(prevAngle), sin(prevAngle)) * curLink.z;\n\n        float curAngle = curLink.y * curTime + curLink.x;\n        curPos += vec2(cos(curAngle), sin(curAngle)) * curLink.z;\n    }\n\n    fragColor.rgb = mix(fragColor.rgb, hue2rgb(fract(0.25 * iTime)), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos) - 0.001));\n    fragColor.rgb *= 0.99;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define hue2rgb(t) clamp(abs(6.0 * fract(vec3(t, t - 1.0 / 3.0, t - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0)\n\n#define LINKS 50\n#define dt 0.02\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 getLink(in int n) {\n    float i = float(n);\n    vec3 link = Hash13(i + 10.0);\n    link.x = link.x * 2.0 - 1.0;\n    link.y *= i * i * 0.01 * sign(Hash13(i + 13.0).x - 0.5);\n    //link.y = 0.25 * i * sign(Hash13(i + 13.0).x - 0.5);\n    link.z *= 0.1;\n    return link;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 642]]}
{"id": "7lcXzr", "name": "Squares on Squares", "author": "oneshade", "description": "Fun fact: the area of this fractal is a geometric series that equals (4 + 4k^2) / (1 - 3k^2)\n(if |k| < 1 / sqrt(3))", "tags": ["2d", "fractal", "squares"], "likes": 13, "viewed": 157, "published": 3, "date": "1648691004", "time_retrieved": "2024-07-30T16:56:06.583990", "image_code": "// Scale to the next layer of squares\n// The fractal won't overlap itself if k < sqrt(2) - 1\n#define k mix(1.0 / 3.0, sqrt(2.0) - 1.0, 0.5 - 0.5 * cos(iTime))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 uv2 = uv;\n\n    uv.y = abs(uv.y);\n    float color = step(max(abs(uv.x), uv.y), 1.0);\n\n    float brightness = 1.0;\n    for (int i=0; i < 10; i++) {\n        brightness *= 0.75;\n\n        // Three way fold\n        uv.x = abs(uv.x);\n        uv = vec2(min(uv.x, uv.y), max(uv.x, uv.y));\n\n        // Translate outwards and scale\n        uv.y -= 1.0 + k;\n        uv /= k;\n\n        color = max(color, step(max(abs(uv.x), abs(uv.y)), 1.0) * sqrt(0.5 + 0.5 * uv.y) * brightness);\n    }\n\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 215, 215, 802]]}
{"id": "ftXcD2", "name": "Colored Logistic Map", "author": "dankcatlord", "description": "A logistic map with coloring", "tags": ["fractal"], "likes": 5, "viewed": 243, "published": 3, "date": "1648681944", "time_retrieved": "2024-07-30T16:56:07.450673", "image_code": "vec3 hue(float a) {\n    return clamp(abs(mod(6.0 * a + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pd = iResolution.xy / vec2(4.0, 1.0);\n    vec2 uv = fragCoord / pd;\n    \n    vec3 col;\n    float a = 0.5;\n    for (int i = 0; i < 128; i++) {\n        a = uv.x * a * (1.0 - a);\n        int b = // reverse bit order //\n            (i & 1)    << 9 |\n            (i & 2)    << 7 |\n            (i & 4)    << 5 |\n            (i & 8)    << 3 |\n            (i & 16)   << 1 |\n            (i & 32)   >> 1 |\n            (i & 64)   >> 3 |\n            (i & 128)  >> 5 |\n            (i & 256)  >> 7 |\n            (i & 512) >> 9;\n        float c = float(b) / 1024.0;\n        col += clamp(1.0 - (abs(a - uv.y) * pd.y), 0.0, 1.0) * hue(c);\n    }\n    col /= 64.0;\n\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 107], [109, 109, 166, 166, 861]]}
{"id": "ftXyD2", "name": "HPG Student Competition 2022", "author": "hpg_conf", "description": "https://www.highperformancegraphics.org/2022/student-competition/\nUnoptimized path tracer for the High Performance Graphics student competition.", "tags": ["pathtracing", "hpgconf"], "likes": 14, "viewed": 1836, "published": 3, "date": "1648678336", "time_retrieved": "2024-07-30T16:56:08.424070", "image_code": "// The following built-in quality knobs are available:\n//\n// (1) Uncomment the preprocessor definition FULL_SCENE to get the full scene.\n// (2) Set NUM_SAMPLES to increase the number of rays per pixel.\n// \n// We will judge your submitted shader as follows:\n// \n//  - Shader run time must not exceed 2x of our baseline shader \n//    with FULL_SCENE and NUM_SAMPLES==1\n//\n//  - Final image quality will be measured using FLIP against a reference \n//    with FULL_SCENE and NUM_SAMPLES==100000\n// \n// Note: Changing these definitions will increase shader compilation times.\n// \n// Windows users will need to configure their browser to use the native OpenGL backend.\n//\n// If you are using Chrome:\n//  - Go to chrome://flags and search for \"Angle\"\n//  - Change backend from \"Default\" to \"OpenGL\"\n//  - Restart your browser\n//\n//#define FULL_SCENE\n#define NUM_SAMPLES 1\n\n#define VERSION 2\n\n// Changelog:\n//\n// Update (2022-06-14): We have updated the quality evaluation metric to\n//                      FLIP (Andersson et al., HPG 2020) instead of SSIM\n//\n// Version 2:\n//   NEE computation: added epsilon for NdotL, commented in NdotL in BRDF term\n//   Thanks to Arthur Firmino for the bug report!\n\n\n// If you have developed your solution with the old code, and cannot update your\n// submission with reasonable effort, we will grade your solution against our version 1\n// renderer.\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nint seed;\nint flat_idx;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\t\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\t\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\t\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\t\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n\t\t);\n\nconst vec3 light_color[4] = vec3[4](\n\t\tvec3(5),\n\t\tvec3(5),\n\t\tvec3(80.0, 50, 30),\n\t\tvec3(30, 30, 80.0)\n\t\t);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\n// TNB, sorry!\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n// adapted from https://cwyman.org/code/dxrTutors/tutors/Tutor14/tutorial14.md.html\nfloat\nggxNormalDistribution(float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = ((NdotH * a2 - NdotH) * NdotH + 1.0);\n\treturn a2 / (d * d * PI);\n}\n\nfloat\nschlickMaskingTerm(float NdotL, float NdotV, float roughness)\n{\n\t// Karis notes they use alpha / 2 (or roughness^2 / 2)\n\tfloat k = roughness*roughness / 2.0;\n\n\t// Compute G(v) and G(l).  These equations directly from Schlick 1994\n\t//     (Though note, Schlick's notation is cryptic and confusing.)\n\tfloat g_v = NdotV / (NdotV*(1.0 - k) + k);\n\tfloat g_l = NdotL / (NdotL*(1.0 - k) + k);\n\treturn g_v * g_l;\n}\n\nvec3\nschlickFresnel(vec3 f0, float lDotH)\n{\n\treturn f0 + (vec3(1.0, 1.0, 1.0) - f0) * pow(1.0 - lDotH, 5.0);\n}\n\n// When using this function to sample, the probability density is:\n//      pdf = D * NdotH / (4 * HdotV)\nvec3\ngetGGXMicrofacetTS(vec2 randVal, float roughness, vec3 hitNorm)\n{\n\t// GGX NDF sampling\n\tfloat a2 = roughness * roughness;\n\tfloat cosThetaH = sqrt(max(0.0, (1.0 - randVal.x) / ((a2 - 1.0) * randVal.x + 1.0)));\n\tfloat sinThetaH = sqrt(max(0.0, 1.0 - cosThetaH * cosThetaH));\n\tfloat phiH = randVal.y * PI * 2.0;\n\n\t// Get our GGX NDF sample (i.e., the half vector)\n\treturn vec3(sinThetaH * cos(phiH), cosThetaH, sinThetaH * sin(phiH));\n}\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\n\nvec3\nsample_light(vec3 rng, out vec3 normal, out float pdf, out vec3 Le)\n{\n\tint face_idx = int(rng.z * float(cube_light_pos.length()) * 6.0);\n\tint cube_idx = face_idx / 6;\n\tface_idx %= 6;\n\n\tLe = light_color[cube_idx];\n\n\tvec3 p, n;\n\tswitch(face_idx) {\n\tdefault:\n\tcase 0: p = vec3(rng.x, 0, rng.y); n = vec3( 0, -1,  0); break; \n\tcase 1: p = vec3(rng.x, 1, rng.y); n = vec3( 0,  1,  0); break; \n\tcase 2: p = vec3(rng.x, rng.y, 0); n = vec3( 0,  0, -1); break; \n\tcase 3: p = vec3(rng.x, rng.y, 1); n = vec3( 0,  0,  1); break; \n\tcase 4: p = vec3(0, rng.x, rng.y); n = vec3(-1,  0,  0); break; \n\tcase 5: p = vec3(1, rng.x, rng.y); n = vec3( 1,  0,  0); break; \n\t}\n\n\tp -= vec3(0.5);\n\tp = (rotate_y(cube_light_pos[cube_idx].w) * vec4(p, 1.0)).xyz;\n\tn = (rotate_y(cube_light_pos[cube_idx].w) * vec4(n, 0.0)).xyz;\n\tp *= cube_light_size;\n\n\tnormal = n;\n\n\tpdf = 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n\n\treturn p + cube_light_pos[cube_idx].xyz;\n}\n\nfloat\nget_light_pdf()\n{\n    return 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n}\n\n// convert pdf from area measure to solid angle\nfloat\npdf_a_to_w(float pdf, float dist2, float cos_theta)\n{\n    float abs_cos_theta = abs(cos_theta);\n    if(abs_cos_theta < 1e-8)\n        return 0.0;\n\n    return pdf * dist2 / abs_cos_theta;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out MaterialSample ms)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n\n\tfor(int i = 0; i < coordinates_H.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_LEFT;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\t\t\t\tmaterial = MAT_FLOOR;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch(material) {\n\tcase MAT_LEFT   : ms = MaterialSample(vec3(0.9, 0.1, 0.1), 0.5,  false); break;\n\tcase MAT_RIGHT  : ms = MaterialSample(vec3(0.1, 0.9, 0.1), 0.5,  false); break;\n\tcase MAT_CEILING: ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_FLOOR  : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.12, false); break;\n\tcase MAT_BACK   : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_H      : ms = MaterialSample(vec3(1.0, 0.0, 0.0), 0.10, false); break;\n\tcase MAT_P      : ms = MaterialSample(vec3(0.0, 0.7, 0.7), 0.10, false); break;\n\tcase MAT_G      : ms = MaterialSample(vec3(0.1, 0.1, 0.7), 0.10, false); break;\n\tcase MAT_2      : ms = MaterialSample(vec3(0.8, 0.8, 0.8), 0.55, false); break;\n\tdefault         : ms = MaterialSample(light_color[material - MAT_LIGHT0], 0.0, true); break;\n\t}\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tMaterialSample ms;\n\tfloat t_shadow = intersect(r, p, n, ms);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tMaterialSample ms;\n\tfloat t = intersect(ray, position, normal, ms);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(ms.is_light) { /* hit light source */\n\t\treturn ms.color;\n\t}\n\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\tfloat NdotV = max(1e-4, dot(normal, -ray.dir));\n\n\t\t{ /* NEE */\n\t\t\tvec3 light_normal;\n\t\t\tfloat light_pdf;\n\t\t\tvec3 Le;\n\t\t\tvec3 pos_ls = sample_light(vec3(get_random(), get_random().x), light_normal, light_pdf, Le);\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\n\t\t\tvec3 H = normalize(-ray.dir + l_nee);\n\t\t\tfloat NdotH = max(0.0, dot(normal, H));\n\t\t\tfloat LdotH = max(0.0, dot(l_nee, H));\n\t\t\tfloat NdotL = max(1e-6, dot(normal, l_nee));\n\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);\n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);\n\n\t\t\t{\n\t\t\t\tvec3 brdf = D * G * F / (4.0 * NdotV  * NdotL );\n                float brdf_pdf = D * NdotH / (4.0 * LdotH);\n                \n                float light_pdf_w = pdf_a_to_w(light_pdf, rr_nee, -dot(l_nee, light_normal));\n                float w = light_pdf / (light_pdf_w + brdf_pdf);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tcontrib += w * tp * (Le * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ /* brdf */\n\t\t\t// Randomly sample the NDF to get a microfacet in our BRDF \n\t\t\tvec3 H = onb * getGGXMicrofacetTS(get_random(), ms.roughness, normal);\n\n\t\t\t// Compute outgoing direction based on this (perfectly reflective) facet\n\t\t\tvec3 L = normalize(reflect(ray.dir, H));\n\n\t\t\t// Compute some dot products needed for shading\n\t\t\tfloat  NdotL = max(1e-6, dot(normal, L));\n\t\t\tfloat  NdotH = max(1e-6, dot(normal, H));\n\t\t\tfloat  LdotH = max(1e-6, dot(L, H));\n\n\t\t\t// Evaluate our BRDF using a microfacet BRDF model\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);          \n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness); \n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);                 \n\t\t\tvec3  brdf = D * G * F / (4.0 * NdotL * NdotV);        \n\n\t\t\t// What's the probability of sampling vector H from getGGXMicrofacet()?\n\t\t\tfloat brdf_pdf = D * NdotH / (4.0 * LdotH);\n\n\t\t\tray = Ray(position + L * 1e-5, L);\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tMaterialSample ms_next;\n\t\t\tfloat t = intersect(ray, position_next, normal_next, ms_next);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            if(ms_next.is_light) {\n\t\t\t\tfloat light_pdf_a = get_light_pdf();\n\t\t\t\tfloat light_pdf_w = pdf_a_to_w(light_pdf_a, t * t, -dot(ray.dir, normal_next));\n\t\t\t\tfloat w = brdf_pdf / (brdf_pdf + light_pdf_w);\n\t\t\t\tcontrib += tp * (ms_next.color * w * brdf) / brdf_pdf;\n\t\t\t\tbreak;\n            }\n\n\t\t\ttp *= NdotL * brdf / brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\tms = ms_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0, 3.0);\n\tvec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float exposure = 2.0;\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n\n\tfragColor = vec4(pow(exposure * s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3536, 3551, 3592, 3592, 3945], [3947, 3947, 3982, 3982, 4338], [4340, 4340, 4359, 4359, 4470], [4472, 4556, 4615, 4615, 4728], [4730, 4730, 4799, 4855, 5142], [5144, 5144, 5187, 5187, 5254], [5256, 5361, 5431, 5452, 5799], [5801, 5801, 5825, 5825, 5942], [5944, 5944, 5990, 5990, 6442], [7544, 7592, 7651, 7651, 7785], [7787, 7787, 7872, 7872, 8197], [8199, 8199, 8233, 8233, 8269], [8271, 8271, 8339, 8339, 8469], [8471, 8471, 8556, 8556, 9164], [9166, 9166, 9248, 9248, 15515], [15517, 15517, 15557, 15557, 15774], [15776, 15776, 15798, 15798, 18707], [18709, 18709, 18764, 18764, 19623]]}
{"id": "NtXcW2", "name": "anillo perdido", "author": "jorge2017a2", "description": "anillo perdido", "tags": ["anilloperdido"], "likes": 1, "viewed": 206, "published": 3, "date": "1648677682", "time_retrieved": "2024-07-30T16:56:09.260833", "image_code": "//----------image\n//por jorge2017a2-\n/// anillo perdido--30-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.z+=iTime*30.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    \n    p.y=p.y-5.0;\n    p.z= opRep1D(p.z, 20.0);\n    p.x= opRep1D(p.x, 75.0);\n    p.y= opRep1D(p.y, 40.0);\n    \n    float d1a= sdCylinderXY(p, vec2(20.0,5.0));\n    float d1b= sdCylinderXY(p, vec2(17.0,6.0));\n    \n    float dif= differenceSDF(d1a, d1b);\n    //poste\n    float d2a= sdRoundBox(p-vec3(20.0,5.0,0.0), vec3(12.0,1.0,1.0), 0.5 );\n    float d2c= sdRoundBox(p-vec3(25.0,4.0,0.0), vec3(1.0,8.0,1.0), 0.5 );\n    float d2b= sdRoundBox(p-vec3(25.0,10.0,0.0), vec3(0.25,1.0,2.0), 0.5 );\n    d2c= differenceSDF(d2c, d2b);\n    //anillo\n    float d3a= sdCylinderXY(p, vec2(19.0,5.5));\n    float d3b= sdCylinderXY(p, vec2(18.0,5.6));\n    float dif3= differenceSDF(d3a, d3b);\n    res =opU2(res, vec2(dif,100.0));\n    res =opU2(res, vec2(d2a,9.0));\n    res =opU2(res, vec2(d2c,9.0));\n    res =opU2(res, vec2(dif3,4.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n    \n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\t\n    p.z+=iTime*30.0;\n    if (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.13, .36, .68), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50){ colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==100 ){ return  getColorTextura( p, nor,100); }\n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(35.0,15.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n   float vel=0.065;\n   //float vel=0.125;\n   rd= rotate_y(rd, radians(360.*cos(iTime*vel*+sin(iTime*vel))));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5)  //9\n);\n\nvec3 getColor(int i)\n{  if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 511, 511, 598], [599, 599, 638, 638, 733], [734, 734, 773, 773, 868], [869, 869, 908, 908, 1003], [1006, 1006, 1053, 1053, 1080], [1081, 1081, 1124, 1124, 1151], [1152, 1152, 1200, 1200, 1228], [1229, 1267, 1303, 1303, 1348], [1350, 1350, 1384, 1384, 1480], [1481, 1481, 1515, 1515, 1606], [1607, 1607, 1641, 1641, 1732], [1734, 1734, 1759, 1759, 2705], [2707, 2707, 2731, 2731, 2893], [2895, 2895, 2943, 2943, 3249], [3252, 3252, 3296, 3296, 3614], [3616, 3616, 3653, 3653, 3910], [3913, 3913, 4003, 4003, 5013], [5015, 5015, 5064, 5064, 5223], [5225, 5225, 5318, 5318, 5448], [5451, 5451, 5483, 5483, 5683], [5686, 5686, 5756, 5756, 5925], [5927, 5927, 5954, 5954, 6043], [6045, 6045, 6103, 6103, 6151], [6153, 6153, 6176, 6176, 6288], [6290, 6290, 6321, 6321, 6950], [6952, 6952, 7009, 7009, 7552]]}
{"id": "NllcDB", "name": "Very Simple Squares", "author": "SnoopethDuckDuck", "description": "Simple example using this equation:\nhttps://www.desmos.com/calculator/rrkc02de7q\n\nYou can also smoothstep it", "tags": ["e"], "likes": 8, "viewed": 217, "published": 3, "date": "1648655130", "time_retrieved": "2024-07-30T16:56:10.092609", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat fn(float t, float a) {\n    float f = 2. * abs(fract(t) - 0.5);\n    return (clamp(f, 1. - a, a) + a - 1.) / (2. * a - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;    \n    uv *= 2.;\n    \n    // Width of squares\n    float a = 0.25 + 0.125 * thc(2., -iTime);\n    \n    // Alters trajectory of square\n    float h = 0.675 + 0.075 * thc(2., -iTime);\n    \n    // Trajectory of square\n    float t = 0.25 * iTime;\n    vec2 p = vec2(fn(t, h), fn(t + 0.25, h))-0.5;\n    \n    //Draw squares\n    float k = 2. / iResolution.y;\n    float s = smoothstep(-k, k, 0.02 - abs(-sdBox(uv - p,   vec2(0.8 * a)) + 0.2 * a));\n         s += smoothstep(-k, k, 0.02 - abs(-sdBox(uv, 0.8 * vec2(0.5 - a)) + 0.2 * (0.5 - a)));\n    \n    vec3 col = vec3(s) + 0.2;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 97, 97, 177], [179, 179, 207, 207, 308], [310, 310, 367, 367, 1039]]}
{"id": "NtsyDS", "name": "05 smiley ", "author": "ccc9527", "description": "procedural texture", "tags": ["smiley"], "likes": 2, "viewed": 246, "published": 3, "date": "1648646976", "time_retrieved": "2024-07-30T16:56:10.864545", "image_code": "//将(a,b)范围的数t映射到(0,1)之间\nfloat Remap01(float a,float b,float t)\n{\n    return clamp((t-a)/(b-a),0.0,1.0);\n}\n//将(a,b)范围的数t映射到(c,d)之间\nfloat Remap(float a,float b,float c,float d,float t)\n{\n    return Remap01(a,b,t)*(d-c)+c;\n}\n//将uv限制在一个矩形中且映射到(0,1)之间,xy为矩形左下角点，zw为矩形右上角点\nvec2 within(vec2 uv,vec2 xy,vec2 zw)\n{\n    return (uv-xy)/(zw-xy);\n}\n//眉毛\nvec4 Brow(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    float y = uv.y+0.1;\n    uv.y += uv.x*0.8-0.2;\n    uv.x -= 0.1;\n    uv -= 0.5;//因为uv被重映射到一个矩形框内，所以要将中心移动到中间\n    \n    float d1 = length(uv);\n    float s1 = smoothstep(0.45,0.35,d1);\n    float d2 = length(uv-vec2(0.07,-0.14));\n    float s2 = smoothstep(0.5,0.4,d2);\n    \n    float browMask = clamp(s1-s2,0.0,1.0);//两个圆相减获得一段弧作眉毛\n    float colMask = Remap01(0.7,0.8,y)*0.75;\n    colMask *= smoothstep(0.6,0.9,browMask);//browMask缩小一些得到colMask\n    //colMask区域显示偏亮的颜色\n    vec4 browCol = mix(vec4(0.4, 0.2, 0.2, 1.0), vec4(1.0, 0.75, 0.5, 1.0), colMask); \n    \n    col = mix(col,browCol,smoothstep(0.2,0.4,browMask));\n    \n    return col;\n}\n//笑脸的眼睛\nvec4 Eye(vec2 uv)\n{\n    uv -= 0.5;//因为uv被重映射到一个矩形框内，所以要将中心移动到中间\n    \n    vec4 col = vec4(1.0);\n    float d = length(uv);\n    vec4 irisCol = vec4(0.3,0.5,1.0,1.0);//虹膜颜色\n    //混合虹膜颜色\n    col.rgb = mix(col.rgb,irisCol.rgb,smoothstep(0.1,0.7,d)*0.4);\n    //眼睛的外描边 eye's outline.\n    col.rgb = mix(col.rgb,vec3(0.0),smoothstep(0.45,0.5,d)*\n        clamp(uv.y+uv.x*0.5,0.0,1.0));\n    //混合眼珠颜色\n    col.rgb = mix(col.rgb,vec3(0.0),smoothstep(0.3,0.28,d));\n    //蓝色区域\n    irisCol.rgb *= 1.0+smoothstep(0.3,0.05,d);\n    col.rgb = mix(col.rgb,irisCol.rgb,smoothstep(0.28,0.25,d));\n    //黑色区域\n    col.rgb = mix(col.rgb,vec3(0.0),smoothstep(0.16,0.14,d));\n    //眼睛中的高光,highLight\n    float highLight = smoothstep(0.1,0.09,length(uv-vec2(-0.15,0.15)));\n    highLight += smoothstep(0.07,0.06,length(uv-vec2(0.08,-0.08)));\n    col.rgb = mix(col.rgb,vec3(1.0),highLight);\n    \n    col.a = smoothstep(0.5,0.48,d);\n    \n    return col;\n}\n//嘴巴\nvec4 Mouth(vec2 uv)\n{\n    vec4 col = vec4(0.5,0.18,0.05,1.0);  //偏深红色\n    uv -= 0.5;        //因为uv被重映射到一个矩形框内，所以要将中心移动到中间\n    uv *= 1.5;        //缩小矩形\n    uv.y -= uv.x*uv.x*2.0;  //将椭圆变为所需嘴巴性,通过将uv.y按uv.x的大小进行偏移\n    float d = length(uv);\n    \n    col.a = smoothstep(0.5,0.48,d);\n    //牙齿，teeth\n    float teeth = length(uv-vec2(0.0,0.6));\n    vec3 tooth = vec3(1.0)*smoothstep(0.6,0.35,d);\n    col.rgb = mix(col.rgb,tooth,smoothstep(0.4,0.37,teeth));\n    //舌头，tongue\n    float tg = length(uv-vec2(0.0,-0.5));\n    col.rgb = mix(col.rgb,vec3(1.0,0.5,0.5),smoothstep(0.5,0.3,tg));\n    \n    return col;\n}\n//头部\nvec4 Head(vec2 uv)\n{\n    vec4 col = vec4(0.9,0.65,0.1,1.0);\n    \n    float d = length(uv);\n    col.a = smoothstep(0.5,0.49,d);//小于0.49为1，(0.49,0.5)是(1.0,0.0)，大于0.5是0\n    \n    float edgeShade = Remap01(0.35,0.5,d);//将距离中心(0.35,0.5)范围的值映射为(0,1)\n    edgeShade *= edgeShade;//变化更缓慢\n    col.rgb *= 1.0-edgeShade*0.5;\n    \n    //outline color\n    col.rgb = mix(col.rgb,vec3(0.6,0.3,0.1),smoothstep(0.47,0.48,d));\n    \n    //highLight,半圆\n    float highLight = smoothstep(0.41,0.405,d);\n    highLight *= Remap(0.41,-0.1,0.75,0.0,uv.y);\n    highLight *= smoothstep(0.18,0.19,length(uv-vec2(0.21,0.075)));//眼睛外的一圈深黄色，加深眼睛深度感\n    col.rgb = mix(col.rgb,vec3(1.0),highLight);\n    \n    //cheek,脸颊\n    d = length(uv-vec2(0.28,-0.2));\n    float cheek = smoothstep(0.2,0.01,d)*0.4;\n    cheek *= smoothstep(0.17,0.16,d);\n    col.rgb = mix(col.rgb,vec3(1.0,0.1,0.1),cheek);\n    \n    return col;\n}\n//笑脸\nvec4 Smiley(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    \n    uv.x = abs(uv.x);//镜像生成另一半眼睛和淡红脸颊\n    \n    vec4 head = Head(uv);\n    col = mix(col,head,head.a);\n    \n    vec4 eye = Eye(within(uv,vec2(0.03,-0.1),vec2(0.37,0.25)));\n    col = mix(col,eye,eye.a);\n    //这里的within将左下角为vec2(-0.3,-0.4)右上角为vec2(0.3,-0.1)的矩形uv映射为(0,0)-(1,1)\n    vec4 mouth = Mouth(within(uv,vec2(-0.3,-0.4),vec2(0.3,-0.1)));\n    col = mix(col,mouth,mouth.a);\n    //这里的within将左下角为vec2(0.03,0.2)右上角为vec2(0.4,0.45)的矩形uv映射为(0,0)-(1,1)\n    vec4 brow = Brow(within(uv,vec2(0.03,0.2),vec2(0.4,0.45)));\n    col = mix(col,brow,brow.a);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Output to screen\n    fragColor = Smiley(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 84, 84, 125], [126, 170, 224, 224, 261], [262, 367, 405, 405, 435], [436, 445, 465, 465, 1235], [1236, 1254, 1273, 1273, 2294], [2295, 2304, 2325, 2325, 3023], [3024, 3033, 3053, 3053, 4004], [4005, 4014, 4036, 4036, 4732], [4734, 4734, 4789, 4789, 4904]]}
{"id": "7lXcDS", "name": "Logo GameCube", "author": "Karp", "description": "GameCube Logo\n//TODO le faire de manière plus propre", "tags": ["logo", "gamecube"], "likes": 1, "viewed": 154, "published": 3, "date": "1648642404", "time_retrieved": "2024-07-30T16:56:11.702305", "image_code": "vec3 Cube(vec2 uv,float size, vec3[3] colors, float blurLvl)\n{\n    vec3 result = vec3(0.0);\n\n    float top   = sdRhombus(RotateUV(uv, 000.0) + vec2(0.0,-.6 /1.732), vec2(.6,.6 /1.732));\n    float left  = sdRhombus(RotateUV(uv, 120.0) + vec2(0.0,-.6 /1.732), vec2(.6,.6 /1.732));\n    float right = sdRhombus(RotateUV(uv,-120.0) + vec2(0.0,-.6 /1.732), vec2(.6,.6 /1.732));\n\n    result = mix(colors[0], result, Clamp01((top)*blurLvl));\n    result = mix(colors[1], result, Clamp01((left)*blurLvl));\n    result = mix(colors[2], result, Clamp01((right)*blurLvl));\n\n    return result;\n}\nfloat CubeMask(vec2 uv,float size, float blurLvl)\n{\n    return Clamp01((sdHexagon(RotateUV(uv, 30.0), size *0.5))*blurLvl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Parameter\n    float size = 0.6;\n    float rounding = 0.1;\n    float blurLvl = 250.0;\n\n    //Color\n    vec3 shadow = Color255(95,74,175);\n    vec3 highlight = Color255(168,139,255);\n    vec3 midtone = Color255(199,166,255);\n    vec3[] colors = vec3[](shadow,midtone,highlight);\n    \n    // UV manipulation\n    vec2 uv  = AspectRatioUV(fragCoord.xy, iResolution.xy);\n    uv = RotateUV(uv, -120.0);\n    \n    //BackGround\n    vec3 pixel = vec3(0.1);\n    \n    //Cube\n    pixel = mix(pixel, Cube(uv, 10.,colors,blurLvl), 1.-Clamp01(CubeMask(uv, 1.,blurLvl)));\n    pixel = mix(pixel, Cube(-uv, 1.,colors,blurLvl), 1.-CubeMask(uv, 0.75,blurLvl));\n    pixel = mix(pixel, vec3(0.1), 1.-CubeMask(uv, 0.72,blurLvl));\n    pixel = mix(Cube( uv, 1.,colors,blurLvl), pixel, CubeMask(uv, 0.5,blurLvl));\n    \n    float voidmask = 1.-Clamp01(CubeMask(uv + vec2(.38,-.38/1.732), 0.3,blurLvl));\n    voidmask *= 1.-Clamp01((sdBox(RotateUV(uv,-120.0)+ vec2(-.095,.825/1.732), vec2(.08,.18)))*blurLvl);\n    pixel = mix(pixel, vec3(0.1), voidmask);\n    \n    voidmask = 1.-Clamp01((sdBox(RotateUV(uv,-120.0)+ vec2(.08,.5/1.732), vec2(.091,.15)))*blurLvl);\n    pixel = mix(pixel, Cube(uv, 1.,colors,blurLvl), voidmask);\n    \n    voidmask = 1.-Clamp01(sdRhombus(RotateUV(uv,30.0) + vec2(.365,-.225), vec2(.135/1.732,.135))*blurLvl);\n    voidmask *= 1.-Clamp01(sdRhombus(RotateUV(uv,30.0) + vec2(.3,-.35), vec2(.135/1.732,.135))*blurLvl);\n    voidmask *= Clamp01(sdBox(RotateUV(uv,30.0) + vec2(.4,-.485), vec2(.135,.135))*blurLvl);\n    voidmask *= Clamp01(sdBox(RotateUV(uv,30.0) + vec2(.3,-.09), vec2(.135,.135))*blurLvl);\n    pixel = mix(pixel, shadow, voidmask);\n\t\n    vec4 result = vec4(pixel.xy, voidmask, 1.);\n    result = vec4(pixel.xyz, 1.);\n    \n\tfragColor = result;\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n//UV\nvec2 AspectRatioUV(vec2 fragCoord, vec2 iResolution)\n{\t\n    vec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n    // [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920 / 1080 = 1.778\n    // [-0.5*iResolution.x, 0.5*iResolution.x] ->[-1.778, 1.778]\n\t// [-0.5*iResolution.y, 0.5*iResolution.y] ->[-1, 1]\n    \n    return uv;\n}\nvec2 RotateUV(inout vec2 uv, float angle)\n{\t\n\tangle = angle * PI / 180.0;\n    return uv * mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\n\n//Color \nvec3 Color255(int R, int G, int B)\n{\n    return vec3(float(R)/255.0, float(G)/255.0, float(B)/255.0);\n}\nfloat Clamp01( in float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n//Regular Hexagon - exact from https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n// Rhombus - exact from IQ (https://www.shadertoy.com/view/XdXcRB)\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\nfloat sdBox( in vec2 pos, in vec2 box )\n{\n    vec2 dist = abs(pos)-box;\n    return length(max(dist,0.0)) + min(max(dist.x,dist.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 581, 632, 632, 706]]}
{"id": "7tXyDB", "name": "Waves fork", "author": "bagnz0r", "description": "Waves fork", "tags": ["fft"], "likes": 6, "viewed": 316, "published": 3, "date": "1648641002", "time_retrieved": "2024-07-30T16:56:12.514135", "image_code": "float squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 85, 85, 144], [146, 146, 172, 172, 270], [272, 272, 329, 329, 1066]]}
{"id": "slXcWB", "name": "Simple Turbulence", "author": "talon", "description": "super simple version turbulence", "tags": ["turbulence"], "likes": 0, "viewed": 214, "published": 3, "date": "1648637473", "time_retrieved": "2024-07-30T16:56:13.419713", "image_code": "#define NoiseStrength 2.0\n#define NoiseFinalMultiplier 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float sint = sin(iTime) * 0.5 + 0.5;\n    float cost = cos(iTime) * 0.5 + 0.5;\n    \n    vec4 p0 = texture(iChannel0 ,uv);\n    vec4 p1 = texture(iChannel0 ,uv + vec2(0.25 ,0.25));\n    vec4 r0 = mix(p0 ,p1 ,sint);\n    \n    vec4 p2 = texture(iChannel0 ,uv + vec2(0.50 ,0.50));\n    vec4 p3 = texture(iChannel0 ,uv + vec2(0.75 ,0.75));\n    vec4 r1 = mix(p2 ,p3 ,cost);\n    \n    float n = 1.0 - max(r0.x ,r1.x);\n    \n    n = clamp((1.0 - n * NoiseStrength) * NoiseFinalMultiplier ,0.0 ,1.0);\n\n    // Output to screen\n    fragColor = vec4(vec3(n,n,n),1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 117, 713]]}
{"id": "slfyDS", "name": "Menger PT v4", "author": "El_Sargo", "description": "Yet another iteration of my basic pathtracer, this time adding some pbr stuff like rougness and fresnel, alowing for all kinds of surfaces to be rendered like gold for example.", "tags": ["3d", "raymarching", "gi", "path", "pbr"], "likes": 6, "viewed": 318, "published": 3, "date": "1648628827", "time_retrieved": "2024-07-30T16:56:14.250492", "image_code": "//The actual rendering is in buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv)/float(iFrame);\n    col = col*exp(vec4(1.1,1.05,1.2,1. ));\n    fragColor = smoothstep(-0.,1.2,col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 sun = normalize(vec3(1.2,1.,1.)); // The direction of the sunlight\nconst vec3 suc = vec3(.99,0.7,0.4); // sunlight color\nconst float unIntersect = 0.001; // don't touch this\nconst int iter = 6; // number of GI bounces\nconst float bou_coef = 5.; // intensity of bounce light\nconst float sun_coef = 1.9; // intensity of sun light\nconst float amb_coef = 1.; // intensity of ambient light\nconst float r = .12;\nconst bool metalic = true;\n//Dosn't actually need an array, just makes it easer to use many materials\n// Pbr also wasn't implemented\nconst vec3[] colors = vec3[](vec3(0.),vec3(0.31,0.28,0.15));\n\n//ambient light color\nvec3 amb(vec3 rd){\n    return clamp(vec3(vec2(0.8,0.9)*(0.7+pow(.9-rd.y, 2.)*0.4),1.-rd.y*0.1),vec3(0.),vec3(1.));\n}\n\n//#define rotations\n\n//Heavy performance impact \n#define raymarchSteps 60\n\n#define ZERO min(iFrame, 0)\n\n//SDF stuff....\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// rotation matrix\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\n\n\n\n// transfrom a point to from a fractal\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n// distance to a fractal\n// yes you can use a loop, but I wanted controll over the rotations\nvec4 map(vec3 p) {\n\n    const float scale = 260.*3.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(2.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(5.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(2.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.512);\n    p = trans(p, 3.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 1.);\n    p.zy*=rotate(0.1);\n    #else\n    p = trans(p, 27.*9.*3.);\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale, p);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// For the fractal\nfloat intersection(vec3 ro, vec3 rd){\n    float dist;\n    float T;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro+rd*T).x;\n        T+=dist;\n        if (dist < 0.00001 || dist > 2.)\n            break;\n    }\n    \n    return T;\n\n}\n\n// Hash function\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\nvec3 hash3(vec3 p3)\n{\n    p3 += iTime*vec3(0.513, 1.134, -2.1245);\n \n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    p3 = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    return normalize(p3-0.5);\n\n}\n/*\n//Random direction\nvec3 hash3( vec3 p )\n{\n    p+=iTime*vec3(0.8,0.5,-2.);\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn normalize(fract(sin(p)*43758.5453123)-0.5);\n}\n*/\n\nvec3 ranRef(vec3 rd, vec3 nor){\n    vec3 dir = hash3(rd-nor*r);\n         dir *= sign(dot(nor,dir));\n         \n    vec3 ref = reflect(rd, nor);\n    \n    if (hash3(rd+nor+r).x*.5+.5 > r){\n        dir = mix(ref, dir, r);\n    }\n    \n    return dir;\n}\n\nstruct world {\n    int  id;\n    vec3 pos;\n    vec3 nor;\n    float dis;\n};\n\nworld wolrdIntersect(vec3 ro, vec3 rd){\n    vec3 nor = vec3(0);\n    float d = 10e10;\n    int id = 0;\n    //fractal\n    {\n        float md = intersection(ro,rd);\n        if (map(ro+rd*md).x < 0.1 && md < d){\n            id = 1;\n            nor = calcNormal(ro+rd*md);\n            d = md;\n        }\n    }\n    /*//ball\n    {\n        vec3 ce = vec3(0,-0.32,-.97);\n        float bd = sphIntersect(ro, rd, ce, 0.05).x;\n        if (bd > -0.1 && bd < d){\n            id = 2;\n            nor = normalize(ce-ro+bd*rd)*-1.;\n            d = bd;\n        }\n    }*/\n    return world(id,ro+d*rd,nor, d);\n}\n\n//Trace a path away from the shape and return 1 if we hit nothing\nfloat getShadow(vec3 p, vec3 rd){\n    rd = normalize(rd+ hash3(rd+p)*0.1);\n    p+=unIntersect*rd;\n    return wolrdIntersect(p, rd).id == 0 ? 1. : 0.;\n}\n\n//Shadow ray in a random direction\nvec3 getAmbiance(vec3 dir, vec3 nor, vec3 p, int i, out vec3 amD){\n    vec3 rd = ranRef(dir,nor);\n    rd.y = .1+rd.y;\n    amD = rd;\n    return getShadow(p+unIntersect*rd,rd)*amb(rd);\n}\n\nstruct ligt {\n    vec3 scl;\n    vec3 nor;\n    float sha;\n    vec3 amb;\n    vec3 amD;\n    vec3 inc;\n    vec3 ref;\n\n};\n\nfloat calcFresnel(vec3 inc, vec3 ref){\n    return ((abs(dot(inc, ref)))*0.5+1.)*0.7;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 dir = rd;\n    vec3 p = ro;\n    vec3 inc = rd;\n    vec3 amD;\n    ligt[iter] lig;\n    //Get light\n    for (int i=0;i<iter;i++){\n\n        world w = wolrdIntersect(p+dir*.05, dir);\n        float sha = getShadow(w.pos, sun);\n\n        //Colors\n        if (w.id==0){\n            if (i==0)\n                //Sky\n                return 0.3*amb(dir);\n             else {\n                break;\n            }\n        }\n        \n        vec3 am = vec3(0.);\n        for(int a=0;a<1;a++){\n            am += getAmbiance(dir, w.nor, w.pos,a,amD)*2.;\n        }\n        \n        dir = ranRef(dir, w.nor);\n        lig[i] = ligt(colors[w.id], w.nor,sha*(dot(sun,w.nor)*.25+.75), am, amD, inc, dir);\n        /*\n        dir = hash3(p+w.pos+dir);\n        dir *= sign(dot(w.nor,dir));\n        */\n        inc = dir;\n        \n        p = w.pos;\n\n\n    }\n    vec3 col = vec3(0);\n    for (int i=iter-1;i>-1;i--) {\n    \n         vec3 scl = lig[i].scl;\n        float sha = lig[i].sha;\n         vec3 am  = lig[i].amb;\n         vec3 amD = lig[i].amD;\n         vec3 nor = lig[i].nor;\n         vec3 inc = lig[i].inc;\n         vec3 ref = lig[i].ref;\n         \n          //prevoius bounce\n          vec3 pre = col*scl*bou_coef;\n          vec3 hVec = normalize(mix(inc,sun,0.5));\n          col = + mix(pre, pre*calcFresnel(inc,ref), 1.-r)+\n                //sun light\n                 float(metalic==false)*scl*sha*suc*sun_coef+\n                 float(metalic)*pow(dot(nor,hVec)*.5+.5,5.)*sun_coef*sha*scl+\n                //ambient light\n                scl*am*amb_coef*calcFresnel(inc,amD);\n\n    }\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = hash3(vec3(uv, iTime)).xz/iResolution.xy*0.5;\n    vec3 rd = normalize(vec3(\n            (uv-0.5)*vec2(1.,iResolution.y/iResolution.x)+o,\n            1.));\n    rd.xz *= rotate(.2);\n    rd.yz *= rotate(0.);\n    \n    vec3 ro = vec3(-.1,0.05,-1.3);//vec3(0.,-0.3,-1.);\n\n    vec3 col = render(ro,rd);\n    \n    vec3 prev = texture(iChannel0, uv).xyz;\n    \n    col += prev;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 275]]}
{"id": "7tXcWS", "name": "Dia uno - Lambmeow", "author": "lambmeow", "description": "Start of a daily challenge", "tags": ["glitch", "daily", "crtesque"], "likes": 8, "viewed": 286, "published": 3, "date": "1648620886", "time_retrieved": "2024-07-30T16:56:15.038386", "image_code": "float box(vec2 u, vec2 d)\n{\n    vec2 b = abs(u) - d;\n    \n    return length(max(b,0.)) + min(max(b.x,b.y),0.);\n}\n\nfloat one(vec2 u)\n{\nu.x += 0.25;\n   vec2 ou = u;\n   float o = box(u, vec2(.07,.5));\n   \n   o = min(o, box(u + vec2(0, 0.5), vec2(.3,.07)));\n   \n   \n   const float ang = degrees(-45.), ca = cos(ang), sa = sin(ang);\n   float cut = length(u - vec2(-0.55, .93)) - .65;\n   u -= vec2(-0.14, .358);\n   u *= mat2(ca, -sa,sa,ca);\n   o = min(o , box(u, vec2(.07, .15)));\n   o = min ( o,  floor(cos(iTime * 3.) +1.) *0.1 + box(ou - vec2(0.6, -.5), vec2(.15, .07)));\n   \n   return max(-cut, o);\n}\nvoid mainImage( out vec4 c, in vec2 f )\n{\n   vec2 r = iResolution.xy, u = (2. * f  -r)/r.y;\n   \n\n   u *= 1. + length(u) * .3;\n   u *= 1. - .3;\n   \n   float a =iTime + u.y * r.y, ro = sin(a), go = cos(a + 2.4), bo= sin(a + 1.1111);\n   ro *= tan(u.y *3. + iTime *.53)* 0.003;\n   bo *= tan(u.y *3. + iTime *.53)* 0.003;\n   go *= tan(u.y *3. + iTime *.53)* 0.003;\n   u.x += sin(iTime + u.y * r.y) *0.005;\n   vec3 col = vec3(one(u + vec2(ro *.24,0)),\n                   one(u + vec2(go * .52,0)),\n                   one(u + vec2(bo *1.15,0)));\n   c += vec4(step(col, vec3(0.001)),1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 112], [114, 114, 133, 133, 598], [599, 599, 640, 640, 1180]]}
{"id": "stXcWS", "name": "Glowing gems", "author": "jarble", "description": "Another glowing fractal pattern.", "tags": ["fractal", "gem", "ruby", "emerald"], "likes": 7, "viewed": 298, "published": 3, "date": "1648619998", "time_retrieved": "2024-07-30T16:56:15.852209", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nfloat triangle_wave(float a){\n    return abs(fract(a)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += (iTime+8.)/vec2(2.0,3.0)/t1/12.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    //float s1 = 1.;\n    for(int k = 0; k < 12; k++){\n        vec2 uv1 = uv;\n        uv -= (t2.yx);\n        t2 = triangle_wave(uv.yx+.5,scale).yx/2.;\n        t3 = triangle_wave(uv,scale).yx;      \n        uv.yx = t3-t2/3.;\n        //uv.y *= sign(uv.x);\n        float m1 = uv.x;\n        \n        \n        //More interesting patterns here:\n        //float m1 = (uv.y-uv.x)/(1.-t2.x);\n        //float m1 = (uv.y+uv.x)/2./(1.-t2.x);\n\n        //float m1 = uv.x-uv.y;\n        //float m1 = uv.y-uv.x;\n        //float m1 = uv.x*float(k%2)+uv.y*float((k+1)%2);\n        \n        col.x = max(m1,col.x);\n        col = abs(col.yzx-vec3(col.x*(2.125+.125*4.*triangle_wave((uv.x)*16.+iTime*4.)/8.-t2.y)));\n        uv /= 1.25;\n        //uv -= float(k%3)/2.;\n        //uv -= float(k%3+5)/2.;\n\n        \n        //if(k>3) uv.x += iTime/s1/4.;\n        //s1 *= scale;\n        //uv /= 1.+normalize(t2).x/3.;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 144, 144, 175], [177, 177, 234, 234, 1397]]}
{"id": "flXcDB", "name": "ola -Melisa-00-2", "author": "jorge2017a2", "description": "ola -Melisa-00-2", "tags": ["olamelisa002"], "likes": 6, "viewed": 212, "published": 3, "date": "1648609907", "time_retrieved": "2024-07-30T16:56:16.678999", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n// referencia\n//https://www.shadertoy.com/view/flfczs....Created by MelisaHot in 2022-03-28\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2, 1.6);\n\nfloat cosNoise( in vec2 p )\n{ return 0.4*( sin(p.x) + sin(p.y) );}\n\nfloat mapMar( in vec3 pos )\n{  float h = 0.0;\n    vec2 q = pos.xz*0.5;    \n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {   h += s*cosNoise( q ); \n        q = m2*q*0.9-iTime; \n        q += vec2(2.,5.);\n        s *= 0.5 + 0.2*h;\n    }\n h *= 2.0;\n return pos.y - h;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tp.y=p.y-5.0;\n    float m1= mapMar(p);\n    return opU2(res, vec2(m1,9.0));\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);    \n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n    \n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n  \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;       \n    return colOut;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 getColor(float c){\n   float r = cos((c-0.75)*PI);\n   float g = cos((c-0.55)*PI);\n   float b = cos((c-0.25)*PI);\n   return vec3(r,g,b);\n}\n\nvec3 render_sky_color(vec3 rd, vec2 frag)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    return  mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 frag)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd,frag);\n   return col;\n}\n\n//https://www.shadertoy.com/view/flfczs\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=mod(iTime*2.0,360.0);\n   \n    float r = 0.25; \n   //vec2 uv=frag;\n   float v = r/(length(uv));\n   vec3 luna= getColor(0.916)*v; \n    \n    float pysol=uv.y+1.0*sin(t*0.5);\n    light_pos1= vec3(-10.0, 15.0-pysol*20.0, -25.); light_color1=luna;\n \tlight_pos2= vec3(-10.0, 20.0-pysol*10.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,2.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   vec3 lp = vec3(0., -0.2, 4); // lookat point (aka camera target\n    rd=camera(ro, lp)*rd;\n   float py= mapMar(ro+rd*1.0);\n   ro.y+=py+2.5;\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd,vec2(uv.x, uv.y+0.5*sin(t*0.5)));\n   luna= getColor(0.916)*v; \n   \n\tcol*=luna;\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(.395, .95, 1.), //8\nvec3(0.425, 0.56, 0.9), //9\nvec3(0.2, 0.5, 0.8)  //10\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 596, 596, 633], [635, 635, 664, 664, 907], [909, 909, 934, 934, 1053], [1055, 1055, 1079, 1079, 1241], [1243, 1243, 1291, 1291, 1597], [1600, 1600, 1644, 1644, 1962], [1964, 1964, 2001, 2001, 2258], [2260, 2260, 2350, 2350, 3380], [3383, 3383, 3476, 3476, 3606], [3608, 3608, 3631, 3631, 3749], [3751, 3751, 3794, 3794, 3974], [3977, 3977, 4047, 4047, 4144], [4146, 4146, 4173, 4173, 4262], [4264, 4264, 4322, 4322, 4370], [4372, 4372, 4395, 4395, 4507], [4509, 4509, 4551, 4551, 5176], [5178, 5218, 5265, 5265, 5478], [5480, 5480, 5537, 5537, 6335]]}
{"id": "NtXcDB", "name": "simple bloque-02", "author": "jorge2017a2", "description": "simple bloque-02", "tags": ["simplebloque02"], "likes": 5, "viewed": 183, "published": 3, "date": "1648609571", "time_retrieved": "2024-07-30T16:56:17.588567", "image_code": "//----------image\n//por jorge2017a1-\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n    { vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n    \nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec3 p0=p;\n    //p.y=p.y-7.0;\n     p.x= opRep1D(p.x, 9.0);\n    p.y= opRep1D(p.y,12.0);\n    float d1=sdBox( p, vec3(5.0,6.0,2.0));\n    float d2a=sdBox( p-vec3(0.0,0.0,0.0), vec3(4.0,5.0,1.0));\n    float d2b=sdBox( p-vec3(0.0,0.0,-1.0), vec3(4.0,5.0,2.0));\n    float d3a= sdCylinderXY(p, vec2(4.0,3.0) );\n    float d3b= sdCylinderXY(p, vec2(1.0,8.0) );\n    \n    d1=differenceSDF(d1,d2b);\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2a,101.0));\n    res =opU2(res, vec2(d3a,100.0));\n    res =opU2(res, vec2(d3b,101.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    \n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n\n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ){ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ){ return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n   \n   if (id_color>99 &&  id_color<105)\n   { return  getColorTextura( p, nor,id_color); }\n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 200.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0+t,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(35.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n\n#define PI 3.14159265\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1)   //4\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 582, 582, 666], [672, 672, 711, 711, 806], [809, 809, 856, 856, 883], [884, 884, 927, 927, 954], [955, 955, 1003, 1003, 1031], [1032, 1032, 1068, 1068, 1113], [1115, 1115, 1149, 1149, 1245], [1246, 1246, 1280, 1280, 1371], [1372, 1372, 1406, 1406, 1497], [1499, 1499, 1524, 1524, 2111], [2113, 2113, 2137, 2137, 2299], [2301, 2301, 2349, 2349, 2655], [2657, 2657, 2701, 2701, 3019], [3021, 3021, 3058, 3058, 3315], [3317, 3317, 3407, 3407, 4423], [4425, 4425, 4474, 4474, 4601], [4603, 4603, 4696, 4696, 4826], [4828, 4828, 4860, 4860, 5057], [5059, 5059, 5129, 5129, 5328], [5330, 5330, 5357, 5357, 5446], [5448, 5448, 5506, 5506, 5554], [5556, 5556, 5579, 5579, 5691], [5693, 5693, 5724, 5724, 6353], [6355, 6355, 6412, 6412, 6878]]}
{"id": "NtXyDB", "name": "ola -Melisa-00-1", "author": "jorge2017a2", "description": "ola -Melisa -00-1", "tags": ["olamelisa001"], "likes": 1, "viewed": 155, "published": 3, "date": "1648606417", "time_retrieved": "2024-07-30T16:56:18.394412", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n// referencia\n//https://www.shadertoy.com/view/flfczs....Created by MelisaHot in 2022-03-28\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2, 1.6);\n\nfloat cosNoise( in vec2 p )\n{ return 0.4*( sin(p.x) + sin(p.y) );}\n\nfloat mapMar( in vec3 pos )\n{  float h = 0.0;\n    vec2 q = pos.xz*0.5;    \n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {   h += s*cosNoise( q ); \n        q = m2*q*0.9-iTime; \n        q += vec2(2.,5.);\n        s *= 0.5 + 0.2*h;\n    }\n h *= 2.0;\n return pos.y - h;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tp.y=p.y-5.0;\n    float m1= mapMar(p);\n    return opU2(res, vec2(m1,9.0));\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);    \n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n    \n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n  \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;       \n    return colOut;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 getColor(float c){\n   float r = cos((c-0.75)*PI);\n   float g = cos((c-0.55)*PI);\n   float b = cos((c-0.25)*PI);\n   return vec3(r,g,b);\n}\n\nvec3 render_sky_color(vec3 rd, vec2 frag)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n   float r = 0.25; \n   vec2 uv=frag;\n   float v = r/(length(uv));\n   vec3 luna= getColor(0.916)*v; \n\treturn sky*luna;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 frag)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd,frag);\n   return col;\n}\n\n//https://www.shadertoy.com/view/flfczs\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=mod(iTime*2.0,360.0);\n    float r = 0.15; \n   \n   float v = r/(length(uv));\n   vec3 luna= getColor(0.916)*v; \n    \n    float pysol=uv.y+1.0*sin(t*0.5);\n    light_pos1= vec3(-10.0, 15.0-pysol*20.0, -25.); light_color1=luna;\n \tlight_pos2= vec3(-10.0, 20.0-pysol*10.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,2.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   vec3 lp = vec3(0., -0.2, 4); // lookat point (aka camera target\n    rd=camera(ro, lp)*rd;\n   \n   float py= mapMar(ro+rd*1.0);\n   ro.y+=py+2.5;\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec2 posluna=vec2(uv.x, uv.y+0.5*sin(t*0.5));\n    vec3 col= Render( ro,  rd,posluna);\n   \n   float t1=mod(t,4.0);\n   float t2=mod(t,5.0);\n   \n   if(t1<t2) \n   {\n   float v2= r/(length(posluna));\n   vec3 colluna= getColor(0.916)*v2; \n\t//col*=luna;\n    col+=colluna;\n   }\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(.395, .95, 1.), //8\nvec3(0.425, 0.56, 0.9), //9\nvec3(0.2, 0.5, 0.8)  //10\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 596, 596, 633], [635, 635, 664, 664, 907], [909, 909, 934, 934, 1053], [1055, 1055, 1079, 1079, 1241], [1243, 1243, 1291, 1291, 1597], [1600, 1600, 1644, 1644, 1962], [1964, 1964, 2001, 2001, 2258], [2260, 2260, 2350, 2350, 3380], [3383, 3383, 3476, 3476, 3606], [3608, 3608, 3631, 3631, 3749], [3751, 3751, 3794, 3794, 4096], [4098, 4098, 4168, 4168, 4265], [4267, 4267, 4294, 4294, 4383], [4385, 4385, 4443, 4443, 4491], [4493, 4493, 4516, 4516, 4628], [4630, 4630, 4672, 4672, 5297], [5299, 5339, 5386, 5386, 5599], [5601, 5601, 5658, 5658, 6610]]}
{"id": "NtfcWB", "name": "simple bloque-01", "author": "jorge2017a2", "description": "simple bloque-01", "tags": ["simplebloque01"], "likes": 3, "viewed": 176, "published": 3, "date": "1648605232", "time_retrieved": "2024-07-30T16:56:19.649058", "image_code": "//----------image\n//por jorge2017a1-\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n/// Solucion por Shane......31-mar-2022\nvec2 GetDist(vec3 p  ) \n{\t\n    vec2 res= vec2(9999.0, -1.0);  \n    //vec3 p0=p;\n     \n    // XY plane repeat scale.\n    const vec2 sc = vec2(9, 12);\n    // Cell ID.\n    // I put the \".5\" outside the floor function, but this way \n    // matches your original.\n    vec2 ip = floor(p.xy/sc + .5);\n    p.xy -= ip*sc; // Same as the two lines below.\n    //p.x= opRep1D(p.x, 9.0);\n    //p.y= opRep1D(p.y,12.0);\n    \n    \n    float d1=sdBox( p, vec3(5.0,6.0,2.0));\n    float d2a=sdBox( p-vec3(0.0,0.0,0.0), vec3(4.0,5.0,1.0));\n    float d2b=sdBox( p-vec3(0.0,0.0,-1.0), vec3(4.0,5.0,2.0));\n    \n    float rnd = hash21(ip);\n    // Rotate local cell coordinates by random multiples of PI/2.\n    vec3 q = vec3(rot2(floor(rnd*32.)*3.14159/2.)*p.xy, p.z); \n    float d3a=sdBox( q-vec3(-1.0,0.0,0.0), vec3(1.0,2.0,3.0));\n    float d3b=sdBox( q-vec3(1.5,2.0,0.0), vec3(1.0,1.0,3.0));\n    \n    d1=differenceSDF(d1,d2b);\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2a,101.0));\n    res =opU2(res, vec2(d3a,100.0));\n    res =opU2(res, vec2(d3b,100.0));\n    return res;\n}\n\n\n/*\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec3 p0=p;\n    //p.y=p.y-7.0;\n     p.x= opRep1D(p.x, 9.0);\n    p.y= opRep1D(p.y,12.0);\n    float d1=sdBox( p, vec3(5.0,6.0,2.0));\n    float d2a=sdBox( p-vec3(0.0,0.0,0.0), vec3(4.0,5.0,1.0));\n    float d2b=sdBox( p-vec3(0.0,0.0,-1.0), vec3(4.0,5.0,2.0));\n    float d3a=sdBox( p-vec3(-1.0,0.0,0.0), vec3(1.0,2.0,3.0));\n    float d3b=sdBox( p-vec3(1.5,2.0,0.0), vec3(1.0,1.0,3.0));\n    d1=differenceSDF(d1,d2b);\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2a,101.0));\n    res =opU2(res, vec2(d3a,100.0));\n    res =opU2(res, vec2(d3b,100.0));\n    return res;\n}\n*/\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    \n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n\n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ){ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ){ return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n   \n   if (id_color>99 &&  id_color<105)\n   { return  getColorTextura( p, nor,id_color); }\n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 200.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0+t,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(35.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n\n#define PI 3.14159265\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1)   //4\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 547, 579, 579, 663], [665, 665, 712, 712, 739], [740, 740, 783, 783, 810], [811, 811, 859, 859, 887], [888, 888, 924, 924, 969], [971, 971, 1005, 1005, 1101], [1102, 1102, 1136, 1136, 1227], [1228, 1228, 1262, 1262, 1353], [1355, 1388, 1410, 1410, 1468], [1469, 1469, 1490, 1490, 1552], [1554, 1594, 1619, 1619, 2663], [3310, 3310, 3334, 3334, 3496], [3498, 3498, 3546, 3546, 3852], [3854, 3854, 3898, 3898, 4216], [4218, 4218, 4255, 4255, 4512], [4514, 4514, 4604, 4604, 5620], [5622, 5622, 5671, 5671, 5798], [5800, 5800, 5893, 5893, 6023], [6025, 6025, 6057, 6057, 6254], [6256, 6256, 6326, 6326, 6525], [6527, 6527, 6554, 6554, 6643], [6645, 6645, 6703, 6703, 6751], [6753, 6753, 6776, 6776, 6888], [6890, 6890, 6921, 6921, 7550], [7552, 7552, 7609, 7609, 8075]]}
{"id": "ftXcWB", "name": "04 change based on rectangle", "author": "ccc9527", "description": "cool", "tags": ["rectangle"], "likes": 1, "viewed": 161, "published": 3, "date": "1648602187", "time_retrieved": "2024-07-30T16:56:20.419996", "image_code": "//构造一个矩形，p为矩形中心相对屏幕中间的偏移，w和h是宽和高，blur是边界的模糊度\nvec3 Rectangle(vec2 uv,vec2 p,float w,float h,float blur)\n{\n    uv -= p;\n    //uv.x += 0.2*uv.y;//平行四边形效果\n    //w -= uv.y*0.2;   //梯形效果\n    //弯曲效果\n    float m = sin(iTime+uv.x*8.0)*0.1;\n    uv.y -= m;//\n    vec3 c1 = vec3(smoothstep(w+blur,w-blur,uv.x));\n    vec3 c2 = vec3(smoothstep(-w-blur,-w+blur,uv.x));\n    vec3 c3 = vec3(smoothstep(h+blur,h-blur,uv.y));\n    vec3 c4 = vec3(smoothstep(-h-blur,-h+blur,uv.y));\n    return c1*c2*c3*c4;\n}\n//求出t在(a,b)范围内出比例\nfloat Remap01(float a,float b,float t)\n{\n    return (t-a)/(b-a);\n}\n//求(a,b)范围的t映射到(c,d)之后的结果\nfloat Remap(float a,float b,float c,float d,float t)\n{\n    return c+(d-c)*Remap01(a,b,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float blur = Remap(-0.5,0.5,0.01,0.2,uv.x);//(-0.5,0.5)是图形的x取值范围\n    blur = pow(blur,2.0);\n    col = Rectangle(uv,vec2(0.0),0.5,0.1,blur);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 174, 174, 585], [586, 622, 662, 662, 688], [689, 739, 793, 793, 830], [832, 832, 889, 889, 1177]]}
{"id": "flfcDS", "name": "Fixed my voronoi", "author": "Veggiebob", "description": "finally added the third point consideration", "tags": ["voronoi"], "likes": 2, "viewed": 296, "published": 3, "date": "1648595325", "time_retrieved": "2024-07-30T16:56:21.932951", "image_code": "\n//credit to iq for noise\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvec3 proj (vec3 a, vec3 b) {\n    return dot(a, b) * b / dot(b, b);\n}\nfloat comp (vec3 a, vec3 b) {\n    return dot(a, b) / length(b);\n}\nfloat comp2 (vec2 a, vec2 b) {\n    return comp(vec3(a.xy, 0.), vec3(b.xy, 0.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 mouse = vec2(0.5);\n    uv.x*=aspect;\n    const int numPoints = 25;\n    float[numPoints] pointsx = float[numPoints](\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.);\n    float[numPoints] pointsy = pointsx;\n    float d = 100000.;\n    float ld = d;\n    float nld = d;\n    vec2 n_last_point = vec2(0.);\n    vec2 last_point = vec2(0.);\n    vec2 point = vec2(0.);\n    for(int i = 0; i<numPoints; i++){\n        float j = float(i);\n        pointsx[i] = snoise(vec2(iTime*0.01+j))+mouse.x*aspect;\n        pointsy[i] = snoise(vec2(iTime*0.01+j+1.))+mouse.y;\n        vec2 r = vec2(pointsx[i], pointsy[i]);\n        float dist = length(r-uv);\n        if(dist<d){\n            nld = ld;\n            n_last_point = last_point;\n            ld = d;\n            last_point = point;\n            d = dist;\n            point = r;\n        } else if (dist<ld){\n            nld = ld;\n            n_last_point = last_point;\n            ld = dist;\n            last_point = r;\n        } else if (dist < nld) {\n            nld = dist;\n            n_last_point = r;\n        }\n    }\n    //one thing to take advantage of is the fact that each line separating points is equal in length\n    float max_dist = length(point - last_point) / 2.;\n    float max_dist2 = length(point - n_last_point) / 2.;\n    float dist = comp2(uv - point, last_point - point); // project vector from nearest onto height-space vector\n    float dist2 = comp2(uv - point, n_last_point - point);\n    float h = abs(dist - max_dist);\n    float h2 = abs(dist2 - max_dist2);\n    float hp = h / max_dist;\n    float hp2 = h2 / max_dist2;\n    h = min(h, h2);\n    float lines = 30.;\n    vec3 mod_color = vec3(abs(mod(h, 1./lines)*lines-0.5));\n    vec3 line_color = smoothstep(0.02, 0.00, h) * vec3(0., 0., 1.);\n    vec3 col = max(mod_color, line_color); // just the line: smoothstep(0.01, 0.02, h)\n    \n    //col = mix(vec3(1.), col, smoothstep(0.01, 0.02, length(uv-point)));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 26, 47, 47, 96], [98, 98, 119, 119, 168], [170, 170, 192, 192, 229], [230, 230, 254, 254, 1760], [1761, 1761, 1789, 1789, 1829], [1830, 1830, 1859, 1859, 1895], [1896, 1896, 1926, 1926, 1977]]}
{"id": "7tlyRs", "name": "bisexual raymarching", "author": "ufffd", "description": "smooth blobby blobs with bisexual lighting, we'll see where it goes", "tags": ["blobs", "raymarch"], "likes": 4, "viewed": 197, "published": 3, "date": "1648581678", "time_retrieved": "2024-07-30T16:56:22.929288", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv = fragCoord.xy / iResolution.xy;\n        \n    vec3 col_a = texture(iChannel0,uv).rgb;\n    vec3 col_b = texture(iChannel1,uv).rgb; // twinkle feedback\n    \n    vec3 col = col_a+col_b;\n    \n    // return col\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define SHORTSTEP 6\n#define ORBS 12\n#define ORBSIZE 0.3\n#define ANIMSPEED .5\n#define ORBSPREAD .7\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat map(in vec3 p, in float sizer, in float smoother) {\n    float time = iTime*ANIMSPEED;\n    float sphere_d = length(p)-.1*sin(p.y+time*3.)*sizer-.4*sizer;\n    float step_d = sphere_d;\n    for (int j=1;j<ORBS;j++){\n        vec3 sphere_p1 = vec3(\n            sin(time+float(j)),\n            cos(time*0.333*float(j)),\n            cos(time*3.+float(j))\n        );\n        vec3 sphere_p2 = vec3(\n            sin(time*2.+float(j))*0.6+sin(time*.5+float(j))*0.6,\n            sin(time*0.03*float(j)*float(j)),\n            sin(time*1.5+float(j))            \n        );\n        vec3 sphere_p3 = vec3(\n            sin(time*1.+float(j))*sin(time*1.+float(j))*sin(time*1.+float(j)),\n            cos(time*1.+float(j))*cos(time*1.+float(j))*cos(time*1.+float(j)),\n            sin(time*3.+float(j))+sin(time*.5+float(j))*0.6            \n        );\n        float pattern_mix = noise(vec2(iTime*0.1,float(j)));\n        float pattern_mix2 = noise(vec2(iTime*0.1,-float(j)));\n        vec3 sphere_p = mix(sphere_p1,sphere_p2,pattern_mix);\n        sphere_p = mix(sphere_p,sphere_p3,pattern_mix2);\n        sphere_p *= 1.7 - (abs(pattern_mix-.5)-abs(pattern_mix2-0.5))*0.7;\n        sphere_d = length(p - ORBSPREAD*sphere_p)-ORBSIZE*sizer;\n        step_d = smin(step_d, sphere_d, smoother*rand(vec2(float(j))));\n    }\n    return step_d;\n}\n\nfloat map(in vec3 p) {\n    return map(p, 1., 1.);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.01,0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec3 RayPlane(in vec3 ro, in vec3 rd, in vec3 p, in vec3 n) {\n    float t = max(0., dot(p-ro,n)/dot(rd,n));\n    return ro + rd*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv *= 1.5;    \n    \n    vec3 ro = vec3(0.,0.,-10.);\n    vec3 rd = normalize(vec3(uv,8.));\n    \n    float d,smooth_d = 0.;\n    bool hit,smooth_hit = false;\n    vec3 p,smooth_p = vec3(0.);\n    int steps = 0;\n    float glow = 0.;\n    for(int i=0;i<60;i++){\n        steps++;\n        p = ro + d*rd;\n        float step_d = map(p);\n        d += step_d;\n        if (i==SHORTSTEP) { smooth_d = d; smooth_p = p; }\n        if (step_d < 0.01) hit=true;\n        if (i==SHORTSTEP && step_d < 0.001) smooth_hit=true;\n        if (i>SHORTSTEP && (step_d < 0.001 || d > 60.)) break;\n        if (d < 20.) glow += 1./(step_d+.5);\n    }\n    vec3 col = vec3(d * smooth_d * 0.001);\n    \n    vec3 smooth_norm = getNormal(smooth_p);\n    vec3 norm = getNormal(p);\n    \n    col.r = 2. - length(p)*1.5;\n    \n    if (!hit) col = vec3(glow*glow*0.0001);\n    if (hit) col = mix(vec3(glow*0.1),col,0.8);\n    \n    float rays, ray_d = 0.;\n    vec3 pp = RayPlane(ro, normalize(vec3(uv,9.)), vec3(0), normalize(ro));\n    float step_d = map(normalize(pp));\n    ray_d += step_d;\n    \n    rays = ray_d;\n    rays = smoothstep(.0,.05 + length(uv),rays) * .7;\n    rays *= smoothstep(0.,.5,length(uv));    \n    rays += smoothstep(0.5,1.,1.0 - length(uv)) * .3;\n    \n    if (!hit) col.b += .01;\n    if (!hit) col.b *= 1.2;\n    vec3 lightcol = mix(vec3(1.,.1,.1),vec3(.1,.1,.3),pow(1.0-rays,5.));\n    if (!hit || hit && d < 2.) col += vec3(pow(rays,1.1)) * lightcol;\n    if (hit) col.b *= 0.3;\n    if (hit) col.g *= 0.1;\n    \n    if (hit) col += vec3(clamp(1.-dot(-norm,rd),0.,1.))*.5*lightcol;\n    \n    col = pow(col, vec3(.4545)); // gamma\n    \n    if (hit) col.gb += vec2(map(p,.05,.1));\n    \n    // return col\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= 0.5;\n    uv *= 0.995;\n    uv += 0.5;\n    \n    vec3 col = texture(iChannel0,uv).rgb;\n    float brightness = (col.r+col.g+col.b)/3.;\n    \n    vec3 blur = vec3(0.);\n    \n    vec2 px = 1./iResolution.xy;\n    \n    float n = noise(uv*10. + iTime*1.);\n    vec2 np = vec2(0.);\n    float b = 0.;\n    \n    if (brightness < 1.)\n    for (float i=1.;i<6.5;i+=2.1) {\n        // tl\n        np = vec2(-i,-i);\n        np *= Rot(iTime);\n        vec3 tl = texture(iChannel0,uv+px*np).rgb*n;\n        b = (tl.r+tl.g+tl.b)/3.;\n        if (b>1.2) blur += tl;\n        // tr\n        np = vec2(i,-i);\n        np *= Rot(iTime);\n        vec3 tr = texture(iChannel0,uv+px*np).rgb*n;\n        b = (tr.r+tr.g+tr.b)/3.;\n        if (b>1.2) blur += tr;\n        // br\n        np = vec2(-i,i);\n        np *= Rot(iTime);\n        vec3 br = texture(iChannel0,uv+px*np).rgb*n;\n        b = (br.r+br.g+br.b)/3.;\n        if (b>1.2) blur += br;\n        // bl\n        np = vec2(i,-i);\n        np *= Rot(iTime);\n        vec3 bl = texture(iChannel0,uv+px*np).rgb*n;\n        b = (bl.r+bl.g+bl.b)/3.;\n        if (b>1.2) blur += bl;\n    }\n    \n    col = min(col,vec3(1.));\n    \n    col = mix(col,blur,0.95);\n    \n    vec3 lastpass = texture(iChannel1,uv).rgb;\n    \n    col = mix(col,lastpass,1.-col.b);\n    \n    col = vec3(min(col.b,1.0));\n    col *= vec3(2.,0.95,0.95);\n    // col = vec3(n);\n    // return col\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 422]]}
{"id": "flXczf", "name": "03 First", "author": "ccc9527", "description": "smiley，笑脸", "tags": ["smiley"], "likes": 0, "viewed": 189, "published": 3, "date": "1648570270", "time_retrieved": "2024-07-30T16:56:23.907671", "image_code": "//绘制圆的函数，p是圆心相对于中心点的偏移，r是半径，blur是圆边缘模糊的宽度\nfloat Circle(vec2 uv,vec2 p,float r,float blur)\n{\n    uv -= p;\n    float d = length(uv);\n    float c = smoothstep(r,r-blur,d);\n    return c;\n}\n//绘制笑脸函数(由绘制圆函数组成)，p是笑脸的位移，size控制笑脸的大小\nfloat smiley(vec2 uv,vec2 p,float size)\n{\n    uv -= p;\n    uv /= size;\n    \n    float mask = Circle(uv,vec2(0.0),0.4,0.03);//最大圆\n    mask -= Circle(uv,vec2(0.13,0.2),0.07,0.01);//眼睛\n    mask -= Circle(uv,vec2(-0.13,0.2),0.07,0.01);\n    float mouse = Circle(uv,vec2(0.0),0.3,0.02) - Circle(uv,vec2(0.0,0.1),0.3,0.02);//嘴巴\n    mask -= mouse;\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    vec2 offset = vec2(0.7*sin(iTime),0.3*cos(iTime));\n    float size = abs(sin(iTime))+0.2;\n    float mask = smiley(uv,offset,size);\n    \n    col = vec3(1.0,1.0,0.0)*mask;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 157, 157, 250], [251, 348, 389, 389, 725], [727, 727, 784, 784, 1081]]}
{"id": "slsyRl", "name": "Logo Smash Bros V2", "author": "Karp", "description": "Improving my first Shader", "tags": ["2d", "smash"], "likes": 2, "viewed": 123, "published": 3, "date": "1648567710", "time_retrieved": "2024-07-30T16:56:24.671629", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //Color\n    vec3 bgColor = vec3(0.95);\n    vec3 logoColor = vec3(0.05);\n    \n    //AspectRatioUV\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n\tuv = 2.0 * uv.xy / iResolution.y;\n    \n    //Rotation\n    float angle = sin(iTime) * 0.02 *PI;\n    uv *= mat2(cos(angle), sin(angle),-sin(angle),cos(angle));\n    //Height Offset\n    uv.y += cos(iTime)*0.05;\n    \n\tvec3 pixel = bgColor;\n    \n    float circle = length(uv-vec2(0.0));\n    float horiLine = abs(uv.x + 0.28);\n    float vertLine = abs(uv.y + 0.32);\n    \n    pixel = mix(logoColor, pixel, clamp(((circle-0.8) * 100.0),0.0,1.0));\n    pixel = mix(bgColor  , pixel, clamp((horiLine -0.13) *100.0,0.0,1.0));\n    pixel = mix(bgColor  , pixel, clamp((vertLine-0.08) *100.0,0.0,1.0));\n\n    //EndResult\n    float alpha = 1.0;\n\tfragColor = vec4(pixel, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 96, 899]]}
{"id": "Ntsczs", "name": "cilindros-mas", "author": "jorge2017a2", "description": "cilindros-mas", "tags": ["cilindrosmas"], "likes": 11, "viewed": 223, "published": 3, "date": "1648566156", "time_retrieved": "2024-07-30T16:56:25.425614", "image_code": "//----------image\n//por jorge2017a2-\n//cilindro mas--29-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 base01(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    float d1a= sdCylinderYZ(p, vec2(2.0,18.0) );  //cilindro principal\n    float d1b= sdCylinderYZ(p-vec3( 10.0,0.0,0.0), vec2(3.0,1.0) ); ///anillo 1\n    float d1c= sdCylinderYZ(p-vec3(-10.0,0.0,0.0), vec2(3.0,1.0) ); ///anillo 2 \n    p.z=abs(p.z)-2.0;\n    float d1d= sdCylinderYZ(p-vec3(0.0,0.0,0.0), vec2(0.3,18.0) );\n    res =opU2(res, vec2(d1a,100.0));\n    res =opU2(res, vec2(d1b,100.0));\n    res =opU2(res, vec2(d1c,100.0));\n    res =opU2(res, vec2(d1d,101.0));\n    return res;\n}   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    p.y=p.y-5.0;\n    p.x= opRep1D(p.x,30.0);\n    p.y= opRep1D(p.y,30.0);\n    p.z= opRep1D(p.z,30.0);\n    \n    p.z=abs(p.z)-4.0;\n    vec2 b1= base01(p);\n    res =opU2(res, b1);\n    \n    p=rotate_z(p, radians(90.0));\n    vec2 b2= base01(p);\n    res =opU2(res, b2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n    \n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n     // back\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\n//https://www.shadertoy.com/view/WdsGR7\nvec3 getColor(float v)\n{  float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    {\n        vec3 col;\n        if( opRep1D(p.z,60.0)>15.0) \n         col=tex3D(iChannel0, p/32., nor)* getColor(0.78);\n        else\n         col=tex3D(iChannel0, p/32., nor);\n         \n        return col*2.0; \n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor)*vec3(0.5,1.0,0.5); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n            \n    if (id_color==100 )\n   { return  getColorTextura( p, nor,100); }\n   \n   if (id_color==101 )\n   { return  getColorTextura( p, nor,101); }\n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(5.0+t,7.0+t*0.5,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   //rd= rotate_x(rd, radians(25.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n//#define PI 3.14159265358979323846264\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\n\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntsczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[526, 526, 562, 562, 583], [584, 584, 623, 623, 718], [719, 719, 758, 758, 853], [854, 854, 893, 893, 988], [990, 990, 1026, 1026, 1071], [1073, 1073, 1107, 1107, 1203], [1204, 1204, 1238, 1238, 1329], [1330, 1330, 1364, 1364, 1455], [1458, 1458, 1479, 1479, 1998], [2003, 2003, 2028, 2028, 2392], [2394, 2394, 2418, 2418, 2580], [2582, 2582, 2630, 2630, 2936], [2938, 2938, 2982, 2982, 3300], [3302, 3302, 3339, 3339, 3596], [3599, 3599, 3689, 3689, 4713], [4715, 4755, 4779, 4779, 4911], [4914, 4914, 4963, 4963, 5268], [5270, 5270, 5363, 5363, 5493], [5495, 5495, 5527, 5527, 5724], [5726, 5774, 5802, 5802, 5990], [5992, 5992, 6062, 6062, 6324], [6326, 6326, 6353, 6353, 6442], [6444, 6444, 6502, 6502, 6550], [6552, 6552, 6575, 6575, 6687], [6689, 6689, 6720, 6720, 7349], [7351, 7351, 7408, 7408, 7881]]}
{"id": "fllczs", "name": "distorted grid", "author": "oatmealine", "description": "a bit laggy; i don't know of a more efficient implementation than what i'm doing unfortunately", "tags": ["2d", "noise", "grid", "simplex"], "likes": 7, "viewed": 457, "published": 3, "date": "1648563745", "time_retrieved": "2024-07-30T16:56:26.373080", "image_code": "#define GRID_COLOR vec3(0.45, 0.01, 0.7)\n#define BG_COLOR vec3(0.07, 0.05, 0.08)\n#define RES_X 256.0\n#define RES_Y ((RES_X/iResolution.x)*iResolution.y)\n#define GRID_SIZE 20.0\n#define XSPEED 0.1\n#define YSPEED 0.05\n#define NOISESPEED 1.2\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 0.8 / RES_X; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nvec2 gridpos(int x, int y, float o) {\n    float fracx = 1.0 / (RES_X/GRID_SIZE);\n    float fracy = 1.0 / (RES_Y/GRID_SIZE);\n\n    vec2 offset = vec2(\n        snoise(vec3(float(x) - floor((iTime * XSPEED) / fracx), float(y) - floor((iTime * YSPEED) / fracy), iTime * NOISESPEED)),\n        snoise(vec3(float(x) - floor((iTime * XSPEED) / fracx), float(y) - floor((iTime * YSPEED) / fracy), -iTime * NOISESPEED))\n    );\n    return vec2(\n        float(x) / (RES_X/GRID_SIZE) + mod(iTime * XSPEED, fracx),\n        float(y) / (RES_Y/GRID_SIZE) + mod(iTime * YSPEED, fracy)\n    ) + offset * o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = vec2(floor(uv.x * RES_X) / RES_X, floor(uv.y * RES_Y) / RES_Y);\n    \n    float amp = (sin(iTime) * 0.5 + 0.5) * 0.2;\n    float line = 0.0;\n    \n    vec2 lowerBound = uv - vec2(amp * 1.1, amp * 1.1);\n    vec2 higherBound = uv + vec2(amp * 1.1, amp * 1.1);\n    \n    int width = int(RES_X/GRID_SIZE);\n    int height = int(RES_Y/GRID_SIZE);\n    \n    \n    \n    for (int x = int(lowerBound.x * float(width)) - 1; x <= int(higherBound.x * float(width)) + 1; x++) {\n        for (int y = int(lowerBound.y * float(height)) - 1; y <= int(higherBound.y * float(height)) + 1; y++) {\n            line += max(drawLine(gridpos(x, y, amp), gridpos(x + 1, y, amp), uv, 1.), 0.0);\n            line += max(drawLine(gridpos(x, y, amp), gridpos(x, y + 1, amp), uv, 1.), 0.0);\n            if (line >= 1.0) break;\n        }\n    }\n    \n    vec3 col = mix(BG_COLOR, GRID_COLOR, min(line, 1.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 293, 314, 314, 351], [352, 352, 379, 379, 427], [429, 429, 450, 450, 2286], [2288, 2288, 2341, 2341, 2746], [2748, 2748, 2785, 2785, 3335], [3337, 3337, 3394, 3394, 4351]]}
{"id": "fllyRs", "name": "undead tunnel2", "author": "cxm", "description": "nothing description", "tags": ["fbm", "cineshader"], "likes": 8, "viewed": 3253, "published": 3, "date": "1648556977", "time_retrieved": "2024-07-30T16:56:27.171944", "image_code": "mat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n    return sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvoid drawCircle( inout float d, in vec2 uv, in vec2 pos, float r ){\n    float g = smoothstep( .0, r + .01, length( uv - pos ) );\n    \n    d = mix(\n        d,\n        1.,\n        g\n    );\n    \n    d = mix(\n        d,\n        2.,\n        smoothstep( r + .05, .0, length( uv - pos ) )\n    );\n    \n}\n\n// pulse\nfloat Pulse2Pixel( in vec2 uv, vec2 pos, float rot, float size, float idx ){\n    float b = 0.;\n    vec2 bUv = uv;\n    uv -= pos;\n    uv *= _rot1( rot );\n    uv += pos;\n    \n    uv = fbm4_2( uv + fbm4_2( uv +fbm4_2( uv - rot ) ) );\n    b = cos( uv.x ) * sin( uv.y );\n    // b = noise( uv ) + cos( uv.x ) * sin( uv.y ) * .3;\n    \n\n    b *= 1. - smoothstep(.0, size, length( bUv - pos ) );\n    \n    b = mix(\n        b, \n        0.,\n        1. - smoothstep(.0, size * .6, length( bUv - pos ) )\n    );\n    \n    // pulse overlay\n    b = mix(\n        b, \n        uv.x * .2,\n        1. - smoothstep(.0, size, length( bUv - pos ) )\n    );\n    \n    return b;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n    vec2 center = vec2( .5 );\n    \n    float d = 1.;\n    vec3 col;\n    \n    \n    float t = fract( iTime * .5 );\n\n    \n    for( float i = 0.; i < 5.; i++ ){\n    \n        t = fract( iTime * .5 - .25 * i );\n        \n    \n        uv -= .5;\n        uv *= _rot1( iTime * .3 ); \n        uv += .5;\n\n        d = Pulse2Pixel( uv, ( center ) * 2. - .5, t, t, 0. );\n\n        col = mix(\n            col,\n            vec3( 3. - 3. * ( t ) ),\n            d\n        );\n        \n\n    \n    }\n    \n    d = col.x;\n    \n    uv -= .5;\n    uv *= _rot1( iTime );\n    uv += .5;\n    \n    uv *= 3.;\n\n    uv = fbm4_2(uv+d+fbm4_2(uv+d+fbm4_2(uv + d - iTime)) + fbm4_2( uv + d - iTime ) + d);\n\n    // Time varying pixel color\n    col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= 5.;\n    // col = vec3( d );\n    col *= d;\n    \n \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 80], [133, 133, 159, 159, 191], [193, 193, 215, 215, 411], [413, 413, 436, 436, 483], [485, 485, 552, 552, 780], [782, 791, 867, 867, 1441], [1444, 1444, 1501, 1551, 2529]]}
{"id": "7tXyRl", "name": "WIP checkerboard", "author": "jakel101", "description": "trying to understand shaders a bit at a time", "tags": ["2d", "pattern"], "likes": 2, "viewed": 199, "published": 3, "date": "1648509925", "time_retrieved": "2024-07-30T16:56:28.024664", "image_code": "#define PI 3.14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 white = vec3(1.,1.,1.);\n    \n    vec3 col = .5 * white;\n    \n    float x = floor(sin(8.0 * PI * uv.x));\n    float y = floor(sin(8.0 * PI * uv.y));\n    \n    col += (x);\n    col -= y;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 124, 450]]}
{"id": "NtXczs", "name": "Dot Damme", "author": "rabbitator", "description": "I like dots, points and also spots", "tags": ["dots", "points", "newspaper"], "likes": 4, "viewed": 235, "published": 3, "date": "1648505730", "time_retrieved": "2024-07-30T16:56:28.818541", "image_code": "// Free for any purposes (that are not evil), forever\n\n#define R 120.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    vec2 s = vec2(R, R/(iResolution.x/iResolution.y));\n    \n    vec2 cell = ceil(uv*s)*(1.0/s);\n    vec3 col = texture(iChannel0, cell).rgb;\n    \n    float v = pow((3.0 - (col.r + col.b + col.g)) * 0.21, 1.5);\n    float c = smoothstep(v-0.02, v, length(fract(uv * s)-0.5)) * 0.8;\n    col = vec3(c, c, c * 0.9);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 547]]}
{"id": "stsyzX", "name": "Day 830", "author": "jeyko", "description": "wait for the bass", "tags": ["sound", "music", "mdtmjvm"], "likes": 20, "viewed": 597, "published": 3, "date": "1648496969", "time_retrieved": "2024-07-30T16:56:29.855769", "image_code": "// Fork of \"Day 829\" by jeyko. https://shadertoy.com/view/slscz2\n// 2022-03-28 08:05:06\n\n// Fork of \"Day 828\" by jeyko. https://shadertoy.com/view/7lfyRj\n// 2022-03-27 08:18:54\n\n// so\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat message(vec2 uv) { // to alter in the icon\n    \n    //uv.y += sin(acos(-1.)*iTime/beat + sin(acos(-1.)*iTime/beat*2.)*float(iTime > msr*2.));\n    \n    uv-=vec2(1.,10.); \n    uv -= vec2(16.,1.5);\n    //uv *= 0.5;\n    //uv.xy *= rot(sin(acos(-1.)*iTime/beat*0.5)*0.1*mod(iTime/beat,2.));\n    \n    uv += cyclicNoise(vec3(uv*0.2,iTime + sin(iTime)));\n        \n    uv += vec2(16.,1.5);\n    if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\t//tGlobal = iTime*2.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n    /*\n    if(iTime > msr*6.)\n        fragColor = 0.5 + 0.5*sin(fragColor + iTime);\n    */\n}   ", "image_inputs": [], "sound_code": "\nfloat gt;\n\n\nFN(kick,\n    vec4 chord = getChord(t);\n    \n    float repd = bar*2.;\n    float reps = 16.;\n    \n    Time T = rep(t,bar*2.,reps);\n    \n    bool kick = getPatt(T,kickPatt) > 0.5;\n    bool kickNext = getPattOffs(T,kickPatt,reps,1.) == 0.5;\n    \n    if(!kick)\n        return vec2(0); \n    \n    //T.te = t;\n    //float env = exp(-T.te*14.);\n    \n    //float freq = note(chord[0],2.)*(1.  );\n    float freq = 40.;\n    float parm = freq*T.tt*tau;\n    \n    if(kick)\n        parm -= exp(-T.te*30.)*64.;\n    \n    \n    vec2 n = lpnoise(T.tt,10. + freq*4.*tau);\n    \n    vec2 osc = sin(parm + 0.*vec2(sin(0.1 + t*2.),sin(0.6 + t*2.5)) + sin(1200.*T.te)*exp(-T.te*40.)*0.*float(kick)\n    );\n    \n    \n    osc = ringmod(osc,(4200. + sin(T.idl)*2000.)*t*tau,1.,0.4*exp(-T.te*120.));\n    \n    s += osc + n*0.01;\n    \n    if(kick) s *= smoothstep(0.,0.001,T.te);\n    \n    s = smoothify(s,1.,0.2);\n    s = smoothify(s,1.,0.5);\n    s = smoothify(s,1.5,0.1);\n    \n    if(kickNext)\n        s *= 1.-smoothstep(0.9,0.99,T.te/repd*16.);\n    s *= exp(-T.te*5.);\n    \n    //s = smoothify(s*1.,0.2);\n    //s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    \n)\n\nFN(snare,\n    \n    Time T;\n\n    T = rep(t + bar*0.25,bar,1.);\n    //T.te = t;\n    float env = exp(-T.te*40.);\n    float freq = 450. ;\n    \n    float osc = sin(tau*freq*T.te + ((freq - 1.4*exp(-T.te*10.))*t*0.1 )  + 0.4*sin(T.te*800.)*exp(-T.te*4.));\n    \n    float oscb = sin(2.5*tau*freq*T.te + sin(4000.*T.te )*exp(-T.te*4.)*0.4 )*exp(-T.te*14.);\n    \n    float oscc = sin((93000.*exp(-T.te*20.)+ 11000.)*T.te + sin(17000.*T.te )*exp(-T.te*40.)*41.*0. )*exp(-T.te*30.);\n    \n    s += osc*env + oscb*0.5 + oscc*0.2;\n    \n    s = ringmod(s,11400.*T.te,1.4,0.2*exp(-T.te*14.));\n    \n    //s += lpnoise(T.te, 300.*(0.04 + exp(-T.te*39.4)))*0.4*exp(-T.te*1.)*pow(env,0.5);\n    s += lpnoise(T.te, 4.*21300.)*0.4*exp(-T.te*13.)*pow(env,0.2);\n    \n    s += lpnoise(T.te, 21300.)*0.2*exp(-T.te*1.)*pow(env,0.5);\n    \n    //s = mix(s,s*sin(t*(15700. )),0.7*exp(-T.te*115.));\n    s = smoothify(s,1.,0.1);\n    s = powify(s,0.9);\n)\n\nFN(hats,\n    Time T = rep(t,bar,16.);\n    \n    vec2 r = hash21(T.idl);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*12.));\n    float freq = 400. + 0. * exp(-T.te*104.) ;\n    vec2 n = lpnoise(T.te, 1140.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    //vec2 n = cyclicNoise(vec3(T.te*11711.))*vec2(3.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        5.*sin(T.te*50000.)*exp(-T.te*10.) + \n        4.*sin(T.te*20000.*0.75 - n*1.)*exp(-T.te*10.) + \n        n * 14.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.1,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n)\n\nFN(rides ,{\n    Time T = rep(t,bar,8.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*0.)*exp(-T.te*1.) + \n        n * (1.-exp(-T.te*10.))*60.\n    );\n    \n    s += osc*env*0.6*smoothstep(0.,0.4,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n\n})\n\n\n\nFN(chord,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    for(float i = 0.; i < 4.; i++){\n        \n        float iters = 65.;\n        float range = 17.;\n        for(float k = 1.; k < iters; k++){\n            float freq = note(chord[int(i)],3. + 1.*float(i == 1.));\n            if(freq < 200.)\n                freq *= 2.;\n                \n            float att = 1.;\n            \n            float localIter = ceil(k/iters*range);\n            att *= mix(1.,0.,k/iters);\n            att = pow(att,2.);\n            //att /= pow(2.*k-1.,2.);\n                        \n            vec2 r = lpnoise(k*111.5 + i*112.525, 1.1);\n            \n            if(localIter > 1.){\n                if(r.x < 0.1 )\n                    freq = freq*(2.*localIter - 1.);\n                else if(r.x < 0.8 )\n                    freq = freq*localIter;\n                else\n                    freq = freq*pow(2.,localIter);\n            }\n            \n            //freq = freq*pow(2.,k);\n            //if(k >= 10.)\n            //    freq *=2.;\n           // if(mod(k,4.) == 4.)\n           //     freq *= 2.;\n            \n            vec2 n = lpnoise(t*.0*0. + k*1.5 + i*2.525, 1.1);\n            n = vec2(sin(n.x*20. + t*.5),sin(n.t*20. + t*.5));\n            \n            float polarity = (mod(k + i,2.)*2. - 1.);\n            vec2 osc = sin( \n                (freq+ freq*n*0.0004*1.+ .1*sin(k + t*0.1 *sin(k)))*t*tau )*polarity; \n            \n            //osc = tri(t,freq + n.x*0.1*1.,3.);\n            s += osc/7./iters*att * (1. + 0.5*cos(localIter*150.+ t*4.));\n        }\n        \n    }\n    s *= 2.;\n})\n\n\nFN(chordSupersaw,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],3.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*10.3 + t*3.)*2.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.4;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.);\n            \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*1.;\n        }\n    }\n    \n    s *= smoothstep(0.,0.01,T.te);\n    s *= smoothstep(bar/8.,bar/8. - 0.05,T.te);\n\n})\n\n\nFN(dubstep,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1.);\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.8 + t*3.)*0.3;\n        \n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.45;\n        vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n        osc = mix(osc,vec2(sin(idx)),0.5); \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*2.;\n    }\n    \n    //s = mix(s,clampifyb(s*1.,1.),0.2);\n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,2.),1. );\n})\n\nconst int mldCnt = 11;\nvec2[] mldArr = vec2[mldCnt](\n    vec2(0,0),\n    vec2(6,3),\n    vec2(4,10),\n    vec2(9,7),\n    vec2(15,8),\n    vec2(0,12),\n    vec2(16,15),\n    vec2(20,14 + 12),\n    vec2(25,22),\n    vec2(30,20),\n    vec2(34,19)\n);\n/*\nstruct Melody{\n    int mldCnt;\n    vec2[] mld;\n}*/\n\n\n\n#define createMelody(name,cnt, len) \\\nvec3[] name = vec3[cnt+1]( \\\n    vec3(cnt,len,0), \n\n#define getMelodyAt(name,at) name[int(at) + 1]\n#define getMelodyNoteCnt(name) name[0].x\n#define getMelodyLen(name) name[0].y\n\n#define playMelody(mld,cb) for(float i=0.;i<getMelodyNoteCnt(mld);i++){ vec3 nt = getMelodyAt(mld,i); if(nt.x < 0.){continue;} cb;} \n\ncreateMelody(bassMelody,9, 32.)\n    vec3(-1,0,1), \n    vec3(3,3,1), \n    vec3(5,-2,1),\n    vec3(8,-5-4,1), \n    vec3(14,-5-4,1), \n    vec3(16,-5-4,1),\n    vec3(19,-5-4,0.5),\n    vec3(-1),\n    vec3(-1)\n);\n\n\nFN(bass,{\n    float period = bar*4.;\n    float reps = getMelodyLen(bassMelody);\n    Time T = rep(t,period,reps);\n    \n    playMelody(bassMelody, {\n        float freq = note(nt.y,2.);\n        float tn = mod(t - nt.x*period/reps,period);\n        \n        vec2 no = lpnoise(t*0. + i,1.);\n        vec2 nob = lpnoise(t + i,111.);\n        //nob += lpnoise(t + i,1111.)*0.2;\n        //nob += lpnoise(t + i,161.)*0.4;\n        //nob += lpnoise(t + i,11111.)*0.5*(1.-exp(-tn*4.));\n        nob *= 0.;\n        float namp = 0.6;\n        \n        loop(14.,k,{\n            float f = 51.*(k*1.5 + 1.);\n            nob += lpnoise(t + i + k,f)*namp;\n            namp /= 1.1;\n        })\n        vec2 osc = sin(tn*tau*freq + no*.0);\n        //vec2 osc = tri(tn,freq,115.);\n        //osc = ringmod(osc,nob,1.,0.5*(1.-exp(-tn*4.)));\n        \n        //osc = ringmod(osc,freq*2.5*t*tau,4.,0.1*exp(-tn));\n        osc = 0.8*ringmod(osc,freq*4.*t*tau,2.,0.1*exp(-tn));\n        osc = ringmod(osc,freq*9.*t*tau,2.,0.1*exp(-tn));\n        \n        float env = exp(-tn*2.*nt.z);\n        \n        vec2 n = lpnoise(T.tt,10. + freq*16.*tau);\n        osc += n*0.02;\n        s += osc*env*0.5;\n    })\n    \n    s = smoothify(s, 4., 0.1);\n    //s = smoothify(s, 1., 0.5);\n\n\n/*\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],2. + 0.*float(mod(T.idl,3.) == 0.));\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    \n    float f = 0.05 + 0.75 * exp(-T.te*(10. + sin(t*tau/beat*0.25)* 25.));// * sin(t*freq*0.5);\n\n    f = 0.1;\n    float wiggle = 0.05;\n    float q = 0.;\n    \n    \n    s += squelchyBass(t, freq, f, q, wiggle, 10.);\n  */  \n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,1.),0.2 );\n    //s = mix(s,clampify(s*1.,1.),1.);\n\n})\n\n\n\nFN(melody,{\n\n    float period = bar*4.;\n    \n    float reps = 64.;\n    \n    Time T = rep(t,period,64.);\n    \n    for(float i = 0.; i < float(mldCnt); i++){\n        vec2 nt = mldArr[int(i)];\n        if(nt.x < 0.)\n            continue;\n        float freq = note(nt.y,3.) + sin(i*4.+t)*.1;\n        float tn = mod(t - nt.x*period/reps,period);\n        \n        vec2 no = lpnoise(t + i,1.);\n        vec2 nob = vec2(0);\n        \n        float namp = 0.6;\n        \n        loop(14.,k,{\n            float f = 51.*(k*1.5 + 1.);\n            nob += lpnoise(t + i + k,f)*namp;\n            namp /= 1.1;\n        })\n        //nob += lpnoise(t + i,11111.)*0.5*(1.-exp(-tn*4.));\n        \n        \n        vec2 osc = sin(tn*tau*freq + no*1.);\n        //vec2 osc = tri(tn,freq,115.);\n        \n        //osc = ringmod(osc,nob,1.,0.9*(1. - smoothstep(0.,1.,tn*5.)));\n        osc = ringmod(osc,nob,1.,0.2*(1. - smoothstep(0.,1.,tn*1.)));\n        osc = ringmod(osc,nob,1.,0.2*(1. - exp(-tn*4.)));\n        \n        loopOne(5.,k,{\n            // osc = ringmod(osc,freq*1.*t*tau,1.,0.5*exp(-tn));\n            osc = ringmod(osc,freq*k*t*tau,1.,0.5*exp(-tn)*taper(k/5.,0.3,0.2));\n            \n        })\n        \n        float env = exp(-tn*1.)*smoothstep(0.,0.001,tn);\n        \n        s += osc*env*0.1;\n    }\n    \n})\n\n\nFN(arp,{\n    Time T = rep(t,bar,16.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(chord[int(T.idl)%4],3. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.5;\n    float iters = 1.;\n    for(float i = 0.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*0.5)*2.,0.7);\n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    }\n})\n\n\nFN(cowbell,{\n    Time T = rep(t,bar*4.,1.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(0.,1. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.25;\n    float iters = 1.;\n    loop(iters,i,{\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*2.)*1.,0.7);\n        //osc = ringmod(osc,freq*0.5*t*tau,1.,0.4);\n        \n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    })\n    /*\n    float iters = 3.;\n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*4.;\n        //asdg\n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.7;\n    }\n    */\n})\n\n\n \nFN(perc ,{\n    Time T = rep(t,bar,1.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 1400. + 1. * exp(-T.te*134.) + 000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*0.)*exp(-T.te*1.) + \n        n * (1.-exp(-T.te*10.))*10.\n    );\n    \n    osc = ringmod(osc,tau*(freq/4. - mod(T.idl*2. + T.idg,8.)*freq/1.)*t,1.,1.*exp(-T.te*1.));\n    \n    s += osc*env*0.6*smoothstep(0.,0.4,r.x);\n    \n    //s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n})\n\nvec2 mainSound( int samp, float t ){    \n    \n    gt = t = t + OFFS;\n    \n    vec2 s = vec2(0);\n\n\n    //s = mod();\n    //return s;\n    //chorus(chord,4.,ch,0.5,0.2);\n    \n    //return s;\n\n\n    //s += sin(t*540.);\n    \n    // --- DRUMS --- //\n    vec2 k = kick(t);\n    delay(kick, 4., bar/8., k, 1., 1., 1., 0.4);\n    reverb(kick,6.,.02,k,0.05, 0.001,0.01);\n    k *= 0.3;\n    \n\n    \n    float sidechain = 1.;\n    {\n        Time T = rep(t,bar*2.,16.);\n        bool kick = getPatt(T,kickPatt) > 0.5;\n        \n        \n        sidechain -= float(kick)\n            * pow(exp(-mod(t,bar*2./16.)*40.),.5)\n            * (1.-exp(-mod(t,bar*2./16.)*140.))\n        ;\n        //sidechain -= float(kick)*pow(exp(-mod(t,bar*2./16.)*40.),.5);\n    }\n    \n    \n    \n    vec2 per = perc(t)*0.3;\n    delay(perc, 6., bar/8., per, 1., 0., 2., 0.9);\n\n    vec2 sn = snare(t)*0.45;\n    if(t > msr*8.)\n        delay(snare, 8., bar/3./2. - abssin(t*tau/beat*0.25)*.05, sn, 1., 1., 0.01, 0.2);\n    \n    reverb(snare,10.,.3,sn,0.1, 0.1,2.);\n    chorus(snare,14.,sn,0.4,0.1 + 0.02*sin(t));\n    \n    //reverb(snare,450.,.9,sn,0.5, 0.04,1.);\n    sn *= pow(sidechain,0.5);\n    \n    s += k*smoothstep(0.,75.,t/msr);\n    s += per*smoothstep(0.,75.,t/msr);\n    s += sn*float(t - msr*4. > 0.);\n    \n    \n    \n    s = clampify(s,0.5);\n    s = smoothify(s,2.5,0.1);\n    \n    vec2 drums = s;\n    \n    s *= 0.;\n    \n    \n    //s = smoothify(s,1.,0.5);\n    //s = smoothify(s,1.5,0.1);\n    //sn *= 1.5;\n    \n    \n    //vec2 h = hats(t)*0.4;\n    //reverb(hats,543.,.89,h,0.3, 0.2,1.);\n    //s += h*pow(sidechain,0.2)*0.6;\n    \n    vec2 cb = cowbell(t);\n    //reverb(cowbell,143.,.9,cb,0.1, 0.,1.);\n    \n    vec2 rd = rides(t)*0.6;\n    //reverb(rides,130.,.2,rd,0.4, 0.1,1.);\n    \n    //s += k;\n    //s += sn;\n\n    //s += h*sidechain;\n    //s += rd*mix(sidechain,1.,0.3)*0.8;\n\n    \n    \n    //s = mix(s,smoothify(s*3.,1.),0.1 );\n    //s = mix(s,smoothify(s*110.,1.),0.01 );\n    \n    //vec2 ml = melody(t)*0.6*mix(1.,sidechain,0.2);\n    //s += ml*0.2*sidechain;\n    \n    // --- MELODY --- //\n    //s *= 0.;\n    \n    //vec2 ch = chord(t)*0.6*sidechain;\n    //reverb(chord,50.,1.3,ch,.1, 0.1,1.);\n    //s = ch;\n    //s += ch*sidechain;\n    \n    vec2 mldy = melody(t);\n    mldy*= 0.8;\n    \n    \n    /*\n    s *= 0.15;\n    vec2 chss = chordSupersaw(t)*0.3;\n    //chorus(chordSupersaw,4.,chss,0.5*smoothstep(0.,1.,t/msr),0.2);\n    //chss *= 0.5;\n    */\n    \n    /*\n    if(!(t < msr*3. || t > msr*7.)){\n        ml *= 0.;\n    } \n    float en = smoothstep(0.,1.,(t - msr*8.)/msr);\n    reverb(melody,40.,.2,ml,0.5 + float(t > msr*4.)*0.2*(1. - en) - float(t > msr*4.)*0.2);\n    ml = ml * smoothstep(0.,50.,t/msr) * (1.-float(t > msr*4.)*pow(1.-en,4.));\n    \n    if(t < msr*12.)\n        s += ml;\n    */\n    \n    \n    //chorus(melody,2.,ml,0.5,0.2);\n    //s += ml*pow(sidechain,0.5)*1.;\n    \n    \n    \n    //s += ch*pow(sidechain,0.1);\n    \n    //reverb(chordSupersaw,10.,1.,chss,0.8);\n    \n    /*\n    if( chop(t,bar,4.) > 1. ){\n        if( (t > msr*6. && t < msr*8.) || (t > msr*3. && t < msr*3.75 ))\n            s += ch*sidechain*1.;\n    } else {\n        s += chss*pow(sidechain,2.)*1.;\n    \n    }\n    */\n    \n    \n    \n    // --- BASS --- //\n    vec2 bs = bass(t)*0.8;\n    \n    if(t > msr*8.){\n        s += cb;\n    \n    }\n    if(t > msr*12.){\n        s += bs*pow(sidechain,2.01);\n    }\n\n    //return bs;\n    \n    // --- MIX --- //\n    s += drums;\n    \n    s += mldy*mix(sidechain,1.,0.4);\n    if(t < msr*4.){\n\n    } else \n    \n    \n    s = mix(s,clampifyb(s,0.6)*1.,0.4);\n    \n\n    \n    float eee = smoothstep(0.,msr,t - msr*3.);\n    \n    \n        \n        \n    s *= 1.;\n    \n    // -- Reinhard\n    //s = s/(1. + abs(s)*4.);\n    \n    // -- Exp\n    // s = (1.-exp(-abs(s)*1.))*sign(s);\n    \n    // -- Aces\n    //s.x = ACESFilm(vec3(abs(s.x))).x*sign(s.x);\n    //s.y = ACESFilm(vec3(abs(s.y))).x*sign(s.y);\n    \n    // -- Clip\n    float clip = 1.;\n    s = clamp(s,-clip,clip)/clip;\n    \n    \n    \n    \n    return s;\n}", "sound_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define bpm (160.)\n#define OFFS msr*0.\n\n\n#define PI acos(-1.)\n#define pi PI\n#define tau 2.*pi\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n\nfloat[] kickPatt = float[16](1.,0.,0.,1.,0.,1.,0.,0.,1.,0.,0.,1.,0.,0.,0.,1.);\n\n#define getPatt(T,patt) patt[int(T.idl)]\n#define getPattOffs(T,patt,cnt,offs) patt[int(T.idl + offs)%int(cnt)]\n\n#define between(t,mn,mx) (t > mn && t < mx)\n\n#define loop(its,k,cb) for(float k = 0.; k < its; k++){cb;}\n#define loopOne(its,k,cb) for(float k = 1.; k < its; k++){cb;}\n\n#define taper(v, f, wiggle) smoothstep(0. + f + wiggle,0. + f - wiggle,v)\n\n#define abssin(a) (0.5 + sin(a)*0.5)\n\n// -------------------------------------------------------- //\n// ------------------------- FX ------------------------ //\n// -------------------------------------------------------- //\n\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n//#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\n#define clampifyb(s, amt) clamp(s,-amt,amt)/amt\n#define smoothify(s, sc, amt) sign(s)*mix(abs(s),smoothstep(0.,1.,abs(s)*sc), amt)\n#define ringmod(s,freq,sc,amt) mix(s,s*sin(freq)*sc,amt)\n#define powify(s, amt) sign(s)*pow(abs(s),vec2(amt))\n\n\n#define delay(fn, iters, len, varname, amt, chorsc, diffsc, dec) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 1.; i < iters; i++){   \\\n        vec2 nois =  lpnoise(i+1100.,111551.); \\\n        vec2 noisb =  lpnoise(i+1100. + t*0.1,11.); \\\n        float amp = 1. - pow(i/iters,dec); \\\n        float idx = t - (i)*len; \\\n        float choramt = 0.04 * chorsc;    \\\n        float diffamt = 0.01  * diffsc;     \\\n        float diffiters = 40.;   \\\n        for(float k = 1.; k < diffiters; k++){   \\\n            vec2 noisb =  lpnoise(i+1100. + t*.41 + k,11.); \\\n            vec2 f = vec2(                       \\\n                fn(idx - abs(nois.x)*choramt - noisb.x*diffamt).x, \\\n                fn(idx - abs(nois.y)*choramt - noisb.y*diffamt).y  \\\n            );                                   \\\n            f = ringmod(f,noisb*1.,1.,0.5);     \\\n            res += f*amp/diffiters;                        \\\n        } \\\n    }\\\n    varname = varname + res*amt; \\\n}\n\n\n#define reverb(fn, iters, len, varname, amt, att, dec) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        float nois =  pow(i/iters,1.)*lpnoise(i/iters+1100.,111551.).x; \\\n        float env = smoothstep(0.,att,i/iters)*smoothstep(1.,0.99 - dec,i/iters);\\\n        res += fn(t - (i/iters)*len - abs(nois)*1.*len*env)*env/iters; \\\n    }\\\n    varname = varname + res/mix(1.,0.5,amt)*10.*amt; \\\n}\n\n#define chorus(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n#define phaser(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n    \n// -------------------------------------------------------- //\n// ------------------------- SYNTH ------------------------ //\n// -------------------------------------------------------- //\n\nvec2 tri(float t, float f, float iters){\n    vec2 s = vec2(0);\n    iters += 1.;\n    for(float k = 1.; k < ceil(iters); k++){\n        float freq = tau*f;\n\n        float osc = sin(freq*(2.*k - 1.)*t) * \n            (-8./(pi*pi)) * \n            (mod(k,2.)*2. - 1.)/pow(2.*k-1.,2.);\n        \n        float fr = fract(iters);\n        if(k == ceil(iters) - 1. && fr != 0.){\n            s += osc*fr;\n        }else{\n            s += osc;\n        }\n    }\n\n    return s;\n}\n\nvec2 squelchyBass(float t, float freq, float f, float q, float wiggle, float iters){\n    vec2 s = vec2(0);\n    for(float i = 1.; i < iters; i++){\n        float k = i < 10. ? i : i*2.;\n        //float k = i;\n        float osc = sin(tau*freq*t*k)*(mod(k,2.)*2. - 1.)/k; \n        if(i == 1.)\n            osc *= 5.;\n        //float att = smoothstep(0. + f + wiggle,0. + f - wiggle,i/iters);\n        float att = taper(i/iters,f,wiggle);\n        att *= 1. + smoothstep(wiggle,0.,abs(i/iters - f))*q;\n        s += osc*att;\n    }\n    \n    return s;\n}\n\n\n\n// -------------------------------------------------------- //\n// ------------------------- SEQ  ------------------------- //\n// -------------------------------------------------------- //\n\n\n\n#define tick (60./bpm)\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n#define chop(t,bt,reps) mod(floor(t/(bt/reps)), reps)\n\n\n#define FN(name, code) vec2 name(float t) { \\\n    vec2 s = vec2(0); \\\n    code \\\n    return s; \\\n}\n\n\n\nstruct Time {\n    float tt;\n    float te;\n    float idl;\n    float idg;\n};\n\nTime rep(float t, float period, float reps){\n    Time data;\n    float per = period/reps;\n    data.tt = mod(t,period);\n    data.te = mod(t,per);\n    data.idl = mod(floor(t/per),reps);\n    data.idg = floor(t/period);\n        \n    return data;\n}\n\n\n\n\nfloat note(float note, float octave){ \n    note -= 7.;\n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.);\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmin73 = vec4(0.,7.,10.,3.);\nconst vec4 cmin11 = vec4(0.,10.,14.,17.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmaj9 - 4.,\n    cmin73 - 7.,\n    cmin11 - 5.,\n    cmin7,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n\nvec4 getChord(float t){\n    return chords[ int(t / bar) % 4];\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = floor(t);\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = hash21(tn / fq*2000.);\n    vec2 n1 = hash21((tn + 1.0) / fq*2000.);\n\n    return mix(n0, n1, ft)*2. - 1.;\n}\n\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    #ifdef TURBULENT\n    return 1. - abs(noise)*0.5;\n    #else\n    return (noise*0.25 + 0.5);\n    #endif\n}\n\n\nFN(kick808,\n    vec4 chord = getChord(t);\n    \n    float repd = bar*2.;\n    float reps = 16.;\n    \n    Time T = rep(t,bar*2.,reps);\n    \n    bool kick = getPatt(T,kickPatt) > 0.5;\n    bool kickNext = getPattOffs(T,kickPatt,reps,1.) == 0.5;\n    \n    \n    //T.te = t;\n    //float env = exp(-T.te*14.);\n    \n    float freq = note(chord[0],2.)*(1.  );\n    \n    float parm = freq*T.tt*tau;\n    if(kick)\n        parm -= exp(-T.te*30.)*64.;\n    \n    \n    vec2 n = lpnoise(T.tt,10. + freq*4.*tau);\n    \n    vec2 osc = sin(parm + 0.*vec2(sin(0.1 + t*2.),sin(0.6 + t*2.5)) + sin(1200.*T.te)*exp(-T.te*40.)*0.*float(kick)\n    );\n    \n    s += osc + n*0.01;\n    \n    if(kick) s *= smoothstep(0.,0.01,T.te);\n    \n    s = smoothify(s,114.,0.2);\n    s = smoothify(s,114.,0.2);\n    \n    if(kickNext)\n        s *= 1.-smoothstep(0.9,0.99,T.te/repd*16.);\n    \n    \n    //s = smoothify(s*1.,0.2);\n    //s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    \n)\n\n\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 260, 383, 1006], [1015, 1015, 1072, 1133, 1446]]}
{"id": "flXyRl", "name": "Bouncing Box Wave", "author": "SnoopethDuckDuck", "description": "Boxes don't bounce perfectly but looks kinda nice, much easier to do with a circle:\nhttps://www.desmos.com/calculator/a0eis58nzj\nhttps://www.desmos.com/calculator/b6tawvw9te\n\nMessy example of square on a line:\nhttps://www.shadertoy.com/view/NtXyRl\n", "tags": ["e"], "likes": 26, "viewed": 409, "published": 3, "date": "1648487564", "time_retrieved": "2024-07-30T16:56:30.811214", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // How far squares travel before stopping etc\n    float rep = 3. * pi;\n    \n    // Stop-Start time (a is time, since you can't spell \"time\" without \"a\")\n    float m = min(mod(iTime, rep), 0.5 * rep);\n    float a = -pi + rep * floor(iTime/rep) \n                  + rep * smoothstep(0., 0.5 * rep, m);\n    \n    // Amplitude of sin wave\n    float c = 0.8 * cos(0.4 * iTime);\n    \n    // Scale + translate uv \n    float sc = 4.5; // + cos(iResolution.y * 3. * uv.x);\n    uv *= sc;\n    uv.y += 0.25;\n    uv.x += c + mix(a, iTime, 0.5);\n    \n    // Smallest square size\n    float r = 0.025;\n    // Square outline width\n    float w = 0.02;// + 0.01 * thc(8., iTime + 20. * uv.x);\n    \n    // Draw sin wave\n    float k = sc / iResolution.y;\n    float s = 1. - 0.98 * smoothstep(-k, k, abs(-uv.y + c * cos(uv.x)) - w);\n    \n    vec3 e = vec3(0.5);\n    vec3 col = vec3(s);\n    \n    float n = 40.;   \n    for (float i = n - 1.; i >= 0.; i--) {\n        // Offset time for each square\n        a += mix(-1., 1., 0.5 - 0.5 * cos(iTime + i * pi / 400.)) * pi / n;\n        \n        // Rescale each square\n        //r *= 1.08;\n        r = mix(0.05, 0.4, cos(a + iTime + 1. * pi * i / n) * 0.5 + 0.5);\n        \n        // sgn determines which side of the sin wave the boxes are on\n        float sgn = -1.;\n        \n        // sq is a constant used for finding the normal to the wave\n        // (mix between 1 and sqrt(2) so the box \"bounces\" correctly-ish)\n        float mx = mix(1., sqrt(2.), abs(ths(1., 2. * a + 4. * iTime)));\n        float sq = mx * sgn * (r + 0.5 * w) / sqrt(c * c * sin(a) * sin(a) + 1.);\n        \n        // First vector is point on wave, 2nd vector is normal\n        vec2 p = vec2(a, c * cos(a)) - sq * vec2(c * sin(a), 1.); \n\n        // Translate + rotate uv to p\n        vec2 uv2 = (uv - p) * Rot(a + c * sin(a));\n        \n        // Draw box\n        float box = w - abs(sdBox(uv2, vec2(0.8 * r - 0.5 * w)) - 0.2 * r);\n        s = (i/40.) * smoothstep(-k, k, box);\n        \n        vec3 col2 = pal(0.5 * a + i/n * 2., e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col2 = vec3(1.); // uncomment me for colors\n        col = mix(col, col2, s);\n    }\n    \n    // Lighten the colors\n    col = sqrt(col);\n\n    //col += 0.25 * step(abs(uv.y - c * cos(a) + c * sin(a) * (uv.x - a)), 0.04);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [119, 119, 176, 176, 2573]]}
{"id": "7lsczf", "name": "Self-aware Hairball", "author": "eiffie", "description": "3D step^2 Euler Spirals", "tags": ["eulerspiral"], "likes": 20, "viewed": 394, "published": 3, "date": "1648486988", "time_retrieved": "2024-07-30T16:56:31.550238", "image_code": "//Self-aware Hairballs by eiffie (Euler Spirals, 3D, power 2 version)\n//If you're interested in the formula for the sum of i*i where i<n, divided by n...\n//=(n-.5)*(n-1.)/3.\n\n#define PI 3.14159265\n#define TM 7.\n#define DIV 22.\n#define SZ 35.\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));} \nfloat ca,sa;vec2 rotate(in vec3 v) {v.xz=ca*v.xz+sa*vec2(v.z,-v.x);return vec2(v.x,v.y+.25*v.z);}\nfloat DE(vec2 u){\n  float t1=mod(iTime,TM+1.),t=(t1<TM?TM*.5+.5*sign(t1-.5*TM)*pow(2.*abs(t1-.5*TM)/TM,.001)*TM:TM)+floor(iTime/(TM+1.))*TM;\n  t=mod(t,DIV*TM);\n  float a=0.,d=1.5,j=(1.+t/TM)/DIV,k=DIV*4.;//a=angle,j=delta,k=steps,t=time,d=distance\n  vec3 p=vec3(0),pn;vec2 p1,p2;\n  for(float i=0.;i<k;i+=1.){\n    a+=PI*i*i*j;\n    a=mod(a,PI*2.);\n    pn=p+vec3(cos(a*2.)*cos(a),cos(a*2.)*sin(a),sin(a*2.))*SZ;\n    p1=rotate(p);p2=rotate(pn);d=min(d,tube(u-p1,p2-p1)-1.);//fake 3d rotation\n    p=pn;\n  }\n  return d;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  ca=cos(iTime);sa=sin(iTime);\n  float d=smoothstep(0.,2.,DE(2.*U-iResolution.xy));\n  O=vec4(d,d,d,1.);\n}", "image_inputs": [], "sound_code": "#define pi 3.14159\nfloat N[6]=float[6](1.,1.25,1.5,1.5,5./3.,1.5);\nvec2 sound(float time){\n  float t=time*3.;\n  int s=int(floor(t)),b=s%3;\n  int p=4*3;float n,nb,nh;\n  n=N[(s/p)%4];p/=4;\n  nb=n;\n  n*=N[(s/p)%4];p/=2;\n  nh=n; \n  n*=N[(s/p)%4];\n  float m=n;m=mod(m,2.);\n  if(mod(m+.125,.25)-.125>0.05 || abs(m-.75)<0.05)n=0.;\n  vec2 v=fract(vec2(n*200.,nb*(b==0?50.03:b==1?62.5:75.03))*time)-.5;\n  v.y*=step(fract(t),.5);v.x*=(fract(t)-1.)*.5;\n  v+=(fract(vec2(199.91,200.05)*time*nh)*.5-.25)*(1.+sin(time*15.*pi))*.25;\n  return v;\n}\nvec2 mainSound( int samp, float time){\n  vec2 v=vec2(0);\n  for(float i=0.;i<5.;i+=1.)v+=sound(time-i*.15)/(1.+i);\n  return v*.125;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 271, 271, 330], [344, 344, 368, 368, 429], [430, 430, 447, 447, 945], [946, 946, 984, 984, 1090]]}
{"id": "slsczf", "name": "random pacman", "author": "yasuo", "description": "random pacman", "tags": ["pacman"], "likes": 4, "viewed": 249, "published": 3, "date": "1648486535", "time_retrieved": "2024-07-30T16:56:32.611400", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.45, 234.56));\n    p+=dot(p,p+23.4);\n    return fract(p.x*p.y);\n}\n\nfloat starDust(vec2 p, float scale, float deg){\n    p*=scale;\n\n    vec2 id = floor(p);\n    p = fract(p)-0.5;\n    float n = Hash21(id);\n    \n    vec2 size = vec2(0.1,0.1);\n    p*=Rot(radians(deg));\n    float r = 0.4*n+0.1;\n    float d = sdPie(p,vec2(0.05-abs(sin(iTime*5.0)*0.045),-0.02),0.4*n+0.1);\n    float eye = length(p-vec2(r*0.4,0.0))-r*0.1;\n    d = max(-eye,d);\n    d = S(d,0.0);\n    \n    d*=pow(abs(sin(n*20.0+iTime*0.5)),30.0);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.0);\n\n    p.x+=iTime*0.2;\n    col+=starDust(p,5.0,90.0);\n    p = prevP;\n    p.x-=iTime*0.2;\n    col+=starDust(p,6.0,-90.0);\n    \n    p = prevP;\n    p.y+=iTime*0.2;\n    col+=starDust(p,7.0,0.0);\n    p = prevP;\n    p.y-=iTime*0.2;\n    col+=starDust(p,8.0,-180.0);\n    \n    fragColor = vec4(col*vec3(1,1,0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 210, 259, 259, 427], [429, 429, 450, 450, 540], [542, 542, 589, 589, 994], [996, 996, 1053, 1053, 1465]]}
{"id": "7tsyRf", "name": "02 rings", "author": "ccc9527", "description": "Different circle at the same center. click mouse change the center，change the second parameter of the rings function to change image", "tags": ["thesamecentermouse"], "likes": 0, "viewed": 188, "published": 3, "date": "1648475280", "time_retrieved": "2024-07-30T16:56:33.735395", "image_code": "vec3 white(float d,int n,float d0)\n{\n    float x = 0.5/float(n);\n    vec3 c1 = vec3(0.0);\n    vec3 c2 = vec3(0.0);\n    c1 = vec3(smoothstep(d0,d0-0.01,d));\n    if(d0-x > 0.001)\n    {\n        c2 = vec3(smoothstep(d0-x,d0-x+0.01,d));\n    }\n    else\n        c2 = vec3(1.0,1.0,1.0);\n    \n    return c1*c2;\n}\nvec3 rings(vec2 uv,int n)\n{\n    vec3 res = vec3(0.0);\n    float d = length(uv);\n    float x = 0.5/float(n);\n    for(int i=0;i<n;i+=2)\n    {\n        res += white(d,n,0.5-float(i)*x);\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 uv = (fragCoord-mouse*iResolution.xy)/iResolution.y;//将原点移动到鼠标点击位置\n    vec3 color = vec3(0.0);\n    \n    color = rings(uv,5);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 303], [304, 304, 331, 331, 509], [510, 510, 567, 567, 808]]}
{"id": "ftsyzf", "name": "My simple 2D light", "author": "JustBoredYo", "description": "A simple 2D point light made during my break. \nCredit to Coding Train for the line intersection  and @ockiller for the Inverse square root approximation algorithm", "tags": ["2d", "light"], "likes": 1, "viewed": 254, "published": 3, "date": "1648451988", "time_retrieved": "2024-07-30T16:56:34.547224", "image_code": "struct Line\n{\n    vec3 p1, p2;\n};\n\nstruct Point\n{\n    float x, y;\n};\n\n//Check if the current Pixel is on the same side as the light source\nbool InShadow(Line line1, Line line2) {\n    float x1 = line1.p1.x;\n    float y1 = line1.p1.y;\n    float x2 = line1.p2.x;\n    float y2 = line1.p2.y;\n\n    float x3 = line2.p1.x;\n    float y3 = line2.p1.y;\n    float x4 = line2.p2.x;\n    float y4 = line2.p2.y;\n\n    float den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (den == 0.0) {\n      return false;\n    }\n\n    float t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n    float u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n    if (t > 0.0 && t < 1.0 && u > 0.0 && u < 1.0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\nfloat invSqrtNewton(float x, float guess) { return guess * (1.5 - 0.5 * x * guess * guess); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Line l1 = Line(vec3(0.0, 30, 0), vec3(512.0, 30, 0));\n    \n    vec3 col = mix(vec3(0.5, 0.5, 1), vec3(1, 0.6, 0), 0.75-(fragCoord.y / (iResolution.y-30.0)));\n    \n    vec3 pos = vec3((sin(iTime/5.0) + 1.0)/2.0*512.0, abs(cos(iTime/5.0)*200.0)+30.0, 5.0);\n    \n    Line p = Line(vec3(fragCoord.x, fragCoord.y, 0), vec3(pos.x, pos.y, 0));\n    \n    //It's important to use || because the different calculation would cancel each other by logic\n    if(InShadow(l1, p))\n    {\n        col = vec3(128.0/255.0, 80.0/255.0, 0);\n    }else{\n        \n        //Using an aproximation of the inverse square root to get the lighting falloff\n        float light = (fragCoord.x - pos.x)*(fragCoord.x - pos.x) + (fragCoord.y - pos.y)*(fragCoord.y - pos.y);\n        float fastInvSqrt = uintBitsToFloat(0x5F400000u - (floatBitsToUint(light) >> 1));\n        float b = invSqrtNewton(light, fastInvSqrt);\n        \n        b *= 25.0;\n    \n        col = col + vec3(b*0.5);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 139, 178, 178, 761], [763, 763, 806, 806, 856], [858, 858, 915, 965, 2029]]}
{"id": "ftlyzf", "name": "try fire", "author": "cailuming", "description": "try some 2d fire , and make fun", "tags": ["fire2d"], "likes": 25, "viewed": 547, "published": 3, "date": "1648450396", "time_retrieved": "2024-07-30T16:56:35.506659", "image_code": "#define PI 3.1415926\n#define SEMI_PI 1.5707963\n//from iq\nvec3 palete(float h,float s,float v){\n   vec3 a = vec3(v,v,v);\n   vec3 b = vec3(s,s,s);\n   vec3 c = vec3(1,1,1);\n   \n   vec3 d = vec3(0.0,0.33,0.67);\n   return a+b*cos(2.0*PI*(c*h+d)); \n} \n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = sin(a);\n   return mat2(c,s,-s,c); \n}\n\n//from iq https://iquilezles.org/articles/fbm\nfloat fbm(vec2 uv) {\n    float total = 0.0, amp = 1.0,freq = 1.0;\n    float G = exp(-0.7);\n    for (int i = 0; i <6; i++) {\n        //total += noise(uv*freq) * amp;\n        total += texture(iChannel0,uv*freq).x * amp;\n        freq = freq*2.0;\n        amp *= G;\n    }\n    return total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv   = fragCoord.xy / iResolution.xy-vec2(0.5);\n    vec2 cuv  = vec2(uv.x*(iResolution.x/iResolution.y),uv.y);\n    float id  = floor(cuv.x/0.4);\n    cuv.x     = mod(cuv.x,0.4)-0.2;\n    vec3 col  = vec3(0); \n    vec2 dir  = vec2(0,1)*rot2D(0.); cuv.y+=0.2;\n    \n    float f   = fbm((cuv-dir*(iTime+id)*0.8)*0.031);\n    vec2  suv = normalize(vec2(cuv.x,cuv.y*0.23));\n    float dp  = clamp(dot(dir,suv),0.0,1.0);\n      \n    float v   = pow((0.2*dp)/length(suv)/length(cuv),5.0)*dp*pow(f,f*9.0);\n    col = vec3(1.1,1.1,0.8)*cuv.x; \n    col += mix(v,pow(0.025*f/length(vec2(cuv.x,cuv.y-0.02)),8.0),0.5);\n    col*= palete(0.94+id*0.28,1.0,1.0);\n     \n    col = smoothstep(0.0,1.0,col);\n    //col = pow(col,vec3(1.6));\n\tfragColor = vec4(col,1.);\n}\n  \n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 57, 94, 94, 244], [247, 247, 267, 267, 338], [340, 386, 406, 406, 672], [675, 675, 732, 732, 1479]]}
{"id": "ftsyRf", "name": "otras torres", "author": "jorge2017a2", "description": "otras torres", "tags": ["otrastorres"], "likes": 7, "viewed": 203, "published": 3, "date": "1648437917", "time_retrieved": "2024-07-30T16:56:36.430191", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n//otras torres ----mar-27-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 medioCirc(vec3 p)\n{\n    vec2 res= vec2(9999.0, -1.0); \n    float d2a= sdCylinderXY( p-vec3(8.0,5.0,0.0), vec2(5.0,5.0) );\n    float d2b= sdCylinderXY( p-vec3(8.0,5.0,0.0), vec2(2.5,5.5) );\n    float d2c=sdBox(p-vec3(8.0,9.0,0.0), vec3(6.0,3.0,6.0) );\n    float dif= differenceSDF(d2a, d2b);\n    dif= differenceSDF(dif, d2c);\n    res =opU2(res, vec2(dif,101.0));\n    return res;\n }   \n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n    p= rotate_y(p, radians(-45.0));\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+35.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,101.0));\n    p.y=p.y-12.0;\n    p.z= opRep1D(p.z, 13.0 );\n    p.x= opRep1D(p.x, 60.0 );\n\n    float alto=50.0;\n    float d1a= sdRoundBox( p, vec3(6.0,alto,5.0), 0.2 );\n    float d1b= sdRoundBox( p-vec3(0.0,5.0,7.0), vec3(6.5,alto+5.0,2.0), 0.2 );\n    res =opU2(res, vec2(d1a,100.0));\n    res =opU2(res, vec2(d1b,101.0));\n    vec2  res2= medioCirc(p);\n    vec2  res3= medioCirc(p-vec3(0.0,20.0,0.0));\n    res =opU2(res, res2);\n    res =opU2(res, res3);    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.001;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }  return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n\n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/16., nor)*3.0*vec3(0.5,0.7,0.5); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{   return  lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist); }\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    vec3 tex=  getColorTextura(rd*1.0, vec3(0.0,1.0,0.0),101); \n    return mix(sky,tex,rd.z);\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  vec3 colobj; \n   if (id_color<50){ colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==100){ return  getColorTextura( p, nor,100); }\n   if (id_color==101){ return  getColorTextura( p, nor,101); }            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,60.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(10.0,20.0+t,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1)   //7\n\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 546, 546, 567], [568, 568, 600, 600, 684], [685, 685, 731, 731, 818], [819, 819, 858, 858, 953], [954, 954, 993, 993, 1088], [1089, 1089, 1128, 1128, 1223], [1225, 1269, 1316, 1316, 1343], [1344, 1344, 1387, 1387, 1414], [1415, 1415, 1463, 1463, 1491], [1492, 1530, 1566, 1566, 1611], [1614, 1614, 1648, 1648, 1744], [1745, 1745, 1779, 1779, 1870], [1871, 1871, 1905, 1905, 1996], [1998, 1998, 2022, 2022, 2383], [2389, 2389, 2414, 2414, 3045], [3047, 3047, 3071, 3071, 3233], [3235, 3235, 3283, 3283, 3589], [3591, 3591, 3635, 3635, 3954], [3956, 3956, 3993, 3993, 4247], [4249, 4249, 4339, 4339, 5346], [5348, 5348, 5397, 5397, 5552], [5554, 5554, 5647, 5647, 5715], [5717, 5717, 5749, 5749, 6027], [6029, 6029, 6099, 6099, 6326], [6328, 6328, 6355, 6355, 6444], [6446, 6446, 6504, 6504, 6552], [6554, 6554, 6577, 6577, 6689], [6691, 6691, 6722, 6722, 7342], [7344, 7344, 7401, 7401, 7869]]}
{"id": "stfczX", "name": "reflect n6", "author": "jorge2017a2", "description": "reflect n6", "tags": ["reflectn6"], "likes": 5, "viewed": 239, "published": 3, "date": "1648414132", "time_retrieved": "2024-07-30T16:56:37.268947", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//referencia de diseño\n//https://www.shadertoy.com/view/7tfcRX...Created by rimina in 2022-03-27\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\nvec3 glow = vec3(0.0);\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvoid rot(inout vec2 p, float a)\n{ p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\n\n\n//https://www.shadertoy.com/view/7tfcRX\nvec3 rotarcentro(vec3 p, vec3 tras, float a)\n{   vec3 pp = p;\n   pp -= tras;\n    rot(pp.xy, a*0.5);\n    rot(pp.xz, a*0.5);\n    rot(pp.yz, a*0.25);\n    return pp;\n}\n\nvec2 GetDist(vec3 p ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    \n    float t=iTime*20.0;\n    p=p0;\n    p.y-=8.5;\n    p.xz = abs(p.xz)-vec2(15.0,10.0);\n    float d1= sdBox(p, vec3(1.5,8.0,1.5) );\n    res =opU2(res, vec2(d1,1.0));\n    \n    p=p0;\n    vec3 translate =vec3(0.0,10.0,0.0);\n    p=rotarcentro(p, translate, iTime);\n    float d2= sdBox(p, vec3(3.0,3.0,3.0) );\n    res =opU2(res, vec2(d2,2.0));\n    p=p0;\n    float d3a= sdBox(p-vec3(0.0,17.0,0.0), vec3(7.0,0.25,10.0) );\n    float d3b= sdBox(p-vec3(-25.0,5.0,0.0), vec3(0.25,10.0,6.0) );\n    p=rotate_x(p-vec3(0.0,4.0,-5.0), radians(15.0));\n    float d3c= sdBox(p, vec3(6.0,0.25,6.0) );\n    \n    res =opU2(res, vec2(d3a,201.0));\n    res =opU2(res, vec2(d3b,201.0));\n    res =opU2(res, vec2(d3c,202.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float PMaxSteps)\n{   float t = 0.1;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= int(PMaxSteps); i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\nvec3 lightingv3(vec3 normal,vec3 p,vec3 lp,vec3 rd, vec3 ro, vec3 color )\n{   vec3 lightPos=lp;\n    vec3 hit=p;\n    vec3 norm=normal;\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos)); // shadows\n    float occ = ambOcclusion(hit, norm);// occ\n\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n\n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);// back\n  vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetColor(vec3 p,vec3 nor, float id_color)\n{  vec3 color=vec3(0.0); \n   if(id_color<50.0)\n   { color=getColor(int(id_color)); }  \n   \n    if (id_color==57.)\n        {return pattern( p.xz );}\n    if (id_color==58.)\n        {return pattern( p.xy );}\n    if (id_color==59.)\n        {return pattern( p.zy );}\n   return color;\n}\n\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n    vec2 t;\n    vec3 rcol = vec3(0);\n    \n    for(int i = 0; i < 3; i++) \n    {\n    t = RayMarch(ro, rd, MAX_DIST);\n    if(t.x < MAX_DIST) \n      { vec3 pos = ro + rd*t.x;\n\t\tvec3 nor = GetNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n        vec3 color= GetColor(pos,nor,t.y);\n        \n        rcol= lightingv3(nor,pos,light_pos1,rd, ro, color );\n        rcol+= lightingv3(nor,pos,light_pos2,rd, ro, color );\n        rcol/=2.0;\n        // set up the ray orgin and direction for reflection.\n\t\tro = pos + nor*0.001;\n            \n        if (t.y==201.0)\n        { rd = ref; rcol+=vec3(0.5); }\n        \n        if (t.y==202.0)\n        { rd=ref; rcol+=vec3(0.5);}\n            \n        if (t.y==203.0)\n        { rd = ref;}\n            \n        if (t.y==204.0)\n        { rd = ref;}\n        \n        // sky fog.\n\t\t///rcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.00715*t.x));\n        // lighten intensity on each successive reflect.\n\t\tif(i == 0) col = rcol;\n\t\telse col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t  }\n     else if(t.x>MAX_DIST)\n     col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n\t}\n  return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,25.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   light_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,8.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//-------common\n//#define PI 3.14159265358979323846264\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1)   //7\n);\n\nvec3 getColor(int i)\n{  if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 621, 657, 657, 678], [679, 679, 711, 711, 795], [798, 823, 857, 857, 953], [954, 954, 988, 988, 1079], [1080, 1080, 1114, 1114, 1205], [1207, 1207, 1240, 1240, 1281], [1284, 1324, 1370, 1370, 1487], [1489, 1489, 1513, 1513, 2360], [2362, 2362, 2386, 2386, 2548], [2550, 2550, 2600, 2600, 2898], [2900, 2900, 2944, 2944, 3262], [3265, 3265, 3305, 3305, 3562], [3564, 3564, 3639, 3639, 4565], [4568, 4568, 4600, 4600, 4797], [4799, 4847, 4875, 4875, 5063], [5065, 5065, 5113, 5113, 5392], [5396, 5396, 5423, 5423, 5512], [5514, 5514, 5572, 5572, 5620], [5622, 5622, 5645, 5645, 5757], [5760, 5760, 5792, 5792, 6958], [6960, 6960, 6997, 6997, 7267], [7270, 7270, 7327, 7327, 7789]]}
{"id": "flfyzX", "name": "Nordine : Billard sur lave ", "author": "Nordine", "description": "\nTexturing : Billard sur table / Pool on lava", "tags": ["texturingpoollavabillard"], "likes": 4, "viewed": 255, "published": 3, "date": "1648389556", "time_retrieved": "2024-07-30T16:56:38.192478", "image_code": "// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c;\nfloat s;\n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// sdRoundBox \n// p : point\n// b : point\n// r : radius\n// index : indice de reflection\n\nV sdRoundBox( vec3 p, vec3 b, float r, int index)\n{\n  vec3 q = abs(p) - b;\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r,index);\n}\n\n// sdCapsule \n// p : point\n// a : point a\n// b : point b\n// r : radius \n// index : indice de reflection\n\nV sdCapsule( vec3 p, vec3 a, vec3 b, float r, int index )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return V(length( pa - ba*h ) - r,index);\n}\n\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nV Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return V(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Difference\n// a, b\n\nV Difference(V a,V b)\n{\n    if (a.v>-b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(-b.v,b.i);\n    }\n}\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersection(Cube(p,c,r*0.75,index),Sphere(p,c,r,index));\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  // sol de lave :\n  V u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n  \n  // boules de billard :\n  u=Union(u,Sphere(p,vec3( 0.0, 0.0, 1.3),0.8,1));\n  u=Union(u,Sphere(p,vec3( 1.5, 0.8, 1.3),0.8,2));\n  u=Union(u,Sphere(p,vec3( 1.5, -0.8, 1.3),0.8,3));\n  u=Union(u,Sphere(p,vec3( 3.0, 0.0, 1.3),0.8,4));\n  u=Union(u,Sphere(p,vec3( 3.0, 1.6, 1.3),0.8,5));\n  u=Union(u,Sphere(p,vec3( 3.0, -1.6, 1.3),0.8,6));\n  u=Union(u,Sphere(p,vec3( 4.5, 0.8, 1.3),0.8,7));\n  u=Union(u,Sphere(p,vec3( 4.5, -0.8, 1.3),0.8,8));\n  u=Union(u,Sphere(p,vec3( 4.5, 2.5, 1.3),0.8,9));\n  u=Union(u,Sphere(p,vec3( 4.5, -2.5, 1.3),0.8,10));\n  u=Union(u,Sphere(p,vec3( 6.0, 0.0, 1.3),0.8,11));\n  u=Union(u,Sphere(p,vec3( 6.0, 1.6, 1.3),0.8,12));\n  u=Union(u,Sphere(p,vec3( 6.0, -1.6, 1.3),0.8,13));\n  u=Union(u,Sphere(p,vec3( 6.0, -3.4, 1.3),0.8,14));\n  u=Union(u,Sphere(p,vec3( 6.0, 3.4, 1.3),0.8,15));\n  u=Union(u,Sphere(p,vec3( -8.0, 0.0, 1.3),0.8,16));\n  \n  // base de la table :\n  u=Union(u,sdRoundBox(p,vec3( 13.0, 8.0, 0.2),0.5,17));\n\n  // trous de la table\n  u=Difference(u,Sphere(p,vec3( 12.0, 7.2, 1.0),1.05,4));\n  u=Difference(u,Sphere(p,vec3( 12.0, -7.2, 1.0),1.05,4));\n  u=Difference(u,Sphere(p,vec3( -12.0, 7.2, 1.0),1.05,4));\n  u=Difference(u,Sphere(p,vec3( -12.0, -7.2, 1.0),1.05,4));\n  u=Difference(u,Sphere(p,vec3( 0.0, 7.2, 1.0),1.05,4));\n  u=Difference(u,Sphere(p,vec3( 0.0, -7.2, 1.0),1.05,4));\n  \n  // pieds de la table :\n  u=Union(u,sdCapsule(p,vec3( 12.0, 7.0, -3.7),vec3( 12.0,7.0, -1.0),0.5,4));\n  u=Union(u,sdCapsule(p,vec3( -12.0, -7.0, -3.7),vec3( -12.0,-7.0, -1.0),0.5,4));\n  u=Union(u,sdCapsule(p,vec3( 12.0, -7.0, -3.7),vec3( 12.0,-7.0, -1.0),0.5,4));\n  u=Union(u,sdCapsule(p,vec3( -12.0, 7.0, -3.7),vec3( -12.0,7.0, -1.0),0.5,4));\n  \n  // queues de billards :\n  u=Union(u,sdCapsule(p,vec3( -10.0, 5.0, 1.0),vec3( 10.0, 5.0, 1.0),0.2,18));\n  u=Union(u,sdCapsule(p,vec3( -10.0, -5.0, 1.0),vec3( 10.0,-5.0, 1.0),0.2,18));\n\n\n\n\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.65,0.75,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\nint convert(float x)\n{\n    if (x<0.0)\n    {\n        x = x-1.0;\n    }\n    return int(x);\n}\n\n// Damier \n// p : point\n// a : couleur 1 \n// b : couleur 2\nvec3 Damier(vec3 p, vec3 a, vec3 b)\n{\n    int x = convert(p.x);\n    int y = convert(p.y);\n    int z = convert(p.z);\n    if ((x+y+z)%2 == 0) return a;\n    else return b;\n\n}\n\n// Spheres \n// p : point\n// a : couleur 1 \n// b : couleur 2\nvec3 Spheres(vec3 p, vec3 a, vec3 b)\n{\n    vec3 q =  fract(p);\n    if(length(q-vec3(0.5,0.5,0.5))<0.8) return a;\n    else return b;\n}\n\n// Bois \n// p : point\n// a : Couleur a \n// b : Couleur b\n\nvec3 Bois(vec3 p, vec3 a, vec3 b)\n{\n    float d = length(p.xy);\n    float v = 0.5*(cos(d/0.1) + 1.0);\n    vec3 c = mix(a,b,v);\n    return c;\n\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n/* \n\nTextures  que j'ai codé mais pas utilisé :\n\nT TextureDamier(in vec3 p)\n{\nvec3 c = Damier(p,vec3(0.0,1.0,0.0),vec3(1.0,0.02,0.5));\n  return T(c,1.0);   \n}\n\nT TextureSpheres(in vec3 p)\n{\n   vec3 c = Spheres(p,vec3(1.0,0.5,0.2),vec3(0.6,0.3,0.7));\n  return T(c,1.0);   \n}\n\n*/\n\nT Texture0(in vec3 p)\n{\n    vec3 c = vec3(0.8,0.0,0.0);\n    vec3 n = vec3(1.0,1.0,1.0);\n    vec3 f = (Noise(p)*c) + (0.5*Noise(p/10.0)*n) +(Noise(p/0.1)*c)\n    ;\n    return T(f,0.0);   \n}\n\n\nT Texture1(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.648,0.0);\n    return T(c,1.0);   \n}\n\n\nT Texture2(in vec3 p)\n{\n    vec3 c =  vec3(0.0,0.0,0.5);\n    return T(c,1.0); \n}\n\n\nT Texture3(in vec3 p)\n{\n    vec3 c =  vec3(0.55,0.05,0.05);\n    return T(c,1.0);   \n}\n\n\nT Texture4(in vec3 p)\n{\n    vec3 c =  vec3(0.0,0.0,0.0);\n    return T(c,1.0);  \n}\n\n\nT Texture5(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.84,0.05);\n    return T(c,1.0);   \n}\n\nT Texture6(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.13,0.13);\n    return T(c,1.0);  \n}\n\nT Texture7(in vec3 p)\n{  \n    vec3 c =  vec3(1.0,0.0,0.0);\n    return T(c,1.0); \n}\n\nT Texture8(in vec3 p)\n{\n    vec3 c =  vec3(0.0,0.75,1.0);\n    return T(c,1.0);    \n}\n\nT Texture9(in vec3 p)\n{\n    vec3 c =  vec3(0.19,0.8,0.19);\n    return T(c,1.0);  \n}\n\nT Texture10(in vec3 p)\n{\n    vec3 c =  vec3(0.0,1.0,0.0);\n    return T(c,1.0);\n}\n\nT Texture11(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.0,1.0);\n    return T(c,1.0);\n}\n\nT Texture12(in vec3 p)\n{\n    vec3 c =  vec3(0.72,0.52,0.04);\n    return T(c,1.0);\n}\n\nT Texture13(in vec3 p)\n{\n    vec3 c =  vec3(0.0,1.0,1.0);\n    return T(c,1.0); \n}\n\nT Texture14(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.6,0.0);\n    return T(c,1.0);  \n}\n\nT Texture15(in vec3 p)\n{\n    vec3 c =  vec3(1.0,0.07,0.57);\n    return T(c,1.0);  \n}\n\nT Texture16(in vec3 p)\n{\n    vec3 c =  vec3(1.0,1.0,1.0);\n    return T(c,1.0); \n}\n\nT Texture17(in vec3 p)\n{\n    vec3 c = Bois(p,vec3(0.85,0.64,0.12),vec3(0.54,0.27,0.07));\n    return T(c,1.0); \n}\n\nT Texture18(in vec3 p)\n{\n    vec3 c = vec3(0.91,0.82,0.65);;\n    return T(c,1.0); \n}\n\n\n\n\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0)\n    {\n        return Texture0(p);\n    }\n    else if (vp.i==1)\n    {\n        return Texture1(p);\n    }\n    else if (vp.i==2)\n    {\n        return Texture2(p);\n    }\n    else if (vp.i==3)\n    {\n        return Texture3(p);\n    }\n    else if (vp.i==4)\n    {\n        return Texture4(p);\n    }\n    else if (vp.i==5)\n    {\n        return Texture5(p);\n    }\n    else if (vp.i==6)\n    {\n        return Texture6(p);\n    }\n    else if (vp.i==7)\n    {\n        return Texture7(p);\n    }\n    else if (vp.i==8)\n    {\n        return Texture8(p);\n    }\n    else if (vp.i==9)\n    {\n        return Texture9(p);\n    }\n    else if (vp.i==10)\n    {\n        return Texture10(p);\n    }\n    else if (vp.i==11)\n    {\n        return Texture11(p);\n    }\n    else if (vp.i==12)\n    {\n        return Texture12(p);\n    }\n    else if (vp.i==13)\n    {\n        return Texture13(p);\n    }\n    else if (vp.i==14)\n    {\n        return Texture14(p);\n    }\n    else if (vp.i==15)\n    {\n        return Texture15(p);\n    }\n    else if (vp.i==16)\n    {\n        return Texture16(p);\n    }\n    else if (vp.i==17)\n    {\n        return Texture17(p);\n    }\n    else if (vp.i==18)\n    {\n        return Texture18(p);\n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.5*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.5  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 476, 520, 520, 555], [557, 608, 649, 649, 754], [844, 844, 895, 895, 995], [1102, 1102, 1161, 1161, 1291], [1294, 1362, 1405, 1405, 1441], [1443, 1531, 1549, 1549, 1644], [1646, 1751, 1776, 1776, 1883], [1908, 1908, 1931, 1931, 2040], [2042, 2093, 2134, 2134, 2203], [2205, 2251, 2269, 2288, 4227], [4337, 4377, 4408, 4408, 4651], [4653, 4783, 4848, 4848, 5255], [5257, 5298, 5323, 5323, 5399], [5402, 5421, 5449, 5467, 5727], [5729, 5729, 5751, 5751, 5818], [5820, 5879, 5916, 5916, 6050], [6052, 6112, 6150, 6150, 6245], [6305, 6305, 6340, 6340, 6448], [6833, 6833, 6856, 6856, 7020], [7023, 7023, 7046, 7046, 7107], [7110, 7110, 7133, 7133, 7190], [7193, 7193, 7216, 7216, 7278], [7281, 7281, 7304, 7304, 7362], [7365, 7365, 7388, 7388, 7449], [7451, 7451, 7474, 7474, 7534], [7536, 7536, 7559, 7559, 7618], [7620, 7620, 7643, 7643, 7704], [7706, 7706, 7729, 7729, 7789], [7791, 7791, 7815, 7815, 7871], [7873, 7873, 7897, 7897, 7953], [7955, 7955, 7979, 7979, 8038], [8040, 8040, 8064, 8064, 8121], [8123, 8123, 8147, 8147, 8205], [8207, 8207, 8231, 8231, 8291], [8293, 8293, 8317, 8317, 8374], [8376, 8376, 8400, 8400, 8488], [8490, 8490, 8514, 8514, 8574], [8581, 8628, 8658, 8658, 9872], [9874, 9937, 9973, 9973, 10098], [10100, 10181, 10217, 10237, 10771], [11089, 11184, 11223, 11248, 11672], [11675, 11684, 11731, 11760, 12461]]}
{"id": "ftXyRX", "name": "More cubic roundy thingies", "author": "xfennec", "description": "Raymarching experiments, v2", "tags": ["raymarching"], "likes": 2, "viewed": 248, "published": 3, "date": "1648372705", "time_retrieved": "2024-07-30T16:56:38.945465", "image_code": "// based on Rémi Papillié's WebGL conference\n// https://www.youtube.com/watch?v=s6t0mJsgUKw\n\n// see also:\n// https://www.shadertoy.com/view/MsBGW1 (shading, AO)\n// \n\n// NOTE :\n// smooth-min (blending SDF)\n// https://iquilezles.org/articles/smin\n\n\nvec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\n\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 saturation(vec3 color, float value) {\n  // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n  const vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\n  vec3 grayscale = vec3(dot(color, luminosityFactor));\n\n  return mix(grayscale, color, 1.0 + value);\n}\n\n\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat map(vec3 pos, float beat) {\n    vec3 posBox = pos + vec3(0.0, 0.0,  0.0);\n    \n    // space yz rotation\n    posBox.yz = rotate(posBox.yz, pos.x * cos(iTime*1.25)* ((1.0 + beat)*0.2) * 0.004);\n    \n    posBox = opRep(posBox, vec3(10.0));\n    //posBox = opRepLim(posBox, vec3(5.0), vec3(3.0));\n    \n    float zfact = pos.z * 0.1;\n    posBox.yz = rotate(posBox.yz, zfact);\n    posBox.xy = rotate(posBox.xy, iTime * 0.3 + (beat * 0.5));\n    posBox.xz = rotate(posBox.xz, iTime * 0.01 + (beat * 0.2));\n    \n    float dBox = sdRoundBox(posBox, vec3(1.5, 1.5, 1.5), 0.2);\n    \n\treturn dBox;\n}\n\nvec3 computeNormal(vec3 pos, float beat) {\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy, beat) - map(pos - eps.xyy, beat),\n        map(pos + eps.yxy, beat) - map(pos - eps.yxy, beat),\n        map(pos + eps.yyx, beat) - map(pos - eps.yyx, beat)\n    ));\n}\n\nfloat diffuse(vec3 normal) {\n\t//return max(dot(normal, lightDir), 0.0);\n\treturn dot(normal, lightDir) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // map uv from 0..1 to -1..1 (x will be scaled using viewport ratio)\n    uv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n\n    int tx = int(uv.x*512.0); // sound texture is 512x2\n\tfloat fft = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; // 1st row is frequency data\n\n\t// crude beat detection\n    float bass = 0.0;\n    int samples = 10;\n    for(int i = 0 ; i < samples ; ++i) {\n        bass += texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n    }\n    bass /= float(samples);\n    float beat = smoothstep(0.9, 1.0, bass);\n\n\n    // right-hand\n    vec3 cam = vec3(\n        -5.0 + -3.0 * sin(iTime) + (beat * 1.0),\n        -5.0 + -3.0 * cos(iTime) + (beat * 1.0),\n        -100.0 * sin(iTime)\n    );\n\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    vec3 color = vec3(0.0);\n    vec3 pos = cam;    \n\n    for (int i = 0 ; i < 256 ; ++i) {\n        float d = map(pos, beat);\n        if (d < 0.01) {\n            //color = 1.0-pos*0.05;\n            color = (10.0-pos);\n            color = normalize(color) * 3.0;\n            //color = vec3(1.0);\n            float z = (1500.0 - (pos.z - cam.z)) / 3000.0;\n            color *= z;\n\n            break;\n        }\n        if (pos.z > 1000.0 + cam.z) {\n            break;\n        }\n        pos += d * dir;\n    }\n\n    \n    vec3 finalColor = color * diffuse(computeNormal(pos, beat));\n    //finalColor = saturation(finalColor, beat * 1.5);\n    finalColor = contrast(finalColor, 1.0 + beat * 1.0);\n    \n\n    // Output to screen\n    //fragColor = vec4(color, 1.0);\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 28678, "src": "https://soundcloud.com/royksopp/breathe?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// distance functions, inigo quilez\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdPlane(vec3 pos) {\n    return pos.y;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n  return length(pos)-radius;\n}\n\nfloat sdRoundBox(vec3 pos, vec3 size, float radius)\n{\n  vec3 q = abs(pos) - (size - vec3(radius));\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// repetition\nvec3 opRep(vec3 pos, vec3 factor)\n{\n    return mod(pos + 0.5*factor, factor) - 0.5*factor;\n}\n\nvec3 opRepLim(vec3 pos, vec3 factor, vec3 limit)\n{\n    return pos - factor*clamp(round(pos/factor), -limit, limit);\n}\n\n\n// NOT USED (YET?)\n// https://www.shadertoy.com/view/Wtl3zN \n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(\n    \toc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0,\n        0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 341, 341, 381], [383, 383, 425, 483, 648], [651, 651, 687, 687, 774], [776, 776, 809, 809, 1367], [1369, 1369, 1411, 1411, 1662], [1664, 1664, 1692, 1735, 1780], [1782, 1782, 1839, 1889, 3473]]}
{"id": "7tsyR2", "name": "evolution", "author": "4eckme", "description": "hexagons fractal generator", "tags": ["fractals", "organic", "evolution", "generator", "hexagons", "clickandmove"], "likes": 4, "viewed": 242, "published": 3, "date": "1648353775", "time_retrieved": "2024-07-30T16:56:39.802174", "image_code": "//CLICK MOUSE AND MOVE\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define o(v2,deg) mod((v2)*rot(radians(deg)),60.0)-30.0;\n#define hex() o1=o(p,0.);o2=o(p,60.);o3=o(p,120.);rgba+=clamp(vec4(abs(o1.y)+abs(o2.y)+abs(o3.y)-54.),0.,1.);\nvoid mainImage(out vec4 rgba,in vec2 p){\n    float itime;vec2 o1,o2,o3;\n    vec2 R=iResolution.xy;\n    rgba=vec4(0);\n    p-=R.xy/2.;p/=min(R.x,R.y)/360.0;\n    p/=cos(length(p)/27.)/3.+2./3.;\n    itime=iTime;\n    p+=itime*5.0;hex();\n    p-=iMouse.xy/2.0;hex();\n    p-=iMouse.xy/2.0;hex();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 281, 281, 530]]}
{"id": "stsyR2", "name": "001 - Respiration line", "author": "PiGIon", "description": "001 - I'm learning GLSL and math concepts.\n\nI was able to discover a way to draw a diagonal line, then, pulse it by creating a cycle function.\n\nComments are more \"me talking to myself\" than a documentation. Code feedback is always appreciated. Thx!", "tags": ["beginner", "learning"], "likes": 2, "viewed": 161, "published": 3, "date": "1648352259", "time_retrieved": "2024-07-30T16:56:40.634948", "image_code": "// 2022.03.27 rev 1\n\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n\n    float x = iTime * perSecond;\n    float d = (x) - floor(x);\n    \n    if (d > 0.5) {\n        d = (1. - d); // reverse the keyframe, go back to start\n    }\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    d *= 2.;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // Now, the coord system is 0 to 1\n    // [0, 0] = left bottom corner\n    // [1, 1] = top right corner\n    \n    // if x is +- equal to y, then paint black\n    // For humans, the typical respiratory rate for a healthy adult at rest is 12–16 breaths per minute.\n    // perSecond = 14 / 60 ~= 0.2333\n    if (distance(uv.x, uv.y) < (0.1 + (cycle(0.233) * 0.04))) {\n        fragColor = vec4(0, 0, 0, 1.0);\n    } else if (uv.x > .5) {\n        fragColor = vec4(1.0, 0, 0,1.0);\n    } else {\n        fragColor = vec4(0, 1, 0,1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 51, 1022, 1379], [1381, 1381, 1438, 1438, 2016]]}
{"id": "7lsyRj", "name": "convolutional CA", "author": "icantcomeupwithausername", "description": "cellular automaton with a single convolution", "tags": ["convolution", "ca"], "likes": 6, "viewed": 268, "published": 3, "date": "1648332466", "time_retrieved": "2024-07-30T16:56:41.901561", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;  \n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat3 kernel = mat3(\n    0.68, -0.9, 0.68,\n    -0.9, -0.56, -0.9,\n    0.68, -0.9, 0.68\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if(iFrame < 10){\n        fragColor = texture(iChannel1, uv) * 50.0;\n    }else{ \n        //convolution\n        vec3 sum = vec3(0);\n        for(int y = 0; y < 3; y++){\n            for(int x = 0; x < 3; x++){\n                sum += texture(iChannel0, fract(uv + vec2(x - 1, y - 1) / iResolution.xy)).xyz * kernel[y][x];\n            }\n        }\n        \n        //inverse gaussian\n        sum = 1.0 - exp2(-0.6 * sum * sum);\n        \n        if(iMouse.z > 0.0){\n            uv = uv * 2.0 - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            \n            vec2 m = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n            m.x *= iResolution.x/iResolution.y;\n            if(dot(uv-m, uv-m) < 0.01) {\n                sum++;\n            } \n        }\n        \n        fragColor = vec4(sum, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = mix(texture(iChannel0, uv), texture(iChannel1, uv), 0.6); //smooth out flickering\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 141]]}
{"id": "NllyR2", "name": "Dagsoc logo competition", "author": "Molive", "description": "tis the dagsoc logo\n\nv. cursed code", "tags": ["caustics", "dagsoc"], "likes": 4, "viewed": 356, "published": 3, "date": "1648329053", "time_retrieved": "2024-07-30T16:56:42.904879", "image_code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n    float n = length(color);\n    color*=pow(n,1.1)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matLight=4;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nvec2 box( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN, in bool far ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    if (far)\n    {\n        oN = -sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n    }\n    else\n    {\n        oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    }\n\n    return vec2( tN, tF );\n}\n\n#define checkinset if ((inset.x != -1.) && abs(inset.x - dist.x) < 0.0001) {if (abs(inset.y - dist.y) > 0.0001) {return vec4(inset.y, extra_normal);} else {return vec4(-1.);}}\n\nvec4 dagsoc(in vec3 ro, in vec3 rd)\n{\n    vec3 normal;\n    vec2 dist = box(ro,rd,vec3(3,3,3),normal,false);\n    if (dist.x != -1.)\n    {\n        vec3 extra_normal;\n        vec2 inset = box(ro-vec3(0,2.5,0),rd,vec3(0.75,0.5,0.75),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.25,-2.25,0),rd,vec3(0.75,0.75,1.4),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.2,0),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.6,1),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        inset = box(ro-vec3(2.7,0.6,-1),rd,vec3(0.3,1,0.3),extra_normal,true);\n        checkinset\n        \n        vec3 normal1;\n        vec2 inset1 = box(ro-vec3(-1,0.7,2.5),rd,vec3(2,0.2,0.5),normal1,true);\n        vec3 normal2;\n        vec2 inset2 = box(ro-vec3(-1,-0.3,2.5),rd,vec3(2,0.2,0.5),normal2,true);\n        vec3 normal3;\n        vec2 inset3 = box(ro-vec3(1.2,-0.35,2.5),rd,vec3(0.2,1.25,0.5),normal3,true);\n        vec3 normal4;\n        vec2 inset4 = box(ro-vec3(0,-1.4,2.5),rd,vec3(1,0.2,0.5),normal4,true);\n        vec3 normal5;\n        vec2 inset5 = box(ro-vec3(-0.8,-0.85,2.5),rd,vec3(0.2,0.35,0.5),normal5,true);\n        if ((inset1.x != -1.) && abs(inset1.x - dist.x) < 0.0001)\n        {\n            if (abs(inset1.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset1.y - dist.y) > 0.0001) \n            {\n                return vec4(inset1.y, normal1);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset2.x != -1.) && abs(inset2.x - dist.x) < 0.0001)\n        {\n            if (abs(inset2.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset2.y - inset5.x) < 0.0001) \n            {\n                if (abs(inset5.y - inset4.x) < 0.0001) \n                {\n                    return vec4(inset4.y, normal4);\n                }\n                else\n                {\n                    return vec4(inset5.y, normal5);\n                }\n            }\n            else\n            if (abs(inset2.y - dist.y) > 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset3.x != -1.) && abs(inset3.x - dist.x) < 0.0001)\n        {\n            if (abs(inset3.y - inset1.x) < 0.0001) \n            {\n                return vec4(inset1.y, normal1);\n            }\n            else\n            if (abs(inset3.y - inset2.x) < 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            if (abs(inset3.y - inset4.x) < 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            if (abs(inset3.y - dist.y) > 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset4.x != -1.) && abs(inset4.x - dist.x) < 0.0001)\n        {\n            if (abs(inset4.y - inset3.x) < 0.0001) \n            {\n                return vec4(inset3.y, normal3);\n            }\n            else\n            if (abs(inset4.y - inset5.x) < 0.0001) \n            {\n                if (abs(inset5.y - inset2.x) < 0.0001) \n                {\n                    return vec4(inset2.y, normal2);\n                }\n                else\n                {\n                    return vec4(inset5.y, normal5);\n                }\n            }\n            else\n            if (abs(inset4.y - dist.y) > 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        if ((inset5.x != -1.) && abs(inset5.x - dist.x) < 0.0001)\n        {\n            if (abs(inset5.y - inset2.x) < 0.0001) \n            {\n                return vec4(inset2.y, normal2);\n            }\n            else\n            if (abs(inset5.y - inset4.x) < 0.0001) \n            {\n                return vec4(inset4.y, normal4);\n            }\n            else\n            if (abs(inset5.y - dist.y) > 0.0001) \n            {\n                return vec4(inset5.y, normal5);\n            }\n            else\n            {\n                return vec4(-1.);\n            }\n        }\n        \n        return vec4(dist.x,normal);\n    }\n    return vec4(-1.);\n}\n\n#define checkinverse if (top.x > 0. && top.x < ret.x) {ret = vec4(top.x, extra_normal);}\n\nvec4 inversedagsoc(in vec3 ro, in vec3 rd)\n{\n    vec3 extra_normal;\n    vec4 ret = vec4(1000);\n    vec2 top = box(ro-vec3(0,2.5,0),rd,vec3(0.75,0.5,0.75),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.25,-2.25,0),rd,vec3(0.75,0.75,1.4),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.2,0),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.6,1),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(2.7,0.6,-1),rd,vec3(0.3,1,0.3),extra_normal,false);\n    checkinverse\n    \n    top = box(ro-vec3(-1,0.7,2.5),rd,vec3(2,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(-1,-0.3,2.5),rd,vec3(2,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(1.2,-0.35,2.5),rd,vec3(0.2,1.25,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(0,-1.4,2.5),rd,vec3(1,0.2,0.5),extra_normal,false);\n    checkinverse\n    top = box(ro-vec3(-0.8,-0.85,2.5),rd,vec3(0.2,0.35,0.5),extra_normal,false);\n    checkinverse\n\n    vec3 normal;\n    vec2 dist = box(ro,rd,vec3(3,3,3),normal,true);\n    if (dist.y > 0. && dist.y < ret.x)\n    {\n        ret = vec4(dist.y, normal);\n    }\n    return ret;\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nint mat;\nfloat inv;\nbool inside;\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matLiquid;\n    vec4 innerScene;\n    if (inside) {\n    innerScene = inversedagsoc(ro,rd);\n    } else {\n    innerScene = dagsoc(ro,rd);\n    }\n    if (innerScene.x > 0.) return innerScene;\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,10.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,5));\n    if (plane > 0.) return vec4(plane, 0.,1.,0.);\n    //vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    //if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .0001;\n\n    vec3 accum = vec3(1);\n    inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n\n        t = 0.;\n        k = 0.;\n        n = vec3(1,0,0);\n        h = vec3(0);\n        mat = matBlack;\n        vec4 scene = iScene(cam,dir);\n        if (scene.x > 0.) \n        {\n            t = scene.x;\n            n = scene.yzw;\n            h = cam+dir*t;\n            k = THRESHOLD;\n            \n            /*if (inside) {\n                n= n*-1.;\n            }*/\n\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (inside)\n            //if (mat != matBound)\n            //if (mat != matLiquid)\n            //return vec3(n*.1+0.1);\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(6.,5.5,5.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matLiquid)\n            {\n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = inside ? 1.364 : 1./1.364;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              0.8 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * THRESHOLD;\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.1,0.03, 0.08);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n    vec3 cam = vec3(1.,1.,-80.);\n    //vec3 cam = vec3(0.1,0.1,0.1);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/6.);\n    dir.yz = rotate(dir.yz, pi/6.);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = .8-3.*(iMouse.y/iResolution.y);\n    \tcam.yz = rotate(cam.yz, a);\n    \tdir.yz = rotate(dir.yz, a);\n    }\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/1.4);\n    dir.xz = rotate(dir.xz, pi/1.4);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = 1.-8.*(iMouse.x/iResolution.x);\n    \tcam.xz = rotate(cam.xz, a);\n    \tdir.xz = rotate(dir.xz, a);\n    }\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n     if (iMouse.z > 0.) fragColor *= .1;\n\n    // accumulate the pixel\n    //if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 202, 202, 583]]}
{"id": "Nllyz2", "name": "geeffer556", "author": "greeffer", "description": "background for a thrree.js site", "tags": ["background", "webgl"], "likes": 0, "viewed": 183, "published": 3, "date": "1648323670", "time_retrieved": "2024-07-30T16:56:43.706735", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.3 + 0.1*cos(iTime-uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nllyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 297]]}
{"id": "7lfyRj", "name": "Day 828", "author": "jeyko", "description": "finally good drums.", "tags": ["sound", "music", "mdtmjvm"], "likes": 26, "viewed": 382, "published": 3, "date": "1648320439", "time_retrieved": "2024-07-30T16:56:44.743961", "image_code": "// Reese from texture idea from 0b5vr.\n\n// so\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat message(vec2 uv) { // to alter in the icon\n    \n    uv.y += sin(acos(-1.)*iTime/beat + sin(acos(-1.)*iTime/beat*2.)*float(iTime > msr*2.));\n    \n    uv-=vec2(1.,10.); \n    uv -= vec2(16.,1.5);\n    uv.xy *= rot(sin(acos(-1.)*iTime/beat)*0.4*mod(iTime/beat,1.)*float(iTime > msr*2.));\n    \n    if(iTime > msr*4.)\n        uv *= 1. + sin(iTime*4.)*0.4;\n        \n    uv += vec2(16.,1.5);\n    if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\t//tGlobal = iTime*2.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n    if(iTime > msr*6.)\n        fragColor = 0.5 + 0.5*sin(fragColor + iTime);\n\n}   ", "image_inputs": [], "sound_code": "\nfloat gt;\n\n\nFN(kick,\n    Time T = rep(t,bar,4.);\n    //T.te = t;\n    float env = exp(-T.te*14.);\n    float freq = 400. + 2300. * exp(-T.te*16.) + 0.78;\n    //freq = 1400. + 500.*exp(-T.te*10.);\n    freq = 400.*(1.  + exp(-T.te*13.)*3.);\n    float osc = sin(freq*T.te*1.\n        + sin(1200.*T.te)*exp(-T.te*40.)*1.\n    );\n    \n    s += osc*env;\n    /*\n    s = smoothify(s*1.,0.2);\n    s = smoothify(s*1.,0.2);\n    s = mix(s,smoothify(s*3.,1.),0.3 * exp(-T.te*45.));\n    */\n)\n\nFN(snare,\n    \n    Time T;\n    if(gt < msr*3.5)\n        T = rep(t + bar/4.,bar,8.);\n    else if(gt < msr*3.75)\n        T = rep(t + bar/4.,bar,16.);\n    else if(gt < msr*4.)\n        T = rep(t + bar/4.,bar,32.);\n    else\n        T = rep(t + bar/4.,bar,2.);\n    //T.te = t;\n    float env = exp(-T.te*50.);\n    float freq = 400. + 2400. * exp(-T.te*134.);\n    \n    float osc = sin(tau*freq*T.te*0.4 + 0.4*sin(T.te*800.)*exp(-T.te*4.));\n    \n    float oscb = sin(3000.*T.te + sin(7000.*T.te )*exp(-T.te*20.)*1. )*exp(-T.te*24.);\n    \n    float oscc = sin((33000.*exp(-T.te*40.)+ 11000.)*T.te + sin(17000.*T.te )*exp(-T.te*10.)*1. )*exp(-T.te*30.);\n    \n    s += osc*env + oscb*0.4 + oscc*0.1;\n    s -= lpnoise(T.te, 11400.*(0.03 + exp(-T.te*39.4)))*0.4*exp(-T.te*20.);\n    \n    //s = smoothify(s*0.5,0.4);\n    //s = powify(s,1.);\n)\n\nFN(hats,\n    Time T = rep(t,bar,8.);\n    \n    vec2 r = hash21(T.idl);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 2000. * float(chop(t,bar,8.) >= 4.) ;\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*82000.)*exp(-T.te*10.) + \n        2.*sin(T.te*182000. - n*10.)*exp(-T.te*1.) + \n        n * 10.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.4,r.x);\n    \n    s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n)\n\nFN(rides ,{\n    Time T = rep(t,bar,16.);\n    \n    vec2 r = hash21(T.idl);\n    r = vec2(1);\n    //T.te = t;\n    float env = exp(-T.te*(40. - r.y*10.));\n    float freq = 4400. + 1. * exp(-T.te*134.) + 7000. * float(chop(t,bar/4.,16.) >= 8.);\n    vec2 n = lpnoise(T.te, 114400.*(1. + exp(-T.te*9.4)))*0.4*exp(-T.te*40.);\n    \n    vec2 osc = sin(\n        tau*freq*T.te*1. + \n        4.*sin(T.te*12000.)*exp(-T.te*10.) + \n        2.*sin(T.te*12000. - n*10.)*exp(-T.te*1.) + \n        n * 10.\n    );\n    \n    s += osc*env*0.4*smoothstep(0.,0.4,r.x);\n    \n    s = smoothify(s*1.,0.4);\n    //s = powify(s,1.);\n\n})\n\n\nFN(chord,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    for(float i = 0.; i < 4.; i++){\n        float freq = tau*note(chord[int(i)],3. + float(i == 2.));\n        float md = sin(freq*t*3.)*exp(-T.te*13.);\n        float osc = sin(freq*t + md*1.5); \n        s += osc/4.;\n    }\n})\n\nFN(amb,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = chords[0];;\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],4.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*2.3 + t*1.)*8.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.2;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.5); \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*0.2;\n        }\n    }\n    \n\n})\n\n\nFN(chordSupersaw,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    \n    for(float i = 0.; i < 4.; i++){\n        float freq = note(chord[int(i)],3.);\n        //float md = sin(freq*t)*exp(-T.te*14.);\n        //float osc = sin(freq*t + md*4.); \n        //s += osc/4.;\n        \n        float iters = 3.;\n    \n        for(float i = 1.; i < iters; i++){\n            float idx = tau*freq*t + sin(i*10.3 + t*3.)*2.;\n                \n            vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.4;\n            vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n            osc = mix(osc,vec2(sin(idx)),0.);\n            \n\n            //osc = smoothify(osc,vec2);\n            s += osc/iters*1.;\n        }\n    }\n    \n    s *= smoothstep(0.,0.01,T.te);\n    s *= smoothstep(bar/8.,bar/8. - 0.05,T.te);\n\n})\n\n\n\nFN(bass,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1. + 1.*float(mod(T.idl,3.) == 0.));\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 150.;\n    \n    float f = 0.05 + 0.75 * exp(-T.te*(10. + sin(t*tau/beat*0.25)* 25.));// * sin(t*freq*0.5);\n    float wiggle = 0.05;\n    float q = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float k = i < 10. ? i : i*2.;\n        //float k = i;\n        float osc = sin(tau*freq*t*k)*(mod(k,2.)*2. - 1.)/k; \n        if(i == 1.)\n            osc *= 5.;\n        float att = smoothstep(0. + f + wiggle,0. + f - wiggle,i/iters);\n        att *= 1. + smoothstep(wiggle,0.,abs(i/iters - f))*q;\n        s += osc*att;\n    }\n    \n    //s *= 2.;\n    s = mix(s,smoothify(s*1.,1.),0.2 );\n    s = mix(s,clampify(s*0.5,1.),1.);\n\n})\n\nFN(dubstep,{\n\n    Time T = rep(t,bar,8.);\n    \n    vec4 chord = getChord(t);\n    float freq = note(chord[0],1.);\n    float md = sin(freq*t*4.)*exp(-T.te*14.);\n    \n    float iters = 5.;\n    \n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.8 + t*3.)*0.3;\n        \n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.45;\n        vec2 osc = texture(iChannel0,p).xy*2. - 1.; \n        osc = mix(osc,vec2(sin(idx)),0.5); \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*2.;\n    }\n    \n    //s = mix(s,clampifyb(s*1.,1.),0.2);\n    //s *= 2.;\n    //s = mix(s,smoothify(s*1.,2.),1. );\n})\n\n\n\nFN(melody,{\n    Time T = rep(t,bar,16.);\n    \n    vec4 chord = chords[0 + int(T.idg)%4];\n    float freq = note(chord[int(T.idl)%4],3. + 1.*float(mod(T.idl,5.) == 0.)+ 1.*float(mod(T.idl,3.) == 0.));\n    freq *= 0.5;\n    float iters = 1.;\n    for(float i = 0.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*1.;\n        \n        idx += 1.*sin(freq*2.*t*tau)*exp(-T.te*4.);\n        //idx += sin(freq*2.*t*tau)*exp(-T.te*4.);\n        \n        vec2 osc = vec2(sin(idx));\n        \n        osc += sin(freq*4.*t*tau)*exp(-T.te*4.)*0.5;\n        osc += sin(freq*8./1.33*t*tau)*exp(-T.te*4.)*0.25;\n        osc += sin(freq*32.*0.75*t*tau)*0.2;\n        \n        osc = mix(osc,osc*sin(freq*t*tau*0.5)*2.,0.7);\n        //asdg\n        //vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        //vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.3;\n    }\n    /*\n    float iters = 3.;\n    for(float i = 1.; i < iters; i++){\n        float idx = tau*freq*t + sin(i*0.5 + t*1.)*4.;\n        //asdg\n        vec2 p = (vec2(sin(idx),cos(idx + sin(i*1. - t*1.)*0.)) + 1.)*0.3;\n        vec2 osc = texture(iChannel1,p).xy*2. - 1.;\n        //osc = mix(osc,vec2(sin(idx)),0.5); \n        //osc *= 3.;\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        //osc = mix(osc,powify(osc*1.,0.1),0.4 );\n        osc = mix(osc,vec2(sin(idx + sin(idx*3.)*2.*exp(-T.te*1.))),1.-exp(-T.te*5.));\n        \n        osc *= exp(-T.te*4.);\n        \n        \n        //osc = smoothify(osc,vec2);\n        s += osc/iters*0.7; \n    }\n    */\n})\n\n \nvec2 mainSound( int samp, float t ){    \n    \n    gt = t = t + OFFS;\n    \n    vec2 s = vec2(0);\n\n    if(between(t,msr*11.5,msr*12.)){\n        //t = bitreduction(s,0.2);\n        t = sampleratereduction(t, 0.0002);\n    }\n\n\n    //s += sin(t*540.);\n    \n    // --- DRUMS --- //\n    vec2 k = kick(t);\n    reverb(kick,40.,.05,k,0.4);\n    k *= 1.;\n    float sidechain = 1.-exp(-mod(t,bar/4.)*10.);\n    \n    sidechain = abs(sidechain);\n    sidechain = pow(sidechain,4.);\n    vec2 sn = snare(t)*0.7;\n    reverb(snare,150.,.3,sn,0.2);\n    \n    \n    vec2 h = hats(t)*0.5;\n    reverb(hats,30.,.1,h,0.1);\n    \n    \n    vec2 rd = rides(t)*0.3;\n    reverb(rides,30.,.1,rd,0.1);\n    \n    if(t > msr*4.){\n        s += k;\n        s += sn;\n\n        s += h*sidechain;\n        if(t > msr*5.)\n            s += rd*sidechain;\n    } else if(t > msr*1. && t < msr*2. ){\n        s += rd*sidechain;\n    } else if(t > msr*2. && t < msr*3. ){\n        s += h*sidechain;\n    \n    } else if(t > msr*3. && t < msr*4. ){\n        s += h*sidechain;\n        s += sn*mix(\n            0.2,\n            smoothstep(0.,1.,mod(t/msr,1.)),\n            1.\n        );\n    \n    }\n    \n    \n    s = mix(s,smoothify(s*3.,1.),0.1 );\n    s = mix(s,smoothify(s*110.,1.),0.01 );\n    s = mix(s,smoothify(s*10.,0.5),0.06 );\n    \n    \n    // --- MELODY --- //\n    \n    vec2 ml = melody(t)*0.6*mix(1.,sidechain,0.2);\n    if(!(t < msr*3. || t > msr*7.)){\n        ml *= 0.;\n    } \n    float en = smoothstep(0.,1.,(t - msr*8.)/msr);\n    reverb(melody,40.,.2,ml,0.5 + float(t > msr*4.)*0.2*(1. - en) - float(t > msr*4.)*0.2);\n    ml = ml * smoothstep(0.,50.,t/msr) * (1.-float(t > msr*4.)*pow(1.-en,4.));\n    \n    if(t < msr*12.)\n        s += ml;\n    \n    \n    \n    //chorus(melody,2.,ml,0.5,0.2);\n    //s += ml*pow(sidechain,0.5)*1.;\n    \n    \n    vec2 ch = chord(t)*0.3;\n    chorus(chord,4.,ch,0.5,0.2);\n    vec2 chss = chordSupersaw(t)*0.3;\n    chorus(chordSupersaw,4.,chss,0.5*smoothstep(0.,1.,t/msr),0.2);\n    chss *= 0.5;\n    \n    \n    //reverb(chordSupersaw,10.,1.,chss,0.8);\n    \n    \n    if( chop(t,bar,4.) > 1. ){\n        if( (t > msr*6. && t < msr*8.) || (t > msr*3. && t < msr*3.75 ))\n            s += ch*sidechain*1.;\n    } else {\n        s += chss*pow(sidechain,2.)*1.;\n    \n    }\n    \n    vec2 a = amb(t);\n    \n    reverb(amb,10.,1.,a,1.);\n    s += a*1.*smoothstep(0.,msr,t - msr*3.)*float(t > msr*3.&& t < msr*4.);\n    \n    \n    // --- BASS --- //\n    \n    vec2 bs = bass(t)*0.4;\n    //chorus(bass,4.,bs,0.1);\n    \n    vec2 dbbs = dubstep(t)*0.4;\n    \n    if(between(t,msr*12.,msr*20.)){\n        if( chop(t,bar/1.,2.) > 0. ){\n            s += bs*pow(sidechain,1.5)*1.;\n        } else {\n            s += dbbs*sidechain*1.;\n        }\n    } else if(t > msr*4.){\n        \n        if( chop(t,bar,4.) < 3. ){\n            s += bs*pow(sidechain,1.5)*1.;\n        } else {\n            s += dbbs*sidechain*1.;\n        }\n    }\n    \n    \n    \n    \n    // --- MIX --- //\n    \n    s = mix(s,clampifyb(s,0.6)*1.,0.4);\n    \n    if(t < msr*4.){\n        s *= 0.8*(1.-0.*smoothstep(0.99,1.,t/(msr*4.)));\n    }\n    \n    float eee = smoothstep(0.,msr,t - msr*3.);\n    \n    // AM\n    if(t < msr*7.99)\n        s *= mix(1.,sin(t*(200.)),pow(smoothstep(0.,msr,t - msr*7.),3.));\n    \n    if(t < msr*4.)\n        s *= mix(1.,sin(t*(200. + eee*1500.)),pow(smoothstep(0.,msr,t - msr*3.),4.));\n    \n    \n    \n        \n        \n    s *= 0.6;\n    float clip = 1.;\n    s = clamp(s,-clip,clip)*clip;\n    s *= smoothstep(0.1,0.4,t);\n    //s = sign(s)*pow(abs(s),vec2(0.5));\n    return s;\n}", "sound_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n\n#define OFFS msr*0.\n\n\n\n#define reverb(fn, iters, len, varname, amt) \\\n{                                       \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        float nois =  pow(i/iters,4.)*lpnoise(i/iters+1100., 11111.).x; \\\n        res += fn(t - (i/iters)*len - abs(nois)*0.2*len)/iters*pow(i/iters,2.)*(1.-i/iters); \\\n    }\\\n    varname = mix(varname,res/mix(1.,0.5,amt)*10.,amt); \\\n}\n\n#define chorus(fn, iters, varname, amt, len) \\\n{ \\\n    vec2 res = vec2(0);                 \\\n    for(float i = 0.; i < iters; i++){   \\\n        res += fn(t - sin(i/iters*pi*4.*t*0.001*len)*1.)/iters; \\\n    }\\\n    varname = mix(varname,res,amt); \\\n}\n\n\n#define PI acos(-1.)\n#define pi PI\n#define tau 2.*pi\n\n#define between(t,mn,mx) (t > mn && t < mx)\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/(amt))*(amt)\n#define sampleratereduction(t, amt) t = floor(t/(amt))*(amt)\n//#define smoothify(s, amt) mix(s,sign(s)*smoothstep(0.0,1.,abs(s)), amt)\n#define clampify(s, amt) clamp(s*amt,-1.,1.)/amt\n#define clampifyb(s, amt) clamp(s,-amt,amt)/amt\n\n#define smoothify(s, amt) sign(s)*mix(abs(s),smoothstep(0.,1.,s), amt)\n\n#define powify(s, amt) sign(s)*pow(abs(s),vec2(amt))\n\n\n#define bpm (150.)\n\n#define tick (60./bpm)\n\n#define beat (tick)\n#define bar  (beat*4.)\n#define hbar  (bar/2.)\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n\n#define chop(t,bt,reps) mod(floor(t/(bt/reps)), reps)\n\n\n#define FN(name, code) vec2 name(float t) { \\\n    vec2 s = vec2(0); \\\n    code \\\n    return s; \\\n}\n\n\n\nstruct Time {\n    float tt;\n    float te;\n    float idl;\n    float idg;\n};\n\nTime rep(float t, float period, float reps){\n    Time data;\n    float per = period/reps;\n    data.te = mod(t,per);\n    data.idl = mod(floor(t/per),reps);\n    data.idg = floor(t/period);\n        \n    return data;\n}\n\n\n\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat[] notesLB = float[8](2.,1.,0.,2.,0.,2.,0.,3.);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst float scale = -4.;\n\nconst vec4 cmin9 = vec4(0.,3.,10.,14.) + scale;\n\nconst vec4 cmin510 = vec4(0.,7.,10.,12.) + scale;\nconst vec4 cmin7 = vec4(0.,3.,7.,10.) + scale;\nconst vec4 cmin73 = vec4(0.,7.,10.,3.) + scale;\nconst vec4 cmin11 = vec4(0.,10.,14.,17.) + scale;\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.) + scale;\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.) + scale;\nconst vec4 cmaj14 = vec4(0.,4.,11.,12. + 7.) + scale;\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.) + scale;\nconst vec4 cmaj7d = vec4(0.,4.,7.,10.) + scale;\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.) + scale;\n\nconst int chordCnt = 8;\n\n\nvec4[] chords = vec4[chordCnt](\n    cmaj9 - 4.,\n    cmin73 - 7.,\n    cmin11 - 5.,\n    cmin7,\n    cmin11,\n    cmaj14 + 1. - 7.,\n    cmaj7 - 1.,\n    cmaj7 - 5.\n);\n\nvec4[] chordsbb = vec4[chordCnt](\n    cmin11,\n    cmaj14 + 2. - 7.,\n    cmin7 - 2.,\n    cmaj7 + 1.,\n    cmaj14 - 3.,\n    cmaj7f15 + 3.,\n    cmin9 + 2. - 4.,\n    cmaj7f15 - 4.\n);\n\nvec4[] chordsb = vec4[chordCnt](\n    cmin9,\n    cmaj7 + 1.,\n    cmaj7f15 - 2.,\n    cmaj7 - 3.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 4.\n);\nvec4[] chordsa = vec4[chordCnt](\n    cmin9,\n    cmaj7f15 - 2.,\n    cmaj9 - 3.,\n    cmin7maj - 5.,\n    cmaj14 - 2.,\n    cmaj7f15 + 3.,\n    cmaj9 - 1.,\n    cmaj7f15 - 2.\n);\n\nvec4 getChord(float t){\n    return chords[ int(t / bar) % 4];\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = floor(t);\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = hash21(tn / fq*2000.);\n    vec2 n1 = hash21((tn + 1.0) / fq*2000.);\n\n    return mix(n0, n1, ft)*2. - 1.;\n}\n\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 122, 146, 870], [879, 879, 936, 997, 1297]]}
{"id": "Nlsczj", "name": "worm sine", "author": "FabriceNeyret2", "description": "reproducing Yugemaku's animation ; https://twitter.com/i/status/1498298813638844421", "tags": ["2d", "2tweets", "short", "reproduction"], "likes": 45, "viewed": 753, "published": 3, "date": "1648319564", "time_retrieved": "2024-07-30T16:56:45.647545", "image_code": "#define S(v) smoothstep(1.5,0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n    float x =  3.5*U.x, t = iTime,\n          v = U.y +.2 - .1*sin(3.14*( x+t ) ),\n          s = U.y -.1 + .2*sin(3.14*2./3.*( x + .5* sin ( 3.14/3.*( x + 3.*t ) ) ) );\n          \n    O =             .5  * S( v/fwidth(v) ) \n        + vec4(0,1,1,0) * S( abs(s)/fwidth(s) -1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlsczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 75, 75, 417]]}
{"id": "fllyRj", "name": "nubes II", "author": "jorge2017a2", "description": "nubes II", "tags": ["nubesii"], "likes": 5, "viewed": 188, "published": 3, "date": "1648307335", "time_retrieved": "2024-07-30T16:56:46.697738", "image_code": "//----------image\n//por jorge2017a2-\n//referencia\n\n////https://www.shadertoy.com/view/lsBfDz.......Created by stubbe in 2017-07-15\n//https://glslsandbox.com/e#78741.0\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    p.y=p.y-5.0;\n    float sds1=sdSphere(p-vec3(0.0,abs(5.0*sin(iTime)),0.0) , 5.0 );\n    res =opU2(res, vec2(sds1,60.0));\n    \n    float d2=sdSphere(p-vec3(10.0,0.0,0.0), 5.0 );\n    res =opU2(res, vec2(d2,58.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    float shadow = getSoftShadow(hit, normalize(lightPos));// shadows\n    float occ = occlusion(hit, norm);// occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0)*norm.y;\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n    \n   if (id_color==60)\n   {   vec3 mat = vec3(0.8, 0.2, 0.2);\t\n\t\tfloat f = smoothstep(0.3, 0.3001, mod(atan(p.x, p.z), 0.65));\n        mat = mix(mat, vec3(0.7, 0.7, 0.8), 1.0 - f);\n        return mat;\n   }\n\n   if (id_color==57)\n    { return Humo( p.xz*0.25, iTime ); }\n   \n   if (id_color==58)\n        {return Humo( p.xy, iTime );}\n   \n            \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n//https://www.shadertoy.com/view/lsBfDz.......Created by stubbe in 2017-07-15\n#define T texture(iChannel0,(s*p.zw+ceil(s*p.x))/2e2).y/(s+=s)*4.\nvec3 nubes(vec2 x)\n{\n    vec4 p,d=vec4(.8,0,x/iResolution.y-.8),c=vec4(.6,.7,d);\n    vec4 O;\n    O=c-d.w;\n    for(float f,s,t=2e2+sin(dot(x,x));--t>0.;p=.05*t*d)\n        p.xz+=iTime,\n        s=2.,\n        f=p.w+1.-T-T-T-T,\n    \tf<0.?O+=(O-1.-f*c.zyxw)*f*.4:O;\n  \n  return O.xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    \n    vec3 col2= nubes(fragCoord-vec2(0.0,-30.0));\n    col=mix(col,col2, 0.6 );\n    // col=col2;\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n\n\n\n///---------\n//https://glslsandbox.com/e#78741.0\n#define NUM_OCTAVES 10\n\nmat3 rotX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, -s,\n\t\t0, s, c\n\t);\n}\nmat3 rotY(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat3(\n\t\tc, 0, -s,\n\t\t0, 1, 0,\n\t\ts, 0, c\n\t);\n}\n\nfloat random(vec2 pos)\n{ return fract(sin(dot(pos.xy, vec2(1399.9898, 78.233))) * 43758.5453123); }\n\nfloat noise(vec2 pos) {\n\tvec2 i = floor(pos);\n\tvec2 f = fract(pos);\n\tfloat a = random(i + vec2(0.0, 0.0));\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 pos) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100.0);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tfor (int i=0; i<NUM_OCTAVES; i++) {\n\t\tv += a * noise(pos);\n\t\tpos = rot * pos * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 Humo( in vec2 fragCoord , float ptime)\n{\n\t//vec2 p = (gl_FragCoord.xy * 3.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 p =fragCoord;\n\tfloat t = 0.0, d;\n\tfloat time2 = 3.0 * ptime / 2.0;\n\n\tvec2 q = vec2(0.0);\n\tq.x = fbm(p + 0.00 * time2);\n\tq.y = fbm(p + vec2(1.0));\n\tvec2 r = vec2(0.0);\n\tr.x = fbm(p + 1.0 * q + vec2(1.7, 9.2) + 0.15 * time2);\n\tr.y = fbm(p + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time2);\n\tfloat f = fbm(p + r);\n    \n    \n    vec3 color = mix(\n\t\tvec3(1., 1.0, 1.0),\n\t\tvec3(.2, 0.2, 0.866667),\n\t\tclamp((f * f) * 4.0, 0.0, 1.0)\n\t);\n    \n    \n    color = mix(\n\t\tcolor,\n\t\tvec3(0.0, 0.0, 1.5),\n\t\tclamp(length(q), 0.0, 1.0)\n\t);\n    \n    \n    color = mix(\n\t\tcolor,\n\t\tvec3(1.0),\n\t\tclamp(length(r.x), 0.0, 1.0)\n\t);\n    \n\n\tcolor = (f *f * f + 0.6 * f * f + 0.5 * f) * color;\n\n\t//fragColor = vec4(color, 1.0);\n    return color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 629, 665, 665, 686], [689, 689, 736, 736, 763], [764, 764, 807, 807, 834], [835, 835, 883, 883, 911], [913, 913, 938, 938, 1296], [1298, 1298, 1322, 1322, 1484], [1486, 1486, 1534, 1534, 1840], [1843, 1843, 1887, 1887, 2205], [2207, 2207, 2244, 2244, 2501], [2503, 2503, 2588, 2588, 3523], [3525, 3525, 3618, 3618, 3748], [3750, 3750, 3782, 3782, 3979], [3982, 3982, 4052, 4052, 4501], [4503, 4503, 4530, 4530, 4619], [4621, 4621, 4679, 4679, 4727], [4729, 4729, 4752, 4752, 4864], [4866, 4866, 4897, 4897, 5517], [5663, 5663, 5683, 5683, 5943], [5946, 5946, 6003, 6003, 6491]]}
{"id": "NllyRj", "name": "reflect n5", "author": "jorge2017a2", "description": "reflect n5", "tags": ["reflectn5"], "likes": 4, "viewed": 273, "published": 3, "date": "1648307325", "time_retrieved": "2024-07-30T16:56:47.936426", "image_code": "//cambios por jorge flores p.---->jorge2017a2\n//23-feb-2022\n///referencia y fork\n//https://www.shadertoy.com/view/MtlfRs.....by zackpudil in 2017-12-11\n//---------image------\n#define MIN_DIST 0.001\n#define MAX_DIST 120.\n#define MAX_STEPS 100\n#define PI 3.1415926535\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  )\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,58.0,-1.0)); //inf\n          p.y=p.y-5.0;\n   \n   vec3 p1=p-vec3(0.0,0.0,0.0);\n   vec3 p2=p-vec3(14.0,3.0,15.0);\n   vec3 p3=p-vec3(7.0,0.0,15.0);\n   \n   p1.x=opRep1D(p1.x,40.0);\n   p1.z=opRep1D(p1.z,40.0);\n   \n   p2.z=opRep1D(p2.z,40.0);\n   p2.x=opRep1D(p2.x,30.0);\n   \n   p3.z=opRep1D(p3.z,30.0);\n   p3.x=opRep1D(p3.x,30.0);\n   \n   float sdsp1= sdSphere( p1, 6.0 );\n   float sdsp2= sdSphere(p2, 6.0 );\n   float sdsp3= sdSphere(p3, 3.0 );\n   \n    res =opU3(res, vec3(sdsp1,203.0,-1)); \n    res =opU3(res, vec3(sdsp2,201.0,-1)); \n    res =opU3(res, vec3(sdsp3,5.0,-1)); \n    return vec2(res.x, res.y);\n   \n}\n\n// basic trace, with some LOD\nvec2 RayMarch(vec3 ro, vec3 rd, float m) {\n    float t;\n\tvec2 d = vec2(9999.0,-1.0);\n    \n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\td = GetDist(ro + rd*t);\n\t\tif(d.x < (0.001 + 0.0001*t) || t >= m) break;\n        t += d.x*0.67;\n\t}\n\treturn vec2(t,d.y);\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p,vec3 lp,vec3 rd, vec3 ro, vec3 color )\n{   vec3 lightPos=lp;\n    vec3 hit=p;\n    vec3 norm=normal;\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = ambOcclusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\n\nvec3 GetColor(vec3 p, float id_color)\n{  vec3 color=vec3(0.0); \n   if(id_color<50.0)\n   { color=getColor(int(id_color)); }  \n        \n   if(id_color==57.0)\n   { color =vec3(1.0)*( 0.2 + 0.5*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0));}\n   \n   if(id_color==58.0)\n   {   if ( (  mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0) )>0.0 )\n           color=vec3(0.0);\n       else  color=vec3(0.3,0.82,0.25);\n    }\n   \n    if(id_color==203.0)\n    {  color=getColor(int(2)); } \n   \n    if(id_color==204.0)\n   { color=getColor(int(4)); } \n   \n   return color;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{  vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig1 = normalize(vec3(10.8, 10.0, -15.6));\n    vec3 lig2 = normalize(vec3(0.0, 60., 25.6));\n    vec2 t;\n    vec3 rcol = vec3(0);\n    \n    \tfor(int i = 0; i < 3; i++) {\n\t\t t = RayMarch(ro, rd, MAX_DIST);\n\t\tif(t.x < MAX_DIST) \n        {   // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t.x;\n\t\t\tvec3 nor = GetNormal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n            vec3 posrf = ref + rd*0.0035;\n            vec3 refr = refract(posrf, -nor,1.0/1.52);\n            \n              vec3 color= GetColor(pos,t.y);\n            \n                   \n                rcol= lightingv3(nor,pos,lig1,rd, ro, color );\n                rcol+= lightingv3(nor,pos,lig2,rd, ro, color );\n                rcol/=2.0;\n            // set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor*0.001;\n            \n            if (t.y==201.0) { rd = ref;}\n            \n            if (t.y==203.0) { rd = refr;}\n            \n            if (t.y==204.0){ rd = ref;}\n               \n    \t\tif(i == 0) col = rcol;\n\t\t\telse  col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t\t}\n        else if(t.x>MAX_DIST)\n        col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n\t}\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,10.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.0,15.0,-20.0);\n    vec3 rd=normalize(vec3(p,1.0));\n    rd= rotate_x(rd, radians(20.0));\n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    vec3 col= render(ro, rd);\n \tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "struct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 398, 398, 419], [421, 421, 457, 457, 502], [508, 533, 567, 567, 663], [664, 664, 698, 698, 789], [790, 790, 824, 824, 915], [917, 917, 941, 941, 1676], [1678, 1708, 1750, 1750, 1958], [1960, 1960, 1984, 1984, 2147], [2149, 2149, 2193, 2193, 2510], [2512, 2512, 2552, 2552, 2809], [2811, 2832, 2862, 2862, 2995], [2997, 2997, 3029, 3029, 3226], [3228, 3228, 3303, 3303, 4261], [4264, 4264, 4303, 4303, 4812], [4814, 4814, 4846, 4846, 6079], [6082, 6082, 6109, 6109, 6198], [6200, 6200, 6258, 6258, 6306], [6309, 6309, 6332, 6332, 6450], [6452, 6452, 6489, 6489, 6759], [6761, 6761, 6819, 6819, 7186]]}
{"id": "slXyzj", "name": "Webcam cel shader", "author": "aviii", "description": "cel shader with webcam", "tags": ["celshader"], "likes": 2, "viewed": 411, "published": 3, "date": "1648293402", "time_retrieved": "2024-07-30T16:56:48.842005", "image_code": "#define SHADES 3.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float Pi = 6.283185307187; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS \n    // applying gaussian blur is important as otherwise the output\n    // will be extremly pixelated{{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 6.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel1, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    \n \n\tfragColor = Color;\n    float intensity = (fragColor.r + fragColor.g + fragColor.b) / 3.;   //Maybe use dot(dirOfLight, surfaceNormal)\n\tfloat shade = floor(intensity * float(SHADES));\n\tfloat brightnessOfShade = shade / float(SHADES);\n\tfloat factor = intensity / brightnessOfShade;\n\tfragColor.rgb /= vec3(factor);\n    vec3 edgeColor = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(((1.0 - edgeColor) * fragColor.rgb),1.0);\n    //fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define emboss mat3(-2, -1, 0, -1, 1, 1, 0, 1, 2)\n#define sobelX mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1)\n#define sobelY mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1)\n#define gaussian mat3(0.0625,0.125,0.0625,0.125,0.25,0.125,0.0625,0.125,0.0625)\nvec2 kpos(int index)\n{\n    return vec2[9] (\n    \tvec2(-1, -1),    \n        vec2(0, -1),\n        vec2(1, -1),\n        vec2(-1, 0),\n        vec2(0, 0),\n        vec2(1, 0),\n        vec2(-1, 1),\n        vec2(0, 1),\n        vec2(1, 1)\n    )[index] / iResolution.xy;\n}\n\nmat3[3] region3x3(sampler2D sampler, vec2 uv)\n{\n    // Create each pixels for region\n    vec4[9] region;\n    \n    //\n    for (int i = 0; i < 9; i++)\n        region[i] = texture(sampler, uv + kpos(i));\n\n    // Create 3x3 region with 3 color channels (red, green, blue)\n    mat3[3] mRegion;\n    \n    for (int i = 0; i < 3; i++)\n        mRegion[i] = mat3(\n        \tregion[0][i], region[1][i], region[2][i],\n        \tregion[3][i], region[4][i], region[5][i],\n        \tregion[6][i], region[7][i], region[8][i]\n    \t);\n    \n    return mRegion;\n\n}\n\nvec3 convolution(mat3 kernel, sampler2D sampler, vec2 uv)\n{\n    vec3 fragment;\n    \n    // Extract a 3x3 region centered in uv\n    mat3[3] region = region3x3(sampler, uv);\n    \n    // for each color channel of region\n    for (int i = 0; i < 3; i++)\n    {\n        // get region channel\n        mat3 rc = region[i];\n        \n        // component wise multiplication of kernel by region channel\n        mat3 c = matrixCompMult(kernel, rc);\n        \n        // add each component of matrix\n        float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n        \n        // for fragment at channel i, set result\n        fragment[i] = r;\n    }\n    \n    return fragment;    \n\n}\n\nvec3 postConvulsion(mat3 kernel, mat3 picture)\n{\n    vec3 fragment;\n    mat3 c = matrixCompMult(kernel, picture);\n    float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n    return vec3(r);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    vec3 colX = convolution(sobelX, iChannel0,uv);\n    vec3 colY = convolution(sobelY, iChannel0,uv);\n    \n    vec3 col=vec3(dot(colX,colX)+dot(colY,colY));\n    \n    //vec3 col = convolution(gaussian, iChannel0, uv);\n    \n    //vec4 color = texture(iChannel0,uv);\n    //col = vec3(color.r,color.g,color.b);\n    fragColor = vec4(col,1.0f);\n    \n    //fragColor = texture(iChannel1,uv);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 1487]]}
{"id": "flXcz2", "name": "Mandelbrot on Riemann sphere", "author": "Fraktoler", "description": "Mandelbrot set is mapped to the Riemann sphere via Stereographic projection, rotated it and mapped back to the complex plane.", "tags": ["fractal", "mandelbrot", "sphere", "projection", "stereographic", "riemann"], "likes": 7, "viewed": 323, "published": 3, "date": "1648283226", "time_retrieved": "2024-07-30T16:56:49.742597", "image_code": "vec2 cis(float theta) {\n    //Euler's formula\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    //Complex multiplication\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec3 rotate(vec3 p, vec3 rot) {\n    vec2 v = mul(p.yz, cis(rot.x));\n    vec3 p_prime = vec3(p.x, v.xy);\n    v = mul(p_prime.xz, cis(rot.y));\n    p_prime = vec3(v.x, p_prime.y, v.y);\n    v = mul(p_prime.xy, cis(rot.z));\n    p_prime = vec3(v.xy, p_prime.z);\n    return p_prime;\n}\n\nvec2 nearestObject(vec3 ro, vec3 rd) {\n    // Outputs vec2(nearest distince to object, type of object)\n\n    //https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n    float planeDist = -ro.z / rd.z;\n\n    //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\n    float b = dot(rd, ro);\n    float delta = b * b - dot(ro, ro) + 1.0;\n    if (delta < 0.0) {\n        return vec2(planeDist, 0.0);\n    } else {\n        float sphereDist = sqrt(delta);\n        sphereDist = min(sphereDist, -sphereDist) - b;\n        if (planeDist < 0.0) {\n            return vec2(sphereDist, 1.0);\n        } else {\n            if (planeDist < sphereDist) {\n                return vec2(planeDist, 0.0);\n            } else {\n                return vec2(sphereDist, 1.0);\n            }\n        }\n    }\n}\n\nfloat DE(vec3 p) {\n    return min(length(p) - 1.0, p.z);\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float max_dist = 1000.0;\n    float min_dist = 0.0001;\n    float dist = 0.0;\n    float steps = 0.0;\n    for (int m = 0; m < 96; m++) {\n        vec3 p = ro + dist * rd;\n        float DE = DE(p);\n        dist += DE;\n        if (dist > max_dist || DE < min_dist) break;\n        steps += 1.0;\n    }\n    return steps;\n}\n\nfloat mandelbrot(vec2 c) {\n    vec2 z = c;\n    float k = 0.0;\n    for (int i = 0; i < 50; i++) {\n        if (dot(z, z) > 4.0) break;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        k += 1.0;\n    }\n    return k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.x - vec2(0.5, iResolution.y / iResolution.x * 0.5)) * 4.0;\n    \n    vec3 camAngle = vec3(-0.5, 0.0, iTime * 0.2);\n    vec3 ro = rotate(vec3(0.0, -3.0, 0.0), camAngle);\n    vec3 rd = rotate(normalize(vec3(uv.x, 1.0, uv.y)), camAngle);\n    vec3 angle = vec3(iTime * 0.5, 0.0, 0.0);\n    \n    //https://en.wikipedia.org/wiki/Stereographic_projection#First_formulation\n    vec2 nearest = nearestObject(ro, rd);\n    vec3 p = ro + nearest.x * rd;\n    float iter = 0.0;\n    vec3 sphere = vec3(0.0);\n    float product = 0.0;\n    if (nearest.y == 0.0) {\n        product = dot(p.xy, p.xy);\n        sphere = rotate(vec3(2.0 * p.xy, product - 1.0) / (product + 1.0), angle);        \n        iter = mandelbrot(sphere.xy / (1.0 - sphere.z));\n    } else {\n        sphere = rotate(p, angle);\n        iter = mandelbrot(sphere.xy / (1.0 - sphere.z));\n    }\n    \n    if (nearest.x < 0.0) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        vec3 col = vec3(iter / 50.0 - raymarch(ro, rd) / 128.0);\n\n        // Output to screen\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 45, 88], [90, 90, 116, 145, 191], [193, 193, 224, 224, 470], [472, 472, 510, 643, 1265], [1267, 1267, 1285, 1285, 1325], [1327, 1327, 1361, 1361, 1679], [1681, 1681, 1707, 1707, 1915], [1917, 1917, 1974, 1974, 3074]]}
{"id": "NlXcR2", "name": "Basic menger pathtracer v2", "author": "El_Sargo", "description": "A simple path-traced fractal, fixing many of the mistakes from my previous attempt. Bow bounce lighting actually works and I used  better rng. Also applied some post.", "tags": ["3d", "raymarching", "gi", "path"], "likes": 5, "viewed": 279, "published": 3, "date": "1648266736", "time_retrieved": "2024-07-30T16:56:50.818719", "image_code": "//The actual rendering is in buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv)/float(iFrame);\n    col = col*exp(vec4(1.1,1.05,1.2,1. ));\n    fragColor = smoothstep(-0.,1.,col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 sun = normalize(vec3(0.2,0,-1.)); // The direction of the sunlight\nconst vec3 suc = vec3(1.,0.7,0.3); // sunlight color\nconst float unIntersect = 0.001; // don't touch this\nconst int iter = 6; // number of GI bounces\nconst float bou_coef = 4.; // intensity of bounce light\nconst float sun_coef = 2.2; // intensity of sun light\nconst float amb_coef = 1.5; // intensity of ambient light\n//Dosn't actually need an array, just makes it easer to use many materials\n// Pbr also wasn't implemented\nconst vec3[] colors = vec3[](vec3(0.),vec3(0.25));\n\n//ambient light color\nvec3 amb(vec3 rd){\n    return clamp(vec3(vec2(0.8,0.9)*(1.1-rd.y*rd.y*rd.y),1.),vec3(0.),vec3(1.));\n}\n\n#define rotations\n\n//Heavy performance impact \n#define raymarchSteps 60\n\n#define ZERO min(iFrame, 0)\n\n//SDF stuff....\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// rotation matrix\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\n\n// transfrom a point to from a fractal\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n// distance to a fractal\n// yes you can use a loop, but I wanted controll over the rotations\nvec4 map(vec3 p) {\n\n    const float scale = 260.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(2.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(5.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(2.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.512);\n    p = trans(p, 3.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 1.);\n    p.zy*=rotate(0.1);\n    #else\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale-0.001, p);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// For the fractal\nfloat intersection(vec3 ro, vec3 rd){\n    float dist;\n    float T;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro+rd*T).x;\n        T+=dist;\n        if (dist < 0.00001 || dist > 2.)\n            break;\n    }\n    \n    return T;\n\n}\n\n// Hash function\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n\n//Random direction\nvec3 hash3( vec3 p )\n{\n    p+=iTime*vec3(0.8,0.5,-2.);\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn normalize(fract(sin(p)*43758.5453123)-0.5);\n}\n\nvec3 ranReflect(vec3 inc, vec3 nor, float r){\n    vec3 ref = reflect(inc,nor);\n    vec3 ran = hash3(inc+nor);\n    ran *= sign(dot(ran,nor));\n    \n    vec3 dir = mix(reflect(inc,nor), ran, r);\n    \n    return normalize(dir);\n}\n\nstruct world {\n    int  id;\n    vec3 pos;\n    vec3 nor;\n    float dis;\n};\n\nworld wolrdIntersect(vec3 ro, vec3 rd){\n    vec3 nor = vec3(0);\n    float d = 10e10;\n    int id = 0;\n    //fractal\n    {\n        float md = intersection(ro,rd);\n        if (map(ro+rd*md).x < 0.1 && md < d){\n            id = 1;\n            nor = calcNormal(ro+rd*md);\n            d = md;\n        }\n    }\n    /*//ball\n    {\n        vec3 ce = vec3(0,-0.32,-.97);\n        float bd = sphIntersect(ro, rd, ce, 0.05).x;\n        if (bd > -0.1 && bd < d){\n            id = 2;\n            nor = normalize(ce-ro+bd*rd)*-1.;\n            d = bd;\n        }\n    }*/\n    return world(id,ro+d*rd,nor, d);\n}\n\n//Trace a path away from the shape and return 1 if we hit nothing\nfloat getShadow(vec3 p, vec3 rd){\n    rd = normalize(rd+ hash3(rd+p)*0.1);\n    p+=unIntersect*rd;\n    return wolrdIntersect(p, rd).id == 0 ? 1. : 0.;\n}\n\n//Shadow ray in a random direction\nvec3 getAmbiance(vec3 p, int i){\n    vec3 rd = hash3(p+float(i*i));\n    \n    return getShadow(p+unIntersect*rd,rd)*amb(rd);\n}\n\nstruct ligt {\n    vec3 scl;\n    float sha;\n    vec3 amb;\n\n};\nvec3 render(vec3 ro, vec3 rd){\n    vec3 dir = rd;\n    vec3 p = ro;\n    \n    ligt[iter] lig;\n    //Get light\n    for (int i=0;i<iter;i++){\n\n        world w = wolrdIntersect(p+dir*.05, dir);\n        float sha = getShadow(w.pos, sun);\n\n        //Colors\n        if (w.id==0){\n            if (i==0)\n                //Sky\n                return 0.3*amb(dir);\n             else {\n                break;\n            }\n        }\n        \n        vec3 am = vec3(0.);\n        for(int a=0;a<1;a++){\n            am += getAmbiance(w.pos,a)*2.;\n        }\n        \n        lig[i] = ligt(colors[w.id], sha, am);\n        \n        dir = hash3(p+w.pos+dir);\n        dir *= sign(dot(w.nor,dir));\n\n        p = w.pos;\n\n\n    }\n    vec3 col = vec3(0);\n    for (int i=iter-1;i>-1;i--) {\n    \n         vec3 scl = lig[i].scl;\n         float sha = lig[i].sha;\n         vec3 am = lig[i].amb;\n         \n          //prevoius bounce\n          col = col*scl*bou_coef+\n                //sun light\n                scl*sha*suc*sun_coef+\n                //ambient light\n                scl*am*amb_coef;\n\n    }\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = hash3(vec3(uv, iTime)).xz/iResolution.xy*0.5;\n    vec3 rd = normalize(vec3(\n            (uv-0.5)*vec2(1.,iResolution.y/iResolution.x)+o,\n            1.));\n    rd.xz *= rotate(.25);\n    rd.yz *= rotate(0.3);\n\n    vec3 ro = vec3(0.,-0.3,-1.);\n\n    vec3 col = render(ro,rd);\n    \n    vec3 prev = texture(iChannel0, uv).xyz;\n    \n    col += prev;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 274]]}
{"id": "NtlcRB", "name": "Bandoran #1", "author": "DrFuehrer", "description": "For a DJ Helmet", "tags": ["music"], "likes": 3, "viewed": 339, "published": 3, "date": "1648223218", "time_retrieved": "2024-07-30T16:56:51.581679", "image_code": "vec2 position(float z) {\n\treturn vec2(0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat camZ = 25.0 * iTime;\n\tvec2 cam = position(camZ);\n\n\tfloat dt = 0.5;\n\tfloat camZ2 = 25.0 * (iTime + dt);\n \tvec2 cam2 = position(camZ2);\n\tvec2 dcamdt = (cam2 - cam) / dt;\n\t\n\tvec3 f = vec3(0.0);\n \tfor(int j = 1; j < 30; j++) {\n\t\tfloat i = float(j);\n\t\tfloat realZ = floor(camZ) + i;\n\t\tfloat screenZ = realZ - camZ;\n\t\tfloat r = 10.0 / screenZ;\n \t\tvec2 c = (position(realZ) - cam) * 10.0 / screenZ - dcamdt * 10.0;\n\t \tvec3 color = (vec3(sin(realZ * 0.07), sin(realZ * 0.1), sin(realZ * 0.08)) + vec3(1.0)) / 1.0;\n \t\tf += color * 0.06 / screenZ / (abs(length(p - c) - r) + 0.01);\n\t}\n\n\tfragColor = vec4(f, 1.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlcRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 46], [48, 48, 105, 105, 802]]}
{"id": "fdffDs", "name": "Scientific Sky Simulation", "author": "blackholes", "description": "//Just suppose the earth is a plane in Rectangular Coordinates,and the atmosphere is a layer endlessly \n//nestle up to the ground.\n//The effect is like this.", "tags": ["sunset", "sun", "light", "sky", "effect", "glass", "sunlight", "shader", "atmosphere", "sunrise", "atmospheric", "grassland", "meadow", "lawn", "meadowland"], "likes": 6, "viewed": 526, "published": 3, "date": "1648217703", "time_retrieved": "2024-07-30T16:56:52.337658", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat pi=3.1415926535;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nfloat ax=2.0*pi*uv.x;  \nfloat ay=-pi*(0.5-uv.y); \nfloat h =1.0/8.0;\n     //Distance of observation line in atmosphere\n     float D = h/sin(ay);\nfloat sky= 1.0-exp(-0.44975*D*8.0); \n\n    vec3 col = 9.2*vec3(sky,sky,sky);\n//Latitude\n   float beta = pi/6.0; \n   //地球的自转\n   float spin = 0.2/2.0*iTime;\n   //Horizontal angle\n   float sunax;\n    if(sin(spin)<.0) sunax=-acos((cos(spin))/(sqrt(cos(spin)*cos(spin)+sin(beta)*sin(beta)*sin(spin)*sin(spin))));\n    else sunax=acos((cos(spin))/(sqrt(cos(spin)*cos(spin)+sin(beta)*sin(beta)*sin(spin)*sin(spin))));\n   //Vertical angle\nfloat sunay=asin(cos(beta)*sin(spin)); \n//The length of sunlight passing through the atmosphere\n  float d = h/sin(sunay);\nvec3 suncolor = vec3(exp(-0.1666*d),exp(-0.44975*d),exp(-1.10894776*d));\n//Given the spherical coordinates of 2 points,caculate the angle between the two points\nfloat alpha=acos(cos(ay)*cos(sunay)*cos(ax-sunax)+sin(ay)*sin(sunay));\n//Mie scattering coefficient\nfloat G1 = 0.25;\nfloat G2 = 0.55;\nfloat G3 = 0.75;\nfloat G4 = -0.5;\n//Mie scattering formula\n float mie1 = 0.95*(1.0-G1*G1)/(1.0+G1*G1-2.0*G1*cos(alpha));\n float mie2 = 0.95*(1.0-G2*G2)/(1.0+G2*G2-2.0*G2*cos(alpha));\n float mie3 = 0.95*(1.0-G3*G3)/(1.0+G3*G3-2.0*G3*cos(alpha));\n float mie4 = 0.95*(1.0-G4*G4)/(1.0+G4*G4-2.0*G4*cos(alpha));\n col = sin(sunay)*col*(1.0-suncolor);\n col+=1.3*suncolor*(0.5*mie1+2.0*mie2+0.5*mie3+0.85*mie4)/3.85*(1.0-exp(-0.225*1.5*D));\n     float n = 0.0225/2.0;\n    //Micodustamount\n    float n2 = 1.5225/2.0;\ncol= col*vec3(exp(-D*(5.0*n+0.25*n2)),exp(-D*(5.0*n+0.51*n2)),exp(-D*(5.0*n+1.17*n2)))+suncolor*sin(sunay)*vec3(1.0-exp(-D*(0.3*n+0.25*n2)),1.0-exp(-D*(0.3*n+0.51*n2)),1.0-exp(-D*(0.3*n+1.17*n2)))*1.1;\n \n if(ay<0.0)col=vec3(0);\n    // Output to screen\n    fragColor = vec4(1.2*col,1.0);\n}\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdffDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1967]]}
{"id": "fdffWl", "name": "Real sky and ground simulation", "author": "blackholes", "description": "Just suppose the earth is a plane in Rectangular Coordinates. And the atmosphere is a layer endlessly \n//nestle up to the ground.\n//The effect is like this.", "tags": ["sunset", "sun", "light", "sky", "effect", "glass", "sunlight", "shader", "atmosphere", "sunrise", "atmospheric", "grassland", "meadow", "lawn", "meadowland"], "likes": 2, "viewed": 594, "published": 3, "date": "1648217534", "time_retrieved": "2024-07-30T16:56:53.153477", "image_code": "//Just suppose the earth is a plane in Rectangular Coordinates,and the atmosphere is a layer endlessly \n//nestle up to the ground.\n//The effect is like this.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float pi =3.1415926535;\n    //The latitude of the observer's position\n        // Sky with haze\t\n          float beta = pi/6.0;\n          //pupilla area\n     float s =1.25;\n\tfloat a = pi*uv.y-pi/2.0; \n    float a2=2.0*pi*uv.x;\n\n       \n            float sunmove = -0.2/2.0*iTime;\n               float suna=-asin(cos(beta)*sin(sunmove));\n               if(sin(suna)>0.0) suna=suna;\n               else suna=pi/5.0;\n                   float suna2;\n    if(sin(sunmove)<.0) suna2=acos((cos(sunmove))/(sqrt(cos(sunmove)*cos(sunmove)+sin(beta)*sin(beta)*sin(sunmove)*sin(sunmove))));\n    else suna2=-acos((cos(sunmove))/(sqrt(cos(sunmove)*cos(sunmove)+sin(beta)*sin(beta)*sin(sunmove)*sin(sunmove))));\n     float h = 0.1;\n     //Distance of observation line in atmosphere\n     float D = h*sqrt((1.0/tan(a))*(1.0/tan(a))+1.0);\n     //sunlight distance in atmosphere\n    float d = h*sqrt((1.0/tan(suna))*(1.0/tan(suna))+1.0);\n    //sphere\n    float alpha=acos(cos(a)*cos(suna)*cos(a2-suna2)+sin(a)*sin(suna));\n    //sunflarebrightness\n    float g = 0.55;\n    float g2 = 0.988;\n    float flare = 0.95*(1.0-g*g)/(1.0+g*g-2.0*g*cos(alpha));\n    float sunflare1 = (1.0-g2*g2)/(1.0+g2*g2-2.0*g2*cos(a-suna));\n    float sunflare2 = (1.0-g2*g2)/(1.0+g2*g2-2.0*g2*cos(cos(a)*(a2-suna2)));\n        //atmosphere thickness\n    //atmosphere absorption\n    float k =6.2;\n    float ab = 1.17/k;\n    float ab2 = 0.51/k;\n    float ab3 = 0.25/k;\n    float effect = (1.0-exp(-ab*D*3.5*(1.2+sin(a)/sin(suna))))/(ab)/(1.2+sin(a)/sin(suna));\n\n        vec3 blue = vec3(0.0,0.0,1.0);\n    vec3 green = vec3(0.0,1.0,0.0);\n    vec3 red = vec3(1.0,0.0,0.0);\n    vec3 sunflare = vec3(exp(-0.25*d/k),exp(-0.51*d/k),exp(-1.17*d/k));\n\n    //starsbrightness\n    float st=0.173;\n\n    vec3 m = vec3(0.25,0.51,1.17);\n    vec3 Sun;\n    if(alpha*360.0/pi <0.535)Sun = 3.0*sunflare;\n    else Sun = vec3(0,0,0);\n    if(sin(sunmove)<0.0) Sun=Sun;\n    else Sun=vec3(0,0,0);\n    if(sin(sunmove)<0.0) flare=flare;\n    else flare =0.0;\n    if(sin(sunmove)<0.0) sunflare1=sunflare1;\n    else sunflare1=0.0;\n     if(sin(sunmove)<0.0) sunflare2=sunflare2;\n    else sunflare2=0.0;\n    blue = blue*effect;\n    green = green*effect;\n    red = red*effect;\n    //light in atmosphere\n    float L=sin(suna);\n    vec3 Mie=vec3 (1,1,1)-sunflare;\n\n    vec3 skycol = L*((blue)*1.17+(green)*0.51+(red)*0.25)*0.275;\n    //skycolor+Miescattering of sun+Miescattering of skycolor+sun+sunbrightness\n    vec3 col4 = 3.0*skycol+1.68*(1.0-exp(-0.575*D))*sunflare*flare+d*sin(suna)*5.45*L*m*(1.0-exp(-1.32*D))+40.5*Sun+0.000072*sunflare*sunflare1*sunflare2;\n    //dustamount\n    float n = 0.0225;\n    //micodustamount\n    float n2 = 1.5225;\n       // Clouds\n\n                         \n    if(a<0.0) col4=1.8*sin(suna)*(vec3(0.16,0.2,0.13))*vec3(exp(-D*(5.0*n+0.25*n2)/100.0),exp(-D*(5.0*n+0.51*n2)/100.0),exp(-D*(5.0*n+1.17*n2)/100.0))+sin(suna)*vec3(1.0-exp(-D*(0.3*n+0.25*n2)/100.0),1.0-exp(-D*(0.3*n+0.51*n2)/100.0),1.0-exp(-D*(0.3*n+1.17*n2)/100.0))*1.1;\n    else col4= col4*vec3(exp(-D*(5.0*n+0.25*n2)),exp(-D*(5.0*n+0.51*n2)),exp(-D*(5.0*n+1.17*n2)))+sunflare*sin(suna)*vec3(1.0-exp(-D*(0.3*n+0.25*n2)),1.0-exp(-D*(0.3*n+0.51*n2)),1.0-exp(-D*(0.3*n+1.17*n2)))*1.1;\n \n   if(sin(sunmove)<0.0) col4 = s/5.55*4.286*col4;\n    else col4 = st*s/5.55*4.286*col4;    \n    // Output to screen\n\nfragColor = vec4(col4,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdffWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 215, 265, 3654]]}
{"id": "slfczB", "name": "windows GLSL bug: mystery float ", "author": "FabriceNeyret2", "description": "If you see black (Windows) then t is neither <0, =0, >0, Inf or Nan.\nGrey on OpenGl (because is Nan). Grey if Q is const.", "tags": ["what", "bug", "float"], "likes": 3, "viewed": 314, "published": 3, "date": "1648214307", "time_retrieved": "2024-07-30T16:56:53.969296", "image_code": "// simplified from https://shadertoy.com/view/stXyDM\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n   \n    float Q =  -1.;             // on Windows, give black.\n // const float Q = -1.;        // grey on Windows and OpenGL.\n \n    float t =  pow(Q , .333) ;  // should be NaN\n  \n    O = vec4(0.);\n    if (isnan(t)) O = vec4(.5); // grey if Nan or Inf or < 0 or = 0 pr > 0 \n    if (t <= 0.)  O = vec4(.5); // -> how can it be black ?\n    if (t >= 0.)  O = vec4(.5);\n    if (isinf(t)) O = vec4(.5);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 92, 92, 493]]}
{"id": "7lXcD4", "name": "Basic pathtracer. Menger fractal", "author": "El_Sargo", "description": "My first attempt at a path tracing/GI renderer. ", "tags": ["3d", "raymarching", "fast", "exact"], "likes": 6, "viewed": 303, "published": 3, "date": "1648189703", "time_retrieved": "2024-07-30T16:56:54.801072", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv)/float(iFrame);\n    fragColor = smoothstep(0.,.17,col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define rotations\n\n//Heavy performance impact \n#define raymarchSteps 100\n//\n#define ZERO min(iFrame, 0)\n\n//SDF stuff....\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere(vec3 p, float r){\n    return length(p) -r;\n}\n\nmat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n\n// yes you can use a loop, but I wanted controll over the rotations\nvec4 map(vec3 p) {\n\n    const float scale = 260.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(13.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(1.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(13.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 3.);\n    p.yz *= rotate(6.12);\n    p = trans(p, 1.);\n    #else\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale - 0.005, p);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n\nfloat intersection(vec3 ro, vec3 rd){\n    float dist;\n    float T;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro+rd*T).x;\n        T+=dist;\n        if (dist < 0.00001 || dist > 2.)\n            break;\n    }\n    \n    return T;\n\n}\n\nconst vec3 sun = normalize(vec3(1.3,1.,2.1));\nconst vec3 amb = vec3(0.7,0.8,0.9);\nconst vec3 suc = vec3(.6,0.5,0.3);\n//Dosn't actually need an array, just makes it easer to use many materials\n// Pbr also wasn't implemented\nconst vec3[] colors = vec3[](amb,vec3(0.2,0.3,0.2));\n\n//A realy crappy random function\nfloat hash(vec2 uv){\n    return fract(sin(dot(vec3(uv+iTimeDelta,iTime), vec3(12.9898, 78.233, 40.1231))) * 43758.5453);\n}\n//Random direction\nvec3 hash3(vec2 uv){\n    vec3 r = vec3(\n        hash(uv+2.513521*iTime),\n        hash(uv+2520.235-iTime),\n        hash(uv+124.124/iTime)\n    );\n    \n    r -= 0.5;\n    \n    return normalize(r);\n}\n\n\n\n//iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nstruct world {\n    int  id;\n    vec3 pos;\n    vec3 nor;\n    float dis;\n};\n\nworld wolrdIntersect(vec3 ro, vec3 rd){\n    vec3 nor = vec3(0);\n    float d = 10e10;\n    int id = 0;\n    //fractal\n    {\n        float md = intersection(ro,rd);\n        if (map(ro+rd*md).x < 0.1 && md < d){\n            id = 1;\n            nor = calcNormal(ro+rd*md);\n            d = md;\n        }\n    }\n    return world(id,ro+d*rd,nor, d);\n}\n\n//Trace a path away from the shape and return 1 if we hit nothing\nfloat getShadow(vec3 p, vec3 rd){\n    rd = normalize(rd+ hash3(rd.xz*p.yz)*0.1);\n    p+=0.001*rd;\n    return wolrdIntersect(p, rd).id == 0 ? 1. : 0.;\n}\n\n//Shadow ray in a random direction\nfloat getAmbiance(vec3 p, int i){\n    vec3 rd = hash3(p.xz*abs(p.yz)+p.xy+float(i*i));\n    \n    return getShadow(p+0.001*rd,rd);\n}\n\nstruct ligt {\n    vec3 scl;\n    float sha;\n    float amb;\n};\nvec3 render(vec3 ro, vec3 rd){\n    vec3 dir = rd;\n    vec3 p = ro;\n    //GI bounces\n    const int iter = 1;\n    \n    ligt[iter] lig;\n    //Get light\n    for (int i=0;i<iter;i++){\n\n        world w = wolrdIntersect(p, dir);\n        float sha = getShadow(w.pos, sun);\n\n        //Colors\n        if (w.id==0){\n            if (i==0)\n                //Sky\n                return amb*0.2;\n             else {\n                break;\n            }\n        }\n        \n        float am = 0.;\n        for(int a=0;a<4;a++){\n            am += getAmbiance(w.pos,a)/2.;\n        }\n        \n        lig[i] = ligt(colors[w.id], sha, am);\n        \n        dir = hash3(dir.xz+w.pos.yz);\n        dir *= -sign(dot(w.nor,dir));\n        p = w.pos;\n\n    }\n    vec3 col = vec3(0);\n    for (int i=iter-1;i>-1;i--) {\n    \n         vec3 scl = lig[i].scl;\n         float sha = lig[i].sha;\n         float am = lig[i].amb;\n         \n          //prevoius bounce\n          col = col*scl+\n                //sun light\n                scl*sha*suc+\n                //ambient light\n                scl*am*amb;\n\n    }\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = hash3(uv).xz/iResolution.xy*0.5;\n    vec3 rd = normalize(vec3(\n            (uv-0.5)*vec2(1.,iResolution.y/iResolution.x)+o,\n            1.));\n            \n    rd.xz *= rotate(0.02);\n    rd.yz *= rotate(0.03);\n\n    vec3 ro = vec3(0,-0.2,-1.5);\n\n    vec3 col = render(ro,rd);\n    \n    vec3 prev = texture(iChannel0, uv).xyz;\n    \n    col += prev;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 192]]}
{"id": "7lXcD7", "name": "learnshader007-创建曲线", "author": "hi347", "description": "创建离散曲线", "tags": ["learn"], "likes": 1, "viewed": 176, "published": 3, "date": "1648184180", "time_retrieved": "2024-07-30T16:56:55.648805", "image_code": "//顶点着色器：用几个顶点构成几何图形\n//颜色着色器：用几个图形并集，合集，交集，互拆，分割构成几何图形\n\n\n//创建第一个图形\nfloat draw1(vec2 uv,float pct) {    \n    return smoothstep(pct -0.02 ,pct ,uv.y) ;\n}\n\n//创建第二个图形\nfloat draw2(vec2 uv,float pct) {    \n    return smoothstep(pct, pct+0.02 ,uv.y);\n}\n\n//两个图形相减 = 互拆，只保留不重合的部分\nfloat draw3(vec2 uv,float pct) {    \n    return smoothstep(pct -0.02 ,pct ,uv.y) - smoothstep(pct, pct+0.02 ,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(1.0 *draw3(uv ,pow(uv.x ,5.0)),0.0 ,0.0 ,1.0);\n    /*\n        draw1（）和draw2()功能一样\n        draw3（）只是互拆计算\n        所以分析draw1（）即可掌握曲线制作方法\n        \n        pow()功能= 幂函数  例 pow（2 ,5） = 2 *2 *2 *2 *2 = 32\n        我们画的曲线，本质上是pow（）幂函数\n        通过smoothstep(pct -0.02 ,pct ,uv.y)划分颜色区\n        如果 小于 pow()-0.02 ，返回0，     黑色\n        如果 大于 pow() ，     返回1，     红色\n        如果 区间 pow()        返回0~0.02，淡红色\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 176, 208, 208, 260], [262, 286, 318, 318, 368], [370, 430, 462, 462, 547], [549, 549, 606, 606, 1252]]}
{"id": "7lXyDM", "name": "learnshader006-创建直线", "author": "hi347", "description": "这是离散直线，而非线性直线。所谓离散就是一个区域范围，每个点的位置不固定；而传统的直线位置都是清晰。", "tags": ["learn"], "likes": 0, "viewed": 146, "published": 3, "date": "1648184103", "time_retrieved": "2024-07-30T16:56:56.479584", "image_code": "//我们独创的功能\nfloat draw(vec2 uv) {    \n    return smoothstep(0.0, 0.02, abs(uv.y - uv.x));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fragColor = vec4(1.0 ,0.0 ,0.0,1.0);                     //红色\n     fragColor = vec4(1.0 *draw(uv) ,0.0 ,0.0,1.0);           //黑线（基础）\n    // fragColor = vec4(uv.x *draw(uv) ,0.0 ,0.0,1.0);          //黑线（改良）\n    // fragColor = vec4(uv.x *(1.0 -draw(uv)) ,0.0 ,0.0,1.0);   //黑线（改良）\n    // fragColor = vec4(uv.x +(1.0 -draw(uv)) ,0.0 ,0.0,1.0);   //黑线（改良）\n    \n    \n     /*\n    smoothstep(0.0, 0.02, abs(v2.y - v2.x)）\n    画布的宽和高不相等，但范围都是0~1，所以高度 - 宽度 = 有三种情况\n    \n    高度 - 宽度 <= 0时，返回0。 \n    此时红色1.0 * 0  = 0， 此时显示黑色 \n    \n    0.02 <= 高度 - 宽度时，返回1。 \n    此时红色1.0 * 1  = 1， 此时显示红色  \n    \n    当 0 <= 高度 - 宽度 <= 0.02时，返回一个0~0.02范围内的数字。 \n    此时红色1.0 * 0.01  = 0.01， 此时显示淡红色，模糊了黑色和红色的界限 \n    */\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 45, 45, 104], [106, 106, 163, 163, 1174]]}
{"id": "7tfcWM", "name": "learnshader005-常见变量声明", "author": "hi347", "description": "常见变量声明", "tags": ["learn"], "likes": 0, "viewed": 169, "published": 3, "date": "1648184083", "time_retrieved": "2024-07-30T16:56:57.359232", "image_code": "/*四种变量声明\nuniform vec2 iResolution;     uniform 能获取（get），不能更新设置（set）\n#define PI  3.14159265359     #define 能获取（get），不能更新设置（set）\nconst float cf=1.0;           const   能获取（get），不能更新设置（set）\nvec2 vv2;                     varying 能获取（get），能更新设置（set）\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(uv.x ,0.0 ,0.0 ,1.0);\n}\n\n\n/* gpu允许使用以下数学功能（官方提供的数学功能）\nsin( )  = 正弦,   返回-1~1\ncos( )  = 余弦，  返回-1~1\ntan( )  = 正切，  返回\nasin( ) = 反正弦，返回\nacos( ) = 反余弦，返回\natan( ) = 反正切，返回 \npow( )  = 幂,   返回\nexp( )  =        返回e为底的指数\nlog( )  =        返回自然对数 \nsqrt( ) = 平方根，返回\nabs( )  = 绝对值，返回整数 & 去符号\nsign( ) = 符号，  返回 0<返回-1， =0返回0 ，<0返回1\nfloor() = 向下取整，返回整数：输入1.1返回整数1\nceil( ) = 向上取整，返回整数：输入1.1返回整数2\nfract() = 求小数，  返回小数0~1：0.1返回0.1，-0.1返回0.9\nmod( )  = 求余数,   返回小数0~1：3.14返回0.14，-3.14返回0.14\nmin( )  = 最小值，  返回最小值\nmax( )  = 最大值，  返回最大值\nclamp() = 限定范围，返回参数限制在最小值和最大值范围内\nstep()  = 设置阈值，返回0或1，举例：step（0.5，input）如果小于0.5返回0，如果大于0.5返回1\nsmoothStep( ) = 平滑阶梯(线性离散插值而非线性连续插值)，返回0~1的平滑过渡值。smoothStep（下限，上限，参数）当x小于下界返回0，当x大于上界返回1,介于上界下界之间返回一个平滑的曲线\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 370, 427, 427, 513]]}
{"id": "7lXyWM", "name": "learnshader004-鼠标动态交互", "author": "hi347", "description": "鼠标交互", "tags": ["learn"], "likes": 0, "viewed": 159, "published": 3, "date": "1648184059", "time_retrieved": "2024-07-30T16:56:58.253840", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n                      \n    vec2 uv = fragCoord/iResolution.xy;      \n   \n                       /*须知：iMouse是4维变量 = 鼠标x坐标 +鼠标y坐标 +鼠标左键点击事件\n                               鼠标x，y坐标范围是屏幕坐标，需要归一化\n                               把iResolution 改成 iMouse即可\n                               需要通过点击鼠标左键来实现鼠标交互               \n                       */\n    vec2 mo = fragCoord/iMouse.xy;\n\n\n    fragColor =  vec4(uv.x  ,abs(sin(iTime))  ,mo.x  ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 618]]}
{"id": "flXyRS", "name": "Ellipsoid - gradient 3D", "author": "iq", "description": "Computes the approximated ellipsoid SDF and the exact normalized gradient/normal of the ellipsoid, by computing it analytically.", "tags": ["3d", "gradient", "normal", "ellipsoid", "analytic"], "likes": 29, "viewed": 798, "published": 3, "date": "1648145055", "time_retrieved": "2024-07-30T16:57:01.462262", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgEllipsoid() returns the approximated ellipsoid SDF and\n// the exact normalized gradient/normal of the ellipsoid, by \n// computing it analytically. This means the normal to\n// the ellipsoid surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:     https://www.shadertoy.com/view/wtcfzM\n// Capsule:   https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgEllipsoid( vec3 p, vec3 r )\n{\n    p /= r; float k0 =        sqrt(dot(p,p));\n    p /= r; float k1 = inversesqrt(dot(p,p));\n    return vec4( k0*(k0-1.0)*k1, p*k1 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    vec3 ra = vec3(0.8,0.1,0.5);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgEllipsoid(pos,ra).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgEllipsoid(pos,ra).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgEllipsoid( pos + e.xyy*eps, ra ).x + \n                             e.yyx*sdgEllipsoid( pos + e.yyx*eps, ra ).x + \n                             e.yxy*sdgEllipsoid( pos + e.yxy*eps, ra ).x + \n                             e.xxx*sdgEllipsoid( pos + e.xxx*eps, ra ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXyRS.jpg", "access": "api", "license": "mit", "functions": [[1614, 1731, 1768, 1768, 1903]]}
{"id": "stscDM", "name": "Parciel 2", "author": "arostaky", "description": "parte dos del parcial ATI", "tags": ["ati"], "likes": 0, "viewed": 207, "published": 3, "date": "1648137195", "time_retrieved": "2024-07-30T16:57:02.848555", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 buf1 = texture(iChannel0,uv).rgb; \n    vec3 buf2 = texture(iChannel1,uv+vec2(-0.1,0.0)).rgb; \n  //  vec3 buf3 = texture(iChannel0,uv+vec2(0.0,0.1)).rgb;\n  //  vec3 buf4 = texture(iChannel0,uv+vec2(0.0,-0.1)).rgb;\n    vec3 col = buf1;\n    col*= -10.0;\n    col+= 0.2;\n    // Output to screen\n    col *= 4.7;\n    col += 10.;\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sub(float d1, float d2){\n\n    return max(-d1, d2);\n    \n}\n\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nmat2 rot (float a) { \n\n    float c=cos(a),s=sin(a); return mat2(c,-s,s,c); \n\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n      vec3 q = abs(p) - b;\n      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n      vec3 pa = p - a, ba = b - a;\n      float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      return length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r ){\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\nvec2 opU2(vec2 d1, vec2 d2){\n\n     return (d1.x <d2.x)? d1 : d2;\n\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 opRep(vec3 p , vec3 c){\n\n    return mod(p+0.5*c,c)-0.5*c;\n\n}\n\nvec2 map(vec3 pos){\n    \n    float v = 0.0;\n    \n    pos.xz *= rot(sin(iTime*1.1));\n    pos.yz *= rot(cos(iTime*1.1));\n    pos = opRep(pos, vec3(9.1, 10.1, 40.1));\n    //pos.yz *= rot(.01+sin(iTime*1.1));\n    //v = sdSphere(pos, 1.0);\n    \n  //  vec2 c = vec2(sdRoundCone(pos,vec3(2.0),vec3(1.1),0.1,0.5),0.5);\n   // c *= rot(3.14/4.0);\n    //pos.yz = rot(0.1);\n    vec2 a = vec2(sdBox(vec3(pos.x+1.,pos.y,pos.z),vec3(1.,.1,3.)),1.);\n    vec2 b = vec2(sdBox(vec3(pos.x+1.,pos.y-.5,pos.z),vec3(1.,.1,3.)),1.);\n    //b *= rot(.001);\n    vec2 a2 = vec2(sdBox(vec3(pos.x-3.,pos.y,pos.z),vec3(.5,.1,1.5)),1.);\n    //vec2 b2 = vec2(sdBox(vec3(pos.x-3.,pos.y-.5,pos.z),vec3(.5,.1,1.5)),1.);\n    vec2 e = vec2(sdBox(vec3(pos.x-3.,pos.y-.5,pos.z),vec3(.5,1.,.01)),1.);\n    \n    \n    vec2 c = vec2(sdBox(vec3(pos.x,pos.y+.2,pos.z),vec3(4,.4,.4)),1.);\n    \n    \n    vec2 engine = vec2(sdBox(vec3(pos.x+1.,pos.y-.9,pos.z),vec3(1,.4,.4)),1.);\n    vec2 engine2 = vec2(sdBox(vec3(pos.x+2.,pos.y-.9,pos.z),vec3(.1,1.,.1)),1.);\n    \n    \n   // vec2 box4 = vec2(sdCapsule(pos,vec3(0.7),vec3(0.2),.5));\n    vec2 alas = opU2(a,b);\n    vec2 alas_back = opU2(a2,e);\n    //vec2 alas_back2 = opU2(alas_back, e);\n    vec2 alas_total = opU2(alas,alas_back);\n    //vec2 engine_total  = opU2(engine, engine2);\n    vec2 alas_engine = opU2(engine,alas_total);\n    vec2 cuerpo = opU2(alas_engine,c);\n    \n    return cuerpo;\n}\n\n\nvec3 GetNormal (vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x\n        ) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd) \n{\n    float contact = 0.0;\n    \n    for(int marche = 0; marche < 64 ; marche++)\n    {\n        vec2 ray = map(ro + rd * contact);\n        \n        if(ray.x < (0.0001*contact))\n        {\n           return vec2(contact,ray.y);\n        }\n        \n        contact += ray.x;\n    }\n\n    return vec2(-1.0,0.0);\n}\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec2 contact = CastRay(ro, rd);\n    \n    vec3 col;\n    \n    if(contact.x == -1.0)\n    {\n        col = vec3(0.0,sin(iTime*0.1),cos(iTime*0.1));\n    }\n    else\n    {\n        if(contact.y==0.0){\n            col =vec3(1.0,1.5+sin(iTime*.1),1.0);\n            vec3 nor = GetNormal(ro + rd * contact.x);\n            \n            //col = nor;\n        }\n        else{\n        \n            \n            col = vec3(0.9,1.5,1.5);\n        \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = 0.0;iTime * .5;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 50.0+sin(t));\n    vec3 cameraTar = vec3(2.0, 2.0, 0.0-t);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n    \n    \n    float p_angle = atan(uv.x, uv.y*0.5);\n    float p_distance = length(uv)*2.0;\n    \n    vec2 st = vec2(p_distance, p_angle);\n    st.y += sin(iTime);\n    float depth = min(st.x*.7,1.0);\n    vec3 col = render(cameraPos, viewDir);\n    col += texture(iChannel0, vec2(1.0 / st.x, st.y)).rgb;\n    //col *=100.;\n    //col *= depth;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = 2.0  * fragCoord/iResolution.xy -1.0;\n   uv.x *= iResolution.x/iResolution.y; \n   float p_angle = atan(uv.x, uv.y*0.5);\n   float p_distance = length(uv)*2.0;\n   vec2 st = vec2(p_distance, p_angle);\n   st.y += sin(iTime);\n   \n   float depth = min(st.x*.7,1.0);\n   vec3 col  = texture(iChannel0, vec2(1.0 / st.x + iTime, st.y)).rgb+cos(iTime*2.1);\n   col *= depth;\n   fragColor = vec4(col, 1.0);\n   \n}", "buffer_b_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stscDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 469]]}
{"id": "7tsyDM", "name": "Little Particles 29480234", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 14, "viewed": 314, "published": 3, "date": "1648136586", "time_retrieved": "2024-07-30T16:57:03.846886", "image_code": "float seg( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// this is very bad but works (clover trajectory)\nfloat pos(float x) {\n    const float[16] arr = float[] (0.,0.,0.,1.,1.,0.,1.,1.,0.,0.,0.,-1.,-1.,0.,-1.,-1.);\n    float f = fract(16. * x);\n    f = smoothstep(0., 1., f);\n    int index = int(floor(16. * x));\n    \n    return mix(arr[(index) & 15], arr[(index + 1) & 15], f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n   // float a = 10.;\n   // float t = 2.1 * iTime;\n    /*\n    float d = 1.;\n    for (float i = 0.; i < 1.; i++) {\n        vec2 p = 0.45 * vec2(fnc(a, t), fnc(a, t + pi/8.));\n        t += pi/75.;\n        d = min(d, length(uv - p));\n    }\n    */\n    \n    float d = 1., d2 = 1.;\n    float s = 0.12;\n    float k = 1. / iResolution.y;\n    float t = -0.04 * iTime;\n    float n = 50.;\n    for (float i = 0.; i < n; i++) {\n        t += mix(0.04, 0.12, mod(i,2.)) * pi; // * 0.005\n        float o = pi * 4.;\n        vec2 p = 0.3 * vec2(pos(fract(t)), pos(fract(t + 0.25)));\n        vec2 q = 0.3 * vec2(pos(fract(t + o)), pos(fract(t + o + 0.25)));\n       \n        d = length(uv - p);\n        d2 = abs(i/n * 0.25 - seg(uv, p, q));\n        \n        float s2 = exp(-50. * d) + smoothstep(-k, k, -d + 0.008);\n        s2 += (0.5 - 0.5 * thc(4., i/n - 0.5 * iTime)) \n            * (exp(-50. * d2) + smoothstep(-k, k, -d2 + 0.002));\n        s2 *= exp(-2.4 * i/n);\n        s = max(s,s2);\n    }\n    vec3 e = vec3(0.5);\n    \n    vec3 col = s * pal(uv.y, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    //scanlines\n    col -= 0.2 * pal(uv.y * iResolution.y * 0.5, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 164], [493, 493, 550, 550, 1817]]}
{"id": "7lfcD7", "name": "Mandelbulb Music visualizer", "author": "Peace", "description": "Mandelbulb fractal which reacts to music", "tags": ["musicvisualizer"], "likes": 5, "viewed": 352, "published": 3, "date": "1648122185", "time_retrieved": "2024-07-30T16:57:04.668689", "image_code": "#define TAU 6.28318530718\n#define TILING_FACTOR 1.0\n\nfloat waterHighlight(vec2 p, float time, float foaminess) {\n    vec2 i = vec2(p);\n\tfloat c = 0.0;\n    float foaminess_factor = mix(1.0, 6.0, foaminess);\n\tfloat inten = 0.005 * foaminess_factor;\n\tfor (float n = 1.0; n <= 8.0; n++) {\n\t\tfloat t = time * (1.0 - (3.5 / n));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0 / length(vec2(p.x / (sin(i.x + t)), p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * 8.0);\n\tc = 1.17 - pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\n#define AA 2\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    float n =  8.0 + sin(iTime);\n    \n\tfor( int i=0; i<3; i++ )\n    {\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        float r = sqrt(m);\n        float b = n*acos(w.y/r);\n        float a = n*atan(w.x / w.z);\n        float sinb = sin(b);\n        w = p + pow(r, n) * vec3(sinb*sin(a), cos(b), sinb*cos(a));       \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 4.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n    \n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<32; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nconst vec3[3] lights = vec3[3](\nvec3(  2.577, 2.577, -2.577 ),\nvec3( -2.707, 0.000,  2.707 ),\nvec3( -2.707, -2.707,  0.000 )\n);\n\nvec3 refVector( in vec3 v, in vec3 n )\n{\n    return v;\n    float k = dot(v,n);\n    return (k>0.0) ? v : v-2.0*n*k;\n}\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    if(t < 0.0)\n    {\n        float time = iTime * 0.2+23.0;\n        vec2 uv = p / iResolution.xy;\n        vec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n        float dist_center = pow(2.0*length(uv - 0.5), 2.0);\n        \n        float foaminess = smoothstep(0.4, 1.8, dist_center);\n        float clearness = 0.1 + 0.9*smoothstep(0.1, 0.5, dist_center);\n        \n        vec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n        \n        float c = waterHighlight(p, time, foaminess);\n        \n        vec3 water_color = vec3(0.1);\n        vec3 color = vec3(c);\n        color = clamp(color + water_color, 0.0, 1.0);\n        \n        color = mix(water_color, color, clearness);\n    \n        return pow(color*0.95, vec3(4.0));\n    \n        return vec3(abs(cam[2].w)*length(sp)*.02);\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, t, px );\n    \n    nor = refVector(nor,-rd);\n    \n    float occ = clamp(0.05*log(tra.x),0.0,1.0);\n    float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        vec3  hal = normalize( lights[i]-rd);\n        vec3  ref = reflect( rd, nor );\n    \n        float sha = softshadow( pos+0.001*nor, lights[i], 4.0 );\n        float dif = clamp( dot( lights[i], nor ), 0.0, 1.0 )*sha;\n        float spe = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,lights[i]),0.0,1.0),5.0));\n        \n        col += spe*15.0;\n    }\n    \n\tcol = pow( col, vec3(0.4545) );\n    \n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n\nfloat zoomEase(float t)\n{\n    return cos(t * 3.14159 * 6.5) * t * 0.1;\n    return (-(1.0/(1.0+t)) + 0.5)*t;\n}\n\nfloat z(float phase, float period, float strength)\n{\n    if(iTime > phase && iTime <= phase + period)\n    {\n        float t = (iTime - phase) / period;\n        return zoomEase(t) * strength;\n    }\n    return 0.0;\n}\n\nfloat frequency(float x)\n{\n    return texture(iChannel0, vec2(x, 0)).r;\n}\n\n#define FREQ 512.0\nfloat smoothFrequency(float x, int smoothness)\n{\n    float f = 0.0;\n    int accumulated = 0;\n    for(float i = 0.0; i <= float(smoothness) / FREQ; i += 1.0 / FREQ)\n    {\n        f += frequency(x + i);\n        ++accumulated;\n    }\n    return f / float(accumulated);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    float dist = 2.5;\n    \n    float music = 0.0;\n\n    music += smoothFrequency(0.05, 2);\n\n    dist -= pow(music, 1.0) * 1.15;\n    \n    dist += z(1.0, 0.25, 2.0);\n\n\tfloat di = pow(dist,2.0);\n\tvec3  ro = di*(vec3( cos(.33+time), 0.8*sin(.37+time), sin(.31+time) ));\n\tvec3  ta = vec3(0.0,0.0,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 112, 112, 587], [604, 604, 657, 657, 852], [854, 854, 897, 897, 1486], [1488, 1488, 1545, 1545, 1776], [1778, 1778, 1834, 1834, 2108], [2110, 2110, 2181, 2181, 2666], [2797, 2797, 2837, 2837, 2913], [2916, 2916, 2955, 2955, 4816], [4818, 4818, 4843, 4843, 4927], [4929, 4929, 4981, 4981, 5143], [5145, 5145, 5171, 5171, 5218], [5239, 5239, 5287, 5287, 5505], [5511, 5511, 5568, 5568, 6471]]}
{"id": "NtlcDM", "name": "Nordine 104", "author": "Nordine", "description": "\nTexturing", "tags": ["texturing"], "likes": 1, "viewed": 180, "published": 3, "date": "1648122121", "time_retrieved": "2024-07-30T16:57:05.696940", "image_code": "// Texturing\n// Eric Galin\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c;\nfloat s;\n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nV Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return V(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersection(Cube(p,c,r*0.75,index),Sphere(p,c,r,index));\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n  \n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 2.0),4.0,1));\n  u=Union(u,Dice(p,vec3( -10.0, 0.0, 2.0),4.0,2));\n  u=Union(u,Dice(p,vec3( 10.0, 0.0, 2.0),4.0,3));\n  u=Union(u,Dice(p,vec3( 0.0, 10.0, 2.0),4.0,4));\n  u=Union(u,Dice(p,vec3( 0.0, -10.0, 2.0),4.0,4));\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.65,0.75,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\nint convert(float x)\n{\n    if (x<0.0)\n    {\n        x = x-1.0;\n    }\n    return int(x);\n}\n\nvec3 Damier(vec3 p, vec3 a, vec3 b)\n{\n    int x = convert(p.x);\n    int y = convert(p.y);\n    int z = convert(p.z);\n    if ((x+y+z)%2 == 0) return a;\n    else return b;\n\n}\n\nvec3 Spheres(vec3 p, vec3 a, vec3 b)\n{\n    vec3 q =  fract(p);\n    if(length(q-vec3(0.5,0.5,0.5))<0.8) return a;\n    else return b;\n}\n\nvec3 Bois1(vec3 p, vec3 a, vec3 b)\n{\n    float d = length(p.xy);\n    float v = 0.7*(cos(d*5000000.0) + 1.2);\n    vec3 c = mix(a,b,v);\n    return c;\n\n}\n\nvec3 Bois(vec3 p, vec3 a, vec3 b)\n{\n    float d = length(p.xy);\n    float v = 0.5*(cos(d/0.1) + 1.0);\n    vec3 c = mix(a,b,v);\n    return c;\n\n}\n\nvec3 Marbre(vec3 p, vec3 a, vec3 b)\n{\n    return p ;\n}\n\n\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT Texture1(in vec3 p)\n{\nvec3 c = Damier(p,vec3(0.0,1.0,0.0),vec3(1.0,0.02,0.5));\n  return T(c,1.0);   \n}\n\nT Texture0(in vec3 p)\n{\n    vec3 c = vec3(0.8,0.0,0.0);\n    vec3 n = vec3(0.0,0.2,1.0);\n    vec3 f = (Noise(p)*c) + (0.5*Noise(p/10.0)*n) +(Noise(p/0.1)*c)\n    ;\n    return T(f,0.0);   \n}\n\n\nT Texture2(in vec3 p)\n{\n  vec3 c = Bois1(p,vec3(0.75,0.2,0.1),vec3(0.2,0.2,0.2));\n  return T(c,1.0);  \n}\n\nT Texture3(in vec3 p)\n{\n   vec3 c = Spheres(p,vec3(1.0,0.5,0.2),vec3(0.6,0.3,0.7));\n  return T(c,1.0);   \n}\n\nT Texture4(in vec3 p)\n{\n   vec3 c = Bois(p,vec3(0.3,1.0,0.5),vec3(0.6,0.3,0.7));\n   return T(c,1.0);   \n}\n\nT Texture5(in vec3 p)\n{\n    vec3 c =  Marbre(p,vec3(0.3,1.0,0.5),vec3(0.6,0.3,0.7));\n    return T(c,1.0);   \n}\n\n\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0){\n        \n        return Texture0(p);\n    }\n    else if (vp.i==1)\n    {\n        return Texture1(p);\n    }\n    else if (vp.i==2)\n    {\n        return Texture2(p);\n    }\n    else if (vp.i==3)\n    {\n        return Texture3(p);\n    }\n    else if (vp.i==4)\n    {\n        return Texture4(p);\n    }\n    else if (vp.i==5)\n    {\n        return Texture5(p);\n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.5*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.5  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 476, 520, 520, 555], [557, 608, 649, 649, 754], [756, 824, 867, 867, 903], [905, 993, 1011, 1011, 1106], [1108, 1213, 1238, 1238, 1345], [1347, 1398, 1439, 1439, 1508], [1510, 1556, 1574, 1574, 1910], [2020, 2060, 2091, 2091, 2334], [2336, 2466, 2531, 2531, 2938], [2940, 2981, 3006, 3006, 3082], [3085, 3104, 3132, 3150, 3410], [3412, 3412, 3434, 3434, 3501], [3503, 3503, 3540, 3540, 3674], [3676, 3676, 3714, 3714, 3809], [3811, 3811, 3847, 3847, 3961], [3963, 3963, 3998, 3998, 4106], [4108, 4108, 4145, 4145, 4162], [4268, 4268, 4291, 4291, 4372], [4374, 4374, 4397, 4397, 4561], [4564, 4564, 4587, 4587, 4668], [4670, 4670, 4693, 4693, 4777], [4779, 4779, 4802, 4802, 4884], [4886, 4886, 4909, 4909, 4996], [5001, 5048, 5078, 5078, 5472], [5474, 5537, 5573, 5573, 5698], [5700, 5781, 5817, 5837, 6371], [6689, 6784, 6823, 6848, 7272], [7275, 7284, 7331, 7360, 8061]]}
{"id": "flsyDM", "name": "Parciel 1", "author": "arostaky", "description": "Parte uno del parcial ", "tags": ["parcielati"], "likes": 1, "viewed": 180, "published": 3, "date": "1648121875", "time_retrieved": "2024-07-30T16:57:06.540684", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 buf1 = texture(iChannel0,uv+vec2(0.1,0.0)).rgb; \n    vec3 buf2 = texture(iChannel0,uv+vec2(-0.1,0.0)).rgb; \n    vec3 buf3 = texture(iChannel0,uv+vec2(0.0,0.1)).rgb;\n    vec3 buf4 = texture(iChannel0,uv+vec2(0.0,-0.1)).rgb;\n    vec3 buf5 = texture(iChannel1,uv+vec2(0.0,0.0)).rgb;\n    vec3 col = buf1  * buf2 * buf3 * buf4 * buf5;\n    col*= -10.0;\n    col+= 0.2;\n    // Output to screen\n    col *= 4.7,\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = 2.0  * fragCoord/iResolution.xy -1.0;\n   uv.x *= iResolution.x/iResolution.y; \n   float p_angle = atan(uv.x, uv.y*0.5);\n   float p_distance = length(uv)*2.0;\n   vec2 st = vec2(p_distance, p_angle);\n   st.y += sin(iTime);\n   \n   float depth = min(st.x*.7,1.0);\n   vec3 col  = texture(iChannel0, vec2(1.0 / st.x + iTime, st.y)).rgb+cos(iTime*2.1);\n   col *= texture(iChannel1, vec2(1.0 / st.x, st.y + iTime)).rgb+sin(iTime*2.5);\n   col *= texture(iChannel2, vec2(1.0 / st.x, st.y + iTime)).rgb+sin(iTime*.1);\n   col *= depth;\n   fragColor = vec4(col, 1.0);\n   \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float stroke (float x, float s, float w){\n\n    float d = step(s, x+w*.5) - step(s, x-w*.5);\n    return clamp(d, 0.,1.);\n\n}\nfloat rectSDF(vec2 st, vec2 s){\n\n    //st = st*2.-1.;\n    return max(abs(st.x/s.x),abs(st.y/s.y));\n\n}\nfloat circleSDF(vec2 st){\n\n    return length(st);\n    //return length(st-.5)*2.;\n\n}\n\nfloat fill(float x, float size){\n\n    return 1.-step(size, x);\n\n}\n\nfloat spiralSDF(vec2 st, float t){\n\n    st -= .5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r)*t+a*0.159)));\n\n}\n\nfloat triangleSDF(vec2 st){\n\n    //st = (st*2.-1.)*2.;\n    return max(abs(st.x)*0.866025 + st.y * 0.5, -st.y * 0.5);\n    \n\n}\n\n\nvec3 bridge(vec3 c, float d, float s, float w){\n\n\n    c *= 1.-stroke(d,s,w*2.);\n    return c + stroke(d,s,w);\n    \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = 2.0  * fragCoord/iResolution.xy -1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    \n    float s = rectSDF(uv, vec2(1.2));\n    float t = triangleSDF(uv*1.4);\n    float c = circleSDF(uv*50.0);\n    vec3 col = vec3(0.1);\n    col += stroke(s, 0.5, 0.05);\n    col += stroke(t, 0.3, 0.04);\n    col += stroke(c, 5.7, 1.3);\n    col *= 10.;\n    fragColor = vec4(col,0.0);\n    \n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 551]]}
{"id": "slXyzr", "name": "sound-waterfall", "author": "sashikus", "description": "Немного изменённый пример https://www.shadertoy.com/view/Ml3fR7\nОтображает спектр сигнала взятого с микрофона. Опытным путём установлено, что в iChannel0 содержатся отсчёты спектра приблизительно до 10 кГц", "tags": ["sound", "waterfall", "microphone"], "likes": 0, "viewed": 259, "published": 3, "date": "1648120910", "time_retrieved": "2024-07-30T16:57:07.446263", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float pixels_count = 1.0;\n    if ((iResolution.y - fragCoord.y) < pixels_count)\n    {\n    \tfragColor = texture(iChannel0, uv);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, uv + vec2(0, 0.01));\n    }\n}\n", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 142]]}
{"id": "7lfyW7", "name": "Cool pattern move", "author": "z0rg", "description": "Blah~", "tags": ["pattern", "dot"], "likes": 3, "viewed": 199, "published": 3, "date": "1648113445", "time_retrieved": "2024-07-30T16:57:08.244129", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0., 0., 0.);\n    float t = iTime*.5;\n    float globalRotateTime = 1.;\n    uv *= r2d(PI/2.*floor(t/globalRotateTime));\n    \n    vec2 rep = vec2(0.1);\n    vec2 id = floor((uv+rep*.5)/rep);\n    \n    \n    float beat = 2.*rep.y*2.;\n    \n    float vtime = t*sat(sign(sin(t*2.*PI/beat)));//mod(t, rep.y);\n    uv.y += mod(id.x,2.)*vtime;//vtime;\n    uv = mod(uv+rep*.5,rep)-rep*.5;\n    float shape = length(uv)-.01;\n    \n    col = mix(col, vec3(1., 1., 1.), 1.-sat(shape*iResolution.x*.5));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = rdr(uv);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfyW7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 416, 416, 473], [528, 528, 547, 547, 1073], [1076, 1076, 1133, 1133, 1256]]}
{"id": "NlXyW7", "name": "pretty good hyperblues", "author": "bigbadbob234", "description": "might give headache and not be pleasant to watch, idk. \nI like it, like hyperpop that goes through your eyeballs\n", "tags": ["colors", "colorshift", "shepardtone", "russellbeat", "inventing", "newcolors"], "likes": 0, "viewed": 188, "published": 3, "date": "1648092032", "time_retrieved": "2024-07-30T16:57:09.184614", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // + vec2(-.5, .5);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //vec2 uv = fragCoord;\n    \n    float t = (sin(iTime*.2)*.5+.5)*1.5; // shld reverse at 26 se\n    float k = .005;\n    float doodle = iTime*64.;\n    float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.7185;\n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n    \n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    //vec3 cola = mix(vec3(1,1,0), vec3(1,0,1), h);\n    //vec3 colb = mix(vec3(1,0,1), vec3(0,1,12), h2*h);\n    //vec3 col = mix(cola, colb, h2);\n\n\n    // Time varying pixel color\n    //vec2 uv2 = fragCoord/iResolution.xy;\n    //vec3 colc = 0.5 + 0.5*cos(t+uv2.xyx+vec3(0,2,4));\n    //vec3 colc2 = 0.5 + 0.5*sin(t+uv2.xyx+vec3(0,2,4));\n    //vec3 cola = mix(colc, vec3(0,3,0), h);\n    //vec3 colb = mix(colc2, vec3(1,1,1), h2*h);\n    //vec3 col = mix(cola, colb, h2);\n    \n    \n    vec3 cola = mix(vec3(0,1,1), vec3(0,0.5,1), h);\n    vec3 colb = mix(vec3(1,1,0), vec3(1,1,0), h2*h);\n    vec3 col = mix(cola, colb, h2);\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 1800]]}
{"id": "ftXyWM", "name": "learnshader003-动态渐变色", "author": "hi347", "description": "动态渐变色", "tags": ["learn"], "likes": 0, "viewed": 171, "published": 3, "date": "1648079099", "time_retrieved": "2024-07-30T16:57:10.009409", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n                      //须知：iTime是动态变量，官方提供的功能，类似frameCount，从0开始无限计时\n                      //已知：shader参数范围是0~1，可以使用三角函数cos（），sin（）限制iTime范围\n                      //已知：sin（），cos（）范围是-1~1\n                      //计算：使用abs()绝对值功能，让-1~1范围进一步缩小到0~1期间\n    // fragColor = vec4(uv.x ,uv.y ,iTime ,1.0);\n    // fragColor = vec4(uv.x ,uv.y ,sin(iTime) ,1.0);\n    fragColor = vec4(uv.x ,uv.y ,abs(sin(iTime)) ,1.0);\n}\n\n/*\n如何知道iTime这类官方变量？\n点击代码第一行上面的【→着色器输入】\n折叠中包含了常用的变量\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 679]]}
{"id": "7lscDN", "name": "learnshader002-静态渐变色", "author": "hi347", "description": "渐变色", "tags": ["learn"], "likes": 0, "viewed": 156, "published": 3, "date": "1648077791", "time_retrieved": "2024-07-30T16:57:10.842183", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n               //已知：fragCoord是着色器的坐标宽度范围是0~1，高度范围0~1\n               //已知：iResolution是屏幕的坐标范围，如宽0~1920，高0~1080\n               //计算：通过除法，将屏幕的坐标宽高归一化为0~1之间。\n    vec2 uv = fragCoord/iResolution.xy;\n    \n               //uv是二维向量，uv.x表示宽度，uv.y表示高度\n               //uv不是静态的某个数字，而是递增的动态参数\n    // fragColor = vec4(uv.x ,0.0 ,0.0 ,1.0);\n     fragColor = vec4(uv.x ,uv.y ,0.0 ,1.0);\n}\n\n/*为什么出现渐变色？\nx轴：0~1 黑~红\ny轴：0~1 黑~绿\n而左上角之所以变黄，是因为（红+绿=黄），颜色自动融合了\n\n光源发出来的三原色：红，绿，蓝\n红色 + 绿色 = 1：1 = 黄色\n绿色 + 蓝色 = 1：1 = 青色\n蓝色 + 红色 = 1：1 = 紫色\n\n反射光源三原色（即非光源发出来的）：青色，黄色，紫色，俗称CMYK\n黄色 + 青色 = 1：1=绿色\n青色 + 紫色 = 1：1=蓝色\n紫色 + 黄色 = 1：1=红色\n\n不同的比例混合，搭配出不同颜色,自行调试测试\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lscDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 329, 617]]}
{"id": "slscDN", "name": "learnshader001-静态纯色", "author": "hi347", "description": "学习shader，第一课", "tags": ["learn"], "likes": 0, "viewed": 184, "published": 3, "date": "1648077074", "time_retrieved": "2024-07-30T16:57:11.688919", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 四维向量（红色，绿色，蓝色，透明程度）\n    \n    // 当三个颜色都是1，那么就是白色\n    // fragColor = vec4(1.0 ,1.0 ,1.0 ,1.0);  //白色\n    \n    // 当三个颜色都是0，那么是黑色\n    // fragColor = vec4(0.0 ,0.0 ,0.0 ,1.0);  //黑色\n    \n    // 0表示黑色，0~1表示过渡色，1表示纯色，\n     fragColor = vec4(1.0 ,0.0 ,0.0 ,1.0);  //红色\n    \n    // 0表示黑色，0~1表示过渡色，1表示纯色，\n    // fragColor = vec4(0.0 ,1.0 ,0.0 ,1.0);  //绿色\n    \n    // 0表示黑色，0~1表示过渡色，1表示纯色，\n    // fragColor = vec4(0.0 ,0.0 ,1.0 ,1.0);  //蓝色\n    \n    // 0表示黑色，0~1表示过渡色，1表示纯色，\n    // fragColor = vec4(0.0 ,1.0 ,0.0 ,0.1);  //透明\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slscDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 407, 825]]}
{"id": "fsSBRh", "name": "Fisheye Effect - Spi3lot", "author": "Spi3lot", "description": "Change where the effect is applied using the mouse/trackpad/touchscreen/whatever", "tags": ["effect", "fisheye", "fish"], "likes": 2, "viewed": 515, "published": 3, "date": "1648047090", "time_retrieved": "2024-07-30T16:57:12.672290", "image_code": "#define PI 3.1415926535\n\n// 0... Don't center fisheye when clicking/dragging with the mouse\n// 1... Center fisheye when clicking/dragging with the mouse\n#define CENTER 0\n\n// 0... Show black pixels if uv coordinates are < 0 or >= 1\n// 1... Loop image if uv coordinates are < 0 or >= 1\n#define LOOP_IMAGE 0\n\n\nvec2 norm(vec2 v)\n{\n    return 2.0 * v - 1.0;\n}\n\nvec2 abnorm(vec2 norm)\n{\n    return 0.5 * (norm + 1.0);\n}\n\n\nvec2 f1(vec2 uv)\n{\n    vec2 v = norm(uv);\n    return v * exp(length(v)) / 4.0;\n}\n\nvec2 f2(vec2 uv)\n{\n    return -cos(uv * PI);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 factor = 1.0 / iResolution.xy;\n    \n    vec2 uv = fragCoord * factor;\n    vec2 mouseNorm = -0.5 + iMouse.xy * factor;\n    mouseNorm *= float(iMouse.z > 0.0);\n    \n#if !CENTER\n    uv -= mouseNorm;\n#endif\n\n    vec2 transformed = abnorm(f1(uv)) + mouseNorm;\n\n    // Output to screen\n#if !LOOP_IMAGE\n    if (all(greaterThanEqual(transformed, vec2(0))) && all(lessThan(transformed, vec2(1))))\n        fragColor = texture(iChannel0, transformed);\n    else\n        fragColor = vec4(0);\n#else\n    fragColor = texture(iChannel0, transformed);\n#endif\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 326, 326, 354], [356, 356, 380, 380, 413], [416, 416, 434, 434, 496], [498, 498, 516, 516, 544], [547, 547, 604, 604, 1156]]}
{"id": "flXyDN", "name": "Painted glass", "author": "jarble", "description": "Another glowing fractal pattern.", "tags": ["fractal", "glass"], "likes": 5, "viewed": 323, "published": 3, "date": "1647987536", "time_retrieved": "2024-07-30T16:57:13.487111", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += (iTime+8.)/vec2(2.0,3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    //float s1 = 1.;\n    for(int k = 0; k < 12; k++){\n        vec2 uv1 = uv;\n        uv -= (t2.yx);\n        \n        //uv.x -= sign(uv.x)/2.;\n        //uv.y -= sign(uv.y)/2.;\n\n        t2 = triangle_wave(uv.yx+.5,scale).yx/2.;\n        t3 = triangle_wave(uv,scale).yx;      \n        uv.yx = t3/1.5-t2;\n        \n        float m1 = uv.x;\n        \n        \n        //More interesting patterns here:\n        //float m1 = (uv.y-uv.x)/(1.-t2.x);\n        //float m1 = (uv.y+uv.x)/2./(1.-t2.x);\n\n        //float m1 = uv.x-uv.y;\n        //float m1 = uv.y-uv.x;\n        //float m1 = uv.x*float(k%2)+uv.y*float((k+1)%2);\n        \n        col.x = max(m1,col.x);\n        col = abs(col.yzx-vec3(col.x*(2.125-t2.y)));\n        uv /= scale+normalize(uv).x/3.;\n        uv -= float(k%3)/2.;\n        //uv -= float(k%3+5)/2.;\n\n        \n        //if(k>3) uv.x += iTime/s1/4.;\n        //s1 *= scale;\n        //uv /= 1.+normalize(t2).x/3.;\n    }\n    fragColor = vec4(col*2.,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1365]]}
{"id": "NtXyDN", "name": "Clean Metaballs", "author": "Veggiebob", "description": "mouseable", "tags": ["3d", "mouse", "sdf", "metaballs", "reflect", "reflective"], "likes": 8, "viewed": 363, "published": 3, "date": "1647987488", "time_retrieved": "2024-07-30T16:57:14.457516", "image_code": "// Fork of \"3D Reflective Metaballs\" by Veggiebob. https://shadertoy.com/view/MldyWn\n// 2022-03-22 22:13:22\n\n#define roughness 2.0 // between 0 and 1\n#define bigness 0.1\n#define EPSILON pow(10., -4.)\n#define num_balls 16.\n#define threshold 45.\n#define TIME_OFFSET (600.)\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nfloat sphere (vec3 spherePos, vec3 pos, float radius){\n    return length(pos-spherePos)-radius;\n}\nfloat sq (float x){\n    return x*x;\n}\nvec3 fractalColor (vec3 p, float iters){\n    vec3 c = texture(iChannel1, p).rgb;\n    for(float i = 0.; i<iters; i++){\n        c+=texture(iChannel1, p*pow(2., i)).rgb*pow(0.8, i);\n    }\n    return c;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\n//from IQ -- https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smin2(float a, float b, float k){\n\treturn min(a, b)-pow(0.5, 10.*mix(0., 0.1, abs(a-b)))*k;\n}\nfloat SDF (vec3 p){\n    float dP = 100.;//cube with rounded corners\n    float dp = 1.;\n    float time = iTime + TIME_OFFSET;\n    for(float i = num_balls; i<num_balls*2.; i++){\n        float inc = i*0.4*sq(sin(time*0.01*i*0.1))*0.5;\n        float constrict = 1.;//sq(sin(iTime))\n        vec3 pos = vec3(sin(time+inc), cos(time+inc), sin((time+inc)*2.))\n            *bigness*constrict;//modifiers\n        float smallSphere = sphere(pos, p, bigness*0.1);\n    \tdP = smin(dP, smallSphere, 0.08);\n    }\n   \t//optional distortion\n    //dP+=length(fractalColor(p*20., 3.))*0.0001*roughness;\n    return dP;//pow(0.99, max(dp, 1.))*0.1;\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<32; i++){\n        p = o+r*t;\n        float d = SDF(p);\n        t+=d*1.;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat bright (vec3 c){\n    return dot(c, vec3(1.))/3.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.0, 0.3);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = mouse.y-0.1;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    \n    vec4 v = trace(camera, ray);\n    vec3 col = vec3(0.);//fractalColor(v.xyz, 5.);//fractalize\n    //col*=1./length(col);//normalize\n    //vec3 randomize = fractalColor(v.xyz*1., 3.);//texture(iChannel1, v.xyz*10.).xyz-0.5; \n    vec3 normal = estimateNormal(v.xyz);\n    vec3 newRay = reflect(ray, normal);\n    col = texture(iChannel0, newRay).rgb;//+vec3(0., 0., 0.3);\n\tfloat fog = 1./(1.+pow(v.w, 10.)*0.1);\n    vec3 background = vec3(1.); //texture(iChannel0, ray).rgb;\n    col=col*fog+(1.-fog)*background;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 307, 307, 391], [392, 392, 442, 442, 625], [626, 626, 680, 680, 723], [724, 724, 743, 743, 761], [762, 762, 802, 802, 962], [963, 963, 999, 999, 1081], [1082, 1132, 1172, 1172, 1265], [1266, 1266, 1305, 1305, 1365], [1366, 1366, 1385, 1385, 1994], [1995, 1995, 2024, 2024, 2182], [2183, 2308, 2337, 2337, 2617], [2618, 2618, 2640, 2640, 2674], [2675, 2675, 2732, 2782, 3878]]}
{"id": "ssjfDG", "name": "Tripping cubes", "author": "z0rg", "description": "Pew pew !", "tags": ["cubes", "trip", "trance", "goa", "cubonaut"], "likes": 14, "viewed": 712, "published": 3, "date": "1647982494", "time_retrieved": "2024-07-30T16:57:15.417948", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.2\n#define GLOW_POW .3\n#define GLOW_OPACITY .6\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 5.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\n#define FFT(a) ((texture(iChannel2, vec2(a,0)).x+.05)*10.)\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec3 op = p;\n    vec3 rep = vec3(1.);\n    vec3 id = floor((p+rep*.5)/rep);\n    p = mod(p+rep*.5,rep)-rep*.5;\n    p.xz *= r2d(id.y+iTime);\n    p.xy *= r2d(sin(id.z)+iTime*.3);\n    vec3 sz = FFT(length(id))*rep*.3 * (sin((id.x)*length(id)+iTime)*.5+.5);\n    float shape = mix(_cucube(p, sz, vec3(.02)), length(p)-length(sz), sin(iTime)*.5-.5);\n    shape = max(shape, -(length(op)-5.));\n    acc = _min(acc, vec2(shape, 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 getCol(vec3 p, vec3 n)\n{\n    vec3 col = n*.5+.5;\n    col.xy *= r2d(p.z*5.+iTime);\n    col.yz *= r2d(sin(p.y*5.)-iTime);\n    col = abs(col);\n    return n*.5+.5;\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 10.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n        rd = normalize(rd-.01*normalize(p));\n        accCol += getCol(p, normalize(p))*(1.-sat(res.x/.52))*.005;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float t= sin(iTime*.25);\n    float d = 5.+3.*sin(iTime*.33);\n    vec3 ro = vec3(sin(t)*d,-5.*sin(t*.25)*d,cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getCol(p, n);\n    }\n    col += accCol;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)// Not so cheap antialiasing\n    {\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 2.5/(col+1.);\n    //col = pow(col, vec3(.4545));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .2);\n    col = sat(col);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28383, "src": "https://soundcloud.com/afginelad/afgin-dreams-in-motion-studio-mix-2017", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfDG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1087]]}
{"id": "NtXyD4", "name": "Groovy Green Screen", "author": "lwneal", "description": "A groovy melting swirl of saturated color seeded by a foreground figure. Inspired by the analog feedback effect of displaying the camera's own output as a backdrop (eg. https://makezine.com/projects/freaky-fractals-hd-video-feedback-machine/). ", "tags": ["greenscreen", "psychedelic", "chromakey", "feedback", "buffer", "groovy", "melting"], "likes": 9, "viewed": 393, "published": 3, "date": "1647974170", "time_retrieved": "2024-07-30T16:57:16.420268", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    fragColor = texture(iChannel1, uv);    \n    //fragColor = texture(iChannel2, uv); // to test the globalColorBalance pass\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This pass performs most of the work; its output is displayed\n// The other buffer exists only to provide globalColorBalance\n\nfloat chromaKey(in vec2 fragCoord) {\n    // Exercise 1: improve this function to remove the green border from Jean-Claude\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = 13. / 255.;\n    float g = 163. / 255.;\n    float b = 38. / 255.;\n    vec3 bkg = vec3(r, g, b);\n    vec3 vid = texture(iChannel0, uv).rgb;\n    return length(vid - bkg);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 fg = texture(iChannel0, uv).rgb;\n\n    // Swirling motion (pan + zoom + rotation about center)\n    // Exercise 2: Reverse the swirl, or move it in another direction\n    uv.y -= .0001;\n    uv -= .5;\n    uv *= 1.01;\n    uv.x += .01 * (0. - sin(uv.y));\n    uv.y += .01 * (0. + sin(uv.x));\n    uv += .5;    \n    vec3 bg = texture(iChannel1, uv).rgb;\n    \n    // global scaling: this provides the lava-lamp cycle through different colors\n    // Exercise 3: What happens when you rearrange the r b g channels here?\n    vec4 globalColorBalance = texture(iChannel2, uv*.01);             \n    bg.rbg += .01 * (.5 - globalColorBalance.bgr);\n    \n    // apply chroma-key\n    float d = chromaKey(fragCoord);\n    float alpha = clamp(.4 + ((d - .4) * 4.), .0, 1.);\n    fragColor.rgb = alpha * fg + (1. - alpha) * bg;\n    fragColor = clamp(fragColor, 0., 1.);\n}\n", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This exists only because I can't figure out how to get the sum of all pixels\n// So, this is like an approximate time-delayed pixel-summing machine\n// Visually it's a faster blurry version of the main buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Spiral inward like a groovy psychedelic map-reduce\n    vec2 uvGroovy = uv;\n    uvGroovy -= .5;\n    uvGroovy *= 1.02;\n    uvGroovy.x += .05 * (0. - sin(uvGroovy.y));\n    uvGroovy.y += .05 * (0. + sin(uvGroovy.x));\n    uvGroovy += .5;\n    uvGroovy += .0001 * sin(iTime);  // wobble a little to avoid aliasing\n \n    float p = 10. * length(uv - uvGroovy);\n    fragColor = (1. - p) * texture(iChannel2, uvGroovy) + p * texture(iChannel1, uv);\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 233]]}
{"id": "ftsyW8", "name": "Raymarch Snowflakes", "author": "karo", "description": "random snowflake generator", "tags": ["raymarching"], "likes": 3, "viewed": 217, "published": 3, "date": "1647966439", "time_retrieved": "2024-07-30T16:57:17.359757", "image_code": "////// PI CONSTANTS //////\n#define M_PI   3.14159265358979323846264338327950288\n#define M_PI_4 .785398163397448309615660845819875721\n#define M_PI_6 .523598775598298873077107230546583814\n\n////// LIGHT POSITION //////\n#define LIGHT_X 0\n#define LIGHT_Y 3\n#define LIGHT_Z -3\n\n////// RAYMARCH SETTINGS /////\n#define MARCH_STEPS 100\n#define MARCH_DIST 100.0\n#define MARCH_TERMINATE .001\n\n////// PRNG //////\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n////// OPERATORS //////\n// rotate around axis\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// smooth step combine\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n////// BASIC SDFS //////\n// sphere = (x, y, z, radius)\nfloat dSphere(vec3 p, vec4 sphere){\n    return length(p - sphere.xyz) - sphere.w;\n}\n// torus = (x, y, z, radius)\nfloat dTorus(vec3 p, vec4 torus, float rThick){\n    vec3 pFloor = vec3(p.x, p.y, 0);\n    float dFloor = length(pFloor.xy - torus.xy) - torus.w;\n    float dRing = length(vec2(dFloor, p.z));\n    return dRing - rThick;\n}\n    \n///// COMPLEX SDFS /////\nfloat dHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// s = size\nfloat dOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat dCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// i made this :)\n// need to implement angle\nfloat dCylinderArrow(vec3 p, float r, float h, float angle) {\n    p.y += h * M_PI;\n    p.x -= h * M_PI;\n    pR(p.xy, M_PI_4);\n    float c1 = dCylinder(p, r, h);\n    pR(p.xy, -M_PI_4);\n    p.x += h * M_PI * 2.;\n    \n    pR(p.xy, -M_PI_4);\n    float c2 = dCylinder(p, r, h);\n    return opSmoothUnion(c1, c2, .1);\n}\n\n////// SCENE //////\nfloat calcScene(vec3 rayPoint) {\n    // random\n    //int tCenter = int(floor(clamp(rand(iTime) * 3., 0., 3.)));\n    //int tSpike  = int(floor(clamp(rand(iTimeDelta) * 2., 0., 2.)));\n    //int tOuter  = int(floor(clamp(rand(sin(iTime)) * 2., 0., 2.)));\n    \n    // showcase\n    int f = int(floor(float(iFrame) / 50.));\n    int tCenter = f % 3;\n    int tSpike = f % 2;\n    int tOuter = f % 2;\n    \n    float final = 1000.;\n    vec3 rayPointOrig = vec3(rayPoint.x, rayPoint.y, rayPoint.z);\n    \n    for(int i = 0; i < 6; i++) {\n        rayPoint = rayPointOrig;\n        \n        pR(rayPoint.xy, M_PI_6 * 2. * float(i));\n        rayPoint.y -= 1.;\n    \n        float dCenter = 0.;\n        float dSpike = 0.;\n        float dOuter = 1000.;\n        \n        float yOffset = 0.;\n\n        switch(tCenter) {\n            case 0:\n                dCenter = dSphere(rayPoint, vec4(0, .2, 0, .6));\n                yOffset = 1.5;\n                break;\n            case 1:\n                dCenter = dTorus(rayPoint, vec4(0, .2, 0, .5), .1);\n                yOffset = 1.8;\n                break;\n            case 2:\n                dCenter = dOctahedron(rayPoint, .6);\n                yOffset = 1.4;\n                break;\n        }\n\n        rayPoint.y -= yOffset;\n        switch(tSpike) {\n            case 0:\n                dSpike = dCylinder(rayPoint, 1.2, .2);\n                break;\n            case 1:\n                dSpike = dHexPrism(rayPoint.xzy, vec2(.2, 1.2));\n                break;\n        }\n\n        rayPoint.y -= 1.;\n        switch(tOuter) {\n            case 0:\n                dOuter = dOctahedron(rayPoint, .7);\n                break;\n            case 1:\n                dOuter = dCylinderArrow(rayPoint, 1.1, .2, 2.);\n                break;\n            \n        }\n\n        float flake = opSmoothUnion(opSmoothUnion(dCenter, dSpike, .3), dOuter, .8);\n        final = opSmoothUnion(flake, final, .3);    \n    }\n    return final;\n}\n\nfloat march(vec3 camPos, vec3 rayNorm) {\n    float rayDist = 0.0;\n    \n    for(int i = 0; i < MARCH_STEPS; i++) {\n        vec3 rayPoint = camPos + (rayNorm * rayDist);\n        float distToGeometry = calcScene(rayPoint);\n        rayDist += distToGeometry;\n        \n        if(rayDist > MARCH_DIST || distToGeometry <= MARCH_TERMINATE) break;\n    }\n    return rayDist;\n}\n\n////// LIGHTING //////\n// returns point's normal vector by calculating average\n// of three points .1 unit away on each axis\nvec3 getNormal(vec3 point) {\n    float distToGeometry = calcScene(point);\n    vec2 diff = vec2(.001, 0);\n    \n    return normalize(vec3(distToGeometry - vec3(\n        calcScene(point - diff.xyy),\n        calcScene(point - diff.yxy),\n        calcScene(point - diff.yyx)\n    )));\n}\n\n// simple shading using dot product of normals\n// returns 1.0 if light is parallel to rayHit, 0.0 if perpendicular\nfloat getSimpleShading(vec3 hitPoint) {\n    vec3 lightPos = vec3(LIGHT_X, LIGHT_Y, LIGHT_Z);\n    \n    // rotate light\n    //lightPos.x -= sin(iTime) * 2.;\n    //lightPos.z -= cos(iTime) * 2.;\n    \n    vec3 lightNorm = normalize(lightPos - hitPoint);\n    vec3 hitPointNorm = getNormal(hitPoint);\n    float illumination = 1.;\n    \n    // march another ray back from the hit point to the light\n    // start slightly offset to avoid terminating march prematurely\n    float distToLight = march(hitPoint + hitPointNorm * 0.15, lightNorm);\n    // if it hits something before it gets to the light,\n    if(distToLight < length(lightPos - hitPoint)){\n        // we are in a shadow\n        illumination = .3;\n    }\n    \n    // a light directly above will illuminate more than angled.\n    // dot product is 1 if light norm + point norm are identical,\n    // 0 at a right angle, and -1 when parallel -\n    // clamp this to [0, 1] to get simple shading value\n    return clamp(dot(hitPointNorm, lightNorm), 0., 1.) * illumination;\n}\n\n////// ENTRYPOINT //////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 0, -10); \n    vec3 rayNorm = normalize(vec3(uv.x, uv.y, 1));\n\n    float rayDist = march(camPos, rayNorm);\n    vec3 hitPoint = camPos + (rayNorm * rayDist);\n    vec3 col = vec3(getSimpleShading(hitPoint));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 401, 423, 423, 471], [472, 472, 492, 492, 560], [561, 561, 581, 581, 614], [616, 662, 694, 694, 736], [737, 760, 812, 812, 911], [913, 968, 1003, 1003, 1051], [1052, 1081, 1128, 1128, 1298], [1304, 1329, 1364, 1364, 1637], [1638, 1650, 1687, 1687, 1967], [1969, 1969, 2014, 2014, 2121], [2123, 2168, 2229, 2229, 2480], [2482, 2502, 2534, 2774, 4430], [4432, 4432, 4472, 4472, 4800], [4802, 4926, 4954, 4954, 5205], [5207, 5322, 5361, 5361, 6339], [6341, 6366, 6423, 6479, 6814]]}
{"id": "slscW8", "name": "adaptive dashes", "author": "FabriceNeyret2", "description": "Draw ~constant size dashed polyline \nmouse controls P1\n\n#def PHASES 1.:  the dash phase is constrained at vertices \n#def PHASES 0.: dashes corners at vertices", "tags": ["line", "drawing", "adaptive", "dashes"], "likes": 18, "viewed": 526, "published": 3, "date": "1647958032", "time_retrieved": "2024-07-30T16:57:18.253367", "image_code": "#define PHASES 0. // 1.: constrained random phases at vertices. 0. : all phases = 0. \n\n// utils from https://www.shadertoy.com/view/llySRh\n\n#define hash(p)  fract(sin( (.1+p) *  78.233 ) * 43758.5453 - PHASES*iTime )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n#define S(v) smoothstep( 1.5/R.y,0., v )              // AA\n\n// modifies period T so as the extremities P1,P2 fit the phases a1, a2\n// then draw AA dashes  ( use S(line(U,P1,P2)) * L(P1,P2,a1,a2) )\n#define L(P1,P2,a1,a2) (                                        \\\n        l  = length(P2-P1),                                     \\\n        Ta =  l / ( floor(l/T) -PHASES*(fract(a1-a2+.5)-.5) ),  \\\n        l  = cos( 6.283*( length(U-P1)/Ta +PHASES*a1 ) ),       \\\n        clamp( .5 + .5*l/fwidth(l) , 0., 1. )                   \\\n    )       // or - if you don't like corners for PHASES = 0.\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R.y,\n         P0 = vec2(.1),                               // 4 points\n         P1 = iMouse.z > 0. ? iMouse.xy / R.y : vec2(.5),\n         P2 = .9*R/R.y,\n         P3 = vec2(.7*R.x/R.y,.3) + .2*cos( iTime + vec2(0,11) );\n         \n    float Ta, l, T = 20./R.y,                         // T: target dash period (pixels)\n         a0 = hash(0.), a1 = hash(1.), a2 = hash(2.), a3 = hash(3.),\n        d01 = line(U,P0,P1),                          // 4 random phases at points\n        d12 = line(U,P1,P2),\n        d23 = line(U,P2,P3),\n        d30 = line(U,P3,P0),\n        m = min( min(d01,d12), min(d23,d30) );\n\n    O = vec4(   m == d01 ? S(d01) * L(P0,P1,a0,a1)    // draw rectified dashes\n              : m == d12 ? S(d12) * L(P1,P2,a1,a2) \n              : m == d23 ? S(d23) * L(P2,P3,a2,a3) \n              :            S(d30) * L(P3,P0,a3,a0) \n            );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slscW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 253, 253, 425], [1018, 1018, 1056, 1056, 1966]]}
{"id": "stsyD8", "name": "SemiQuantize", "author": "TinyTexel", "description": "A quantization transfer function that supports sloped steps as well as uneven step distributions.", "tags": ["quantization"], "likes": 14, "viewed": 391, "published": 3, "date": "1647954647", "time_retrieved": "2024-07-30T16:57:23.893288", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n    \n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 A, B, C, D;\n\n// C. Schlick. \"Fast alternatives to Perlin’s bias and gain function\"\n// inverse(Bias(x,s)) =   Bias(x  ,1-s)\n// inverse(Bias(x,s)) = 1-Bias(1-x,  s)\nfloat Bias(float x, float s)\n{\n    if(s == 0.0) return x != 1.0 ? 0.0 : 1.0;\n    if(s == 1.0) return x != 0.0 ? 1.0 : 0.0;\n    \n    return x / ((1.0/s - 2.0) * (1.0 - x) + 1.0);\n}\n\nfloat linstep(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    return x;\n}\n\nfloat smootherstep(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    return x*x*x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat bump(float a, float b, float x)\n{\n    x = clamp((x - a) / (b - a), 0.0, 1.0);\n    x = (x - x*x) * 4.0;\n    return x*x*x;\n}\n\n\n#define STEPMAP smootherstep\n#define BUMPMAP bump\n// count [0..s] | sharp [0..1] | bias [0..0.5..1] | blend [0..1]\nfloat Quantize(float y, float count, float sharp, float bias, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float yu = y;\n    yu = Bias(yu, bias);\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(Bias((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count, 1.0-bias), y, blend);\n}\n\n\n// count [0..s] | sharp [0..1] | blend [0..1]\nfloat Quantize(float y, float count, float sharp, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count), y, blend);\n}\n\nvec3 Quantize(vec3 v, float count, float sharp, float blend)\n{\n    return vec3(Quantize(v.r, count, sharp, blend),\n                Quantize(v.g, count, sharp, blend),\n                Quantize(v.b, count, sharp, blend));\n}\n\nfloat QBumps(float y, float count, float sharp)\n{\n    if(count == 0.0) return 0.0;\n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return sharp == 1.0 ? 0.0 : BUMPMAP(sharp*0.5, 1.0 - sharp*0.5, yf);\n}\n\nvec3 QBumps(vec3 v, float count, float sharp)\n{\n    return vec3(QBumps(v.r, count, sharp),\n                QBumps(v.g, count, sharp),\n                QBumps(v.b, count, sharp));\n}\n\n\n// count [0..s] | sharp [0..1] | bias [0..0.5..1] | blend [0..1]\nfloat Quantize2(float y, float count, float sharp, float bias, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float y0 = y;\n    \n        float yu = y;\n    yu = Bias(yu, bias);\n    \n    float sw = 1.0 / count * 0.5 * sharp;\n    yu = mix(sw, 1.0 - sw, yu);    \n    \n\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(Bias((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count, 1.0-bias), y0, blend);\n}\n\n// count [0..s] | sharp [0..1] | blend [0..1]\nfloat Quantize2(float y, float count, float sharp, float blend)\n{\n    if(count == 0.0) return y;\n    \n    float y0 = y;\n    \n    float sw = 1.0 / count * 0.5 * sharp;\n    y = mix(sw, 1.0 - sw, y);     \n    \n    float yu = y;\n    yu *= count;\n    float yi = floor(yu);\n    float yf = yu - yi;\n\n    return mix(((yi + (sharp == 1.0 ? (yf < 0.5 ? 0.0 : 1.0) : STEPMAP(sharp*0.5, 1.0 - sharp*0.5, yf))) / count), y0, blend);\n}\n#undef STEPMAP\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    float knobVal   = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n\n    int KnobMatId = 0;\n    ivec2 KnobMatStateBuffOrigin = ivec2(KnobMatId * 4, KnobMatStateBuffY0);\n\n    A.x = texelFetch(iChannel0, ivec2(0, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.y = texelFetch(iChannel0, ivec2(1, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.z = texelFetch(iChannel0, ivec2(2, 0) + KnobMatStateBuffOrigin, 0).w;\n    //A.w = texelFetch(iChannel0, ivec2(3, 0) + KnobMatStateBuffOrigin, 0).w;\n\n    B.x = texelFetch(iChannel0, ivec2(0, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.y = texelFetch(iChannel0, ivec2(1, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.z = texelFetch(iChannel0, ivec2(2, 1) + KnobMatStateBuffOrigin, 0).w;\n    //B.w = texelFetch(iChannel0, ivec2(3, 1) + KnobMatStateBuffOrigin, 0).w;\n\n    C.x = texelFetch(iChannel0, ivec2(0, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.y = texelFetch(iChannel0, ivec2(1, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.z = texelFetch(iChannel0, ivec2(2, 2) + KnobMatStateBuffOrigin, 0).w;\n    //C.w = texelFetch(iChannel0, ivec2(3, 2) + KnobMatStateBuffOrigin, 0).w;\n\n    D.x = texelFetch(iChannel0, ivec2(0, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.y = texelFetch(iChannel0, ivec2(1, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.z = texelFetch(iChannel0, ivec2(2, 3) + KnobMatStateBuffOrigin, 0).w;\n    //D.w = texelFetch(iChannel0, ivec2(3, 3) + KnobMatStateBuffOrigin, 0).w;\n        \n\n    {\n        vec2 tex = uv0;\n        tex -= iResolution.xy * 0.5;\n        tex /= iResolution.yy * 0.4;\n\n        //tex *= 0.25+0.0375;\n\n\n        col = mix(vec3(1.0), vec3(0.95), Grid(tex.xy * 4.0, 0.0));        \n        col = mix(col, vec3(0.75), Grid(tex.xy * 1.0, 0.0));        \n        col = mix(col, vec3(0.5), Cross(tex.xy * 1.0, 0.)); \t\n\n\n        // relevant plotting code:\n\n        // black\n        float f = clamp(tex.x * 0.5 + 0.5, 0.0, 1.0);\n        {\n            float count = round(mix(1.0, 8.0, A.x));\n            \n            float sharp = B.x;\n            \n            float bias = C.x;\n            \n            float blend = D.x;\n\n            f = Quantize(f, count, sharp, bias, blend);\n        }\n        f = f * 2.0 - 1.0;\n        \n        col = mix(col, vec3(0.), Graph(f - tex.y, 1.));  \n    }\n\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n\n#if 1\n//if(ReadKeyToggle(KEY_TAB) != 0.0)\n{    \n    #if 0\n    {\n        float width = KnobSizeTotal * 4.0;\n        \n        if(uv.x < width+4.0 && uv.y > GetKnobMatPosY1()-4.0 && uv.y < GetKnobMatPosY0() + 48.0+2.0)\n        {\n            col *= 0.75;\n        }\n         \n    }\n    #endif\n    \n    // knobs\n    vec3 ui = texelFetch(iChannel0, ivec2(uv), 0).rgb;\n    \n    vec3 kcol = vec3(0.1);\n    if(ui.z == 1.0) kcol = vec3(0.1, 0.0, 0.0); else\n    if(ui.z == 2.0) kcol = vec3(0.0, 0.05, 0.0); else\n    if(ui.z == 3.0) kcol = vec3(0.0, 0.0, 0.18); else\n    if(ui.z == 4.0) kcol = vec3(0.1, 0.1, 0.0); else\n    if(ui.z == 5.0) kcol = vec3(0.0, 0.08, 0.08); else\n    if(ui.z == 6.0) kcol = vec3(0.1, 0.0, 0.1);\n    \n    //col = mix(col, kcol, ui.y);\n    //col = mix(col, kcol*(1.0-ui.y), ui.y);\n    col = mix(col, vec3(0.0), ui.y);\n    col = mix(col, mix(kcol*10.0, vec3(1.0), 0.5), ui.x*1.5);\n    //col = mix(col, vec3(0.99), ui.x);\n}\n#endif\n\n\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* persistent state stuff and knobs */\n\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec3 Knob(vec2 uv, KnobState state)\n{\n    if(state.colId < 0.0) return vec3(0.0);\n    \n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.18);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0., 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.18, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    \n    return vec3(r, 1.0 - sh, state.colId);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf);// * 0.999;\n}\n\nfloat KnobMatIdButtonMat(inout vec4 col, vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n    \n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    float ButtonCountX = 4.0;\n    float ButtonCountY = 2.0;\n\n    if(uv2.x < width && uv2.y >= 0.0 && uv2.y < height)\n    {\n        float wi = width / ButtonCountX;\n        float hi = height / ButtonCountY;\n\n        float ix = 0.0;\n        float iy = 1.0;\n\n        ix = floor(uv2.x / wi);\n        uv2.x = (uv2.x / wi - ix) * wi;\n\n        iy = floor(uv2.y / hi);\n        uv2.y = (uv2.y / hi - iy) * hi;\n        iy = float(ButtonCountY) - 1.0 - iy;\n\n        uv2 -= vec2(wi, hi) * 0.5;\n\n        float buttonSizeMod = 2.0;\n        float l = length(uv2) + buttonSizeMod;\n\n        float ll = min(wi, hi) * 0.5;\n\n        float i = ix + iy * ButtonCountX;\n\n        bool isActive = int(i) == ActiveKnobMatId;\n\n        float buttonOpacity = isActive ? 1.0 : 0.5;\n        float shadowOpacity = isActive ? 0.6 : 0.4;\n\n        col.rgb = vec3(smoothstep(ll-3.0, ll-4.5, l)       * buttonOpacity , \n                   pow(smoothstep(ll    , ll-4.0, l), 2.0) * shadowOpacity, .0);\n                   \n        return i;\n    }\n    \n    return -1.0;\n}\n\nfloat KnobMatIdButtonMat(vec2 uv)\n{\n    vec4 col;\n    return KnobMatIdButtonMat(col, uv);\n}\n\n/*\nbool IsUIPixel(vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n\n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    if(uv.x < width && uv2.y >= 0.0 && uv2.y < height) return true;\n\n    if(uv.x < width && uv.y < GetKnobMatPosY0() && uv.y > GetKnobMatPosY1() ) return true;\n    \n    return false;\n}\n*/\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    //col = texelFetch(iChannel0, ivec2(0), 0);\n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n    //float numKeyLast    = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    //float numKey = \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n   // ActiveKnobMatId = ReadKeyToggle(KEY_TAB) != 0.0 ? 1 : 0;\n    if(isClick)\n    {\n        float i;\n        if((i = KnobMatIdButtonMat(iMouseClick.xy)) >= 0.0)\n        {\n            ActiveKnobMatId = int(i);\n        }\n    }\n        \n    if(uv.y >= float(KnobMatStateBuffY0) && uv.y < float(KnobMatStateBuffY0 + 4))\n    {\n        int ActiveKnobMatIdTemp = ActiveKnobMatId;\n        \n        ActiveKnobMatId = int(uint(uv.x) / 4u);\n        \n        bool IsKnobMatActuallyActive = ActiveKnobMatId == ActiveKnobMatIdTemp;\n        \n        ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n    \n        KnobState knob;\n    \tif(GetKnob(ivec2(uv) - KnobMatStateBuffOrigin, iChannel0, frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick && IsKnobMatActuallyActive && knob.colId >= 0.0)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                float n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                //n = round(n*32.0)/32.0;\n                knobVal = knob.n = n;\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;\n        }\n        \n        ActiveKnobMatId = ActiveKnobMatIdTemp;\n    }\n    \n    float knobVal0 = 0.0;\n    {\n        KnobState knob; int i;\n        if((GetKnob(iMouseClick.xy, iChannel0, /*out*/ knob).x) >= 0)\n        {\n            knobVal0 = knob.n;\n            didInteractUI = true;\n        }\n        \n        //if(uv.y != 4.0) knobVal0 = knobVal;\n    }\n    \n    {\n        KnobState state;\n        bool isKnob = GetKnob(uv0, iChannel0, frameAccuLast == 0.0, /*out*/ state).x >= 0;\n\n        if(isKnob)\n        {\n            vec3 k = Knob(uv0, state);\n            col.rgb = k;\n        }\n        \n    \tValueText(col, uv0, knobVal0);\n        //KnobMatIdButtonMat(col, uv0);\n    }\n    \n\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n    WriteVar(float(ActiveKnobMatId), J);\n\n    WriteVar2(iMouseClick,  J);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 Resolution;\n\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat Intersect_Ray_Sphere(vec3 rp, vec3 rd, vec3 sp, float sr2, out vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(1.0 - s1*s1);\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(1.0 - abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// Box-Muller Transform: \n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n// u (0..1] | v [-1..1]\nvec2 Sample_Gauss2D(float u, float v)\n{\n    float l = sqrt(-2.0 * log(u));\n    \n    return vec2(cos(v * Pi), sin(v * Pi)) * l;\n}\n\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n// ===============================================  KNOB STUFFS  =========================================================================== //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    float colId;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.colId = 0.0;\n    state.n = n;\n\n    return state;\n}\n\nint ActiveKnobMatId = 0;\n\nconst int KnobMatCount = 2; \nconst int KnobMatKnobCount = 16;\nconst int KnobCount = KnobMatKnobCount * KnobMatCount;\n\nconst int KnobMatStateBuffY0 = 5;\nconst int KnobMatStaticStateBuffY0 = 9;\n\nconst float KnobOuterRadius = 16.0; \nconst float KnobCircleThick =  4.0; \nconst float KnobPadding     =  4.0; \nconst float KnobSizeTotal   =  2.0 * (KnobOuterRadius + KnobPadding);\nfloat GetKnobMatPosY0() { return Resolution.y*0.5 + (KnobSizeTotal*2.0); } \nfloat GetKnobMatPosY1() { return Resolution.y*0.5 - (KnobSizeTotal*2.0); } \n \nKnobState GetKnobOfMat(ivec2 xy, bool signed, float n, float colId)\n{\n    float x = float(xy.x);\n    float y = float(xy.y);\n    \n    KnobState knob;\n    knob.p.x = 0.5 * KnobSizeTotal + x * KnobSizeTotal;\n    knob.p.y = 0.5 * KnobSizeTotal + y * KnobSizeTotal;\n    \n    knob.p.y = GetKnobMatPosY0() - knob.p.y;\n\n    knob.r = vec2(KnobOuterRadius, KnobCircleThick);\n    knob.signed = signed;\n    knob.colId = colId;\n\n\tknob.n = n;\n    \n    return knob;\n}\n\nbool GetKnob0(ivec2 xy, sampler2D stateBuffer, out KnobState knob)\n{\n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    if(xy.x < 0 || xy.x > 3 || \n       xy.y < 0 || xy.y > 3) return false;\n\n    if(ActiveKnobMatId < 0 || ActiveKnobMatId >= KnobMatCount) return false;\n\n    int i = xy.x + xy.y * 4;\n    \n    i += ActiveKnobMatId * KnobMatKnobCount;\n    \n    const bool fals = false;\n    const bool IsSigned[KnobCount] = bool[]\n    (\n        //========  0  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals // D\n    );\n    \n    const float DefaultValue[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.25, 0.5, 0.5, 0.0,// A \n        0.5, 0.0, 0.0, 0.0,// B \n        0.5, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );\n    \n    const float ColId[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.0, -1.0, -1.0, -1.0,// A \n        0.0, -1.0, -1.0, -1.0,// B \n        0.0, -1.0, -1.0, -1.0,// C \n        0.0, -1.0, -1.0, -1.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );    \n    \n    knob = GetKnobOfMat(xy, IsSigned[i], DefaultValue[i], ColId[i]);\n    \n    return true;\n}\n\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n\tif(!GetKnob0(xy, stateBuffer, /*out*/ knob)) return false;\n\n    ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n\n    if(!doInit)\n    knob.n = texelFetch(stateBuffer, KnobMatStateBuffOrigin + xy, 0).w;\n    \n    return true;\n}\n\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(xy, stateBuffer, false, knob);\n}\n\nivec2 GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    int x = int(floor(uv.x / KnobSizeTotal));\n    int y = int(floor((GetKnobMatPosY0() - uv.y) / KnobSizeTotal));\n    \n    if(x < 0 || x >= 4 || y < 0 || y >= 4) return ivec2(-1, -1);\n    \n    {\n    \tif(!GetKnob0(ivec2(x, y), stateBuffer, /*out*/ knob)) return ivec2(-1, -1);\n        \n        if(SqrLen(uv - knob.p) < Pow2(knob.r.x + KnobPadding))\n        {\n            ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n        \n\t        if(!doInit)\n            knob.n = texelFetch(stateBuffer, KnobMatStateBuffOrigin + ivec2(x, y), 0).w;\n\n            return ivec2(x, y);\n        }\n    }\n    \n    return ivec2(-1, -1);\n}\n\nivec2 GetKnob(vec2 uv, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(uv, stateBuffer, false, /*out*/ knob);\n}\n\n/*\nbool WriteKnobMatStaticStateToTexture(inout vec4 col, ivec2 uv)\n{\n    int i = uv.x;\n    int j = uv.y - KnobMatStaticStateBuffY0;\n\n    if(i < 0 || i >= KnobCount) return false;\n    if(j < 0 || j >= 3        ) return false;\n    \n    \n    const bool fals = false;\n    const bool IsSigned[KnobCount] = bool[]\n    (\n        //========  0  ========//\n        true, true, true, fals,// A\n        true, true, fals, fals,// B\n        fals, fals, true, true,// C\n        true, true, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals // D\n    );\n    \n    const float DefaultValue[KnobCount] = float[]\n    (\n        //======  0  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n       -1.0, 1.0, 0.0, 0.0,// D\n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );\n    \n    const float ColId[KnobCount] = float[]\n    (\n        //======  0  ======//\n        5.0, 5.0, 4.0, 4.0,// A \n        2.0, 2.0, -.1, -.1,// B \n        1.0, 1.0, 1.0, 1.0,// C \n        0.0, 0.0, -.1, -.1,// D\n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0 // D \n    );  \n    \n    if(j == 0) { col.w = IsSigned[i] ? 1.0 : 0.0; }\n    if(j == 1) { col.w = DefaultValue[i]; }\n    if(j == 2) { col.w = ColId[i]; }\n    \n    return true;\n}\n    bool IsSigned2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 0), 0).w != 0.0;\n    float DefaultValue2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 1), 0).w;\n    float ColId2 = texelFetch(stateBuffer, ivec2(i, KnobMatStaticStateBuffY0 + 2), 0).w;\n    knob = GetKnobOfMat(xy, IsSigned2, DefaultValue2, ColId2);\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsyD8.jpg", "access": "api", "license": "cc0-1.0", "functions": [[369, 369, 397, 397, 451], [452, 452, 486, 486, 540], [542, 542, 573, 573, 629], [630, 630, 661, 661, 712], [713, 713, 744, 744, 816], [817, 817, 848, 848, 941], [943, 943, 971, 971, 997], [998, 998, 1026, 1026, 1053], [1054, 1054, 1082, 1082, 1109], [1110, 1110, 1138, 1138, 1165], [1185, 1337, 1367, 1367, 1516], [1518, 1518, 1560, 1560, 1620], [1622, 1622, 1669, 1669, 1765], [1767, 1767, 1806, 1806, 1895], [1948, 2013, 2089, 2089, 2378], [2381, 2427, 2491, 2491, 2741], [2743, 2743, 2805, 2805, 2964], [2966, 2966, 3015, 3015, 3214], [3216, 3216, 3263, 3263, 3395], [3398, 3463, 3540, 3540, 3946], [3948, 3994, 4059, 4059, 4415], [4432, 4432, 4478, 4478, 8151]]}
{"id": "NtscDH", "name": "Fork Ink Splatt elvi5tim 034", "author": "elvi5tim", "description": "Ink splatter\n\nTried to recreate this effect:\nhttps://www.youtube.com/watch?v=mI1fhT2IMMU\n\nTechniques picked from this tutorial\n(Regarding seamless radial noise)\nhttps://www.youtube.com/watch?v=JYbgjCR8PMI\n\nCodes: https://www.shadertoy.com/view/Md33zB", "tags": ["ink", "paper", "splatter", "reveal"], "likes": 8, "viewed": 381, "published": 3, "date": "1647947049", "time_retrieved": "2024-07-30T16:57:25.402254", "image_code": "// https://www.shadertoy.com/view/Md33zB\n// 3D simplex noise from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t vec4 w, d;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f = 0.0;\t\n\tfloat frequency = 1.0;\n\tfloat amplitude = 0.5;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += simplex3d(p * frequency) * amplitude;\n\t\tamplitude *= 0.5;\n\t\tfrequency *= 2.0 + float(i) / 100.0;\n\t}\n\treturn min(f, 1.0);\n}\n\nfloat random (in vec2 st) \n{ \n    return fract(sin(dot(st.xy,vec2(12.9798,78.323)))* 43858.5563313);\n}\n\n// -----------------------------------------------------------------------------\n\n// Recreating the effect from After Effects\nvec2 rectToPolar(vec2 p, vec2 ms) {\n\tp -= ms / 2.0;\n\tconst float PI = 3.1415926534;\n\tfloat r = length(p);\n\tfloat a = ((atan(p.y, p.x) / PI) * 0.5 + 0.5) * ms.x;\n\treturn vec2(a, r);\t\n}\n\n// A line as mask, with 'f' as feather\nfloat line(float v, float from, float to, float f)\n{\n\tfloat d = max(from - v, v - to);\n\treturn 1.0 - smoothstep(0.0, f, d);\n}\n\n// -----------------------------------------------------------------------------\n\nfloat effect(vec2 p, float o) {\n    \n    p *= 2.0;\n    \n    //float f1 = fbm(vec3(p * vec2(13.0, 1.0) + 100.0 + vec2(0.0, o), iTime * .005) ) * 0.5;\n    float f1 = simplex3d(vec3(p * vec2(1.0, 5.0), iTime * 0.05) ) * 0.5 + 0.5;\n    \n \tfloat e = fbm(vec3(p * vec2(15.0, 1.0) + vec2(f1 * 0.85, o), iTime * .005));\n    \n    e = abs(e) * sqrt(p.y / 5.0);\n    \n    float c2 = simplex3d(vec3(p * vec2(6.0, 2.0), iTime * 0.05));\n    \n    c2 = (c2 * 0.5) + 0.5;\n    c2 *= 0.5; //sqrt(p.y / 5.0);\n    \n    e += c2;\n    \n    return e * 0.5;\n}\n\n// ShockWave technique\nfloat sw(vec2 p, vec2 ms) {\n\t\t\n\tp = rectToPolar(p, ms);\n\t\n\t// Offset it on the x\n\tp.x = mod(p.x + 0.5, ms.x);\n\t\n\t// Create the seem mask at that offset\n\tconst float b = 0.5;\n\tconst float d = 0.04;\n\tfloat seem = line(p.x, -1.0, d, b) + line(p.x, ms.x - d, ms.x + 1.0, b);\n\tseem = min(seem, 1.0);\n\t\n\tfloat s1 = effect(p, 0.0);\n\t\n\t// Create another noise to fade to, but the seem has the be at a different position\n\tp.x = mod(p.x + 0.6, ms.x);\n\tfloat s2 = effect(p, -1020.0);\n\t\n\t// Blend them together\n\tfloat s = s1;\n\ts = mix(s1, s2, seem);\n\t\n\t//float m = line(p.y, -0.1, 0.2 + s * 0.9, 0.2);\n    \n    float perc = min( max(abs(sin(iTime * 0.1)), iTime * 0.1), 1.0);\n    //float perc = 0.8;\n    \n    float f1 = perc * 0.25;\n    float f2 = perc * 1.;\n    \n    float m = line(p.y, -0.1, f1 + s * f2, 0.2);\n\t\n\treturn smoothstep(0.31, 0.6, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.yy;\n    \n    float m = iResolution.x / iResolution.y;\n\tvec2 ms = vec2(m, 1.0);\n     \n    float c = 0.0;\n    \n    float s = sw(p, ms);\n    c += s;\n    \n    float t = random(p * 4.0);\n        \n    float shade = fbm(vec3(p * 3.0, iTime * 0.1) ) * 0.5 + 0.5;\n    \n    shade = sqrt( pow(shade * 0.8, 5.5) );\n    \n    vec3 pic = vec3(shade); // * texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n   \tvec3 col = mix(vec3(0.95, 0.96, 0.8), pic, c); \n    \n    // Some grain\n    col -= (1.0 - s) * t * 0.04;\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtscDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 186, 186, 383], [385, 385, 410, 410, 1010], [1012, 1012, 1031, 1031, 1258], [1260, 1260, 1288, 1288, 1362], [1446, 1490, 1525, 1525, 1673], [1675, 1714, 1766, 1766, 1839], [1923, 1923, 1954, 1954, 2455], [2457, 2480, 2507, 2507, 3318], [3320, 3320, 3377, 3377, 3954]]}
{"id": "ftXyDr", "name": "Giza Necropolis - Sunrise", "author": "sandaruwan", "description": "Nine pyramids of the Giza pyramid complex.", "tags": ["pyramids", "giza"], "likes": 26, "viewed": 517, "published": 3, "date": "1647941701", "time_retrieved": "2024-07-30T16:57:26.504307", "image_code": "/*---------------------------------------------\n\nGiza Necropolis, Sandaruwan Silva 2022\n\nNine pyramids of the Giza pyramid complex.\n\n1. Clouds and noise functions etc. based on Inigo Quilez's Rainforest\n   https://www.shadertoy.com/view/4ttSWf\n2. Dust storm roughly based on VoidChicken's The Rude Sandstorm \n   https://www.shadertoy.com/view/Mly3WG\n\n---------------------------------------------*/\n\nfloat sdSphere(in vec3 p, in float radius) {\n     return length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat sdOctahedronStepped(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x + floor(p.y * 15.0) / 15.0 + p.z - s) * 0.47735027;\n}\n\nfloat sdGiza(in vec3 p, in float s, in float dmg) {\n    p = abs(p);\n    float v = (p.x + p.y + p.z - s) * 0.57735027;\n    \n    p.y -= s + 0.25 - dmg;\n    \n    float b = sdBox(p, vec3(0.25));\n    v = max(v, -b);\n    return v;\n}\n\n// -- cloud generation -----------------------\n\nvec4 sky( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0.3, 0.4, 1.0) - rd.y * 0.7;\n    float t = (1000.0 - ro.y) / rd.y;\n\n    \n    if(t > 0.0) {\n        vec2 uv = (ro + t * rd).xz;\n        float cl = fbm_9(uv * 0.002 - iTime * 0.2);\n        float dl = smoothstep(-0.2, 0.6, cl);\n        col = mix(col, vec3(1.0), 0.12 * dl);\n    }\n    \n\treturn vec4(col, t);\n}\n\n// -- scene ----------------------------------\n\n// scene map\nvec3 map(in vec3 p) {\n    vec3 res = vec3(-1.0);\n    \n    vec3 offset = vec3(0.3, 0.0, -8.0);\n    vec3 offset2 = vec3(0.6, 0.0, -8.0);\n    \n    float d = 0.0;\n    \n    // noise values\n    float nv1 = noise(p * 0.25 + 2.1);\n    float nv2 = noise(p * 230.0 + 2.1);\n    float nv3 = noise(p * 12.5 + 2.1);\n    float nv4 = noise(vec3(p.x, p.y, 0.0) * 1.5 + 2.1);\n    float nv5 = noise(p * 49.5 + 2.1);\n    float nv6 = noise(vec3(p.x, p.y, 0.0) * 0.5 + 2.1);\n    \n    \n    // height map\n    float heightMap = nv1 * 0.5 + nv2 * 0.002;\n    float terrain = p.y + heightMap;\n    \n    // common values for pyramids\n    vec3 mainOffset = p * rotate_y(PI_4) + offset;\n    float mainNoise1 = nv3 * 0.02;\n    float mainNoise2 = nv4 * 0.07;\n    float mainNoiseTop = nv5 * 0.015;\n    \n    vec3 smallOffset = p * rotate_y(PI_4) + offset2;\n    \n    float ySin = smoothstep(0.93, 1.0, sin(p.y * 400.0)) * 0.01;\n    float xSin = smoothstep(0.94, 1.0, sin(p.x * 260.0)) * 0.005;\n    float zSin = smoothstep(0.94, 1.0, sin(p.z * 260.0)) * 0.005;\n    float sinComb = ySin + xSin + zSin;\n    \n    float ySinM1 = smoothstep(0.2, 1.0, sin(p.y * 200.)) * 0.007;\n    float xSinM1 = smoothstep(0.2, 1.0, sin(p.x * 200.)) * 0.005;\n    float zSinM1 = smoothstep(0.2, 1.0, sin(p.z * 200.)) * 0.005;\n    float sinMComb1 = ySinM1 + xSinM1 + zSinM1;\n    \n    float ySinM2 = smoothstep(0.2, 1.0, sin(p.y * 100.)) * 0.005;\n    float xSinM2 = smoothstep(0.2, 1.0, sin(p.x * 100.)) * 0.005;\n    float zSinM2 = smoothstep(0.2, 1.0, sin(p.z * 100.)) * 0.005;\n    float sinMComb2 = ySinM2 * 4.0 + xSinM2 + zSinM2;\n    \n    // pyramid of Menkaure, one in the front\n    float p1 = sdGiza(mainOffset + vec3(-3.0, 2.8, 1.0),\n        4.9 - sinMComb1 - mainNoise1 * 0.2 - nv5 * 0.01 - mainNoise2 * 0.2, 0.08);\n    \n    // pyramid of Khafre, one in the middle\n    float p2 = sdOctahedron(mainOffset + vec3(0.0, 2.0, 15.0),\n        7.5 - sinMComb2 - mainNoise1 - mainNoise2);\n    // pyramid top\n    float ptop = sdGiza(mainOffset + vec3(0.01, -4.0, 14.98),\n        1.58 - mainNoiseTop, 0.05);\n    ptop = max(ptop, -sdSphere(mainOffset + vec3(0.04, -1.8, 13.98), 2.8 + nv1 * 0.2 +  nv3 * 0.1));\n\n    // pyramid of Khufu, distant one\n    float p3 = sdGiza(mainOffset + vec3(0.0, 2.0, 30.0),\n        8.0 - sinMComb2 - mainNoise1 - mainNoise2, 0.2);\n\n    // queens' pyramids\n    float p4 = sdOctahedronStepped(smallOffset + vec3(-5.6, 0.47, -4.4),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    float p5 = sdOctahedronStepped(smallOffset + vec3(-6.0, 0.37, -4.0),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    float p6 = sdOctahedronStepped(smallOffset + vec3(-6.4, 0.34, -3.6),\n        0.58 - sinComb - nv5 * 0.02 - nv6 * 0.07);\n    \n    // remove algorithmic artifacts on the top\n    p5 = max(p5, -sdBox(smallOffset + vec3(-6.0, -0.3, -4.0), vec3(0.1)));\n    \n    // spheres to smoothen the pyramids\n    float s4 = sdSphere(p + vec3(5.2, 0.2, -12.3), 0.3);\n    float s5 = sdSphere(p + vec3(4.7, 0.1, -12.3), 0.22);\n    float s6 = sdSphere(p + vec3(4.2, 0.1, -12.3), 0.22);\n    \n    \n    // other pyramids in the complex\n    // represent them with just spheres since they're far away\n    float s7 = sdSphere(p + vec3(-22.2, -1.1, 11.0),\n        0.2 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    float s8 = sdSphere(p + vec3(-22.2, -0.7, 13.0),\n        0.5 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    float s9 = sdSphere(p + vec3(-22.2, -0.5, 15.0),\n        0.5 - ySin - xSin - zSin - nv5 * 0.01 - nv6 * 0.07);\n    \n    \n    d = min(terrain, p1);\n    d = min(d, p2);\n    d = min(d, ptop);\n    d = min(d, p3);\n    \n    d = opSmoothUnion(d, s7, 2.6);\n    d = opSmoothUnion(d, s8, 1.2);\n    d = opSmoothUnion(d, s9, 1.2);\n    \n    // add queens' pyramids\n    d = opSmoothUnion(opSmoothUnion(d, p4, 0.05), s4, 0.2);\n    d = opSmoothUnion(opSmoothUnion(d, p5, 0.05), s5, 0.2);\n    d = opSmoothUnion(opSmoothUnion(d, p6, 0.05), s6, 0.2);\n    \n    res.x = d;\n    return res;\n}\n\n// ray marching through terrain and objects\nvec3 trace(in vec3 ro, in vec3 rd) {\n    float tMax = 1000.0;\n    vec3  res  = vec3(-1.0);\n    vec3  last = vec3(0.0);\n    float t    = 0.0;\n\n    vec3 dust = vec3(1.0);\n    \n    for (int i = 0; i < 150; i++) {\n        vec3 pos = ro + t * rd;\n        vec3 hit = map(pos);\n        \n        if (abs(hit.x) < 0.0001 * t || t > tMax) break;\n\n        t += hit.x;\n        last = hit;\n\n        // add dust cloud\n        vec3 a = vec3(noise(pos + iTime * 0.13) + 0.1);\n        dust += a * sqrt(float(i)) * 1.0 *\n            pow(smoothstep(0.0, 1.0, clamp(float(i) / 15.0, 0.0, 1.0)), 1.0 / 2.5);\n    }\n    \n    if (t < tMax) {\n        res = vec3(t, last.yz);\n    }\n    \n    dust.x = clamp(dust.x, -200.0, 200.0);\n    res.y = dust.x * 0.001;\n    return res;\n}\n\n// calculate normals\nvec3 calcNormal(in vec3 p, in float t) {\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1),\n            ((i >> 1) &1 ),(i & 1)) - 1.0);\n        n += e * map(p + e * 0.001 * t).x;\n    }\n    \n    return normalize(n);\n}\n\n// calculate ao\nfloat calcAO(in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i=0; i < 5; i++) {\n        float h = 0.001 + 0.15 * float(i) / 4.0;\n        float d = map(pos + h * nor).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);    \n}\n\n// camera/projection\nmat3 camera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2  p    = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3  col  = vec3(0.0);\n    float time = iTime;\n    \n    // set up camera/projection\n    float an = -0.35;\n    float ra = 17.0;\n    float fl = 4.0;\n    vec3  ta = vec3(sin(time * 0.13 - 0.1) * 0.1,\n        cos(time * 0.1 - 4.0) * 0.05 + 0.1, 0.0);\n    vec3  ro = ta + vec3(ra * sin(an), 0.0, ra * cos(an));\n    mat3  ca = camera(ro, ta, 0.0);\n    vec3  rd = ca * normalize(vec3(p.x + 0.3, p.y + 0.4,fl));\n    \n    // ray marching\n    vec3 ray = trace(ro, rd);\n    float resT = 1000.;\n    \n    if (ray.x >= 0.0) {\n        float t   = ray.x;\n        vec3 pos  = ro + t * rd;\n        vec3 norm = calcNormal(pos, t);\n        \n        // prepare diffusion\n        float sun_dif = clamp(dot(norm, sun_direction), 0.0, 1.0);\n        vec3  sky_dir = normalize(vec3(0.0, 1.0, 0.0));\n        float sky_dif = clamp(dot(norm, sky_dir), 0.0, 1.0);\n        \n        // set up cheap shadows\n        float sun_sha = trace(pos + norm * 0.0001, sun_direction).x;\n        float dif = clamp(sun_dif, 0.0, 1.0);\n        \n        col += vec3(0.6, 0.4, 0.2) * dif * 1.29;\n        col += vec3(0.6, 0.4, 0.8) * sky_dif * 0.4;\n        col *= calcAO(pos, norm);\n        \n        if (sun_sha > 0.0) {\n            col *= 0.5;\n        }\n        \n        col += ray.y * vec3(1.0, 0.8, 0.4) * 0.6;\n        \n        col = fog(col, t);\n        col *= 0.5 + 0.5 * vec3(0.8, 0.3, 0.0);\n \n    } else {\n        vec4 sky_color = sky(ro, rd);\n        col = sky_color.rgb;\n        \n        col = fog(col, sky_color.a * 0.01);\n    }\n    \n\n    // gamma\n    col = pow(clamp(col * 1.1 - 0.04, 0.0, 1.0), vec3(0.4545));\n\n    // contrast\n    col = col * col * (3.0 - 2.0 * col);            \n\n    // add sun glare\n    float sun = clamp(dot(sun_direction, rd), 0.0, 1.0);\n    col += 0.75 * vec3(0.8, 0.4, 0.2) * sun * sun * sun;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n#define PI_4 0.78539816339\n\nconst vec3 sun_direction = normalize(vec3(0.8, 0.3, -0.6));\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2  = mat2( 0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nmat3 rotate_x(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(1.0, 0.0, 0.0),\n        vec3(0.0, ca, sa), vec3(0.0, -sa, ca));\n}\n\nmat3 rotate_y(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(ca, 0.0, sa),\n        vec3(0.0, 1.0, 0.0), vec3(-sa, 0.0, ca));\n}\n\nmat3 rotate_z(in float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(vec3(ca, sa, 0.0),\n        vec3(-sa, ca, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nfloat opSmoothUnion(in float d1, in float d2, in float k ) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec3 fog(in vec3 col, float t) {\n    vec3 ext = exp2(-t * 0.0007 * vec3(2.0, 2.5, 4.0)); \n    return col * ext + (1.0 - ext) * vec3(0.75, 0.65, 0.58);\n}\n\nfloat hash1(float n) {\n    return fract(n * 17.0 * fract(n * 0.3183099));\n}\n\nfloat hash1(vec2 p) {\n    p  = 50.0 * fract(p * 0.3183099);\n    return fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n    float n = 1.0 * p.x + 317.0 * p.y + 157.0 * p.z;\n    \n    float a = hash1(n + 0.0);\n    float b = hash1(n + 1.0);\n    float c = hash1(n + 317.0);\n    float d = hash1(n + 318.0);\n    float e = hash1(n + 157.0);\n\tfloat f = hash1(n + 158.0);\n    float g = hash1(n + 474.0);\n    float h = hash1(n + 475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y +\n        k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z +\n        k6 * u.z * u.x + k7 * u.x * u.y * u.z);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n\n    float a = hash1(p + vec2(0, 0));\n    float b = hash1(p + vec2(1, 0));\n    float c = hash1(p + vec2(0, 1));\n    float d = hash1(p + vec2(1, 1));\n    \n    return -1.0 + 2.0 * (a + (b - a) * u.x +\n        (c - a) * u.y + (a - b - c + d) * u.x * u.y);\n}\n\nfloat fbm_9( in vec2 x ) {\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    \n    for(int i = 0; i < 9; i++) {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 444, 444, 478], [480, 480, 511, 511, 602], [604, 604, 647, 647, 712], [714, 714, 764, 764, 850], [852, 852, 903, 903, 1078], [1128, 1128, 1164, 1164, 1490], [1540, 1553, 1574, 1574, 5500], [5502, 5546, 5582, 5582, 6295], [6297, 6318, 6358, 6358, 6606], [6608, 6624, 6664, 6664, 6941], [6943, 6964, 7011, 7011, 7186], [7188, 7188, 7243, 7243, 9135]]}
{"id": "ftlyD8", "name": "Hole Thing 9023420", "author": "SnoopethDuckDuck", "description": "Not sure what this is, but it's different", "tags": ["e"], "likes": 4, "viewed": 233, "published": 3, "date": "1647922765", "time_retrieved": "2024-07-30T16:57:27.524579", "image_code": "vec3 getCol(vec2 uv, float sc) {\n    vec2 ipos = floor(sc * uv);\n    vec3 e = vec3(0.5);\n    vec3 col = pal(h21(ipos), e, e, e, vec3(0,1,2)/3.);\n    \n    float m = 1.; // 0.5 looks interesting too    \n    const float n = 5.;\n    for (float i = 0.; i < n; i++) {\n        m *= 2.;\n        ipos = floor(m * sc * uv);\n        float h = h21(ipos);\n        col = mix(col, \n                  pal(h + 2. * i / n, e, e, e, col), \n                  0.5 + 0.5 * thc(4., 2. * pi * h + uv.y - 0.25 * iTime));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv += vec2(0.1,0.04) * iTime;\n    \n    float sc = 1.5;\n    \n    vec3 col = vec3(0.);\n    \n    float o = 1./(sc*80.);\n    col = max(col, getCol(uv + vec2(0, o),  sc));\n    col = max(col, getCol(uv + vec2(0, -o), sc));\n    col = max(col, getCol(uv + vec2(o, 0),  sc));\n    col = max(col, getCol(uv + vec2(-o, 0), sc));\n    \n    col = exp(-1.5 * col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 519], [521, 521, 578, 578, 1031]]}
{"id": "flscWr", "name": "minibrot flattening", "author": "peabrainiac", "description": "Visually \"flattens\"/undistorts minibrots by interpolating between their actual formulas and quadratic approximations, turning them into an exact replica of the mandelbrot set while shedding all the filaments they're surrounded with.", "tags": ["mandelbrot", "animation", "minibrot"], "likes": 13, "viewed": 364, "published": 3, "date": "1647916285", "time_retrieved": "2024-07-30T16:57:28.404227", "image_code": "// targeted minibrot/bulb; other targets can be found below\n\nconst vec2 a = vec2(-1.0,0.0);          // minibrot position\nconst vec2 scale = vec2(0.5,0.0);       // minibrot scale\nconst int n = 2;                        // minibrot period\nconst float brightnessAdjustment = 1.9; // handpicked value so the animation loops better\n\n//const vec2 a = vec2(-1.754877666,0.0);\n//const vec2 scale = vec2(0.019035516,0.0);\n//const int n = 3;\n//const float brightnessAdjustment = 1.3;\n\n//const vec2 a = vec2(-0.1225611,0.7448617);\n//const vec2 scale = vec2(-0.0095177579,-0.188673925);\n//const int n = 3;\n//const float brightnessAdjustment = 1.3;\n\n//const vec2 a = vec2(-0.504340175,0.562765761);\n//const vec2 scale = vec2(0.0455608555,-0.0627925894);\n//const int n = 5;\n//const float brightnessAdjustment = 1.25;\n\n//const vec2 a = vec2(0.359031062,-0.100934876);\n//const vec2 scale = vec2(-0.0107836821,-0.00590681318);\n//const int n = 8;\n//const float brightnessAdjustment = 0.9;\n\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvec2 cpow(vec2 a, float b){\n    float arg = b*atan(a.y,a.x);\n    float r = pow(dot(a,a),0.5*b);\n    return r*vec2(cos(arg),sin(arg));\n}\n\nconst int ITER = 250;\nconst float sampleGridSize = 0.5;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // precomputes coefficients for the linear approximation of (...(((z+a)^2+(c+a))...)^2+(c+a)\n    vec2 adz = vec2(1.0,0.0);\n    vec2 adc = vec2(0.0,0.0);\n    vec2 z = a;\n    for (int i=1;i<n;i++){\n        adz = 2.0*cmul(adz,z);\n        adc = 2.0*cmul(adc,z)+vec2(1.0,0.0);\n        z = cmul(z,z)+a;\n    }\n    \n    vec2 C = cmul(a,cdiv(scale,vec2(1.0,0.0)-scale));\n    \n    float time = mod(0.25*iTime,1.0);\n    float t = (0.5+0.5*cos(time*3.14159265358));\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    \n    for (float offsetX=-0.5+0.5*sampleGridSize;offsetX<0.5;offsetX+=sampleGridSize){\n        for (float offsetY=-0.5+0.5*sampleGridSize;offsetY<0.5;offsetY+=sampleGridSize){\n            vec2 c = -0.35*a+5.0*(fragCoord+vec2(offsetX,offsetY)-iResolution.xy*0.5)/length(iResolution.xy);\n            c = cmul((c-C),cpow(scale,time))+C;\n            z = vec2(0.0,0.0);\n            vec2 dz = vec2(1.0,0.0);\n            int i;\n            for (i=0;i<ITER&&dot(z,z)<100.0;i++){\n                // does one iteration normally\n                dz = i==0?dz:2.0*cmul(z,dz);\n                z = cmul(z,z)+c;\n                // does n-1 iterations, then linearly interpolates that with its linear approximation\n                vec2 z2 = z+a;\n                vec2 dz2 = dz;\n                for (int i2=1;i2<n&&dot(z2,z2)<1e13;i2++){\n                    dz2 = 2.0*cmul(z2,dz2);\n                    z2 = cmul(z2,z2)+c+a;\n                }\n                z = mix(cmul(adz,z)+cmul(adc,c),z2,t);\n                dz = mix(cmul(adz,dz),dz2,t);\n            }\n            float d = (i>=ITER)?1.0:pow(dot(adz,adz),t)*sqrt(dot(z,z)/dot(dz,dz))*0.5*(log(dot(z,z))+(1.0-t)*log(dot(adz,adz)));\n            d *= pow(dot(scale,scale),0.5-brightnessAdjustment*time);\n            fragColor.xyz += vec3(max(0.0,1.0-0.15*length(iResolution.xy)*d))*(sampleGridSize*sampleGridSize);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flscWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[975, 975, 1001, 1001, 1057], [1059, 1059, 1085, 1085, 1150], [1152, 1152, 1179, 1179, 1287], [1346, 1346, 1400, 1497, 3269]]}
{"id": "7lXcW8", "name": "sphere from 4 points", "author": "elenzil", "description": "Porting [url=https://stackoverflow.com/a/70846528/230851]Robert Bruce's C++ math[/url] to GLSL.\nExcept for the local function it basically a copy-paste.  Check out what's going on with #define, in the Common tab!", "tags": ["sphere", "points", "fit"], "likes": 13, "viewed": 327, "published": 3, "date": "1647889812", "time_retrieved": "2024-07-30T16:57:29.441454", "image_code": "// Fitting a sphere to four points.\n// Copy of Robert Bruce's math on SO:\n// https://stackoverflow.com/a/70846528/230851\n//\n// I was mostly curious to see how the novel use of #define\n// would port into GLSL, and it ported just fine.\n//\n// See sphereFromFourPoints() in the \"Common\" tab.\n//\n//////////////////////////////////////////////////\n\n// Fork of \"Ordinary Glass, with Comments\" by elenzil. https://shadertoy.com/view/7dlBRf\n// 2022-03-19 02:59:18\n\n\n// the maximum number of simultaneous rays in the backlog.\n// the number of rays per pixel can be more than this.\nconst uint  gMaximumRaysInQueue = 10u;\n\n// a ray must have at least this much contribution left to be enqueued.\nconst float gMinimumRayContribution = 0.005f;\n\n// #define HEATMAP\n\n\nstruct ray_t {\n    // origin\n    vec3  ro;\n    \n    // direction\n    vec3  rd;\n    \n    // what amount of the pixel this ray is contributing. [0, 1]\n    float contribution;\n    \n    // whether this ray is on the inside of the SDF.\n    bool  internal;\n};\n\n\n////////////////////////////////////////////////////////////////////////////\n// This section of code implements a ring-buffer queue for holding rays.\n// Using a queue of rays instead of a stack\n// because earlier child-rays are more important than later.\n// ie, if we used a stack, the less-contributing rays would get processed\n// earlier than the more-contributing rays, eating up our budgets.\n// This is a pretty standard implementation of a ring-buffer, not special to GLSL.\n// The only difference from an implementation in say C++ is no error-checking!\n\n// my kingdom for templates in GLSL..\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u;\nQTYPE gQ[gQNumSlots];\nuint gQHead = 0u;\nuint gQTail = 0u;\n\n// the number of items in the queue\nuint QCount() {\n\tif (gQHead >= gQTail) {\n\t\treturn gQHead - gQTail;\n\t}\n\telse {\n\t\treturn gQNumSlots - (gQTail - gQHead);\n\t}\n}\n\n// the remaining capacity of the queue\nuint QSpaceLeft() {\n\treturn gQCapacity - QCount();\n}\n\nbool QIsFull() {\n\treturn QSpaceLeft() == 0u;\n}\n\nbool QIsEmpty() {\n\treturn QCount() == 0u;\n}\n\n// add an item to the head of the queue.\n// only call this if the queue is not empty !\nvoid QEnqueue(QTYPE item) {\n\tgQHead = (gQHead + 1u) % gQNumSlots;\n\tgQ[gQHead] = item;\n}\n\n// pull an item off the tail of the queue.\n// only call this if the queue is not empty !\nQTYPE QDequeue() {\n\tgQTail = (gQTail + 1u) % gQNumSlots;\n\treturn gQ[gQTail];\n}\n\n// conditionally add a ray to the queue\nbool addRay(in ray_t ray) {\n    if (QIsFull()) {\n        return false;\n    }\n    if (ray.contribution < gMinimumRayContribution) {\n        return false;\n    }\n    QEnqueue(ray);\n    return true;\n}\n\n// do not call this if the queue is empty !\nray_t popRay() {\n    return QDequeue();\n}\n\n// this section has a bunch of globals which are configured once per pixel per frame,\n// and then re-used multiple times.\n// for example, rotation matrices used in the core map() function.\n// I haven't noticed other people doing this, perhaps there's a reason..\nfloat gViewTheta = 0.0;\nvec3  gSceneCenter = gVy * 8.0;\nfloat gRounding = 0.075;\nvec3  gLightDirection = normalize(vec3(1.0, -2.0, 1.0));\nfloat gUnderStepFactor = 1.0;\nvec2  gRes;\nbool  gDoStereo = false;\nfloat gMouseTargetRad = 50.0;\n\nfloat gSSZoom;\nvec2  gM;\n\n// map globals\nvec3  gBallPositions[4];\nfloat gBallRad;\nvec3  gCenterBallPos;\nfloat gCenterBallRad;\n\n\n\n// the maximum number of steps to raymarch.\nint   gMaxMarchStepsExternal = 250;\nint   gMaxMarchStepsInternal = 200;\n\n// more configuration.\nvoid configGlobals0() {\n    gMouseTargetRad = 50.0;\n}\n\nvoid configGlobals1() {\n    gSSZoom = 1.5;\n\n    gT = iTime * PI / 10.0;\n    gSSEps  = 3.0/MINRES/gSSZoom;\n    gSSLw   = 2.0/MINRES/gSSZoom;\n\n    vec2 M = iMouse.xy;\n    if (gDoStereo || length(M) < gMouseTargetRad) {\n        M = (vec2(cos(gT * 0.751) * 0.8, cos(gT * 0.631)) * 0.4 + 0.4) * gRes.xy;\n    };\n    gM = M / gRes.xy;\n    gViewTheta = gM.x * PI * 2.0 + 2.0;\n}\n\n// a variable to track the number of calls to map().\n// this can be displayed as a 'heat map'.\nfloat gMapCalls = 0.0;\n\n// pre-calculate values which are used in the core map() sdf function.\nvoid configMap() {\n    \n    gBallRad = 0.5;\n        \n    for (int n = 0; n < gBallPositions.length(); ++n) {\n        float height = float(n + 4) * 2.123;\n        float v0     = sqrt(2.0 * height);\n        float period = 2.0 * v0;\n        float t      = mod(gT * 3.0 + period / 2.0, period);\n        float y      = v0 * t - t * t / 2.0;\n        y += gBallRad;\n        \n        vec3 p = vec3(float(n / 2), 0.0, float(n % 2));\n        p   -= 0.5;\n        p   *= 6.0;\n        p.y  = y;\n        gBallPositions[n] = p;\n    }\n    \n    vec4 sphere = sphereFromFourPoints(\n        gBallPositions[0],\n        gBallPositions[1],\n        gBallPositions[2],\n        gBallPositions[3]);\n        \n    gCenterBallPos = sphere.xyz;\n    gCenterBallRad = sphere.w;\n}\n\nvec2 selMin(in vec2 A, in vec2 B) {\n    return A.x < B.x ? A : B;\n}\n\n// the core signed-distance-function routine.\nvec2 map(vec3 p) {\n    gMapCalls += 1.0;\n    \n    float ballMinY = 1e9;\n    float d2 = 1e9;\n    for (int n = 0; n < gBallPositions.length(); ++n) {\n        float l = length(gBallPositions[n] - p);\n        d2 = min(d2,   l - gBallRad);\n        d2 = max(d2, -(l - gBallRad * 0.94));\n        ballMinY = min(ballMinY, gBallPositions[n].y);\n    }\n    \n    float d1 = p.y;\n    d1 += 0.2 * smoothstep(gBallRad * 1.5, gBallRad * 1.0, ballMinY);\n    \n    \n    float d3 = 1e9;\n    float l = length(gCenterBallPos - p);\n    d3 = min(d3,   l - gCenterBallRad);\n    d3 = max(d3, -(l - gCenterBallRad * 0.98));\n\n    \n    vec2 ret = vec2(1e9);\n    \n    ret = selMin(ret, vec2(d1, 1.0));\n    ret = selMin(ret, vec2(d2, 2.0));\n    ret = selMin(ret, vec2(d3, 3.0));\n    \n    return ret;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gWSEps).x;\n    }\n    return normalize(n);\n}\n\n// return a ray from the camera through our pixel and into the scene.\n// uv should be 0 in the center of the viewport, not 0.5.\nray_t getCamRay(vec2 uv, bool isLeftEye) {\n\n    ray_t ray;\n    \n    float stereoSep = -0.9 * (isLeftEye ? -1.0 : 1.0);\n    \n    // this seed ray is the whole contribution of the pixel!\n    // .. or at least it is until I add anti-aliasing.\n    ray.contribution = 1.0;\n\n    float zoomFac = 0.7;\n\n    // look-from and look-to.\n    vec3  lookSrc = vec3(cos(gViewTheta), (1.4 - gM.y * 1.3) * 4.0/3.0, sin(gViewTheta)) * 20.0;\n    vec3  lookDst = gSceneCenter;\n    \n    // construct an orthobasis for the camera. altho I don't turn it into an actual matrix.\n    vec3  camFw   = normalize(lookDst - lookSrc);\n    vec3  camRt   = normalize(cross(camFw, gVy));\n    vec3  camUp   = cross(camRt, camFw);\n    \n    lookSrc += camRt * stereoSep;\n    camFw   = normalize(lookDst - lookSrc);\n    camRt   = normalize(cross(camFw, gVy));\n    camUp   = cross(camRt, camFw);\n    \n\n    \n    // determine a 'look to' point for this specific pixel.\n    // gV0 is vec3(0).\n    vec3  p       = gV0;\n    p            += lookSrc;\n    p            += camFw;\n    p            += camRt * uv.x * zoomFac;\n    p            += camUp * uv.y * zoomFac;\n    \n    // copy it to the ray.\n    ray.ro        = lookSrc;\n    ray.rd        = normalize(p - ray.ro);\n    \n    // if the camera is initially inside an object, things are going to look weird,\n    // but at least this gives them a shot at correctness.\n    ray.internal  = map(p).x < 0.0;\n    \n    return ray;\n}\n\n// ordinary raymarching.\n// return distance along ray to nearest intersection.\n// also returns the minimum distance from the ray to a surface. ie, often 0.\nvec2 marchExternal(vec3 ro, vec3 rd, out float minD) {\n    float t = 0.0;\n    minD = 1e9;\n    \n    vec3 p;\n    for (int n = 0; n < gMaxMarchStepsExternal && (dot(p, p) < 1e4); ++n) {\n        p = ro + rd * t;\n        vec2 mr = map(p);\n        float d = mr.x;\n        minD = min(minD, d);\n        if (d < gWSEps) {\n            minD = 0.0;\n            return vec2(t, mr.y);\n        }\n        \n        t += d * gUnderStepFactor;\n    }\n    \n    return vec2(1e9);\n}\n\n// raymarching in the negative side of the SDF.\nvec2 marchInternal(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    \n    for (int n = 0; n < gMaxMarchStepsInternal && t < 1e2; ++n) {\n        vec3  p = ro + rd * t;\n        vec2 mr = map(p);\n        float d = mr.x;\n        if (d > -gWSEps) {\n            return vec2(t, mr.y);\n        }\n\n        t -= d * gUnderStepFactor;\n    }\n    \n    return vec2(1e9);\n}\n\n// a function for some 'sky'. takes direction only, no positon.\n// could be replaced with a cubemap.\nvec3 sky(vec3 dir) {\n    float theta = atan(dir.z, dir.x);\n    vec3 rgb = abs(dir);\n    float absst = abs(sin(theta * 10.0 ));\n    rgb = mix(rgb, vec3(1.0), 0.2 * smoothstep(0.05, 0.0, absst - 0.2));\n    rgb *= mix(1.0, smoothstep(-0.1, 0.1, dir.y), 0.7);\n    rgb = mix(rgb, vec3(rgb.x + rgb.y + rgb.z) / 3.0, absst);\n    return rgb;\n}\n\n// takes a ray off the queue, marches it, potentially adds children to the queue.\n// repeats indefinitely until either the queue is empty or we pass a limit.\n// in a recursive implementation this would be \"processRay()\", and would call itself.\nvec3 processRays() {\n\n    // rgb is the output pixel color. start with black.\n    vec3 rgb = gV0;\n    \n    // track how many rays we've processed.\n    // stop when either that number is too large,\n    // or when the queue is empty.\n    uint processingIter;\n    for (processingIter = 0u;\n        processingIter < gQCapacity * 3u && !QIsEmpty();\n        ++processingIter) {\n        \n        // take the oldest ray out of the queue.\n        // on the first call to this method, there is only one ray in the queue,\n        // so the queue is empty after this call.\n        ray_t ray = popRay();\n        \n        // march either external or internal, depending on the ray.\n        vec2 mr;\n        if (ray.internal) {\n            mr = marchInternal(ray.ro, ray.rd);\n        }\n        else {\n            float _unused;\n            mr = marchExternal(ray.ro, ray.rd, _unused);\n        }\n        \n        float distanceAlongRayToSurface = mr.x;\n        \n        // if the returned distance is \"near\", call it a surface.\n        // if it's \"far\", call it the sky.\n        if (distanceAlongRayToSurface < 1e4) {\n        \n            // the position of the intersection\n            vec3  p    = ray.ro + distanceAlongRayToSurface * ray.rd;\n            vec3  grad = getNormal(p);\n            vec3  n    = grad;\n            \n            // If the ray is internal,\n            // we need to adjust the normal to point inwards.\n            // We also attenuate the ray's contribution according\n            // to how much material the ray passed through.\n            if (ray.internal) {\n                // surface normal is from the gradient, so flip it.\n                n = -n;\n                \n                // attenuation\n                ray.contribution *= exp(-1.0 * distanceAlongRayToSurface);\n            }\n            \n            bool isFloor = mr.y == 1.0;\n            \n            // diffuse component\n            float diffAmt = 1.0;\n            diffAmt = mr.y == 1.0 ? 0.9 : diffAmt;\n            diffAmt = mr.y == 2.0 ? 0.9 : diffAmt;\n            diffAmt = mr.y == 3.0 ? 0.1 : diffAmt;            \n            \n            // dot the surface normal with our light direction\n            float diff = max(0.0, dot(n, -gLightDirection));\n            \n            // shadows\n            // only do these if there's a point.\n            if (diff * diffAmt * ray.contribution > 0.01) {\n                // for shadows we march towards the light\n                // and take advantage of the ease with which raymarching\n                // tells you approximately how close you came to any surface,\n                // and use that for a little soft shadowing.\n                // Soft shadowing tends to being out the artifacts in raymarching,\n                // so we understep significantly.\n                // Don't forget to offset the initial point from the surface by a bit,\n                // and not to use 'n' for that, because for internal rays it points inward.\n                float minD;\n                const float penumbra = 0.1;\n                float saveUnderStep = gUnderStepFactor;\n                int   saveMaxSteps  = gMaxMarchStepsExternal;\n                gMaxMarchStepsExternal = 200;\n                gUnderStepFactor *= 0.3;\n                marchExternal(p + grad * (penumbra + 0.01), -gLightDirection, minD);\n                diff *= smoothstep(0.0, penumbra, minD);\n                gUnderStepFactor = saveUnderStep;\n                gMaxMarchStepsExternal = saveMaxSteps;\n            }\n            \n            // almost done with diffuse shading.\n            // calculate albedo, the inherent color of the surface.\n            // it's white for glass, and patterned for the floor.\n            // note this is still modulated by the 'diffAmt' factor.\n            vec3 albedo = gV1 * 0.5;\n            if (isFloor) {\n                float x = abs(cos(p.z)) - 0.5 * -cos(p.x * 1.5);\n                x = sqrt(x);\n                albedo = gV1 * 0.4 * smoothstep(0.49, 0.51, x) + 0.05;\n                albedo *= 0.3;\n                albedo.r *= 0.5;\n            }\n            \n            // ambient light.\n            // it's good to add in some of this\n            // so that albedo texture that's in shadow isn't lost.\n            diff = max(0.04, diff);\n            \n            // add the diffuse lighting to the pixel.\n            rgb += diff * ray.contribution * diffAmt * albedo;\n            \n            // add rays for reflection and transmission\n\n            // \"eta\" is the greek letter η.\n            // it's the ratio of the two indices of refraction of the mediums.\n            // eg, air to glass.\n            // we animate the index of refraction a little,\n\n            const float ior_air     = 1.0003;\n            const float ior_water   = 1.333;\n            const float ior_quartz  = 1.46;\n            const float ior_diamond = 2.42;\n\n            float eta = ior_air / ior_diamond;\n\n            // if we're transitioning from inside to outside,\n            // eta should be inverted.\n            if (ray.internal) {\n                eta = 1.0 / eta;\n            }\n\n            // The next chunk of code determines the contributions\n            // of the reflected and refracted rays.\n\n            // this is the portion of the ray contribution left for\n            // reflection and refraction, after whatever diffuse used up.\n            float reflectAndRefractAmt = 1.0 - diffAmt;\n\n            // this is what portion of the reflect/refract portion is reflect vs. refract.\n            // 0 = all reflection, no transmission\n            // 1 = all transmission, no reflection\n            float reflectVsRefract = 0.0;\n            reflectVsRefract = mr.y == 1.0 ? 0.0 : reflectVsRefract;\n            reflectVsRefract = mr.y == 2.0 ? 0.0 : reflectVsRefract;\n            reflectVsRefract = mr.y == 3.0 ? 0.9 : reflectVsRefract;\n            \n\n            // glsl conveniently provides these helpers:\n            vec3  reflectDir = reflect(ray.rd, n);\n            vec3  refractDir = refract(ray.rd, n, eta);\n\n            // refract() returns 0 if there's total internal reflection.\n            // it's critical to handle this case because it's common.\n            bool totalInternal = dot(refractDir, refractDir) == 0.0;\n\n            // no transmission if total internal reflection.\n            // no transmission for the floor\n            if (isFloor || totalInternal) {\n                reflectVsRefract = 0.0;\n            }\n\n            // The portion of the contribution for reflection and transmission\n            float reflectAmt = reflectAndRefractAmt * (1.0 - reflectVsRefract);\n            float refractAmt = reflectAndRefractAmt * reflectVsRefract;\n            float reflectContribution = ray.contribution * reflectAmt;\n            float refractContribution = ray.contribution * refractAmt;\n\n            // the origin of the ray for reflection should be offset from the surface a bit.\n            // the origin for transmission should be inset into the surface a bit.\n            vec3  reflectSrc = p + n * gWSEps * 2.0;\n            vec3  refractSrc = p - n * gWSEps * 2.0;\n\n\n            // enqueue the reflected ray. it copies the parent ray's internal-ness\n            if (!addRay(ray_t(reflectSrc, reflectDir, reflectContribution,  ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * reflectContribution;\n            }\n\n            // enqueue the transmitted ray. it inverts the parent ray's internal-ness\n            if (!addRay(ray_t(refractSrc, refractDir, refractContribution, !ray.internal))) {\n                // ray was not enqueued, either the queue was full or the contribution was too small.\n                rgb += sky(ray.rd) * refractContribution;\n            }\n            \n        }\n        else {\n            // this ray did not hit a surface. it's the sky!\n            // ray contribution is still super important here,\n            // as that's handling all the attenuation due to transmission, reflection.\n            rgb += sky(ray.rd) * ray.contribution;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid addCircle(inout vec3 rgb, in vec2 p, float rad) {\n    float lp = length(p);\n    rgb = mix(rgb, gV0, 0.1 * smoothstep(2.0, 0.0,     lp - rad));\n    rgb = mix(rgb, gV1, 0.2 * smoothstep(2.0, 0.0, abs(lp - rad)));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    configGlobals0();\n    \n    vec2 xy = XY;\n    \n    gDoStereo = length(vec2(iMouse.x, RES.y - iMouse.y)) < gMouseTargetRad;    \n    gRes = gDoStereo ? vec2(RES.x / 2.0, RES.y) : RES.xy;    \n    bool isLeftEye = XY.x < gRes.x;    \n    if (gDoStereo && !isLeftEye) {\n        xy.x -= gRes.x;        \n    }\n    \n    // set up some things we'll re-use\n    configGlobals1();\n    \n    // configure the geometry of the scene.\n    // this is called once per pixel here,\n    // but map() is called hundreds of times.\n    configMap();\n    \n    // screen-space coordinates with 0,0 at the center\n    vec2 uv = (xy - gRes.xy / 2.0) / MINRES * 2.0 / gSSZoom;\n    \n    // kick things off with a single ray for this pixel\n    addRay(getCamRay(uv, isLeftEye));\n\n    // march the ray and all its children\n    vec3 rgb = processRays();\n    \n    // gamma\n    rgb = pow(rgb, vec3(1./2.2));\n    \n    // \"UI\"\n    addCircle(rgb, XY, gMouseTargetRad);\n    addCircle(rgb, vec2(XY.x, iResolution.y - XY.y), gMouseTargetRad);\n\n    #ifdef HEATMAP\n    float pixelExpense = clamp(gMapCalls/1000.0, 0.0, 1.0);\n    rgb   *= 0.2;\n    rgb.r += pixelExpense;\n    #endif\n    \n    RGBA = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Sphere Fit\n// Fit a sphere to four points.\n// By Robert Bruce - Public Domain.\n// https://stackoverflow.com/a/70846528/230851\n\n#define _SF_U(a,b,c,d,e,f,g,h) (a.z - b.z)*(c.x*d.y - d.x*c.y) - (e.z - f.z)*(g.x*h.y - h.x*g.y)\n#define _SF_D(x,y,a,b,c) (a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y))\n#define _SF_E(x,y) ((ra*_SF_D(x,y,b,c,d) - rb*_SF_D(x,y,c,d,a) + rc*_SF_D(x,y,d,a,b) - rd*_SF_D(x,y,a,b,c)) / uvw)\n\n// returns xyz = center, w = radius\nvec4 sphereFromFourPoints(in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    float u = _SF_U(a,b,c,d,b,c,d,a);\n    float v = _SF_U(c,d,a,b,d,a,b,c);\n    float w = _SF_U(a,c,d,b,b,d,a,c);\n    float uvw = 2.0 * (u + v + w);\n    if (abs(uvw) < 1e-3) {\n        // Oops.  The points are coplanar.\n        // Replace with some epsilon appropriate for your project.\n        vec4 ret = vec4(0.0);\n        ret.xyz += a;\n        ret.xyz += b;\n        ret.xyz += c;\n        ret.xyz += d;\n        ret.xyz /= 4.0;\n        ret.w   += length(a - ret.xyz);\n        ret.w   += length(b - ret.xyz);\n        ret.w   += length(c - ret.xyz);\n        ret.w   += length(d - ret.xyz);\n        ret.w   /= 4.0;\n        return ret;\n    }\n    \n    float ra = dot(a, a);\n    float rb = dot(b, b);\n    float rc = dot(c, c);\n    float rd = dot(d, d);\n    \n    vec4 ret;\n    ret.x = _SF_E(y, z);\n    ret.y = _SF_E(z, x);\n    ret.z = _SF_E(x, y);\n    ret.w = length(a - ret.xyz);\n    return ret;\n}\n\n#undef _SF_U\n#undef _SF_D\n#undef _SF_E\n\n\n///////////////////////////////////////////////////////////////////////\n\n\n\n\n#define RES    iResolution\n#define MINRES min(RES.x, RES.y)\n#define ZERO   (min(iFrame, 0))\n\nconst float PI = 3.14159265359;\n\n// WS = world space SS = screen space\nfloat gWSEps = 0.001;  // WS epsilon for surfaces\nfloat gSSEps;          // SS epsilon for smoothstep\nfloat gSSLw;           // SS line width\nfloat gT;\n\nconst vec3 gV0 = vec3(0.0);\nconst vec3 gV1 = vec3(1.0);\nconst vec3 gVx = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gMagenta = vec3(1.0, 0.0, 1.0);\nconst vec3 gGreen   = vec3(0.0, 1.0, 0.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat opU(float A, float B) {\n    return min(A, B);\n}\nfloat opS(float A, float B) {\n    return -min(-A, B);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCylX(vec3 p, float r) {\n    return length(p.yz) - r;\n}\n\nfloat sdCylY(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdCylZ(vec3 p, float r) {\n    return length(p.xy) - r;\n}\nfloat sdPlnY(vec3 p) {\n    return p.y;\n}\nfloat sdSlabX(vec3 p, float r) {\n    return abs(p.x) - r;\n}\nfloat sdSlabY(vec3 p, float r) {\n    return abs(p.y) - r;\n}\nfloat sdSlabZ(vec3 p, float r) {\n    return abs(p.z) - r;\n}\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1769, 1805, 1820, 1820, 1928], [1930, 1969, 1988, 1988, 2021], [2023, 2023, 2039, 2039, 2069], [2071, 2071, 2088, 2088, 2114], [2116, 2203, 2230, 2230, 2290], [2292, 2381, 2399, 2399, 2459], [2461, 2501, 2528, 2528, 2697], [2699, 2743, 2759, 2759, 2784], [3530, 3553, 3576, 3576, 3606], [3608, 3608, 3631, 3631, 3977], [4098, 4169, 4187, 4187, 4916], [4918, 4918, 4953, 4953, 4985], [4987, 5033, 5051, 5051, 5803], [5806, 5964, 5987, 5987, 6186], [6188, 6316, 6358, 6358, 7745], [7747, 7903, 7957, 7957, 8362], [8364, 8412, 8450, 8450, 8764], [8766, 8867, 8887, 8887, 9202], [9204, 9448, 9468, 9525, 17600], [17602, 17602, 17656, 17656, 17819], [17821, 17821, 17864, 17864, 19034]]}
{"id": "NlfcWH", "name": "adaptive polar lines 4", "author": "FabriceNeyret2", "description": "draw a ~screenspace-constant density of curves \ngetting a unique id per line.\niMouse.y controls zoom while preserving screen-space density.", "tags": ["raytracing", "intersection", "isolines", "hatching", "balanced"], "likes": 28, "viewed": 692, "published": 3, "date": "1647884636", "time_retrieved": "2024-07-30T16:57:30.264254", "image_code": "// variant of https://shadertoy.com/view/NllczM\n// variant of https://shadertoy.com/view/flXyR7\n\n//#define S\n#define S(v) ( v - 6.283*sign(v)*step(3.14,abs(v)) )       // fight wrap discontinuity\n#define fwidth2(v) length( S( vec2( dFdx(v), dFdy(v) ) ) ) // high quality fwidyj\n#define fwidth(v)  fwidth2(v)                              // to manage wrap\n#define r(t)       mat2(cos( t + vec4(0,-1,1,0)*1.5708))   // rotation\n#define LOD(v)     exp2( round(log2(abs(.5/(v)))))\n#define hue(v)   ( .6 + .6 * cos( 6.283*(v)  + vec4(0,23,21,0)  ) )\n#define hash(p)   fract(sin( (p) * 12.9898 ) * 43758.5453)\n//#define hash(p)   fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( 2.*u - R.xy, 0 ) / R.y;                 // P on sphere surface (or background)\n // P *= exp2( 2.*sin(.5*iTime) );\n    if (iMouse.z>0.) P *= exp2( 2.*(2.*iMouse.y/R.y-1.) ); // mouse.y zoom\n    float l = length(P), n=2.,                             // n : more lines  \n          T = .3*iTime;\n    P.z = sqrt(1.-l*l);\n    P.xy *= r(T); P.yz *= r(T);                            // rotations\n    //if (P.z<0.) P.x = -P.x;   \n    float a = sign(P.z)* acos(clamp(P.x/sqrt(1.-P.y*P.y),-1.,1.)), // polar coord\n          t = sin(3.*asin(P.y)),\n          U = a + .1*cos(10.*a)  - t,  U0 = U,             // isoline to draw\n          V,\n          d = fwidth2(U),\n          z = LOD(d) ,                                     // LOD \n          f = .5 + log2(abs(.5/d)) - log2(z),              // fractional part\n          p = fwidth(U) * z*n;\n          U *= z*n;\n         \n    V = 1. - abs(sin(U)/(cos(U)*p));                       // lines\n    U0 -= tan(U0*z*n)/(z*n); // U0 = line id. reproject on the closest drawn line\n    U0 -= tan(U0*z*n)/(z*n);\n    vec4 C = sqrt(V) * hue( hash(round(mod(U0+exp2(-9.),6.283)*exp2(9.))) );\n         \n // f = max(1.5*f-.5 ,0.);                                 // shorter transition\n    O = l > 1. \n          ? vec4(0)                                        // background\n          : vec4( abs(sin(U/2.)) < .5 \n                    ? C                                    // plain line\n                    : mix( vec4(0), C, f ));               // transition lines  \n  //O = sqrt(O);                                           // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfcWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 680, 718, 718, 2323]]}
{"id": "NtXyWH", "name": "Fast path tracer v3.3", "author": "me_123", "description": "Comment on optimizations that can be made.", "tags": ["3d", "reflection", "ray", "texture", "fast", "cubemap", "tracing", "path", "scatter", "multipass"], "likes": 20, "viewed": 673, "published": 3, "date": "1647879456", "time_retrieved": "2024-07-30T16:57:31.038185", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz/=fragColor.w;\n    fragColor.xyz = 1.0-exp(-5.0*fragColor.xyz); // hand-tuned exposure rate\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.9)); // gamma correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct ray {\n    vec3 o; //Origin\n    vec3 d; //Direction\n};\nstruct rec {\n    bool hit;\n    vec3 normal;\n    float d; //distance\n    vec3 color;\n    int mat; //materal\n};\nconst rec noHit = rec(false, vec3(0), 10000., vec3(0), 0);\n\n//Ray intersections by iq\nrec hitBox(in ray r, vec3 offset, vec3 boxSize, int mat, vec3 color, in vec3 m) \n{\n    r.o -= offset;\n    vec3 n = m*r.o;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return noHit;\n    return rec(true, -sign(r.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz), tN, color, mat);\n}\nfloat bbox(in ray r, vec3 A, vec3 B, in vec3 m)\n{\n    vec3 t1 = ((A+A)-r.o)*m;\n    vec3 t2 = ((B+B)-r.o)*m;\n    vec3 F = min(t1, t2);\n    vec3 N = max(t1, t2);\n    float tmin = max(max(F.x, F.y), F.z);\n    float tmax = min(min(N.x, N.y), N.z);\n\n    if (tmax < 0.0 || tmin > tmax)\n    {\n        return 10000.;\n    }\n    return tmin;\n}\nrec sphere(ray r, vec3 offset, float ra, int mat, vec3 color)\n{\n    r.o -= offset;\n    float b = dot( r.o, r.d );\n    float c = dot( r.o, r.o ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return noHit;\n    h = sqrt( h );\n    float d = -b-h;\n    if (d < 0.0) return noHit;\n    vec3 p = (r.o+offset)+r.d*d;\n    return rec(true, (p-offset)/ra, d, color, mat);\n}", "buffer_a_code": "#define samples 10\n\n\n//0: test scene, 1: BVH demo\n#define scene 1\n\n#define BVH true\n\n//hashes\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 10.;\n\nfloat hash() {\n    uint n = base_hash(floatBitsToUint(vec2(g_seed+=.1,g_seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash3() {\n    uint n = base_hash(floatBitsToUint(vec2(g_seed+=.1,g_seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nray cam(in vec2 coord) { //camera\n    vec2 ri = 1./iResolution.xy;\n    vec2 uv = ((coord.xy*ri)-0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.x == 0. ? vec2(0.5) : ((iMouse.xy*ri)-0.5)*vec2(6.283185307179586, 3.141592653589793);\n    float Y = cos(m.y);\n    vec3 ro = vec3(sin(m.x)*Y, sin(m.y), cos(m.x)*Y)*17.;\n    #if scene\n    ro *= 0.08;\n    #endif\n    vec3 cam_z = normalize(-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    ro.y += 1.0;\n    #if scene\n        ro.y -= 1.5;\n    #endif\n    return ray(ro, normalize(uv.x * cam_x + uv.y * cam_y + 1. * cam_z));\n}\n#define BOX(p, s, m, c) tmp = hitBox(r, p, s, m, c, rdINV);if (tmp.d < o.d) {o = rec(true, tmp.normal, tmp.d, tmp.color, tmp.mat);}\n#define SPHERE(p, s, m, c) tmp = sphere(r, p, s, m, c);if (tmp.d < o.d) {o = rec(true, tmp.normal, tmp.d, tmp.color, tmp.mat);}\n#define BOUND(a, b) o.d>bbox(r, a, b, rdINV) || !BVH\nrec hitScene(in ray r) { // EDIT SCENE HEAR\n    vec3 rdINV = 1./r.d;\n    int mat = 0;\n    rec o = noHit;\n    rec tmp;\n    \n    #if scene\n    //38 objects\n    /*\n   BOX(vec3(-1000.), vec3(2000.), 3, vec3(1)); \n   */\n    BOX(vec3(0, -0.8, 0.0), vec3(5.0, 0.01, 5.0),    0     , vec3(0.8));\n    if ( BOUND(vec3(-.3, -0.4, -.3), vec3(.3, 0.0, .3)) ) {\n        if (BOUND(vec3(.15, -.275, -.075), vec3(0.3, -.05, 0.075))) {\n            BOX(vec3(0.45, -0.325, 0.0), vec3(0.15, 0.025, 0.15), 0, vec3(0.8, 0.2, 0.2));\n            BOX(vec3(0.475, -0.45,-0.0), vec3(0.025, 0.1, 0.025), 0, vec3(0.8, 0.2, 0.2));\n            if (BOUND(vec3(.15, -.15, -.075), vec3(0.3, -.05, 0.075))) {\n                BOX(vec3(0.31, -0.29, 0.0), vec3(0.01, 0.01, 0.15), 3, vec3(0.8, 0.2, 0.2));\n                BOX(vec3(0.59, -0.29, 0.0), vec3(0.01, 0.01, 0.15), 3, vec3(0.8, 0.2, 0.2));\n                BOX(vec3(0.45, -0.29, 0.14), vec3(0.15, 0.01, 0.01), 3, vec3(0.8, 0.2, 0.2));\n                BOX(vec3(0.45, -0.29, -0.14), vec3(0.15, 0.01, 0.01), 3, vec3(0.8, 0.2, 0.2));\n                SPHERE(vec3(0.45, -0.2, 0.0), 0.1, 2, vec3(0.8));\n            }\n        }\n        if (BOUND(vec3(-.3, -.275, -.075), vec3(-0.15, -.05, 0.075))) {\n            BOX(vec3(-0.45, -0.325, 0.0), vec3(0.15, 0.025, 0.15), 0, vec3(0.2, 0.8, 0.2));\n            BOX(vec3(-0.475, -0.45,-0.0), vec3(0.025, 0.1, 0.025), 0, vec3(0.2, 0.8, 0.2));\n            \n            if (BOUND(vec3(-.3, -.15, -.075), vec3(-0.15, -.05, 0.075))) {\n                BOX(vec3(-0.31, -0.29, 0.0), vec3(0.01, 0.01, 0.15), 3, vec3(0.2, 0.8, 0.2));\n                BOX(vec3(-0.59, -0.29, 0.0), vec3(0.01, 0.01, 0.15), 3, vec3(0.2, 0.8, 0.2));\n                BOX(vec3(-0.45, -0.29, 0.14), vec3(0.15, 0.01, 0.01), 3, vec3(0.2, 0.8, 0.2));\n                BOX(vec3(-0.45, -0.29, -0.14), vec3(0.15, 0.01, 0.01), 3, vec3(0.2, 0.8, 0.2));\n                SPHERE(vec3(-0.45, -0.2, 0.0), 0.1, 2, vec3(0.8));\n            }\n        }\n        if (BOUND(vec3(-.075, -.275, .15), vec3(0.075, -.05, 0.3))) {\n            BOX(vec3(0.0, -0.325, 0.45), vec3(0.15, 0.025, 0.15), 0, vec3(0.2, 0.2, 0.8));\n            BOX(vec3(0.0, -0.45, 0.475), vec3(0.025, 0.1, 0.025), 0, vec3(0.2, 0.2, 0.8));\n            \n            if (BOUND(vec3(-.075, -.15, .15), vec3(0.075, -.05, 0.3))) {\n                SPHERE(vec3(0, -0.2, 0.45), 0.1, 2, vec3(0.8));\n                BOX(vec3(0.0, -0.29, 0.31), vec3(0.15, 0.01, 0.01), 3, vec3(0.1, 0.2, 0.8));\n                BOX(vec3(0.0, -0.29, 0.59), vec3(0.15, 0.01, 0.01), 3, vec3(0.1, 0.2, 0.8));\n                BOX(vec3(0.14, -0.29, 0.45), vec3(0.01, 0.01, 0.15), 3, vec3(0.1, 0.2, 0.8));\n                BOX(vec3(-0.14, -0.29, 0.45), vec3(0.01, 0.01, 0.15), 3, vec3(0.1, 0.2, 0.8));\n            }\n        }\n        if (BOUND(vec3(-.075, -.275, -.3), vec3(0.075, -.05, -0.15))) {\n            BOX(vec3(0.0, -0.325, -0.45), vec3(0.15, 0.025, 0.15), 0, vec3(0.8, 0.8, 0.1));\n            BOX(vec3(0.0, -0.45, -0.475), vec3(0.025, 0.1, 0.025), 0, vec3(0.8, 0.8, 0.1));\n        \n            if (BOUND(vec3(-.075, -.15, -.3), vec3(0.075, -.05, -0.15))) {\n                BOX(vec3(0.0, -0.29, -0.31), vec3(0.15, 0.01, 0.01), 3, vec3(0.8, 0.8, 0.2));\n                BOX(vec3(0.0, -0.29, -0.59), vec3(0.15, 0.01, 0.01), 3, vec3(0.8, 0.8, 0.2));\n                BOX(vec3(0.14, -0.29, -0.45), vec3(0.01, 0.01, 0.15), 3, vec3(0.8, 0.8, 0.2));\n                BOX(vec3(-0.14, -0.29, -0.45), vec3(0.01, 0.01, 0.15), 3, vec3(0.8, 0.8, 0.2));\n                SPHERE(vec3(0, -0.2, -0.45), 0.1, 2, vec3(0.8));\n            }\n        }\n        if (BOUND(vec3(-.075, -.275, -0.075), vec3(0.075, -.00, 0.075))) {\n            BOX(vec3(0.0, -0.4, 0.0), vec3(0.025, 0.15, 0.025), 0, vec3(0.5));\n            BOX(vec3(0.0, -0.225, 0.0), vec3(0.15, 0.025, 0.15), 0, vec3(0.5));\n            SPHERE(vec3(0.0, -0.1, 0.0), 0.1, 3, vec3(0.8));\n        }\n        if (BOUND(vec3(-.25, -.4, -.25), vec3(0.25, -0.275, 0.25))) {\n            BOX(vec3(0.25, -0.7, 0.25), vec3(0.025, 0.1, 0.025), 0, vec3(0.8));\n            BOX(vec3(0.25, -0.7, -0.25), vec3(0.025, 0.1, 0.025), 0, vec3(0.8));\n            BOX(vec3(-0.25, -0.7, 0.25), vec3(0.025, 0.1, 0.025), 0, vec3(0.8));\n            BOX(vec3(-0.25, -0.7, -0.25), vec3(0.025, 0.1, 0.025), 0, vec3(0.8));\n            BOX(vec3(0.0, -0.575, -0.0), vec3(0.275, 0.025, 0.275), 0, vec3(0.8));\n            BOX(vec3(0.0, -0.575, -0.0), vec3(0.025, 0.025, 0.5), 0, vec3(0.8));\n            BOX(vec3(0.0, -0.575, -0.0), vec3(0.5, 0.025, 0.025), 0, vec3(0.8));\n        }\n    }\n    #else\n    //9 objects\n    BOX(vec3(0, -.6, 0), vec3(20., .1, 20.), 0, vec3(0.8));\n    if (BOUND(vec3(-2.5, -0.25, -2.5), vec3(2.5, 4.0, 2.5))) {\n        BOX(vec3(0, 3.5, 0), vec3(5., .1, 5.), 0, vec3(0.2, 0.6, 0.8));\n        SPHERE(vec3(0.0, 1.5, 0.0), 2.0, 3, vec3(0.8));\n        if (BOUND(vec3(-2.0, 1.8, -2.0), vec3(2.0, 4.0, 2.0))) {\n            BOX(vec3(0, 3.67, 0), vec3(4., .25, 4.), 1, vec3(0.8, 0.8, 0.3));\n            SPHERE(vec3(0.0, 5.9, 0.0), 2.0, 2, vec3(1));\n        }\n        BOX(vec3(-4, 1.5, -4), vec3(0.4, 2., 0.4), 0, vec3(0.8, 0.3, 0.3));\n        BOX(vec3(-4, 1.5, 4), vec3(0.4, 2., 0.4), 0, vec3(0.8, 0.3, 0.3));\n        BOX(vec3(4, 1.5, -4), vec3(0.4, 2., 0.4), 0, vec3(0.8, 0.3, 0.3));\n        BOX(vec3(4, 1.5, 4), vec3(0.4, 2., 0.4), 0, vec3(0.8, 0.3, 0.3));\n    }\n    #endif\n    \n    return o;\n}\n\nvec3 rus() { //random number in sphere\n    vec3 h = hash3() * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 0.3333333333333333);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\nvec3 sky(vec3 rd) { //background\n    return texture(iChannel1, rd).xyz*0.3;\n}\nvec3 getColor(ray r) {\n    vec3 v = vec3(1);\n    int i;\n    for (i = 0; i < 100; i += 1) {\n        rec hit = hitScene(r);\n        if (hit.hit) v *= hit.color;\n        else return v*sky(r.d);\n        vec3 nd;\n        if (hit.mat == 0) nd = (hit.normal+rus());\n        else if (hit.mat == 1) nd = reflect(r.d, (hit.normal+0.05*rus()));\n        else if (hit.mat == 2) {\n            if (hash() > (1./-dot(r.d, hit.normal))*0.1) nd = hit.normal+rus();\n            else nd = reflect(r.d, hit.normal);\n        }\n        else if (hit.mat == 3) return (v*vec3(2));\n        r = ray(r.o+r.d*(hit.d-0.00001), normalize(nd));\n    }\n    return vec3(v);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_seed = float(iFrame)*151.45137+fragCoord.x*1000.+fragCoord.y;\n    fragColor = vec4(0);\n    //fragColor = vec4(hash(), hash(), hash(), 1);return;\n    for (int i = 0; i < samples; i += 1) {\n        vec2 o = vec2(hash(), hash()-0.5);\n        ray c = cam(fragCoord+o);\n        vec3 col = max(getColor(c), 0.0);\n        fragColor += vec4(col,1.0);\n    }\n    vec4 tf = vec4(0);\n    tf += texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z < 0.0 || iMouse.x == 0.) fragColor += tf;\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 299]]}
{"id": "NtXyW8", "name": "long-way", "author": "jorge2017a2", "description": "long-way", "tags": ["longway"], "likes": 4, "viewed": 182, "published": 3, "date": "1647869406", "time_retrieved": "2024-07-30T16:57:31.796158", "image_code": "\n//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);\n    //p.xyz=p.zyx;\n    p.y=p.y-6.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    p.z= opRep1D(p.z,42.0 );\n    \n    float d3a= sdCylinderXY(p-vec3(0.0,8.0,0.0), vec2(8.5,1.0) ); //arco\n    float d3b= sdCylinderXY(p-vec3(0.0,8.0,0.0), vec2(6.0,1.5) );\n    float d3c= sdBox( p-vec3(0.0,4.5,0.0), vec3(10.0,5.5,1.6) );\n    d3a= differenceSDF(d3a, d3b);\n    d3a= differenceSDF(d3a, d3c);\n    p=p0;\n    \n    vec3 p1=p0;\n    p1.z= opRep1D(p1.z,60.0 );\n    float d0= sdBox( p1-vec3(0.0,-4.0,0.0), vec3(12.0,0.5,30.0) ); //base\n    vec3 p2=p0;\n    \n    p2.z= opRep1D(p2.z,42.0 );\n    p2.x=abs(p2.x)-7.0;\n    float d1= sdBox( p2-vec3(0.0,3.0,0.0), vec3(1.5,7.0,1.5) );  //columna1\n    \n    vec3 p3=p0;\n    p3.z= opRep1D(p3.z,60.0 );\n    p3.x=abs(p3.x)-7.0;\n    float d1b= sdBox( p3-vec3(0.0,-0.5,0.0), vec3(1.0,3.0,30.0) ); //pared inf\n    p=p0;\n    \n    p.z-=15.0;\n    p.z=abs(p.z)-7.0;\n    p.x=abs(p.x)-7.0;\n    p.z= opRep1D(p.z,15.0 );\n    float d1c= sdBox( p-vec3(0.0,4.5,0.0), vec3(1.5,8.0,1.5) );  //columnas simple\n    \n    res =opU2(res, vec2(d0,64.0));\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d1b,101.0));\n    res =opU2(res, vec2(d1c,101.0));\n    res =opU2(res, vec2(d3a,100.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    float shadow = getSoftShadow(hit, normalize(lightPos));// shadows\n    float occ = occlusion(hit, norm);// occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0)*norm.y;\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*3.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor)*2.0; }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y) ;\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   \n   if (id_color==100)\n   { return  getColorTextura( p, nor,100); }\n   \n   if (id_color==101)\n   { return  getColorTextura( p, nor,101); }\n            \n   \n   if (id_color==64)\n   { \n       vec3 col;\n       if (mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0)>0.0 )\n           col=vec3(1.0);\n       else\n           col=vec3(0.28,0.6,1.0);\n       return col; \n       }\n   \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n \tlight_pos1= vec3(-10.0, 30.0,-25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(15.0,20.0,-40.0+t);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   \n   if (-5.0*sin(iTime)>0.0)\n   {rd= rotate_x(rd, radians(20.0));rd= rotate_y(rd, radians(-30.0)); }\n   else\n   {\n    ro=vec3(0.0,11.0,-40.0+t);\n   }\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 531, 531, 615], [616, 616, 653, 653, 748], [749, 749, 788, 788, 883], [884, 884, 923, 923, 1018], [1019, 1019, 1058, 1058, 1153], [1155, 1199, 1246, 1246, 1273], [1274, 1274, 1317, 1317, 1344], [1345, 1345, 1393, 1393, 1421], [1422, 1460, 1496, 1496, 1541], [1542, 1542, 1581, 1581, 1625], [1626, 1626, 1665, 1665, 1709], [1710, 1710, 1742, 1742, 1767], [1768, 1833, 1867, 1867, 1963], [1964, 1964, 1998, 1998, 2089], [2090, 2090, 2124, 2124, 2215], [2216, 2216, 2250, 2250, 2341], [2342, 2342, 2367, 2367, 3630], [3632, 3632, 3656, 3656, 3818], [3820, 3820, 3868, 3868, 4174], [4176, 4176, 4220, 4220, 4538], [4540, 4540, 4577, 4577, 4834], [4836, 4836, 4921, 4921, 5869], [5871, 5871, 5920, 5920, 6057], [6059, 6059, 6152, 6152, 6282], [6284, 6284, 6316, 6316, 6514], [6517, 6517, 6587, 6587, 6975], [6977, 6977, 7004, 7004, 7093], [7095, 7095, 7153, 7153, 7201], [7203, 7203, 7226, 7226, 7338], [7340, 7340, 7371, 7371, 7991], [7993, 7993, 8050, 8050, 8646]]}
{"id": "slfyDr", "name": "大龙猫 - Apericucubes", "author": "totetmatt", "description": "Des Apericubes encore !", "tags": ["cubes"], "likes": 15, "viewed": 396, "published": 3, "date": "1647868825", "time_retrieved": "2024-07-30T16:57:32.741630", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(0.)))+min(0.,max(q.x,max(q.y,q.z)));;\n}\nfloat diam(vec3 p,float s){\n   p = abs(p);\n   return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\nfloat mandel(vec2 uv){\n    uv = vec2(log(length(uv)),atan(uv.x,uv.y));\n    uv*=2.;\n    uv = asin(sin(uv)*.9)/2.;\n    vec2 z=uv;\n    vec2 c = vec2(0.451410,-.1222) ;\n    float i,lim = 200.;\n    for(i=0.;i<lim;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c;\n        if(dot(z,z)>4.) break;\n        \n    \n    }\n    return i/lim;\n\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=4.;\n    vec3 col = vec3(.1);//vec3(1.)*mandel(uv);\n    \n    vec3 p,d=normalize(vec3(uv,1.));\n    \n    for(float i=0.,g=0.,e,t;i++<99.;){\n      \n       p = d*g;\n      \n       p.xy *= rot(iTime*.1);\n       vec2 id = floor(p.xy);\n        \n        p.y +=mod(id.x,2.)==0. ? iTime:-iTime;\n        id = floor(p.xy);\n        \n        p.z = asin(sin(p.z+iTime));\n       p.xy =fract(p.xy)-.5;\n       \n       p.xy *=rot(-iTime*.2+id.y+id.x);\n       \n       float m = 1.-mandel(.1*sin(id+iTime)+min(abs(p.zx),min(abs(p.yx),abs(p.xy))))*1.44;\n       \n       float h = box(p,vec3(.25,.25,.1))*.8;\n       g+=e=max(.01,abs(h));\n       col += vec3(1.-(sin(id.y)*.5+.5),.5,cos(id.x*10.)*.5+.5)*smoothstep(m*.9,.3,.65)/exp(.9*i*i*e);\n    \n    };col=sqrt(col)*col;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 91, 91, 183], [184, 184, 211, 211, 271], [272, 272, 294, 294, 605], [606, 606, 661, 661, 1516]]}
{"id": "stlcWr", "name": "3D Blobs", "author": "z0rg", "description": "blobs", "tags": ["blobs"], "likes": 4, "viewed": 340, "published": 3, "date": "1647861048", "time_retrieved": "2024-07-30T16:57:33.857646", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\n\nvec3 camp;\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(1000.,-1.);\n\n  float a = texture(iChannel0, p.xz*.01+vec2(0.,iTime)*0.001).x-.4;\n  float b = texture(iChannel0,p.xy*0.02+vec2(iTime,0.)*0.002).x-.1;\n  return vec2(max(-a*b+.2,-(length(p-camp)-1.)),0.);//*texture2D(noise,p.xz).x-.5,0.);\n\n  return acc;\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  camp = ro;\n  vec3 p = ro;\n  for (int i = 0; i<steps&& distance (p,ro)<15.;++i)\n  {\n    vec2 res = map(p);\n    res.x = min(res.x,.9);\n    if (res.x<0.001)\n      return vec3(res.x,distance(p,ro),res.y);\n    accCol+= .75*sat(sin(p.y+p.z+iTime)*.5+.5)*.05\n    *mix(vec3(.12,.45,.78),vec3(.2,.5,.4),abs(p.x*1.))*(1.-sat(res.x/.5));\n    p+= rd*res.x*.75;\n  }\n  return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n\n  float z = mod(iTime,18.);\n  vec3 ro = vec3(0.,-5.,-5.+z);\n  vec3 ta = vec3(0.,-1.,z);\n  float t = mod(iTime,9.);\n  if (t<3.)\n  {\n  }\n  else if(t<6.)\n  {\n    ta = vec3(-5.,0.,0.);\n  }\n  else\n  {\n    ro = vec3(sin(iTime),sin(iTime*.5),cos(iTime));\n  }\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n  accCol = vec3(0.);\n  vec3 res = trace(ro,rd,128);\n  float depth = 5.;\n  if (res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    vec3 rgb = mix(vec3(0.),vec3(.2,.7,.4)*2.,sat((sin((p.x+p.z)*20.)-.975)*400.));\n    col = rgb;\n    depth = res.y;\n  }\n  col+= accCol.zxy;\n  col = mix(col,\n    mix(vec3(.1,.67,.78),\n      vec3(.1),sat(uv.y*1.)),.5*sat(depth/5.));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  vec3 col = rdr(uv);\n  col = pow(col,vec3(1.45));\n  col += col/(2.+col);\n  col *= 1.5*(1.-sat(length(uv)));\n  col *= pow(1.-sat(length(uv)-.2), 2.);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlcWr.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[440, 440, 458, 458, 729], [743, 743, 784, 784, 1161], [1163, 1163, 1194, 1194, 1342], [1344, 1344, 1375, 1375, 1484], [1488, 1488, 1507, 1507, 2243], [2245, 2245, 2302, 2302, 2553]]}
{"id": "stsyWn", "name": "Newton Fractal - Spi3lot", "author": "Spi3lot", "description": "Newton Fractal", "tags": ["fractal", "mandelbrot", "newton", "set"], "likes": 3, "viewed": 219, "published": 3, "date": "1647858574", "time_retrieved": "2024-07-30T16:57:34.732307", "image_code": "#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n\n// ITERATIONS basically only define how far you can zoom *OUT*\n#define ITERATIONS 50\n#define CENTER c(0.0, 0.0)\n//#define CENTER ROOT_1 - c(5.0 / 9.0 - 249225.0 / 90000000.0)\n\n#define ROOT_1 rootOfUnity(0, 3)\n#define ROOT_2 rootOfUnity(1, 3)\n#define ROOT_3 rootOfUnity(2, 3)\n\n\nvec2 c(float a, float b)\n{\n    return vec2(a, b);\n}\n\nvec2 c(float a)\n{\n    return c(a, 0.0);\n}\n\nvec2 polar(float r, float theta)\n{\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec2 polar(float theta)\n{\n    return polar(1.0, theta);\n}\n\nvec2 rootOfUnity(int n, int index) {\n    return polar(TAU * float(n) / float(index));\n}\n\n\nvec2 conjugate(vec2 z) {\n    return c(z.x, -z.y);\n}\n\nvec2 cmul(vec2 ab, vec2 cd)\n{\n    float a = ab.x * cd.x - ab.y * cd.y;\n    float b = ab.x * cd.y + ab.y * cd.x;\n    \n    return vec2(a, b);\n}\n\nvec2 cdiv(vec2 ab, vec2 cd)\n{\n    // dot(cd, cd) = cd.x * cd.y (= c² + d²) = cd * conjugate(cd)\n    return cmul(ab, conjugate(cd)) / dot(cd, cd);\n}\n\nvec2 sq(vec2 z)\n{\n    return cmul(z, z);\n}\n\n\nvec2 P(vec2 z)\n{\n    // Maybe use vieta theorem here for custom roots\n    return cmul(z, sq(z)) - c(1.0);\n}\n\nvec2 P_prime(vec2 z)\n{\n    // 3z²\n    return 3.0 * sq(z);\n}\n\nvec2 iterate(vec2 z)\n{\n    for (int i = 0; i < ITERATIONS; i++)\n        z -= cdiv(P(z), P_prime(z));\n        \n    return z;\n}\n\n\n// Distance to root\nfloat dist(vec2 z, vec2 root)\n{\n    return distance(z, root);\n}\n\nvec2 closestRoot(vec2 z) {\n    float d1 = dist(z, ROOT_1);\n    float d2 = dist(z, ROOT_2);\n    float d3 = dist(z, ROOT_3);\n    \n    float mini = min(min(d1, d2), d3);\n    \n    vec2 closest;\n    if (mini == d1) closest = ROOT_1;\n    else if (mini == d2) closest = ROOT_2; \n    else if (mini == d3) closest = ROOT_3;\n\n    return acos(closest);\n    //return acos(closest) / PI;\n\n    /*\n    int n;\n    switch (mini)\n    {\n        case d1: n = 1; break;\n        case d2: n = 2; break;\n        case d3: n = 3; break;\n    }\n    \n    return n;\n    */\n}\n\n\nvec2 transform(vec2 v)\n{\n    return 2.0 * v - iResolution.xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = exp2(12.0 - iTime) * transform(fragCoord) / iResolution.x;\n    \n    if (iMouse.z > 0.0)\n        uv += transform(iMouse.xy) / iResolution.x;\n    \n    vec2 z = iterate(uv);\n    vec2 col = closestRoot(z);\n\n    // Output to screen\n    fragColor = vec4(col, 1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 350, 350, 375], [377, 377, 394, 394, 418], [420, 420, 454, 454, 501], [503, 503, 528, 528, 560], [562, 562, 598, 598, 649], [652, 652, 676, 676, 703], [705, 705, 734, 734, 846], [848, 848, 877, 945, 997], [999, 999, 1016, 1016, 1041], [1044, 1044, 1060, 1113, 1151], [1153, 1153, 1175, 1187, 1213], [1215, 1215, 1237, 1237, 1340], [1343, 1363, 1394, 1394, 1426], [1428, 1428, 1454, 1454, 1972], [1975, 1975, 1999, 1999, 2038], [2041, 2041, 2098, 2098, 2376]]}
{"id": "ftlcDr", "name": "Finite Element Calculus", "author": "microwerx", "description": "Click on the image to change the operator performed (from left: 1st: vector field (RGB), 2nd: scalar field, 3rd: Gradient, 4th: Divergence, 5th: Laplacian, 6th: Laplacian Sign, 7th: Curl, 8th: Curl Length, 9th: Curl Vorticity).", "tags": ["gradient", "curl", "nyancat", "laplacian", "laplace", "divergence", "vorticity"], "likes": 2, "viewed": 636, "published": 3, "date": "1647843878", "time_retrieved": "2024-07-30T16:57:35.927113", "image_code": "const float dx = 1.0;\nconst float dy = 1.0;\nconst float dz = 1.0;\nconst vec2 PosX = vec2( 1.0,  0.0); //  1,  0,  0\nconst vec2 NegX = vec2(-1.0,  0.0); // -1,  0,  0\nconst vec2 PosY = vec2( 0.0,  1.0); //  0,  1,  0\nconst vec2 NegY = vec2( 0.0, -1.0); //  0, -1,  0\nconst vec2 PosZ = vec2( 0.0,  0.0); //  0,  0,  1\nconst vec2 NegZ = vec2( 0.0,  0.0); //  0,  0, -1\nconst vec2 Zero = vec2( 0.0,  0.0); //  0,  0,  0\nconst int ALL_FIELDS = 0;\nconst int VECTOR_FIELD = 1;               // Original RGB.\nconst int SCALAR_FIELD = 2;               // Average of RGB.\nconst int GRADIENT_OF_SCALAR_FIELD = 3;   // Produces a vector field.\nconst int DIVERGENCE_OF_VECTOR_FIELD = 4; // Produces a scalar field.\nconst int LAPLACIAN_OF_SCALAR_FIELD = 5;  // Produces a scalar field.\nconst int LAPLACIAN_OF_SCALAR_FIELD_SIGN = 6; // Colors the Laplacian.\nconst int CURL_OF_VECTOR_FIELD = 7;           // Produces a vector field.\nconst int CURL_OF_VECTOR_FIELD_LENGTH = 8;    // Produces a scalar field.\nconst int CURL_OF_VECTOR_FIELD_VORTICITY = 9;      // Colors the Curl.\nconst float NUM_CHOICES = 10.0;\n\n// Pick a combo of the following.\nconst bool USE_WEBCAM = false;\nconst bool USE_NYANCAT = true;\nconst bool USE_VIDEO = true;\nconst bool USE_BUFFER_A = false;\n\nvec3 v(vec2 ij, vec2 offset) {\n    vec2 uv = (ij + offset) / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float count = 0.0;\n\n    if (USE_VIDEO) {\n        col += texture(iChannel0, uv).rgb;\n        count++;\n    }\n        \n    if (USE_WEBCAM) {\n        col += texture(iChannel1, uv).rgb;\n        count++;\n    }\n        \n    if (USE_NYANCAT) {\n        vec2 uv2 = vec2(-0.15 + uv.x + 0.4 * sin(iTime), uv.y + 0.1 * cos(iTime));\n        // Add the nyan cat sprite: https://www.shadertoy.com/view/lsX3Rr\n        vec2 uvNyan = (uv2  - vec2(0.25, 0.15)) / (vec2(0.7,0.5) - vec2(0.5, 0.15));\n        uvNyan = clamp(uvNyan, 0.0, 1.0);\n        float ofx = floor(mod(iTime*15.0, 6.0));\n        float ww = 40.0/256.0;\n        uvNyan = vec2(clamp(uvNyan.x*ww + ofx*ww, 0.0, 1.0 ), uvNyan.y);\n        vec4 texel = texture(iChannel2, uvNyan);\n        if (texel.a > 0.5) {\n            col = texel.rgb;\n            count = 1.0;\n        }\n    }\n    \n    if (USE_BUFFER_A) {\n        col += texture(iChannel3, uv).rgb;\n        count++;\n    }\n        \n    return col/count;\n}\n\nfloat f(vec2 ij, vec2 offset) {\n    vec3 col = v(ij, offset);\n    return (col.x + col.y + col.z) / 3.0;\n}\n\nvec3 gradient(vec2 ij) {\n    float dfdx = 0.5 / dx * (f(ij, PosX) - f(ij, NegX));\n    float dfdy = 0.5 / dy * (f(ij, PosY) - f(ij, NegY));\n    float dfdz = 0.5 / dz * (f(ij, PosZ) - f(ij, NegZ));\n    return vec3(dfdx, dfdy, dfdz);\n}\n\nfloat divergence(vec2 ij) {\n    float dfdx = 0.5 / dx * (f(ij, PosX) - f(ij, NegX));\n    float dfdy = 0.5 / dy * (f(ij, PosY) - f(ij, NegY));\n    float dfdz = 0.5 / dz * (f(ij, PosZ) - f(ij, NegZ));\n    return dfdx + dfdy + dfdz;\n}\n\nvec3 curl(vec2 ij) {\n    float dvzdy = 0.5 / dy * (v(ij, PosY).z - v(ij, NegY).z);\n    float dvydz = 0.5 / dz * (v(ij, PosZ).y - v(ij, NegZ).y);\n    float dvxdz = 0.5 / dz * (v(ij, PosZ).x - v(ij, NegZ).x);\n    float dvzdx = 0.5 / dx * (v(ij, PosX).z - v(ij, NegX).z);\n    float dvydx = 0.5 / dy * (v(ij, PosX).y - v(ij, NegX).y);\n    float dvxdy = 0.5 / dx * (v(ij, PosY).x - v(ij, NegY).x);\n    return vec3(dvzdy - dvydz, dvxdz - dvzdx, dvydx - dvxdy);\n}\n\nfloat laplacian(vec2 ij) {\n    return ( f(ij, PosX) + f(ij, NegX)\n           + f(ij, PosY) + f(ij, NegY)\n           + f(ij, PosZ) + f(ij, NegZ)\n           - 6.0 * f(ij, Zero)\n           ) / (dx * dy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int choice = int(iMouse.x * NUM_CHOICES / iResolution.x);\n    if (choice == 0)\n        choice = int(fragCoord.x * (NUM_CHOICES-1.0) / iResolution.x) + 1;\n    \n    float intensity = 1.0;\n    vec3 col;\n    if (choice == VECTOR_FIELD) {\n        col = v(fragCoord, vec2(0, 0));\n    } else if (choice == SCALAR_FIELD) {\n        col = vec3(f(fragCoord, vec2(0, 0)));\n    } else if (choice == GRADIENT_OF_SCALAR_FIELD) {\n        vec3 G = gradient(fragCoord);        \n        col = G;\n        // Boost the intensity.\n        intensity = 6.0;\n    } else if (choice == DIVERGENCE_OF_VECTOR_FIELD) {\n        col = vec3(divergence(fragCoord));\n        // Boost the intensity\n        intensity = 6.0;\n    } else if (choice == LAPLACIAN_OF_SCALAR_FIELD) {\n        col = vec3(laplacian(fragCoord));\n        \n        // Boost the intensity\n        intensity = 12.0;\n    } else if (choice == LAPLACIAN_OF_SCALAR_FIELD_SIGN) {\n        float L = laplacian(fragCoord);\n        \n        // Differentiate between negative, positive, and zero\n        // Red is less than zero, Green is greater than zero, Blue is none.\n        if (L < 0.0)\n            col = vec3(-L, 0.0, 0.0);\n        else if (L > 0.0)\n            col = vec3(0.0, L, 0.0);\n        else\n            col = vec3(0.0, 0.0, 0.0);\n        \n        // Boost the intensity\n        intensity = 12.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD) {\n        col = curl(fragCoord);\n\n        // Boost the intensity\n        intensity = 12.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD_LENGTH) {\n        float C = length(curl(fragCoord));\n        col = vec3(C);\n        \n        // Don't boost the intensity.\n        intensity = 1.0;\n    } else if (choice == CURL_OF_VECTOR_FIELD_VORTICITY) {\n        float C = dot(curl(fragCoord), vec3(0.0, 0.0, 1.0));\n        \n        // This is vorticity because we are using a 2D field.\n        \n        // Differentiate between negative, positive, and zero\n        // Red is less than zero, Green is greater than zero, Blue is none.\n        if (C < 0.0)\n            col = vec3(-C, 0.0, 0.0);\n        else if (C > 0.0)\n            col = vec3(0.0, C, 0.0);\n        else\n            col = vec3(0.0, 0.0, 0.0);\n        \n        // Boost the intensity\n        intensity = 6.0;\n    }\n    \n    if (intensity != 1.0)\n        col = intensity * col / (1.0 + intensity * col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1254, 1254, 1284, 1284, 2309], [2311, 2311, 2342, 2342, 2416], [2418, 2418, 2442, 2442, 2650], [2652, 2652, 2679, 2679, 2883], [2885, 2885, 2905, 2905, 3341], [3343, 3343, 3369, 3369, 3545], [3548, 3548, 3605, 3655, 6101]]}
{"id": "NlsyDr", "name": "Gilded carpet", "author": "jarble", "description": "A shiny gold carpet pattern.", "tags": ["fractal", "knot"], "likes": 11, "viewed": 350, "published": 3, "date": "1647836571", "time_retrieved": "2024-07-30T16:57:37.175774", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += (iTime+8.)/vec2(2.0,3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    for(int k = 0; k < 18; k++){\n        vec2 uv1 = uv;\n        uv -= (t2.yx);\n        \n        //uv += fract(uv.x/(3.)); //a more interesting quilt pattern\n\n        //uv -= ceil(t2.x+t2.y+5.)/2.; //mosaic pattern\n\n        t2 = triangle_wave(uv.yx+.5,scale)/2.;\n        t3 = triangle_wave(uv,scale);    \n        \n        uv.yx = t3-t2*1.5;\n        col.x = max((uv.x-uv.y),col.x);\n        col = abs(col.yzx-vec3(col.x*(2.)));\n\n        uv /= scale*scale;\n        \n        //this makes a flower pattern\n        //uv += float(k%3)/2.;\n        \n        //another carpet pattern\n        //uv *= 2. - float(k%3);\n        \n        //another carpet pattern\n        //uv /= .5 + float(k%3)/2.;\n\n    }\n    fragColor = vec4(abs(col),1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1138]]}
{"id": "NlscWr", "name": "Leaves and stars", "author": "jarble", "description": "A fractal with leaf and star patterns.", "tags": ["fractal", "knot"], "likes": 4, "viewed": 281, "published": 3, "date": "1647830359", "time_retrieved": "2024-07-30T16:57:37.999572", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n\n    vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 12; k++){\n            vec2 uv1 = uv;\n            uv -= (t2.yx);\n            //uv.x += sign(uv.x)/2.;\n\n            //uv -= (t2.yx)/(1.+(t2.x-t2.y)/4.);\n            vec2 temp = t2*t3;\n            t2 = triangle_wave(uv.yx+.5,scale);\n            t3 = triangle_wave(uv,scale);\n            //t2 = triangle_wave(uv.yx+.5,scale)/(1.+t2);\n            //t3 = triangle_wave(uv,scale)/(1.+t3);\n            \n            uv.yx = t3-t2/2.;\n            //uv /= 1.+temp;\n            //uv -= uv.yx/8.;\n\n        col.x = max((uv.x-uv.y),col.x);\n        col = abs(col.yzx-vec3(col.x*(2.)));\n        \n        //col.x = abs(uv.x+uv.y-col.x*2.);\n        //col = abs(1.-col.yzx);\n        \n        uv /= scale*scale;\n        //uv -= ceil(t2.x*t2.y+2.)/2.; //mosaic pattern\n        //uv /= 1.+temp.yx;\n      }\n    fragColor = vec4(abs(col),1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlscWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 1388]]}
{"id": "stXyWr", "name": "Hand Eye Coordination", "author": "mrange", "description": "CC0: Hand Eye Coordination\nWanted to add some kind of pattern to the inside of the hand\nso stole some code from an earlier shader\n", "tags": ["2d"], "likes": 27, "viewed": 415, "published": 3, "date": "1647797505", "time_retrieved": "2024-07-30T16:57:38.838329", "image_code": "// CC0: Hand Eye Coordination\n//  Wanted to add some kind of pattern to the inside of the hand\n//  so stole some code from an earlier shader\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)     (0.5+0.5*sin(x))\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat parabola(vec2 pos, float wi, float he) {\n  pos.x = abs(pos.x);\n  float ik = wi*wi/he;\n  float p = ik*(he-pos.y-0.5*ik)/3.0;\n  float q = pos.x*ik*ik*0.25;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r/q)/3.0)*sqrt(p);\n  x = min(x,wi);\n  return length(pos-vec2(x,he-x*x/ik)) * \n         sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nfloat segmenty(vec2 p, float off) {\n  p.y = abs(p.y);\n  p.y -= off;\n  float d0 = abs(p.x);\n  float d1 = length(p);\n  return p.y > 0.0 ? d1 : d0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 polySoftMin3(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*polySoftMin3(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\n// Taken from evilryu's shader: https://www.shadertoy.com/view/XdlSD4\n// And tinkered with\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 2 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat eye(vec2 p) {\n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  \n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n\n  vec2 p1 = p;\n  p1.y -= 0.28;\n  float d1 = circle(p1, 0.622);\n  d1 = max(d1,d0);\n\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n\n  vec2 p3 = p;\n  p3.y -= 0.28;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-length(p1));\n\n  vec2 p4 = p;\n  p4.y -= 0.28;\n  float d4 = circle(p4, 0.285);\n\n  d3 = max(d3,-d4);\n\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n\n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  d0 = abs(d0)-mix(0.0125, -0.0025, t0);\n\n\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return d;\n}\n\nfloat starn(vec2 p, float r, float n, float m) {\n  // next 4 lines can be precomputed for a given shape\n  float an = 3.141593/float(n);\n  float en = 3.141593/m;  // m is between 2 and n\n  vec2  acs = vec2(cos(an),sin(an));\n  vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n  float bn = mod(atan(p.x,p.y),2.0*an) - an;\n  p = length(p)*vec2(cos(bn),abs(sin(bn)));\n  p -= r*acs;\n  p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n  return length(p)*sign(p.x);\n}\n\nvec2 hand(vec2 p) {\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.180+0.00);\n  float d0 = segmenty(p0, 0.61)-0.1;\n  vec2 p1 = p;\n  p1 -= vec2(0.2, 0.125);\n  float d1 = segmenty(p1,0.55)-0.09;\n  vec2 p2 = p;\n  p2 -= vec2(0.0, -0.38+0.3);\n  p2.y = -p2.y;\n  float d2 = unevenCapsule(p2, 0.3, 0.38, 0.3);\n  vec2 p3 = p;\n  p3 -= vec2(0.47, -0.31);\n  float d3 = parabola(p3, 0.37, 0.5);\n\n  vec2 p4 = p;\n  p4 -= vec2(0.99, -0.4);\n  float d4 = circle(p4, 0.61);\n  d3 = max(d3, -d4);\n\n  vec2 p5 = p;\n  p5 -= vec2(0.0, -0.45);\n//  float d5 = vesica(p5.yx, 0.175, 0.1)-0.2;\n  float d5 = starn(p5.yx, 0.33, 10.0, 3.5);\n  float d6 = abs(d5-0.005)-0.005;\n\n\n  d0 = min(d0, d1);  \n  d3 = p.y > -0.40 ? d3 : d2;\n\n  \n  float d = d3;\n  d = min(d, d2);\n  d = pmax(d, -(d0-0.01), 0.025);\n  d = min(d, d0);\n  float ds = max(min(d0, d3), -d5);\n  d = max(d, -d6);\n  \n  float od = d;\n  od = abs(od-0.02)-0.0075;\n  \n  d = min(d, od);\n  d = pmin(d, d5, 0.01);\n  return vec2(d, ds);\n}\n\nfloat weird(vec2 p) {\n  const float s = 0.55;\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, PSIN(TIME*0.257));\n  p3.yz *= ROT(TIME*0.05);\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  return mb(p3)*s;\n}\n\nfloat df(vec2 p) {\n  const float zw = 1.25;\n  float da = weird(p/zw)*zw;\n  vec2 dh = hand(p);\n  const float ze = 0.28;\n  vec2 pe = p;\n  pe -= vec2(0.0, -0.45);\n  pe /= ze;\n  float de = eye(pe);\n  de *= ze;\n  \n  float d = dh.x;\n  d = max(d, -de);\n  d = max(d, -pmax(da, dh.y, 0.0125));\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x    *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.1*q.y);\n  float d = df(p);\n  float fade = smoothstep(0.0, 4.0, TIME);\n  col = mix(col, mix(vec3(1.0, 0.5, 0.5), vec3(.5, 0.55, 0.95), q.y), smoothstep(aa, -aa, d)*fade);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[601, 684, 720, 720, 953], [955, 1038, 1077, 1077, 1162], [1164, 1164, 1203, 1203, 1232], [1234, 1234, 1264, 1264, 1292], [1294, 1325, 1364, 1364, 1489], [1491, 1577, 1622, 1622, 1776], [1778, 1829, 1869, 1869, 2018], [2020, 2071, 2129, 2129, 2354], [2356, 2407, 2453, 2453, 2840], [2842, 2934, 2963, 2963, 3028], [3030, 3030, 3061, 3061, 3087], [3090, 3090, 3125, 3125, 3236], [3238, 3238, 3260, 3260, 3304], [3307, 3307, 3328, 3328, 3373], [3375, 3375, 3423, 3423, 3693], [3695, 3695, 3738, 3738, 3826], [3828, 3828, 3873, 3873, 4101], [4103, 4103, 4134, 4134, 4158], [4160, 4251, 4269, 4269, 4758], [4760, 4760, 4821, 4821, 5034], [5036, 5036, 5055, 5055, 5909], [5911, 5911, 5959, 6014, 6395], [6397, 6397, 6416, 6416, 7360], [7362, 7362, 7383, 7383, 7606], [7608, 7608, 7626, 7626, 7906], [7908, 7908, 7963, 7963, 8347]]}
{"id": "NtfcDr", "name": "TP1-2 P2003442", "author": "valentinCuzin", "description": "réalisation d'un temple par Valentin Cuzin-Rambaud", "tags": ["templesdffunction"], "likes": 4, "viewed": 240, "published": 3, "date": "1647783253", "time_retrieved": "2024-07-30T16:57:39.631209", "image_code": "// Modeling - 2022.02.06\n// Eric Galin \n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Primitives \n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Sphere \n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n//un Disque\n// p : point\n// c : centre du tore\n// r : rayon hauteur\n// R : rayon externe\n// n : Normal du Tore\nfloat Disque(vec3 p, vec3 c,vec3 n, float r, float R){\n    float pc = length(p-c);\n    float pq = abs(dot(p-c,n));\n    float qc = sqrt( pc*pc - pq*pq );\n    if(qc<R){\n        return pq-r;\n    }else{\n        return sqrt( pq*pq + (qc -R)*(qc -R))-r;\n    }\n}\n\n//la boite\n// p : le point Ã  qui on calcul la distance Ã  la boite\n// S : l'espace entre deux plan de la boite\nfloat Boite(vec3 p, vec3 s){\n    vec3 q = abs(p)-s;\n    return length( max(q , 0.0))+ min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat cylinder (vec3 a, vec3 b, float r, vec3 p)\n{\n    float aq = dot((p-a),(b-a)/length(b-a));\n    float l = sqrt(dot(p-a,p-a)- aq*aq);\n    return l-r;\n}\n\nfloat Capsule (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa-ba*h)-r;\n}\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// Intersection\n// a,b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n\n// DiffÃ©rence\n// a,b : les deux distance de la fonction SDF des deux object\nfloat Differance(float a, float b){\n    return max(a, -b);\n}\n\nvec3 Translation(vec3 p, vec3 T){\n    return p - T;\n}\n\n//matrice de rotation\n// a : prend en paramÃ¨tre iTime\nmat2 Rotation(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//Tore\nfloat Tore(vec3 p, vec3 normal, float Rextern, float Rintern, float rayon){\n    vec3 centre = vec3(0.0, 0.0, 3.0); \n    return Differance( Disque(p, centre, normal, rayon, Rextern), Disque(p, centre, normal, rayon, Rintern));\n}\n\n//cylindrefini\n// p : point\n// r : rayon\n// t : taille du cylindre\nfloat CylindreFini(vec3 p, float r, float t)\n{\n    float cylindreInf = cylinder(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, t), r, p);\n    float demiCylindreInf1 = Differance(cylindreInf, Plane( p, vec3(0.0, 0.0, -1.0) , vec3(0.0, 0.0, t+1.0))); \n    float demiCylindreInf2 = Differance(cylindreInf, Plane( p, vec3(0.0 ,0.0 ,1.0) , vec3(0.0,0.0,1.0) ));\n    return Intersection(demiCylindreInf1, demiCylindreInf2);\n    \n}\n\n//Pilier\n// p : point\n// t : taille du pilier\nfloat Pilier(vec3 p, float t){\n    float base = Boite(p, vec3(3.0, 3.0, 1.0));\n    vec3 transCourrante = Translation(p, vec3(0.0, 0.0, t));\n    float toit = Boite(transCourrante, vec3(3.0, 3.0, 1.0));\n    float Colone = CylindreFini(p, 2.0, t);\n    transCourrante = Translation(p, vec3(0.0, 0.0, -2.0));\n    float Disque = Disque(transCourrante, vec3(0.0, 0.0, 3.0), vec3(0.0, 0.0, 1.0), 0.5, 2.5);\n    return Union( Disque, Union(base, Union(toit, Colone)));\n}\n\n//Temple\n// p : point\nfloat Temple(vec3 p){\n  vec3 transCourrante = Translation(p, vec3(0.0, 0.0, -3.0));\n  float B1 = Boite(transCourrante, vec3(20.0, 15.0,1.0));\n  transCourrante = Translation(p, vec3(-2.0, 0.0, -2.0));\n  float B2 = Boite(transCourrante, vec3(18.0, 15.0,1.0));\n  float base = Union(B1, B2);\n  \n  transCourrante = Translation(p, vec3(-10.0, 0.0, 0.0));\n  float murs = Pilier(transCourrante, 4.0);\n  for( int i = 0; i<4; i++){\n      transCourrante = Translation(p, vec3(i*9-15, 11.0, 0.0));\n      murs = Union(murs, Pilier(transCourrante, 11.0));\n  }\n  for( int i = 0; i<4; i++){\n      transCourrante = Translation(p, vec3(i*9-15, -11.0, 0.0));\n      murs = Union(murs, Pilier(transCourrante, 11.0));\n  }\n  \n  float Tonnelle = Capsule(p, vec3(-18.0, -11.0, 10.0), vec3(-18, 11.0, 10.0), 0.5);\n  for( int i = 0; i<4; i++){\n      transCourrante = Translation(p, vec3(i*9-15, -11.0, 0.0));\n      Tonnelle = Union(Tonnelle, Capsule(p, vec3(i*9-15, -11.0, 12.0), vec3(i*9-15, 11.0, 12.0), 1.0));\n  }\n  \n  return Union( Tonnelle, Union(base, murs));\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  vec3 Tp = Translation(p, vec3(-10.0, 0.0, 4.0));\n  Tp.xy = Tp.xy * Rotation(0.2*iTime);\n  float AnneauMagique = Tore(Tp, vec3(0.0, 0.7, 1.0), 2.5, 2.0, 0.5);\n  vec3 Pp = Translation(p, vec3(10.0, -7.0,0.0));\n  float temple1 = Temple(p);\n  float v = Union(AnneauMagique, temple1);\n                        \n\n  /*Union(\n      Union(Sphere(p,vec3( 0.0, 2.0, 2.0),2.25),\n            Sphere(p,vec3( 3.0, 0.0,-1.0),3.0)),\n            Sphere(p,vec3( 3.0, 0.0,5.0),3.75));*/     \n    \n  v = Union(v,\n      Intersection(\n            Plane(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0)),\n            Sphere(p,vec3(0.0,0.0,-4.0),25.0))\n     );\n\n  return v;\n}\n\n// Analysis of the scalar field \n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n  // Start at the origin\n  float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting \n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// r : Radius for ambient occlusion\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, float r, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,r,h,s);\n        if (!h) {ao+=1.0;}\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.45,0.55,0.99),vec3(0.65,0.69,0.99), d.z*0.5+0.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n      return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = 0.25+0.25*background(n);\n    \n    // Ambient occlusion\n    ambient += 0.15 * AmbientOcclusion(p+0.1*n,n,5.0,50) * vec3(1.0,1.0,1.0);\n    \n    // Shadow computation\n    float shadow = Shadow(p,n,l);\n    \n    // Phong diffuse\n    vec3 diffuse = 0.35  * clamp(dot(n, l),0.0,1.0) * vec3(1.0,1.0,1.0);\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = 0.15 * pow(clamp(dot(r,l),0.0,1.0),30.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t = float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p = (-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip = true;\n    }\n       else\n       {\n           pip = false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "// Modeling\n// Eric Galin\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( float seed, vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m, vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.5;\n    \n    // Origin\n    ro=vec3(37.0,0.0,15.0);\n    ro*=Rz(a); \n\n    // Target\n    vec3 ta = vec3(0.0,0.0,1.0);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 217, 255, 255, 281], [283, 352, 389, 389, 416], [418, 529, 583, 583, 784], [786, 900, 928, 928, 1022], [1024, 1024, 1074, 1074, 1178], [1180, 1180, 1229, 1229, 1351], [1367, 1428, 1458, 1458, 1481], [1483, 1551, 1588, 1588, 1611], [1614, 1693, 1728, 1728, 1753], [1755, 1755, 1788, 1788, 1808], [1810, 1867, 1891, 1891, 1967], [1969, 1976, 2051, 2051, 2203], [2205, 2272, 2318, 2318, 2685], [2687, 2733, 2763, 2763, 3194], [3196, 3218, 3239, 3239, 4258], [4260, 4306, 4328, 4328, 4970], [5006, 5046, 5073, 5073, 5299], [5301, 5431, 5496, 5496, 5882], [5898, 6007, 6062, 6062, 6334], [6336, 6377, 6402, 6402, 6474], [6476, 6539, 6575, 6575, 6707], [6709, 6790, 6826, 6846, 7498], [7716, 7811, 7850, 7875, 8305], [8308, 8317, 8364, 8393, 9094]]}
{"id": "NtXcDr", "name": "A Sunday Distance field", "author": "mrange", "description": "A Sunday Distance field\nCombination of an earlier eye shader and a hand shader in an effort to\nto recreate the classic hand eye pattern", "tags": ["2d"], "likes": 12, "viewed": 270, "published": 3, "date": "1647779066", "time_retrieved": "2024-07-30T16:57:40.497892", "image_code": "// CC0: A Sunday Distance field\n//  Combination of an earlier eye shader and a hand shader in an effort to\n//  to recreate the classic hand eye pattern\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat vesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat parabola(vec2 pos, float wi, float he) {\n  pos.x = abs(pos.x);\n  float ik = wi*wi/he;\n  float p = ik*(he-pos.y-0.5*ik)/3.0;\n  float q = pos.x*ik*ik*0.25;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r/q)/3.0)*sqrt(p);\n  x = min(x,wi);\n  return length(pos-vec2(x,he-x*x/ik)) * \n         sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat segmenty(vec2 p, float off) {\n  p.y = abs(p.y);\n  p.y -= off;\n  float d0 = abs(p.x);\n  float d1 = length(p);\n  return p.y > 0.0 ? d1 : d0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat eye(vec2 p) {\n  float a  = mix(0.0, 0.85, smoothstep(0.995, 1.0, cos(TAU*TIME/5.0)));\n  const float b = 4.0;\n  float rr = mix(1.6, b, a);\n  float dd = mix(1.12, b, a);\n  vec2 p0 = p;\n  p0 = p0.yx;\n  float d0 =  vesica(p0, rr, dd);\n  float d5 = d0;\n  vec2 p1 = p;\n  p1.y -= 0.28;\n  float d1 = circle(p1, 0.622);\n  d1 = max(d1,d0);\n  vec2 p2 = p;\n  p2 -= vec2(-0.155, 0.35);\n  float d2 = circle(p2, 0.065);\n  vec2 p3 = p;\n  p3.y -= 0.28;\n  p3 = toPolar(p3);\n  float n3 = mod1(p3.x, 0.05);\n  float d3 = abs(p3.x)-0.0125*(1.0-length(p1));\n  vec2 p4 = p;\n  p4.y -= 0.28;\n  float d4 = circle(p4, 0.285);\n  d3 = max(d3,-d4);\n  d1 = pmax(d1,-d2, 0.0125);\n  d1 = max(d1,-d3);\n  float t0 = abs(0.9*p.x);\n  t0 *= t0;\n  t0 *= t0;\n  t0 *= t0;\n  t0 = clamp(t0, 0.0, 1.0);\n  d0 = abs(d0)-mix(0.0125, -0.0025, t0);\n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  return d;\n}\n\nfloat hand(vec2 p) {\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0 -= vec2(0.0, 0.180+0.00);\n  float d0 = segmenty(p0, 0.61)-0.1;\n  vec2 p1 = p;\n  p1 -= vec2(0.2, 0.125);\n  float d1 = segmenty(p1,0.55)-0.09;\n  vec2 p2 = p;\n  p2 -= vec2(0.0, -0.38+0.3);\n  p2.y = -p2.y;\n  float d2 = unevenCapsule(p2, 0.3, 0.38, 0.3);\n  vec2 p3 = p;\n  p3 -= vec2(0.47, -0.31);\n  float d3 = parabola(p3, 0.37, 0.5);\n  vec2 p4 = p;\n  p4 -= vec2(0.99, -0.4);\n  float d4 = circle(p4, 0.61);\n  d3 = max(d3, -d4);\n  vec2 p5 = p;\n  p5 -= vec2(0.0, -0.47);\n  float d5 = vesica(p5.yx, 0.175, 0.1)-0.2;\n  d0 = min(d0, d1);  \n  d3 = p.y > -0.40 ? d3 : d2;\n  float d = d3;\n  d = min(d, d2);\n  d = pmax(d, -(d0-0.01), 0.025);\n  d = min(d, d0);\n  float od = d;\n  od = abs(od-0.02)-0.0075;\n  d = min(d, od);\n  d = pmin(d, d5, 0.01);\n  return d;\n}\n\nfloat df(vec2 p) {\n  float dh = hand(p);\n  const float ze = 0.3;\n  vec2 pe = p;\n  pe -= vec2(0.0, -0.45);\n  pe /= ze;\n  float de = eye(pe);\n  de *= ze;\n  float d = dh;\n  d = max(d, -de);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x    *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.1*q.y);\n  float d = df(p);\n  col = mix(col, mix(vec3(1.0, 0.5, 0.5), vec3(.5, 0.55, 0.95), q.y), smoothstep(aa, -aa, d));\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXcDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 339, 375, 375, 608], [611, 697, 736, 736, 861], [863, 957, 997, 997, 1146], [1148, 1242, 1300, 1300, 1525], [1527, 1621, 1667, 1667, 2054], [2056, 2139, 2178, 2178, 2263], [2265, 2265, 2304, 2304, 2333], [2335, 2335, 2370, 2370, 2481], [2483, 2483, 2505, 2505, 2549], [2551, 2551, 2582, 2582, 2608], [2610, 2610, 2629, 2629, 3471], [3473, 3473, 3493, 3493, 4278], [4280, 4280, 4298, 4298, 4480], [4482, 4482, 4537, 4537, 4874]]}
{"id": "NtfyDr", "name": "Fluid Circles 2837492", "author": "SnoopethDuckDuck", "description": "made this as i was feeling asleep, simple but kinda cool", "tags": ["e"], "likes": 11, "viewed": 270, "published": 3, "date": "1647778258", "time_retrieved": "2024-07-30T16:57:41.404468", "image_code": "float cc(float a, float b, float c) {\n    float f = thc(a,b);\n    return sign(f) * pow(abs(f), c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.y += 0.03 * cos(iTime);\n    float d = 1e5;\n    \n    vec2 p = vec2(0);\n    for (float i = -1.; i < 20.; i++) {\n        float t = 4.5 * pi * i / 20. - 0.6 * iTime;\n        float pw = (32. + 16. * cos(pi * i + iTime)) / length(uv);\n        vec2 q = 0.35 * vec2(cc(4., t, pw), cc(4., pi/2. - t, pw));\n        \n        vec2 m = 0.5 * (p + q);\n        float ci = abs(length(uv - m) - 0.5 * length(p-q));\n        \n        if (i > -1.) d = min(d, ci);\n        p = q;\n    }\n    \n    float k = 0.75 / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.01);\n    \n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 100], [102, 102, 159, 159, 849]]}
{"id": "NtXyWr", "name": "Ray Marching part 6 (Optimized)", "author": "El_Sargo", "description": "Part 6 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching", "fast"], "likes": 2, "viewed": 224, "published": 3, "date": "1647759324", "time_retrieved": "2024-07-30T16:57:42.560378", "image_code": "// Optimisations used:\n// Domain reflections to get 5/6 balls for free and 2/3 cylenders for free\n// raytraced bounding volumes\n// less raymarch steps \n// faster rotations (mat2 instead of mat3)\n\n// Performance is around 10-14 times faster on my laptop, although if you look closely there are a few small artifacts\n// Using more raymrach steps would fix this but hurt performance\n// Although instead of geeting rif of them completly it would be probably faster to implement 2x SSAA\n// For some reason the terahedron normals function seems to be slower in this shader, at least on my laptop\n\n// Also the easy to followness of this tutorial shader is kinda gone because of my modifications\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\n//Rotate around an axis\n//Set on the two other components of the vector that you aren't rotating round\n//for example x axis rotation\n//pos.yz *= rotate(0.1);\n\nmat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,\n                s, c);\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat CubeSDF(vec3 samplePoint) {    \n    samplePoint.xz *= rotate(.5 * iTime); \n    vec3 cylinderCoords = samplePoint;\n    cylinderCoords = (abs(cylinderCoords))*-1.;\n    cylinderCoords.xy = ((cylinderCoords.x - cylinderCoords.y < 0.) ? cylinderCoords.yx : cylinderCoords.xy);  \n    cylinderCoords.zy = ((cylinderCoords.z - cylinderCoords.y > 0.) ? cylinderCoords.yz : cylinderCoords.zy);\n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(cylinderCoords, 4.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n    \n    return differenceSDF(intersectSDF(cube, sphere),\n                        cylinder1);\n    \n}\n\nfloat BallsSDF(vec3 samplePoint){\n    samplePoint.xz *= rotate(.5 * iTime); \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    vec3 ballCoords = samplePoint;\n    ballCoords = (abs(ballCoords) )*-1.;\n    ballCoords.xy = ((ballCoords.x - ballCoords.y < 0.) ? ballCoords.yx : ballCoords.xy);  \n    ballCoords.zy = ((ballCoords.z - ballCoords.y > 0.) ? ballCoords.yz : ballCoords.zy);\n    \n    return sphereSDF(ballCoords +vec3(0.,.0,ballOffset), ballRadius);\n}\n//Basiclly just for the normals\nfloat sceneSDF(vec3 samplePoint){\n    return min(BallsSDF(samplePoint), CubeSDF(samplePoint));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToCube(vec3 eye, vec3 marchingDirection, float start, float end) {\nconst int MAX_MARCHING_STEPS = 20;\n\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = CubeSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat shortestDistanceToBalls(vec3 eye, vec3 marchingDirection, float start, float end) {\nconst int MAX_MARCHING_STEPS = 10;\n\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = BallsSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nfloat intersection(vec3 ro, vec3 rd, float start, float end){\n    //Cube\n    float cube;\n    vec2 CubeBound = boxIntersection(ro, rd, vec3(1.2,.9,1.2)); \n    if(CubeBound.x > -0.1) {\n        cube = shortestDistanceToCube(ro, rd, CubeBound.x, CubeBound.y);\n        if ( abs(cube - CubeBound.y) < .1)\n            cube = 1000.;\n     } else\n        cube = 1000.;\n        \n        \n    //Balls\n    return min(cube, shortestDistanceToBalls(ro, rd,start,end));\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    const float e = 0.0001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + e, p.y, p.z)) - sceneSDF(vec3(p.x - e, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + e, p.z)) - sceneSDF(vec3(p.x, p.y - e, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + e)) - sceneSDF(vec3(p.x, p.y, p.z - e))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    float dist;\n    vec2 boundingSphere = sphIntersect(eye, worldDir, vec3(0), max(1.2,1.7 + sin(1.7 * iTime)) );\n    if (boundingSphere.x > -0.1){//no intersection\n        dist = intersection(eye, worldDir, boundingSphere.x, boundingSphere.y);\n        if (abs(dist - boundingSphere.y) < 0.0001)\n            dist = 1000.;\n    } else {\n        dist = 1000.;\n    }\n    if (dist > 320.) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 nor = estimateNormal(p);\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (nor + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1204, 1204, 1225, 1225, 1316], [1318, 1409, 1455, 1455, 1487], [1489, 1573, 1615, 1615, 1647], [1649, 1738, 1785, 1785, 1818], [1820, 1928, 1961, 1961, 2391], [2393, 2480, 2514, 2514, 2542], [2544, 2661, 2706, 2775, 3381], [3383, 3383, 3445, 3445, 3856], [3857, 3857, 3924, 3924, 4142], [4144, 4384, 4417, 4417, 5142], [5144, 5144, 5177, 5177, 5636], [5637, 5669, 5702, 5702, 5765], [5767, 6188, 6276, 6276, 6617], [6619, 6619, 6708, 6708, 7050], [7064, 7064, 7125, 7136, 7519], [7521, 7775, 7840, 7840, 7972], [7974, 8063, 8092, 8092, 8394], [8396, 8888, 9028, 9028, 9618], [9620, 9990, 10075, 10075, 10875], [10877, 11204, 11253, 11288, 11419], [11421, 11421, 11478, 11478, 12677]]}
{"id": "NlfyDn", "name": "Transparent Boxes", "author": "kbx", "description": "looks neat", "tags": ["2d", "video", "transparent", "box"], "likes": 2, "viewed": 239, "published": 3, "date": "1647744644", "time_retrieved": "2024-07-30T16:57:43.439028", "image_code": "vec3 cutSquare(vec2 uv, vec3 col, vec2 pos, vec2 size) {\n  if (uv.x > pos.x && uv.x < size.x + pos.x) {} else {\n    col = vec3(.0);\n  }\n\n  if (uv.y > pos.y && uv.y < size.y + pos.y) {} else {\n    col = vec3(.0);\n  }\n  return col;\n}\n\nvec3 tex2D(sampler2D _tex, vec2 _p) {\n  vec3 col = texture(_tex, _p).xyz;\n  if (0.5 < abs(_p.x - 0.5)) {\n    col = vec3(0.1);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = fragCoord / iResolution.x;\n  vec4 m = iMouse / iResolution.x;\n  vec3 col = tex2D(iChannel0, uv);\n  vec3 cola;\n  if (m.z > 0.0) \n  {\n    for (int i = 1; i != 11; i++) {\n      cola += cutSquare(uv, col, vec2(0.1 * float(i) - 0.1, mod(m.y + 0.2, 1.) - 0.5 + (0.2 + sin(0.2 + m.y * float(i)) / 10.)), vec2(0.1));\n    }\n  } else {\n    for (int i = 1; i != 11; i++) {\n      cola += cutSquare(uv, col, vec2(0.1 * float(i) - 0.1, mod(iTime, 1.) - 0.5 + (0.2 + sin(iTime * float(i)) / 10.)), vec2(0.1));\n    }\n  }\n  fragColor = vec4(cola, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 231], [233, 233, 270, 270, 378], [380, 380, 435, 435, 986]]}
{"id": "flfcWn", "name": "Interesting Colors 9304823942", "author": "SnoopethDuckDuck", "description": "was messing around with iq's color pallettes and got this. looks surprisingly nice (very messy code)", "tags": ["e"], "likes": 6, "viewed": 312, "published": 3, "date": "1647740539", "time_retrieved": "2024-07-30T16:57:44.732570", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define pi 3.14159\n\nfloat invs(float y) { return 0.5 - sin(asin(1.0-2.0*y)/3.0); }\nvec3 invs(vec3 y) { return vec3(invs(y.x), invs(y.y), invs(y.z)); }\n\nvec3 cc(vec3 p) {\n    vec3 f = thc(0.01, p);\n   // return sign(f) * pow(abs(f), vec3(16.));\n    float k = 5.;//1. * pi;\n   // f = mod(f, 2.) -1.;\n    //f = smoothstep(0.25, 0.75, f);\n    f = mod(p, 2.)-1.;\n    //f = 2. * max(fract(p), fract(-p))- 1.;\n   // return sign(f) * pow(abs(f), vec3(4.));\n   return f; exp(0.0 * abs(f));\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n   // return 0.5 + 0.5 * tanh(0.5 + 0.5 * cos(6.28318*(c*t+d) ));\n    return a + b*(cc(6.28318*(c*t+d) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float d = exp(-4. * length(uv)) + 0.1 * iTime;\n    float a = mod(atan(uv.x, uv.y), 2. * pi);\n    //vec3 col = pal(d * 1. + 0.2 * iTime,\n    \n   \n    \n    vec3 col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    vec3 col2 = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    col = mix(col, col2, 0.5 + 0.5 * cos(a + iTime));\n    \n    /*if( a>(2. * pi * 1.0/7.0) ) col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( a>(2. * pi * 2.0/7.0) ) col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( a>(2. * pi * 3.0/7.0) ) col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( a>(2. * pi * 4.0/7.0) ) col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( a>(2. * pi * 5.0/7.0) ) col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( a>(2. * pi * 6.0/7.0) ) col = pal( d, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    */\n    col = clamp(col, 0., 1.);\n    col = pow(col, vec3(1.5));\n    //vec3 col = vec3(d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfcWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 81, 81, 122], [123, 123, 142, 142, 190], [192, 192, 209, 209, 522], [525, 525, 593, 659, 702], [704, 704, 761, 761, 2118]]}
{"id": "slscRM", "name": "The Drive Home Hack", "author": "ASkkk", "description": "1", "tags": ["1"], "likes": 2, "viewed": 254, "published": 3, "date": "1647705877", "time_retrieved": "2024-07-30T16:57:49.749157", "image_code": "// \"The Drive Home\" by Martijn Steinrucken aka BigWings - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// I was looking for something 3d, that can be made just with a point-line distance function.\n// Then I saw the cover graphic of the song I'm using here on soundcloud, which is a bokeh traffic\n// shot which is a perfect for for what I was looking for.\n//\n// It took me a while to get to a satisfying rain effect. Most other people use a render buffer for\n// this so that is how I started. In the end though, I got a better effect without. Uncomment the\n// DROP_DEBUG define to get a better idea of what is going on.\n//\n// If you are watching this on a weaker device, you can uncomment the HIGH_QUALITY define\n//\n// Music:\n// Mr. Bill - Cheyah (Zefora's digital rain remix) \n// https://soundcloud.com/zefora/cheyah\n//\n// Video can be found here:\n// https://www.youtube.com/watch?v=WrxZ4AZPdOQ\n//\n// Making of tutorial:\n// https://www.youtube.com/watch?v=eKtsY7hYTPg\n//\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n#define sat(x) clamp(x,0.,1.)\n\n#define streetLightCol vec3(1., .7, .3)\n#define headLightCol vec3(.8, .8, 1.)\n#define tailLightCol vec3(1., .1, .1)\n\n#define HIGH_QUALITY\n#define CAM_SHAKE 1.\n#define LANE_BIAS .5\n#define RAIN\n//#define DROP_DEBUG\n\nvec3 ro, rd;\n\nfloat N(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n \nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nfloat Remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\nfloat BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n\tfloat d = DistLine(ro, rd, p);\n    float m = S(size, size*(1.-blur), d);\n    \n    #ifdef HIGH_QUALITY\n    m *= mix(.7, 1., S(.8*size, size, d));\n    #endif\n    \n    return m;\n}\n\n\n\nfloat SawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\n\nfloat DeltaSawTooth(float t) {\n    return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n}  \n\nvec2 GetDrops(vec2 uv, float seed, float m) {\n    \n    float t = iTime+m*30.;\n    vec2 o = vec2(0.);\n    \n    #ifndef DROP_DEBUG\n    uv.y += t*.05;\n    #endif\n    \n    uv *= vec2(10., 2.5)*2.;\n    vec2 id = floor(uv);\n    vec3 n = N31(id.x + (id.y+seed)*546.3524);\n    vec2 bd = fract(uv);\n    \n    vec2 uv2 = bd;\n    \n    bd -= .5;\n    \n    bd.y*=4.;\n    \n    bd.x += (n.x-.5)*.6;\n    \n    t += n.z * 6.28;\n    float slide = SawTooth(t);\n    \n    float ts = 1.5;\n    vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n    \n    bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n    \n    #ifdef HIGH_QUALITY\n    float dropShape = bd.x*bd.x;\n    dropShape *= DeltaSawTooth(t);\n    bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n    #endif\n    \n    float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n    \n    float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n    trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n    float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n    \n    float mainDrop = S(.2, .1, d);\n    float dropTrail = S(.1, .02, td);\n    \n    dropTrail *= trailMask;\n    o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n    \n    #ifdef DROP_DEBUG\n    if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n    #endif\n    \n    return o;\n}\n\nvoid CameraSetup(vec2 uv, vec3 pos, vec3 lookat, float zoom, float m) {\n\tro = pos;\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    float t = iTime;\n    \n    vec2 offs = vec2(0.);\n    #ifdef RAIN\n    vec2 dropUv = uv; \n    \n    #ifdef HIGH_QUALITY\n    float x = (sin(t*.1)*.5+.5)*.5;\n    x = -x*x;\n    float s = sin(x);\n    float c = cos(x);\n    \n    mat2 rot = mat2(c, -s, s, c);\n   \n    #ifndef DROP_DEBUG\n    dropUv = uv*rot;\n    dropUv.x += -sin(t*.1)*.5;\n    #endif\n    #endif\n    \n    offs = GetDrops(dropUv, 1., m);\n    \n    #ifndef DROP_DEBUG\n    offs += GetDrops(dropUv*1.4, 10., m);\n    #ifdef HIGH_QUALITY\n    offs += GetDrops(dropUv*2.4, 25., m);\n    //offs += GetDrops(dropUv*3.4, 11.);\n    //offs += GetDrops(dropUv*3., 2.);\n    #endif\n    \n    float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n    ripple *= .005;\n    offs += vec2(ripple*ripple, ripple);\n    #endif\n    #endif\n    vec3 center = ro + f*zoom;\n    vec3 i = center + (uv.x-offs.x)*r + (uv.y-offs.y)*u;\n    \n    rd = normalize(i-ro);\n}\n\nvec3 HeadLights(float i, float t) {\n    float z = fract(-t*2.+i);\n    vec3 p = vec3(-.3, .1, z*40.);\n    float d = length(p-ro);\n    \n    float size = mix(.03, .05, S(.02, .07, z))*d;\n    float m = 0.;\n    float blur = .1;\n    m += BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    m += BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur);\n    #endif\n    \n    float distFade = max(.01, pow(1.-z, 9.));\n    \n    blur = .8;\n    size *= 2.5;\n    float r = 0.;\n    r += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), size, blur);\n    r += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), size, blur);\n    r *= distFade*distFade;\n    \n    return headLightCol*(m+r)*distFade;\n}\n\n\nvec3 TailLights(float i, float t) {\n    t = t*1.5+i;\n    \n    float id = floor(t)+i;\n    vec3 n = N31(id);\n    \n    float laneId = S(LANE_BIAS, LANE_BIAS+.01, n.y);\n    \n    float ft = fract(t);\n    \n    float z = 3.-ft*3.;\t\t\t\t\t\t// distance ahead\n    \n    laneId *= S(.2, 1.5, z);\t\t\t\t// get out of the way!\n    float lane = mix(.6, .3, laneId);\n    vec3 p = vec3(lane, .1, z);\n    float d = length(p-ro);\n    \n    float size = .05*d;\n    float blur = .1;\n    float m = BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur) +\n    \t\t\tBokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    float bs = n.z*3.;\t\t\t\t\t\t// start braking at random distance\t\t\n    float brake = S(bs, bs+.01, z);\n    brake *= S(bs+.01, bs, z-.5*n.y);\t\t// n.y = random brake duration\n    \n    m += (BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur) +\n    \tBokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur))*brake;\n    #endif\n    \n    float refSize = size*2.5;\n    m += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), refSize, .8);\n    m += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), refSize, .8);\n    vec3 col = tailLightCol*m*ft; \n    \n    float b = BokehMask(ro, rd, p+vec3(.12, 0., 0.), size, blur);\n    b += BokehMask(ro, rd, p+vec3(.12, -.2, 0.), refSize, .8)*.2;\n    \n    vec3 blinker = vec3(1., .7, .2);\n    blinker *= S(1.5, 1.4, z)*S(.2, .3, z);\n    blinker *= sat(sin(t*200.)*100.);\n    blinker *= laneId;\n    col += blinker*b;\n    \n    return col;\n}\n\nvec3 StreetLights(float i, float t) {\n\t float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset); \n    vec3 p = vec3(2.*side, 2., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    distFade *= (1.-z);\n    float m = BokehMask(ro, rd, p, .05*d, blur)*distFade;\n    \n    return m*streetLightCol;\n}\n\nvec3 EnvironmentLights(float i, float t) {\n\tfloat n = N(i+floor(t));\n    \n    float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset+fract(n*234.));\n    float n2 = fract(n*100.);\n    vec3 p = vec3((3.+n)*side, n2*n2*n2*1., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    float m = BokehMask(ro, rd, p, .05*d, blur);\n    m *= distFade*distFade*.5;\n    \n    m *= 1.-pow(sin(z*6.28*20.*n)*.5+.5, 20.);\n    vec3 randomCol = vec3(fract(n*-34.5), fract(n*4572.), fract(n*1264.));\n    vec3 col = mix(tailLightCol, streetLightCol, fract(n*-65.42));\n    col = mix(col, randomCol, n);\n    return m*col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec3 col = vec3(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 pos = vec3(.3, .15, 0.);\n    \n    float bt = t * 5.;\n    float h1 = N(floor(bt));\n    float h2 = N(floor(bt+1.));\n    float bumps = mix(h1, h2, fract(bt))*.1;\n    bumps = bumps*bumps*bumps*CAM_SHAKE;\n    \n    pos.y += bumps;\n    float lookatY = pos.y+bumps;\n    vec3 lookat = vec3(0.3, lookatY, 1.);\n    vec3 lookat2 = vec3(0., lookatY, .7);\n    lookat = mix(lookat, lookat2, sin(t*.1)*.5+.5);\n    \n    uv.y += bumps*4.;\n    CameraSetup(uv, pos, lookat, 2., mouse.x);\n   \n    t *= .03;\n    t += mouse.x;\n    \n    // fix for GLES devices by MacroMachines\n    #ifdef GL_ES\n\tconst float stp = 1./8.;\n\t#else\n\tfloat stp = 1./8.\n\t#endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += StreetLights(i, t);\n    }\n    \n    for(float i=0.; i<1.; i+=stp) {\n        float n = N(i+floor(t));\n    \tcol += HeadLights(i+n*stp*.7, t);\n    }\n    \n    #ifndef GL_ES\n    #ifdef HIGH_QUALITY\n    stp = 1./32.;\n    #else\n    stp = 1./16.;\n    #endif\n    #endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += EnvironmentLights(i, t);\n    }\n    \n    col += TailLights(0., t);\n    col += TailLights(.5, t);\n    \n    col += sat(rd.y)*vec3(.6, .5, .9);\n    \n\tfragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slscRM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1442, 1442, 1460, 1460, 1508], [1509, 1509, 1528, 1564, 1736], [1737, 1737, 1755, 1811, 1954], [1957, 1957, 1999, 1999, 2034], [2037, 2037, 2082, 2135, 2180], [2182, 2182, 2240, 2240, 2273], [2275, 2275, 2342, 2342, 2520], [2524, 2524, 2549, 2549, 2604], [2606, 2606, 2636, 2636, 2707], [2711, 2711, 2756, 2756, 4054], [4056, 4056, 4127, 4127, 5130], [5132, 5132, 5167, 5167, 5942], [5945, 5945, 5980, 5980, 7393], [7395, 7395, 7432, 7432, 7840], [7842, 7842, 7884, 7884, 8594]]}
{"id": "stsyRM", "name": "ccb feedback test", "author": "morisil", "description": "basic feedback demo", "tags": ["test"], "likes": 6, "viewed": 368, "published": 3, "date": "1647703400", "time_retrieved": "2024-07-30T16:57:50.957926", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nhttps://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\nvec2 R = iResolution.xy,\n  // U = fragCoord / R.y;                     // [0,1] vertically\n     U = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n  // U = ( fragCoord - .5*R ) / R.y;          // [-1/2,1/2] vertically\n  // U = ( 2.*fragCoord - R ) / min(R.x,R.y); // [-1,1] along the shortest side\n*/  \n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =  (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 offsetInput = texture(iChannel0, uv).rgb;\n\n    vec2 feedbackOffset = vec2(sin(st.x * 40.), cos(st.y * 40. + iTime)) * .0005;\n    //vec2 feedbackOffset = (offsetInput.xy * 2. - 1.) * .001;\n    //vec2 feedbackOffset = st * .001;\n    vec3 prevFrame = texture(iChannel0, uv - feedbackOffset).rgb;\n    vec3 cameraFrame = texture(iChannel1, uv).rgb;\n    vec3 color = prevFrame * .99 + cameraFrame * .01;\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 142]]}
{"id": "ftscz7", "name": "Fork L2 - TP1 & Nordine 076", "author": "Nordine", "description": "TP 1 & 2 \nModeling shapes with signed distance fields", "tags": ["distancefields", "scalarfields"], "likes": 2, "viewed": 277, "published": 3, "date": "1647698562", "time_retrieved": "2024-07-30T16:57:52.053994", "image_code": "// Modeling - 2022.02.06\n// Eric Galin \n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Primitives \n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Sphere \n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n\n// Intersection\n// a,b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\n\n/*float Cercle()\n{\n    d\n}\n*/\n\n// Boite \n// p : point\n// c : position centre\n// tx : taille x\n// ty : taille y\n// tz : taille z\n\n\nfloat Boite(vec3 p, vec3 c, float tx,float ty,float tz) // fonction qui crée une boite\n{\n    vec3 o1 = c + vec3(tx,0,0); // j'initialise la position des faces de la boite\n    vec3 o2 = c + vec3(0,ty,0); // (leurs distance depuis le centre)\n    vec3 o3 = c + vec3(0,0,tz);\n    vec3 o4 = c + vec3(-tx,0,0);\n    vec3 o5 = c + vec3(0,-ty,0);\n    vec3 o6 = c + vec3(0,0,-tz);\n    vec3 n1 = vec3(1,0,0); // je crée les 6 normale \n    vec3 n2 = vec3(0,1,0);\n    vec3 n3 = vec3(0,0,1);\n    vec3 n4 = vec3(-1,0,0);\n    vec3 n5 = vec3(0,-1,0);\n    vec3 n6 = vec3(0,0,-1);\n    float p1 = Plane(p,n1,o1); // je crée les 6 plans d'une boite\n    float p2 = Plane(p,n2,o2);\n    float p3 = Plane(p,n3,o3);\n    float p4 = Plane(p,n4,o4);\n    float p5 = Plane(p,n5,o5);\n    float p6 = Plane(p,n6,o6);\n    float f1 = Intersection(p1,p2); //On relie tout les cotés de la boite\n    float f2 = Intersection(p3,p4);\n    float f3 = Intersection(p5,p6);\n    return Intersection(f1,Intersection(f2,f3)); // retourne la distance euclidienne d'une boite\n}\n\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    float p1 = Boite(p,vec3(24.0,0.0,0.0),1.0,1.0,6.0); // je crée les 4 pilliers qui tiennent\n    float p2 = Boite(p,vec3(24.0,12.0,0.0),1.0,1.0,6.0); // la base du lit\n    float p3 = Boite(p,vec3(0.0,12.0,0.0),1.0,1.0,6.0);\n    float p4 = Boite(p,vec3(0.0,0.0,0.0),1.0,1.0,6.0);\n    \n    float u1 = Union(p1,p2); // je les lies\n    float u2 = Union(p3,p4);\n    float Ensemble_pillier_barre = Union(u1,u2); // stock les barres des pilliers\n    \n    float p5 = Boite(p,vec3(0.0,0.0,5.0),0.15,0.15,2.0); // je crée les 4 sous-pilliers\n    float sp1 = Sphere(p,vec3(0.0,0.0,7.2),0.9); // je crée les 4 spheres qui seront soutenues\n    \n    float p6 = Boite(p,vec3(24.0,0.0,5.0),0.15,0.15,2.0);\n    float sp2 = Sphere(p,vec3(24.0,0.0,7.2),0.9);\n    \n    float p7 = Boite(p,vec3(24.0,12.0,5.0),0.15,0.15,2.0);\n    float sp3 = Sphere(p,vec3(24.0,12.0,7.2),0.9);\n    \n    float p8 = Boite(p,vec3(0.0,12.0,5.0),0.15,0.15,2.0);\n    float sp4 = Sphere(p,vec3(0.0,12.0,7.2),0.9);\n    \n    float boule1 = Union(p5,sp1);\n    float boule2 = Union(p6,sp2);\n    float boule3 = Union(p7,sp3);\n    float boule4 = Union(p8,sp4);\n    \n    float Ensemble_pillier_boule = Union(boule1,Union(boule2,Union(boule3,boule4))); //stock les boules\n    \n    float Ensemble_pillier = Union(Ensemble_pillier_boule,Ensemble_pillier_barre); // stock pillier\n    \n    float oreiller = Boite(p,vec3(4.5,6.0,3.5),3.0,5.0,0.7);\n    \n    float base_lit = Boite(p,vec3(12.0,6.0,2.0),12.0,6.0,1.0);\n    \n    float lit = Union(Union(base_lit,Ensemble_pillier),oreiller); // crée le lit\n    \n    float placard_base = Boite(p,vec3(-6,-10,0.0),2.0,6.0,10.5);\n    \n    float placard_separe_porte = Boite(p,vec3(-4.1,-10.0,0.3),0.3,0.3,10.2);\n    \n    float base_placard = Union(placard_base,placard_separe_porte);\n    \n    float poignee_droite = Boite(p,vec3(-3.8,-8.6,3.5),0.3,0.3,1.2);\n        \n    float poignee_gauche = Boite(p,vec3(-3.8,-11.4,3.5),0.3,0.3,1.2);\n    \n    float ensemble_poignees = Union(poignee_gauche,poignee_droite);\n    \n    float placard = Union(base_placard,ensemble_poignees); // crée le placard\n        \n    return Union(Plane(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0)),Union(lit,placard));// crée la scene\n\n    \n  \n  \n}\n\n// Analysis of the scalar field \n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n  // Start at the origin\n  float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting \n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// r : Radius for ambient occlusion\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, float r, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,r,h,s);\n        if (!h) {ao+=1.0;}\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.45,0.55,0.99),vec3(0.65,0.69,0.99), d.z*0.5+0.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p+0.1*n,l,100.0,h,s);\n    if (!h)\n    {\n      return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    // Ambient color\n    vec3 ambient = 0.25+0.25*background(n);\n    \n    // Ambient occlusion\n    ambient += 0.15 * AmbientOcclusion(p+0.1*n,n,5.0,0) * vec3(1.0,1.0,1.0);\n    \n    // Shadow computation\n    float shadow = Shadow(p,n,l);\n    \n    // Phong diffuse\n    vec3 diffuse = 0.35  * clamp(dot(n, l),0.0,1.0) * vec3(1.0,1.0,1.0);\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = 0.15 * pow(clamp(dot(r,l),0.0,1.0),30.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t = float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p = (-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip = true;\n    }\n       else\n       {\n           pip = false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Modeling\n// Eric Galin\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( float seed, vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m, vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.5;\n    \n    // Origin\n    ro=vec3(37.0,0.0,15.0);\n    ro*=Rz(a); \n\n    // Target\n    vec3 ta = vec3(0.0,0.0,1.0);\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftscz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 217, 255, 255, 281], [283, 352, 389, 389, 416], [433, 494, 524, 524, 547], [550, 618, 655, 655, 678], [811, 811, 900, 900, 1842], [1846, 1892, 1914, 1914, 4121], [4157, 4197, 4224, 4224, 4450], [4452, 4582, 4647, 4647, 5033], [5049, 5158, 5213, 5213, 5485], [5487, 5528, 5553, 5553, 5625], [5627, 5690, 5726, 5726, 5858], [5860, 5941, 5977, 5997, 6648], [6866, 6961, 7000, 7025, 7455], [7458, 7467, 7514, 7543, 8244]]}
{"id": "Ntscz7", "name": "peaks n2", "author": "jorge2017a2", "description": "peaks n2", "tags": ["peaksn2"], "likes": 0, "viewed": 178, "published": 3, "date": "1647698181", "time_retrieved": "2024-07-30T16:57:53.072272", "image_code": "\n//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdBox2d( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nvec2 picos02bxPar(vec2 p, float par)\n{    p.x= opRep1D(p.x, par );\n    float d1a= sdCircle(p*vec2(1.0,0.4)-vec2(-1.6,-0.5), 1.6 );\n    float d1b= sdCircle(p*vec2(1.0,0.4)-vec2( 1.6,-0.5), 1.6 );\n    float d2a= sdBox2d(p-vec2(0.0,1.2),vec2(3.25,1.8) );\n    float dif;\n    dif=differenceSDF(d2a, d1a);\n    dif=differenceSDF(dif, d1b);\n    return vec2(dif,1.0);\n}\n\nvec2 HacerPicosParXY(vec3 p, float par, float mul)\n{   vec2 res= vec2(9999.0, -1.0);\n    vec2 pibx1= picos02bxPar(p.xy*mul, par);\n    float d1= sdBox( p, vec3(15.0,6.0,0.5) );\n    float dif=intersectSDF(pibx1.x,d1);\n    res =opU2(res, vec2(dif, 1.0));\n    return res;\n}\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    \n    p.y=p.y+5.0;\n    p= rotate_y(p, radians(45.0));\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+5.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,62.0));\n   float py=5.0*sin(iTime*0.5);\n   p=p0; \n   p.z-=10.0;  p.y-=2.0+py;\n   vec2 h1= HacerPicosParXY(p, 1.35,1.0);\n   p=p0; \n   p.z-=15.0; p.y-=7.0+py;\n   vec2 h2= HacerPicosParXY(p, 1.96,1.0);\n   p=p0;p.z-=20.0; p.y-=5.0+py;\n   vec2 h3= HacerPicosParXY(p, 6.4,1.0);\n   p=p0;p.z-=30.0; p.y+=3.0+py;\n   vec2 h4= HacerPicosParXY(p, 6.4,0.5);\n   res =opU2(res,vec2(h1.x,1.0));\n   res =opU2(res, h2);\n   res =opU2(res, h3);\n   res =opU2(res, h4);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    float shadow = getSoftShadow(hit, normalize(lightPos));// shadows\n    float occ = occlusion(hit, norm);// occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0)*norm.y;\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color)); return colobj; }\n    \n   if (id_color==64)\n   { return vec3(1)*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0); }\n   \n   \n   if (id_color==62)\n   { if ( mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0)>0.5)\n      return vec3(0.0);\n     else  return vec3(0.0,0.5,1.0);\n   }  \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=17.0;\n   float veltime=20.0;  \n    float tt = radians( -iTime*veltime);\n\n    vec3  pos=vec3(-10.0,-2.5,40.0);\n    vec3 rotation1 =pos+ vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0,35.0); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -40.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,6.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n   rd= rotate_x(rd, radians(5.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//-------common\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntscz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 532, 532, 616], [618, 618, 665, 665, 692], [693, 693, 736, 736, 763], [764, 764, 812, 812, 840], [841, 841, 877, 877, 922], [923, 963, 997, 997, 1093], [1094, 1094, 1128, 1128, 1219], [1220, 1220, 1254, 1254, 1345], [1347, 1347, 1386, 1386, 1460], [1462, 1462, 1497, 1497, 1520], [1523, 1523, 1561, 1561, 1883], [1885, 1885, 1937, 1937, 2154], [2155, 2155, 2180, 2180, 2826], [2828, 2828, 2852, 2852, 3014], [3016, 3016, 3064, 3064, 3380], [3382, 3382, 3426, 3426, 3752], [3754, 3754, 3791, 3791, 4052], [4054, 4054, 4139, 4139, 5087], [5089, 5089, 5182, 5182, 5312], [5314, 5314, 5346, 5346, 5543], [5546, 5546, 5614, 5614, 5959], [5961, 5961, 5988, 5988, 6077], [6079, 6079, 6137, 6137, 6185], [6187, 6187, 6210, 6210, 6328], [6330, 6330, 6361, 6361, 6981], [6984, 6984, 7021, 7021, 7295], [7299, 7299, 7356, 7356, 7891]]}
{"id": "NllczM", "name": "adaptive polar lines 3", "author": "FabriceNeyret2", "description": "draw a ~screenspace-constant density of curves \n\niMouse.y controls zoom while preserving screen-space density.", "tags": ["raytracing", "intersection", "isolines", "hatching", "balanced"], "likes": 15, "viewed": 369, "published": 3, "date": "1647688352", "time_retrieved": "2024-07-30T16:57:54.190283", "image_code": "// variant of https://shadertoy.com/view/flXyR7\n\n//#define S\n#define S(v)     ( v - 6.283*sign(v)*step(3.14,abs(v)) )     // fight wrap discontinuity\n#define fwidth2(v) length( S( vec2( dFdx(v), dFdy(v) ) ) )   // high quality fwidyj\n#define fwidth(v)  fwidth2(v)                                // to manage wrap\n#define r          mat2(cos(.3*iTime+vec4(0,-1,1,0)*1.5708)) // rotation\n#define LOD(v)     exp2( round(log2(abs(.5/(v)))))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( 2.*u - R.xy, 0 ) / R.y;                 // P on sphere surface (or background)\n    if (iMouse.z>0.) P *= exp2( 2.*(2.*iMouse.y/R.y-1.) ); // mouse.y zoom\n    float l = length(P), n=2.;                             // n : more lines  \n    P.z = sqrt(1.-l*l);\n    P.xy *= r; P.yz *= r;                                  // rotations\n    float a = sign(P.z)* acos(clamp(P.x/sqrt(1.-P.y*P.y),-1.,1.)), // polar coord\n          t = sin(3.*asin(P.y)),\n          U = a + .1*cos(10.*a)  - t,                      // isoline to draw\n          V,\n          d = fwidth2(U),\n          z = LOD(d) ,                                     // LOD \n          f = .5 + log2(abs(.5/d)) - log2(z),              // fractional part\n          p = fwidth(U) * z*n;\n          U *= z*n;\n    V = abs(sin(U)/(cos(U)*p));                            // lines\n // f = max(1.5*f-.5 ,0.);                                 // shorter transition\n    O = l > 1. \n          ? vec4(.5)                                       // background\n          : vec4( abs(sin(U/2.)) < .5 \n                    ? V                                    // plain line\n                    : mix( 1., V, f ));                    // transition lines  \n\n    O = sqrt(O);                                           // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 476, 476, 1782]]}
{"id": "NllcRM", "name": "cubemap=_=", "author": "fl0a1e", "description": "hhh", "tags": ["3d"], "likes": 2, "viewed": 234, "published": 3, "date": "1647680113", "time_retrieved": "2024-07-30T16:57:55.110821", "image_code": "\n#define PI 3.1415926\n#define AA 2\n#define INV_GAMMA 0.454545\n#define FOCAL  3.5f \n#define SENSITIVITY 5.\n\n// p is the point in 3D world\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\n\n\n// return minimum distance to surface\nfloat map(in vec3 pos){\n    float res = sdSphere( pos-vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n\n\n// return distance to surface of each ray\nfloat raycast(in vec3 cameraPos, in vec3 rayDir) {\n    float res = -1.0;\n    \n    // minimum and maximum distance ray traveled\n    float minDist =1.0;\n    float maxDist = 30.0;\n    \n    // raymarching\n    float dist = minDist;\n    for(int i = 0; i < 40 && dist < maxDist; i++) {   // \"i\" means the frequency of sphere tracking.\n    \n        float temp = map(cameraPos + rayDir * dist);\n        if( abs(temp) < 0.0001 ) {    // if close enough to the surface\n            res = dist;\n            break;\n        }\n        dist += temp; // Sphere Tracking, so we need to add minimum distance to Surface for speed up function.\n    }\n    return res;\n}\n\n\n\nvec3 calcNormal(in vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n      \n    }\n    return normalize(n);\n}\n\n\nvec3 render(in vec3 cameraPos, in vec3 rayDir, in vec2 uv, in vec3 col) {\n    // raycast scene(raymarching!)\n    float res = raycast(cameraPos, rayDir);\n    \n    // render sphere\n    if(res > 0.){\n        vec3 pos = cameraPos + rayDir * res;\n        vec3 nor = calcNormal(pos);    // normal\n        \n        {\n        // texture    \n        vec2 polarUV = vec2(atan(pos.x*800., pos.z*450.)/PI, 4.*pos.y);\n        vec3 t = texture(iChannel0, nor).rgb;\n        \n        col = t;     \n        }\n        \n    }\n    return col;\n}\n\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n    vec3 cw = normalize(ta - ro); // the direction our camera watched\n    // calculate the x&y-axis centered on camera.\n    vec3 cu= normalize( cross(cw,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 cv=          ( cross( cu, cw ) );  \n\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot;\n\n    // set camera\n    vec3 cameraPos = vec3(sin(SENSITIVITY * iMouse.x/iResolution.x), 4.*sin(SENSITIVITY * iMouse.y/iResolution.y) , 5.* cos(SENSITIVITY * iMouse.x/iResolution.x));\n    vec3 cameraOrit = vec3(0., 0., 0.);\n    mat3 camera = setCamera(cameraPos, cameraOrit, 0.);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    // ray direction\n    vec3 rayDir = camera * normalize( vec3(uv,FOCAL) );\n    \n    vec3 col;\n    \n    // background\n    col = texture(iChannel0, normalize(uv.x * camera[0] + uv.y * camera[1] + rayDir)).xyz;\n        \n    // render our world\n    col = render(cameraPos, rayDir, uv, col);\n\n    tot += col;\n\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 137, 175, 175, 201], [204, 242, 265, 265, 340], [344, 386, 436, 436, 1031], [1035, 1035, 1064, 1064, 1270], [1273, 1273, 1346, 1381, 1797], [1800, 1800, 1853, 1853, 2114], [2118, 2118, 2175, 2175, 2902]]}
{"id": "7tXyzr", "name": "sphere! blinn-phone", "author": "fl0a1e", "description": " create a sphere in the 3D world!", "tags": ["3d", "sphere"], "likes": 2, "viewed": 216, "published": 3, "date": "1647673474", "time_retrieved": "2024-07-30T16:57:55.943595", "image_code": "// ----------------------------------------------------\n// my 2nd shader!\n// I'll create a 3D sphere in this shader\n// and i'll use a simple light shading on the surface.\n// refer to iq!\n// \n// you can learn more in below project:\n// https://www.shadertoy.com/view/Xl2XWt\n//\n// or\n// https://www.shadertoy.com/view/Xds3zN\n//\n// about texture\n// https://www.shadertoy.com/view/sdj3Rc\n//\n// how amazing the raymarching is!\n// -----------------------------------------------------\n\n\n\n\n// PI\n// SSAA\n// GAMMA\n// focal length\n#define PI 3.1415926\n#define AA 2\n#define INV_GAMMA 0.454545\n#define FOCAL  3.5f      \n\n// p is the point in 3D world\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\n\n\n// return minimum distance to surface\nfloat map(in vec3 pos){\n    float res = sdSphere( pos-vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n\n\n// return distance to surface of each ray\nfloat raycast(in vec3 cameraPos, in vec3 rayDir) {\n    float res = -1.0;\n    \n    // minimum and maximum distance ray traveled\n    float minDist =1.0;\n    float maxDist = 30.0;\n    \n    // raymarching\n    float dist = minDist;\n    for(int i = 0; i < 40 && dist < maxDist; i++) {   // \"i\" means the frequency of sphere tracking.\n    \n        float temp = map(cameraPos + rayDir * dist);\n        if( abs(temp) < 0.0001 ) {    // if close enough to the surface\n            res = dist;\n            break;\n        }\n        dist += temp; // Sphere Tracking, so we need to add minimum distance to Surface for speed up function.\n    }\n    return res;\n}\n\n\n// light shader need normal.\n// calculate normal by using gradient.\n// but here I use the function from iq\n// https://www.shadertoy.com/view/Xds3zN\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\nvec3 calcNormal(in vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n      \n    }\n    return normalize(n);\n}\n\n\nvec3 render(in vec3 cameraPos, in vec3 rayDir, in vec2 uv) {\n    \n    vec3 col;\n    \n    // raycast scene(raymarching!)\n    float res = raycast(cameraPos, rayDir);\n    \n    // render sphere\n    if(res > 0.){\n        \n        vec3 pos = cameraPos + rayDir * res;\n        vec3 nor = calcNormal(pos);    // normal\n        \n        // blinn phong\n        {\n        vec3 sunPos = vec3(15.0 * cos(iTime), 15.0, 10.0 * sin(iTime));\n        \n        \n        // texture    \n        vec2 polarUV = vec2(atan(pos.x*800., pos.z*450.)/PI, 4.*pos.y);\n        vec3 t = texture(iChannel0, polarUV).rgb;\n        \n        \n        vec3 ambientColor = 2.* t;\n        vec3 diffuseColor = 2.* t;\n        vec3 specColor = vec3(0.5, 0.5, 0.5);\n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n        vec3 lightDir =  normalize(sunPos - pos);\n        float lambertian = max(dot(lightDir, nor), 0.0);\n        float shininess = 16.0;\n        float specular = 0.0;\n        float lightPower = 15.0;\n        \n        \n        vec3 halfDir = normalize(lightDir - rayDir);\n        float specAngle = max(dot(halfDir, nor), 0.0);\n        specular = pow(specAngle, shininess);\n        \n        \n        col = ambientColor +\n              diffuseColor * lambertian * lightColor * lightPower / length(sunPos - pos)*length(sunPos - pos) +\n              specColor * specular * lightColor * lightPower / length(sunPos - pos)*length(sunPos - pos);\n        }\n        \n    } else {\n        // background\n        col = vec3(0.01);\n    }\n    return col;\n}\n\n\n\n// create our camera!\n// each parameter means:ray origin, target and camera rotation\n// \n// I think that it's so-called \"billboard\". \n// we can calculate the coordinates centered on our camera.\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n    vec3 cw = normalize(ta - ro); // the direction our camera watched\n    // calculate the x&y-axis centered on camera.\n    vec3 cu= normalize( cross(cw,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 cv=          ( cross( cu, cw ) );  \n\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot;\n    \n    // init camera\n    // Attention, z-axis points out of the screen!\n    vec3 cameraPos = vec3(3.*sin(iTime), 0.5, 3.0*cos(iTime));\n    // camera orientation\n    vec3 cameraOrit = vec3(0., 0., 0.2);\n    // create camera\n    // camera-to-world transformation\n    mat3 camera = setCamera(cameraPos, cameraOrit, 0.);\n    \n    // SSAA\n    // get uv for each pixel\n    #if AA > 1\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        \n        vec2 offset = (vec2(i,j)/float(AA)) - 0.5;\n        vec2 uv = ((fragCoord+offset)-0.5*iResolution.xy)/iResolution.x;\n    \n    #else \n        vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n        \n        // ray direction\n        vec3 rayDir = camera * normalize( vec3(uv,FOCAL) );\n        \n        // render our world\n        // return color of each pixel\n        vec3 col = render(cameraPos, rayDir, uv);\n        \n        // gamma\n        col = pow( col, vec3(INV_GAMMA) );\n        \n        tot += col;\n        \n    \n    #if AA > 1\n        tot /= float(AA*AA);\n    }\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 639, 677, 677, 703], [706, 744, 767, 767, 842], [846, 888, 938, 938, 1533], [1536, 1778, 1807, 1807, 2013], [2016, 2016, 2076, 2076, 3527], [3531, 3725, 3778, 3778, 4039]]}
{"id": "7lfyz7", "name": "Blue lace pattern", "author": "jarble", "description": "A lace-like fractal pattern.", "tags": ["fractal", "lace"], "likes": 2, "viewed": 211, "published": 3, "date": "1647667556", "time_retrieved": "2024-07-30T16:57:56.776368", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.);  \n    float t1 = 36.*16.*16.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float p1 = 1.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            vec2 div = 2.5+t2*t3.yx;\n            t2 = p1*triangle_wave(uv.yx-.5,scale);\n            t3 = -p1*triangle_wave(uv,scale);\n            uv.yx = (t2+t3)/div;\n            p1 *= -1.;\n        }\n        col.x = -min(uv.y+uv.x+col.x,col.x);\n        //col.x = -max(uv.y+uv.x+col.x,col.x);\n        \n        //blue and pink\n        col = max(col,abs(col.yzx+vec3(col.x))/2.);\n        \n        //orange and blue\n        //col = col.yzx/2. + max(col.yzx,abs(col+vec3(col.x))).yzx/2.;\n        \n        //pink lace pattern\n        //col = max(col,abs(col+vec3(col.x)))/4.;\n\n        \n        \n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*6.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1248]]}
{"id": "stXyz7", "name": "Fractal knots 14", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 2, "viewed": 191, "published": 3, "date": "1647665896", "time_retrieved": "2024-07-30T16:57:57.629088", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += 1.5+(t2.yx);\n            vec2 div = scale-t3*t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2+t3+div)/div;\n            \n        }\n        //if(i>1) uv += iTime+col.x;\n        col.x = -max(((uv.y-uv.x)),-col.x);\n        //col = (col+vec3(col.x))/2.;\n        col = (col.yzx+col);\n        col /= 2.;\n    }\n    fragColor = vec4(vec3(-col*3.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 971]]}
{"id": "flXcz7", "name": "sound rudo hex", "author": "jorge2017a2", "description": "sound rudo hex", "tags": ["soundrudohex"], "likes": 3, "viewed": 247, "published": 3, "date": "1647630322", "time_retrieved": "2024-07-30T16:57:58.533670", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(2.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nconst vec2 s = vec2(1, 1.7320508);\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n\nvec3 RepetirHex(vec2 p,vec3 col)\n{\n  p=p.yx;\n  vec2 p1=p;\n  vec2 p2=p-vec2(0.0,2.0); //doble posicion\n  p1.y= opRep1D(p1.y, 4.0 );  ///posx\n  p2.y= opRep1D(p2.y, 4.0 ); ///en pos x\n  \n  float d1= sdHexagon(p1,1.0 );\n  \n  float d2=sdHexagon(p2,1.0 );\n  col= DrawFigBorde(vec3(0.3), col, d1 );\n  col= DrawFigBorde(vec3(0.5), col, d2 );\n  \nreturn col;\n}\n\nvec3 hacerHex(vec2 uv, vec3 col)\n{\n    vec2 uv1=uv;\n    vec2 uv2=uv-vec2(1.0,1.75);\n    vec2 uv3=uv-vec2(2.0,3.5);\n    float t=3.25;\n    uv1.y= opRep1D(uv1.y,t);\n    uv2.y= opRep1D(uv2.y,t);\n    uv3.y= opRep1D(uv3.y,t);\n    \n    col= RepetirHex(uv1,col);\n    col= RepetirHex(uv2,col);\n    return col;    \n}    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    \n    \n     //picture and picture\n    if (uv.x>0.0 && uv.x < 8.0 &&  uv.y>0.0 && uv.y < 8.0 )\n    {\n        float t=iTime*5.0;\n        uv+=iTime*2.0;\n        uv-=vec2(-0.5+2.5*sin(t),-0.25);\n        uv*= 0.5+sin(t*0.25);\n        col= hacerHex(uv, col);\n        col*=vec3(1.0,0.1,0.2);\n    }\n    else\n    {  uv= rotatev2(uv, radians( iTime)*20.0);\n       col= hacerHex(uv, col);\n    }\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "//modificado por jorge2017a2\n//18-mar-2022\n//referencia\n//Created by mememaestro in 2015-10-15\n//https://www.shadertoy.com/view/llBSzK\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n\nfloat note2freq(float note) \n{ return 440.0 * pow(trt,note); }\n\nfloat sawWave(float time, float freq, float amp) {\n \t   return mod(time,1.0/freq)*freq*amp;\n}\n\nvec2 bassSynth(float time, float tempo,float note) \n{ return vec2(sawWave(time, note2freq(note), exp(-0.0*mod(tempo, 0.5)))); }\n\nvec2 leadSynth(float time, float tempo,float note, float ampMask)\n{  return vec2(sawWave(time, note2freq(note+0.01), ampMask * exp(-1.0*mod(tempo, 0.5))),\n                sawWave(time, note2freq(note-0.01), ampMask * exp(-1.0*mod(tempo, 0.5))));\n}\n\nvec2 kickSynth(float time, float tempo) {\n    const float dist = 3.0;\n    tempo = mod(tempo,1.0); \n    return vec2(clamp(sin(pow((tempo+0.2)*0.0001,-0.5))*exp(-3.0*tempo),-(1.0/dist),(1.0/dist)) * dist);\n}\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 clapSynth(float time, float tempo,float ampMask) {\n    return vec2(rand(vec2(time+1.2,tempo+6.1)) * ampMask * exp(-1.5*tempo),\n                rand(vec2(time+2.1,tempo+1.6)) * ampMask * exp(-1.5*tempo));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float tempo = t * (bpm/60.0);\n    \n    float m = floor(mod(tempo/2.0,10.0)); //minim number\n    float note = floor(mod(tempo*2.0,2.0)) * 12.0 - 35.0 +\n        float(m >= 4.0  && m < 6.5) * (5.0 +2.0*(m-5.0)+ (m-4.0) * 2.0) ;\n        \n    float note2 = floor(mod(tempo*2.0,2.0)) * 6.0 - 30.0 +\n        float(m >= 4.0  && m < 6.5) * (5.0 + (m-3.0) * 2.0) ;\n    \n    vec2 bass, lead;\n    float m1= floor(mod(tempo/2.0,12.0)); \n    \n    if (m1<m)\n    {\n    \n     bass=bassSynth(t, tempo,note2)*0.30;\n     lead = leadSynth(t*1.005,tempo,note2,1.0) * 0.333;\n    }\n    \n    else\n    \n    {\n     bass=bassSynth(t, tempo,note)*0.30;\n     lead = leadSynth(t*1.005,tempo,note,1.0) * 0.333;\n    }\n    \n    vec2 kick = kickSynth(t,tempo) * 0.233;\n    \n    float q = floor(mod(tempo*2.0,32.0)); //quaver number;\n    float b = floor(q/8.0);//bar number\n    float qb = mod(q,8.0); //quaver in bar;\n    float ampMask = float((qb >= 2.0 && qb < 4.0) || (qb >= 6.0 && qb < 7.0)\n                         || (b == 3.0 && (qb == 1.0 || qb >= 5.0))); \n    if (t>10.0 && t<30.0 )\n    tempo = mod(tempo*4.0 ,2.0);\n    else\n    tempo = mod(tempo*0.5 ,4.0);\n    vec2 clap = clapSynth(t,tempo,ampMask) * 0.333;\n    \n   \n    \n    vec2 synths = bass + lead; //sidechain\n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    return synths + kick+clap*2.0;\n    \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 337, 337, 382], [388, 388, 435, 435, 462], [463, 463, 506, 506, 533], [534, 534, 582, 582, 610], [613, 613, 675, 675, 805], [808, 808, 865, 865, 935], [937, 937, 971, 971, 1066], [1068, 1068, 1105, 1105, 1179], [1218, 1218, 1243, 1243, 1262], [1263, 1263, 1288, 1288, 1307], [1308, 1308, 1344, 1344, 1372], [1374, 1374, 1416, 1416, 1606], [1609, 1609, 1643, 1643, 1959], [1961, 1961, 1995, 1995, 2267], [2278, 2278, 2335, 2335, 2986]]}
{"id": "NlXyR7", "name": "Melty feathers", "author": "ailanthus", "description": "shaders are fun", "tags": ["simple"], "likes": 1, "viewed": 196, "published": 3, "date": "1647627609", "time_retrieved": "2024-07-30T16:57:59.484129", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    uv -= .5;\n    \n    uv.x *= sin(uv.y) * 10.;\n    \n    vec3 col = vec3(0);\n    col.r = sin(uv.x*3.14*10.+iTime) + sin(uv.y*3.14*10.+iTime);\n    col.b = sin(uv.x*3.14*9.+iTime) + sin(uv.y*3.14*11.+iTime);\n    col.g = col.r*col.b*.3;\n    \n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 474]]}
{"id": "flXyR7", "name": "adaptive polar lines 2", "author": "FabriceNeyret2", "description": "draw a ~screenspace-constant density of meridians\n", "tags": ["raytracing", "intersection", "isolines", "hatching", "balanced"], "likes": 10, "viewed": 320, "published": 3, "date": "1647625181", "time_retrieved": "2024-07-30T16:58:00.422619", "image_code": "// variant of https://shadertoy.com/view/NtXyzM\n// variant of https://shadertoy.com/view/NlfcRM\n\n//#define S\n#define S(v) ( v - 6.283*sign(v)*step(3.14,abs(v)) )       // fight wrap discontinuity\n#define fwidth2(v) length( S( vec2( dFdx(v), dFdy(v) ) ) ) // high quality fwidyj\n#define fwidth(v)  vec2( fwidth2(v.x), fwidth2(v.y) )        // to manage wrap\n#define r          mat2(cos(.3*iTime+vec4(0,-1,1,0)*1.5708)) // rotation\n#define LOD(v)     exp2( round(log2(abs(.5/(v)))))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( 2.*u - R.xy, 0 ) / R.y;                 // P on sphere surface (or background)\n    float l = length(P), n = 1.;                           // n : more lines \n    P.z = sqrt(1.-l*l);\n    P.xy *= r; P.yz *= r;                                  // rotations\n    //if (P.z<0.) P.x = -P.x;   \n    vec2 U = vec2(  sign(P.z)*acos(clamp(P.x/sqrt(1.-P.y*P.y),-1.,1.) ), // polar coords\n                   asin(P.y) ),\n         V,\n         d = vec2( fwidth2(U.x) , fwidth2(U.y) ),\n         z = LOD(d) ,                                      // LOD \n         f = .5 + log2(abs(.5/d)) - log2(z),               // fractional part\n         p = fwidth(U) * z*n;\n         U *= z*n;\n    V = abs(sin(U)/(cos(U)*p));                            // lines\n    f = max(1.5*f-.5 ,0.);                                 // shorter transition\n    int i = 0*int(2.*u.x/R.x);                             // screen side chooser\n    O = l > 1. \n          ? vec4(.5)                                       // background\n          : vec4( abs(sin(U/2.))[i] < .5 \n                    ? V[i]                                 // plain line\n                    : mix( 1., V[i], f[i] ));              // transition lines\n       // : vec4( abs(cos(U)/(sin(U)*p))[i] , f[i],0,0);    \n\n    O = sqrt(O);                                           // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 520, 520, 1876]]}
{"id": "NtXyzM", "name": "adaptive polar lines", "author": "FabriceNeyret2", "description": "draw a ~screenspace-constant density of lines \nleft: meridians   right: parallels", "tags": ["raytracing", "intersection", "isolines", "hatching", "balanced"], "likes": 13, "viewed": 281, "published": 3, "date": "1647621165", "time_retrieved": "2024-07-30T16:58:01.295286", "image_code": "// variant of https://shadertoy.com/view/NlfcRM\n\n#define fwidth2(v) length(vec2(dFdx(v),dFdy(v)))\n#define r          mat2(cos(.3*iTime+vec4(0,-1,1,0)*1.5708)) // rotation\n#define LOD(v)   ( n* exp2( round(log2(abs(.5/(v)/n)))) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( 2.*u - R.xy, 0) / R.y;                // P on sphere surface (or background)\n    float l = length(P), n=30.;     \n    P.z = sqrt(1.-l*l);\n    P.xy *= r; P.yz *= r;                                // rotations\n    \n    vec2 U = vec2( acos(P.x/sqrt(1.-P.y*P.y)) ,          // polar coords\n                   asin(P.y) ),\n\n         z = LOD( vec2( fwidth2(U.x) , fwidth2(U.y) ) ), // LOD\n         p = fwidth(U) * z;\n         U *= z;\n    n = 2.*u.x/R.x; int i = int(n);                      // side chooser\n    O = l > 1. || abs(n-1.)<.01\n          ? vec4(.5)                                     // background\n          : vec4( abs(cos(U)/(sin(U)*p))[i] );           // lines\n\n    O = sqrt(O);                                         // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 268, 268, 1054]]}
{"id": "NlfcRM", "name": "short sphere", "author": "FabriceNeyret2", "description": ".", "tags": ["raytracing", "intersection", "2tweets", "short"], "likes": 17, "viewed": 350, "published": 3, "date": "1647619067", "time_retrieved": "2024-07-30T16:58:02.268683", "image_code": "/**/\n\n#define r  mat2(cos(.3*iTime+vec4(0,-1,1,0)*1.5708)) // rotation\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         P = vec3( u+u - R.xy, 0) / R.y; // P on sphere surface (or background)\n    float l = dot(P,P), b;     \n    P.z = sqrt(1.-l);\n    P.xy *= r; P.yz *= r;                // rotations\n    \n    b = asin(P.y);                       // polar coords\n    O = l > 1. ? vec4(.5) : vec4( .5+.5*cos(50.*vec2(acos(P.x/cos(b)),b)) , 0, 0);\n                                      //   cheaper: acos(P.x/sqrt(1.-P.y*P.y))\n}\n\n\n\n\n\n\n\n\n/** // golfed down to 212 chars / 257 by Xor, Coyote , Greg, Fabrice\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u += u - (O.xy=iResolution.xy);\n    mat2 r = mat2( cos(.3*iTime + vec4(0,11,33,0)));\n        O = .5+ ( ( O.z = sqrt(1. - dot(u/=O.y, u )) )  < 1.\n                ? O.xy = u*r, O.yz *= r,.5*cos( 50.*atan( O, vec4(O.z,length(O.xz),0,0) ) )\n                : O-O );\n}\n\n/* // 218 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{    \n    u += u - (O.xy=iResolution.xy);\n    O.z = sqrt(O.w=1.-dot(u/= O.y,u));\n    \n    mat2 r = mat2( cos(.3*iTime + vec4(0,11,33,0)) );\n    O.xy = u* r; O.yz *= r;\n\n    O = .5+(O.w>0.?.5*cos(50.*atan(O, vec4(O.z,length(O.xz),0,0))) : O-O);\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 110, 110, 550]]}
{"id": "stsczN", "name": "tunnel hexagon", "author": "jorge2017a2", "description": "tunnel hexagon", "tags": ["tunnelhexagon"], "likes": 14, "viewed": 320, "published": 3, "date": "1647613581", "time_retrieved": "2024-07-30T16:58:03.131377", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n///Referencia\n//iq libreria\n//https://www.shadertoy.com/view/fdtGDH...Created by TheTurk in 2021-08-23\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 HexResp00(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    float d1= hexResp(p.xy*0.125);\n    p.y-=5.0;\n    float d2a= sdBox( p, vec3(13.0,20.0,0.7) );\n    float d2b= sdBox( p, vec3(14.0,21.0,0.6) );\n    \n    p.z-=13.0;\n    float d3a= sdBox( p, vec3(13.0,20.0,0.7) );\n    float d3b= sdBox( p, vec3(14.0,21.0,0.6) );\n    \n    float inter1= intersectSDF(d1, d2a);\n    float inter2= intersectSDF(d1, d3a);\n    \n    float dif1= differenceSDF(inter1, d2b);\n    float dif2= intersectSDF(inter2, d3b);\n    res =opU2(res, vec2(dif1,0.0));\n    res =opU2(res, vec2(dif2,1.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    p.y=p.y-13.0;\n    p.z= opRep1D(p.z, 20.0 );\n    float d1a= sdHexPrism( p, vec2(11.0,10.0) );\n    float d1b= sdHexPrism( p, vec2(10.0,10.5) );\n    float dif1= differenceSDF(d1a, d1b);\n    p.z-=14.0;\n    float d2a= sdHexPrism( p, vec2(11.0,7.0) );\n    float d2b= sdHexPrism( p, vec2(10.0,7.5) );\n    float dif2= differenceSDF(d2a, d2b);\n    \n    p=p0;\n    p.z= opRep1D(p.z, 40.0 );\n    vec2 h1= HexResp00(p);\n    res =opU2(res, vec2(dif1,1.0));\n    res =opU2(res, vec2(dif2,2.0));\n    res =opU2(res, h1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    \n    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    float occ = occlusion(hit, norm);\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color)); return colobj; }\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   ///mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,1000.0);\n \tlight_pos1= vec3(10.0, 100.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(-1.5,9.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n\n///-----------\n//https://www.shadertoy.com/view/fdtGDH...Created by TheTurk in 2021-08-23\nfloat hexagon(vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5);\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1.0 - max(position.x + position.y * 1.5, position.x * 2.0)) * sqrt(3.0) * 0.5;\n}\n\nfloat hexResp( in vec2 fragCoord) \n{   vec2 position = fragCoord ;\n    float spacing = 0.02;\n    float scale =  0.25;\n    float d = hexagon(position / scale) * scale - spacing;\n    return d;    \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 635, 635, 719], [720, 720, 767, 767, 794], [795, 795, 838, 838, 865], [866, 866, 914, 914, 942], [944, 944, 980, 980, 1025], [1028, 1028, 1062, 1062, 1158], [1159, 1159, 1193, 1193, 1284], [1285, 1285, 1319, 1319, 1410], [1412, 1412, 1448, 1448, 1721], [1723, 1723, 1747, 1747, 2309], [2311, 2311, 2336, 2336, 2903], [2905, 2905, 2929, 2929, 3091], [3093, 3093, 3141, 3141, 3478], [3481, 3481, 3525, 3525, 3851], [3853, 3853, 3890, 3890, 4151], [4153, 4153, 4238, 4238, 5155], [5158, 5158, 5251, 5251, 5381], [5383, 5383, 5415, 5415, 5612], [5614, 5614, 5682, 5682, 5778], [5781, 5781, 5808, 5808, 5897], [5899, 5899, 5957, 5957, 6005], [6008, 6008, 6031, 6031, 6149], [6151, 6151, 6182, 6182, 6803], [6806, 6806, 6863, 6863, 7313]]}
{"id": "Ns2fzG", "name": "Fractal Cube Steps", "author": "Shane", "description": "The classic hexagon fractal cube grid, rendered in 3D form.", "tags": ["fractal", "raymarch", "cube", "wall", "box", "step"], "likes": 66, "viewed": 1084, "published": 3, "date": "1647613124", "time_retrieved": "2024-07-30T16:58:04.140678", "image_code": "/*\n\n\tFractal Cube Steps\n\t------------------\n\n\tI'm sure everyone's seen the hexagon cube examples, and probably coded\n    one before. It's a great 2D effect. The fractal cube example is a simple \n    extension on that. The 3D version is less common, but for anyone curious\n    as to what that would look like, here it is. There are so many ways to \n    code one of these, and I've coded them all at one time or another, but \n    this is my preferred method.\n    \n    The first iteration comprises two lines of repeat cubes rotated about\n    the X-axis by a ceratin amount and then rotated about the Y axis by \n    another. Determining the correct rotations can be annoying, but\n    luckily for me, a younger version of myself got out a pen and paper and\n    figured them out years ago, so I only had to copy them. :)\n    \n    The top layers consist of single offset-row repeat grids containing\n    smaller cubes offset and rotated at the same fixed amounts as the first \n    layer... The code in the \"map\" function should make it clearer.\n    \n    Anyway, there's not a lot to this, but it might be interesting for \n    anyone who's ever wanted to make one of these.\n    \n    \n   \n    Other examples:\n\n\t// You can't have a cube example without referencing this. It's all\n    // over the internet these days. :)\n    Cubes and Spheres - Paulo Falcao\n\thttps://www.shadertoy.com/view/MsX3zr\n\n    // Another isometric style rendering. \n    Cubes are dancing - Flopine\n    https://www.shadertoy.com/view/tttBRX\n    \n    // A 3D cube wall rendered with 2D techniques. Very cool.\n    Cyberspace data warehouse - bitless\n    https://www.shadertoy.com/view/NlK3Wt\n\n*/\n\n#define ZERO min(0, iFrame)\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Global block scale. Something that is obvious to me now is that rotated\n// cubes fill in cells that have dimensional rations consisting of the diagonal \n// face length along the X direction the the longest diagonal along the Y direction.\n// That ratio turns out to be sqrt(3)/2. Common sense, and obvious... once I'd\n// spent ages trying to fit a square peg into a round hole. :)\n//\n// The divisor, \"4\", is variable global scaling.\n#define GSCALE vec2(1., .8660254)/4. \n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D tex, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(tex, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n}\n\n/*\n// This is a trimmed down version of one of Gaz's clever routines. I find it a \n// lot cleaner than those functions full of a million trigonometric variables.\nvec3 rot3(in vec3 p, vec3 a, float t){\n\ta = normalize(a);\n\tvec3 q = cross(a, p), u = cross(q, a);\n    return mat3(u, q, a)*vec3(cos(t), sin(t), dot(p, a));\n}\n*/\n\n// Hacked in at the last minute to differentiate between the block and\n// the metallic trimmings.\nfloat blockPartID;\n\n\nvec3 gCoord;\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    p.z = abs(p.z + 1.) - 1.;\n    \n    // Wall behind the pylons to stop the light getting through, if we decide\n    // to contract the boxes.\n    float wall = -p.z + .16;\n    \n\n    // Scaling: This can be confusing, since the scene looks like it's rendering on \n    // a 3D grid, but it's a 2D grid of rotated boxes all aligned on a flat plane.\n    // The \"vec2(1, 2)\" scaling figure accounts for the fact that two overlapping\n    // rows of boxes are rendering -- in a similar way that we render a 2D hexagon grid.\n    vec2 s = GSCALE*vec2(1, 2);\n    \n    // Box, box smoothing factor, and the gap between boxes.\n    float bx = 1e5, sf = .001, gap = .003;\n    \n    \n    // The rotated cubes on the diagonal cover a larger area relating to \n    // the diagonal distance. After getting things wrong for way too long,\n    // I now know this. :)\n    float sc0 = s.x*sqrt(2.)/2.;\n    \n    \n    // The fist layer contains cubes that encroach on neighboring boundaries,\n    // so two overlapping grids are necessary... Technically, you could get\n    // away with one, but artifacts can arise.\n    for(int i = ZERO; i<2; i++){\n        \n        // Global coordinates.\n        vec3 q = p;\n        \n        vec2 cntr = i==0? vec2(.5) : vec2(0); // Offset position for each row.\n        vec2 ip = floor(q.xy/s - cntr) + cntr + .5; // Local tile ID.\n        q.xy -= (ip)*s; // New local position.\n\n        // I can't for the life of me remember how I came up with the first \n        // rotation, but I'm guessing the side-on cube step view would involve\n        // a 1-1-sqrt(2) triangle, and the angle would arise from that.\n        q.yz *= rot2(.61547518786); // atan(1., sqrt(2.)).\n        // A quater PI rotation around the Y axis is much easier to visualize.\n        q.xz *= rot2(3.14159/4.); \n        \n        // Smooth rounded box distance field.\n        float bxi = sBoxS(q, vec3(sc0/2. - gap), sf);\n\n        // If we have the closest of the two boxes, update the distance\n        // field information.\n        if(bxi<bx){\n            bx = bxi;                   \n            gID.yz = (ip);\n            blockPartID = 0.;\n            gCoord = q;\n        }\n\n    }\n    \n    \n    // The second, third, etc, layers. Here, we're only doing two.\n    \n    // Scaling: Since the smaller boxes don't enchroach upon one another's \n    // boundaries, only one grid pre layer need be rendered.\n    vec2 s2 = GSCALE*2.;\n    // Box offset distance (relative to the larger box) and direction.\n    float offsD = 0., dir = 1.;\n    \n    // Render two layers.\n    for(int i = ZERO; i<2; i++){\n        \n        // Reducing size, scaling and offset for each succesive box layer.\n        sc0 /= 2.;\n        s2 /= 2.;\n        offsD += s.x/8./pow(2., float(i));\n\n        // Global coordinates, relatve to the large base layer box.\n        vec3 q = p - vec3(0, 1, -1)*offsD;\n        \n        // Offset each second row by half a cell.\n        vec2 cntr = vec2(0); \n        if(dir*mod(floor(q.y/s2.y), 2.)<dir*.5) cntr.x -= .5;\n        vec2 ip2 = floor(q.xy/s2 - cntr) + cntr + .5; // Local tile ID.\n        q.xy -= (ip2)*s2; // New local position.\n\n        // Randomly break from the loop at certain levels, thus omitting\n        // the rendering of all boxes that follow... Draw random boxes\n        // would be another way to put it. L)\n        if(hash21(ip2 + .03)<.2) break;\n        \n        // Rotating into the step position: Horizontal X-axis followed by\n        // vertical Y axis rotation.\n        q.yz *= rot2(.61547518786); // atan(1., sqrt(2.)).\n        q.xz *= rot2(3.14159/4.);\n\n        // Smooth rounded box distance field.\n        float bxi = sBoxS(q, vec3(sc0/2. - gap), sf);\n        \n       \n        // Updating the smoothing factor and direction for smaller boxes.\n        sf *= .7;\n        dir = -1.;\n\n        // If we have the closest of the two boxes, update the distance\n        // field information.\n        if(bxi<bx){\n           bx = bxi;\n           gID.yz = (ip2);\n           blockPartID = float(i + 1);//blPtID;\n           gCoord = q;\n        }\n    \n    }\n    \n    \n    \n    gID.x = bx;\n \n    // Overall object ID.\n    //objID = d4.x<wall || d4.x<bx? 0. : bx<wall? 1. : 2.;\n    objID = bx<wall? 0. : 1.;\n    //objID = 0.;\n    \n    // Combining the wall with the extruded blocks.\n    return min(bx, wall);//min(min(wall, d4.x), bx);\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... \n    //Not on my slow test machine, anyway.\n    const int iter = 32; \n    \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: \n        // dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2.5, occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .8;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat fBm(vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n*/\n\n// Face pattern.\nfloat fPat(vec2 p, float sc, vec2 gIP){\n\n    // Simple maze pattern consisting of random diagonal lines.\n    // Pretty standard.\n    \n    // Rotation and scaling.\n    p *= rot2(3.14159/4.);\n    sc *= 5.5*.7071;\n    p *= sc;\n    \n    // Grid partioning:\n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random cell flip.\n    float rnd = hash21(ip + gIP*.123 +.01);\n    if(rnd<.5) p.y = -p.y;\n    \n    // Render a diagonal line through the center, and\n    // at the edges.\n    vec2 ap = abs(p - .5);\n    float d = abs((ap.x + ap.y)*.7071 - .7071);\n    ap = abs(p);\n    d = min(d, abs((ap.x + ap.y)*.7071 - .7071));\n    d -= .125; // Line width.\n    \n    // Rescaling.\n    return d/sc;\n}\n\n// Face pattern.\nfloat fPat2(vec2 p, float sc){\n\n    // Scaling.\n    sc *= 11.;\n    p *= sc;\n    \n    // Partioning into a grid of squares.\n    p *= rot2(3.14159/2.); \n    p = fract(p + .5) - .5;\n\n    // Squares.\n    p = abs(p);\n    float d = -(max(p.x, p.y) - (.5 - .125/2.));\n    \n    // Rescaling.\n    return d/sc;\n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n    \n    map(p);\n    \n    vec3 txP = gCoord;\n    // The objects (cubes) have been rotated in the distance function,\n    // so the normal needs to match... If I had a dollar for every time\n    // I've forgotten that... :)\n    vec3 txN = n;\n    txN.yz *= rot2(.61547518786); // atan(1., sqrt(2.)).\n    txN.xz *= rot2(3.14159/4.); // 4.\n\n    vec2 uv = abs(txN.x)>.5? txP.zy : abs(txN.y)>.5? txP.xz : txP.xy;\n    //float faceID = abs(txN.x)>.5? 0. : abs(txN.y)>.5? 1. : 2.;\n    \n    \n    \n    vec2 scale = GSCALE;\n    float sc = scale.x/sqrt(2.)/2. -  .003;//*(blockPartID + 1.);\n    sc /= exp2(blockPartID); // Dividing smaller cubes by powers of 2.\n                \n    vec2 auv = abs(uv);\n    float fdf = abs(max(auv.x, auv.y) - sc) - .002;        \n    \n    //uv += blockPartID<2.? .25 : .0;\n    float pat2 = fPat2(uv/1.03 + .25, 2.);// + blockPartID*.5\n    \n    sc *= exp2(blockPartID);\n    pat2 = smoothstep(0., .0002/sc/1., pat2);\n\n    pat2 = mix(0., pat2, (1. - smoothstep(0., .0002/sc, fdf - .02 + .002 + .009)));\n    \n    return pat2;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    vec2 ra = vec2(1, iResolution.x/iResolution.y);\n    uv *= 1. + (dot(uv*ra, uv*ra)*.05 - .025);\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/6., 0, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.01*0., .01*0., .1);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(.25, .25, .7); //.25// Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n    \n   \n    \n    float alpha = 1.;\n    \n    for(int j = ZERO; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        float svObjID = objID;\n        vec4 svGID = gID;\n        float svBPID = blockPartID;\n        vec3 svCoord = gCoord;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            // Function based bump mapping for the edges.\n            sn = doBumpMap(sp, sn, .03);\n\n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            float sh = 1.;\n            if(j == 0) sh = softShadow(sp, lp, sn, 8.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            gSh = min(sh, gSh); // Adding a touch of light to the shadow.\n          \n            float att = 1./(1. + lDist*lDist*.05); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 32.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n           vec3 oCol;\n            \n             \n            if(svObjID == 0.) {\n            \n                // Cube face coloring.\n            \n                // Face scaling.\n                vec2 scale = GSCALE;\n                float sc = scale.x/sqrt(2.)/2. -  .003;\n                // Dividing smaller cubes by powers of 2.\n                float sc2 = sc/exp2(svBPID);\n                \n                // Local face texture coordinates.\n                vec3 txP = svCoord;\n                \n                // The objects (cubes) have been rotated in the distance function,\n                // so the normal needs to match... If I had a dollar for every time\n                // I've forgotten that... :)\n                vec3 txN = sn;\n                txN.yz *= rot2(.61547518786); // atan(1., sqrt(2.)).\n                txN.xz *= rot2(3.14159/4.); // 4.\n                \n                // Using the normal to obtain the UV coordinates for the cube face.\n                vec2 uv = abs(txN.x)>.5? txP.zy : abs(txN.y)>.5? txP.xz : txP.xy;\n                float faceID = abs(txN.x)>.5? 0. : abs(txN.y)>.5? 1. : 2.;\n\n         \n                // Block coloring.\n                vec3 tx = getTex(iChannel0, uv + hash21(svGID.yz));\n                tx = smoothstep(0., .5, tx);\n\n \n                // Edge coloring, but has been replaced by trimming.\n                // Needs to match the box function inside the distance field.\n                \n                 \n                // Random face value (blinking).\n                float rndF = hash21(svGID.yz + svBPID/6. + .08);\n                rndF = smoothstep(.92, .97, sin(6.2831*rndF + iTime)*.5 + .5);\n                // Blinking face light color.\n                vec3 blCol = mix(vec3(3.2, .7, .3), vec3(3.4, .4, .6), hash21(svGID.yz + .32));\n                blCol = mix(blCol, blCol.zyx, step(.5, hash21(svGID.yz + .21)));\n                //blCol = mix(blCol, blCol.zyx, floor(hash21(svGID.yz + .21)*2.999)/2.);\n                // Face glow color.\n                vec3 glCol = smoothstep(0., 1., 1. - length(uv)/sc2)*blCol*6.;\n        \n                float pat2 = fPat2(uv, 1./.125);\n                vec3 metCol = vec3(1.1, .9, 1.1);\n                oCol = tx/2.*metCol;\n\n                //if(svBPID <= 1.){\n                    // Applying spherical glow to the face.\n                    oCol = mix(oCol, glCol, rndF + .01); \n                    oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .0003/sc2, pat2))*.9);\n                // }\n               \n                // Face pattern.\n                float pat = fPat(uv, 1./.125, svGID.yz + faceID/6. + svBPID/6.);\n                \n                // Edge pattern.\n                pat2 = fPat2(uv/1.03 + .25, 2.);\n                \n                // Edge coloring.\n                vec3 eCol = mix(tx*.5 + .5, tx*.5 + .3 + blCol*.15, rndF)/3.;\n                // Edge pattern.\n                eCol = mix(eCol, vec3(0), (1. - smoothstep(0., .0002/sc, pat2))*.5);\n                // Fake bump... Needs work.\n                //eCol = mix(eCol, vec3(1), (1. - smoothstep(0., .0004/sc, pat2 - .001))*.35);\n                //eCol = mix(eCol, vec3(0), (1. - smoothstep(0., .0002/sc, pat2))*.9);\n                eCol *= metCol;\n\n                // Applying the maze pattern to the faces.\n                oCol = mix(oCol, oCol/8., (1. - smoothstep(0., .0002/sc, pat)));\n\n                // Applying the edge color.\n                vec2 auv = abs(uv);\n                float fdf = abs(max(auv.x, auv.y) - sc2) - .002;\n                oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .0002/sc, fdf - .02 + .002)));\n                oCol = mix(oCol, eCol, (1. - smoothstep(0., .0002/sc, fdf - .02 + .002 + .009)));\n\n                // Different reflectance on different parts of the surface.\n                //\n                // Reflectance of the glass (or perspex) face pattern.\n                float faceRef = mix(.25, .5, (1. - smoothstep(0., .0002/sc, pat)));\n                // Reflectance of the face and edge.\n                objRef = mix(faceRef, .1, (1. - smoothstep(0., .0002/sc, fdf - .02 + .002 + .009)));\n             \n       \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            \n            }\n \n \n            // The color for this layer.\n            colL = oCol*(dif*gSh + .1 + vec3(1, .8, .5)*spe*1.*gSh);\n        \n           \n            // Optional environmental mapping. Not used.\n            //vec3 envCol = envMap(reflect(rd, sn)).zyx;\n            //colL += colL*envCol*3.;\n            \n            colL *= ao*att;\n\n            // Used for refraction, but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        //float td = length(sp - cam); \n        //vec3 fogCol = vec3(0);\n        //colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        col += colL*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    //fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2fzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2467, 2500, 2522, 2522, 2580], [2582, 2610, 2631, 2631, 2694], [2696, 2943, 2978, 3355, 3446], [3451, 3479, 3526, 3526, 3621], [4155, 4178, 4196, 4293, 8627], [8630, 8651, 8681, 8730, 9222], [9225, 9416, 9468, 9592, 10911], [10914, 11066, 11101, 11101, 11489], [11492, 11592, 11619, 11962, 12234], [14593, 14610, 14649, 14772, 15337], [15339, 15356, 15386, 15403, 15658], [15661, 15688, 15727, 15727, 16770], [16775, 16966, 17021, 17122, 18374], [18376, 18376, 18432, 18465, 28713]]}
{"id": "ftsyRN", "name": "Chains of Lights", "author": "jarble", "description": "This fractal resembles a mesh of glowing lights.", "tags": ["fractal"], "likes": 3, "viewed": 228, "published": 3, "date": "1647584012", "time_retrieved": "2024-07-30T16:58:05.117067", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*4.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += 1.+(t2.yx);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2-t3)/(2.-float((k+i)%2));\n            uv += float(i%3);\n        }\n        col.x = -max(((uv.y-uv.x)+col.x),-col.x);\n        col = -abs(col.yzx/(1.-uv.x*2.125+sin((iTime+(uv.x+uv.y)*float(i))*16.)/8.)-vec3(col.x));\n    }\n    fragColor = vec4(-vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 948]]}
{"id": "slXcR4", "name": "Mandelmapped spiral", "author": "mrange", "description": "Quick thursday hack\nCombination of spirals and mandelbrot domain mapping\n", "tags": ["2d", "mandelbrot", "spiral"], "likes": 12, "viewed": 338, "published": 3, "date": "1647552321", "time_retrieved": "2024-07-30T16:58:06.011676", "image_code": "// CC0: Quick thursday hack\n//  Combination of spirals and mandelbrot domain mapping\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x)+PI);\n}\n\nvec2 spiralEffect(vec2 p, float a, float n) {\n  vec2 op = p;\n  float b = a/TAU;\n  vec2 pp   = toPolar(op);\n  float  aa = pp.y;\n  pp        -= vec2(pp.y*n*b, (pp.x/b+PI)/n);\n  vec2  nn  = mod2(pp, vec2(a, TAU/n));\n  // Yes, this is a trial and error:ed until it looked good \n  // because I couldn't be bothered to compute the real solution\n  float xf  = tanh_approx(20.0*length(p)/abs(n));\n  return vec2(abs(pp.x)*xf, mod(nn.y, n));\n}\n\nfloat julia_map(inout vec2 p, vec2 c) {\n  float s = 1.0;\n  // Mandelbrot\n  p.x -= 0.5;\n  c = p;\n  const int JULIA_ITERATIONS = 24;\n  for (int i = 0; i < JULIA_ITERATIONS; ++i) {\n    // Turns out this is the classic julia loop after all. \n    // Oh well :)\n    vec2 p2 = p*p;\n    p = vec2(p2.x-p2.y, 2.0*p.x*p.y);\n    p += c;\n    s *= 1.9; // Mindless fine tuning at its best\n    s *= sqrt(p2.x+p2.y);\n  }\n  \n  return 1.0/s;\n}\n\nvec3 df(vec2 p) {\n  vec2 c0 = vec2(-0.7440, .0148);\n  vec2 c1 = 0.85*vec2(-0.45, 0.75);\n  vec2 c = mix(c0, c1, smoothstep(-1.0, 1.0, sin(0.5*TIME)));\n  float js = julia_map(p, c);\n  \n  float cd = -(length(p) - 2.0)*js;\n\n  const float z = 0.25;\n  p /= z;\n  \n  float a = 0.5;\n  float sp0 = 11.0;\n  float sp1 = -3.0;\n  vec2 se0 = spiralEffect(p*ROT(-0.123*TIME), a, sp0);\n  vec2 se1 = spiralEffect(p*ROT(.1*TIME), a, sp1);\n  \n  vec2 se = vec2(pmin(se0.x, se1.x, 0.125), se0.y+se1.y);\n  \n  float h = se.y*0.05+TIME*0.2;\n  float d = -((se.x)-0.05);\n  d *= z*js;\n\n  return vec3(d, cd, h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q  = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  vec3 d3 = df(p);\n  float d = d3.x;\n  float cd= d3.y;\n  float h = d3.z;\n  float s = smoothstep(aa, -aa, d);\n  vec3 col = vec3(0.0);\n  \n  col = hsv2rgb(vec3(fract(h), 0.95, s));\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, cd));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[325, 416, 438, 438, 584], [586, 686, 707, 707, 780], [781, 881, 903, 903, 952], [954, 1037, 1076, 1076, 1161], [1163, 1249, 1285, 1285, 1379], [1381, 1441, 1469, 1535, 1611], [1613, 1613, 1635, 1635, 1682], [1684, 1684, 1729, 1729, 2117], [2119, 2119, 2158, 2158, 2544], [2546, 2546, 2563, 2563, 3130], [3132, 3132, 3187, 3187, 3605]]}
{"id": "stsczH", "name": "picture in picture -basic", "author": "jorge2017a2", "description": "picture in picture -basic", "tags": ["pictureinpicturebasic"], "likes": 5, "viewed": 214, "published": 3, "date": "1647530262", "time_retrieved": "2024-07-30T16:58:07.011004", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n///------------------------------------\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    p.y=p.y-5.0;\n    float sds1=sdSphere(p-vec3(0.0,abs(5.0*sin(iTime)),0.0) , 5.0 );\n    res =opU2(res, vec2(sds1,2.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n\n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n\n}\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{ vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{   vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    // shadows\n    float shadow = getSoftShadow(hit + norm * 0.02, normalize(lightPos));\n    // occ\n    float occ = occlusion(hit, norm);\n    vec3 ambient = 0.05 * color;\n    vec3 fresnel = 0.15 * color * pow(1.0 + dot(rd, norm), 3.0);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   \n    return colOut;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57)\n        {return pattern( p.xz );}\n    if (id_color==58)\n        {return pattern( p.xy );}\n    if (id_color==59)\n        {return pattern( p.zy );}\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n    bool pip=true;\n    \n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   //ro= getMouse(ro);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    \n    //picture and picture\n    if (uv.x < 1.0/64.0 && uv.y < 1.0/64.0 )\n    {\n        //uv-=vec2(-0.5,-0.25);\n        float t=iTime;\n        ro+=vec3(0.0+5.0*sin(t),0.0,0.0);\n        uv-=vec2(-0.5+0.25*sin(t),-0.25);\n        uv*= 2.0;\n        rd=normalize( vec3(uv.x,uv.y,1.0));\n    }    \n   \n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "float itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 535, 535, 556], [557, 601, 648, 648, 675], [676, 676, 719, 719, 746], [747, 747, 795, 795, 823], [825, 865, 890, 890, 1160], [1162, 1162, 1186, 1186, 1348], [1350, 1350, 1398, 1398, 1727], [1729, 1800, 1836, 1836, 2039], [2040, 2111, 2135, 2135, 2384], [2387, 2387, 2431, 2431, 2757], [2759, 2759, 2796, 2796, 3057], [3059, 3059, 3144, 3144, 4082], [4084, 4084, 4177, 4177, 4307], [4309, 4309, 4341, 4341, 4538], [4540, 4588, 4616, 4616, 4804], [4807, 4807, 4875, 4875, 5140], [5143, 5143, 5170, 5170, 5259], [5261, 5261, 5319, 5319, 5367], [5370, 5370, 5393, 5393, 5511], [5513, 5513, 5544, 5544, 6165], [6167, 6167, 6224, 6224, 6984]]}
{"id": "7tlyzH", "name": "Soccer Mini", "author": "4eckme", "description": "It's mini game.", "tags": ["game", "loop", "football", "soccer"], "likes": 7, "viewed": 2061, "published": 3, "date": "1647529158", "time_retrieved": "2024-07-30T16:58:07.911596", "image_code": "//CLICK MOUSE AND MOVE\n\n\n#define W 5\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define m(v2,deg) mod((v2)*rot(radians(deg)),60.0)-30.0\n#define hex() o1=m(o,0.);o2=m(o,60.);o3=m(o,120.);rgba+=clamp(vec4(abs(o1.y)+abs(o2.y)+abs(o3.y)-54.),0.1,1.0);\n\nvoid mainImage(out vec4 rgba,in vec2 o){\n    rgba=vec4(0.33,1.0,0.5,1);\n    vec2 R=iResolution.xy,iM=((length(iMouse.z)>=1.0)?vec2(iMouse.x,iMouse.y)*1.0:R/2.0)*min(R.x,R.y)/360.0;\n    o-=R/2.;vec2 a=o,M=o,field=o;o/=min(R.x,R.y)/360.0;;field/=min(R.x,R.y)/360.0;\n    vec2 o1,o2,o3;float iT=iTime;\n    o-=(-iM/min(R.x,R.y)*360.0+R/2.0)/min(R.x,R.y)*360.0*(vec2(sign(cos(iT/3.14))*cos(iT/3.14)*cos(iT/3.14),sin(iT/1.57)));\n    o/=(abs(cos(radians(iTime*180.0)))+0.5)/1.5;\n    float scale=7.0,x=o.x/scale,y=o.y/scale,\n    z=sqrt(x*x+y*y)/scale;o/=cos(z);\n    //field\n    ivec4 f=ivec4(int(abs(field.x))/W,int(abs(field.y))/W,int((abs(field.x)-0.499)/float(W)*2.0),int(length(field)/float(W)));\n    if(((f.x-10*W)*(f.y-5*W)==0||f.x>=8*W&&f.y==2*W||f.x==8*W&&f.y<=2*W||(f.z)==0)&&(f.y<=5*W&&f.x<=10*W)||f.w==2*W)\n      rgba=vec4(2.0,2.2,2.0,1);\n    if(z<1.0){//ball\n      rgba=vec4(0,0,0,1);\n      o+=vec2(cos(iTime/1.0)*90.0,-sin(iTime/1.0)*90.0);hex();o.y+=40.;hex();\n      rgba*=(pow(1.0-cos(z),2.0)+3./4.0);\n      if(rgba.x<=0.5)rgba*=pow(cos(z),-2.0)/2.0;\n    }else{//grass\n      rgba*=(cos(length(mod(a,R/10.5))*length(mod(a,R/10.5))*5.0)+2.0)/3.0;\n      if(-length(M+R/2.-iM/min(R.x,R.y)*360.0)>=-16.*min(R.x,R.y)/360.0){//Player\n       rgba=clamp(rgba,0.0,1.0)*0.5;\n      }if(z<2.){//shadow\n       rgba=clamp(rgba,0.0,1.0)+clamp((z-1.1)/((abs(cos(radians(iTime*180.0)))+0.5)/1.5),-1.0,0.0);\n}   } }", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n    float t = time*3.1415;\n    return vec2(sin(2.0*t*float((cos(t))<0.05)));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 296, 296, 1658]]}
{"id": "sllcRH", "name": "Fork Ink Blot S elvi5tim 212", "author": "elvi5tim", "description": "ink logic stolen from https://www.shadertoy.com/view/4tsSRS", "tags": ["noise", "transition", "paint", "ink", "fill", "splatter", "blot"], "likes": 6, "viewed": 484, "published": 3, "date": "1647528238", "time_retrieved": "2024-07-30T16:58:14.420194", "image_code": "#define SPEED 10.0\n#define MAX_DIST 1.0\n#define CELLS 10.0\n\n\nfloat sqrLen(vec2 vec)\n{\n\treturn vec.x * vec.x + vec.y * vec.y  ;  \n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//noise from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat mapToRange(float fromMin, float fromMax, float toMin, float toMax, float val)\n{\n    val = max(fromMin, (min(fromMax, val)));//clamp in range if outside\n    float fromSize = fromMax - fromMin;\n    val = (val - fromMin) / fromSize;\n    return mix(toMin, toMax, val);\n}\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nfloat opUnion(float d1, float d2)\n{\n \treturn min(d1, d2);  \n}\n\nfloat opMinus(float d1, float d2)\n{\n \treturn max(-d1, d2);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n \treturn max(d1, d2);\n}\n\nfloat circle(vec2 diff, float radius)\n{\n    return length(diff) - radius;\n}\n\nfloat line(vec2 diff, vec2 dir, float thickness)\n{\n    vec2 proj = dot(diff, dir) * dir;\n    vec2 perp = diff - proj;\n    return length(perp) - thickness;\n}\n\nfloat signedDist2D(vec2 pos)\n{\n\tfloat dist = MAX_DIST;\n    for (int i = 0; i < int(CELLS); ++i)\n    {\n        \n        dist = opUnion(dist, circle(random2(vec2(i)), 1.0 / (CELLS * 2.0)));\n    }\n\n    return dist;\n}\n\nfloat FX0(float val, float noise)\n{    \n    noise \t\t= pow(noise, 6.0);\n    float time \t= iTime * 2.0 + 0.1;\n    float str \t= max(0.0, (val * time));\n    float str2 \t= pow(str, 10.0) ;\n    str \t\t= str2 * noise;\n    \n    return str;\n}\n\nfloat FX1(float val, float noise, float expansion, float time)\n{\n    \n    noise \t\t= pow(noise, 6.0);\n    \n    val \t\t= val * expansion * 0.5;\n    float str \t= (1.0 + val * time);\n    float str2 \t= pow(str, 20.0) ;\n    str \t\t= mapToRange(0.3, 1.0, 0.0, 1.0, str2 * noise) ;  \n    \n    return str;\n}\n\nfloat FX2(float val, float noise, float expansion, float time)\n{    \n    noise \t\t= pow(noise, 6.0);\n    \n    val \t\t= val * (expansion);\n    float str \t= (1.0 + val * time) * (expansion);\n    float str2 \t= pow(str, 20.0) ;\n    str \t\t= str2 * noise;\n    str \t\t= mapToRange(0.2, 1.0, 0.0, 1.0, str);\n    \n    return str;\n}\n\nfloat FX3(float val, float noise, float expansion, float time)\n{    \n    val = clamp(val, 0.0, 1.0);\n    float str \t= mapToRange(0.3, 1.0, 0.0, 1.0, FX2(val, noise, expansion, time)) * expansion;\n    float ins \t= FX2(val * pow(expansion - 0.5, 1.0), noise, expansion, time) * expansion;\n    ins \t\t= mapToRange(0.0, 20.0, 0.0, 1.0, ins);\n    str \t\t+= ins;\n    \n    return str;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time \t= mod(iTime, 5.0) * 5.0;\n    vec2 fragPos \t\t= pixelToNormalizedspace(fragCoord.xy);\n\tvec3 pos \t\t= vec3(fragPos, time * 0.00001 * SPEED);\n    \n    //noise sampling\n    vec3 scaledPos \t= 8.0 * pos;\n    float noiseVal \t= 0.0;\n    float ampl \t\t= 1.0;\n    float maxValue \t= 0.0;\n    \n    for(float i = 0.0; i < 8.0; ++i)\n    {\n        noiseVal \t+= noise(scaledPos) * ampl;\n        scaledPos \t*= 2.0;\n        maxValue \t+= ampl;\n        ampl \t\t*= 0.5;\n    }\n    noiseVal /= maxValue;\n    vec2 startPoint = vec2(0.0, 0.0);\n\n    float expansion = sqrLen(fragPos - startPoint);\n    expansion \t\t= 1.0 - expansion;\n    expansion \t\t+= time * time * SPEED  * 0.0005 - 0.6;    \n    expansion \t\t= min(expansion, MAX_DIST);\n    \n\n    float res = FX3(-signedDist2D(fragPos), noiseVal, expansion, time);\n\n    res = clamp(res, 0.0, 1.0);\n    \n    fragColor = vec4(texture(iChannel1, fragCoord / iResolution.xy).rgb *vec3(1.0 - res), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 85, 85, 130], [132, 132, 156, 156, 249], [251, 267, 293, 293, 503], [505, 505, 590, 590, 777], [779, 779, 820, 820, 1016], [1018, 1018, 1053, 1053, 1079], [1081, 1081, 1116, 1116, 1141], [1143, 1143, 1182, 1182, 1206], [1208, 1208, 1247, 1247, 1283], [1285, 1285, 1335, 1335, 1441], [1443, 1443, 1473, 1473, 1656], [1658, 1658, 1693, 1693, 1890], [1892, 1892, 1956, 1956, 2188], [2190, 2190, 2254, 2254, 2509], [2511, 2511, 2575, 2575, 2888], [2892, 2892, 2949, 2949, 3886]]}
{"id": "7tlcz8", "name": "Spiral Thing 519340341", "author": "SnoopethDuckDuck", "description": "Wanted to make this: https://en.wikipedia.org/wiki/Pentagonal_tiling#/media/File:Binary_tiling_straight.svg\n\n...but got a bit distracted", "tags": ["e"], "likes": 16, "viewed": 405, "published": 3, "date": "1647524308", "time_retrieved": "2024-07-30T16:58:15.574109", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    uv = vec2(3.5 * atan(uv.x,uv.y), length(uv));\n    uv.y = pow(uv.y+0.5, 0.125);\n    uv.y *= 50.;\n    uv.y += -iTime - 12.5 * uv.x / uv.y;\n    \n    \n    vec2 ipos = floor(uv) + 0.;\n    vec2 fpos = fract(uv) - 0.5;\n    \n    float n = 11.;\n    float s = mod(0.25 * n * iTime + (n-3.) * ipos.x + (n-1.) * ipos.y, n) / n;\n    \n    vec3 col = vec3(s);\n    col *= 0.92 + 0.08 * h21(floor(10. * uv));\n    col *= pal(0.125 * n, col, col, col, 0.6 * vec3(0,1,2)/3.);\n    col = sqrt(col + 0.02);\n    float k = 8. / iResolution.y;\n    col *= smoothstep(-k, k, -mlength(fpos) + 0.47);\n    \n    col *= 1.-exp(-10. * length(ouv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlcz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 814]]}
{"id": "slfcRr", "name": "texture-simple-example", "author": "sashikus", "description": "Базовый пример отображения текстуры", "tags": ["example", "simple", "texture"], "likes": 0, "viewed": 189, "published": 3, "date": "1647516513", "time_retrieved": "2024-07-30T16:58:16.776893", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 144]]}
{"id": "slfczr", "name": "fragcoord-time-example", "author": "sashikus", "description": "Пример преобразования времени в координаты", "tags": ["fragcoord", "itime"], "likes": 0, "viewed": 188, "published": 3, "date": "1647516379", "time_retrieved": "2024-07-30T16:58:17.634599", "image_code": "// возвращает остаток от деления\nint imod(int n, int d)\n{\n  return n - d * (n / d) * int (n > d);\n}\n\n\n// генератор значения от 0.0 до 1.0 для заданного диапазона\n// времени заданного в секундах\nfloat gen_ftime(float range)\n{\n    int ms = int(iTime * 1000.0);\n    ms = imod(ms, int(range));\n    return float(ms) / range;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    float fms = gen_ftime(5000.0); // 0 .. 1.0\n    fragColor *= float(abs(uv.y - fms) < 0.01);      \n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 83, 83, 125], [128, 287, 317, 317, 414], [417, 417, 472, 472, 662]]}
{"id": "NldXWN", "name": "TeSsErAcT", "author": "z0rg", "description": "Tesseract", "tags": ["3d", "tesseract", "cubeception", "cucube"], "likes": 21, "viewed": 534, "published": 3, "date": "1647512873", "time_retrieved": "2024-07-30T16:58:18.493304", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        //if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb, vec3(1.5));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    //rgb *= 1.-sat(length(cuv*2.)-.5);\n    //rgb += vec3(.5)*(1.-sat((abs(cuv.x)-.115)*400.));\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat _time;\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(uv.x*r+-uv.y*u));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.);\n    for (int i = 0; i < 15; ++i)\n    {\n        float fi = float(i);\n        vec3 pl = p;\n        pl.xy *= r2d(sin(iTime*.5-fi*.1)*2.);   \n        //pl.xz *= r2d(fi+iTime*(1.+fi)*.1);\n        //p.xz *= r2d(float(i));\n        //p *= .8;\n        float cucube = _cucube(pl, 5.*vec3(.5, .1, .5)*(fi/15.), vec3(.0001));\n        acc = _min(acc, vec2(cucube, float(i)));\n    }\n    \n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x;\n    }\n    vec3(-1.);\n}\n\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d) - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 grad(float f)\n{\n    vec3 cols[4];\n    cols[0] = vec3(0.05);\n    cols[1] = vec3(0.859,0.039,0.286);\n    cols[2] = vec3(1.);\n    cols[3] = vec3(1.0);\n    \n    \n    f = pow(sat(sin(f*3.-iTime*1.5)*.5+.5), 2.)*3.0;\n    vec3 prev = cols[int(f)];\n    vec3 next = cols[int(min(f+1.,3.))];\n    return mix(prev, next, fract(f))*1.2;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float d = 11.;\n    vec3 ro = vec3(sin(_time*.25)*d,0.,cos(_time*.25)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 col = texture(iChannel2, rd*vec3(1.,1.,1.)).xxx*.1;\n    vec3 res = trace(ro, rd, 64);\n    if (res.y > 0.)\n    {\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNormal(res.x, p);\n        \n        col = n*.5+.5;\n        col = grad(res.z/15.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = iTime;// .15*iTime+texture(iChannel0, fragCoord/8.).x*iTimeDelta;\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    //col += sat(grad(1.-sat(length(uv*2.)))*2.)*(1.-sat(length(uv*4.)));\n    col = mix(col, texture(iChannel1, ouv).xyz, .5);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        //if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW .9\n#define GLOW_OPACITY 1.1\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXWN.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1177]]}
{"id": "ftXczH", "name": "Silver knots", "author": "jarble", "description": "A fractal with shiny knot patterns.", "tags": ["fractal", "knot"], "likes": 3, "viewed": 261, "published": 3, "date": "1647495103", "time_retrieved": "2024-07-30T16:58:19.389906", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += 1.+(t2.yx);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2-t3)/(scale);\n        }\n        col.x =\n            min(((uv.x-uv.y)-col.x),col.x)/sqrt(2.)\n            //min(uv.y+uv.x+col.x,col.x)/2.\n        ;\n        col = (col+vec3(col.x))/sqrt(2.);\n    }\n    fragColor = vec4(-vec3(col*2.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 918]]}
{"id": "stlyRr", "name": "The Other Great Chrome Donut", "author": "elenzil", "description": "Hopefully the shader survives the saving process this time.\nStarted off working on less-wrong shadows from glass, ended up here.\nSky, Hexagons, Donut SDF, and Hash() borrowed.", "tags": ["reflection", "sunset", "ball", "donut", "rolling", "cineshader"], "likes": 50, "viewed": 4343, "published": 3, "date": "1647468678", "time_retrieved": "2024-07-30T16:58:20.426136", "image_code": "#define RES     (iResolution)\n#define MINRES  (min(RES.x, RES.y))\n#define ZERO    (min(iFrame,0))\n\n\nconst float PI       = 3.14159265359;\nconst float gMaxTime = 3e3;   // numerical precision gets bad above this\n\nconst vec3 gV0  = vec3(0.0);\nconst vec3 gV1  = vec3(1.0);\nconst vec3 gV1n = normalize(gV1);\nconst vec3 gVx  = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy  = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz  = vec3(0.0, 0.0, 1.0);\n\nvec3 sky(vec3 dir);\n\n// general math\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat square(float a) { return a * a; }\nfloat selfDot(vec2 a) { return dot(a, a); }\nfloat selfDot(vec3 a) { return dot(a, a); }\n\n// author: Neil Mendoza   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\n//mat4 rotationMatrix(vec3 axis, float angle) {     axis = normalize(axis);     float s = sin(angle);     float c = cos(angle);     float oc = 1.0 - c;          return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,                0.0,                                0.0,                                0.0,                                1.0); \n\n\n// author: blackle mori   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\nreturn mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle);\n}\n\n// SDF manipulators\nfloat opU(float a, float b) {\n    return min(a, b);\n}\nfloat opS(float a, float b) {\n    return -min(-a, b);\n}\n\n// SDF primitives\n\nfloat sdPlaneY(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// author: sam hocevar, license: WTFPL, link: https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c) {   vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));     float d = q.x - min(q.w, q.y);     float e = 1.0e-10;     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }\nvec3 hsv2rgb(vec3 c) {   vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins. https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n//---------------------------------------------------------\nfloat Pow2(float x) { return x * x; }\n// PaniniProjection from TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = PI / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n\n\nvec3 getCamRayDir(vec3 camDir, vec2 uv, float zoom) {\n\n    vec3 camFw  = normalize(camDir);\n    vec3 camRt  = normalize(cross(camFw, gVy));\n    vec3 camUp  = cross(camRt, camFw);    \n    mat3 camMat = mat3(camRt, camUp, camFw);\n    \n    uv /= zoom;\n    \n    float paniniFOV = 0.35 * PI;\n    float paniniD   = 0.1;\n    vec3  rayDirCam = PaniniProjection(uv, paniniFOV, paniniD);\n    \n    return normalize(camMat * rayDirCam);\n}\n\n\n\n\n\n\n\n//-----------------------------------------------------------\n\n\n\n\n\n\nconst int   gMarchMaxSteps      = 150;\nconst float gMarchUnderStep     = 0.98;  // slight understepping to allow for convexity of floor tiles\nconst float gMarchHorizon       = 100.0;\nconst float gMarchHorizonSq     = gMarchHorizon * gMarchHorizon;\nconst float gMarchEps           = 0.001;\nconst float gNormEps            = gMarchEps;\n\n// for development: bigger pixels = clearer problems\nconst float gDownRes            = 1.0;\n\n\nconst uint  gMaximumRaysInQueue = 20u;\n\n// the maximum total number of calls to Map().\nconst float gMaxTotalMapIters   = float(gMarchMaxSteps) * 10.0;\n\n// the least significant ray which will be processed\nconst float gMinRayContribution = 0.001;\nconst float gMinRayContribSq    = gMinRayContribution * gMinRayContribution;\n\n\n\nfloat gSSZoom;\nfloat gSSEps;\nfloat gT;\nfloat gTotalMapIters = 0.0;\n\n// distance from camera to center of scene\nfloat gCamDist     = 20.0;\nvec3  gSceneCenter = gVy * 3.0;\nvec3  gLightDir;\nvec2  gTorusDims;\nvec3  gTorusPos;\nfloat gBallRad;\nfloat gBallOrbit;\nvec3  gBallPos;\nfloat gBallTime;\nfloat gBallInset;\nfloat gBallCycle;\nfloat gBallCycleHash;\nfloat gHexTileFac = 0.67;\n\n\nvec2 gMouse;    // 0 to RES\nvec2 gSSMouse;  // 0 to 1\n\nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    bool internal;\n    bool shadow;\n    vec3 contribution;\n};\n\nstruct marchResult_t {\n    float t;\n    uint  m;\n};\n\n\n// \"diffuse\"  includes regular diffuse plus ambient\n// \"specular\" includes reflection and transmission\nstruct material_t {\n    vec3 c1;\n    vec3 c2;\n    \n    // 0 = all diffuse, 1 = all specular\n    float diffuseVsSpecular1;\n    float diffuseVsSpecular2;\n    \n    // 0 = all reflection, 1 = all transmission\n    // scoped to 'specular'\n    float reflectionVsTransmission;\n    \n    // Lambert's linear attenuation coefficient\n    float attenuationCoefficient;    \n};\n\nconst uint kMSky   = 0u;\nconst uint kMFloor = 1u;\nconst uint kMTorus = 2u;\nconst uint kMBall  = 3u;\n\n\n// scoped to 'diffuse'.\nvec3 gAmbientLight;\nvec3 gDirectionalLight;\n\n\nmaterial_t[] kMaterials = material_t[] (\n    // sky\n    material_t (\n        1.0 * vec3(0.1, 0.2, 1.0),\n        1.0 * vec3(0.3, 0.05, 0.1),\n        0.0, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // floor\n    material_t (\n        gV1 * 0.1,\n        vec3(0.5, 0.8, 0.1) * 0.3,\n        0.2, 0.7,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // torus\n    material_t (\n        gV1 * 0.2,\n        gV0,\n        0.8, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // ball\n    material_t (\n        gV1,\n        gV0,\n        0.2, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    )\n);\n\nvoid configMaterials() {\n    float ambientLightAmt = 0.04;\n    float directionalLightAmt = 1.0 - ambientLightAmt;\n    \n    gAmbientLight     = ambientLightAmt * sky(gV1n);\n    gDirectionalLight = clamp(directionalLightAmt * sky(-gLightDir) * 3.0, 0.0, 1.0);\n\n    if (gBallCycleHash != 0.0) {\n        kMaterials[kMBall].diffuseVsSpecular1 = gBallCycleHash * gBallCycleHash;\n    }\n}\n\n\n// queue of ray_t's. ------------------------------\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u; QTYPE gQ[gQNumSlots]; uint gQHead = 0u; uint gQTail = 0u;\nuint QCount    ()           { if (gQHead >= gQTail) {return gQHead - gQTail;} else { return gQNumSlots - (gQTail - gQHead); } }\nuint QSpaceLeft()           { return gQCapacity - QCount(); }\nbool QIsFull   ()           { return QSpaceLeft() == 0u;}\nbool QIsEmpty  ()           { return QCount() == 0u; }\nvoid QEnqueue  (QTYPE item) { gQHead = (gQHead + 1u) % gQNumSlots; gQ[gQHead] = item; }\nQTYPE QDequeue ()           { gQTail = (gQTail + 1u) % gQNumSlots; return gQ[gQTail]; }\n//-------------------------------------------------\n\nfloat stretchRange(float t, vec2 gap, float fac) {\n    float range = gap[1] - gap[0];\n    float f     = (t - gap[0]) / range;\n\n    if (f < 0.0) {\n        return t;\n    }\n    else if (f > 1.0) {\n        return t + range * (fac - 1.0);\n    }\n    else {\n        return mix(gap[0], gap[1], f * fac);\n    }\n}\n\nvoid configGlobals1() {\n    gT       = mod(iTime, gMaxTime);\n    gT       = stretchRange(gT, vec2(90.6, 97.0), 0.2);\n    \n    gSSZoom  = 1.3;\n    gSSEps   = 4.0 / MINRES / gSSZoom;\n    \n    gMouse   = length(iMouse.xy) < 50.0 ? (vec2(sin(gT * 0.107), -cos(gT * 0.1)) * 0.5 + 0.5) * RES.xy : iMouse.xy;\n    gSSMouse = gMouse/RES.xy;\n    \n    gLightDir     = normalize(-gVy + gVz * 0.4);\n    float sunTime = gT * 0.017 - 0.3;\n    gLightDir.yx *= rot2(PI/2.0 * 1.01 * sin(sunTime) * sign(cos(sunTime)));\n    \n    gTorusDims   = vec2(4.0, 2.0);\n    gTorusPos    = gVy * gTorusDims[1] * 0.0;\n\n//  gBallInset   = (sin(gT * 0.1) * 0.3 + 0.7) * gBallRad * 1.2;\n    const float insetMinFac = 0.2;\n    const float insetMaxFac = 2.1;\n    float git    = (gT + 31.0) * 0.015;\n    gBallCycle   = floor(git - 31.0 * 0.015);\n    gBallCycleHash = hash11(gBallCycle * 15.621341);\n    float ballRadMin = 0.2;\n    float ballRadMax = 2.2;\n    float ballRadFac = mix(ballRadMin, ballRadMax, gBallCycleHash);\n    if (gBallCycle == 0.0) {\n        gBallCycleHash = 0.0;\n        ballRadFac = 1.4;\n    }\n    \n    gBallRad     = gTorusDims.y * ballRadFac;\n    float gbx    = smoothstep(1.0, 0.7, -cos(git * PI * 2.0));\n    gBallInset   = gBallRad * mix(insetMaxFac, insetMinFac, gbx);\n    gBallOrbit   = gTorusDims.x + gTorusDims.y + gBallRad + 1.00;\n    float ballDir = gBallCycleHash < 0.5 ? 1.0 : -1.0;\n    gBallTime    = gT * ballDir * mix(0.42, 0.9, gBallCycleHash) + 2.2;\n    gBallPos     = gVx * gBallOrbit + gVy * (gBallRad - gBallInset);\n    gBallPos.xz *= rot2(-gBallTime);\n\n    configMaterials();\n}\n\nvec3 toBallSpace(in vec3 p) {\n    float f = 40.0;\n    p.xz = mod(p.xz + f / 2.0, f) - f/2.0;\n    return p - gBallPos;    \n}\n\n\nmarchResult_t map(vec3 p) {\n    gTotalMapIters += 1.0;\n    \n    vec3 pbs = toBallSpace(p);\n    \n    float d1 = p.y;\n    // add some convexity to each hexagonal tile\n    vec2 v2 = p.xz * gHexTileFac;\n    float hexHash = hash12(hextile(v2) * 4.83);\n    float lt = length(p.xz);\n    float hl = dot(v2, v2);\n    d1 += hl * 0.9 / (1.0 + lt);\n    if (hexHash < 0.06) {\n        d1 += cos(hl * 40.0) * 0.003;\n    }\n        \n    \n    float subtractedTorusRad = gBallRad * 1.0001;\n    d1 = opS(d1, sdTorus(pbs + gBallPos - gVy * (gBallRad - gBallInset), vec2(gBallOrbit, subtractedTorusRad)));\n\n    vec3 pt = p - dot(gTorusDims, vec2(1.0)) * gVy;\n    pt.xy *= rot2(PI/2.0);\n    float d2 = sdTorus(pt, gTorusDims);\n    \n    float d3 = sdSphere(toBallSpace(p), gBallRad);\n    \n    marchResult_t ret = marchResult_t(1e9, kMSky);\n    if (d1 < ret.t) { ret = marchResult_t(d1, kMFloor); }\n    if (d2 < ret.t) { ret = marchResult_t(d2, kMTorus); }\n    if (d3 < ret.t) { ret = marchResult_t(d3, kMBall); }\n    \n    return ret;\n}\n\nvoid getCamPosDir(out vec3 camPos, out vec3 camDir) {\n    float y    = smoothstep(0.05, 0.95, gSSMouse.y);\n    camPos     = gVz * gCamDist;\n    camPos.yz *= rot2((0.7 - y * 0.7) *  PI / 2.0);\n    camPos.xz *= rot2((gSSMouse.x * 2.0 - 1.0) * -PI * 1.1);\n    camPos    += gSceneCenter + gVy * 1.8;\n    \n //   camPos     = gBallPos * 2.0;\n   // camPos.y   = gBallPos.y * 0.5;\n    camDir     = normalize(gSceneCenter - camPos);\n}\n\nray_t getCamRay(in vec2 uv, float camZoom, in vec3 contribution) {\n    vec3 camPos;\n    vec3 camDir;\n    getCamPosDir(camPos, camDir);\n    ray_t ray;\n    ray.ro           = camPos;\n    ray.rd           = getCamRayDir(camDir, uv, camZoom);\n    ray.internal     = map(camPos).t < 0.0;\n    ray.shadow       = false;\n    ray.contribution = contribution;\n    return ray;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gNormEps).t;\n    }\n    return normalize(n);\n}\n\nmarchResult_t march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    vec3 p = ro;\n    \n    for (int n = 0; dot(p, p) < gMarchHorizonSq; ++n) {\n        marchResult_t mr = map(p);\n        if (mr.t < gMarchEps || n == gMarchMaxSteps) {\n            return marchResult_t(t, mr.m);\n        }\n        \n        t += mr.t * gMarchUnderStep;\n        p = ro + t * rd;\n    }\n    \n    return marchResult_t(1e9, 0u);\n}\n\n\nvec3 sky(vec3 dir) {\n    vec3 ret = simple_sky(gVy * -1.5, dir, -gLightDir);\n    // ungamma.\n    // I'm not sure if this is 'correct'\n    // but without it there are nasty pops in the post-sunset darkness.\n    ret = pow(ret, vec3(1.5));\n    return ret;\n}\n\nstruct materialProps_t {\n    vec3 albedo;\n    vec3 emissive;\n    float diffuse_vs_specular;  // 0 = diffuse 1 = specular\n};\n\nmaterialProps_t getMaterialProps(in vec3 p, uint m) {\n    materialProps_t ret;\n    \n    material_t mat = kMaterials[m];\n    \n    ret.albedo              = mat.c1;\n    ret.emissive            = gV0;\n    ret.diffuse_vs_specular = mat.diffuseVsSpecular1;\n\n    // special cases\n    switch (m) {\n        case kMFloor: {\n            \n            vec2 v2 = p.xz * gHexTileFac;\n            vec2 ht = hextile(v2);\n            ht.y *= 1.5;\n            float hash = hash12(ht);\n            if (hash * 4e3 < dot(ht, ht)) {\n                ret.albedo = mat.c2;\n                ret.emissive = ret.albedo * 0.1;\n            }\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, hash);\n            break;\n        }\n        case kMBall: {\n            vec3 pp = toBallSpace(p);\n            float at = smoothstep(gBallOrbit + gBallRad + 2.0, gBallOrbit + gBallRad + 1.0, length(p.xz));\n            at = 0.1 + 0.9 * at;\n            pp.xz *= rot2(gBallTime);                       // orbit\n            pp.yz *= rot2(gBallTime * 4.0 * PI / gBallRad); // roll\n            pp.xy *= rot2(2.2);                             // de-align\n            vec3 rgb = vec3(0.0);\n            for (int n = 0; n < 3; ++n) {\n                const float eps = 0.03;\n                float s = sin(4.0 * PI * (atan(pp[(n + 2)%3], pp[(n + 1)%3]) / (PI/2.0) * 0.5 + 0.5));\n                float f = smoothstep(-eps, eps, s);\n                rgb[(n + 0)%3] += f * 0.4;\n                rgb[(n + 1)%3] += f * 0.4;\n                rgb[(n + 2)%3] += f * 0.2;\n            }\n            rgb *= at;\n            ret.albedo = mix(rgb, vec3(1.0), 0.05);\n            ret.diffuse_vs_specular *= at;\n            break;\n        }\n    }\n    \n\n#if 0\n    // ping-pong between totally matte and specular,\n    // with the nice tuned materials in the middle.\n    float blah = sin(gT * 0.1);\n    \n    if (blah < 0.0) {\n        ret.diffuse_vs_specular = mix(0.0, ret.diffuse_vs_specular, blah + 1.0);\n    }\n    else {\n        ret.diffuse_vs_specular = mix(ret.diffuse_vs_specular, 1.0, blah);\n    }\n#endif\n\n    \n    return ret;\n}\n\nvec3 processRays() {\n\n    vec3 rgb = gV0;\n\n    while (!QIsEmpty() && gTotalMapIters < gMaxTotalMapIters) {\n        ray_t ray = QDequeue();\n        \n        vec3 rayRGB = gV0;\n\n        marchResult_t mr = march(ray.ro, ray.rd);\n        \n        if (ray.shadow) {\n            if (mr.t > 1e4) {\n                rgb += ray.contribution;\n            }\n        }\n        else {\n            if (mr.t < 1e4) {\n                vec3 p = ray.ro + ray.rd * mr.t;\n\n                vec3 n = calcNormal(p);\n\n                materialProps_t mp = getMaterialProps(p, mr.m);\n\n                vec3 albedo = mp.albedo;\n\n                float specAmt = mp.diffuse_vs_specular;\n                float diffAmt = 1.0 - specAmt;\n\n                float maximumDirectionalContribution = max(0.0, dot(n, -gLightDir));\n\n                vec3 directionalAmt = gDirectionalLight * maximumDirectionalContribution;\n                vec3 diffContrib = directionalAmt * albedo * diffAmt;\n\n                if (gLightDir.y < 0.0) {\n                    if (maximumDirectionalContribution > 0.0 && !ray.internal && !QIsFull() && dot(diffContrib, diffContrib) > gMinRayContribSq) {\n                        ray_t shdwRay;\n                        shdwRay.ro           = p + n * gMarchEps * 2.0;\n                        shdwRay.rd           = -gLightDir;\n                        shdwRay.contribution = ray.contribution * diffContrib;\n                        shdwRay.internal     = false;\n                        shdwRay.shadow       = true;\n                        QEnqueue(shdwRay);\n                    }\n                    else {\n                        rayRGB += diffContrib;\n                    }\n                }\n                \n                rayRGB += albedo * gAmbientLight;\n                rayRGB += mp.emissive;\n\n                vec3 specContrib = ray.contribution * specAmt;\n\n                if (!QIsFull() && dot(specContrib, specContrib) > gMinRayContribSq) {\n                    ray_t rflRay;\n                    rflRay.ro = p + n * gMarchEps * 2.0;\n                    rflRay.rd = reflect(ray.rd, n);\n                    rflRay.contribution = specContrib;\n                    rflRay.internal = ray.internal;\n                    rflRay.shadow       = false;\n                    QEnqueue(rflRay);\n                }\n\n            }\n            else {\n                rayRGB += sky(ray.rd);\n            }\n            rgb += ray.contribution * rayRGB;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    configGlobals1();\n    \n    vec2 uv = (floor((XY - RES.xy/2.0)/gDownRes)) / MINRES * 2.0 * gSSZoom * gDownRes;\n    \n    QEnqueue(getCamRay(uv, 2.0, gV1));\n    \n    vec3 rgb = processRays();\n    \n    // temporal fade-in\n    rgb *= 0.2 + 0.8 * square(smoothstep(0.0, 8.0, iTime));\n\n    // gamma\n    rgb = pow(rgb, vec3(1.0/2.2));\n    \n    \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[443, 459, 483, 483, 567], [569, 569, 592, 592, 608], [609, 609, 632, 632, 652], [653, 653, 676, 676, 696], [1490, 1608, 1657, 1657, 1732], [1734, 1754, 1783, 1783, 1807], [1808, 1808, 1837, 1837, 1863], [1884, 1884, 1908, 1908, 1926], [1928, 1928, 1961, 1961, 1989], [1991, 1991, 2022, 2022, 2109], [2110, 2110, 2155, 2155, 2442], [2444, 2444, 2477, 2477, 2542], [2546, 2647, 2675, 2774, 3101], [3103, 3186, 3208, 3208, 3536], [3537, 3537, 3559, 3559, 3726], [3729, 3880, 3903, 3903, 3988], [3989, 3989, 4011, 4011, 4128], [4129, 4149, 4171, 4171, 4290], [4291, 4310, 4332, 4332, 4465], [4978, 4978, 5021, 5021, 5069], [5071, 5071, 5100, 5100, 5139], [5141, 5141, 5183, 5267, 5457], [5459, 5459, 5507, 5507, 5825], [5827, 5887, 5908, 5908, 5924], [5925, 6096, 6148, 6148, 6952], [6956, 6956, 7009, 7009, 7382], [10475, 10475, 10499, 10499, 10855], [11074, 11074, 11103, 11103, 11201], [11202, 11202, 11231, 11231, 11263], [11264, 11264, 11293, 11293, 11321], [11322, 11322, 11351, 11351, 11376], [11377, 11377, 11406, 11406, 11464], [11465, 11465, 11494, 11494, 11552], [11606, 11606, 11656, 11656, 11909], [11911, 11911, 11934, 11934, 13492], [13494, 13494, 13523, 13523, 13617], [13620, 13620, 13647, 13647, 14631], [14633, 14633, 14686, 14686, 15058], [15060, 15060, 15126, 15126, 15427], [15430, 15476, 15501, 15501, 15704], [15706, 15706, 15745, 15745, 16109], [16112, 16112, 16132, 16132, 16366], [16493, 16493, 16546, 16546, 18592], [18594, 18594, 18614, 18614, 21050], [21052, 21052, 21095, 21095, 21465]]}
{"id": "Ntsyzr", "name": "Fork Drunk came vgabrielr 085", "author": "vgabrielr", "description": "You might not want to stare at this for too long.", "tags": ["2d", "filter", "sin", "camera", "vignette", "drunk"], "likes": 1, "viewed": 240, "published": 3, "date": "1647451241", "time_retrieved": "2024-07-30T16:58:21.314760", "image_code": "#define scale_uv(uv, scale, center) ((uv - center) * scale + center)\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    \n    float t = iTime * 1.0;\n    vec2 center = vec2(\n        sin(t * 1.25 + 75.0 + uv.y * 0.5) + sin(t * 2.75 - 18.0 - uv.x * 0.25),\n        sin(t * 1.75 - 125.0 + uv.x * 0.25) + sin(t * 2.25 + 4.0 - uv.y * 0.5)\n    ) * 0.25 + 0.5;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float z = (iMouse.z > 0.0) ?\n        1.0 - distance(mouse, vec2(0.5)) :\n        sin((t + 234.5) * 3.0) * 0.05 + 0.75;\n    \n    vec2 uv2 = scale_uv(uv, z, center);\n    \n    color = texture(iChannel0, uv2);\n    \n    float vignette = 1.0 - distance(uv, vec2(0.5));\n    color = mix(color, color * vignette, sin((t + 80.023) * 2.0) * 0.75);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntsyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 114, 114, 779]]}
{"id": "Ntlyzn", "name": "simple design", "author": "jorge2017a2", "description": "simple design", "tags": ["simpledesign"], "likes": 9, "viewed": 223, "published": 3, "date": "1647442891", "time_retrieved": "2024-07-30T16:58:22.065752", "image_code": "//----------image\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 130.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n//referencia\n//iq y etc\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n//iQ\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n       \n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    p= rotate_y( p, radians(300.0));\n    \n    p.y=p.y-5.0;\n    vec2 wh=vec2(10.0,3.0);\n    float d1= sdStairs(vec2(-p.x, p.y+5.0), wh,15.0 );    \n    float d2= sdBox( p-vec3(-40.0,0.0,0.0), vec3(45.0,30.0,15.0) );\n    float d3= sdBox( p-vec3(-40.0,20.0,30.0), vec3(45.0,30.0,15.0) ); //bloque izq\n    float d4= sdBox( p-vec3(-45.0,20.0,-25.0), vec3(45.0,30.0,10.0) ); //bloque der\n    float d5= sdBox( p-vec3(-20.0,-7.0,-10.0), vec3(45.0,2.0,55.0) ); //bloque piso\n    \n    float inter= intersectSDF(d1, d2);\n    float fmv=fbm(p*1.);\n    inter= clamp(fmv,0.,1.)*0.1+inter;\n    d3= clamp(fmv,0.,1.)*0.1+d3;\n    d4= clamp(fmv,0.,1.)*0.1+d4;\n    d5= clamp(fmv,0.,1.)*0.1+d5;\n    \n    res =opU2(res, vec2(inter,8.0));\n    res =opU2(res, vec2(d3,1.0));\n     res =opU2(res, vec2(d4,1.0));\n    res =opU2(res, vec2(d5,57.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n        //if (abs(hit.x) < EPSILON) break;\n    }\n    return object;\n\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos));// shadows\n    float occ = occlusion(hit, norm);// occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   \n    return colOut;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color<50)\n\t{ colobj=getColor(int( id_color)); return colobj; }\n    if (id_color==57) {\n    p= rotate_y( p, radians(300.0));\n    return pattern( p.xz );\n    }\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   \n   vec3 ro=vec3(0.0,11.0+5.0*sin(iTime),-35.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\n\n\nfloat cnoise4 (const in vec3 xx) \n{\n    vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = random4(N1);\n    vec4 R2 = random4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\nfloat fbm(vec3 p) {\n    float f;\n    f=0.0;\n    f += 0.5000*cnoise4( p ); p = p*2.02;\n    f += 0.2500*cnoise4( p ); p = p*2.03;\n    f += 0.1250*cnoise4( p ); p = p*2.01;\n    f += 0.0625*cnoise4( p );  \n     return f;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntlyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[522, 522, 554, 554, 638], [640, 640, 687, 687, 714], [715, 715, 758, 758, 785], [786, 786, 834, 834, 862], [864, 889, 923, 923, 1019], [1020, 1020, 1054, 1054, 1145], [1146, 1146, 1180, 1180, 1271], [1272, 1272, 1306, 1306, 1401], [1403, 1403, 1428, 1428, 1447], [1448, 1453, 1506, 1518, 2398], [2400, 2400, 2425, 2425, 3356], [3358, 3358, 3382, 3382, 3544], [3546, 3546, 3594, 3594, 3964], [3967, 3967, 4011, 4011, 4337], [4339, 4339, 4376, 4376, 4637], [4639, 4639, 4724, 4724, 5681], [5684, 5684, 5777, 5777, 5907], [5909, 5909, 5941, 5941, 6138], [6140, 6188, 6216, 6216, 6404], [6407, 6407, 6475, 6475, 6758], [6760, 6760, 6787, 6787, 6876], [6878, 6878, 6936, 6936, 6984], [6987, 6987, 7010, 7010, 7128], [7130, 7130, 7161, 7161, 7782], [7785, 7785, 7842, 7842, 8278]]}
{"id": "sd2BRV", "name": "3D Hexagon Triangle Pinwheel", "author": "Shane", "description": "An extruded irregular pinwheel tile pattern consisting of hexagons and triangle wedges.", "tags": ["triangle", "hexagon", "tile", "pinwheel", "extrude", "irregular"], "likes": 37, "viewed": 649, "published": 3, "date": "1647441371", "time_retrieved": "2024-07-30T16:58:23.006237", "image_code": "/*\n\n    3D Hexagon Triangle Pinwheel\n    ----------------------------\n\n    See Buffer A.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer. \n     \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Gamma correction and screen presentation.\n    // \"col\" should already be above zero.\n    fragColor = pow(col, vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    3D Hexagon Triangle Pinwheel\n    ----------------------------\n\n\tYou'll see a lot of path traced extruded stock imagery around. Depending\n    on your taste, you'll either like it, or you'll be one of those people who \n    are happy to leave it to the abstract computer art crowd. :) For whatever\n    reason, I've always liked geometrical wallpapers, so it's right up my alley.\n    I even like the incredibly cliche square grid pylons that everyone makes.\n    \n    Sometimes, I'll see an interesting pattern, then wonder what it'd look like\n    in extruded form, so that's what is happening here. These things are better\n    path traced as a static image, but on Shadertoy there's a certain amount of \n    pressure to render it in realtime. I've done my best, but it can be \n    difficult rendering something on the cheap whilst also maintaining quality.\n    \n    Things like this need antialiasing, but it's hard enough rendering one pass\n    at full frame rate, let along several. Therefore, I've done the next best\n    thing and accumulated a few frames to the buffer for a bit of temporal \n    depixelization. With just three frames, ghosting isn't too bad, provided \n    things are running at full frame rate, which should be the case on mid-range\n    to good systems. Things could be improved with camera reprojection, but I\n    left that out to simplify the code.\n    \n    In regard to the pattern algorithm itself, I've taken a brute force approach\n    to keep the logic simple, but it could be improved. I could also do a heap\n    of precalculation on an offscreen buffer, which I might do at a later date.\n    Therefore, apologies in advance for those with slower machines that are\n    experiencing ghosting; I'll attempt to speed things up in due course. In\n    the meantime, just comment out the TEMPORAL_AA define.\n    \n\n\tBased on:\n    \n\t// Much easier to understand, and would render much faster too.\n    Hexagon Triangle Wedge Pattern - Shane\n\thttps://www.shadertoy.com/view/ss2BDc\n\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// A pinwheel arrangement with wedge looking triangles. Commenting this \n// out will result in a regular hexagon triangle pinwheel arrangement.\n#define WEDGE\n\n// Very rough temporal anitaliasing. If you have a slow machine and are\n// experiencing too much ghosting, turn this off. By the way, I've disabled\n// this for resolutions over a certain amount, since I'm getting fullscreen\n// ghosting.\n#define TEMPORAL_AA\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/iChannelResolution[0].xy*2.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){\n\n    //return hash21(p/4.)/2.;\n\n    vec3 tx = texture(iChannel1, p/iChannelResolution[0].xy*4.).xyz; tx *= tx;\n    return dot(tx, vec3(.299, .587, .114)); \n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) + sdf*.5;\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .01;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n/* \n// This is a bound. Technically, it's not a proper distance field, but for\n// this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    //return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.  \n  p = abs(p); \n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n   \n \n  r -= sf;\n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n\nfloat tri(vec2 p){\n\n    return max(abs(p.x)*.8660254 + p.y*.5, -p.y);\n}\n\n/////////////////////////\n// Scaling.\n#ifdef WEDGE \nconst float sc = 1./2.5;\n#else\nconst float sc = 1./3.75;\n#endif\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(1.7320508, 1)*sc;\n\n// Hexagon edge and vertex IDs. They're useful for neighboring edge comparisons,\n// etc. Multiplying them by \"s\" gives the actual vertex postion.\n//\n// Vertices and edges: Clockwise from the left.\n//\n// Note that these are all six times larger than usual. We're doing this to \n// get rid of decimal places, especially those that involve division by three.\n// I't a common accuracy hack. Unfortunately, \"1. - 1./3.\" is not always the \n// same as \"2./3.\" on a GPU.\n\n// Multiplied by 12 to give integer entries only.  \nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n                    \n\n/*\nconst vec2[6] vID = vec2[6](vec2(-1./3., 0), vec2(-1./6., .5), vec2(1./6., .5), \n                      vec2(1./3., 0), vec2(1./6., -.5), vec2(-1./6., -.5)); \n\nconst vec2[6] eID = vec2[6](vec2(-.25, .25), vec2(0, .5), vec2(.25), \n                      vec2(.25, -.25), vec2(0, -.5), vec2(-.25));\n*/                       \n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n   \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n}                      \n//////////////////////////\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID = vec4(1e5);\n\n// The extruded blocks. This was written in a rush, so with more thought\n// put into it, you could make it faster. The code could also be neater.\n// However, if you're interested in how the 2D field value comes together,\n// you can reference my 2D example, here: https://www.shadertoy.com/view/ss2BDc\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + 1.;\n \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p.xy);\n\n    // Edge width. Set to zero for this example.\n    const float ew = 0.;//.015*sc;\n    \n    // Height factor.\n    const float hFact = .15;//.15;\n    \n    // Object scaling dimension.\n    #ifdef WEDGE \n    float sz = sc/6. - ew;\n    vec2 ip = p4.zw*18.; // Central object ID.\n    #else\n    float sz = sc/4. - ew;\n    vec2 ip = p4.zw*12.; // Central object ID.\n    #endif\n    \n    // Central hexagon 2D field value.\n    float di2D = sHexS(p4.xy, sz - sz*.02, sz*.02);\n    // Block height.\n    float h = hm(ip)*hFact;\n    gID.w = di2D; // Saved 2D field value.\n\n    // The extruded distance function value.\n    float di = opExtrusion(di2D, (p.z + h - 1.), h + 1.);\n    //di = max(di, -opExtrusion(di2D + sc*.1, (p.z + h + .02), h));\n    \n    // Overall object distance, set to the central block.\n    float d = di;\n    \n    // Hexagon arrangement ID -- The rest range from zero to five.\n    float id = 6.;\n    \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){\n     \n            #ifdef WEDGE \n             // Triangle central offset index.\n            vec2 indx1 = vID[i];\n            mat2 qR = rot2(6.2831/6.*float(i)); // Local rotation.\n            vec2 q = qR*(p4.xy - indx1*s/18.); // Local rotated coordinates.\n            di2D = tri(q) - sz; // Inner triangle distance.\n            \n            // Neighbor triangle central offset index.\n            vec2 indx2 = (eID[i]*3. + vID[(i+4)%6]);\n            q = qR*(p4.xy - indx2*s/18.); // Local rotated coordinates.\n            float di2D2 = tri(q) - sz; // Outer triangle distance.\n            \n            // Overal index for the inner object.\n            vec2 ipt = p4.zw*18. + indx1;\n            h = hm(ipt)*hFact; // Block height.\n            di2D = max(di2D, -(di2D2 - ew*2.));\n            di = opExtrusion(di2D, (p.z + h - 1.), h + 1.); // Extruded inner block distance.\n            // Extra detail.\n            //di = max(di, -opExtrusion(di2D + sc*.05, (p.z + h + .02), h));\n            \n            // Set the minimum distance and IDs for the inner object.\n            if(di<d) {\n                d = di;\n                id = float(i);\n                ip = ipt;\n                gID.w = di2D;\n            }\n            \n            // Overal index for the outer object.\n            ipt = p4.zw*18. + indx2; // Offset indices.\n            h = hm(ipt)*hFact; // Block height.\n            di = opExtrusion(di2D2, (p.z + h - 1.), h + 1.); // Extruded outer block distance.\n            // Extra detail.\n            //di = max(di, -opExtrusion(di2D2 + sc*.05, (p.z + h + .02), h));\n            \n            // Set the minimum distance and IDs for the outer object.\n            if(di<d) {\n                d = di;\n                id = mod(float(i + 4), 6.);\n                ip = ipt;\n                gID.w = di2D2;\n            }\n            \n            #else\n            \n            vec2 indx1 = vID[i]; // Offset indices.\n            vec2 q = p4.xy - indx1*s/12.; // Local coordinates.\n            q *= rot2(-6.2831/6.*float(i)); // Rotation.\n            di2D = tri(q) - sz; //1./.8660254+1.; // Triangle distance.\n            \n            vec2 ipt = p4.zw*12. + indx1;  // Offset indices.\n            h = hm(ipt)*hFact; // Block height.\n            di = opExtrusion(di2D, (p.z + h - 1.), h + 1.); // Extruded block distance.          \n            //di = min(di, opExtrusion(di2D + sc*.1, (p.z + h + .01), h));\n            \n            // Set the minimum distance and IDs.\n            if(di<d) {\n                d = di;\n                id = float(i);\n                ip = ipt;\n                gID.w = di2D;\n            }\n            \n            #endif\n            \n            \n    }\n    \n    // Save the ID for the nearest block.\n    gID.yz = ip; \n    gID.x = id; // Arrangement ID. Not really important, but useful for pattern colors.\n \n    \n \n    // Overall object ID.\n    objID = fl<d? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<40? d*.5 : d*.8; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t){\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function. \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n \n    // Initial values.\n    float shade = 1.;\n    float t = 1e-6;  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .85;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Block face pattern field. Just some animated\n// rising bubbles.\nvec3 df(vec2 p){\n   \n    // Upward movement, rotation and scaling.\n    p -= iTime/128.;\n    p *= rot2(3.14159/12.);\n    float sc = 1./9.;\n    p /= sc;\n    \n    // Row offset and grid partitioning.\n    if(mod(floor(p.y/s.y), 2.)>.5) p.x += s.x/2.;\n    vec2 ip = floor(p/s);\n    p -= (ip + .5)*s;\n    \n    // Rendering an offset circle in each cell.\n    vec2 offs = vec2(hash21(ip + .16), hash21(ip + .2)) - .5;\n    offs = sin(offs*6.2831+ iTime)*.5;\n    float d = length(p - offs*.15) - .16;\n    \n    // Distand and cell ID.\n    return vec3(d*sc, ip);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n    #ifdef TEMPORAL_AA\n    if(iResolution.y<650.){\n        vec2 jit = vec2(hash21(uv + .5 + fract(iTime*.07)), hash21(uv + .35 + fract(iTime*.17)));\n        uv += (jit - .5)/iResolution.y;\n    }\n   \t#endif\n    \n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/16., 0, -2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(-.08, .05, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.75, 1.25, 1.25);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2(sin(iTime)/16.);\n\t//rd.xy *= rot2(3.14159/6.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    // Saving the scene object.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;\n        vec3 tx4 = vec3(0);\n\n        // The extruded grid.\n        if(svObjID<.5){\n        \n             // Height.\n            float h = hm(svGID.yz);\n            // Smoothing factor for 2D face decoration.\n            float sf = .001; //1./iResolution.y;  \n            \n            // Coloring the individual blocks with the saved ID.\n            //vec3 tx = getTex(iChannel1, svGID.yz);\n            //tx = smoothstep(-.05, .5, tx);\n            //tx = mix(tx, tx.xzy, -rd.y*1.5 + .5);\n            \n            // Using the ID to produce a 2D sinusoidal pattern.\n            vec2 id = rot2(3.14159/6.)*svGID.yz/8.; // Position based ID.\n            float rnd = hash21(svGID.yz); // Random ID.\n            // Sinusoidal pattern.\n            float fn = dot(sin(id - cos(id*2.)*1.5), vec2(.25)) + .5;\n            // Sprinkling in some random noise.\n            fn = mix(fn, rnd, .2);\n            // Using IQ's palette formular to produce a limited range golden palette.\n            vec3 tx = .5 + .5*cos(6.2831*fn/10. + vec3(0, 1, 2)*.8 + 1.25);\n            // Other palette variations.\n            //vec3 tx = vec3((1.-step(.5, svGID.x - 5.))*.7 + .05);\n            //vec3 tx = .5 + .45*cos(6.2831*svGID.x/7. + vec3(0, 1, 2));\n            //vec3 tx = .5 + .45*cos(6.2831*rnd + vec3(0, 1, 2)*1.5);\n            //if(svGID.x<5.5 && mod(svGID.x + mod(svGID.y+svGID.z, 2.), 2.)<.5) tx = tx.xxx;\n            \n            // Pearl centers.\n            //if(svGID.x>5.5) tx = tx.xxx;\n            \n            // Top to bottom gradient coloring.\n            tx = mix(tx, tx.xzy, clamp((-sp.y + .25) + .5, 0., 1.)*.9);\n            \n            // Using the cell object normal to produce some UV coordinates for texturing.\n            // Normals pointing up, versus side normals.\n            vec2 uv = abs(sn.z)>.5? sp.xy : vec2(dot(normalize(sn.yx), sp.xy), sp.z);\n            // Loading in the trusty metallic texture... That, along with the timber texture,\n            // are the only two fine grained textures on here. If Shadertoy had a wider choice\n            // of textures, we could make some pretty awesome things. From a logistics standpoint,\n            // I'm not seeing the problem with supplying more textures, but there could be \n            // something I'm overlooking, like extra server costs, etc.\n            vec3 tx2 = texture(iChannel0, uv).xyz; tx2 *= tx2;\n            tx2 = .1 + tx2*2.5;//.25 + tx2*2.25;//vec3(.7);//\n            \n\n            // Overall color.\n            texCol = tx*tx2*.75;\n            \n            /*\n            // Line overlays. Interesting, but a bit much.\n            const float lNum = 100.;\n            vec2 rUV = rot2(-3.14159/3.)*uv;\n            float pat = (abs(fract(rUV.x*lNum) - .5)*2. - .5)/lNum/2.;\n            pat = smoothstep(0., .001, pat)*.5 + .65;\n            tx *= pat;\n            */ \n            \n            // Face and sides.\n            float hd = sp.z + h*.15*2.; // Rim height.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, hd - .005)));\n            texCol = mix(texCol, tx2*.9, (1. - smoothstep(0., sf, svGID.w + .005)));\n\n            // Overall object color.\n            vec3 tCol = tx*tx2*1.5;\n\n            // Bubble overlay field and application.\n            vec3 d3 = df(uv);\n            tCol = mix(tCol, tCol/1.5, (1. - smoothstep(0., sf, d3.x)));\n            //float sh = clamp(.25 - d3.x/.01, 0., 1.15);\n            tCol = mix(tCol, mix(tx*tx2*2., vec3(1), .1), (1. - smoothstep(0., sf, d3.x + .006)));\n            \n            // Applying the face color and border.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, svGID.w + .0125)));\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, svGID.w + .0125 + .005)));\n\n              \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n      \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some silhouette lighting.\n        //float rim = pow(clamp(1. + dot(rd, sn), 0., 1.), 5.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .8, .5)*spec*4.*sh);\n        //col += tx4*tx4*(sh*.7 + .3)*rim*8.;\n        //col += texCol*(sh*.7 + .3)*rim*8.;\n        \n        vec3 refTx = texture(iChannel2, reflect(rd, sn)).xyz; refTx *= refTx;\n        //col += dot(col, vec3(.299, .587, .114))*refTx*(sh*.7 + .3);\n        //col += texCol*refTx*1.;\n        col += (dot(texCol, vec3(.299, .587, .114))*(sh*.7 + .3))*refTx*.25;\n\n        // Shading.\n        col *= ao*atten;\n        \n        \n\t\n\t}\n    \n    // Sprinkles.\n    //float rnd = hash21(rd.xy + fract(iTime));\n    //col = clamp(col + (rnd*rnd - .5)*.1, 0., 1.);\n    \n    #ifdef TEMPORAL_AA\n    if(iResolution.y<650.){\n        // No camera reprojection. However, I'm roughly estimating where the camera\n        // would have been for the previous frame... Very hacky, but it'll do. :)\n        vec3 prevCol = texture(iChannel3, (fragCoord + vec2(1./3., 0))/iResolution.xy).xyz;\n        col = mix(prevCol, col, 1./3.);\n    }\n    #endif\n    \n    // Rough gamma correction.\n\tfragColor = vec4(max(col, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2BRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 152, 225, 426]]}
{"id": "ss2BRt", "name": "time-simple-example", "author": "sashikus", "description": "Простой пример работы с временем iTime", "tags": ["simple", "time"], "likes": 0, "viewed": 169, "published": 3, "date": "1647424658", "time_retrieved": "2024-07-30T16:58:23.821059", "image_code": "vec4 col_red = vec4(1.0, 0.2, 0.1, 1.0);\nvec4 col_grey = vec4 (0.4, 0.4, 0.45, 1.0);\n\nvoid circle(inout vec4 fragColor, vec2 uv, vec2 c, float r, vec3 col)\n{\n    float l = length(uv.xy - c.xy);\n    if (l < r) fragColor += vec4(col.rgb, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float r = (1.0 + sin(iTime)) / 4.0; // (время в секундах) -> (0.0 ... 0.5)\n    vec2 c = vec2(0.5, 0.5);\n    fragColor = col_grey;\n    circle(fragColor, uv, c, r, col_red.rgb);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2BRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 157, 157, 243], [246, 246, 301, 301, 544]]}
{"id": "slfyRn", "name": "7_5_lpVoronoi", "author": "tomoe", "description": "sample code\nVoronoi decomposition with L^p norms", "tags": ["ch7"], "likes": 1, "viewed": 400, "published": 3, "date": "1647421373", "time_retrieved": "2024-07-30T16:58:24.575043", "image_code": "ivec2 channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nfloat length2(vec2 p){\n    p = abs(p);\n    float d = 4.0 * sin(iTime) + 5.0;\n    return pow(pow(p.x, d) + pow(p.y, d), 1.0 / d);\n}\n\nvec2 voronoi2(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = length2(vec2(1));\n    vec2 id;\n    for(float j = 0.0; j <= 2.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = -1.0; i <= 1.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            if (length2(glid + jitter - p) <= dist){\n                dist = length2(glid + jitter - p);\n                id = glid;\n            }\n        }\n    }\n    return id;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor = vec4(hash22(voronoi2(pos)), 1, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 265], [266, 266, 289, 289, 402], [403, 403, 426, 426, 527], [528, 528, 550, 550, 633], [634, 634, 655, 655, 741], [742, 742, 763, 763, 849], [850, 850, 870, 870, 952], [953, 953, 973, 973, 1055], [1056, 1067, 1089, 1089, 1197], [1199, 1199, 1221, 1221, 1799], [1800, 1800, 1854, 1854, 2007]]}
{"id": "stfyRn", "name": "7_4_lp", "author": "tomoe", "description": "sample code\nSDF with L^p norms", "tags": ["ch7"], "likes": 1, "viewed": 295, "published": 3, "date": "1647420993", "time_retrieved": "2024-07-30T16:58:25.415795", "image_code": "const float PI = 3.14159265359;\nfloat length2(vec2 p){\n    p = abs(p);\n    float d = 4.0 * sin(0.5 * iTime) + 5.0;\n    return pow(pow(p.x, d) + pow(p.y, d), 1.0 / d);\n}\nfloat circle(vec2 p, vec2 c, float r){\n    return length2(p - c) - r;\n}\nvec3 contour(float v, float interval){\n    return abs(v) < 0.01 ? vec3(0.0):\n    mod(v, interval) < 0.01 ? vec3(1.0):\n    mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(v) / PI + 0.5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ min(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(contour(circle(pos, vec2(0.0), 1.0), 0.1));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 168], [169, 169, 207, 207, 240], [241, 241, 279, 279, 419], [420, 420, 474, 474, 656]]}
{"id": "slXyRn", "name": "7_3_varyVoronoi", "author": "tomoe", "description": "sample code\n2D (down) and 3D (up) Voronoi decomposition with Euclid (left), Manhattan (center), and chessboard (right) distances\n", "tags": ["ch7"], "likes": 2, "viewed": 251, "published": 3, "date": "1647420693", "time_retrieved": "2024-07-30T16:58:26.257544", "image_code": "ivec2 channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nfloat length2(vec2 p){\n    float t = mod(iTime, 3.0);\n    p = abs(p);\n    return channel.x == 0 ? length(p):\n        channel.x == 1 ? dot(p, vec2(1.0)):\n        max(p.x, p.y);\n}\nfloat length3(vec3 p){\n    float t = mod(iTime, 3.0);\n    p = abs(p);\n    return channel.x == 0 ? length(p):\n        channel.x == 1 ? dot(p, vec3(1.0)):\n        max(max(p.x, p.y), p.z);\n}\nvec2 voronoi2(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = length2(vec2(1));\n    vec2 id;\n    for(float j = 0.0; j <= 2.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = -1.0; i <= 1.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            if (length2(glid + jitter - p) <= dist){\n                dist = length2(glid + jitter - p);\n                id = glid;\n            }\n        }\n    }\n    return id;\n}\nvec3 voronoi3(vec3 p){\n    vec3 n = floor(p + 0.5);\n    float dist = length3(vec3(1));\n    vec3 id;\n    for(float k = 0.0; k <= 2.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = -1.0; i <= 1.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                if (length3(glid + jitter - p) <= dist){\n                    dist = length3(glid + jitter - p);\n                    id = glid;\n                }\n            }\n        }\n    }\n    return id;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = ivec2(vec2(3, 2) * fragCoord.xy/ iResolution.xy); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor = channel.y == 0 ? vec4(hash22(voronoi2(pos)), 1, 1) : vec4(hash33(voronoi3(vec3(pos, 0.5 * iTime))), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 265], [266, 266, 289, 289, 402], [403, 403, 426, 426, 527], [528, 528, 550, 550, 633], [634, 634, 655, 655, 741], [742, 742, 763, 763, 849], [850, 850, 870, 870, 952], [953, 953, 973, 973, 1055], [1056, 1067, 1089, 1089, 1244], [1245, 1245, 1267, 1267, 1432], [1433, 1433, 1455, 1455, 2033], [2034, 2034, 2056, 2056, 2898], [2899, 2899, 2953, 2953, 3239]]}
{"id": "stXyRn", "name": "7_2_varyDist", "author": "tomoe", "description": "sample code\nepsilon-neighborhood in Manhattan, Euclid, and chessboard distance", "tags": ["ch7"], "likes": 2, "viewed": 233, "published": 3, "date": "1647420263", "time_retrieved": "2024-07-30T16:58:27.035465", "image_code": "const float PI = 3.14159265359;\nfloat length2(vec2 p){\n    float t = mod(iTime, 3.0);\n    p = abs(p);\n        return t < 1.0 ? length(p)://Euclid\n            t < 2.0 ? dot(p, vec2(1.0))://Manhattan\n        max(p.x, p.y);//chessboard\n}\nfloat circle(vec2 p, vec2 c, float r){\n    return length2(p - c) - r;\n}\nvec3 contour(float v, float interval){\n    return abs(v) < 0.01 ? vec3(0.0):\n    mod(v, interval) < 0.01 ? vec3(1.0):\n    mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(v) / PI + 0.5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ min(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(contour(circle(pos, vec2(0.0), 1.0), 0.1));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 234], [235, 235, 273, 273, 306], [307, 307, 345, 345, 485], [486, 486, 540, 540, 722]]}
{"id": "ftfczr", "name": "7_1_rectSDF", "author": "tomoe", "description": "sample code\nSDF of rectangle", "tags": ["ch7"], "likes": 0, "viewed": 205, "published": 3, "date": "1647419878", "time_retrieved": "2024-07-30T16:58:27.848291", "image_code": "const float PI = 3.14159265359;\nfloat rectSDF(vec2 p, vec2 c, vec2 d){\n    p = abs(p - c);\n    return length(max(p - d, vec2(0.0))) + min(max(p.x - d.x, p.y - d.y), 0.0);\n}\nvec3 contour(float v, float interval){\n    return abs(v) < 0.01 ? vec3(0.0):\n    mod(v, interval) < 0.01 ? vec3(1.0):\n    mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(v) / PI + 0.5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ min(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(contour(rectSDF(pos, vec2(0.0), vec2(0.5)), 0.1));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 70, 70, 172], [173, 173, 211, 211, 351], [352, 352, 406, 406, 595]]}
{"id": "NlXczr", "name": "7_0_circle", "author": "tomoe", "description": "sample code\ncontour of (x^2+y^2)^d - r (d is determined by the mouse x-position)", "tags": ["ch7"], "likes": 1, "viewed": 215, "published": 3, "date": "1647419522", "time_retrieved": "2024-07-30T16:58:28.668099", "image_code": "const float PI = 3.14159265359;\nfloat circle(vec2 p, vec2 c, float r){\n    float d = 0.5 + iMouse.x / iResolution.x;\n    return pow(dot(p - c, p - c), d) - r;\n}\nvec3 contour(float v, float interval){\n    return abs(v) < 0.01 ? vec3(0.0):\n    mod(v, interval) < 0.01 ? vec3(1.0):\n    mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(v) / PI + 0.5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ min(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(contour(circle(pos, vec2(0.0), 1.0), 0.3));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 70, 70, 160], [161, 161, 199, 199, 339], [340, 340, 394, 394, 576]]}
{"id": "flfyzr", "name": "6_6_cnoise", "author": "tomoe", "description": "sample code\n2D (down) and 3D (up) cellular noise with several weights\n", "tags": ["ch6"], "likes": 9, "viewed": 275, "published": 3, "date": "1647418611", "time_retrieved": "2024-07-30T16:58:29.438041", "image_code": "ivec2 channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nvec4 sort(vec4 list, float v){\n    bvec4 res = bvec4(step(v, list));\n    return res.x ? vec4(v, list.xyz):\n        res.y ? vec4(list.x, v, list.yz):\n        res.z ? vec4(list.xy, v, list.z):\n        res.w ? vec4(list.xyz, v):\n        list;\n}\nvec4 fdist24(vec2 p){\n    vec2 n = floor(p) + 0.5;\n    vec4 dist4 = vec4(length(1.5 - abs(p - n)));\n    for(float j = 0.0; j <= 4.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist4.w){\n            continue;\n        }\n        for(float i = -2.0; i <= 2.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            dist4 = sort(dist4, length(glid + jitter - p));\n        }\n    }\n    return dist4;\n}\nvec4 fdist34(vec3 p){\n    vec3 n = floor(p) + 0.5;\n    vec4 dist4 = vec4(length(1.5 - abs(p - n)));\n    for(float k = 0.0; k <= 4.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist4.w){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist4.w){\n                continue;\n            }\n            for(float i = -2.0; i <= 2.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                dist4 = sort(dist4, length(glid + jitter - p));\n            }\n        }\n    }\n    return dist4;\n}\nvec4 wt;\nfloat cnoise21(vec2 p){\n    return abs(dot(wt, fdist24(p)));\n}\nfloat cnoise31(vec3 p){\n    return abs(dot(wt, fdist34(p)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = ivec2(vec2(3, 2) * fragCoord.xy/ iResolution.xy); \n    pos *= 10.0;\n    pos += iTime;\n    wt = channel.x == 0 ? vec4(0.2):\n        channel.x == 1 ? vec4(0.5, -1.0, 1.4, -0.1):\n        vec4(-0.3, -0.5, -1.2, 1.0);\n    fragColor = vec4(channel.y == 0 ? cnoise21(pos) : cnoise31(vec3(pos, iTime)));\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 265], [266, 266, 289, 289, 402], [403, 403, 426, 426, 527], [528, 528, 550, 550, 633], [634, 634, 655, 655, 741], [742, 742, 763, 763, 849], [850, 850, 870, 870, 952], [953, 953, 973, 973, 1055], [1056, 1067, 1097, 1097, 1308], [1309, 1309, 1330, 1330, 1830], [1831, 1831, 1852, 1852, 2607], [2617, 2617, 2640, 2640, 2679], [2680, 2680, 2703, 2703, 2742], [2743, 2743, 2797, 2797, 3196]]}
{"id": "ftXyzr", "name": "6_5_fdist4RGB", "author": "tomoe", "description": "sample code\nf0, f1, f2, f3: distances to the first, second , third, and fourth feature points\nblack if f3<threshold; blue if f2<threshold<f3; green if f1<threshold<f2; red if f0<threshold<f1; white if threshold<f0", "tags": ["ch6"], "likes": 0, "viewed": 145, "published": 3, "date": "1647417877", "time_retrieved": "2024-07-30T16:58:30.270814", "image_code": "ivec2 channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nvec4 sort(vec4 list, float v){\n    bvec4 res = bvec4(step(v, list));\n    return res.x ? vec4(v, list.xyz):\n        res.y ? vec4(list.x, v, list.yz):\n        res.z ? vec4(list.xy, v, list.z):\n        res.w ? vec4(list.xyz, v):\n        list;\n}\nvec4 fdist24(vec2 p){\n    vec2 n = floor(p) + 0.5;\n    vec4 dist4 = vec4(length(1.5 - abs(p - n)));\n    for(float j = 0.0; j <= 4.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist4.w){\n            continue;\n        }\n        for(float i = -2.0; i <= 2.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            dist4 = sort(dist4, length(glid + jitter - p));\n        }\n    }\n    return dist4;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = ivec2(vec2(4, 2) * fragCoord.xy/ iResolution.xy); \n    pos *= 3.0;\n    pos += iTime;\n    float thr = 0.7;\n    bvec4 dist4b = bvec4(step(thr, fdist24(pos)));\n    fragColor = dist4b.x ? vec4(1,1,1,1): \n        dist4b.y ? vec4(1,0,0,1): \n        dist4b.z ? vec4(0,1,0,1): \n        dist4b.w ? vec4(0,0,1,1):\n        vec4(0,0,0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 265], [266, 266, 289, 289, 402], [403, 403, 426, 426, 527], [528, 528, 550, 550, 633], [634, 634, 655, 655, 741], [742, 742, 763, 763, 849], [850, 850, 870, 870, 952], [953, 953, 973, 973, 1055], [1056, 1067, 1097, 1097, 1308], [1309, 1309, 1330, 1330, 1830], [1831, 1831, 1885, 1885, 2292]]}
{"id": "NlXcRr", "name": "6_4_fdist4", "author": "tomoe", "description": "sample code\ndistance to the first (left), second (center left), third (center right), and forth (right) closest feature point", "tags": ["ch6"], "likes": 3, "viewed": 181, "published": 3, "date": "1647416604", "time_retrieved": "2024-07-30T16:58:31.083641", "image_code": "ivec2 channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nvec4 sort(vec4 list, float v){\n    bvec4 res = bvec4(step(v, list));\n    return res.x ? vec4(v, list.xyz):\n        res.y ? vec4(list.x, v, list.yz):\n        res.z ? vec4(list.xy, v, list.z):\n        res.w ? vec4(list.xyz, v):\n        list;\n}\nvec4 fdist24(vec2 p){\n    vec2 n = floor(p + 0.5);\n    vec4 dist4 = vec4(length(1.5 - abs(p - n)));\n    for(float j = 0.0; j <= 4.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist4.w){\n            continue;\n        }\n        for(float i = -2.0; i <= 2.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            dist4 = sort(dist4, length(glid + jitter - p));\n        }\n    }\n    return dist4;\n}\nvec4 fdist34(vec3 p){\n    vec3 n = floor(p + 0.5);\n    vec4 dist4 = vec4(length(1.5 - abs(p - n)));\n    for(float k = 0.0; k <= 4.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist4.w){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist4.w){\n                continue;\n            }\n            for(float i = -2.0; i <= 2.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                dist4 = sort(dist4, length(glid + jitter - p));\n            }\n        }\n    }\n    return dist4;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = ivec2(vec2(4, 2) * fragCoord.xy/ iResolution.xy); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor = channel.y == 0 ? vec4(fdist24(pos)[channel.x % 4]) : vec4(fdist34(vec3(pos, iTime))[channel.x % 4]);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXcRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 166, 166, 265], [266, 266, 289, 289, 402], [403, 403, 426, 426, 527], [528, 528, 550, 550, 633], [634, 634, 655, 655, 741], [742, 742, 763, 763, 849], [850, 850, 870, 870, 952], [953, 953, 973, 973, 1055], [1056, 1067, 1097, 1097, 1308], [1309, 1309, 1330, 1330, 1830], [1831, 1831, 1852, 1852, 2607], [2608, 2608, 2662, 2662, 2968]]}
{"id": "NtfyRr", "name": "6_3_voronoi", "author": "tomoe", "description": "sample code\nVoronoi decomposition with random feature points\n(left) 2D (right) 3D", "tags": ["ch6"], "likes": 1, "viewed": 198, "published": 3, "date": "1647413144", "time_retrieved": "2024-07-30T16:58:31.881507", "image_code": "int channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nvec2 voronoi2(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = sqrt(2.0);\n    vec2 id;\n    for(float j = 0.0; j <= 2.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = -1.0; i <= 1.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            if (length(glid + jitter - p) <= dist){\n                dist = length(glid + jitter - p);\n                id = glid;\n            }\n        }\n    }\n    return id;\n}\nvec3 voronoi3(vec3 p){\n    vec3 n = floor(p + 0.5);\n    float dist = sqrt(3.0);\n    vec3 id;\n    for(float k = 0.0; k <= 2.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = -1.0; i <= 1.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                if (length(glid + jitter - p) <= dist){\n                    dist = length(glid + jitter - p);\n                    id = glid;\n                }\n            }\n        }\n    }\n    return id;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x/ iResolution.x); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor.rgb = channel == 0 ? vec3(hash22(voronoi2(pos)), 1) : vec3(hash33(voronoi3(vec3(pos, iTime))));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 164, 164, 263], [264, 264, 287, 287, 400], [401, 401, 424, 424, 525], [526, 526, 548, 548, 631], [632, 632, 653, 653, 739], [740, 740, 761, 761, 847], [848, 848, 868, 868, 950], [951, 951, 971, 971, 1053], [1054, 1065, 1087, 1087, 1656], [1657, 1657, 1679, 1679, 2512], [2513, 2513, 2567, 2567, 2855]]}
{"id": "7dsyD7", "name": "6_2_fdistGrad", "author": "tomoe", "description": "sample code\ndistance to the closest feature point (left) and derivatives (right)", "tags": ["ch6"], "likes": 3, "viewed": 215, "published": 3, "date": "1647412487", "time_retrieved": "2024-07-30T16:58:32.682366", "image_code": "int channel;\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\nfloat fdist(vec2 p){\n    vec2 n = floor(p + 0.5);\n    float dist = sqrt(2.0);\n    for(float j = 0.0; j <= 2.0; j ++ ){\n        vec2 glid;\n        glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n        if (abs(glid.y - p.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = -1.0; i <= 1.0; i ++ ){\n            glid.x = n.x + i;\n            vec2 jitter = hash22(glid) - 0.5;\n            dist = min(dist, length(glid + jitter - p));\n        }\n    }\n    return dist;\n}\nvec2 grad(vec2 p){\n    float eps = 0.001;\n    return 0.5 * (vec2(\n            fdist(p + vec2(eps, 0.0)) - fdist(p - vec2(eps, 0.0)),\n            fdist(p + vec2(0.0, eps)) - fdist(p - vec2(0.0, eps))\n        )) / eps;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ min(iResolution.x, iResolution.y);\n    channel = int(2.0 * fragCoord.x/ iResolution.x); \n    pos *= 10.0;\n    pos += iTime;\n    fragColor = channel == 0 ? vec4(fdist(pos)) : vec4(grad(pos), 1.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 164, 164, 263], [264, 264, 287, 287, 400], [401, 401, 424, 424, 525], [526, 526, 548, 548, 631], [632, 632, 653, 653, 739], [740, 740, 761, 761, 847], [848, 848, 868, 868, 950], [951, 951, 971, 971, 1053], [1054, 1065, 1085, 1085, 1557], [1558, 1558, 1576, 1576, 1776], [1777, 1777, 1831, 1831, 2086]]}
{"id": "ftXyzn", "name": "Fractal box mosaic", "author": "jarble", "description": "I don't know what this thing is, but I like it.", "tags": ["fractal", "box", "mosaic"], "likes": 4, "viewed": 204, "published": 3, "date": "1647408668", "time_retrieved": "2024-07-30T16:58:33.477241", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36./1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += (t2.yx);\n            uv /= -1.25;\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = -triangle_wave(uv,scale);\n            uv.yx = (t2+t3)/scale;\n            //uv += uv/scale;\n        }\n        col.x = -max(uv.y-uv.x+col.x,col.x);\n        //uv.x *= -1.;\n        col = -abs(col.yzx-vec3(col.x)/2.);\n        uv.y *= -1.;\n    }\n    fragColor = vec4(-col*4.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 965]]}
{"id": "flfyRn", "name": "Golden flower stars", "author": "jarble", "description": "This fractal reminds me of a Christmas tree.", "tags": ["fractal", "flower", "star"], "likes": 8, "viewed": 314, "published": 3, "date": "1647407609", "time_retrieved": "2024-07-30T16:58:34.236212", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);  \n    float t1 = 36.*16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<12;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += (t2.yx);\n            uv /= -1.25;\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = -triangle_wave(uv,scale);\n            uv.yx = (t2+t3)/scale;\n            //uv += uv/scale;\n        }\n        col.x = max(uv.y+uv.x-col.x,-col.x);\n        //uv.x *= -1.;\n        col = abs(col.yzx-vec3(col.x)/2.);\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*4.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 966]]}
{"id": "7d2BDd", "name": "Fractal knots 13", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot", "mosaic"], "likes": 7, "viewed": 257, "published": 3, "date": "1647400998", "time_retrieved": "2024-07-30T16:58:35.015129", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*16.*16.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec3 col1 = col;\n    \n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            \n            //uv += fract(uv.x/2.)/2.; //gnarled lichen\n\n            \n            //uv += ceil(uv.y+uv.x)/19.; //another interesting pattern\n            uv += (t2.yx);\n            uv /= -1.35;\n            \n\n            //uv -= ceil(t2.x+p1)/2.; //mosaic pattern\n            //uv -= ceil(t2.x*t2.y-p1)/2.; //another mosaic pattern\n            //uv += vec2(1.); //this also makes an interesting pattern\n            vec2 temp = t2;\n            t2 =\n                p1*triangle_wave(uv.yx-.5,1.5)\n                //p1*triangle_wave(uv.yx-.5-fmod(t2.x/1.5,2.),1.5)\n            ;\n            t3 = -p1*triangle_wave(uv,1.5);\n            uv.yx = (t2+t3)/scale;\n            //uv += dot(uv,t2)/4.;\n            p1 *= -1.;\n            //uv += uv/scale;\n        }\n        float s1 = 2.-uv.y*2.;\n        col.x = min(uv.y+uv.x+col.x,col.x*s1);\n        //col.x = min(uv.y-uv.x+col.x,col.x*2.);\n        \n        //uv.x *= -1.;\n        col = abs(col.yzx-vec3(col.x)*s1)/s1;\n        col1 = abs(col1-col);\n        //col = abs(col.yzx+vec3(col.x)*2.)/3.;\n\n        uv.y *= -1.;\n    }\n    fragColor =\n        vec4(col*2.,1.0);\n        //vec4(col1*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 103, 103, 148], [150, 150, 207, 207, 1722]]}
{"id": "sd2BDd", "name": "Fractal knots 12", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 3, "viewed": 152, "published": 3, "date": "1647400855", "time_retrieved": "2024-07-30T16:58:35.787065", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*16.*16.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<9;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            uv /= -1.35;\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = -triangle_wave(uv,scale);\n            uv.yx = (t2+t3)/scale;\n            //uv += uv/scale;\n        }\n        col.x = max(uv.y+uv.x+col.x,col.x);\n        col = abs(col.yzx-vec3(col.x)*2.);\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2BDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 947]]}
{"id": "ssjfWd", "name": "It's a Moire!", "author": "itishappy", "description": "quick test of colorful moire patterns", "tags": ["moire"], "likes": 0, "viewed": 61, "published": 3, "date": "1647396512", "time_retrieved": "2024-07-30T16:58:36.661728", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotate \n    float theta = iTime/10. + 3.;\n    vec2 uv2 = mat2(cos(theta),sin(theta),-sin(theta),cos(theta)) * uv;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(20. * uv2.yxy * uv.xyx + vec3(1.,2.,-3.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 436]]}
{"id": "Nd2fDd", "name": "Murky Waves", "author": "SnoopethDuckDuck", "description": "i like the fresnel on it", "tags": ["e"], "likes": 9, "viewed": 221, "published": 3, "date": "1647386719", "time_retrieved": "2024-07-30T16:58:37.604207", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(3, 1.6, 1.2);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1.)) - 0.1;\n    //p.y -= 0.4 * cross(p, normalize(vec3(0. * cc(0.01, 2.2 * p.x + iTime), \n    //                             100. + 0. * cos(p.y + iTime), \n    //                             -30. * fract(p.y * 10.)))).y;\n    // i dont know what this does (lol)\n    p.y -= 0.2 * cross(p, normalize(vec3(0., \n                                         80., \n                                         -2.5 * cos(p.y * 10.)))).y;\n    p.y += 2.5 + 2. * thc(2.,-2. + 0.05 * p.x - 0.4 * iTime);\n    p.z += 0.5 * thc(1.01, p.x + iTime);\n    p.y += 0.5 * thc(1.01, p.z + 0.8 * iTime);\n    d = p.y;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    vec3 q = 8. * vec3(cos(0.81 * iTime), 0.25, sin(iTime));\n    vec3 rd = GetRayDir(uv, ro, vec3(0.), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        vec2 ipos = floor(2. * p.xz);\n        float bg = mod(3. * ipos.x + 5. * ipos.y, 7.);\n        col = mix(col, vec3(0.), exp(-10. * p.y));\n        \n        float mx = exp(-0.03 * length(p));\n        //col = vec3(mx * bg);\n        col = vec3(1);// * bg /7.;\n        \n        vec3 e = vec3(1);\n        col *= pal(p.y * 1.6 + bg / 7., e, e, 0.14 * e, 0.4 * vec3(0,1,2)/3.);\n        //col = vec3(1) * bg * 4. * exp(-2. * length(p-q));\n        //col += (1.-bg) * mx;\n        float fres = pow(1. + dot(rd, n), 5.);\n        col *= fres;\n        col = mix(vec3(0.85), col, mx);\n    } else col = vec3(0.85);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2fDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 723], [725, 725, 748, 748, 1378], [1380, 1380, 1423, 1423, 1730], [1732, 1732, 1756, 1756, 1946], [1948, 1948, 1998, 1998, 2189], [2191, 2191, 2248, 2248, 3668]]}
{"id": "NdjBWt", "name": "Checkerboard Truchet 2", "author": "SnoopethDuckDuck", "description": "basically the same as fork, but overlayed 3 different thresholds + used different colors. \n\nbit of a mess, really like this pattern :)", "tags": ["e"], "likes": 16, "viewed": 335, "published": 3, "date": "1647365914", "time_retrieved": "2024-07-30T16:58:38.344228", "image_code": "float h21 (vec2 uv, float sc) {\n    uv = mod(uv, sc);\n    return fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat line(vec2 uv, float width) {\n    return max(-uv.y + width, abs(uv.x));\n}\n\nfloat curve(vec2 uv) {\n    return abs(length(uv-0.5) - 0.5);\n}\n\nfloat shape(vec2 uv, vec4 h, float width) {\n    if (h.x + h.y + h.z + h.w == 0.)\n        return 0.;\n         \n    // center circle to round off line segments\n    float d = length(uv);     \n         \n    // draw line segment from center to edge (-width offset for center circle)\n    d = mix(d, min(d, line(uv,     width)), h.x);\n    d = mix(d, min(d, line(uv.yx,  width)), h.y);\n    d = mix(d, min(d, line(-uv,    width)), h.z);\n    d = mix(d, min(d, line(-uv.yx, width)), h.w);\n    \n    // draw quarter circle between 2 edges\n    d = mix(d, min(d, curve(vec2(uv.x, uv.y))),   h.x * h.y);\n    d = mix(d, min(d, curve(vec2(uv.x, -uv.y))),  h.y * h.z);\n    d = mix(d, min(d, curve(vec2(-uv.x, -uv.y))), h.z * h.w);\n    d = mix(d, min(d, curve(vec2(-uv.x, uv.y))),  h.w * h.x);\n    \n    float k = 6./iResolution.y;\n    return smoothstep(-k, k, -d + width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    uv.x += 10. + 0.08 * iTime;          \n    uv.y += 0.005 * thc(10., 3. * uv.x + 0.28 * iTime);\n    \n    float sc = 13.;         \n    vec2 ipos = floor(sc * uv) + 0.;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float width = 0.3 + 0.15 * cc(0.5, 0.5 * h21(ipos) + .5 * uv.x + 0.8 * iTime);\n\n    // arbitrary values - hash repetition, offset\n    float rep = 302.; \n    float val = 0.01;   \n    \n    // Checkerboard pattern:\n    // black cells choose edges for themselves + white cells\n    // white cells look at black cells to find edges\n    // construct pattern for cell based on edge configuration\n    float s = 0.;\n    vec4 r;\n    vec4 h, h2, h3;\n    if (mod(ipos.x + ipos.y, 2.) == 0.) {\n        r = vec4(h21(ipos,            rep),  // up\n                 h21(ipos + val,      rep),  // right\n                 h21(ipos + 2. * val, rep),  // down\n                 h21(ipos + 3. * val, rep)); // left ( I think* )\n        \n        h3 = step(r, vec4(0.6)), h2 = step(r, vec4(0.4)), h = step(r, vec4(0.2));   \n        s = shape(fpos, h, width);\n        s += 0.5 * (1.-s) * shape(fpos, h2, width);\n        s += 0.25 * (1.-s) * shape(fpos, h3, width);\n    } else {\n        r = vec4(h21(ipos + vec2(0,1) + 2. * val, rep),  // up's down\n                 h21(ipos + vec2(1,0) + 3. * val, rep),  // right's left\n                 h21(ipos - vec2(0,1),            rep),  // down's up\n                 h21(ipos - vec2(1,0) + val,      rep)); // left's right\n        \n        h3 = step(r, vec4(0.6)), h2 = step(r, vec4(0.4)), h = step(r, vec4(0.2));\n        s = shape(fpos, h, width);\n        s += 0.5 * (1.-s) * shape(fpos, h2, width);  \n        s += 0.25 * (1.-s) * shape(fpos, h3, width);\n    }\n    \n    vec3 e = vec3(1);\n    // was using floor(h21() + iTime), width is a messy stand-in\n    vec3 col = s * pal(-0.08 * floor(width * 4.) + 0.19 + 0.05 * (r.x + r.y + r.z + r.w), e, e, e, 0.42 * vec3(0,1,2)/3.);\n    //col += (1.-s) * pal(0.5 + 0.23 * uv.y, e, e, e, 0.15 * vec3(0,1,2)/3.);\n    //col *= 10. *(1.-s) * exp(-8. * length(ouv));\n    col += (1.-s) * vec3(s,0,0.22) * (uv.y+0.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 124], [126, 126, 160, 160, 204], [206, 206, 228, 228, 268], [270, 270, 313, 313, 1124], [1126, 1126, 1183, 1183, 3391]]}
{"id": "ssBfWd", "name": "Copper Fires", "author": "lwswl", "description": "static flames", "tags": ["raymarch", "fire", "polar"], "likes": 2, "viewed": 224, "published": 3, "date": "1647363161", "time_retrieved": "2024-07-30T16:58:39.154063", "image_code": "#define PI 3.141\n#define iTime abs(mod(iTime-2000.,4000.)-2000.)\nvec3 albedo=vec3(0.5);\nfloat pat(vec2 co){\n    co=vec2(length(co),6.*atan(co.y,co.x)/PI);\n    co.y+=sin(co.x*3.+iTime);\n    float o=abs(mod(co.y,1.)-0.5);\n    o=3.*o*o-2.*o*o*o;\n    return o;\n}\nfloat dist(vec3 p){\n    float ret= p.y+pat(p.xz)*0.5;\n    vec3 f=p;\n    f.xz=mod(f.xz-10.,20.)-10.;\n    f.x+=mod(round(p.z/20.),2.)*10.;\n    albedo.b+=0.003/length(f.xz);\n    ret*=clamp(dot(p.xz,p.xz)*0.2,0.04,0.7);\n    albedo+=vec3(0.6,0.2,0)*0.04*(1./dot(f,f)*0.8+0.8);\n    return ret;\n}\nvec3 N(vec3 p){\n    float e=0.001;\n    float d=dist(p);\n    return normalize(vec3(d-dist(vec3(p.x-e,p.yz)),d-dist(vec3(p.x,p.y-e,p.z)),d-dist(vec3(p.xy,p.z-e))));\n}\n#define rot(x) mat2(cos(x),sin(x),-sin(x),cos(x))\nvoid mainImage( out vec4 col, in vec2 co )\n{\n    col=vec4(0);\n    for(int I=0;I<4;I++){\n        vec2 uv=(co+vec2(I/2,I%2)*0.25)/iResolution.xy-0.5;\n        uv*=normalize(iResolution.xy);\n        vec3 o=vec3(0,0,12.+iTime);\n        vec3 d=normalize(vec3(uv,-1));\n        mat2 m2=rot(0.8+sin(iTime*0.1)*0.5);\n        o.yz*=m2;\n        d.yz*=m2;\n        float t=0.1;\n        float x=1.0;\n        vec3 att=vec3(1);\n        albedo=vec3(0.5);\n        float i=0.;\n        while(i<12.){\n            while(t<4000.&&x>0.001){\n                x=dist(o+d*t);\n                t+=x;\n\n            }\n            \n            if(t>4000.)break;\n            o=o+d*t;\n            d=reflect(d,N(o));\n            att*=albedo*(dot(d,vec3(0,1,0))*0.5+0.5);\n            //att-=t*0.03;\n            t=0.1;\n            x=1.0;\n            i++;\n        }\n\n\n\n        col.rgb+=clamp(att,0.,1.)*0.25;\n    }\n    //if(t<1000.)col.rgb+=N(o)*0.5+0.5;\n    //col/=2.;\n    col=sqrt(col);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 107, 107, 258], [259, 259, 278, 278, 548], [549, 549, 564, 564, 713], [764, 764, 808, 808, 1718]]}
{"id": "7dBfDt", "name": "Checkerboard Truchet", "author": "SnoopethDuckDuck", "description": "(not sure if this is actually a truchet tiling)\n\nMight try it in 3D + would be cool for procgen shapes if you abs(uv.x) and cut out a region \n\nsmall bug: hash messes up around 0,0, y=0 line, idk why. (hence uv.x +=10.)\n", "tags": ["e"], "likes": 11, "viewed": 293, "published": 3, "date": "1647352722", "time_retrieved": "2024-07-30T16:58:40.130452", "image_code": "float h21 (vec2 uv, float sc) {\n    uv = mod(uv, sc);\n    return fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat line(vec2 uv, float width) {\n    return max(-uv.y + width, abs(uv.x));\n}\n\nfloat curve(vec2 uv) {\n    return abs(length(uv-0.5) - 0.5);\n}\n\nfloat shape(vec2 uv, vec4 h, float width) {\n    if (h.x + h.y + h.z + h.w == 0.)\n        return 0.;\n         \n    // center circle to round off line segments\n    float d = length(uv);     \n         \n    // draw line segment from center to edge (-width offset for center circle)\n    d = mix(d, min(d, line(uv,     width)), h.x);\n    d = mix(d, min(d, line(uv.yx,  width)), h.y);\n    d = mix(d, min(d, line(-uv,    width)), h.z);\n    d = mix(d, min(d, line(-uv.yx, width)), h.w);\n    \n    // draw quarter circle between 2 edges\n    d = mix(d, min(d, curve(vec2(uv.x, uv.y))),   h.x * h.y);\n    d = mix(d, min(d, curve(vec2(uv.x, -uv.y))),  h.y * h.z);\n    d = mix(d, min(d, curve(vec2(-uv.x, -uv.y))), h.z * h.w);\n    d = mix(d, min(d, curve(vec2(-uv.x, uv.y))),  h.w * h.x);\n    \n    float k = 6./iResolution.y;\n    return smoothstep(-k, k, -d + width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        \n    // change me!\n    float width = 0.25;\n    float threshold = 0.5;  \n    \n    float sc = 18.;\n    // uv.x = abs(uv.x);\n    // uv += floor(iTime)/sc;\n        \n    uv.x += 10. + 0.1 * iTime;    \n        \n    vec2 ipos = floor(sc * uv) + 0.;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    // arbitrary values - hash repetition, offset\n    float rep = 302.; \n    float val = 0.01;   \n    \n    // Checkerboard pattern:\n    // black cells choose edges for themselves + white cells\n    // white cells look at black cells to find edges\n    // construct pattern for cell based on edge configuration\n    float s = 0.;\n    if (mod(ipos.x + ipos.y, 2.) == 0.) {\n        vec4 h = vec4(h21(ipos,            rep),  // up\n                      h21(ipos + val,      rep),  // right\n                      h21(ipos + 2. * val, rep),  // down\n                      h21(ipos + 3. * val, rep)); // left ( I think* )\n        h = step(h, vec4(threshold));\n        s = shape(fpos, h, width);\n    } else {\n        vec4 h = vec4(h21(ipos + vec2(0,1) + 2. * val, rep),  // up's down\n                      h21(ipos + vec2(1,0) + 3. * val, rep),  // right's left\n                      h21(ipos - vec2(0,1),            rep),  // down's up\n                      h21(ipos - vec2(1,0) + val,      rep)); // left's right\n        h = step(h, vec4(threshold));\n        s = shape(fpos, h, width);        \n    }\n    \n    vec3 e = vec3(1);\n    vec3 col = s * pal(0.63 + 0.2 * uv.y, e, e, e, 0.15 * vec3(0,1,2)/3.);\n    col += (1.-s) * pal(0.57 + 0.23 * uv.y, e, e, e, 0.15 * vec3(0,1,2)/3.);\n   // col = vec3(s,0,0.22);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 124], [126, 126, 160, 160, 204], [206, 206, 228, 228, 268], [270, 270, 313, 313, 1124], [1126, 1126, 1183, 1183, 2878]]}
{"id": "ss2BDc", "name": "Hexagon Triangle Wedge Pattern", "author": "Shane", "description": "An irregular pinwheel tile pattern consisting of hexagons and triangle wedges.", "tags": ["triangle", "hexagon", "pattern", "tile", "pinwheel", "irregular", "semiregular"], "likes": 42, "viewed": 650, "published": 3, "date": "1647351654", "time_retrieved": "2024-07-30T16:58:41.023066", "image_code": "/*\n\n\tHexagon Triangle Wedge Pattern\n\t------------------------------\n    \n    I haven't posted anything in a while due to Shadertoy having problems\n    dealing with excess traffic -- If you're going to have a website problem, \n    too much popularity would be the one you'd want to have. :) Having said \n    that, I doubt it's been a fun couple of weeks for the creators. \n    \n    Anyway, this is a simple rendering of one of the many cliche hexagon grid \n    based patterns that exist. I'm sure most have seen this one around.  \n    \n    There's not really much to it: Create a hexagon grid, render some hexagons \n    in the centers, then construct triangles around the hexagon edges in a \n    pinwheel fashion. How you do that is down to common sense. If you know \n    how to move, rotate and render 2D objects, then it shouldn't give you too\n    much trouble.\n    \n    The default pattern is kind of interesting, given the fact that the triangles\n    look like they infinitly overlap one another. There's also an option below \n    to display a semi-regular hexagon triangle pinwheel arrangement.\n    \n    There would be faster ways to render the pattern. The brute force 7-tap \n    method I've employed works well enough, but you could get that number down. \n    I also have an extruded version ready to go. It was surprisingly easy to \n    put together, and I intend to post that a little later.\n\n\t\n    \n    Other Tiled Pattern Examples:\n\n    // Here's a much more interesting irregular tiling.\n    Moebius Lizard - iapafoto \n    https://www.shadertoy.com/view/wtjyz1\n    \n    // Heaps of different tiled configurations.\n    Wythoff Uniform Tilings + Duals - fizzer\n    https://www.shadertoy.com/view/3tyXWw\n    \n    // A decent irregular tiling example.\n    escherized tiling 2 (WIP) - Fabrice\n    https://www.shadertoy.com/view/lsdBR7\n    \n\n*/\n\n\n// Color scheme - White: 0, Random color: 1, Ordered color: 2.\n#define COLOR 1\n\n// A pinwheel arrangement with wedge looking triangles. Commenting this \n// out will result in a regular hexagon triangle pinwheel arrangement.\n#define WEDGE\n\n// Show the hexagon grid that the pattern is based on. Knowing where\n// the cell boundary lies can be helpful.\n//#define SHOW_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat hash21(vec2 p){ \n   \n    //return texture(iChannel0, p).x;\n    // IQ's vec2 to float hash.\n    //return fract(sin(dot(p, vec2(57.609, 27.781)))*43758.5453); \n     \n    // Using a very slight variation on Dave Hoskin's hash formula, \n    // which can be found here: https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    \n}\n\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon edge and vertex IDs. They're useful for neighboring edge comparisons,\n// etc. Multiplying them by \"s\" gives the actual vertex postion.\n//\n// Vertices and edges: Clockwise from the left.\n//\n// Note that these are all six times larger than usual. We're doing this to \n// get rid of decimal places, especially those that involve division by three.\n// I't a common accuracy hack. Unfortunately, \"1. - 1./3.\" is not always the \n// same as \"2./3.\" on a GPU.\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top hexagon.\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n}\n\n// Triangle bound.\nfloat getTri(vec2 p){\n\n    p.x = abs(p.x);\n    return max(dot(p, s/2.), -p.y*s.y);\n}\n\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Global scale factor.\n    #ifdef WEDGE\n    const float sc = 3.;\n    #else\n    const float sc = 4.5;\n    #endif\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = mat2(1, 0, 0, 1);//rot2(-3.14159/24.); // Scene rotation.\n    vec2 camDir = sRot*normalize(s); // Camera movement direction.\n    vec2 ld = sRot*vec2(-cos(3.14159/5.), -sin(3.14159/5.)); // Light direction.//-.5, -1.732\n    vec2 p = sRot*uv*sc + camDir*s.xy*iTime/6.; \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    float df = 1e5, dfHi = 1e5;\n    \n    // Cell object ID and cell arrangement ID.\n    vec2 id;\n    float tID;\n    \n    // A cell ratio factor for the two arrangements.\n    #ifdef WEDGE \n    const float divF = 1./6.;\n    #else\n    const float divF = 1./4.;\n    #endif\n    \n    // Set the initial ID and minimum distance to the central hexagon.\n    df = gHx - divF;\n    #ifdef WEDGE\n    id = p4.zw*18.;\n    #else\n    id = p4.zw*12.;\n    #endif\n    \n    // Pinwheel ID for the hexagon: There are seven objects per cell. The\n    // central hexagon ID is the highest and the surrounding pinwheel objects\n    // are numbered zero through to five.\n    tID = 6.; \n    \n    // Offset hexagon for highlighting purposes.\n    dfHi = getHex(p4.xy - ld*.001) - divF;\n     \n     \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){ \n            \n            \n            #ifdef WEDGE \n            \n                // Triangle 1 central offset index. These numbers have been multiplied\n                // by 18 to produce integers for more index accuracy... It's related to\n                // GPUs giving different results for \"1. - 1./3.\" and \"2./3.\".  \n                vec2 indx1 = vID[i];\n\n                // Local coordinates.\n                vec2 q = p4.xy - indx1*s/18.;\n                // The sign matters for bump mapping, etc.\n                mat2 mR = rot2(6.2831/6.*float(i));\n                // Triangle one (and highlight field).\n                float tri1 = getTri(mR*q) - divF;\n                float tri1B = getTri(mR*(q - ld*.001)) - divF;\n\n\n                // Go to the neighboring cell and retrieve the opposite overlapping\n                // triangle by rotating forward 4 vertices.\n                //\n                // Triangle 2 central offset index.\n                vec2 indx2 = eID[i]*3. + vID[(i + 4)%6];\n                // Local coordinates.\n                q = p4.xy - indx2*s/18.;\n\n                // The neighboring triangle (and highlight field). See the image\n                // for a clearer picture.\n                float tri2 = getTri(mR*q) - divF;\n                float tri2B = getTri(mR*(q - ld*.001)) - divF;\n                // Using the neighboring triangle to chop a little wedge out of\n                // the main triangle. Obviously, that's what gives it a V-shape.\n                tri1 = max(tri1, -tri2);\n                tri1B = max(tri1B, -tri2B);\n\n                // Set the minimum distance and IDs for the inner object.\n                if(tri1<df) {\n\n                    df = tri1;\n                    tID = float(i);\n                    id = p4.zw*18. + indx1;\n                }\n\n                // Set the minimum distance and IDs for the outer object. If you\n                // don't include this, the neighboring triangle won't fill in the\n                // V-shape's wedge gap.\n                if(tri2<df) {\n\n                    df = tri2;\n                    tID =  float((i + 4)%6);\n                    id = p4.zw*18. + indx2;\n                }            \n\n                // Offset distance field value for highlighting. \n                dfHi = min(dfHi, min(tri1B, tri2B));\n            \n            #else\n            \n                vec2 indx1 = vID[i]; // Vertex postion index.\n                vec2 q = p4.xy - indx1*s/12.; // Local coordinates.\n                mat2 mR = rot2(6.2831/6.*float(i));\n                // Triangle one (and highlight field).\n                float tri1 = getTri(mR*q) - divF; //1./.8660254+1.;//\n                float tri1B = getTri(mR*(q - ld*.001)) - divF;\n\n                // Set the minimum distance and IDs for the inner object.\n                if(tri1<df) {\n\n                    df = tri1;\n                    tID = float(i);\n                    id = p4.zw*12. + indx1;\n                }\n\n                // Offset distance field value for highlighting. \n                dfHi = min(dfHi, tri1B);\n            \n            #endif\n\n    }\n    \n    // Giving the object some edging and rescaling the ID\n    #ifdef WEDGE\n    float ew = .018;\n    id /= 18.;\n    #else\n    float ew = .025;\n    id /= 12.;\n    #endif\n    //\n    df += ew;\n    dfHi += ew;\n     \n    \n     \n    // Using the IDs for coloring.\n    #if COLOR == 1\n    float rnd2 = hash21(id);\n    vec3 tCol = .5 + .45*cos(6.2831*rnd2 + vec3(0, 1, 2)*1.5);\n    // if(tID>5.5) tCol = vec3(.8); // White hexagons.\n    #elif COLOR == 2\n    #ifndef WEDGE\n    // This is a bit of a cop-out, but I didn't feel like arranging for all \n    // colors to line up in a manner similar to the ordered wedge arrangement... \n    // It could be done by a less lazy person though. :)\n    if(tID<5.5) tID = mod(tID, 2.) + 2.;\n    #endif\n    vec3 tCol = .5 + .45*cos(6.2831*tID/6. + vec3(0, 1, 2)*1.5 + .5);\n    if(tID>5.5) tCol = vec3(.8); // White hexagons.\n    #else\n    vec3 tCol = vec3(.8);\n    #endif\n    \n    // Evening the color intensity a bit.\n    //tCol /= (.75 + dot(tCol, vec3(.299, .587, .114))*.5);\n    \n    /*\n    // Textures work too, but they're not used here.\n    vec3 tx = texture(iChannel0, p/8.).xyz; tx *= tx;\n    tx = smoothstep(-.1, .5, tx);\n    vec3 tx2 = texture(iChannel1, id/8.).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.1, .5, tx2);\n    tCol *= tx*tx2*1.5;\n    */\n \n    // Applying some directional derivative based highlighting. \n    float b = max(dfHi - df, 0.)/.001;\n    tCol = tCol*.65 + mix(tCol, vec3(1), .05)*b*b*.65;\n     \n \n    // Subtle line pattern overlay.\n    vec2 ruv = rot2(-3.14159/3.)*p;\n    float lSc = (120./sc);\n    float pat = (abs(fract(ruv.x*lSc - .5) - .5) - .125)/lSc/2.;\n    tCol *= smoothstep(0., sf, pat)*.35 + 1.;\n     \n    // Applying the object color to the background.\n    vec3 col = mix(vec3(0), tCol, (1. - smoothstep(0., sf, df)));\n \n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(gHx - .5) - .012))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(gHx - .5) - .012)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, abs(gHx - .5) - .003)));\n    #endif\n   \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2BDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2224, 2257, 2279, 2279, 2337], [2339, 2339, 2360, 2647, 2768], [3605, 3704, 3725, 3755, 3809], [3811, 3830, 3851, 3851, 3914], [3917, 4134, 4155, 4155, 4353], [4357, 4357, 4411, 4459, 11377]]}
{"id": "7d2BW3", "name": "Fast Voronoi/Cell Noise", "author": "Dragonpeak", "description": "A fast Voronoi function. I don't know if something like this already exists but I needed it for a project and though I might as well share it. I am sure it can be optimised further.", "tags": ["voronoi", "noise", "fast"], "likes": 0, "viewed": 249, "published": 3, "date": "1647347401", "time_retrieved": "2024-07-30T16:58:41.762090", "image_code": "//A fast Voronoi function. \n//I don't know if something like this already exists but I needed it for a project and though I might as well share it.\n//I am sure it can be optimised further.\n\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 rand2(vec2 v)\n{\n    //random vec2 from 0 to 1 on each component. uses pcg2d, above for hashing.\n    //multiplies the input vec2 by a large value and then converts it to a uvec2 for the hash function\n    //divides the hash output by the max int to get it into the 0-1 range\n    return vec2(pcg2d(uvec2(v*87198.5193)))/float(0xffffffffu);\n}\n\nvec2 get_point_in_cell(vec2 cell, float offset)\n{\n    //gets a random point in the input cell, offset can be incremented to generate multiple different points in the cell\n    //the point is generated within a 0-1 square which is then offset by the cell\n    return rand2(cell+offset*165.426812)+cell;\n}\n\nfloat get_min_dist_in_cell(vec2 uv, vec2 cell, int amt)\n{\n    // gets the distance to the closest point in the cell from the input point\n    // amt controls the number of points in the cell which are then generated using the above function\n    float dist = 999999.;\n    for(int i = 0; i < amt; i++)\n    {\n        \n        dist = min(dist, distance(uv, get_point_in_cell(cell, float(i))));\n    }\n    return dist;\n}\n\nfloat fast_voro(vec2 uv, int points_per_cell)\n{\n    //fast voronoi or worley like noise function \n    //checks the cell of the input point and all adjacent cells to find the smallest distance to a point \n    //using more points per cell can improve the variance of the noise but will also slow the generation as it has to check points_per_cell*9 points\n    // at 1 ppc only 9 distance calculations are needed while at 10 ppc 90 calculations are required, for example\n    float dist = 9999.;\n    vec2 current_cell = floor(uv);\n    \n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            dist = min(dist, get_min_dist_in_cell(uv, current_cell+vec2(x,y), points_per_cell));\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv*=10.;\n\n    float dist = fast_voro(uv, 1);\n\n    // Output to screen\n    fragColor = vec4(vec3(dist),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 212, 261, 470], [472, 472, 492, 749, 815], [817, 817, 866, 1069, 1118], [1120, 1120, 1177, 1359, 1533], [1535, 1535, 1582, 2001, 2283], [2285, 2285, 2342, 2392, 2551]]}
{"id": "NssBDM", "name": "Vaporwave thing", "author": "z0rg", "description": "A chill vaporwave landscape inspired by album covers of bands I love.", "tags": ["vapor", "chill"], "likes": 8, "viewed": 403, "published": 3, "date": "1647340521", "time_retrieved": "2024-07-30T16:58:42.534026", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456)*123.456, 1.);\n}\n\nmat2 r2d(float a) { float c= cos(a), s= sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n// Thanks IQ\n// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.5;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\n\n#define GROUND_MAT 0.\n#define BALL_MAT 1.\n#define TUBEA_MAT 2.\n#define TUBEB_MAT 3.\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n    \n    float bouboules = 1000.;\n    float coef = 10.8;\n    bouboules = smin(bouboules, length(p-vec3(4.+cos(iTime*.3),-25.+sin(iTime*1.2)*3.,1.))-3., coef);\n    bouboules = smin(bouboules, length(p-vec3(-4.+2.*sin(iTime),-25.+3.*sin(iTime*.35),7.+3.*sin(iTime)))-5., coef);\n    bouboules = smin(bouboules, length(p-vec3(-2.+5.*cos(iTime),-20.+7.*sin(-iTime*.5),11.+cos(iTime*.5)))-2., coef);\n    acc = _min(acc, vec2(bouboules, BALL_MAT));\n    \n    \n    acc = _min(acc, vec2(-p.y, GROUND_MAT));\n    \n    acc = _min(acc, vec2(length(p.zy-vec2(-3.,-23.))-.01, TUBEA_MAT));\n    acc = _min(acc, vec2(length(p.xy-vec2(12.,-20.))-.01, TUBEB_MAT));\n    return acc;\n}\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        if (res.y == TUBEA_MAT)\n            accCol += (1.-sat(res.x/3.))*vec3(.75,.1,.3)*.4;\n        if (res.y == TUBEB_MAT)\n            accCol += (1.-sat(res.x/3.))*vec3(.1,.75,.3)*.4;\n        float f = sat((res.x-20.)*.5);\n        p+= rd*res.x*mix(1., 150., f);\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    float f = sat(pow(abs(rd.y-.05)*2., .65));\n    vec3 cols[6];\n    cols[0] = vec3(0.910,0.502,0.392);\n    cols[1] = vec3(0.929,0.427,0.290);\n    cols[2] = vec3(0.902,0.663,0.431);\n    cols[3] = vec3(0.800,0.643,0.678);\n    cols[4] = vec3(0.482,0.435,0.631);\n    cols[5] = vec3(0.055,0.141,0.294);\n    \n    float cnt = 5.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    vec3 col =  mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n    col = pow(col, vec3(.8));\n    col= col*sat(.7+.3*dot(rd, vec3(0.,0.,1.)))\n    +col*pow(sat(.7+.3*dot(rd, vec3(0.,0.,1.))), 5.)*.5;\n    return col;//*sat(-rd.y*10000.+200.);\n}\n\nvec3 getMat(vec3 res, vec3 rd, vec3 p, vec3 n)\n{\n    vec3 albedo = vec3(0.);\n    if (res.z == GROUND_MAT)\n    {\n        albedo = vec3(.0)+vec3(.3)*texture(iChannel0, p.xz*.001).x;\n    }\n    if (res.z == TUBEA_MAT || res.z == TUBEB_MAT)\n        albedo = vec3(1.);\n    return albedo;\n}\n\nfloat _sqr(vec2 uv, vec2 sz)\n{\n    vec2 l = abs(uv)-sz;\n    return max(l.x, l.y);\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv *= r2d(.15);\n    vec2 ouv = uv;\n    vec3 col = vec3(0.);\n    \n    float d = 25.;\n    float t = iTime*0.2+2.;\n    vec3 ro = vec3(sin(t)*d,-20.,-5.+cos(t)*d);\n    vec3 ta = vec3(0.,-22.5,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    float maxDist = 100.;\n    float dist = maxDist;\n    vec3 res = trace(ro, rd, 512);\n    vec3 accLightA = accCol;\n    if (res.y > 0.)\n    {\n        dist = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(res, rd, p, n);\n        float reflf = 1.;\n        vec3 refl = vec3(0.);// normalize(reflect(rd, n)+0.3*(vec3(rand(), rand(), rand())-.5));\n        float spec = mix(0.4, 0., sat(sin(p.y*2.)*100.));\n\n        if (res.z == BALL_MAT)\n        {\n            refl = normalize(reflect(rd, n)+spec*(vec3(rand(), rand(), rand())-.5));\n        }\n        else if (res.z == GROUND_MAT)\n        {\n            refl = normalize(vec3(rand(), rand(), rand()-.5));\n            if (dot(refl, vec3(0.,1.,0.)) > 0.)\n                refl = -refl;\n\n            reflf = .125;\n        }\n        if (length(refl) > .1)\n        {\n            vec3 resrefl = trace(p+n*0.01, refl, 128);\n            if (resrefl.y > 0.)\n            {\n                vec3 prefl = p+refl*resrefl.y;\n                vec3 nrefl = getNorm(prefl, resrefl.x);\n                \n                col += getMat(resrefl, refl, prefl, nrefl);\n            }\n            else\n                col += getEnv(refl);\n            col += accCol;\n            if (spec > 0.1)\n                col = col * .5;\n        }\n        col += getEnv(refl)*reflf;\n\n    }\n    else\n        col = getEnv(rd);\n    col += accLightA;\n    col = sat(col);\n    rd.y = -abs(rd.y);\n    col = mix(col, getEnv(rd), 1.-sat(exp(-dist*.01)));\n    \n    float rect2 = abs(_sqr(uv*r2d(.25), vec2(.43)))-0.001;\n    col = mix(col, vec3(1.000,0.322,0.749)*5., 1.-sat(rect2*400.));\n    col = mix(col, vec3(0.482,0.059,1.000)*5., (1.-sat(rect2*40.))*.1);\n\nfloat rect = abs(_sqr(uv, vec2(.35)))-0.001;\n    col = mix(col, vec3(1.000,0.322,0.749)*5., 1.-sat(rect*400.));\n    col = mix(col, vec3(1.000,0.322,0.749)*5., (1.-sat(rect*40.))*.2);\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    float stp = .005;\n    uv = floor(uv/stp)*stp;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec3 col = rdr(uv);\n    col *= 2./(col+1.);\n    col = pow(col, vec3(2.2));\n    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .75);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssBDM.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 553]]}
{"id": "7d2fWc", "name": "deusexgold", "author": "satoshishader", "description": "deusexgold", "tags": ["deusex"], "likes": 4, "viewed": 221, "published": 3, "date": "1647309768", "time_retrieved": "2024-07-30T16:58:43.388741", "image_code": "\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n\nvoid mainImage( out vec4 frag_color, vec2 frag_coord )\n{  \n\t\n\n    frag_coord -= iResolution.xy/200.;\n    //frag_color -= frag_color;\n\tfrag_color = vec4(0,0,0,1.0); // keeps alpha\n    \n    for (float i=2.; i<40.; i+=2.) {\n        uvec2 p = uvec2( frag_coord * (i*.04+.96)+iTime*100. + 10000.); \n        uint temp = ( p.x + uint(100000.*i) ) \n        \t          ^  // try ^ & |\n        \t          p.y;\n  \n        frag_color += step(.98, hash11(temp)) * vec4(2.23/3.,1.16/3.,0.12/3.,1.) / i;\n    }\n\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2fWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 178, 178, 248], [251, 251, 307, 307, 751]]}
{"id": "7sjfD3", "name": "dientes-bloques", "author": "jorge2017a2", "description": "dientes-bloques", "tags": ["dientesbloques"], "likes": 3, "viewed": 214, "published": 3, "date": "1647294203", "time_retrieved": "2024-07-30T16:58:44.275370", "image_code": "//----------image\n//por jorge2017a2-\n//dientes bloques 14-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nvec3 pobj;\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat random(vec2 _st) \n{ return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat Cuadrosvarios(vec2 p )\n{\n    float dist=9999.9;\n    int num=14,i=1;\n    \n    for(int i=0; i<num;i++)\n    {\n        float rndv=random(vec2(i,iResolution.x-float(i+1)) )*4.0;\n        vec2 pos=vec2(float(i)*1.0,0.0);\n        float d1= sdBox(p+pos, vec2(0.5,1.0+rndv) );\n        dist= unionSDF(d1, dist);\n    }\n      return dist;\n}\n\nvec2 cuadrotodo01(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n     p.x= opRep1D(p.x, 12.9);\n    float c1= Cuadrosvarios(p.xy-vec2(6.0,1.0) );\n    float d1= sdBox(p, vec3(10.0,6.0,2.0) );\n    float inter=intersectSDF(d1,c1);\n    res =opU2(res, vec2(inter,100.0));\n    return res;\n }   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    vec3 p1=p,p2=p;\n    p1.y=abs(p.y)-9.0;\n    p2.y=abs(p.y)-6.0;\n    float t=iTime*2.0;\n    vec2 re1= cuadrotodo01(p1+vec3(t,0.0,0.0));\n    vec2 re2= cuadrotodo01(p1+vec3(3.5-t,2.5*sin(t),6.0));\n    res =opU2(res, vec2(re1.x,100.0));\n    res =opU2(res, vec2(re2.x,101.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    float occ = occlusion(hit, norm); // occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0); // back\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;   \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/8., nor)*1.5; }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n     sky = mix(vec3(.0, .1, .4)*sky, vec3(1.0), 0.5 - rd.x*rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n         \n   if (id_color==100)\n   { float t=iTime*2.0;\n     vec3 pnew=p+vec3(t,0.0,0.0);\n     return  getColorTextura(pnew, n, 100); \n   }\n   \n   if (id_color==101)\n   { float t=iTime*2.0;\n    vec3 pnew=p+vec3(3.5-t,2.5*sin(t),6.0);\n   return  getColorTextura(pnew, n, 101); \n   }\n   \n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   light_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,2.0,-22.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 576, 576, 597], [598, 598, 630, 630, 714], [717, 717, 764, 764, 791], [792, 792, 835, 835, 862], [863, 863, 911, 911, 939], [940, 978, 1014, 1014, 1059], [1061, 1061, 1086, 1086, 1154], [1157, 1157, 1194, 1194, 1268], [1270, 1270, 1300, 1300, 1603], [1605, 1605, 1632, 1632, 1884], [1889, 1889, 1914, 1914, 2293], [2295, 2295, 2319, 2319, 2481], [2483, 2483, 2531, 2531, 2861], [2863, 2863, 2907, 2907, 3233], [3235, 3235, 3272, 3272, 3533], [3535, 3535, 3620, 3620, 4551], [4553, 4553, 4602, 4602, 4738], [4740, 4740, 4833, 4833, 4963], [4965, 4965, 4997, 4997, 5260], [5263, 5263, 5331, 5331, 5635], [5638, 5638, 5665, 5665, 5754], [5756, 5756, 5814, 5814, 5862], [5865, 5865, 5888, 5888, 6006], [6008, 6008, 6039, 6039, 6660], [6663, 6663, 6720, 6720, 7108]]}
{"id": "fd2fDc", "name": "Dark kelp", "author": "lwswl", "description": "some procedural kelp", "tags": ["raymarching", "kelp"], "likes": 0, "viewed": 194, "published": 3, "date": "1647292325", "time_retrieved": "2024-07-30T16:58:45.008410", "image_code": "vec3 albedo=vec3(1);\nfloat alpha=1.;\n#define rot(p) mat2(cos(p),sin(p),-sin(p),cos(p));\nfloat dist(vec3 p){\n    float r=10.;\n    vec3 l=p;\n    \n    p.z+=round(mod(p.x-r*0.8,r*1.6)-r*0.8);\n    p=mod(p-r*0.8,r*1.6)-r*0.8;\n    \n    p.xz*=rot(p.y*0.1);\n    p.x+=1.;\n    vec3 op=p;\n    float d=r-length(p);\n    d=max(d,-l.y);\n    d=min(d,r-length(p.xz));\n    albedo=vec3(0);\n    vec3 op2=op;\n    for(float i=0.;i<4.;i++){\n        r*=0.1;\n        p.y+=round(mod(p.x+p.z,r*1.6));\n        p.xz*=rot(p.y*0.01*r);\n        p.yz*=rot(iTime*0.1);\n        p.x+=r*0.1;\n        p=mod(p-r*0.8,r*1.6)-r*0.8;\n        d=max(d,r-length(p));\n        albedo+=length(p-op2)*0.008;\n        albedo+=vec3(1,0.3,0.1)*length(op-p)*0.005;\n        \n        op2=p;\n    }\n    return d;\n}\nvec3 normal(vec3 p){\n    float e=0.001;\n    return normalize(vec3(dist(vec3(p.x+e,p.yz))-dist(vec3(p.x-e,p.yz)),\n                dist(vec3(p.x,p.y+e,p.z))-dist(vec3(p.x,p.y-e,p.z)),\n                dist(vec3(p.xy,p.z+e))-dist(vec3(p.xy,p.z-e))));\n}\nvoid mainImage( out vec4 col, in vec2 co )\n{\n    vec2 uv = (co/iResolution.xy-0.5)*normalize(iResolution.xy);\n    vec3 d=normalize(vec3(uv,-1));\n    vec3 o=vec3(100,0,0);\n    o.xz*=rot(iTime*0.1);\n    d.xz*=rot(iTime*0.1);\n    float t=0.1;\n    float f=1.0;\n    while(f>0.01&&t<1000.){\n        f=dist(o+d*t);\n        t+=f*0.8;\n    }\n    col=vec4(0);\n    if(t<1000.){\n        o=o+d*t;\n        col.rgb-=t*0.01;\n        \n        col.rgb+=clamp(albedo,0.,1.);\n        col.rgb=clamp(col.rgb,0.,1.);\n        \n        \n    }\n    col.rgb+=vec3(1,0.5,0.9)*0.2*clamp(t*0.001,0.,1.);\n    col*=3.;\n    col=sqrt(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 107, 107, 754], [755, 755, 775, 775, 1003], [1004, 1004, 1048, 1048, 1609]]}
{"id": "NsjBDc", "name": "Point Light Cloud", "author": "intrakits", "description": "testing making point lights in clouds", "tags": ["cloud", "light"], "likes": 3, "viewed": 249, "published": 3, "date": "1647273449", "time_retrieved": "2024-07-30T16:58:45.852154", "image_code": "//3d cellular tiling reference: https://www.shadertoy.com/view/ld3Szs\n//cloud reference:              https://www.shadertoy.com/view/4sXGRM\n\n#define _StepSize 200.\n#define _VolDepth 10000.0\n#define _CloudScale 7.\n#define _CloudOffset 0.\n#define _DensityThreshold .1\n#define _DensityMultiplier .00005\n\n\n#define _DarknessThreshold .3\n#define _LightAbsorbtion 100.\n#define _LightAbsorbtionTowardsSun 100.\n#define  _NumStepsLight 6\n#define _PhaseVal 100.\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nvec2 cloudHeight = vec2(-2000,2000);\n\nvec3 lightDir = normalize(vec3(0.1,.1,.5));\n\n\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.166));\n    \n}\n\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n\nvec3 camera(float time)\n{\n    return vec3(0,0., time*2000.);\n}\nfloat getDensity(vec3 pos){\n    float n1 = smoothstep(.7,.1,cellTile(pos*.00005));\n    float n2 = smoothstep(0.,.5,cellTile(pos*.0001));\n   // float n3 = smoothstep(0.,.4,cellTile(pos*.00001));\n   // float n4 = smoothstep(0.,.4,cellTile(pos*.0002));\n    float alpha = smoothstep(0.5, 1.0,n1*n2);\n    \n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    return alpha;\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n    float f = 0.5000 * getDensity(p);\n    p = m * p;\n    f += 0.2500 * getDensity(p);\n    p = m * p;\n    f += 0.1666 * getDensity(p);\n    p = m * p;\n    f += 0.0834 * getDensity(p);\n    \n    return f;\n}\n\nvec3 lightmarch(vec3 pos){\n   /* vec3 dirToLight = lightDir;\n    float totalDensity = 0.;\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = fbm(pos);//getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    return _DarknessThreshold + transmittance * (1.-_DarknessThreshold);\n    */\n    vec3 dirToLight = vec3(6000.*sin(iTime),0.,6000.)-pos;\n    float attenuation = 1./(dot(dirToLight,dirToLight)*4.);\n    float totalDensity = 0.;\n    dirToLight=normalize(dirToLight);\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = fbm(pos);//getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = attenuation*10000000.*exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    vec3 col = vec3((_DarknessThreshold + transmittance * (1.-_DarknessThreshold)));\n   // return smoothstep(.0,1.,transmittance)*vec3(1,0,0);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = sin(iTime*.1);\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + .1);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    vec3 lightE = vec3(0.);\n    float transmittance = 1.;\n    for (float depth = 0.0; depth < _VolDepth; depth += _StepSize)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudHeight.x < ray.y && ray.y < cloudHeight.y)\n        {\n            \n            float alpha =fbm(ray);//getDensity(pos);\n            \n            alpha = (1.0 - sum.a) * alpha;\n            if(alpha >0.){\n                vec3 lightTransmittance = lightmarch(ray);\n                lightE+=alpha*_StepSize*transmittance*lightTransmittance*_PhaseVal;\n                transmittance*= exp(-alpha*_StepSize*_LightAbsorbtion);\n                if(transmittance < 0.01){\n                  break;\n                }\n            }\n            sum += vec4(vec3(1) * alpha, alpha);\n        }\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb= lightE;\n    float sundot = clamp(dot(fragAt, lightDir), 0.0, 1.0);\n    vec3 col = 0.8 * (vec3(0,0,1));\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    col = mix(col, sum.rgb, 1.-transmittance);\n\n    //col=vec3(smoothstep(.0,.7,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.5,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.4,cellTile(vec3(uv.x*2.,uv.y*2.,0.))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[610, 610, 638, 638, 759], [761, 761, 787, 787, 1323], [1326, 1326, 1351, 1351, 1388], [1389, 1389, 1416, 1416, 1773], [1775, 1805, 1824, 1841, 2044], [2046, 2046, 2072, 2510, 3174], [3175, 3175, 3232, 3232, 5025]]}
{"id": "fsjBDc", "name": "Basic And Fast Dissolve Shader", "author": "Sayuri", "description": "Can be faster with better hash/noise.", "tags": ["dissolve"], "likes": 0, "viewed": 231, "published": 3, "date": "1647273359", "time_retrieved": "2024-07-30T16:58:46.647029", "image_code": "float hash (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n\n    // Loop of octaves\n    for (int i = 0; i < 3; i++) {\n        value += amplitude * noise(st);\n        st *= 2.0;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Use fbm to decrease alpha\n    float alpha = smoothstep(sin(iTime), 1.0, fbm(uv * 10.0));\n   \n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0, uv).xyz * alpha, alpha);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 132], [134, 212, 235, 235, 607], [609, 609, 630, 652, 869], [872, 872, 929, 929, 1162]]}
{"id": "fs2fWc", "name": "Basic and Fast 9-Pass Blur", "author": "Sayuri", "description": "Made for GLES. Need to rander to a FBO first, then blur again.", "tags": ["blur"], "likes": 0, "viewed": 254, "published": 3, "date": "1647272633", "time_retrieved": "2024-07-30T16:58:47.557594", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u_dir = vec2 (0.0, 1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = vec4(0.0);\n    \n    //apply blurring, using a 9-tap filter with predefined gaussian weights\n\tcolor += texture(iChannel0, vec2(uv.x - 0.00625  * u_dir.x, uv.y - 0.01111111111 * u_dir.y)) * 0.0162162162;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.0046875  * u_dir.x, uv.y - 0.00833333333 * u_dir.y)) * 0.0540540541;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.003125  * u_dir.x, uv.y - 0.00555555555 * u_dir.y)) * 0.1216216216;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.0015625  * u_dir.x, uv.y - 0.00277777777 * u_dir.y)) * 0.1945945946;\n\n\tcolor += texture(iChannel0, uv) * 0.2270270270;\n\t\n\tcolor += texture(iChannel0, vec2(uv.x + 0.0015625  * u_dir.x, uv.y + 0.00277777777 * u_dir.y)) * 0.1945945946;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.003125  * u_dir.x, uv.y + 0.00555555555 * u_dir.y)) * 0.1216216216;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.0046875  * u_dir.x, uv.y + 0.00833333333 * u_dir.y)) * 0.0540540541;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.00625  * u_dir.x, uv.y + 0.01111111111 * u_dir.y)) * 0.0162162162;\n    \n    // Would be better with a FBO\n    \n    u_dir = vec2(1.0, 0.0);\n    \n\tcolor += texture(iChannel0, vec2(uv.x - 0.00625  * u_dir.x, uv.y - 0.01111111111 * u_dir.y)) * 0.0162162162;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.0046875  * u_dir.x, uv.y - 0.00833333333 * u_dir.y)) * 0.0540540541;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.003125  * u_dir.x, uv.y - 0.00555555555 * u_dir.y)) * 0.1216216216;\n\tcolor += texture(iChannel0, vec2(uv.x - 0.0015625  * u_dir.x, uv.y - 0.00277777777 * u_dir.y)) * 0.1945945946;\n\n\tcolor += texture(iChannel0, uv) * 0.2270270270;\n\t\n\tcolor += texture(iChannel0, vec2(uv.x + 0.0015625  * u_dir.x, uv.y + 0.00277777777 * u_dir.y)) * 0.1945945946;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.003125  * u_dir.x, uv.y + 0.00555555555 * u_dir.y)) * 0.1216216216;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.0046875  * u_dir.x, uv.y + 0.00833333333 * u_dir.y)) * 0.0540540541;\n\tcolor += texture(iChannel0, vec2(uv.x + 0.00625  * u_dir.x, uv.y + 0.01111111111 * u_dir.y)) * 0.0162162162;\n    \n\n    fragColor = color * 0.5;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2fWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2239]]}
{"id": "7ts3Rr", "name": "Glitcher [ppxxll]", "author": "robclouth", "description": "glitch", "tags": ["glitch"], "likes": 1, "viewed": 209, "published": 3, "date": "1647267727", "time_retrieved": "2024-07-30T16:58:48.383386", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec3 mask = texture(iChannel2, vUv).xyz; \n    \n    if(iMouse.z > 0.0)\n        fragColor = texture(iChannel0, vUv);\n    else{\n       fragColor = texture(iChannel1, fract(vUv + mask.xy * 0.5));\n    }        \n}", "buffer_a_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 uv1 ) \n{\n\tuv1 /= iResolution.xy * 0.5;\n    vec2 k = floor((simplex_noise(vec3(round(uv1), iTime))) * 5.0 * uv1.yx),\n       uv2 = round(k*uv1) / k;\n    float a = simplex_noise(vec3(uv1.x * 0.5, uv2.y * 0.5, iTime*0.2)),\n          b = simplex_noise(vec3(uv2.x * 0.5, uv1.y * 0.5, iTime*0.2));\n\tfloat v1 = 0.0;\n    if(a > .5) v1 += a;\n    if(b > .5) v1 -= b;\n    float v2 = 0.0;\n    if(b > .5) v2 += a;\n    if(a > .5) v2 -= b;\n    O =vec4(v1,v2,0.0,1.0);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ts3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]]}
{"id": "fsjBD3", "name": "texelFetch Test [ppxxll]", "author": "robclouth", "description": "Testing texelfetch on ios", "tags": ["test"], "likes": 0, "viewed": 182, "published": 3, "date": "1647266983", "time_retrieved": "2024-07-30T16:58:49.122410", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\nfragColor = col;\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 136]]}
{"id": "ssSfDc", "name": "Golden flow 4", "author": "zsjasper", "description": "Golden flow 4", "tags": ["goldenflow4"], "likes": 5, "viewed": 232, "published": 3, "date": "1647253711", "time_retrieved": "2024-07-30T16:58:49.871408", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ii = iTime*0.2;\n    vec2 q=0.5*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x,iResolution.y);\n\t\n\tfor(float i=1.0;i<40.0;i*=1.1)\n\t{\n\t\tvec2 o=q;\n\t\to.x+=(0.5/i)*cos(i*q.y+ii*0.297+0.03*i)+1.3;\t\t\n\t\to.y+=(0.5/i)*cos(i*q.x+ii*0.414+0.03*(i+10.0))+1.9;\n\t\tq=o;\n\t}\n\n\tvec3 col=vec3(0.5*sin(3.0*q.x)+0.5,0.5*sin(3.0*q.y)+0.5,sin(1.3*q.x+1.7*q.y));\n    float f=0.43*(col.x+col.y+col.z);\n\n\tfragColor=vec4(f+0.6,0.2+0.75*f,0.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 493]]}
{"id": "ssBBDc", "name": "flow flow", "author": "zsjasper", "description": "flow flow", "tags": ["flowflow"], "likes": 4, "viewed": 259, "published": 3, "date": "1647252443", "time_retrieved": "2024-07-30T16:58:50.677254", "image_code": "const float brightness = 40.;\nconst float speed = .3;\nconst int rings = 1024;\nconst float blur = .3;\nconst float offset = 6.;\nconst float peaks = 10.;\nconst float peakStrength = .5;\nconst float twisting = 1.;\n\nfloat rectSin(float p){\n\treturn sin(p) / 2. + .5;\n}\n\nfloat circle(float r, vec2 pos){\n\treturn abs(r - length(pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv =  uv * vec2(2) - vec2(1);\n    nuv.x /= (iResolution.y / iResolution.x);\n\n    vec3 col = vec3(0);\n    int iter = rings;\n    for(int i = 0; i < iter; i++){\n        float prog = float(i) / float(iter);\n        float angle = atan(nuv.x,nuv.y);\n        float radius = pow(rectSin(iTime * speed + prog * offset),2.);\n        radius += pow(radius,.3) * abs(rectSin(iTime / 1. + (angle + rectSin(iTime - radius) * twisting) * peaks)) * peakStrength;\n        vec3 ringColor = vec3(\n            (1.5 - prog - radius) / (radius + .1),\n            rectSin(radius) / (radius + .1),\n            pow(prog,2.) + pow(1. - prog,1.));\n        ringColor += ringColor * smoothstep(0.1,1.,pow(mod(prog , .25) * 4.,9.)) * radius;\n        \n        col +=  ringColor * smoothstep(1.,0.,circle(radius,nuv) / blur);\n    }\n    col /= sqrt(length(col));\n    col /= (float(rings) / log(1. / blur));\n    col = col * brightness;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 233, 233, 261], [263, 263, 295, 295, 327]]}
{"id": "7dBBDc", "name": "swirl camera zsj gradient", "author": "zsjasper", "description": "gradient", "tags": ["gradient"], "likes": 17, "viewed": 386, "published": 3, "date": "1647252073", "time_retrieved": "2024-07-30T16:58:51.429242", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n/*\n\tMany thanks to pik33. I was inspired by his shader: \n\thttps://www.shadertoy.com/view/wdcSzr\n\n\tI reused his idea to distort space using only sine functions, but I made it as a 3D volumetric plane.\n\n\tYou can switch to HIGH_QUALITY mode in the common tab :)\n\n\tPreview generated at 11.88 s.\n\n\t1.01 - add HIGH QUALITY\n\t1.02 - add balanced HIGH_QUALITY and vignette \n\t1.03 - lower flight\n*/\n\nvec3 colorFromUV(vec2 uv, float shift)\n{\n \treturn 0.7 + 0.3*cos(TIME * 0.2 + uv.xyx * 0.1 + vec3(0,2,4) + pow(shift, 4.0)); //XD\n}\n\nvec3 fancyLayer(vec2 uv, float cut)\n{\n    uv *= 0.1;\n\n    for (float i = DISTORTION_BASE_ITERATION; i <= DISTORTION_BASE_ITERATION + DISTORTION_ITERATIONS; i++)\n    {\n     \tuv.x += STRENGTH * sin(uv.y * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.18) / pow(DISTORTION_POW, i);\n        uv.y += STRENGTH * sin(uv.x * pow(DISTORTION_POW, i) + TIME * DISTORTION_SPEED + i * 0.21) / pow(DISTORTION_POW, i);\n    }\n    \n    float fancyness = noise12(uv * 10.0 + TIME * 0.1 * 5.0);\n    float noise = noise12(uv * 2.0 + TIME * 0.5 + 21.0);\n    \n    vec3 col = colorFromUV(uv, noise);\n    \n    return smoothstep(cut - VOLUMETRIC_CUT_WIDTH, cut + VOLUMETRIC_CUT_WIDTH, fancyness) * (2.0 + fancyness) / 3.0 * col;\n}\n\n\nvec3 uvToCastPlane(vec2 uv)\n{\n \treturn vec3(uv.x, uv.y, -1.0 + sin(TIME * 0.2) * 0.2);   \n}\n\n//xy - plane uv\n//z - distance to plane point\nvec3 rayCastPlane(vec3 rayOrigin, vec3 rayDirection, float planeHeight)\n{\n    rayDirection /= rayDirection.y;\n    float distanceToPlane = abs(rayOrigin.y - planeHeight);\n    rayDirection *= distanceToPlane;\n    return vec3(rayOrigin.xz + rayDirection.xz, length(rayDirection));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    //Camera rotation and position\n    vec3 angle = vec3(-0.42 + cos(TIME * 0.3) * 0.08, sin(TIME * 0.2) * 0.5, cos(TIME * 0.21) * 0.1);\n    mat3x3 rotationMatrix = mat3x3(cos(angle.z), -sin(angle.z), 0.0,\n                                  sin(angle.z), cos(angle.z), 0.0,\n                                  0.0, 0.0, 1.0)\n        \t\t\t\t  * mat3x3(1.0, 0.0, 0.0,\n                                  0.0, cos(angle.x), -sin(angle.x),\n                                  0.0, sin(angle.x), cos(angle.x))\n        \t\t\t\t  * mat3x3(cos(angle.y), 0.0, -sin(angle.y),\n                                  0.0, 1.0, 0.0,\n                                  sin(angle.y), 0.0, cos(angle.y));\n    \n    vec3 cameraShift = vec3(0.0, sin(TIME * 0.24) * 0.12 - 0.36, TIME * 1.3);\n    \n    //Creating ray\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0) + cameraShift;\n    vec3 castPoint = uvToCastPlane(uv) * rotationMatrix + cameraShift;\n    vec3 rayDirection = castPoint - rayOrigin;\n    \n    //Raycast vase plane to get fog\n    vec3 planeUV = rayCastPlane(rayOrigin, rayDirection, -0.5);\n    float fog = 0.0;\n    if(rayDirection.y > 0.0) fog = 1.0;\n    else fog = sqrt(smoothstep(-0.1, FOG_DISTANCE, distance(cameraShift.xz, planeUV.xy)));\n\n    //ambient lighting\n    vec3 backgroundColor = colorFromUV(rayOrigin.xz, 0.0) * 0.3 * smoothstep(0.14, 0.0, abs(rayDirection.y - 0.02));\n    \n    //Adding many planes with small height differencies to create volumentric effect\n    vec3 col = vec3(0.0) + colorFromUV(rayOrigin.xz, 0.0) * 0.2;\n    \n    for (float i = 1.0; i <= LAYERS_COUNT ; i++)\n    {\n        planeUV = rayCastPlane(rayOrigin, rayDirection, -0.5 - i * LAYERS_DISTANCE - 1.0 * LAYERS_DISTANCE);\n        col += fancyLayer(planeUV.xy, 1.1 - pow(i / LAYERS_COUNT, 2.0)) * COLOR_MULTIPLIER * pow(0.99, i);\n    }\n    \n    //Mixing volumetric plane, fog and ambient lighting with some postprocessing\n    float vignette = smoothstep(2.5, 0.4, length(uv));\n\tcol = smoothstep(-0.0, 1.1, col * (1.0 - fog) + backgroundColor * fog) * vignette;\n    \n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define TIMESCALE 1.0\n\n//Uncoment if you have better PC\n//#define HIGH_QUALITY\n\n//Display parameters\n#ifdef HIGH_QUALITY \n\t#define STRENGTH 0.7\n    #define LAYERS_COUNT 200.0\n    #define LAYERS_DISTANCE 0.00225\n    #define COLOR_MULTIPLIER 0.05\n    #define NOISE_SHARPNESS 0.9\n    #define VOLUMETRIC_CUT_WIDTH 0.01\n    #define DISTORTION_POW 1.3\n    #define DISTORTION_SPEED 0.4\n    #define DISTORTION_BASE_ITERATION 8.0\n    #define DISTORTION_ITERATIONS 20.0\n    #define FOG_DISTANCE 17.0\n#else\n\t#define STRENGTH 0.7\n    #define LAYERS_COUNT 45.0\n    #define LAYERS_DISTANCE 0.0095\n    #define COLOR_MULTIPLIER 0.074\n    #define NOISE_SHARPNESS 1.0\n    #define VOLUMETRIC_CUT_WIDTH 0.05\n    #define DISTORTION_POW 1.3\n    #define DISTORTION_SPEED 0.4\n    #define DISTORTION_BASE_ITERATION 8.0\n    #define DISTORTION_ITERATIONS 15.0\n    #define FOG_DISTANCE 17.0\n#endif\n\n\n//Misc\n#define TIME (iTime * TIMESCALE)\n\n//Useful functions\nfloat hash12(vec2 x)   \n{\n    return fract(sin(dot(x, vec2(342.243, 234.4281))) * 235.2412);\n}\n\nfloat hash11(float x)   \n{\n    return fract(sin(x * 342.243) * 235.2412);\n}\n\nfloat noise12(vec2 uv)\n{\n \tvec2 rootUV = floor(uv);\n    vec2 fractUV = smoothstep(0.0, 1.0, fract(uv));\n    \n    float v00 = hash12(rootUV + vec2(0.0, 0.0));\n    float v01 = hash12(rootUV + vec2(0.0, 1.0));\n    float v10 = hash12(rootUV + vec2(1.0, 0.0));\n    float v11 = hash12(rootUV + vec2(1.0, 1.0));\n    \n    float v0 = mix(v00, v01, fractUV.y);\n    float v1 = mix(v10, v11, fractUV.y);\n    \n    return pow(mix(v0, v1, fractUV.x), NOISE_SHARPNESS);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBBDc.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[452, 452, 492, 492, 582], [584, 584, 621, 621, 1300], [1303, 1303, 1332, 1332, 1394], [1396, 1442, 1515, 1515, 1721], [1723, 1723, 1780, 1780, 3922]]}
{"id": "sdSBWc", "name": "Ultra cheap exact Menger sponge", "author": "El_Sargo", "description": "A super cheap and exact Menger that only calls the box sdf once no matter how many iterations are applied.  The sdf is also exact so it works perfectly with rounding or smin or other functions that require precise distances. Its all at lines 26 and 42. ", "tags": ["3d", "raymarching", "fast", "exact"], "likes": 4, "viewed": 489, "published": 3, "date": "1647239162", "time_retrieved": "2024-07-30T16:58:52.179237", "image_code": "//Use mouse to look and wasd to move\n//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n\n\n//#define rotations\n\n//Heavy performance impact \n#define AA 2\n#define raymarchSteps 100\n//\n#define ZERO min(iFrame, 0)\n\n\nconst float pi = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere(vec3 p, float r){\n    return length(p) -r;\n}\n\nmat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s,\n                -s, c);\n}\nvec3 trans(vec3 p, float s){\n        //Mirror\n        p = abs(p)-1.*s;\n        p *= -1.;\n        //Reflect column\n        p.xy = ((p.x - p.y > 0.) ? p.yx : p.xy);  \n        p.zy = ((p.z - p.y > 0.) ? p.yz : p.zy);  \n\n        //construct column\n        p.y = (abs(p.y-0.5*s)-0.5*s);\n        \n        return p;\n}\n\n\n// I don't know why but putting the calls to trans in a loop caused some weid behavioirs\nvec4 map(vec3 p) {\n\n    const float scale = 260.;\n\n    p*= scale;\n    \n    #ifdef rotations\n    p = trans(p, 27.*9.);\n    p.xy *= rotate(13.2);\n    p = trans(p, 27.*3.);\n    p.zy *= rotate(1.2);\n    p = trans(p, 27.);\n    p.xz *= rotate(13.12);\n    p = trans(p, 9.);\n    p.yz *= rotate(1.12);\n    p = trans(p, 3.);\n    p.yz *= rotate(6.12);\n    p = trans(p, 1.);\n    #else\n    p = trans(p, 27.*9.);\n    p = trans(p, 27.*3.);\n    p = trans(p, 27.);\n    p = trans(p, 9.);\n    p = trans(p, 3.);\n    p = trans(p, 1.);\n    \n    #endif\n\n    return vec4(sdBox(p, vec3(.5))/scale - 0.0005, p);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 intersection(vec3 ro, vec3 rd){\n    float dist;\n    for (int i = 0; i < raymarchSteps; i++){\n        dist = map(ro).x;\n        ro += dist*rd;\n        if (dist < 0.00001 || dist > 20.)\n            break;\n    }\n    \n    return ro;\n\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    vec3 p = intersection(ro,rd);\n    vec3 t = map(p).yzw;\n    \n    //Shading\n     vec3 sun = normalize(vec3(1., 1., 1.9));\n     \n     //Most of the lag is from shadows\n    float sha = softshadow(p, sun, .005, 10., 10.);\n     vec3 nor = calcNormal(p);\n    float occ = calcAO(p, nor);\n    float bou = pow(dot(sun*-1.,nor)*0.5+0.5, 1.);\n\n    //Colors\n    vec3 col = vec3(0.);\n    vec3 bcl = vec3(0.929,0.027,0.027);//vec3(distance(t,p)/40.1);\n    vec3 scl = vec3(1., 0.86 ,.7);\n    vec3 amb = vec3(0.7, 0.85, 1.);\n    vec3 hvc = normalize(sun - rd);\n    //\n    if (map(p).x < 0.1) {\n        col += 2.2*scl*bcl*sha;\n        col += .6*scl*bcl*bou*pow(occ, .23);\n        col += 0.8*bcl*amb*occ*(dot(nor, vec3(0,1,0))*.4+.6);\n        col += sha*max(0.,pow(dot(nor,hvc), 5.));\n        \n    } else\n        col = vec3((rd.y+.5)*.5+0.9)*amb;\n    return vec4(col, 1);\n}\n\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) \n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    rd = CameraRotation(m) * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3   ro = vec3(0, 0, -12.5);\n    \n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        Camera(fragCoord+o, ro, rd);\n\n        tot += render(ro, rd) / float(AA*AA);\n    }}\n\n    \n    tot = smoothstep(-0.,1.2, tot);\n    // Output to screen\n    fragColor = sqrt(tot);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Free cam by  glk7\n//https://www.shadertoy.com/view/4lVXRm\n\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    \n    position += (target - position) * iTimeDelta * 5.0;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY * rotX;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 284, 284, 371], [372, 372, 404, 404, 431], [433, 433, 454, 454, 546], [547, 547, 575, 592, 857], [860, 949, 967, 967, 1536], [1539, 1539, 1616, 1616, 1831], [1833, 1833, 1863, 1863, 2088], [2089, 2089, 2123, 2123, 2384], [2387, 2387, 2423, 2423, 2623], [2625, 2625, 2655, 2655, 3514], [3728, 3728, 3787, 3787, 4025], [4027, 4027, 4084, 4084, 4614]]}
{"id": "sdBfD3", "name": "Mandelbrot Set Cycles", "author": "oneshade", "description": "Cycles from 1 to 8. The 6, 7, and 8 cycles were a pain to calculate since WolframAlpha wouldn't find them for me.", "tags": ["2d", "fractal", "math", "mandelbrot", "cycles", "investigation"], "likes": 17, "viewed": 249, "published": 3, "date": "1647236106", "time_retrieved": "2024-07-30T16:58:53.223445", "image_code": "// Note that subcycles have been factored out.\n// For example, stepping twice through a three step cycle\n// could be counted as a six step cycle but can be ignored\n// since you might as well just be looking for three step cycles.\n\n// Also note that these are numerical approximations, not exact values\n// except for the fixed point and 2-cycle. The 3-cycle could actually\n// be solved analytically, but why do that when I just need numbers?\n\n// Btw, this is all ignoring more complicated behavior, such as taking 100 steps and\n// then landing in a 3-cycle, and more!\n\n// A basic Python library I made for doing stuff with polynomials:\n// https://replit.com/@hathnoname/Computer-Algebra-III-Polynomials#main.py\n\n// https://www.shadertoy.com/view/XsXGD4\nvec2 magnify(in vec2 actualUV, in vec2 pointUV, in float radius, in float strength) {\n    vec2 vecToPoint = pointUV - actualUV;\n    float distToPoint = length(vecToPoint);\n\n    float mag = (1.0 - distToPoint / radius) * strength;\n    mag *= step(distToPoint, radius);\n\n    return actualUV + vecToPoint * mag;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvec3 mandelbrot(in vec2 c) {\n    vec2 z = vec2(0.0);\n    for (int i=0; i < 25; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (length(z) > 2.0) return vec3(0.3, 0.5, 0.3); // Escaped\n    }\n\n    return vec3(0.0); // Stayed inside\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float distToMouse;\n    if (iMouse.z > 0.0) {\n        distToMouse = length(uv - mouse);\n        uv = magnify(uv, mouse, 1.0, 0.5);\n    }\n\n    // Almost center\n    uv.x -= 0.5;\n\n    // Draw 4x4 sampled mandelbrot\n    float offs = 0.75 / iResolution.y;\n    for (float i=0.0; i < 1.0; i += 0.25) {\n        for (float j=0.0; j < 1.0; j += 0.25) {\n            color += mandelbrot(uv + vec2(i, j) * offs);\n        }\n    }\n\n    color /= 16.0;\n\n    // Fake magnifying lense\n    if (iMouse.z > 0.0 && distToMouse < 1.0) {\n        color *= mix(1.0, 0.7, distToMouse);\n    }\n\n    // Animate cycles\n    float time = mod(0.5 * iTime, 120.0);\n    int idx = int(floor(time));\n    float transition = fract(time);\n    for (int i=0; i < 3; i++) transition = smoothstep(0.0, 1.0, transition);\n    vec2 c = mix(cycle8[hash120(idx)], cycle8[hash120((idx + 1) % 120)], transition);\n\n    // Draw path of Z through the complex plane\n    vec2 z = vec2(0.0);\n    for (int i=0; i < 8; i++) {\n        vec2 nz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        drawSDF(sdLine(uv, z, nz), vec3(1.0, 0.0, 0.0));\n        z = nz;\n    }\n\n    // Draw (some of) the C values that cause Z to cycle\n    drawSDF(length(uv - fixedp) - 0.01, vec3(0.0, 1.0, 0.0));\n    drawSDF(length(uv - cycle2) - 0.01, vec3(1.0, 0.8, 0.0));\n    for (int i=0; i < 3; i++) drawSDF(length(uv - cycle3[i]) - 0.01, vec3(1.0, 0.0, 1.0));\n    for (int i=0; i < 6; i++) drawSDF(length(uv - cycle4[i]) - 0.01, vec3(0.2, 0.2, 1.0));\n    for (int i=0; i < 15; i++) drawSDF(length(uv - cycle5[i]) - 0.01, vec3(0.0, 1.0, 1.0));\n    for (int i=0; i < 27; i++) drawSDF(length(uv - cycle6[i]) - 0.01, vec3(1.0, 0.4, 0.0));\n    for (int i=0; i < 63; i++) drawSDF(length(uv - cycle7[i]) - 0.01, vec3(0.7, 0.0, 1.0));\n    for (int i=0; i < 120; i++) drawSDF(length(uv - cycle8[i]) - 0.01, vec3(0.35, 0.0, 0.5));\n\n    // Vignette\n    color *= 1.0 - pow(length(fragCoord / iResolution.xy - 0.5), 2.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Shuffling hashes\nint hash3(in int x) { return int[3](2, 1, 3)[x]; }\nint hash6(in int x) { return int[6](1, 0, 4, 3, 5, 2)[x]; }\nint hash15(in int x) { return int[15](2, 5, 7, 4, 12, 14, 3, 9, 8, 11, 0, 13, 10, 6, 1)[x]; }\nint hash27(in int x) { return int[27](21, 20, 11, 9, 5, 25, 0, 12, 3, 16, 7, 17, 24, 14, 18, 4, 15, 13, 26, 10, 2, 1, 6, 23, 8, 19, 22)[x]; }\nint hash63(in int x) { return int[63](21, 32, 20, 3, 24, 47, 48, 38, 42, 43, 54, 46, 17, 40, 23, 50, 5, 22, 28, 4, 34, 29, 36, 7, 15, 56, 52, 45, 31, 62, 33, 18, 11, 12, 27, 59, 19, 13, 39, 25, 55, 8, 58, 49, 0, 60, 6, 61, 44, 41, 35, 16, 14, 30, 2, 37, 10, 9, 26, 1, 53, 57, 51)[x]; }\nint hash120(in int x) { return int[120](49, 14, 117, 47, 21, 106, 64, 53, 20, 66, 5, 26, 82, 96, 50, 73, 24, 6, 42, 18, 17, 55, 108, 23, 56, 111, 22, 70, 10, 115, 46, 33, 36, 77, 39, 44, 80, 27, 3, 54, 76, 81, 113, 58, 104, 100, 65, 62, 45, 85, 91, 4, 69, 102, 7, 119, 19, 93, 95, 116, 101, 92, 114, 84, 61, 32, 107, 60, 109, 40, 43, 89, 68, 72, 25, 28, 51, 0, 12, 30, 34, 52, 1, 8, 38, 112, 29, 41, 88, 71, 37, 63, 78, 83, 9, 16, 110, 13, 48, 97, 79, 15, 57, 90, 74, 2, 94, 118, 35, 99, 59, 75, 105, 86, 31, 103, 98, 87, 11, 67)[x]; }\n\n// f(0) = 0\n// c = 0\nconst vec2 fixedp = vec2(0.0);\n\n// f(f(0)) = 0\n// c^2 + c = 0\nconst vec2 cycle2 = vec2(-1.0, 0.0);\n\n// f(f(f(0))) = 0\n// c^4 + 2c^3 + c^2 + c = 0\n// Note that this could be solved exactly\nconst vec2[3] cycle3 = vec2[3](\n    vec2(-1.754877666246690,  0.000000000000000),\n    vec2(-0.122561166876654, -0.744861766619744),\n    vec2(-0.122561166876654,  0.744861766619744)\n);\n\n// f(f(f(f(0)))) = 0\n// c^8 + 4c^7 + 6c^6 + 6c^5 + 5c^4 + 2c^3 + c^2 + c = 0\nconst vec2[6] cycle4 = vec2[6](\n    vec2(-1.940799806529485,  0.000000000000000),\n    vec2(-1.310702641336833,  0.000000000000000),\n    vec2(-0.156520166833755, -1.032247108922832),\n    vec2(-0.156520166833755,  1.032247108922832),\n    vec2( 0.282271390766914, -0.530060617578525),\n    vec2( 0.282271390766914,  0.530060617578525)\n);\n\n// f(f(f(f(f(0))))) = 0\n// c^16 + 8c^15 + 28c^14 + 60c^13 + 94c^12 + 116c^11 + 114c^10 + 94c^9 + 69c^8 + 44c^7 + 26c^6 + 14c^5 + 5c^4 + 2c^3 + c^2 + c = 0\nconst vec2[15] cycle5 = vec2[15](\n    vec2(-1.985424253054205,  0.000000000000000),\n    vec2(-1.860782522204855,  0.000000000000000),\n    vec2(-1.625413725123304,  0.000000000000000),\n    vec2(-1.256367930068181, -0.380320963472723),\n    vec2(-1.256367930068181,  0.380320963472723),\n    vec2(-0.504340175446244, -0.562765761452982),\n    vec2(-0.504340175446244,  0.562765761452982),\n    vec2(-0.198042099364254, -1.100269537292699),\n    vec2(-0.198042099364254,  1.100269537292699),\n    vec2(-0.044212357704071, -0.986580976280893),\n    vec2(-0.044212357704071,  0.986580976280893),\n    vec2( 0.359259224758007, -0.642513737138542),\n    vec2( 0.359259224758007,  0.642513737138542),\n    vec2( 0.379513588015924, -0.334932305597498),\n    vec2( 0.379513588015924,  0.334932305597498)\n);\n\n// f(f(f(f(f(f(0)))))) = 0\n// c^32 + 16c^31 + 120c^30 + 568c^29 + 1932c^28 + 5096c^27 + 10948c^26 + 19788c^25 + 30782c^24 + 41944c^23 + 50788c^22 + 55308c^21 + 54746c^20 + 49700c^19 + 41658c^18 + 32398c^17 + 23461c^16 + 15864c^15 + 10068c^14 + 6036c^13 + 3434c^12 + 1860c^11 + 958c^10 + 470c^9 + 221c^8 + 100c^7 + 42c^6 + 14c^5 + 5c^4 + 2c^3 + c^2 + c = 0\nconst vec2[27] cycle6 = vec2[27](\n    vec2(-1.996376137711194,  0.000000000000000),\n    vec2(-1.966773216392929,  0.000000000000000),\n    vec2(-1.907280091065302,  0.000000000000000),\n    vec2(-1.772892903381624,  0.000000000000000),\n    vec2(-1.476014642728430,  0.000000000000000),\n    vec2(-1.284084925525686, -0.427268896040686),\n    vec2(-1.284084925525686,  0.427268896040686),\n    vec2(-1.138000666650965, -0.240332401262098),\n    vec2(-1.138000666650965,  0.240332401262098),\n    vec2(-0.596891644645127, -0.662980744577030),\n    vec2(-0.596891644645127,  0.662980744577030),\n    vec2(-0.217526747030511, -1.114454265873293),\n    vec2(-0.217526747030511,  1.114454265873293),\n    vec2(-0.163598261552023, -1.097780642888272),\n    vec2(-0.163598261552023,  1.097780642888272),\n    vec2(-0.113418655949437, -0.860569472501573),\n    vec2(-0.113418655949437,  0.860569472501573),\n    vec2(-0.015570386020902, -1.020497366498289),\n    vec2(-0.015570386020902,  1.020497366498289),\n    vec2( 0.359892739012579, -0.684762020211813),\n    vec2( 0.359892739012579,  0.684762020211813),\n    vec2( 0.389006840569771, -0.215850650870819),\n    vec2( 0.389006840569771,  0.215850650870819),\n    vec2( 0.396534570032415, -0.604181810488989),\n    vec2( 0.396534570032415,  0.604181810488989),\n    vec2( 0.443325633399624, -0.372962416662847),\n    vec2( 0.443325633399624,  0.372962416662847)\n);\n\n// f(f(f(f(f(f(f(0))))))) = 0\n// c^64 + 32c^63 + 496c^62 + 4976c^61 + 36440c^60 + 208336c^59 + 971272c^58 + 3807704c^57 + 12843980c^56 + 37945904c^55 + 99582920c^54 + 234813592c^53 + 502196500c^52 + 981900168c^51 + 1766948340c^50 + 2943492972c^49 + 4562339774c^48 + 6609143792c^47 + 8984070856c^46 + 11500901864c^45 + 13910043524c^44 + 15941684776c^43 + 17357937708c^42 + 17999433372c^41 + 17813777994c^40 + 16859410792c^39 + 15286065700c^38 + 13299362332c^37 + 11120136162c^36 + 8948546308c^35 + 6939692682c^34 + 5193067630c^33 + 3754272037c^32 + 2625062128c^31 + 1777171560c^30 + 1166067016c^29 + 742179284c^28 + 458591432c^27 + 275276716c^26 + 160617860c^25 + 91143114c^24 + 50323496c^23 + 27049196c^22 + 14162220c^21 + 7228014c^20 + 3598964c^19 + 1749654c^18 + 831014c^17 + 385741c^16 + 175048c^15 + 77684c^14 + 33708c^13 + 14290c^12 + 5916c^11 + 2398c^10 + 950c^9 + 365c^8 + 132c^7 + 42c^6 + 14c^5 + 5c^4 + 2c^3 + c^2 + c = 0\nconst vec2[63] cycle7 = vec2[63](\n    vec2(-1.999095682327019,  0.000000000000000),\n    vec2(-1.991814172549122,  0.000000000000000),\n    vec2(-1.977179587006257,  0.000000000000000),\n    vec2(-1.953705894284396,  0.000000000000000),\n    vec2(-1.927147709363950,  0.000000000000000),\n    vec2(-1.884803571586682,  0.000000000000000),\n    vec2(-1.832315202751229,  0.000000000000000),\n    vec2(-1.674066091474788,  0.000000000000000),\n    vec2(-1.574889139752301,  0.000000000000000),\n    vec2(-1.769261670276831, -0.056919500395600),\n    vec2(-1.769261670276831,  0.056919500395600),\n    vec2(-1.408446485740073, -0.136171997304660),\n    vec2(-1.408446485740073,  0.136171997304660),\n    vec2(-1.292558061033522, -0.438198816086632),\n    vec2(-1.292558061033522,  0.438198816086632),\n    vec2(-1.262287281438472, -0.408104324112690),\n    vec2(-1.262287281438472,  0.408104324112690),\n    vec2(-1.252735884012038, -0.342470647889751),\n    vec2(-1.252735884012038,  0.342470647889751),\n    vec2(-1.028193852454818, -0.361376517118562),\n    vec2(-1.028193852454818,  0.361376517118562),\n    vec2(-0.623532485956253, -0.681064414225240),\n    vec2(-0.623532485956253,  0.681064414225240),\n    vec2(-0.622436295041294, -0.424878436475629),\n    vec2(-0.622436295041294,  0.424878436475629),\n    vec2(-0.530827804859943, -0.668288725559206),\n    vec2(-0.530827804859943,  0.668288725559206),\n    vec2(-0.272102461488939, -0.842364690294128),\n    vec2(-0.272102461488939,  0.842364690294128),\n    vec2(-0.224915951286740, -1.116260157454992),\n    vec2(-0.224915951286740,  1.116260157454992),\n    vec2(-0.207283835455666, -1.117480772494963),\n    vec2(-0.207283835455666,  1.117480772494963),\n    vec2(-0.174578221135717, -1.071427671454031),\n    vec2(-0.174578221135717,  1.071427671454031),\n    vec2(-0.157516053475965, -1.109006514113607),\n    vec2(-0.157516053475965,  1.109006514113607),\n    vec2(-0.127499973546363, -0.987460909489457),\n    vec2(-0.127499973546363,  0.987460909489457),\n    vec2(-0.014233481920354, -1.032914775213644),\n    vec2(-0.014233481920354,  1.032914775213644),\n    vec2(-0.006983568496261, -1.003603862288289),\n    vec2(-0.006983568496261,  1.003603862288289),\n    vec2( 0.014895466603688, -0.848148761908416),\n    vec2( 0.014895466603688,  0.848148761908416),\n    vec2( 0.121192786105906, -0.610611692210754),\n    vec2( 0.121192786105906,  0.610611692210754),\n    vec2( 0.352482539722363, -0.698337239583330),\n    vec2( 0.352482539722363,  0.698337239583330),\n    vec2( 0.376008681846768, -0.144749371321633),\n    vec2( 0.376008681846768,  0.144749371321633),\n    vec2( 0.376893240379311, -0.678568693190448),\n    vec2( 0.376893240379311,  0.678568693190448),\n    vec2( 0.386539176596158, -0.569324711303103),\n    vec2( 0.386539176596158,  0.569324711303103),\n    vec2( 0.412916024722701, -0.614806760143386),\n    vec2( 0.412916024722701,  0.614806760143386),\n    vec2( 0.432376192641995, -0.226759904435349),\n    vec2( 0.432376192641995,  0.226759904435349),\n    vec2( 0.452774498724915, -0.396170128033165),\n    vec2( 0.452774498724915,  0.396170128033165),\n    vec2( 0.456823285823317, -0.347758700883482),\n    vec2( 0.456823285823317,  0.347758700883482)\n);\n\n// f(f(f(f(f(f(f(f(0)))))))) = 0\n// c^128 + 64c^127 + 2016c^126 + 41696c^125 + 637360c^124 + 7685024c^123 + 76185104c^122 + 639097008c^121 + 4634116312c^120 + 29524775520c^119 + 167453394320c^118 + 854515874096c^117 + 3958458557608c^116 + 16771945556496c^115 + 65418624260840c^114 + 236221241425176c^113 + 793548088258508c^112 + 2490875091238112c^111 + 7333879739219600c^110 + 20324543852025936c^109 + 53181959591958024c^108 + 131760770157606224c^107 + 309881648709683160c^106 + 693434955498545848c^105 + 1479594496462756340c^104 + 3016191418506637264c^103 + 5884917700519129288c^102 + 11008161481780603512c^101 + 19772322481956974532c^100 + 34150590308701283528c^99 + 56796799826096529620c^98 + 91071943593142473900c^97 + 140960183546144741182c^96 + 210835921361505594848c^95 + 305060580205223726864c^94 + 427417353874088245520c^93 + 580430565842543266504c^92 + 764655844340519788496c^91 + 978057923319151340728c^90 + 1215604411161527170376c^89 + 1469189341596552030212c^88 + 1727958521630464742736c^87 + 1979045408073272278264c^86 + 2208653487832260558008c^85 + 2403354418943890067404c^84 + 2551425591643957182856c^83 + 2644036970936308845148c^82 + 2676118542978972739644c^81 + 2646791812246207696810c^80 + 2559320275988283588176c^79 + 2420609646335251593480c^78 + 2240353897304462193848c^77 + 2029966595320794439668c^76 + 1801452751402955781592c^75 + 1566365198635995978988c^74 + 1334957092752100409132c^73 + 1115597581733327913554c^72 + 914470757914434625800c^71 + 735537050036491961156c^70 + 580706779030058464252c^69 + 450159936955994386738c^68 + 342743629811082484420c^67 + 256386228250001079082c^66 + 188481251186354006062c^65 + 136210493669590627493c^64 + 96791719611591962592c^63 + 67649247253332557392c^62 + 46514944583399578896c^61 + 31472438318100876584c^60 + 20959276151880728336c^59 + 13741246529612440920c^58 + 8870996681171366696c^57 + 5640327912922026260c^56 + 3532711259225506384c^55 + 2180053774442766712c^54 + 1325752376790240280c^53 + 794643418760272876c^52 + 469540646039042536c^51 + 273551721580800380c^50 + 157160523515654628c^49 + 89054473147697354c^48 + 49778848242964944c^47 + 27452211062573400c^46 + 14938862548001560c^45 + 8022825031835276c^44 + 4252710138415640c^43 + 2225301467579844c^42 + 1149605839249820c^41 + 586400982013486c^40 + 295372837865192c^39 + 146932182777116c^38 + 72188854953372c^37 + 35031835376454c^36 + 16792863663700c^35 + 7952125694214c^34 + 3720187393990c^33 + 1719477330477c^32 + 785248461712c^31 + 354347339496c^30 + 158015533208c^29 + 69640352964c^28 + 30336029592c^27 + 13062923500c^26 + 5560968284c^25 + 2340595778c^24 + 974083128c^23 + 400844588c^22 + 163107044c^21 + 65626918c^20 + 26108844c^19 + 10269590c^18 + 3993030c^17 + 1534301c^16 + 582408c^15 + 218324c^14 + 80812c^13 + 29538c^12 + 10652c^11 + 3774c^10 + 1302c^9 + 429c^8 + 132c^7 + 42c^6 + 14c^5 + 5c^4 + 2c^3 + c^2 + c = 0\nconst vec2[120] cycle8 = vec2[120](\n    vec2(-1.999774048693727,  0.000000000000000),\n    vec2(-1.997962915597714,  0.000000000000000),\n    vec2(-1.994332966715535,  0.000000000000000),\n    vec2(-1.988793274309471,  0.000000000000000),\n    vec2(-1.981655786276044,  0.000000000000000),\n    vec2(-1.972199838366876,  0.000000000000000),\n    vec2(-1.960758987197429,  0.000000000000000),\n    vec2(-1.941782090318198,  0.000000000000000),\n    vec2(-1.917098277113422,  0.000000000000000),\n    vec2(-1.896917994678833,  0.000000000000000),\n    vec2(-1.870003880828765,  0.000000000000000),\n    vec2(-1.851730049410641,  0.000000000000000),\n    vec2(-1.810001385728012,  0.000000000000000),\n    vec2(-1.711079470013152,  0.000000000000000),\n    vec2(-1.521817231671251,  0.000000000000000),\n    vec2(-1.381547484432061,  0.000000000000000),\n    vec2(-1.770713201296948, -0.063904331714888),\n    vec2(-1.770713201296948,  0.063904331714888),\n    vec2(-1.766495147993645, -0.041726706146453),\n    vec2(-1.766495147993645,  0.041726706146453),\n    vec2(-1.627929065204338, -0.022145736517251),\n    vec2(-1.627929065204338,  0.022145736517251),\n    vec2(-1.423454458533147, -0.156442843876153),\n    vec2(-1.423454458533147,  0.156442843876153),\n    vec2(-1.295189163585398, -0.440937435674443),\n    vec2(-1.295189163585398,  0.440937435674443),\n    vec2(-1.286481200313292, -0.433943872327566),\n    vec2(-1.286481200313292,  0.433943872327566),\n    vec2(-1.285677330213732, -0.352707123723361),\n    vec2(-1.285677330213732,  0.352707123723361),\n    vec2(-1.281533105319488, -0.418316059833958),\n    vec2(-1.281533105319488,  0.418316059833958),\n    vec2(-1.242578028187509, -0.413225009775680),\n    vec2(-1.242578028187509,  0.413225009775680),\n    vec2(-1.185611193044230, -0.303040886564509),\n    vec2(-1.185611193044230,  0.303040886564509),\n    vec2(-1.028969519024400, -0.386312083216542),\n    vec2(-1.028969519024400,  0.386312083216542),\n    vec2(-0.999442387206567, -0.265387532468407),\n    vec2(-0.999442387206567,  0.265387532468407),\n    vec2(-0.690942897652005, -0.465349538581011),\n    vec2(-0.690942897652005,  0.465349538581011),\n    vec2(-0.632384121969239, -0.684701757623218),\n    vec2(-0.632384121969239,  0.684701757623218),\n    vec2(-0.606185558894826, -0.684031616476013),\n    vec2(-0.606185558894826,  0.684031616476013),\n    vec2(-0.592465902746754, -0.621348689261353),\n    vec2(-0.592465902746754,  0.621348689261353),\n    vec2(-0.525971082530693, -0.696943648552084),\n    vec2(-0.525971082530693,  0.696943648552084),\n    vec2(-0.359102390112449, -0.617353453398827),\n    vec2(-0.359102390112449,  0.617353453398827),\n    vec2(-0.296350364863718, -0.845154528884588),\n    vec2(-0.296350364863718,  0.845154528884588),\n    vec2(-0.240416194737743, -0.870487421314561),\n    vec2(-0.240416194737743,  0.870487421314561),\n    vec2(-0.227331323047004, -1.115883598594023),\n    vec2(-0.227331323047004,  1.115883598594023),\n    vec2(-0.222235654179709, -1.118375889201622),\n    vec2(-0.222235654179709,  1.118375889201622),\n    vec2(-0.207991431776635, -1.109132944418652),\n    vec2(-0.207991431776635,  1.109132944418652),\n    vec2(-0.206598609869805, -1.121383303100915),\n    vec2(-0.206598609869805,  1.121383303100915),\n    vec2(-0.183173449982320, -1.091560429186861),\n    vec2(-0.183173449982320,  1.091560429186861),\n    vec2(-0.162867707067255, -1.037313240810425),\n    vec2(-0.162867707067255,  1.037313240810425),\n    vec2(-0.157781855891046, -1.112590613593092),\n    vec2(-0.157781855891046,  1.112590613593092),\n    vec2(-0.154454617643616, -1.104395461077708),\n    vec2(-0.154454617643616,  1.104395461077708),\n    vec2(-0.074470451380032, -0.970542136899210),\n    vec2(-0.074470451380032,  0.970542136899210),\n    vec2(-0.023242291961163, -0.998992644684930),\n    vec2(-0.023242291961163,  0.998992644684930),\n    vec2(-0.015608533223847, -1.036645665847862),\n    vec2(-0.015608533223847,  1.036645665847862),\n    vec2(-0.009862436986086, -1.029630118361600),\n    vec2(-0.009862436986086,  1.029630118361600),\n    vec2( 0.000464217447541, -1.004501022924267),\n    vec2( 0.000464217447541,  1.004501022924267),\n    vec2( 0.022860533259552, -0.813669918234632),\n    vec2( 0.022860533259552,  0.813669918234632),\n    vec2( 0.025970522960208, -0.864697720038508),\n    vec2( 0.025970522960208,  0.864697720038508),\n    vec2( 0.135782238839752, -0.670855910094680),\n    vec2( 0.135782238839752,  0.670855910094680),\n    vec2( 0.324819701465460, -0.563815622140334),\n    vec2( 0.324819701465460,  0.563815622140334),\n    vec2( 0.347358607651260, -0.701559767060788),\n    vec2( 0.347358607651260,  0.701559767060788),\n    vec2( 0.359031062836614, -0.100934876864298),\n    vec2( 0.359031062836614,  0.100934876864298),\n    vec2( 0.359325657833447, -0.699215766441657),\n    vec2( 0.359325657833447,  0.699215766441657),\n    vec2( 0.377149286568174, -0.666878777916213),\n    vec2( 0.377149286568174,  0.666878777916213),\n    vec2( 0.380722369849916, -0.683831461840431),\n    vec2( 0.380722369849916,  0.683831461840431),\n    vec2( 0.403033458686289, -0.565397856797952),\n    vec2( 0.403033458686289,  0.565397856797952),\n    vec2( 0.404899665175122, -0.145820363766589),\n    vec2( 0.404899665175122,  0.145820363766589),\n    vec2( 0.414978784748552, -0.621007807403794),\n    vec2( 0.414978784748552,  0.621007807403794),\n    vec2( 0.416146913225193, -0.607394909415916),\n    vec2( 0.416146913225193,  0.607394909415916),\n    vec2( 0.437283929497173, -0.210381200598479),\n    vec2( 0.437283929497173,  0.210381200598479),\n    vec2( 0.442074530015487, -0.239426040286596),\n    vec2( 0.442074530015487,  0.239426040286596),\n    vec2( 0.450528859613642, -0.331931387726143),\n    vec2( 0.450528859613642,  0.331931387726143),\n    vec2( 0.451145803591671, -0.406520992288107),\n    vec2( 0.451145803591671,  0.406520992288107),\n    vec2( 0.461703168202125, -0.390110237949803),\n    vec2( 0.461703168202125,  0.390110237949803),\n    vec2( 0.466959205647030, -0.351546724574027),\n    vec2( 0.466959205647030,  0.351546724574027)\n);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 752, 837, 837, 1062], [1064, 1064, 1111, 1111, 1219], [1221, 1221, 1249, 1249, 1484], [1566, 1566, 1621, 1640, 3840]]}
{"id": "7dSBD3", "name": "China Flag", "author": "Delincoter", "description": "I made it when I was bored at work :)", "tags": ["2d", "flag"], "likes": 20, "viewed": 695, "published": 3, "date": "1647229190", "time_retrieved": "2024-07-30T16:58:54.026299", "image_code": "/*\n\"Waviness factor\" and \"Vignette\" cited from https://www.shadertoy.com/view/3lyGRd\n*/\n\n#define S(a,b,t) smoothstep(a,b,t) \n#define PI 3.1415927\n\nmat2 Rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat DrawGrid(vec2 uv)\n{\n    vec2 gv = fract(uv * 10. - 0.025);\n    \n    float grid = 0.;\n    \n    if(gv.x > .95) grid = 1.;\n    if(gv.y > .95) grid = 1.;\n    \n    return grid;\n}\n\nfloat Star(vec2 uv, float feature)\n{\n    uv.x = abs(uv.x);\n    \n    float S1 = 0.11;\n    float S2 = S1 - feature;\n    \n    float side1 = S(S1, S2, uv.y);\n    \n    vec2 dv = Rot(0.4*PI*2.) * uv;\n    float side2 = S(S1, S2, dv.y);\n    \n    dv = Rot(0.4*PI*3.) * uv;\n    float side3 = S(S1, S2, dv.y);\n    \n    dv = Rot(0.4*PI*4.) * uv;\n    float side4 = S(S1, S2, dv.y);\n    \n    return side2*side4+side1*side3;\n}\n\nfloat StarLayer(vec2 uv)\n{\n    float star1 = Star((uv+vec2(0.4, 0.))*1.1, .01);\n    \n    float star2 = Star(((uv+vec2(-0.1, 0.4))*3.1)* Rot(0.5), .02);\n    \n    float star3 = Star(((uv+vec2(-0.3, 0.2))*3.1), .02);\n    \n    float star4 = Star(((uv+vec2(-0.3, -0.1))*3.1)* Rot(-0.25), .02);\n    \n    float star5 = Star(((uv+vec2(-0.1, -0.3))*3.1)* Rot(0.5), .02);\n    \n    return star1+star2+star3+star4+star5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n\n    uv -= .5;  \n    uv.x *= iResolution.x/iResolution.y;\n  \n    uv *= 2.;\n    uv += vec2(iResolution.x/iResolution.y*0.5, -0.5);\n    \n    float w = sin((uv.x + uv.y - iTime * .75 + sin(1.5 * uv.x + 4.5 * uv.y) * PI * .3)\n                  * PI * .6); // fake waviness factor  \n    uv *= 1. + (.036 - .036 * w);\n    \n    //float tex = texture(iChannel0, uv * 200.).r;\n      \n    vec3 col = vec3(0.870588,0.1607843,0.0627451);\n    col = mix(col, vec3(1., 0.8705882, 0.), clamp(StarLayer(uv),0.,1.));\n    col += w * .15;\n    //col *= tex*2.;\n    \n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y); // vignette\n    col *= vec3(1. - .25 * exp2(-4.5 * v));\n    \n    //col += DrawGrid(uv)*.5; // grid\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 166, 166, 237], [239, 239, 264, 264, 418], [420, 420, 456, 456, 831], [833, 833, 859, 859, 1243], [1245, 1245, 1302, 1302, 2099]]}
{"id": "ssBBW3", "name": "cielo-brusco", "author": "jorge2017a2", "description": "cielo-brusco", "tags": ["cielobrusco"], "likes": 10, "viewed": 205, "published": 3, "date": "1647226155", "time_retrieved": "2024-07-30T16:58:54.767318", "image_code": "//----------image\n//por jorge2017a2-\n///referencia\n//\n//iQ , Shane,FabriceNeyret2 ,etc\n//https://www.shadertoy.com/view/tsySDw\n//http://patriciogonzalezvivo.com\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n    \n///https://www.shadertoy.com/view/tsySDw\nfloat sdCylinderY(vec3 p, vec3 c)\n{  return length(p.xz-c.xy)-c.z;}\nfloat sdCylinderZ(vec3 p, vec3 c)\n{  return length(p.xy-c.xy)-c.z;}\nfloat sdCylinderX(vec3 p, vec3 c)\n{  return length(p.zy-c.xy)-c.z;}\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{return dot(p, n.xyz) + n.w;}\n\nvec2 Pisosdf01(vec3 pos)\n{ \n  const float repeat = 20.0;\n   float b= pos.y-0.0;\n  pos.x= opRep1D( pos.x, repeat );\n  pos.z= opRep1D( pos.z, repeat );\n  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 10.0));\n  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 10.0));\n  float c = min(cz, cx);   \n  return vec2( differenceSDF(b,c),100.0);  \n}\n\nvec2 Pisosdf02(vec3 pos)\n{ \n  float repeat = 50.0;\n  pos.y-=12.0;\n   float b= pos.y-0.0;\n  pos.x= opRep1D( pos.x, repeat );\n  pos.z= opRep1D( pos.z, repeat );\n  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 25.0));\n  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 25.0));\n  float c = min(cz, cx);   \n  return vec2( differenceSDF(b,c),101.0);\n  \n}\n\n///https://www.shadertoy.com/view/tsySDw\nfloat opUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\n\nvec2 pillarsSdf(vec3 pos)\n{\n  const float repeat = 20.0;\n  pos.x= opRep1D( pos.x, repeat );\n  pos.z= opRep1D( pos.z, repeat );\n\n  float d = 9999.9;\n  float pillar = sdBox(pos, vec3(1.0, 8.0, 1.0));\n  float base = sdBox(pos, vec3(1.5, 0.5, 1.5));  \n  float top = sdBox(pos - vec3(0.0, 4.5, 0.0), vec3(1.25, 0.2, 1.25));\n  d = opUnionStairs(pillar, base, 0.5, 3.0);\n  d = opUnionStairs(d, top, 0.3, 2.0);\n  return vec2( d,100);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\t vec2 re1= Pisosdf01(p);\n    res =opU2(res, re1);\n    vec2 re2= Pisosdf02(p);\n    res =opU2(res, re2);\n    vec2 re3=pillarsSdf(p-vec3(-1.0,-2.0,5.0));\n    res =opU2(res, re3);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n        //if (abs(hit.x) < EPSILON) break;\n    }\n    return object;\n\n}\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos));// shadows\n    float occ = occlusion(hit, norm); // occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd,vec2 st)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    vec2 q, r;\n    float ti=iTime;\n    float ti2=(0.25*tan(ti*0.2)+1.0);\n    ///st *= (5.+ti2);\n    st += vec2(0.0, t+ti * 0.25+(ti2));\n     st *= (5.+ti2);\n\tfloat pr=pattern(st, q, r);\n    float pr2= clamp(pr*3.0,0.,1.)*0.1+pr;\n    return  mix( sky , vec3(0.2,0.2,0.5)*sky.y*sin(pr2),pr);\n}\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color==100)\n       { return getColorTextura(p, n, 100);}\n   if (id_color==101)\n       { return getColorTextura(p, n, 101);} \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd,uv);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(3.0,7.0,-25.0+iTime*5.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd, uv);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 3\nfloat fbm (in vec2 st) \n{ // Initial values\n    float value = 0.0;\n    float amplitude = 0.65;\n    float frequency = 0.2;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 0.01;\n        amplitude *= .15;\n    }\n    return value;\n}\n\nfloat pattern( in vec2 p, out vec2 q, out vec2 r )\n{\n    q.x = fbm( p + vec2(0.0,0.0) );\n    q.y = fbm( p + vec2(1.2,1.3) );\n\n    r.x = fbm( p + 4.0*q + vec2(1.7,9.2) );\n    r.y = fbm( p + 4.0*q + vec2(8.3,2.8) );\n\n    return fbm( p + 4.0*r );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 657, 657, 741], [747, 788, 823, 823, 855], [856, 856, 891, 891, 923], [924, 924, 959, 959, 991], [992, 1036, 1083, 1083, 1110], [1111, 1111, 1154, 1154, 1181], [1182, 1182, 1230, 1230, 1258], [1259, 1297, 1333, 1333, 1378], [1379, 1379, 1413, 1413, 1509], [1510, 1510, 1544, 1544, 1635], [1636, 1636, 1670, 1670, 1761], [1763, 1763, 1794, 1794, 1822], [1824, 1824, 1850, 1850, 2153], [2155, 2155, 2181, 2181, 2494], [2496, 2537, 2594, 2594, 2705], [2708, 2708, 2735, 2735, 3135], [3137, 3137, 3162, 3162, 3399], [3401, 3401, 3425, 3425, 3587], [3589, 3589, 3637, 3637, 4012], [4013, 4013, 4057, 4057, 4383], [4385, 4385, 4422, 4422, 4683], [4685, 4685, 4770, 4770, 5728], [5730, 5730, 5779, 5779, 5912], [5914, 5914, 6007, 6007, 6137], [6139, 6139, 6179, 6179, 6653], [6655, 6655, 6723, 6723, 6876], [6878, 6878, 6905, 6905, 6994], [6996, 6996, 7054, 7054, 7102], [7105, 7105, 7128, 7128, 7246], [7248, 7248, 7288, 7288, 7912], [7915, 7915, 7972, 7972, 8380]]}
{"id": "NsSfWc", "name": "Little Light Test", "author": "SnoopethDuckDuck", "description": "i really like setting color = 1, then darkening with exp(-length). super simple + looks really nice", "tags": ["e"], "likes": 22, "viewed": 491, "published": 3, "date": "1647204963", "time_retrieved": "2024-07-30T16:58:56.086789", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0.1 * cos(iTime), 0.1 * sin(iTime), 2. + iTime);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 getRo2() {\n    vec3 ro = getRo();\n    \n    return ro + vec3(1.4 * thc(2.01, iTime), 0.3 * sin(0.2 * iTime),-4);//4. * vec3(cos(iTime), 0., sin(iTime));\n}\n\n\n// this is a mess but im too lazy to change it\nvec2 GetDist(vec3 p) {\n    vec3 op = p;\n    float d0 = p.y + 0.1 * cos(1.5 * p.x + iTime) + 0.6;//length(p - getRo2()) + 0.;\n    \n    op -= getRo2();\n    \n    op.xy *= Rot(2. * iTime);\n    op.zy *= Rot(1.8 * iTime);\n    op.y = abs(op.y) - 0.1;\n    float r1 = 0.1;\n    float r2 = 0.04;\n    float da = length(op.xz) - r1;\n    float db = length(vec2(da, op.y)) - r2;\n    \n    p.xz = fract(0.5 * p.xz) - 0.5;\n    p.xz *= 1. + cos(3. * p.y) + 0. * cc(2., 10. * length(p.y) - iTime);\n    float d = length(p.xz) - 0.1;\n    d *= 0.2;\n    if (d0 < d)\n        return vec2(d0, 0.);\n        \n    d = min(d0, d);\n    if (db < d)\n        return vec2(db, 1.);\n    \n    \n    return vec2(d, 2.);\n    \n   // return min(d0, d);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    vec2 dS = vec2(0, 1);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        if (s != sign(dS.x)) { z *= 0.5; s = sign(dS.x); }\n        if(abs(dS.x)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS.x*z; \n    }\n    \n    return vec2(min(dO, MAX_DIST), dS.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 rd) {\n    vec3 lightPos = getRo2();\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n   // float dif = clamp(dot(n, l), 0., 1.);\n    float dif = 1.;\n    float d = RayMarch(p+n*SURF_DIST*2., l, 1.).x;\n    if(d<length(lightPos-p)) dif *= 0.92;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n \n    float d = RayMarch(ro, rd, 1.).x;\n    vec3 p = ro + rd * d;\n    \n    vec3 ro2 = getRo2();\n    \n    vec3 col = vec3(GetLight(p, rd));\n    col *= exp(-1.2 * length(ro2 - p));\n      \n    vec3 e = vec3(1);\n    col *= pal(2. * exp(-0.08 * length(ro2-p)),e,e,e,0.55 * vec3(0,1,2)/3.);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 649, 649, 841], [843, 843, 858, 858, 1001], [1004, 1051, 1073, 1073, 1761], [1763, 1763, 1805, 1805, 2152], [2154, 2154, 2178, 2178, 2376], [2378, 2378, 2428, 2428, 2619], [2621, 2621, 2654, 2654, 2986], [2988, 2988, 3045, 3045, 3556]]}
{"id": "ssSBRz", "name": "Simple 2D Waves with texture", "author": "broelik", "description": "Simple 2D Waves", "tags": ["2d"], "likes": 2, "viewed": 278, "published": 3, "date": "1647180791", "time_retrieved": "2024-07-30T16:58:57.011318", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // чем ближе к краям, тем больше эффект\n    vec2 center_dist = 1.0 - abs(uv - .5) / .5;\n    float arg = sin(iTime + fragCoord.y / 150.0);\n    fragColor = texture(iChannel0, uv + arg / 30.0 * center_dist);\n    //fragColor = vec4(center_dist.x);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 381]]}
{"id": "sd2BDV", "name": "Tree fold", "author": "takahiroando", "description": "based on https://gam0022.net/blog/2017/03/02/raymarching-fold/", "tags": ["fold"], "likes": 5, "viewed": 213, "published": 3, "date": "1647171736", "time_retrieved": "2024-07-30T16:58:57.749344", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n// from: https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec3 foldX(vec3 p) {\n    // This is the trick to make a mirror\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat dTree(vec3 p) {\n    float scale = 0.8;\n    vec3 size = vec3(0.1, 1.0, 0.1);\n    float d = sdBox(p, size);\n    for (int i = 0; i < 7; i++) {\n        p = foldX(p);\n        p.y -= size.y;\n        p.xy *= rot(-0.5);\n        d = min(d, sdBox(p, size));\n        size *= scale;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-8);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=dTree(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2BDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 178], [181, 244, 264, 306, 342], [344, 344, 365, 365, 642], [644, 644, 701, 701, 923]]}
{"id": "7sjfWV", "name": "foldtest minimum dTree", "author": "takahiroando", "description": "based on: https://gam0022.net/blog/2017/03/02/raymarching-fold/", "tags": ["fold"], "likes": 0, "viewed": 165, "published": 3, "date": "1647169564", "time_retrieved": "2024-07-30T16:58:58.486375", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n// from: https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec3 foldX(vec3 p) {\n    // This is the trick to make a mirror\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat dTree(vec3 p) {\n    vec3 size = vec3(0.1, 1.0, 0.1);\n    float d = sdBox(p, size);\n    \n    p = foldX(p); // mirror(which means ignoring left side)\n    p.y -= 0.5;\n    p.xy *= rot(-1.2); // angle of arm\n    \n    // combine 2 boxes here\n    d = min(d, sdBox(p, size));\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-5);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=dTree(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 178], [181, 244, 264, 306, 342], [344, 344, 365, 365, 634], [636, 636, 693, 693, 915]]}
{"id": "7djfWV", "name": "fold test dTree", "author": "takahiroando", "description": "based on: https://gam0022.net/blog/2017/03/02/raymarching-fold/", "tags": ["fold"], "likes": 0, "viewed": 159, "published": 3, "date": "1647169519", "time_retrieved": "2024-07-30T16:58:59.355052", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p){\n    p -= vec3(2.0, 0.0, 0.0);\n    p.xy*=rot(iTime*1.);\n    p.xz*=rot(iTime*1.);\n    // This is a 2D SDF to 3D trick.\n    // 1. Calculate 2D SDF\n    float sdf2d=abs(length(p.xy)-1.)-.2;\n    // 2. Calculate 1D SDF\n    float d=abs(p.z)-.3;\n    // 3. Combie them by max(boolean)\n    return max(sdf2d,d);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n// from: https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec3 foldX(vec3 p) {\n    // This is the trick to make a mirror\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat dTree(vec3 p) {\n    vec3 size = vec3(0.1, 1.0, 0.1);\n    float d = sdBox(p, size);\n    p = foldX(p);\n    p.y -= 0.1;\n    p.xy *= rot(-1.2); // angle of arm\n    d = min(d, sdBox(p, size));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-5);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=dTree(foldX(p)));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 371], [374, 374, 405, 405, 501], [504, 567, 587, 629, 665], [667, 667, 688, 688, 876], [878, 878, 935, 935, 1164]]}
{"id": "7sjfWK", "name": "torus UVs", "author": "elenzil", "description": "just working out torus UVs", "tags": ["torus"], "likes": 7, "viewed": 226, "published": 3, "date": "1647157573", "time_retrieved": "2024-07-30T16:59:00.282571", "image_code": "// CC0: elenzil\n\n// return UV coords for torus with major axis = y\n// todo: incorporate fabrice's conformal mapping: https://www.shadertoy.com/view/sdd3R4\n// thanks: oneshade !\nvec2 torusUV(in vec3 p, in float majorRadius) {\n    float f = atan(p.z, p.x);\n    float g = atan(p.y, length(p.xz) - majorRadius);\n    return vec2(f, g) / PI * 0.5 + 0.5;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////\n\n\nconst int   gMarchMaxSteps      = 150;\nconst float gMarchUnderStep     = 0.7;\nconst float gMarchHorizon       = 100.0;\nconst float gMarchHorizonSq     = gMarchHorizon * gMarchHorizon;\nconst float gMarchEps           = 0.001;\nconst float gNormEps            = gMarchEps;\n\n// for development: bigger pixels = clearer problems\nconst float gDownRes            = 1.0;\n\n\nconst uint  gMaximumRaysInQueue = 20u;\n\n// the maximum total number of calls to Map().\nconst float gMaxTotalMapIters   = float(gMarchMaxSteps) * 10.0;\n\n// the least significant ray which will be processed\nconst float gMinRayContribution = 0.001;\nconst float gMinRayContribSq    = gMinRayContribution * gMinRayContribution;\n\n\n\nfloat gSSZoom = 1e9;\nfloat gSSEps = 1e9;\nfloat gT = 1e9;\nfloat gTotalMapIters = 0.0;\n\n// distance from camera to center of scene\nfloat gCamDist     = 20.0;\nvec3  gSceneCenter = gVBig;\nvec3  gLightDir    = gVBig;\nvec2  gTorusDims   = gVBig.xy;\nvec3  gTorusPos    = gVBig;\nfloat gHexTileFac  = 0.67;\n\n\nvec2 gMouse   = gVBig.xy;  // 0 to RES\nvec2 gSSMouse = gVBig.xy;  // 0 to 1\n\nstruct ray_t {\n    vec3 ro;\n    vec3 rd;\n    bool internal;\n    bool shadow;\n    vec3 contribution;\n};\n\nstruct marchResult_t {\n    float t;\n    uint  m;\n};\n\n\n// \"diffuse\"  includes regular diffuse plus ambient\n// \"specular\" includes reflection and transmission\nstruct material_t {\n    vec3 c1;\n    vec3 c2;\n    \n    // 0 = all diffuse, 1 = all specular\n    float diffuseVsSpecular1;\n    float diffuseVsSpecular2;\n    \n    // 0 = all reflection, 1 = all transmission\n    // scoped to 'specular'\n    float reflectionVsTransmission;\n    \n    // Lambert's linear attenuation coefficient\n    float attenuationCoefficient;    \n};\n\nconst uint kMSky   = 0u;\nconst uint kMFloor = 1u;\nconst uint kMTorus = 2u;\nconst uint kMBall  = 3u;\n\n\n// scoped to 'diffuse'.\nvec3 gAmbientLight     = gVBig;\nvec3 gDirectionalLight = gVBig;\n\n\nmaterial_t[] kMaterials = material_t[] (\n    // sky\n    material_t (\n        1.0 * vec3(0.1, 0.2, 1.0),\n        1.0 * vec3(0.3, 0.05, 0.1),\n        0.0, 0.0,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // floor\n    material_t (\n        gV1 * 0.8,\n        gV1 * 0.8,\n        0.4, 0.02,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    ),\n    \n    // torus\n    material_t (\n        gV1 * 0.8,\n        gV1 * 0.0,\n        0.1, 0.1,        // directional -> specular  1 & 2\n        0.0,             // reflection  -> transmission\n        0.0              // linear attenuation\n    )\n);\n\nvoid configMaterials() {\n    float ambientLightAmt = 0.3;\n    float directionalLightAmt = 1.0 - ambientLightAmt;\n    \n    gAmbientLight     = ambientLightAmt * sky(gV1n);\n    gDirectionalLight = clamp(directionalLightAmt * sky(-gLightDir) * 3.0, 0.0, 1.0);\n}\n\n\n// queue of ray_t's. ------------------------------\n#define QTYPE ray_t\nconst uint gQCapacity = gMaximumRaysInQueue;\nconst uint gQNumSlots = gQCapacity + 1u; QTYPE gQ[gQNumSlots]; uint gQHead = 0u; uint gQTail = 0u;\nuint QCount    ()           { if (gQHead >= gQTail) {return gQHead - gQTail;} else { return gQNumSlots - (gQTail - gQHead); } }\nuint QSpaceLeft()           { return gQCapacity - QCount(); }\nbool QIsFull   ()           { return QSpaceLeft() == 0u;}\nbool QIsEmpty  ()           { return QCount() == 0u; }\nvoid QEnqueue  (QTYPE item) { gQHead = (gQHead + 1u) % gQNumSlots; gQ[gQHead] = item; }\nQTYPE QDequeue ()           { gQTail = (gQTail + 1u) % gQNumSlots; return gQ[gQTail]; }\n//-------------------------------------------------\n\nvec3 toSpaceTorus(in vec3 p) {\n    vec3 pt = p - dot(gTorusDims, vec2(1.0)) * gVy;\n    pt.xy *= rot2(PI/2.0);\n    return pt;\n}\n\nvoid configGlobals1() {\n    gT       = mod(iTime, gMaxTime);\n    \n    gSSZoom  = 1.2;\n    gSSEps   = 4.0 / MINRES / gSSZoom;\n    \n    gMouse   = length(iMouse.xy) < 50.0 ? (vec2(sin(gT * 0.05107), -sin(gT * 0.051)) * 0.5 + 0.5) * RES.xy : iMouse.xy;\n    gSSMouse = gMouse/RES.xy;\n    \n    gLightDir     = normalize(-gVy + gVz * 0.4);\n    float sunTime = 40.0;\n    gLightDir.yx *= rot2(PI/2.0 * 1.01 * sin(sunTime) * sign(cos(sunTime)));\n    gLightDir.xz *= rot2(gT * 0.005);\n    \n    gTorusDims.x = mix(3.0, 9.0, smoothstep(-0.8, 0.8, sin(gT * 0.0)));\n    gTorusDims.y = mix(1.0, gTorusDims.x * 0.7, smoothstep(-0.8, 0.8, sin(gT * 0.1)));\n    gTorusPos    = dot(gTorusDims, vec2(1.0)) * gVy;\n    gSceneCenter = gTorusPos;\n\n    configMaterials();\n}\n\n\nmarchResult_t map(vec3 p) {\n    gTotalMapIters += 1.0;\n        \n    float d1 = p.y;\n    vec3 ps = abs(p.xyz);\n    float sr = 6.0;\n    ps -= vec3(50.0, sr, 50.0);\n    ps.y = mod(ps.y + sr, sr * 2.0) - sr;\n    d1 = min(d1, length(ps) - 6.0);\n\n    vec3 pt = toSpaceTorus(p);\n\n    float thick = 0.5;\n    float sep = (gTorusDims[0] + gTorusDims[1] * 2.0) * 2.0 / 12.0;\n    float gap = (sep - thick) / 2.0 * smoothstep(-0.1, 0.1, cos(10.0 + gT * 0.15 - floor((p.y + sep/2.0)/sep) * 0.05));\n    float d2 = sdTorus(pt, gTorusDims);\n    float noMoreVariableNames = mix(gTorusDims[1], thick, smoothstep(-0.1, 0.1, cos(2.0 + gT * 0.15 + floor((p.y + sep/2.0)/sep) * 0.05)));\n    d2 = max(d2, -sdTorus(pt, gTorusDims - vec2(0.0, noMoreVariableNames)));\n    \n    d2 = max(d2, -(abs(mod(pt.x + sep/2.0, sep) - sep/2.0) - gap));\n    \n    marchResult_t ret = marchResult_t(1e9, kMSky);\n    if (d1 < ret.t) { ret = marchResult_t(d1, kMFloor); }\n    if (d2 < ret.t) { ret = marchResult_t(d2, kMTorus); }\n    \n    return ret;\n}\n\nvoid getCamPosDir(out vec3 camPos, out vec3 camDir) {\n    float y    = smoothstep(0.05, 0.95, gSSMouse.y);\n    camPos     = gVz * gCamDist;\n    camPos.yz *= rot2((0.4 - y * 0.5) *  PI / 2.0);\n    camPos.xz *= rot2((gSSMouse.x * 2.0 - 1.0) * -PI * 1.1);\n    camPos    += gSceneCenter + gVy * 3.0;\n    \n    camDir     = normalize(gSceneCenter - camPos);\n}\n\nray_t getCamRay(in vec2 uv, float camZoom, in vec3 contribution) {\n    vec3 camPos;\n    vec3 camDir;\n    getCamPosDir(camPos, camDir);\n    ray_t ray;\n    ray.ro           = camPos;\n    ray.rd           = getCamRayDir(camDir, uv, camZoom);\n    ray.internal     = map(camPos).t < 0.0;\n    ray.shadow       = false;\n    ray.contribution = contribution;\n    return ray;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*gNormEps).t;\n    }\n    return normalize(n);\n}\n\nmarchResult_t march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    vec3 p = ro;\n    \n    for (int n = 0; dot(p, p) < gMarchHorizonSq; ++n) {\n        marchResult_t mr = map(p);\n        if (mr.t < gMarchEps || n == gMarchMaxSteps) {\n            return marchResult_t(t, mr.m);\n        }\n        \n        t += mr.t * gMarchUnderStep;\n        p = ro + t * rd;\n    }\n    \n    return marchResult_t(1e9, 0u);\n}\n\n\nvec3 sky(vec3 dir) {\n    vec3 ret = simple_sky(gVy * -1.5, dir, -gLightDir);\n    // ungamma.\n    // I'm not sure if this is 'correct'\n    // but without it there are nasty pops in the post-sunset darkness.\n    ret = pow(ret, vec3(1.5));\n    return ret;\n}\n\nstruct materialProps_t {\n    vec3 albedo;\n    vec3 emissive;\n    float diffuse_vs_specular;  // 0 = diffuse 1 = specular\n};\n\n\nmaterialProps_t getMaterialProps(in vec3 p, uint m) {\n    materialProps_t ret;\n    \n    material_t mat = kMaterials[m];\n    \n    ret.albedo              = mat.c1;\n    ret.emissive            = gV0;\n    ret.diffuse_vs_specular = mat.diffuseVsSpecular1;\n\n    // special cases\n    switch (m) {\n        case kMFloor: {\n            float theta = atan(p.z, p.x);\n            theta += 0.02 * length(p.xz);\n            float f = smoothstep(-0.01, 0.01, sin(theta * 6.0 + PI/6.0));\n            ret.albedo              = mix(mat.c1, mat.c2, f);\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, f);\n            break;\n        }\n        case kMTorus: {\n            ret.albedo = gV0;\n            \n            vec2 uv = torusUV(toSpaceTorus(p), gTorusDims[0]);\n            \n            uv += gT * vec2(0.01, 0.05);\n            \n            uv = fract(uv);\n            \n            vec2 scale = vec2(90.0, 31.0);\n            \n            vec2 tmp = uv * scale;\n            vec2 ht  = hextile(tmp);\n\n            if (ht.x < -scale.x + 0.001) {\n                ht.x = 0.0;\n            }\n            if (ht.y < -scale.y / 1.75) {\n                ht.y = 0.0;\n            }\n            \n            float h = hash12(ht);\n            \n            ret.albedo              = mix(mat.c1, mat.c2, h);\n            ret.diffuse_vs_specular = mix(mat.diffuseVsSpecular1, mat.diffuseVsSpecular2, h);\n            \n            // dots, but some glitch at the seams.\n            // ret.diffuse_vs_specular *= 0.1 + 0.9 * smoothstep(0.3, 0.31, length(tmp));\n            \n            break;\n        }\n    }\n    \n    \n    return ret;\n}\n\nvec3 processRays() {\n\n    vec3 rgb = gV0;\n\n    while (!QIsEmpty() && gTotalMapIters < gMaxTotalMapIters) {\n        ray_t ray = QDequeue();\n        \n        vec3 rayRGB = gV0;\n\n        marchResult_t mr = march(ray.ro, ray.rd);\n        \n        if (ray.shadow) {\n            if (mr.t > 1e4) {\n                rgb += ray.contribution;\n            }\n        }\n        else {\n            if (mr.t < 1e4) {\n                vec3 p = ray.ro + ray.rd * mr.t;\n\n                vec3 n = calcNormal(p);\n\n                materialProps_t mp = getMaterialProps(p, mr.m);\n\n                vec3 albedo = mp.albedo;\n\n                float specAmt = mp.diffuse_vs_specular;\n                float diffAmt = 1.0 - specAmt;\n\n                float maximumDirectionalContribution = max(0.0, dot(n, -gLightDir));\n\n                vec3 directionalAmt = gDirectionalLight * maximumDirectionalContribution;\n                vec3 diffContrib = directionalAmt * albedo * diffAmt;\n\n                if (gLightDir.y < 0.0) {\n                    if (maximumDirectionalContribution > 0.0 && !ray.internal && !QIsFull() && dot(diffContrib, diffContrib) > gMinRayContribSq) {\n                        ray_t shdwRay;\n                        shdwRay.ro           = p + n * gMarchEps * 2.0;\n                        shdwRay.rd           = -gLightDir;\n                        shdwRay.contribution = ray.contribution * diffContrib;\n                        shdwRay.internal     = false;\n                        shdwRay.shadow       = true;\n                        QEnqueue(shdwRay);\n                    }\n                    else {\n                        rayRGB += diffContrib;\n                    }\n                }\n                \n                rayRGB += albedo * gAmbientLight;\n                rayRGB += mp.emissive;\n\n                vec3 specContrib = ray.contribution * specAmt;\n\n                if (!QIsFull() && dot(specContrib, specContrib) > gMinRayContribSq) {\n                    ray_t rflRay;\n                    rflRay.ro = p + n * gMarchEps * 2.0;\n                    rflRay.rd = reflect(ray.rd, n);\n                    rflRay.contribution = specContrib;\n                    rflRay.internal = ray.internal;\n                    rflRay.shadow       = false;\n                    QEnqueue(rflRay);\n                }\n\n            }\n            else {\n                rayRGB += sky(ray.rd);\n            }\n            rgb += ray.contribution * rayRGB;\n        }\n    }\n    \n    return rgb;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    configGlobals1();\n    \n    vec2 uv = (floor((XY - RES.xy/2.0)/gDownRes)) / MINRES * 2.0 * gSSZoom * gDownRes;\n    \n    QEnqueue(getCamRay(uv, 2.0, gV1));\n    \n    vec3 rgb = processRays();\n    \n    rgb = pow(rgb, vec3(1.0/2.2));\n    \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "#define RES     (iResolution)\n#define MINRES  (min(RES.x, RES.y))\n#define ZERO    (min(iFrame,0))\n\n\nconst float PI       = 3.14159265359;\nconst float gMaxTime = 3e3;   // numerical precision gets bad above this\n\nconst vec3 gV0   = vec3(0.0);\nconst vec3 gV1   = vec3(1.0);\nconst vec3 gV1n  = normalize(gV1);\nconst vec3 gVx   = vec3(1.0, 0.0, 0.0);\nconst vec3 gVy   = vec3(0.0, 1.0, 0.0);\nconst vec3 gVz   = vec3(0.0, 0.0, 1.0);\nconst vec3 gVBig = vec3(1e13);\n\nvec3 sky(vec3 dir);\n\n// general math\nmat2 rot2(float theta) { float c = cos(theta); float s = sin(theta); return mat2(c, s, -s, c); }\n\nfloat square(float a) { return a * a; }\nfloat selfDot(vec2 a) { return dot(a, a); }\nfloat selfDot(vec3 a) { return dot(a, a); }\n\n// author: Neil Mendoza   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\n//mat4 rotationMatrix(vec3 axis, float angle) {     axis = normalize(axis);     float s = sin(angle);     float c = cos(angle);     float oc = 1.0 - c;          return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,                0.0,                                0.0,                                0.0,                                1.0); \n\n\n// author: blackle mori   license: unknown    link: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\nreturn mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle);\n}\n\n// SDF manipulators\nfloat opU(float a, float b) {\n    return min(a, b);\n}\nfloat opS(float a, float b) {\n    return -min(-a, b);\n}\n\n// SDF primitives\n\nfloat sdPlaneY(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec3 getCamRayDir(vec3 camDir, vec2 uv, float zoom) {\n\n    vec3 camFw = normalize(camDir);\n    vec3 camRt = normalize(cross(camFw, gVy));\n    vec3 camUp = cross(camRt, camFw);\n    \n    uv /= zoom;\n    \n    return normalize(camFw + camRt * uv.x + camUp * uv.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// { 2d cell id, distance to border, distance to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n\n\n\n// author: sam hocevar, license: WTFPL, link: https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c) {   vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));     float d = q.x - min(q.w, q.y);     float e = 1.0e-10;     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }\nvec3 hsv2rgb(vec3 c) {   vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\n\n\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    vec3 sun = simple_sun(d, lightDir);\n    vec3 sky = d * 0.25 + 0.25;\n    return clamp(max(sun, sky), 0.0, 1.0);\n}\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 177, 224, 224, 349], [3207, 3207, 3231, 3231, 3465], [3684, 3684, 3713, 3713, 3811], [3812, 3812, 3841, 3841, 3873], [3874, 3874, 3903, 3903, 3931], [3932, 3932, 3961, 3961, 3986], [3987, 3987, 4016, 4016, 4074], [4075, 4075, 4104, 4104, 4162], [4216, 4216, 4246, 4246, 4342], [4344, 4344, 4367, 4367, 5091], [5094, 5094, 5121, 5121, 6102], [6104, 6104, 6157, 6157, 6457], [6459, 6459, 6525, 6525, 6826], [6829, 6875, 6900, 6900, 7103], [7105, 7105, 7144, 7144, 7508], [7511, 7511, 7531, 7531, 7765], [7893, 7893, 7946, 7946, 9532], [9534, 9534, 9554, 9554, 11990], [11992, 11992, 12035, 12035, 12302]]}
{"id": "sdjBDK", "name": "Fractal knots 10", "author": "jarble", "description": "Yet another fractal knot pattern", "tags": ["fractal", "knot"], "likes": 2, "viewed": 212, "published": 3, "date": "1647151050", "time_retrieved": "2024-07-30T16:59:01.386620", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<12;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            uv /= -2.5+t2.x;\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2+t3)/scale;\n            uv += uv/scale;\n        }\n        col.x = (uv.y-uv.x+col.x);\n        col = abs(col.yzx-vec3(col.x));\n    }\n    fragColor = vec4(col/2.,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 901]]}
{"id": "NdjBDV", "name": "12-03-2022 MM Experiment", "author": "PauloFalcao", "description": "Something I have done now in Material Maker playing with MFSDF and transformations in rotation", "tags": ["materialmaker", "nodes", "mfsdf"], "likes": 29, "viewed": 478, "published": 3, "date": "1647129692", "time_retrieved": "2024-07-30T16:59:02.403900", "image_code": "// Material Maker Experiment 12-03-2022\n// By PauloFalcao\n//\n// Made in material maker\n//\n// MaterialMaker is a node based shader maker\n// where nodes have functions as inputs\n// so it's possible to do raymarching, fractals,\n// and more pretty things\n//\n// Material Maker\n//   https://rodzilla.itch.io/material-maker\n//\n// My Raymarching library for Material Maker\n//   https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n\n\n#define SEED_VARIATION 0.0\n\nfloat wave3d_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nvec3 MFSDF_Obj_Maker_rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nfloat mfsdf3d_smooth_union_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn min(a,b)-h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_union(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n    float h=mfsdf3d_smooth_union_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_union_f(a.w+e,b.w,k)-mfsdf3d_smooth_union_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_union_f(a.w,b.w+e,k)-mfsdf3d_smooth_union_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_subtraction_f(float a,float b,float k){\n\tfloat h = max( k-abs(-a-b), 0.0 )/k;\n\treturn max(-a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_subtraction(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_subtraction_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_subtraction_f(a.w+e,b.w,k)-mfsdf3d_smooth_subtraction_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_subtraction_f(a.w,b.w+e,k)-mfsdf3d_smooth_subtraction_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\nfloat mfsdf3d_smooth_intersection_f(float a,float b,float k){\n\tfloat h = max( k-abs(a-b), 0.0 )/k;\n\treturn max(a,b)+h*h*k*0.25;\n}\n\nvec4 mfsdf3d_smooth_intersection(vec4 a, vec4 b, float k) {\n    float e=0.001;\n    k=max(k,e);\n\tfloat h=mfsdf3d_smooth_intersection_f(a.w,b.w,k);\n\tvec2 n=normalize(vec2(mfsdf3d_smooth_intersection_f(a.w+e,b.w,k)-mfsdf3d_smooth_intersection_f(a.w-e,b.w,k),\n                          mfsdf3d_smooth_intersection_f(a.w,b.w+e,k)-mfsdf3d_smooth_intersection_f(a.w,b.w-e,k)));\n    return vec4(mix(a.xyz,b.xyz,atan(abs(n.y),abs(n.x))/(3.14159265359/2.0)),h);\n}\n\n// https://www.shadertoy.com/view/XsX3zB by Nikita Miropolskiy\n// MIT License\n\n// discontinuous pseudorandom constly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_oct_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_oct_F3 =  0.3333333;\nconst float XsX3zB_oct_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_oct_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_oct_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_oct_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_oct_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_oct_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_oct_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_oct_random3(s), x);\n\t d.y = dot(XsX3zB_oct_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_oct_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_oct_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}\n\nvec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n\n//Simple HDRI END\nconst float p_o8705_CamX = 0.872000000;\nconst float p_o8705_CamY = 1.094000000;\nconst float p_o8705_CamZ = 3.000000000;\nconst float p_o8705_LookAtX = 0.000000000;\nconst float p_o8705_LookAtY = 0.000000000;\nconst float p_o8705_LookAtZ = 0.000000000;\nconst float p_o8705_CamD = 1.500000000;\nconst float p_o8705_CamZoom = 2.347000000;\nconst float p_o8705_SunX = 2.500000000;\nconst float p_o8705_SunY = 2.500000000;\nconst float p_o8705_SunZ = 2.500000000;\nconst float p_o8705_AmbLight = 0.250000000;\nconst float p_o8705_AmbOcclusion = 1.000000000;\nconst float p_o8705_Shadow = 1.000000000;\nconst float p_o8705_Gamma = 1.300000000;\nconst float p_o8718_xyz = 0.451000000;\nconst float p_o8718_x = 1.000000000;\nconst float p_o8718_y = 1.000000000;\nconst float p_o8718_z = 1.000000000;\nconst float p_o8738_k = 0.446000000;\nconst float p_o8725_k = 1.000000000;\nconst float p_o8714_BaseColor_r = 1.000000000;\nconst float p_o8714_BaseColor_g = 0.656250000;\nconst float p_o8714_BaseColor_b = 0.000000000;\nconst float p_o8714_BaseColor_a = 1.000000000;\nconst float p_o8714_Specular = 0.961000000;\nconst float p_o8714_Roughness = 0.000000000;\n\n\nfloat o8762_fct(vec3 uv, float _seed_variation_) {\n\treturn mix3d_xor(wave3d_square(uv.x), wave3d_square(uv.y), wave3d_square(uv.z));\n}\n\nvec3 o8714_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n    vec3 o8762_0_1_tex3d = vec3(o8762_fct((p).xyz, _seed_variation_));\n    return o8762_0_1_tex3d;\n}\n\nfloat o8714_input_Metallic_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o8714_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o8714_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nvec3 o8714_input_Emission_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(1.0,1.0,1.0);\n}\n\nvec3 o8714_input_Normal_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(0.0,1.0,0.0);\n}\n\nfloat o8714_input_Alpha_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\nfloat o8714_input_AmbientOcclusion_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nconst float p_o8719_d = 3.140000000;\nconst float p_o8713_r = 0.610000000;\n\nfloat o8719_input_in(vec2 uv, float _seed_variation_) {\n    float o8713_0_1_sdf2d = length((uv)-vec2((cos(_seed_variation_*6.0)*0.4)+0.5, (sin(_seed_variation_*5.0)*0.4)+0.5))-p_o8713_r;\n    return o8713_0_1_sdf2d;\n}\n\nfloat o8714_input_sdf3d(vec3 p, float _seed_variation_) {\n    vec2 o8719_0_q = vec2(length((p).xy)-p_o8719_d+0.5, (p).z+0.5);\n    float o8719_0_1_sdf3d = o8719_input_in(o8719_0_q,atan((p).x,(p).y));\n    return o8719_0_1_sdf3d;\n}\n\n\nvec4 PBRObjectMaker_o8714(vec4 uv, float _seed_variation_) {\n\tfloat sdf=o8714_input_sdf3d(uv.xyz, _seed_variation_);\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o8714_Roughness*o8714_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o8714_Specular*o8714_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o8714_BaseColor_r, p_o8714_BaseColor_g, p_o8714_BaseColor_b, p_o8714_BaseColor_a).rgb*o8714_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nconst float p_o8726_BaseColor_r = 0.000000000;\nconst float p_o8726_BaseColor_g = 0.424825996;\nconst float p_o8726_BaseColor_b = 1.000000000;\nconst float p_o8726_BaseColor_a = 1.000000000;\nconst float p_o8726_Specular = 0.969000000;\nconst float p_o8726_Roughness = 0.000000000;\n\n\nvec3 o8726_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n    return vec3(1.0);\n}\n\nfloat o8726_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o8726_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nconst float p_o8737_d = 4.730000000;\nconst float p_o8730_r = 0.500000000;\n\nfloat o8737_input_in(vec2 uv, float _seed_variation_) {\n    float o8730_0_1_sdf2d = length((uv)-vec2((cos(_seed_variation_*9.0)*0.6)+0.5, (sin(_seed_variation_*7.0)*0.4)+0.5))-p_o8730_r;\n    return o8730_0_1_sdf2d;\n}\n\nfloat o8726_input_sdf3d(vec3 p, float _seed_variation_) {\n    vec2 o8737_0_q = vec2(length((p).xy)-p_o8737_d+0.5, (p).z+0.5);\n    float o8737_0_1_sdf3d = o8737_input_in(o8737_0_q,atan((p).x,(p).y));\n    return o8737_0_1_sdf3d;\n}\n\nvec4 PBRObjectMaker_o8726(vec4 uv, float _seed_variation_) {\n   // uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o8726_TranlateX,p_o8726_TranlateY,p_o8726_TranlateZ),vec3(p_o8726_RotateX,p_o8726_RotateY,p_o8726_RotateZ)*6.28318530718)/p_o8726_scale;\n\tfloat sdf=o8726_input_sdf3d(uv.xyz, _seed_variation_);\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o8726_Roughness*o8726_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o8726_Specular*o8726_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o8726_BaseColor_r, p_o8726_BaseColor_g, p_o8726_BaseColor_b, p_o8726_BaseColor_a).rgb*o8726_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nconst float p_o8733_BaseColor_r = 1.000000000;\nconst float p_o8733_BaseColor_g = 1.000000000;\nconst float p_o8733_BaseColor_b = 1.000000000;\nconst float p_o8733_BaseColor_a = 1.000000000;\nconst float p_o8733_Specular = 1.000000000;\nconst float p_o8733_Roughness = 0.000000000;\nconst float p_o8733_scale = 1.000000000;\nconst float p_o8733_TranlateX = 0.000000000;\nconst float p_o8733_TranlateY = 0.000000000;\nconst float p_o8733_TranlateZ = 0.000000000;\nconst float p_o8733_RotateX = 0.000000000;\nconst float p_o8733_RotateY = 0.000000000;\nconst float p_o8733_RotateZ = 0.000000000;\nconst float p_o8749_g_0_pos = 0.409091000;\nconst float p_o8749_g_0_r = 1.000000000;\nconst float p_o8749_g_0_g = 0.000000000;\nconst float p_o8749_g_0_b = 0.000000000;\nconst float p_o8749_g_0_a = 1.000000000;\nconst float p_o8749_g_1_pos = 0.518182000;\nconst float p_o8749_g_1_r = 1.000000000;\nconst float p_o8749_g_1_g = 1.000000000;\nconst float p_o8749_g_1_b = 1.000000000;\nconst float p_o8749_g_1_a = 1.000000000;\n\nvec4 o8749_g_gradient_fct(float x) {\n  if (x < p_o8749_g_0_pos) {\n    return vec4(p_o8749_g_0_r,p_o8749_g_0_g,p_o8749_g_0_b,p_o8749_g_0_a);\n  } else if (x < p_o8749_g_1_pos) {\n    return mix(vec4(p_o8749_g_0_r,p_o8749_g_0_g,p_o8749_g_0_b,p_o8749_g_0_a), vec4(p_o8749_g_1_r,p_o8749_g_1_g,p_o8749_g_1_b,p_o8749_g_1_a), ((x-p_o8749_g_0_pos)/(p_o8749_g_1_pos-p_o8749_g_0_pos)));\n  }\n  return vec4(p_o8749_g_1_r,p_o8749_g_1_g,p_o8749_g_1_b,p_o8749_g_1_a);\n}\n\nconst float p_o8744_scale = 3.768000000;\nconst float p_o8744_scale_x = 1.000000000;\nconst float p_o8744_scale_y = 1.000000000;\nconst float p_o8744_scale_z = 1.000000000;\nconst float p_o8744_transx = 0.000000000;\nconst float p_o8744_transy = 0.000000000;\nconst float p_o8744_transz = 0.000000000;\nconst float p_o8744_persistence = 0.500000000;\nconst float p_o8744_brightness = 0.000000000;\nconst float p_o8744_contrast = 2.255000000;\n\nfloat o8744_fbm(vec3 coord, float persistence, float _seed_variation_) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfloat size = 1.0;\n\tfor (int i = 0; i < 2; i++) {\n\t\tvalue += XsX3zB_oct_simplex3d(coord*size) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nfloat o8744_bc(float f,float contrast, float brightness, float _seed_variation_) {\n\treturn f*contrast+brightness+0.5-contrast*0.5;\n}\n\nvec3 o8733_input_BaseColor_tex3d(vec4 p, float _seed_variation_) {\n    vec3 o8744_0_out = vec3(o8744_bc(o8744_fbm((p).xyz*vec3(p_o8744_scale_x,p_o8744_scale_y,p_o8744_scale_z)*0.5*p_o8744_scale+vec3(p_o8744_transx,p_o8744_transy,p_o8744_transz),p_o8744_persistence, _seed_variation_)*0.5+0.5,p_o8744_contrast,p_o8744_brightness, _seed_variation_));vec3 o8744_0_1_tex3d = o8744_0_out;\n    vec3 o8749_0_1_tex3d = o8749_g_gradient_fct(dot(o8744_0_1_tex3d, vec3(1.0))/3.0).rgb;\n    return o8749_0_1_tex3d;\n}\n\nfloat o8733_input_Specular_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nfloat o8733_input_Roughness_tex3d(vec4 p, float _seed_variation_) {\n    return 1.0;\n}\n\nconst float p_o8739_Distort = 0.107000000;\nconst float p_o8739_Correction = 0.000000000;\nconst float p_o8739_Bound = 9.411000000;\nconst float p_o8732_d = 4.320000000;\nconst float p_o8731_r = 0.610000000;\n\nfloat o8732_input_in(vec2 uv, float _seed_variation_) {\n    float o8731_0_1_sdf2d = length((uv)-vec2((cos(_seed_variation_*4.0)*0.6)+0.5, (sin(_seed_variation_*4.0)*0.4)+0.5))-p_o8731_r;\n    return o8731_0_1_sdf2d;\n}\n\nfloat o8739_input_sdf(vec3 p, float _seed_variation_) {\n    vec2 o8732_0_q = vec2(length((p).xy)-p_o8732_d+0.5, (p).z+0.5);\n    float o8732_0_1_sdf3d = o8732_input_in(o8732_0_q,atan((p).x,(p).y));\n    return o8732_0_1_sdf3d;\n}\n\nvec3 o8739_input_tex3d(vec4 p, float _seed_variation_) {\n    vec3 o8744_0_out = vec3(o8744_bc(o8744_fbm((p).xyz*vec3(p_o8744_scale_x,p_o8744_scale_y,p_o8744_scale_z)*0.5*p_o8744_scale+vec3(p_o8744_transx,p_o8744_transy,p_o8744_transz),p_o8744_persistence, _seed_variation_)*0.5+0.5,p_o8744_contrast,p_o8744_brightness, _seed_variation_));vec3 o8744_0_1_tex3d = o8744_0_out;\n    return o8744_0_1_tex3d;\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o8739(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o8739_input_sdf(p+e.xyy, _seed_variation_);\n  float v2=o8739_input_sdf(p+e.yyx, _seed_variation_);\n  float v3=o8739_input_sdf(p+e.yxy, _seed_variation_);\n  float v4=o8739_input_sdf(p+e.xxx, _seed_variation_);\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nfloat distortByNormal_o8739(vec3 uv, float _seed_variation_) {\n    float d=o8739_input_sdf(uv, _seed_variation_);\n\tif (d<=abs(p_o8739_Distort*(p_o8739_Bound+1.0))+0.01){\n\t\tvec3 n=normal_o8739(uv, _seed_variation_);\n\t\tvec3 s=o8739_input_tex3d(vec4(uv,0.0), _seed_variation_);\n\t\treturn o8739_input_sdf(uv-(n*s*p_o8739_Distort), _seed_variation_);\n\t} else return d;\n}\n\nfloat o8733_input_sdf3d(vec3 p, float _seed_variation_) {\n    float o8739_0_1_sdf3d = distortByNormal_o8739((p), _seed_variation_)/(1.0+p_o8739_Distort*p_o8739_Correction);\n    return o8739_0_1_sdf3d;\n}\n\n\nvec4 PBRObjectMaker_o8733(vec4 uv, float _seed_variation_) {\n    uv.xyz=MFSDF_Obj_Maker_rotate3d(uv.xyz-vec3(p_o8733_TranlateX,p_o8733_TranlateY,p_o8733_TranlateZ),vec3(p_o8733_RotateX,p_o8733_RotateY,p_o8733_RotateZ)*6.28318530718)/p_o8733_scale;\n\tfloat sdf=o8733_input_sdf3d(uv.xyz, _seed_variation_)*p_o8733_scale;\n\t//5 - Roughness\n\tif (uv.w>4.5) {\n\t\treturn vec4(p_o8733_Roughness*o8733_input_Roughness_tex3d(vec4(uv.xyz,5.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//4 - Specular\n\tif (uv.w>3.5) {\n\t\treturn vec4(p_o8733_Specular*o8733_input_Specular_tex3d(vec4(uv.xyz,4.0), _seed_variation_),0.0,0.0,sdf);\n\t} else\n\t//1 - BaseColor\n\tif (uv.w>0.5){\n\t\treturn vec4(vec4(p_o8733_BaseColor_r, p_o8733_BaseColor_g, p_o8733_BaseColor_b, p_o8733_BaseColor_a).rgb*o8733_input_BaseColor_tex3d(vec4(uv.xyz,1.0), _seed_variation_),sdf);\n\t} else\n\t//0 - SDF\n\t{\n\t\treturn vec4(vec3(0),sdf);\n\t}\n}\n\nvec4 o8705_input_mfsdf(vec4 p, float _seed_variation_) {\n\n    vec3 r=v4v4_rotate(p.xyz, -vec3(iTime*31.0, iTime*33.0, iTime*35.0)*0.01745329251);\n    if (iMouse.z>0.5){\n        r=vec3(p.xyz);\n    }\n    vec4 rot=vec4(vec4(r, p.w).xyz/vec3(p_o8718_x, p_o8718_y, p_o8718_z)/p_o8718_xyz,vec4(r,p.w).w);\n\n    vec4 o8714_0_1_v4v4 = PBRObjectMaker_o8714(rot, _seed_variation_);\n    vec4 o8726_0_1_v4v4 = PBRObjectMaker_o8726(rot, _seed_variation_);\n    vec4 o8725_0_1_v4v4 = mfsdf3d_smooth_union(o8714_0_1_v4v4, o8726_0_1_v4v4,p_o8725_k);\n    vec4 o8733_0_1_v4v4 = PBRObjectMaker_o8733(rot, _seed_variation_);\n    vec4 o8738_0_1_v4v4 = mfsdf3d_smooth_union(o8725_0_1_v4v4, o8733_0_1_v4v4,p_o8738_k);\n    vec4 o_o8718_0=o8738_0_1_v4v4;vec4 o8718_0_1_v4v4 = vec4(o_o8718_0.xyz,o_o8718_0.w*min(min(p_o8718_x, p_o8718_y), p_o8718_z)*p_o8718_xyz);\n    vec4 o8720_0_1_v4v4 = o8718_0_1_v4v4;\n\n    return o8720_0_1_v4v4;\n}\nvec3 o8705_input_hdri(vec2 uv, float _seed_variation_) {\n\nreturn Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o8705_SunX,p_o8705_SunY,-p_o8705_SunZ)));\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o8705(vec3 p, float _seed_variation_) {  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=o8705_input_mfsdf(vec4(p+e.xyy,0.0), _seed_variation_).w;\n  float v2=o8705_input_mfsdf(vec4(p+e.yyx,0.0), _seed_variation_).w;\n  float v3=o8705_input_mfsdf(vec4(p+e.yxy,0.0), _seed_variation_).w;\n  float v4=o8705_input_mfsdf(vec4(p+e.xxx,0.0), _seed_variation_).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o8705(inout float d,inout vec3 p,float dS, vec3 ro, vec3 rd, float _seed_variation_) {\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = o8705_input_mfsdf(vec4(p,0.0), _seed_variation_).w;\n        d += dS;\n        if (d > 50.0 || abs(dS) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o8705( in vec3 pos, in vec3 nor , float _seed_variation_) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = o8705_input_mfsdf(vec4( pos + h*nor ,0.0), _seed_variation_).w;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o8705( in vec3 ro, in vec3 rd, in float mint, in float tmax, float _seed_variation_) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = o8705_input_mfsdf(vec4( ro + rd*t ,0.0), _seed_variation_).w;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o8705(vec2 uv, float _seed_variation_) {\n    uv-=0.5;\n\n    float mx=iMouse.x/iResolution.x*PI*2.0;\n    float my=iMouse.y/iResolution.y*PI/2.01;\n    \n    vec3 lookat=vec3(p_o8705_LookAtX,p_o8705_LookAtY,p_o8705_LookAtZ);\n    \n    vec3 cam;\n    if (iMouse.z<0.1){\n        cam=vec3((sin(iTime*0.1)*2.0),(sin(iTime*0.13)*1.0),(sin(iTime*0.17)*2.0))*p_o8705_CamZoom;\n    } else {\n        cam=lookat+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*6.0;\n    }\n    \n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o8705_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tfloat dS=0.0;\n\tmarch_o8705(d,p,dS,ro,rd, _seed_variation_);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=o8705_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;   // 1 - BaseColor (r,g,b,sdf) linear (0-1) \n\tfloat objSpecular=o8705_input_mfsdf(vec4(p,4.0), _seed_variation_).x*0.2;  // 4 - Specular  (v,0,0,sdf)\n\tfloat objRoughness=o8705_input_mfsdf(vec4(p,5.0), _seed_variation_).x; // 5 - Roughness (v,0,0,sdf)\n\tvec3 light=normalize(vec3(p_o8705_SunX,p_o8705_SunY,p_o8705_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o8705(p, _seed_variation_);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o8705(p,n, _seed_variation_),p_o8705_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o8705(p,light,0.05,5.0, _seed_variation_),p_o8705_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o8705_AmbLight)),max(l,p_o8705_AmbLight))*max(cAO,p_o8705_AmbLight)*objColor+4.0*pow(r,pow(256.0,(1.0-objRoughness)))*objSpecular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o8705(d,p,dS,p,ref, _seed_variation_);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=o8705_input_mfsdf(vec4(p,1.0), _seed_variation_).xyz;\n\t\t\tn=normal_o8705(p, _seed_variation_);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o8705_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o8705_input_hdri(equirectangularMap(ref.xzy), _seed_variation_).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,objSpecular);\n\t} else {\n\t\tcolor=o8705_input_hdri(equirectangularMap(rd.xzy), _seed_variation_).xyz;\n\t}\n\treturn pow(color,vec3(1.0/p_o8705_Gamma));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    float _seed_variation_ = SEED_VARIATION;\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o8705_0_1_rgb = raymarch_o8705((UV), _seed_variation_);\n    fragColor = vec4(pow(o8705_0_1_rgb,vec3(1.0/1.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 460, 490, 490, 530], [532, 532, 576, 576, 638], [640, 640, 687, 687, 991], [993, 993, 1047, 1047, 1115], [1117, 1117, 1169, 1169, 1531], [1533, 1533, 1593, 1593, 1663], [1665, 1665, 1723, 1723, 2112], [2114, 2114, 2175, 2175, 2243], [2245, 2245, 2304, 2304, 2698], [2779, 2850, 2883, 2883, 3056], [3182, 3202, 3238, 3480, 4472], [4474, 4474, 4508, 4508, 4812], [4844, 4844, 4879, 4879, 4968], [4992, 5066, 5101, 5101, 5218], [5220, 5220, 5253, 5253, 5549], [5551, 5551, 5587, 5587, 5794], [5796, 5796, 5831, 5831, 6040], [6042, 6042, 6079, 6079, 6168], [6170, 6170, 6220, 6220, 6767], [6769, 6769, 6817, 6817, 7087], [8237, 8237, 8287, 8287, 8371], [8373, 8373, 8439, 8439, 8540], [8542, 8542, 8608, 8608, 8626], [8628, 8628, 8694, 8694, 8712], [8714, 8714, 8781, 8781, 8799], [8801, 8801, 8866, 8866, 8898], [8900, 8900, 8963, 8963, 8995], [8997, 8997, 9060, 9060, 9078], [9079, 9079, 9153, 9153, 9171], [9248, 9248, 9303, 9303, 9464], [9466, 9466, 9523, 9523, 9694], [9697, 9697, 9757, 9757, 10379], [10660, 10660, 10726, 10726, 10750], [10752, 10752, 10818, 10818, 10836], [10838, 10838, 10905, 10905, 10923], [11000, 11000, 11055, 11055, 11216], [11218, 11218, 11275, 11275, 11446], [11448, 11448, 11508, 11697, 12319], [13318, 13318, 13354, 13354, 13770], [14206, 14206, 14278, 14278, 14559], [14561, 14561, 14643, 14643, 14693], [14695, 14695, 14761, 14761, 15198], [15200, 15200, 15266, 15266, 15284], [15286, 15286, 15353, 15353, 15371], [15578, 15578, 15633, 15633, 15794], [15796, 15796, 15851, 15851, 16022], [16024, 16024, 16080, 16080, 16427], [16429, 16505, 16556, 16556, 16882], [16884, 16884, 16946, 16946, 17248], [17250, 17250, 17307, 17307, 17452], [17455, 17455, 17515, 17515, 18338], [18340, 18340, 18396, 18396, 19247], [19248, 19248, 19304, 19304, 19424], [19426, 19502, 19553, 19553, 19935], [19937, 19937, 20034, 20034, 20227], [20229, 20274, 20346, 20346, 20646], [20648, 20693, 20800, 20800, 21150], [21152, 21152, 21206, 21206, 23431], [23433, 23433, 23488, 23488, 23821]]}
{"id": "fdjfWV", "name": "Fake 3D Mandelbulb", "author": "oneshade", "description": "Rendering a mandelbulb.", "tags": ["3d", "mandelbulb", "slicing"], "likes": 15, "viewed": 170, "published": 3, "date": "1647123341", "time_retrieved": "2024-07-30T16:59:03.277564", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nvec3 cart2pol(in vec3 p) {\n    return vec3(atan(p.z, p.x), atan(p.y, length(p.xz)), length(p));\n}\n\nvec3 pol2cart(in vec3 p) {\n    float cylRadius = cos(p.y);\n    return vec3(cos(p.x) * cylRadius, sin(p.y), sin(p.x) * cylRadius) * p.z;\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.5;\n    vec4 color = vec4(1.0);\n\n    float time = 0.01 * float(iFrame);\n    //time = mod(time, 10.0);\n\n    vec3 z = vec3(0.0);\n    vec3 c = vec3(uv, 0.25 * time - 1.1).xzy;\n\n    c.xy = Rotate2D(0.25) * c.xy;\n    c.yz = Rotate2D(-0.25) * c.yz;\n\n    // Try n=2 and i<10\n    float n = 8.0;\n    for (int i=0; i < 4; i++) {\n        vec3 s = cart2pol(z);\n        z = pol2cart(vec3(s.xy * n, pow(s.z, n))) + c;\n        if (length(z) > 2.0) {\n            color = vec4(0.0);\n            break;\n        }\n    }\n\n    vec2 bands = cos(cart2pol(c).xy * n);\n    color.rgb *= 0.5 + 0.4 * bands.x * bands.y;\n    color.rgb *= vec3(0.8, 0.3, 0.0);\n\n    //vec2 bands = sin(cart2pol(c).xy * 8.0);\n    //color.rgb *= mix(vec3(0.2), vec3(0.8, 0.2, 0.0), 0.5 + 0.5 * bands.x * bands.y);\n\n    fragColor += color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + 0.5);\n    fragColor /= 4.0;\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float time = 0.01 * float(iFrame);\n    //time = mod(time, 10.0);\n\n    uv.y -= 0.025 * time - 0.1;\n    uv.y /= 0.95;\n    uv = (uv * iResolution.y + 0.5 * iResolution.xy) / iResolution.xy;\n\n    fragColor = texture(iChannel0, st);\n    vec4 slice = texture(iChannel1, uv);\n    fragColor.rgb = mix(fragColor.rgb, slice.rgb, slice.w);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 175]]}
{"id": "fd2fDK", "name": "Filter your webcam", "author": "microwerx", "description": "This does a simple filter on the webcam.", "tags": ["webcam"], "likes": 3, "viewed": 404, "published": 3, "date": "1647110593", "time_retrieved": "2024-07-30T16:59:04.028556", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 webcam = texture(iChannel0, uv).rgb;\n   \n    \n    float angle = 1.0*iTime * 3.14159/180.0;\n    mat3 texcoordTransform = mat3(cos(angle), -sin(angle), 0,\n                                  sin(angle),  cos(angle), 0,\n                                  0, 0, 1);\n    uv = (texcoordTransform * vec3(uv, 0.0)).xy;\n   \n    if (length(webcam) < 0.9)\n        col *= webcam;\n    else\n        col += texture(iChannel1, uv * 2.0).rgb;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 779]]}
{"id": "7sSBDV", "name": "Saturday morning tinkering", "author": "mrange", "description": "CC0: Saturday morning tinkering\n Tinkering a bit on shader morning with something that looks like a bit like \n a truchet pattern but isn't\n", "tags": ["2d"], "likes": 14, "viewed": 271, "published": 3, "date": "1647088086", "time_retrieved": "2024-07-30T16:59:04.898230", "image_code": "// CC0: Saturday morning tinkering\n// Tinkering a bit on shader morning with something that looks like a bit like \n// a truchet pattern but isn't\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nconst int no_buckets = 3;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p) {\n  return abs(length(p) - 0.5);\n}\n\nfloat segmentx(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  return p.x > 0.0 ? d1 : d0;\n}\n\nint bucket(vec2 n) {\n  const float bs = float(no_buckets);\n  float h = hash(n);\n  return int(floor(h*bs));\n}\n\nstruct selector {\n  bool sc;\n  bool s1;\n  bool s2;\n  bool s4;\n  bool s8;\n  bool c3;\n  bool c6;\n  bool c9;\n  bool c12;\n};\n\nconst selector selectors[16] = selector[](\n    selector(true , false, false, false, false, false, false, false, false)  // 0\n  , selector(true , true , false, false, false, false, false, false, false)  // 1\n  , selector(true , false, true , false, false, false, false, false, false)  // 2\n  , selector(false, false, false, false, false, true , false, false, false)  // 3\n  , selector(true , false, false, true , false, false, false, false, false)  // 4\n  , selector(false, true , false, true , false, false, false, false, false)  // 5\n  , selector(false, false, false, false, false, false, true , false, false)  // 6\n  , selector(true , true , true , true , false, false, false, false, false)  // 7\n  , selector(true , false, false, false, true , false, false, false, false)  // 8\n  , selector(false, false, false, false, false, false, false, true , false)  // 9 \n  , selector(false, false, true , false, true , false, false, false, false)  // 10\n  , selector(true , true , true , false, true , false, false, false, false)  // 11\n  , selector(false, false, false, false, false, false, false, false, true )  // 12\n  , selector(true , true , false, true , true , false, false, false, false)  // 13\n  , selector(true , false, true , true , true , false, false, false, false)  // 14\n  , selector(true , true , true , true , true , false, false, false, false)  // 15\n  );\n\nfloat df(vec2 p, out float h, out int b) {\n  vec2 pp = p;\n  vec2 pn = floor(pp+0.5);\n  pp = fract(pp+0.5)-0.5;\n  h = hash(pn);\n\n  float d = 1E6;\n  float dc = length(pp)-0.1;\n  float ds1 = segmentx(-pp); \n  float ds2 = segmentx(-pp.yx); \n  float ds4 = segmentx(pp); \n  float ds8 = segmentx(pp.yx);\n  float dc3 = circle(pp-vec2( 0.5,  0.5));\n  float dc6 = circle(pp-vec2(-0.5,  0.5));\n  float dc9 = circle(pp-vec2( 0.5, -0.5));\n  float dc12= circle(pp-vec2(-0.5, -0.5));\n  \n  b  = bucket(pn);\n  int b0 = bucket(pn-vec2(-1.0,  0.0));\n  int b1 = bucket(pn-vec2( 0.0, -1.0));\n  int b2 = bucket(pn-vec2( 1.0,  0.0));\n  int b3 = bucket(pn-vec2( 0.0,  1.0));\n  \n  bool s0 = b0 == b;\n  bool s1 = b1 == b;\n  bool s2 = b2 == b;\n  bool s3 = b3 == b;\n\n  int sb = 0;\n  sb += s0 ? 1 : 0;\n  sb += s1 ? 2 : 0;\n  sb += s2 ? 4 : 0;\n  sb += s3 ? 8 : 0;\n  \n  selector sel = selectors[sb];\n  if (sel.s1)   d = min(d, ds1); \n  if (sel.s2)   d = min(d, ds2); \n  if (sel.s4)   d = min(d, ds4); \n  if (sel.s8)   d = min(d, ds8); \n  if (sel.c3)   d = min(d, dc3); \n  if (sel.c6)   d = min(d, dc6); \n  if (sel.c9)   d = min(d, dc9); \n  if (sel.c12)  d = min(d, dc12); \n\n  if (sel.sc)  d =min(d, dc);\n\n  float w = 0.075;  \n  d = d - w;\n  for (int ii = 0; ii < b; ++ii) {\n    d = abs(d) - w*0.5;\n    w *= 0.5;\n  }\n\n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float h;\n  int   b;\n  float z = mix(0.5, 0.05, smoothstep(-0.5, 0.5, -cos(0.5*TIME)));\n  vec2  dp = p;\n  const float off = 10.0; \n  dp /= z;\n  dp += off*vec2(cos(2.0*TIME/off*(vec2(1.0, sqrt(0.5)))));\n  float d = df(dp, h, b);\n  d *= z;\n  \n  float bh = float(b)/float(no_buckets);\n  vec3 bcol = hsv2rgb(vec3(bh, 0.75, 0.5));\n  vec3 col  = hsv2rgb(vec3(bh, 0.75, 0.125));\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[385, 385, 407, 407, 553], [967, 1067, 1088, 1088, 1161], [1162, 1262, 1284, 1284, 1333], [1335, 1395, 1419, 1419, 1489], [1491, 1491, 1513, 1513, 1546], [1548, 1548, 1572, 1572, 1651], [1653, 1653, 1673, 1673, 1761], [3253, 3253, 3295, 3295, 4551], [4554, 4554, 4611, 4611, 5211]]}
{"id": "7dSBDV", "name": "my first shader at ShaderToy!", "author": "fl0a1e", "description": "my first shader at ShaderToy!", "tags": ["2d", "circle"], "likes": 2, "viewed": 150, "published": 3, "date": "1647087405", "time_retrieved": "2024-07-30T16:59:05.776881", "image_code": "// ---------------------------------------\n// It's my first shader!\n// \n// create 2D circle\n// And I want to test something in this shader\n// Including SSAA and gamma \n// just for fun\n// ---------------------------------------\n\n#define AA 2\n#define INV_GAMMA 0.454545\n\n#define OUTSIDECIRCLE 0.0f\n#define INSIDECIRCLE 1.0f\n\nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\n\nfloat map(vec2 uv) {\n    float res = -1.0f;\n\n    // distance between uv and O\n    float r = 0.5*abs(sin(iTime))-0.2;\n    res = (sdCircle(uv, r) >= 0.05 && sdCircle(uv, r) <= 0.1) ? OUTSIDECIRCLE : res;\n    res = (sdCircle(uv, r) >= 0.001 && sdCircle(uv, r) <= 0.03) ? INSIDECIRCLE : res;\n\n    return res;\n}\n\n\nvec3 shader(vec2 uv, float flag){\n    // background\n    vec3 col = vec3(.03, .03, .06);\n    \n    // circle\n    if(flag == OUTSIDECIRCLE){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    if(flag == INSIDECIRCLE){\n        col = 0.5 + 0.5*cos(sin(iTime)+uv.xyx+vec3(0,2,4));\n        \n    }\n    return col;\n}\n\n\nvec3 render(vec2 uv){\n    \n    // 2D raymarching(I called so)\n    float flag = map(uv);\n    \n    // shadering\n    vec3 col = shader(uv, flag);\n    \n    // others\n    if(uv.y <= .001 && uv.y >= .0){\n        col = vec3(1,1,1);\n    }\n    if(uv.x <= .001 && uv.x >= .0){\n        col = vec3(1,1,1);\n    }\n    if(sdCircle(uv, .001) <= .005){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;\n    \n    // SSAA\n    #if AA > 1\n    for(int i = 0; i < AA; i++)\n        for(int j = 0; j < AA; j++){\n            vec2 offset = (vec2(i,j)/float(AA)) - 0.5;\n\n            // SSAA:1 pixel->AA*AA pixels\n            // move our coordinates to center\n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = ((fragCoord+offset)-0.5*iResolution.xy)/iResolution.x; // fix range of x axis\n            \n    #else\n            vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n            // ----------------------------------------------\n            col = render(uv);\n            \n    \n     #if AA>1 \n          // can't be dropped in 3D scene, maybe, because we have sampled a pixel AA*AA times\n          // col /= float(AA*AA);\n        }\n     #endif\n   \n    \n    // gamma\n    col = pow(col, vec3(INV_GAMMA));\n    \n    vec3 tot = col;\n    \n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 355, 355, 381], [384, 384, 404, 404, 690], [693, 693, 726, 744, 1015], [1018, 1018, 1039, 1079, 1433]]}
{"id": "7sSfWK", "name": "Fractal knots 9", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 5, "viewed": 264, "published": 3, "date": "1647059980", "time_retrieved": "2024-07-30T16:59:06.585719", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a = -a;\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<12;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        //float scale = scale+col.x/16.;\n        for(int k = 0; k < 3; k++){\n            \n            //uv /= -scale-col.x;\n            uv += (t2.yx);\n            uv /= -scale*scale;\n            \n            //uv -= offset + (t2.yx)/(scale+length(col));\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx-.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale);\n            \n            uv.yx = (t2+t3)/scale;\n            uv += uv/scale;\n            //t2 /= (1.-temp);\n            //offset -= col.x/16.;\n            //offset += offset1;\n        }\n        //offset += .5/scale;\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n        //scale *= 1.0+col.x/16.;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 134, 246], [248, 248, 305, 305, 1523]]}
{"id": "7dSfWK", "name": "Fractal knots 8", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 2, "viewed": 226, "published": 3, "date": "1647059353", "time_retrieved": "2024-07-30T16:59:07.433452", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a = -a;\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<12;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        //float scale = scale+col.x/16.;\n        for(int k = 0; k < 3; k++){\n            \n            //uv /= -scale-col.x;\n            uv += (t2.yx);\n            uv /= -scale*scale;\n            \n            //uv -= offset + (t2.yx)/(scale+length(col));\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx-.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale);\n            \n            uv.yx = (t2-t3)/scale;\n            uv += uv/scale;\n            //t2 /= (1.-temp);\n            //offset -= col.x/16.;\n            //offset += offset1;\n        }\n        //offset += .5/scale;\n        col.x = abs(uv.y+uv.x-col.x);\n        //col.x = abs(uv.y-abs(uv.x-col.x));\n        //col.x = abs(abs(col.x-uv.y)+uv.x/2.);\n        //col.x = abs(abs(col.x-uv.x)+uv.y/2.);\n        //col.x = abs(abs(uv.y-uv.x)-col.x/2.);\n\n        col = col.yzx;\n        //scale *= 1.0+col.x/16.;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 134, 246], [248, 248, 305, 305, 1723]]}
{"id": "fdBfDK", "name": "BulbVolumetrics", "author": "El_Sargo", "description": "Volumetric lighting on a mandelbulb.", "tags": ["3d", "raymarching", "volumetric"], "likes": 12, "viewed": 330, "published": 3, "date": "1647045513", "time_retrieved": "2024-07-30T16:59:08.270215", "image_code": "#define AA 1\nconst int steps = 50;\n\nvec3 calcNormal( in vec3 p, float d ){\n    float h = 0.0001*d;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h, iTime);\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor, iTime);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat getVL(vec3 ro, vec3 rd, float maxLen){\n\n    const float stepsize = 0.02;\n                float vl = 0.;\n                 float t = 0.;\n    const float d = 2.2;\n    for(int i=0;i<200;i++){\n        float s = length(ro+t*rd);\n        #define scatter\n        #ifdef scatter\n        float e = exp(-s);\n        vl += 0.25*texture(iChannel0, normalize(ro+t*rd)).x * e;\n        vl += max(0.,1. - e)*0.01;\n        #else\n        vl += 0.25*texture(iChannel0, normalize(ro+t*rd)).x * exp(-s);\n        #endif\n        t += stepsize;\n        if (t > maxLen)\n            break;\n    }\n    \n    return vl;\n}\n\n//iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    // World info\n       vec3 p = intersection(ro,rd, steps, iTime);\n      float d = distance(p,ro);\n       tdp md = sdMandelBulb(p, iTime);\n    float trp = distance(md.pos, p);\n    \n    //Shading\n     vec3 nor = calcNormal(p, d);\n    float occ = calcAO(p, nor);\n\n    //Colors\n    vec3 col = vec3(0);\n    vec3 bcl = vec3(0.1);\n    vec3 scl = vec3(1.,0.8,0.6);\n    vec3 amb = vec3(0.6,0.8,1.);\n    vec3 vol = palette(iTime*0.066, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n    //\n    if (map(p, iTime) < 0.1) {\n        col += bcl;\n        col += .4*amb*occ*occ*occ; \n        col += pow(1.-abs(dot(nor,rd)), 4.)*0.3*vol;\n        col += vol*max(0.,(.5-occ*occ));\n        \n        vec3 hvc = normalize(-normalize(p)-rd);\n        col += pow(max(0.,dot(nor,hvc)),10.);\n    } else\n        col = vec3(0.2);\n        \n    float vl = getVL(ro, rd, distance(p,ro)); \n    \n    col += vol * smoothstep(0.,12.,vl);\n    \n    return vec4(col, 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -2.5);\n    mat3 yrot = roty(iTime*0.4);\n    mat3 xrot = rotx(0.7);\n           ro*=xrot*yrot;\n           ro += vec3(0,0.2,0);\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n\n    \n    // Output to screen\n    \n    tot = smoothstep(vec4(0), vec4(1.01), tot);\n    \n    fragColor = tot;\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//Shadow map of sorts, used for the volumetric lighting\n/*\nWe basicly start 1 unit away from the bulb in the direction rd,\nand then march towards the bulb.\n\nWe can get away with very few steps because the lighting is supposed to be kinda fuzzy\n\nThe function that sampels this map is in the image pass at line 40\n*/\n\n//lol\nconst int steps = 1;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\n    ro = rd*1.;//Starting pos\n    rd *= -1.; //March to the center\n    \n    vec3 p = intersection(ro, rd, steps, iTime);\n    \n    float g = length(p);\n    \n    //uncomment for uniform glow\n    //g = 0.;\n    \n    //uncomment for no lighting\n    // g= 1.;\n    \n    // Output to cubemap\n    fragColor = vec4(smoothstep(1.,.98,g));\n}", "cube_a_inputs": [], "common_code": "//Was created so that orbit traps could be used for coloring but I didn't end up using them\nstruct tdp{\n    vec3 pos;\n    float dist;\n};\n\n#define ZERO min(iFrame, 0)\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n//Returns the distance to the mandel bulb and the transformed pos of p\ntdp sdMandelBulb(vec3 p, float time) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.;\n\tfloat r, theta, phi;\n\tfloat dr = .84;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r) + time*0.4;\n\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn tdp(z, 0.5 * log(r) * r / dr);\n}\n\n\nconst float pi = 3.14159265359;\n\n//Distance to the scene\nfloat map(vec3 p, float time){\n    return sdMandelBulb(p, time).dist;\n}\n\n\nvec3 intersection(vec3 ro, vec3 rd, int steps, float time){\n    for(int i=0;i < steps;i++){\n        float dist = map(ro, time);\n        ro += rd*dist*0.92;\n        if(dist <0.01)\n            break;\n    }\n    return ro;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 74, 74, 300], [301, 301, 334, 334, 600], [602, 602, 646, 646, 1198], [1200, 1205, 1277, 1277, 1320], [1322, 1322, 1352, 1370, 2330], [2331, 2331, 2388, 2388, 3019]]}
{"id": "7sjfWy", "name": "Pseudo Fluid", "author": "SnoopethDuckDuck", "description": "nice little for loop\n", "tags": ["e"], "likes": 5, "viewed": 366, "published": 3, "date": "1647023194", "time_retrieved": "2024-07-30T16:59:09.125927", "image_code": "#define pi 3.14159\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // larger n -> larger chain of dots\n    float n = 12.;    \n    for (float i = 0.; i < n; i++) {\n        float io = 8. * pi * i / n;\n        float s = sign(uv.x);\n        uv *= Rot(thc(1.5, io + 8. * length(uv) - iTime) * s * pi / n);\n        uv -= 0.024 * s; // increase multiplier to get bigger flames\n    }\n    \n    float s = exp(0.05 - 2.5 * length(uv));\n    vec3 e = vec3(1);    \n    vec3 col = s * pal(0.2 + 0.25 * length(uv), e, e, e, 0.35 * vec3(0,1,2)/3.);\n    col = sqrt(col) + 0.08;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 179, 179, 222], [224, 224, 281, 281, 882]]}
{"id": "7d2BWG", "name": "Little Basket", "author": "SnoopethDuckDuck", "description": "not happy with the colors + messy code. the hole when it squashes is actually a bug lol\n\n2D version here: https://www.shadertoy.com/view/ss2BWG\nalternated and layered ^", "tags": ["e"], "likes": 12, "viewed": 259, "published": 3, "date": "1647008119", "time_retrieved": "2024-07-30T16:59:09.866946", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 angleMod(vec3 p, in float r) {\n    float a = pi / r;\n    \n    float a2 = mod(atan(p.z, p.x) + a, 2. * a) - a;\n    \n    p.xz = length(p.xz) * vec2(cos(a2), sin(a2));\n    \n    return p;\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 1.82, -3.5 - (0.15 + 0.15 * thc(3., 0.5 * iTime)));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    p.xz *= Rot(-0.1 * iTime);\n    vec3 op = p;\n   // p *= 1.5;\n   //p *= 0.8;\n    //p.xz *= 0.5 + 0.3 * thc(1., iTime - cos(1.2 * p.y - 0.5 * iTime) + p.y);\n    p.xz *= 1.3;\n    p.xz /= abs(thc(1., 0.8 * p.y));\n\n    float n = 21.;\n    float r = 2. + (0.25 + 0.25 * thc(6., 0.5 * iTime));// * thc(1., p.y);//sqrt(abs(1. - p.y * p.y));\n\n    vec3 q = p;\n    //q.xz *= Rot(0.5 * pi / n); // if n is even\n    q = angleMod(q, 2. * n);\n    q.x -= r;\n    float w = 0.025;\n\n    float d = length(q.xz) - w;\n    \n    float sc = 1.;\n    float i = 1.;\n    p.y = fract(p.y) - 0.5;\n    float m = 0.25;//0.15 + 0.1 * cos(q.y + iTime);\n    // bad way of doing it, but it works! :)\n    for (int j = 0; j < 4; j++) {\n        i *= sign(p.y);\n        p.y = abs(p.y) - m;\n        m *= 0.5;\n    }\n\n    float d1 = length(p.xz) - r;\n    float a = atan(p.x, p.z);\n    float d2 = length(vec2(d1, p.y) - vec2(2. * w * cos(n * a + i * pi/2.), 0)) - w;\n\n    float d3 = length(vec2(d1, op.y - 1.4)) - w;\n\n   // float \n\n   //d2 *= 0.05;\n    d2 = min(d2, d);\n    d2 *= 0.08;\n    d2 = max(d2, op.y - 1.4);\n    d2 = max(d2, -op.y - 1.4);\n    d2 = min(d2, d3);\n    \n    d2 = min(d2, op.y * (1. + 0.2 * cos(length(op.xz) - iTime))+ 1.7);\n    \n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat getLight(vec3 p) {\n    vec3 lp = vec3(5. * cos(iTime), 4, 5. * sin(iTime));\n    float l = length(lp - p);\n    if (RayMarch(p, lp - p, 1.) < l) return 0.;\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    \n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 1.); \n        col.rg += 0.75 * fresnel2;\n        col *= 0.7 + 0.3 * n.y;\n       \n        col = clamp(col, 0., 1.);\n       \n        col -= 0.4 * cross(col, n);\n       \n        if (p.y > -1.4) {\n            //col.r = 0.;\n            float iy = floor(8. * p.y) + 0.5;\n            iy /= 8.;\n            col *= 0.4 * iy + 0.5;\n       \n        }\n        vec3 e = vec3(1);\n        vec3 pal = pal(0.1 * log(length(p.xz)), e, e, e, 0.4 * vec3(0,1,2)/3.);\n        col *= pal;\n      //  col = mix(col, pal, exp(-4. * length(p.xz)));\n        \n       // col *= getLight(p - 30. * SURF_DIST * n);\n       //col = clamp(col,0.,1.);\n        //want to add shadows + light\n        // + curve into basket maybe\n    \n    }\n    col = mix(vec3(0), col, exp(-0.1 * length(p)));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 670, 670, 825], [827, 827, 841, 841, 1039], [1041, 1041, 1064, 1064, 2288], [2290, 2290, 2333, 2333, 2640], [2642, 2642, 2666, 2666, 2856], [2858, 2858, 2908, 2908, 3099], [3101, 3101, 3125, 3125, 3282], [3284, 3284, 3341, 3341, 4983]]}
{"id": "fd2BDy", "name": "Blurred Net", "author": "dr2", "description": "Blurred Apollonian net", "tags": ["blur", "dof", "focus", "apollonian"], "likes": 13, "viewed": 323, "published": 3, "date": "1647003366", "time_retrieved": "2024-07-30T16:59:10.609959", "image_code": "// \"Blurred Net\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define txBuf iChannel0\n\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 txVal, col4;\n  vec2 canvas, uv, duv;\n  float dstFoc, dPix, r;\n  float ga = pi * (3. - sqrt(5.));\n  const float NP = 32.;\n  canvas = iResolution.xy;\n  uv = fragCoord / canvas;\n  dstFoc = 5.; // (from \"Losing Focus 2\")\n  dPix = abs (dstFoc - texture (txBuf, uv).a);\n  duv = 0.0008 * dPix * vec2 (canvas.y / canvas.x, 1.);\n  col4 = vec4 (0.);\n  for (float n = float (VAR_ZERO); n < NP; n ++) {\n    r = sqrt (n / NP);\n    txVal = texture (txBuf, uv + duv * r * sin (n * ga + vec2 (0.5 * pi, 0.)));\n    col4 += vec4 (txVal.rgb, 1.) * exp (-1. * r * r) *\n       clamp (1. + (1. + 0.1 * txVal.a * txVal.a) * (abs (dstFoc - txVal.a) - dPix), 0., 1.);\n  }\n  col4.rgb /= col4.a;\n  fragColor = vec4 (col4.rgb, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Blurred Net\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm3 (vec3 p);\n\nvec3 ltDir;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat tCur, dstFar;\nconst float pi = 3.1415927;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q;\n  q = vec4 (p, 1.);\n  q.xy -= TrackPath (p.z).xy;\n  for (float j = 0.; j < 8.; j ++) {\n    q.xyz = 2. * fract (0.5 * q.xyz + 0.5) - 1.;\n    q *= 1.3 / dot (q.xyz, q.xyz);\n  }\n  return 0.25 * (length (q.xyz) / q.w - 0.01);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.y), 0.5 * pi - acos (rd.z)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.6, 0.5, 0.), vec3 (0.9, 0.4, 0.2), 0.5 + 0.5 * rd.z) *\n     (0.24 + 0.44 * (rd.z + 1.) * (rd.z + 1.)) * (1. + 0.2 * gd);\n}\n\nvec4 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = mix (vec4 (0.6, 0.8, 0.6, 0.1), vec4 (0.8, 0.8, 0.9, 0.5), smoothstep (0.5, 0.55,\n       Fbm3 (16. * ro)));\n    col = col4.rgb * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n       col4.a * vec3 (1., 1., 0.) * pow (max (dot (ltDir, vn), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.2, 1., dstObj / dstFar));\n  } else col = bgCol;\n  return vec4 (clamp (col, 0., 1.), dstObj);\n}\n\n#define txSize iChannelResolution[0].xy\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, col4;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, asp, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  zmFac = 3.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  trkAx = 0.25 * vec2 (2., 0.9);\n  trkAy = 0.25 * vec2 (1.3, 0.66);\n  trkFx = 2. * vec2 (0.2, 0.23);\n  trkFy = 2. * vec2 (0.17, 0.24);\n  vFly = 0.5;\n  ro = TrackPath (vFly * tCur) + 1.;\n  vd = normalize (TrackVel (vFly * tCur));\n  az += atan (vd.x, vd.z);\n  vuMat = StdVuMat (el, az);\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n  dstFar = 50.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col4 = vec4 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col4 += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = col4;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2BDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[245, 245, 301, 301, 1014]]}
{"id": "WtfyR2", "name": "Oh Sodd0ff(fixed)", "author": "deuZige", "description": "It's not working. A copy paste from another shader and this one don't work. I've tried to find out why it don't work (the only way i seem to be able to learn) but i'm stumped.... \nAnyone wanna point me to the solution? I'd appreciate it like crazy!!", "tags": ["not", "it", "getting"], "likes": 2, "viewed": 242, "published": 3, "date": "1646976760", "time_retrieved": "2024-07-30T16:59:11.525511", "image_code": "/*\nI continue with my amiga retro effects.\nThis time a sinus scroller & a starfield.\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nStarfield:  https://www.shadertoy.com/view/lst3Wn by Gigatron\nFonts: https://www.shadertoy.com/view/4s3XDn by Andre\n*/\n\n\nvec3 SinusScroll(vec2 uv)\n{\n    uv.y+=0.22*sin(uv.x*6.+iTime*6.);\n    return texture(iChannel0, uv).xyz;\n    \n}\n\nconst vec2 O = vec2(0.,1.);\n\nfloat rand (in vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241);\n}\n\n\nfloat noise (in vec2 uv)\n{\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\nvec3 Starfield(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < 4; layer++) {\n\t\tfl = float(layer);\n\t\ts = (400.-fl*20.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s + iTime*-80. - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(4.));\n\t}\n\t \n\treturn vec3(stars);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pat = iTime*5.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec3 rainbow = vec3(0.5 + 0.5 * sin(uv.x*8. + 3.14 + pat), 0.5 + 0.5 * cos (uv.x*8. + pat), 0.5 + 0.5 * sin (uv.x*8. + pat));\n    float ay=0.1;\n    vec3 Color=vec3(0);\n    \n    if (uv.y > ay && uv.y < ay+0.006 || uv.y > (1.-ay) && uv.y < 1.-ay+0.006 ) Color = rainbow;\n    if(uv.y<ay || uv.y>1.-ay+0.006) Color=vec3 (0.0, 0.15, 0.25);\n    if(uv.y>ay+0.006 && uv.y<1.-ay && ay==0.1) Color+=SinusScroll(uv);\n    if(uv.y>ay+0.006 && uv.y<1.-ay && Color==vec3(0)) Color=Starfield(fragCoord);\n    \n\tfragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec2 coord;\n\n#define scrolltext BOLD d_ e_ u_ Z_ i_ g_ e_ _ b_ e_ a_ t_ i_ n_ g_ _ u_ r_ _ B_ r_ a_ i_ n_ _ w_ i_ t_ h_ _ A_ n_ o_ t_ h_ e_ r_ _ O_ l_ d_ s_ c_ h_ o_ o_ l_ M_ i_ x_ X_   _ _exclam _exclam  _   _ _dot _dot _dot _dot _dot _dot\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n#define _ cp+=.5;\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define crlf uv.y += 2.0; cp = 0.;\n\n// the test scroller\nvec3 Scroller(vec2 fragCoord )\n{\n    float ms = float(iMouse.w>0.);\n    float scale = 0.8;\n    vec2 mouseOffs = vec2(0);\n\tvec2 uv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.x+=8.*iTime;\n    uv.x-=290.;\n    uv.y-=0.55;\n    uv.x=mod(uv.x,150.)-30.;\n  \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n\n    //uv.x=uv.x+0.5*sin(uv.y+2.*iTime);\n    uv.y = mod(uv.y,2.0)-1.;\n    scrolltext\n    float weight  = 0.06;\n    return vec3(mix(us.rgb,vec3(0.5),smoothstep(weight-px,weight+px, x)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 Color=vec3(0);\n    float x = fragCoord.x;\n    float pat = iTime*5.0;\n    vec3 rainbow = vec3(0.5 + 0.5 * sin(x/120. + 3.14 + pat), 0.5 + 0.5 * cos (x/120. + pat), 0.5 + 0.5 * sin (x/120. + pat));\n    \n    if(uv.y>0.35 && uv.y<0.55)\n    {\n    vec3 cc = Scroller(fragCoord);\n    if(cc!=vec3(0.5)) Color=rainbow;\n    }\n    \n    fragColor = vec4( Color, 1.0 );\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 415, 415, 499], [530, 530, 555, 555, 623], [626, 626, 652, 652, 752], [754, 754, 786, 786, 1099], [1101, 1101, 1158, 1158, 1766]]}
{"id": "NdjfWG", "name": "Something's Not right.... ", "author": "deuZige", "description": "Not responding to mike, or any other sound....... Playing soundcloud allright though.", "tags": ["oldschool", "eq", "borked", "scrol"], "likes": 4, "viewed": 253, "published": 3, "date": "1646975995", "time_retrieved": "2024-07-30T16:59:12.322380", "image_code": "\nfloat time = 0.0;\nvec2 pos = vec2(0);  //  0 .. 1\nvec2 uv  = vec2(0);  // -1 .. 1\nvec2 tp  = vec2(0);  // text position\n\n//--- font data ---\n#define FONT_SIZE1 0.45\n#define FONT_SIZE2 0.3\n#define FONT_SPACE 0.45\n#define SIN_FREQ 0.75\n#define SIN_SPEED 3.0\n#define SCROLL_LEN 30.\n#define SCROLL_SPEED 2.0\n\n//----- access to the image of ascii code characters ------\n//#define S(a) c+=texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(a,15.999-float(a)/16.))/16.)).x; uv.x-=FONT_SPACE;\n\n#define S(a) c+=char(float(a)); tp.x-=FONT_SPACE;\n\n#define _note  S(10);\n#define _star  S(28);\n#define _smily S(29);\n#define _    S(32);\n#define _exc S(33);\n#define _add S(43);\n#define _dot S(46);\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n\n// return character intensity of ch at position tp\nfloat char(float ch)\n{\n  vec4 f = texture(iChannel0,clamp(tp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n  if (iMouse.z > 0.0) \n    return f.x;   // 2d \n  else\n    return f.x * (f.y+0.3)*(f.z+0.3)*2.0;   // 3d\n}\n\nvec4 ScrollText1()\n{\n  tp = uv / FONT_SIZE1;  // set font size\n  tp.x = 2.0*(tp.x -4. +mod(time*SCROLL_SPEED, SCROLL_LEN));\n  float SIN_AMP = 1.5 * iMouse.y  / iResolution.y - 0.5;\n  tp.y = tp.y +0.5 +SIN_AMP*sin(tp.x*SIN_FREQ +time*SIN_SPEED);\n\n  float c = 0.0;\n    \n  _d _e _u _Z _i _g _e _  _k _i _c _k _i _n _g _ _exc _exc\n\n  _ _O _L _D _S _C _H _O _O _L _ _1 _9 _9 _1 _ _exc _exc\n\n  _ _T _h _e _9 _0 _s _  _w _e _r _e _  _t _h _e _  _b _e _s _t _ _o _f _  \n\n  _ _h _u _m _a _n _  _h _i _s _t _o _r _y _ _ _G _R _E _E _T _Z\n      \n  _ _g _o _  _t _o _ _a _l _l _ _t _h _e _ _o _n _e _s\n      \n  _ _S _T _I _L _L _ _S _T _A _N _D _I _N _G _\n  \n_ _dot _dot _smily _dot _dot _dot _dot _smily _dot _dot  \n     \n_ _smily  _dot _dot _dot _dot \n\n  return c * vec4(pos, 0.5+0.5*sin(2.0*time),1.0);\n}\n\nvec4 ScrollText2()\n{\n  tp = uv / FONT_SIZE2;  // set font size\n  tp.x = 2.0*(tp.x-5.8+mod(time*SCROLL_SPEED, SCROLL_LEN));\n  tp.y = tp.y + 3.2;\n\n  float c = 0.0;\n  _ _star _ _star _ _star _ _star _ _note _note _note _note _  \n  _d _a _y _u _m _n _  _  _d _i _t _  _b _r _e _n _g _t _  \n  _m _e _m _o _r _i _e _s _ _f _r _o _m _ _l _a _n _g _  _v _e _r _v _l _o _g _e _n _ \n  _t _i _j _d _e _n _star _star _D _E _  _C _o _m _m _o _d _o _r _e _ _A _m _i _g _a _   \n  _note _note _note _note _ _star _ _star _ _star _ _star\n  // _1 _2 _3 _4 _5 _6 _7 _8 _9 _0 \n  return c * vec4(pos, 0.5+0.5*sin(time),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  pos = fragCoord.xy / iResolution.xy; //  0 .. 1\n  uv = pos*2.0 - 1.0;                  // -1 .. 1\n\n  fragColor  = ScrollText1();\n  fragColor += ScrollText2();\n}\n\n#define PI 3.14159265\n\nfloat rewrap(float r, float rep) {\n    \n    if (r < 0.) {\n        r = -r;\n    }\n    \n    r = mod(r*rep, PI);\n                  \n    return r/(PI);\n}\n\nvoid whatever( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    const int size = 24;\n                \n    float ar = iResolution.x / iResolution.y;\n    \n    px.y /= ar;\n    \n    vec2 pos = px-vec2(0.5, 0.5/ar);\n    \n    float len = length(pos);\n    \n\tvec3 color = vec3(0,0,0);\n    \n    float rep = 1.;\n    \n    float delta = rewrap(atan(pos.x, pos.y), rep);\n        \n    float div = 100./float(size);\n    \n    float modifier = sin(iTime*0.1);\n    \n    float index = float(int(mod(iTime*0.+delta+modifier, 1.) * 100. / div));\n    \n\tfloat f = texelFetch(iChannel0, ivec2(index/float(size)*512.,0), 0).x;\n    \n    float base = texelFetch(iChannel0, ivec2(0.*512.,0), 0).x;\n    \n    float cpi = smoothstep((0.1 + base*0.05), 0.15 + f * 0.01, len);\n       \n\tif (len < 0.15 + f * 0.1 && len > (0.1 + base*0.05) && mod(delta + modifier, 1./float(size)) < 0.035 && (delta) > 0.009)\n\t\tcolor = vec3(1.-delta, delta*0.3, delta);\n    \n    color *= cpi;\n    \n    if (len < 0.1 + base * 0.05 && len > 0.09 + base * 0.05)\n      color = vec3(1);\n    \n    float eq = texelFetch(iChannel0, ivec2(px.x*512.,1), 0).x;\n        \n    if (abs(px.y*ar-0.54+eq*0.1) < 0.008 && \n        px.x > 0.5-(0.1+base * 0.05-0.01) &&\n        px.x < 0.5+(0.1+base * 0.05-0.01)) {\n        color = vec3(eq,1.-eq,eq*eq);\n    }\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28327, "src": "https://soundcloud.com/twisted-events/mandalorian-darkside-glasgow-ttrp?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1831, 1882, 1904, 1904, 2110], [3516, 3516, 3573, 3573, 3752], [3777, 3777, 3811, 3811, 3925], [3927, 3927, 3983, 3983, 5298]]}
{"id": "7lcGDS", "name": "[CrzClm] Curtain", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n\nmousabled.", "tags": ["maptoy", "crazyclimbers"], "likes": 8, "viewed": 261, "published": 3, "date": "1646975843", "time_retrieved": "2024-07-30T16:59:13.333677", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 2.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nfloat gainstep(float edge0, float edge1, float x, float k) {\n    x = clamp((x-edge0)/(edge1-edge0), 0., 1.);\n    float a = .5*pow(2.*((x<.5)?x:1.-x), k);\n    return (x<.5)?a:1.-a;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q=abs(p)-s;\n    return length(max(vec3(0),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sdCurtain(vec3 p, vec2 pinY, float offsetY, float pushX, float smoothness, float curvature, bool wDump) {\n    #define w(p) (sin(p*25.)*.05)\n    \n    float py = p.y+offsetY;\n    float a = (.5/smoothness)*py*py+smoothness*.5;\n\tfloat b = abs(py);\n\tpy = b<smoothness ? a : b;\n    \n    const float offset = .1;\n    float movp = gainstep(pinY.x, pinY.y, py, curvature);\n    float damping = gainstep(pushX*1.5,.0,-p.x, 5.)*.85+.15;\n    if(wDump)pushX *= damping;\n    p.x+=movp*pushX;\n    p.x/=((1.-pushX)+pushX*(1.-movp));\n    float wavep = w(p.x);\n    float gp = (w(p.x-offset)-w(p.x+offset))/.05;\n    wavep /= gp;\n    p.z+=wavep;\n    vec3 s = vec3(.5,1.2,.015);\n    vec3 q = abs(p+vec3( .51,0,0))-s;\n    return length(max(vec3(0),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat map(vec3 p){\n    float bd = sdBox(p, vec3(1,1.2,.2));\n    if(bd>.01){\n        return bd*.75;\n    }\n    else{\n        p.z += gfbm(p.xy*vec2(8,3.), 1, .5)*.05;\n        float t = iTime*4.;\n        float handY = .4+.4*floor(sin(floor(t/TAU+TAU))*20.)/20.;\n        float openP = mod(floor((cos(floor(t/TAU+TAU)))*20.),2.);\n        float openN = mod(floor((sin(floor(t/TAU+TAU)))*20.),2.);\n        float dp = sdCurtain(p, vec2(1.8, -3.), handY, openP*(sin(t)+1.), .2, 1., true);\n        p.x*=-1.;\n        float dn = sdCurtain(p, vec2(1.8, -3.), handY, openN*(sin(t)+1.), .2, 1., false);\n        return min(dn,dp)*.3;\n    }\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        \n        fragColor = vec4(1, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 296, 296, 417], [419, 419, 448, 448, 536], [538, 538, 649, 649, 1305], [1307, 1307, 1325, 1325, 1931]]}
{"id": "7dSBDy", "name": "Nice little light", "author": "SnoopethDuckDuck", "description": "simple shader - doesnt work zoomed out ( because using exp(-cos(d)) )", "tags": ["e"], "likes": 12, "viewed": 327, "published": 3, "date": "1646959395", "time_retrieved": "2024-07-30T16:59:14.073698", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n    \n    // uv *= 2.5 + 1.5 * cc(1., 1. * length(uv) - iTime);\n    // uv *= 8.;\n    \n    vec2 v = vec2(0, 0.4 * thc(2., 1.5 * uv.x + iTime));\n    \n    // replace me with other distance functions\n    float d = abs(uv.y) * length(uv - v) - 1.5765;// + 0.0015 * h21(uv);\n    //d = length(uv) - 1.62;\n    float s = exp(-2.65 * cc(1., d));\n    \n    vec3 e = vec3(1);\n    vec3 col = s * pal(-0.38 * uv.y, e, e, e, 0.38 * vec3(0,1,2)/3.);\n    \n    // col = clamp(col, 0., 1.);\n    // col = sqrt(col) + 0.05;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 69, 69, 136], [138, 138, 204, 204, 247], [249, 249, 306, 306, 926]]}
{"id": "fs2BR3", "name": "Screen-space radiosity (static)", "author": "Dave_Hoskins", "description": "This is a static version, with sampling smoothing.\nFor the averaging I needed another buffer because buffer A is used for the radiosity, and it has a high dynamic range.\nEvery pixel is a light source.\n\n\n\n\n", "tags": ["3d", "screenspace", "radiosity"], "likes": 31, "viewed": 1098, "published": 3, "date": "1646944214", "time_retrieved": "2024-07-30T16:59:14.817709", "image_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Static version\n\n// 1. Render an unlit scene from the point of view of each pixel.\n// 2. Use screen buffer to store accumulated light. 🌞\n\n// Every pixel is a light source\n// This is simumlar to light patch rendering where you'd create and store a map of light patches\n\n\n// I amazes me how nicely it works, even though it can't see light from hidden objects.\n\n// I was inspired many years ago by this nice and descriptive article:\n// ( I think it was written before GPU shaders existed)\n// https://justinmeiners.github.io/Hugo-Elias-Radiosity/\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(coord), 0);\n    // Probably don't need to clamp, but I was getting a lot of computer crashes, so maybe it was a div by 0 thing.\n    col.w = max(col.w,  1.0);\n    // Divide by a frame count for averaging...\n    col.xyz /= col.w;\n    \n    colour = vec4(sqrt(col.xyz), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define UNI(a, b) (a.x) < (b.x) ? a:b\nstruct Box\n{\n    vec3 centre;\n    vec3 size;\n};\n\n// This is the simple room scene of boxes...\n// TRY LIFTING THE ROOF A LITTLE! 😀\n// Boxes filled in as above structure\nBox boxes[] = Box[]\n(\n    Box(vec3(0,0,-300), vec3(210,100,10)),\n    Box(vec3(-200,00,0), vec3(10,100,300)),\n    Box(vec3(100,0,300), vec3(100,100,10)),  // Either side of door\n    Box(vec3(-150,0,300), vec3(100,100,10)),\n    Box(vec3(-0,70,300), vec3(100,30,10)), // Lintel\n    Box(vec3(200,-70,0), vec3(10,40,300)),   // Window wall\n    Box(vec3(190.,60,0), vec3(20,40,300)),\n    Box(vec3(200.,0,0), vec3(10,40,120)),\n    Box(vec3(0.,110,0), vec3(200,10,300)),      // Roof\n    Box(vec3(0.,-120,0), vec3(200,20,300)),     // Floor\n    Box(vec3(150.,-50,150), vec3(10,200,10)),   // Pillar.\n    Box(vec3(-150.,-50,150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(150.,-50,-150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(-150.,-50,-150), vec3(10,200,10))  // Pillar.\n\n);\n\n//-----------------------------------------------------------------------------------------------------------------\n// Hash without Sine 2 (WebGL 2)\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/intersectors\nvec4 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec4(10000.0); // no intersection\n    vec3 norm = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4( tN, norm);\n}\n\n\n//-----------------------------------------------------------------------------------------------------------------\nvec4 boxWorldIntersection( in vec3 ro, in vec3 rd, vec3 loc, vec3 boxSize) \n{\n    return boxIntersection(ro-loc, rd, boxSize);\n}\n//-----------------------------------------------------------------------------------------------------------------\nvec4 traceScene(vec3 ori, vec3 dir)\n{\n    vec4 a,b;\n\n    a.x = 10000.0;\n    for (int i = 0; i < boxes.length(); i++)\n    {\n        a = UNI(a, boxWorldIntersection(ori, dir, boxes[i].centre, boxes[i].size));\n    }\n    return a;\n}\n//\n\n\n", "buffer_a_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define VIEW_PROJ_Z 1.25\nmat3 camMat;\nvec3 camPos;\nfloat time;\n//-----------------------------------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z));\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nmat3 cameraMat( in vec3 ro, in vec3 ta, float roll )\n{\n\tvec3 cw = normalize(ta-ro);\n   \n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    mat3 m;\n    m = mat3( cu, cv, cw );\n    return m;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvec2 getScreenspaceLocation(vec3 pos, mat3 cMat, vec3 cPos)\n{\n \n    mat3 inv = transpose(cMat);\n    vec3 cp = inv * (cPos - pos);\n    vec2 sun2d = VIEW_PROJ_Z * cp.xy / cp.z;\n    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);\n    vec2 st = .5+.5*sun2d*asp;\n    return st;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// The open areas are the only light source...\nvec3 getSky(vec3 ray)\n{\n\n    vec3 sunDir = normalize(vec3(30, 25., 20.));\n    \n    vec3 col1 =  texture(iChannel1, ray).xyz * 4.;\n\n    float sun = pow(max(dot(sunDir, ray), 0.0), 1000.0)*6000.0;\n    return col1+sun;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\n#define SAMPLES 50\n\nvec3 getPixelView(vec3 pos, vec3 nor, vec2 uv)\n{\n    vec3 col = vec3(0);    \n\n    for (int i = min(0, iFrame); i < SAMPLES; i++)\n    {\n        // Random hemispherical rays around the surface normal\n\n        vec3 ray  = (hash33(float(i*133)+pos*5.+iTime*5.)-.5);\n        ray = ray * sign(dot(ray, nor));\n        ray = normalize(ray+nor*.1);\n\n        vec4 res = traceScene(pos+nor*.1, ray);\n\n        if (res.x >= 10000.)\n        {\n            col += getSky(ray); \n        }\n        else\n        {\n            vec3 p = pos + ray * res.x;\n            vec2 st = getScreenspaceLocation(p,camMat, camPos);\n            // Add previous results if we can see them!\n            if (st.x >= 0.0 && st.x < 1.0 && st.y >=0.0 && st.y < 1.0)\n            {\n                col += texture(iChannel0, st).xyz * max(dot(ray, nor),0.) ;\n                // each pixel is lit by Lambert's cosine law.\n            }\n        }\n    }\n    return (col / float(SAMPLES)) ;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    time = iTime;\n    time = 6.5;\n    vec3 col = vec3(0);\n    vec2 uv = (-iResolution.xy + 2.0 * coord ) / iResolution.y;\n    camPos = vec3(-70, 0., sin(-time*.3)*230.0);\n    vec3 camTar = vec3(50, 10, 0);\n\n    camMat = cameraMat(camPos, camTar, 0.0);\n    vec3 ray = normalize( vec3(uv,  VIEW_PROJ_Z)) * camMat;\n   \n    vec4 res = traceScene(camPos, ray);\n    if (res.x >= 10000.)\n    {\n        col = getSky(ray);\n    }\n    else\n    {\n        vec3 pos = camPos + ray * res.x;\n        vec3 diff = texCube(iChannel3, pos*.004, res.yzw).xyz; // Get a diffuse texture\n        diff = diff*.5+.5;\n        \n        col = diff * getPixelView(pos, res.yzw, coord);\n    }\n    colour = vec4(col, 1.);\n\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 colour, in vec2 coord )\n{\n   vec4 ocol;\n   \n   \n   // Start with black...\n   if (iFrame == 0) \n   {\n       ocol = vec4(0);\n   }else\n   {\n       ocol = texelFetch(iChannel1, ivec2(coord), 0);\n   }\n\n   // Add each frame, including a frame count in w\n   vec4 col = texelFetch(iChannel0, ivec2(coord), 0);\n   // Col can get massive so always clamp it.\n   col = clamp(col, 0.0, 1.0);\n\n   \n   colour = ocol + col;\n   \n   \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2BR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[662, 662, 712, 712, 1029]]}
{"id": "fsjfWw", "name": "[CrzClm] Cartoon Drawing lines", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["texture", "crazyclimbers"], "likes": 3, "viewed": 338, "published": 3, "date": "1646933186", "time_retrieved": "2024-07-30T16:59:15.907794", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // transform canvas\n    R(uv, -PI*.15);\n    uv *= 3.;\n    uv.y*=.15;\n    \n    // debug scroll\n    uv+=iTime*.5;\n    \n    vec3 dc;\n    dc.x = gnoise(uv.xy*.75);\n    dc.y = gnoise(uv.yx*.5+2.);\n    dc.z = gnoise(dc.xy*15.);\n    \n    // wave\n    const float SHK = 50.;\n    float wave = uv.x*15.;\n    wave+=sin(uv.x*SHK) + cos(uv.y*20.)*.5;\n    wave+=length(dc.xy)*SHK;\n    wave = sin(wave);\n    wave *= dc.z;\n    \n    // mask\n    const float DEN = .7;\n    float msk = length(dc.xy)*DEN;\n    \n    float lines = smoothstep(msk, msk+18./iResolution.y, wave);\n    \n    fragColor = vec4(lines);\n}", "image_inputs": [], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n// https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n// https://www.shadertoy.com/view/3dVXDc\n// Gradient noise by iq (modified to be tileable)\nfloat gnoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\nfloat voronoi(in vec2 st, in float scl, in float speed, inout vec2 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec2 ist = floor(st);\n\tvec2 fst = fract(st);\n\tfor(float y=-1.; y<=1.; y+=1.){\n\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\tvec2 gridOffset = vec2(x,y);\n\t\t\tvec2 rnd = hash22(ist+gridOffset+speed*.5);\n\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\tif(d<res){\n\t\t\t\tres = d;\n\t\t\t\tid = rnd;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nfloat voronoi(in vec3 st, in float scl, in float speed, inout vec3 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec3 ist = floor(st);\n\tvec3 fst = fract(st);\n\tfor(float z=-1.; z<=1.; z+=1.){\n\t\tfor(float y=-1.; y<=1.; y+=1.){\n\t\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\t\tvec3 gridOffset = vec3(x,y,z);\n\t\t\t\tvec3 rnd = hash33(ist+gridOffset+speed*.5);\n\t\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\t\tif(d<res){\n\t\t\t\t\tres = d;\n\t\t\t\t\tid = rnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\nfloat gfbm(vec3 n, int rep, float pers){\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < rep; ++i)\n    {\n        noise += amp * gnoise(n * pers, pers);\n        pers *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat SMinC3(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = (0.25 - n*0.1) * ((n*n)*(n*n));\n    \n    return min(a, b) - o*r;\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n\tvec2 u = max(vec2(r + b,r + -a), vec2(0));\n\treturn min(-r, max (b, -a)) + length(u);\n}\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = SMinC3( res, d, s );\n    }\n    return res;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 695]]}
{"id": "NdSfDG", "name": "resilient distance field", "author": "sympou", "description": "click to draw,\nshift + click to remove !\n\na way to slowly \"correct\" a distance field,\nnot perfect, but might be useful for some situations.", "tags": ["sdf"], "likes": 19, "viewed": 372, "published": 3, "date": "1646928554", "time_retrieved": "2024-07-30T16:59:16.776472", "image_code": "//a lot of ressources found on iq's blog : https://iquilezles.org/www/index.htm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float SDFres = 1./iResolution.y;\n\n\tvec2 p = (2.0*fragCoord-iResolution.xy)*SDFres;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)*SDFres;\n\n\tfloat d = texelFetch( iChannel0, ivec2(fragCoord), 0 ).r;\n    \n\t// coloring, iq style\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.5 ) {\n        d =  texelFetch( iChannel0, ivec2(iMouse.xy), 0 ).r;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define repair true\n\nfloat sdCircle( in vec2 p ) {\n    return length(p) - 0.1;\n}\n\nfloat Cell( in ivec2 p ) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = clamp(p,ivec2(0),r-1);\n    return texelFetch(iChannel0, p, 0).r;\n}\n\nfloat sign2 (in float n) {\n    float s = sign(n);\n    return s - abs(s) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float SDFres = 1./iResolution.y;\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)*SDFres;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)*SDFres;\n    \n    ivec2 fc = ivec2(fragCoord);\n    \n    float d = Cell(fc);\n\n    // the resilient part\n        \n    if (repair) {\n\n        float si = sign2(d);\n\n        vec4 n = vec4(Cell(fc+ivec2(1,0)),\n                      Cell(fc-ivec2(1,0)),\n                      Cell(fc+ivec2(0,1)),\n                      Cell(fc-ivec2(0,1)));\n\n        vec2 normal = normalize( n.xz - n.yw ) * si;\n\n        float d2 = texture(iChannel0, (fragCoord - normal)/iResolution.xy).r;\n\n        if ( si == sign2(d2) ) {\n            d = min(d*si + SDFres, d2*si + SDFres*2. )*si;\n        }\n\n    }\n\n\n    // inputs\n    \n    if (iMouse.z > 0.5) {\n        float val = sdCircle(p-m);\n        float shiftKey = texelFetch( iChannel1, ivec2(16,0), 0 ).x;\n        d = (shiftKey<0.5) ? min(d,val):max(-val,d);\n    }\n    \n    // circle at the beginning\n\n    if (iFrame == 0) d = sdCircle(p);\n    \n    ////////\n    \n    fragColor = vec4(d,d,d,1.0);\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 138, 867]]}
{"id": "fsBfDR", "name": "[CrzClm] Multi Level AO", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["ao", "occlusion", "ambient", "crazyclimbers"], "likes": 12, "viewed": 470, "published": 3, "date": "1646893660", "time_retrieved": "2024-07-30T16:59:17.642157", "image_code": "#define LIGHTING\n#define AA\n\n#define PI acos(-1.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MIN_DIST 0.0001\n#define MAX_DIST 30.0\nvec3 ro = vec3(0), rd = vec3(0), camup;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n  p.x = abs(p.x);\n  vec2 sc = vec2(sin(per), cos(per));\n  float k = (sc.y * p.x > sc.x * p.z) ? dot(p.xz, sc) : length(p.xz);\n  return sqrt(dot(p, p) + r.x * r.x - 2.0 * r.x * k) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, vec3(0))) + vmax(min(d, vec3(0.0)));\n}\n\nfloat sdScene(vec3 p) {\n  p += vec3(0, 0, .3);\n  R(p.xz, PI);\n  float d = sdBox(p - vec3(0, .275, .4), vec3(.75, .5, .5));\n  d = abs(d - .025) - .02;\n  d = max(d, -p.z);\n  d = min(length(p + vec3(.25, .125 - abs(cos(iTime * 1.5)) * .2 - .0125, -.5)) - .125 + .0125 - length(vec2(sin(p.z * 50.), sin(p.y * 50.))) * .0125, d);\n  d = min(length(p + vec3(-.25, .125 - abs(sin(iTime * 1.5)) * .2, -.5)) - .125, d);\n  R(p.xz, sin(iTime * .5));\n  const float BR = .005;\n  d = min(sdBox(p + vec3(0, .125, -.75), vec3(.125 + abs(sin(iTime * .5)) * .125, .125, .125) - BR) - BR, d);\n  R(p.xz, cos(iTime * .5) * .5);\n  p += vec3(0, abs(cos(iTime * .25)) * .125, -.75);\n  R(p.yz, sin(iTime) * PI);\n  d = min(sdBox(p, vec3(.125 + abs(cos(iTime * .5)) * .125, .125, .125) - BR) - BR, d);\n\n  return d;\n}\n\nfloat intersect() {\n  float d = MIN_DIST;\n  for(int i = 0; i < 60; i++) {\n    vec3 p = ro + d * rd;\n    float res = sdScene(p);\n    if(abs(res) < MIN_DIST) break;\n    d += res;\n    if(d >= MAX_DIST) return MAX_DIST;\n  }\n  if(d > MAX_DIST) return MAX_DIST;\n  return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n  vec3 n = vec3(0.0);\n  for(int i = 0; i < 4; i++) {\n    vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n    n += e * sdScene(p + 0.0005 * e);\n  }\n  return normalize(n);\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat aoSeed = 0.;  // for reduce artefact that occur in lower number of samping.\nconst float MAX_SAMP = 4.;  // you can reduce number of samping at each level.\nfloat ao(vec3 p, vec3 n, float radius) {\n  float ao = 0.;\n  for(float i = 0.; i <= MAX_SAMP; i++) {\n    vec2 rnd = hash21(i + 1. + aoSeed);\n\n    // The contribution is adjusted according to the distance from the origin.\n    // http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n    float scale = (i + 1.) / MAX_SAMP;\n    scale = mix(.0, 1., pow(scale, .5));  // I should pow with 2., but it looks nicer with .5. I dont know why...\n\n    // random radians for rotate normal in hemisphere.\n    rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n    rnd.y = (rnd.y * 2. - 1.) * PI;\n    vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n    rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n    rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n    // http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n    rd *= sign(dot(rd, n));\n\n    float raylen = radius * scale;\n    vec3 rndp = p + normalize(n + rd) * raylen;\n    float res = clamp(sdScene(rndp) / raylen, .01, 1.);\n    ao += res;\n    aoSeed++;\n  }\n  return ao / float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld) {\n  float norm_factor = (shininess + 5.) / (2. * PI);\n  vec3 h = normalize(-vd + ld);\n  return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 ACESFilm(vec3 x) {\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid camera(vec2 uv) {\n  const float pY = .5;\n  const float cL = 10.;\n  const vec3 forcus = vec3(0, .2, -.137);\n  const float fov = .015;\n  vec3 up = vec3(0, 1, 0);\n  vec3 pos = vec3(0, .8, 3) * 8.;\n  if(iMouse.z > .5) {\n    pos = vec3(sin(iMouse.x / iResolution.x * PI + PI * .5), sin(iMouse.y / iResolution.y * PI * 2.), cos(iMouse.x / iResolution.x * PI + PI * .5)) * cL;\n    R(pos.xz, PI);\n  }\n  vec3 dir = normalize(forcus - pos);\n  vec3 target = pos - dir;\n  vec3 cw = normalize(target - pos);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu, cw));\n  camup = cv;\n  mat3 camMat = mat3(cu, cv, cw);\n  rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n  ro = pos;\n}\n\n#ifdef AA\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#endif\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = (uv * 2. - 1.);\n  uv.x *= iResolution.x / iResolution.y;\n  camera(uv);\n  float hit = intersect();\n  vec3 p = ro + hit * rd;\n  vec3 n = normal(p);\n\n  // For example:\n  // 4 levels x 4 sampling = 16 sampling\n  // I think this is not so bad :)\n  float a = ao(p, n, .2);\n  a += ao(p, n, .5);\n  a += ao(p, n, .8);\n  a += ao(p, n, 1.2);\n  a /= 5.;  // a little bit darker.\n\n#ifdef LIGHTING\n  vec3 ldir = normalize(vec3(0, 1.5, 1.75));\n  R(ldir.xz, sin(iTime * .25) * .75);\n  float diff = max(0., dot(n, ldir)) * (1. / PI);\n  float indr = (dot(n, -ldir) * .5 + .5) * (1. / PI);\n  float spec = normalizedBlinnPhong(1. / .0005, n, rd, ldir);\n  const float albd = .45;\n  float st = 0.;\n  float sdw = 1.;\n  p += n * .01;\n  for(int i = 0; i < 80; i++) {\n    float d = sdScene(p + ldir * st);\n    d += length(hash21(fragCoord.x * fragCoord.y + iTime + float(i))) * .0005;\n    if(d < MIN_DIST * 20.) {\n      sdw = 0.;\n      break;\n    }\n    if(st > MAX_DIST * .8) { break; }\n    st += d;\n  }\n  a = albd * diff * 4. * sdw + .25 * a + indr * a * .8 + spec * 10. * sdw;\n  a += length(hash21(fragCoord.x * fragCoord.y + iTime)) * (1. - pow(a, .75)) * .025;  // add a little dithering\n\n  a = ACESFilm(vec3(a)).r;\n  a = smoothstep(.0, 1., pow(a, 1.5));\n#endif\n\n  fragColor = vec4(vec3(pow(a, .4545)), 1);\n}\n\n#ifdef AA\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n  mainImage0(O, U);\n  if(fwidth(length(O)) > .01) {  // difference threshold between neighbor pixels\n    vec4 o;\n    for(int k = 0; k < 9; k += k == 3 ? 2 : 1) {\n      mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.);\n      O += o;\n    }\n    O /= 9.;\n    // O.r++;                        // uncomment to see where the oversampling occurs\n  }\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 500, 520, 520, 556], [558, 558, 593, 593, 674], [676, 676, 717, 717, 777], [779, 779, 827, 827, 1015], [1017, 1017, 1046, 1046, 1131], [1133, 1133, 1156, 1156, 1921], [1923, 1923, 1942, 1942, 2192], [2194, 2214, 2235, 2235, 2444], [2446, 2527, 2549, 2549, 2681], [2703, 2844, 2884, 2884, 3928], [3930, 4044, 4115, 4115, 4260], [4262, 4262, 4285, 4285, 4429], [4431, 4431, 4453, 4453, 5157]]}
{"id": "Ndjfzd", "name": "girando", "author": "jorge2017a2", "description": "girando", "tags": ["girando"], "likes": 3, "viewed": 195, "published": 3, "date": "1646883941", "time_retrieved": "2024-07-30T16:59:18.883837", "image_code": "//----------image\n//por jorge2017a2----09-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nvec3 poBjrot;\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 variasArboles(vec3 p, vec2 pdist)\n{   vec2 res=pdist;\n    float num=10.0;\n    float ang=360.0/num;\n    vec3 p0=p;    \n    for(float i=0.0;i<num;i++)\n    {\n    vec3  p3= rotate_x( p0-vec3(mod(i,4.0)*7.0,0.0,0.0), radians(ang*i));\n    p3.y-=15.0;\n    float d2a= sdCylinderXZ(p3-vec3(-5.0,10.0,0.0), vec2(1.0,6.0) );\n    float d2b= sdSphere( p3*vec3(0.6,1.0,1.0)-vec3(-3.0,18.0,0.0), 3.0 );\n    res =opU2(res, vec2(d2a,27.0));\n    res =opU2(res, vec2(d2b,28.0));\n    }\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tp.y=p.y-5.0;\n    p= rotate_x( p, radians(iTime*15.));\n    poBjrot=p;\n    float d1=sdCylinderYZ(p, vec2(20.0,25.0)  );\n    res =opU2(res, vec2(d1,100.0));\n    vec2 vA1= variasArboles(p,res);\n    res =opU2(res, vA1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = occlusion(hit, norm);\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ){ vec3 col=tex3D(iChannel0, p/32., nor); return col*1.5; }  }\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{   return lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist); }\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    //por ocb\n    col += smoothstep(.45,.9,texture(iChannel0,vec2(.1/rd.y-.01*iTime,.3*rd.z)).z) + sky - max(0.7 * rd.y, 0.0);\n\n\t//return sky;\n    return col*0.5;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n       if (id_color<50)\n\t\t{ return getColor(int( id_color)); } \n    if (id_color==100)\n   {vec3 pn=poBjrot;\n   return getColorTextura( pn, n,100)*vec3(0.25,1.2,0.20); }\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   light_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n   light_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,25.0,-35.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9),\nvec3(0.15, 0.5, 0.15) \n);\n\nvec3 getColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndjfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 527, 563, 563, 584], [585, 585, 624, 624, 719], [720, 720, 759, 759, 854], [855, 855, 894, 894, 989], [991, 1035, 1082, 1082, 1109], [1110, 1110, 1153, 1153, 1180], [1181, 1181, 1229, 1229, 1257], [1258, 1298, 1332, 1332, 1428], [1429, 1429, 1463, 1463, 1554], [1555, 1555, 1589, 1589, 1680], [1681, 1681, 1715, 1715, 1810], [1812, 1812, 1852, 1852, 2300], [2302, 2302, 2327, 2327, 2603], [2605, 2605, 2629, 2629, 2791], [2793, 2793, 2841, 2841, 3168], [3170, 3170, 3214, 3214, 3540], [3542, 3542, 3579, 3579, 3840], [3842, 3842, 3927, 3927, 4867], [4869, 4869, 4918, 4918, 4992], [4994, 4994, 5087, 5087, 5154], [5156, 5156, 5188, 5188, 5535], [5537, 5537, 5605, 5605, 5792], [5795, 5795, 5822, 5822, 5911], [5913, 5913, 5971, 5971, 6019], [6022, 6022, 6045, 6045, 6163], [6165, 6165, 6196, 6196, 6817], [6819, 6819, 6876, 6876, 7226]]}
{"id": "7sGSWw", "name": "[CrzClm] Leg", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["maptoy", "crazyclimbers"], "likes": 7, "viewed": 266, "published": 3, "date": "1646883335", "time_retrieved": "2024-07-30T16:59:20.155437", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 1\n#define TURN_TABLE_SPEED .5\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = fOpUnionSmooth( res, d, s );\n    }\n    return res;\n}\n\nvec3 bokoboko = vec3(0); \nvec3 paripari = vec3(0);\n\nfloat getTriDisp(vec3 v3, vec3 n) {\n    const float k = 3.;\n    n = normalize(n);\n    vec3 w = pow( abs(n), vec3(k) );\n    return (v3.x*w.x + v3.y*w.y + v3.z*w.z) / (w.x + w.y + w.z);\n}\n\nvec3 getTriTrans(vec3 v3, vec3 n) {\n    const float k = 3.;\n    n = normalize(n);\n    vec3 w = pow( abs(n), vec3(k) );\n    w /= w.x + w.y + w.z;\n    return v3*sign(n) * w;\n}\n\nfloat map(vec3 p){\n    \n    const float sclpari = 6.;\n    const float smoothness = .2;\n    paripari.x = voronoiSmooth(p.yz*sclpari, smoothness);\n    paripari.y = voronoiSmooth(p.xz*sclpari, smoothness);\n    paripari.z = voronoiSmooth(p.xy*sclpari, smoothness);\n    paripari=pow(paripari, vec3(2));\n    paripari = smoothstep(.01, 1., paripari);\n    const float sclboko = 10.;\n    bokoboko.x = gfbm(p.yz*sclboko, 1, .5);\n    bokoboko.y = gfbm(p.xz*sclboko, 1, .5);\n    bokoboko.z = gfbm(p.xy*sclboko, 1, .5);\n    bokoboko = smoothstep(.01, 1., bokoboko);\n    \n    p.y-=.315*1.5;\n    R(p.yz, -saturate(cos(iTime*.85)));\n    \n    // Overall wrinkles\n    p-=getTriTrans(bokoboko, (p+vec3(0,.5,0))*vec3(1,.3,1))*.02;\n    p-=getTriTrans(paripari, (p+vec3(0,.5,0))*vec3(1,.3,1))*.01;\n    \n    vec3 cp0 = p;\n    {\n        vec3 q = cp0;\n        vec3 b = q;\n        b.y+=.315*2.;\n        float bend = ((cos(iTime*2.)-1.)*PI*.3);\n        float bendf = abs(bend)/((cos(PI*.5)-1.)*PI*.3)*-1.*.5;\n        R(b.yz, bend);\n        \n        const float SCL_WRK_BEND = 120.;\n        const float SCL_WRK = 60.;\n        \n        vec3 qq = q;\n        R(qq.yz, -PI*.25 - PI*.15*(1.-smoothstep(-.9, -.4, q.y)));\n        float wrk0 = sin(qq.y*SCL_WRK_BEND-PI*.5)*.02*bendf;\n        float msk0 = smoothstep(-.6, .2, qq.z);\n        float msk1 = smoothstep(-.1, -.5, qq.y);\n        float msk2 = smoothstep(-.7, -.4, qq.y);\n        float msk3 = smoothstep(-.45, -.3, qq.y);\n        \n        vec3 qqq = q;\n        R(qqq.yz, -PI*.25);\n        float wrk1 = sin(qqq.y*SCL_WRK)*.01*getTriDisp(bokoboko, qqq);\n        float msk4 = smoothstep(-.6, -.5, q.y);\n        \n        \n        float bendWrinkle = wrk0 * msk0 * msk1 * msk2 * msk3 + wrk1 * msk4;\n        \n        float wrk2 = sin(qq.y*60.+getTriDisp(bokoboko, qq)*8.+cos(qq.x*3.)*10.) * .05 * (1.-bendf);\n        float msk5 = smoothstep(-.1, .2, b.y);\n        float msk6 = smoothstep(.3, -.1, b.y);\n        float msk7 = smoothstep(.05, -.05, b.z);\n        float kneeWrinkle = wrk2*msk5*msk6*msk7*getTriDisp(bokoboko, q);\n        \n        cp0 = q+vec3(bendWrinkle, .315, kneeWrinkle);        \n    }\n    float root = sdEllipsoid(p, vec3(0.337084)*.65);\n    float d1 = sdEllipsoid(cp0, vec3(0.347419, 0.634445, 0.347419)*.5);\n    d1 = fOpUnionSmooth(d1, root, .3);\n    \n    vec3 cp1 = cp0;\n    vec3 cp2 = cp0;\n    {\n        vec3 b = cp1;\n        b.y+=.315;\n        float bend = ((cos(iTime*2.)-1.)*PI*.3);\n        float bendf = abs(bend)/((cos(PI*.5)-1.)*PI*.3)*-1.*.5;\n        R(b.yz, bend);\n        vec3 bb = b;\n        R(bb.yz, -PI*.25);\n        cp2 = b;\n        const float SCL_WRK = 50.;\n        float wrk0 = sin(bb.y*SCL_WRK)*.02;\n        float msk0 = smoothstep(0., -.2, b.y);\n        \n        cp1 = b+vec3(wrk0*msk0*getTriDisp(bokoboko, b), .28, 0);\n    }\n    float d2 = sdEllipsoid(cp1, vec3(0.293975, 0.58795, 0.293975)*.5);\n    d2 = fOpSubstractionSmooth(cp2.y+.45, d2, .015);\n    \n    float mix0 = 0.;\n    {\n        vec3 b = p;\n        b.y+=.315*2.;\n        float bend = ((cos(iTime*2.)-1.)*PI*.3);\n        float bendf = abs(bend)/((cos(PI*.5)-1.)*PI*.3)*-1.*.5;\n        R(b.yz, bend);\n        R(b.yz, bend*-.5);\n        mix0 = (1.-smoothstep(-.1, .2+.1*(1.-bendf), b.z))*.4+.0001;\n    }\n    float d = fOpUnionSmooth(d1, d2, mix0);\n    \n    return d;\n}\n\nrender();", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 274, 274, 566], [620, 620, 655, 655, 805], [807, 807, 842, 842, 980], [982, 982, 1000, 1000, 4263]]}
{"id": "fs2fzt", "name": "Ellipse Cloud", "author": "SnoopethDuckDuck", "description": "lots of unused code, spent a lot of time trying to make something else then it became whatever this is", "tags": ["e"], "likes": 16, "viewed": 448, "published": 3, "date": "1646872160", "time_retrieved": "2024-07-30T16:59:21.065005", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat invs(float y) {\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat isBetween(float a, float b, float c) {\n    //float k = 3. / iResolution.y;\n    return smoothstep(-0.5, 0., -mod(c-a, 2. * pi) + mod(b-a - 0.1 * pi, 2. * pi));\n   //return exp( -1. * (abs(-mod(c-a, 2. * pi) + mod(b-a, 2. * pi))) );\n}\n\nfloat ellipse(vec2 uv, vec2 p, vec2 q, float i) {\n    float quadTest = 0.5 * (sign(q.x - p.x) * sign(q.y - p.y) + 1.);\n    i = 1.-quadTest;\n\n    // center point\n    vec2 c = (i == 1.) ? vec2(p.x, q.y)\n                       : vec2(q.x, p.y);\n\n    // axis distances between points\n    float x = abs(q.x - p.x), y = abs(q.y - p.y);\n\n    // ellipses (asymptotes when x==0 or y==0, annoying)\n    //float d = (i == 1.) ? length((uv - c) * vec2(y/x,1)) - y\n    //                    : length((uv - c) * vec2(1,x/y)) - x;\n\n    float d = sdEllipse(uv - c, vec2(x, y));\n\n    // (make this smoothstep or exp)\n    // float s = smoothstep(-0.02, 0.02, -abs(d) + 0.01);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -abs(d) + 0.006);\n    s = exp(-100. * abs(d));\n    // a, b angles from center to points\n    // c angle from center to uv\n    float a1 = atan(p.x-c.x, p.y-c.y);\n    float a2 = atan(q.x-c.x, q.y-c.y); // move b from a-> b to \"draw\" thing\n    float b = atan(uv.x-c.x, uv.y-c.y);\n    \n    // flip clockwise <-> anticlockwise across diagonal quads\n    // float quadTest = 0.5 * (sign(q.x - p.x) * sign(q.y - p.y) + 1.);\n    \n    // cut out a1,a2 segment of ellipse\n    float as = isBetween(a1, a2, b);\n    return s;// * mix(as, 1. - as, quadTest);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 1.1 + 0.15 * cos(uv.y - 0.6 * iTime);\n    uv.y += 0.02 * cos(iTime);\n    \n    // points\n    vec2 p = 0.1 * vec2(cos(0.913 * iTime), sin(iTime));\n    vec2 q = 0.2 * vec2(cos(0.81 * iTime), sin(0.73 * iTime));\n\n    // should look bad if time gets too high\n    float t = 10. * iTime + 8. * h21(uv) + 15. *exp(-0.01 * length(uv)) * (650. + iTime);\n    int f = int(floor(t)); \n    \n    float d = 10.;\n    float s = 0.;\n    vec2 pp = vec2(0.);\n    \n    vec3 e = vec3(1);\n    vec3 col = vec3(0);\n    \n    float n = 20.;\n    for (float i = 0.; i <= n; i++) {\n        float f2 = 0.0001 * float(f);\n        float f3 = 0.0001 * float(f + 1);\n\n        vec2 qp = pp;\n             \n        pp = vec2( h21(vec2(f2)), h21(vec2(0.01 + f2)) );\n        pp = pow(4. * pp * (1.-pp), vec2(4));\n\n        vec2 pp2 = vec2( h21(vec2(f3)), h21(vec2(0.01 + f3)) );\n        float fr = fract(t);\n        fr = smoothstep(0., 1., fr); //idk if this changes anything\n        pp = mix(pp, pp2, fr); // looks cool if you remove this too\n        pp = 0.3 * (pp - 0.5);\n        f++;\n        //if(i>0.) d = length(uv-pp);sdSegment(uv, pp, qp);\n        //s += exp(-40. * d);\n        float s2;\n        if (i > 0.) s2 = ellipse(uv, pp, qp, 0.);//mod(i, 2.));\n        s = clamp(s + s2, 0., 1.);\n        vec3 col2 = pal(i/n, e, e, e, (i/n) * vec3(0,1,2)/3.);\n        col = mix(col, col2, s2);\n    }\n    \n    col += 0.03;\n    col += 0.35 * exp(-3. *length(uv));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2fzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [173, 173, 215, 215, 1237], [1239, 1239, 1260, 1260, 1305], [1307, 1307, 1351, 1387, 1545], [1547, 1547, 1596, 1596, 2814], [2816, 2816, 2873, 2873, 4405]]}
{"id": "fdjfRt", "name": "simple time warp without discard", "author": "teadrinker", "description": "time warp single pass:\nhttps://www.shadertoy.com/view/NtlXWn\n", "tags": ["timewarp"], "likes": 7, "viewed": 518, "published": 3, "date": "1646861167", "time_retrieved": "2024-07-30T16:59:21.847912", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float waitPixelRows = 200.;\n    int speed = 1; // higher values will reduce quality\n    int width = 3; \n    vec4 scanColor = vec4(0.4, 1., 0.85,1.);\n    \n    int scanPos = int(mod(float(iFrame * speed), iResolution.y + waitPixelRows));\n    if(int(fragCoord.y) > int(iResolution.y) - scanPos)\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    else if(abs(int(fragCoord.y) + speed*width - (int(iResolution.y) - scanPos)) < width)\n        fragColor = scanColor;\n    else\n        fragColor = texture(iChannel1, vec2(iResolution.x - fragCoord.x, fragCoord.y) / iResolution.xy);\n}\n\n\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 58, 58, 124]]}
{"id": "sdBfRd", "name": "Another Weird wave", "author": "cooldude999", "description": "more testing", "tags": ["wobble", "warp", "trippy", "weird", "sinwave", "insanity"], "likes": 2, "viewed": 226, "published": 3, "date": "1646851604", "time_retrieved": "2024-07-30T16:59:22.665725", "image_code": "vec3 hueshift(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5700,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    float timeMulti = 30.09;\n    float timeDiv = 6.3;\n\t// Get the UV Coordinate of your texture or Screen Texture, yo!\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Flip that shit..? \n\tuv.x + 2.0 * iTime;\n    uv.y * 2.0 * iTime / uv.y;\n\t\n\t// the funny doings!\n    \n    //some weird spinny wobble thing !! :]? ??\n\tuv.x += sin(uv.x*1.0*iTime / 9.0)/20.0;  //some weird ripple effect\n    uv.y += sin(uv.y*0.8/iTime + timeDiv)/1.0; //intro stretch\n\n\tuv.xy += sin(uv.x-10.0+iTime)*0.29; //wave one\n\n    uv.yx += sin(uv.y+10.0+iTime)/10.0; //wave two\n\n    uv.y += sin(uv.x * 10.0+iTime + 0.03)*0.08;\n\n\n \n\t\n\t\n\t\n\t\n\t\n    \n    \n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;\n    \n    \n    \n    \n    \n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 123], [125, 125, 182, 182, 908]]}
{"id": "7sSBzt", "name": "Insanity Shader [Sin/Wobble]", "author": "cooldude999", "description": "Original from: https://www.shadertoy.com/view/MsX3DN\n\nmodified for testing and fun, fucking around with this is interesting\n\n\n\nfort nite", "tags": ["wobble", "warp", "trippy", "weird", "sinwave", "insanity"], "likes": 0, "viewed": 239, "published": 3, "date": "1646841508", "time_retrieved": "2024-07-30T16:59:23.402755", "image_code": "vec3 hueshift(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5700,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    bool DoColor = false;//fun\n    \n    float timeMulti = 30.09;\n    float timeDiv = 6.3;\n\t// Get the UV Coordinate of your texture or Screen Texture, yo!\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Flip that shit, cause shadertool be all \"yolo opengl\"\n\tuv.x + 0.09 / iTime;\n    uv.y * 2.0 * iTime / uv.y;\n\t\n\t// the funny doings!\n    \n    //some weird spinny wobble thing !! :]? ??\n\tuv.x += sin(uv.y*0.5*iTime * 0.005)/20.0;\n    uv.y += sin(uv.x*0.8/iTime + timeDiv)/00.3;\n\tuv.xy += sin(uv.x-10.0+iTime)*0.29;\n    uv.xy += sin(uv.y+10.0+iTime)/10.0;\n    uv.y += sin(uv.x * 10.0+iTime + 0.03)*0.08;\n    uv.x += sin(uv.y * 20.0+iTime * 0.5)*0.005;\n    uv.x * 0.09 * iTime;\n \n\t\n\t\n\t\n\t\n\t\n    \n    \n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;\n    \n    //COLOR STUFF!!!!!! use the BOOL to enable a silly little rainbow :3\n    if (DoColor)\n    {\n        vec3 hue = hueshift(vec3(0.3, 0., 0.), -uv.x * 6.283);    \n        \n        vec3 col = texture(iChannel0, uv).rgb;\n        \n        fragColor = vec4(hueshift(col, iTime / 1.3), 1.);\n    \n    }\n    \n    \n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 123], [125, 125, 182, 182, 1267]]}
{"id": "7djfz3", "name": "Fractal Fire Stars", "author": "jarble", "description": "A fractal with flame-like patterns.", "tags": ["fractal", "fire", "star"], "likes": 11, "viewed": 270, "published": 3, "date": "1646809507", "time_retrieved": "2024-07-30T16:59:24.257470", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8./2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);   \n    for(int k = 0; k < 9; k++){\n        uv -= (t2.yx)*scale;\n        vec2 t4 = vec2(0.);\n        t3 = triangle_wave(-uv,scale)-t4;\n        vec2 temp = t2;\n        t2 = triangle_wave(-uv.yx-.5,scale)-t4;\n        uv.yx = (t3-t2);\n        t2 /= (temp-.75);\n        //t2 /= abs(t2 - 2.5);\n        col.x = 1.-abs(uv.x+uv.y+col.x);\n        col = col.yzx;\n        uv /= scale;\n    }\n    fragColor = vec4(1.-col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 120, 232], [234, 234, 291, 291, 962]]}
{"id": "7s2BR3", "name": "spqr: Paris 3040 AD 4", "author": "spqr", "description": "more domain gating and IFS\n\nHD video available here :\n\n https://youtu.be/CT19xGgonyQ", "tags": ["a"], "likes": 3, "viewed": 365, "published": 3, "date": "1646809011", "time_retrieved": "2024-07-30T16:59:25.352542", "image_code": "\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*33.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\n\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n/*\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n*/\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<8;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\n\n\n\n\nint matter = 0;\n\nfloat artifact(vec3 p, float width) {\n  vec3 pt=p;\n  \n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n  dist=box(pt,vec3(.131));\n  \n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gatedcyl(vec3 p, vec2 dim, float domain, float prob) {\n\n     prob = prob/=2.;\n     prob = 1.-prob;\n     \n \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = cylcap(p,dim.x,dim.y);\n        return u;\n        \n    } else {\n        float u = cylcap(p,dim.x,dim.y);\n       \n        return u;\n    }\n \n}\n\n\nfloat gatedbox(vec3 p, vec3 dim, float domain, float prob) {\n\n     prob = prob/=2.;\n     prob = 1.-prob;\n     \n \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nfloat box(vec3 p, float w, float h) {\n\n  vec3 b = vec3(w,w,h);\n  vec3 q = abs(p) - b;\n  return max(q.x,max(q.y,q.z)) ;\n\n}\n\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\n\n\nfloat hash21(vec2 p) {\n    float a = sin(p.x*1831.424)*9918.3232;\n    float b = sin(p.y*4254.001)*7742.4342;\n\n    float d = fract(a+b);\n    float e = sin(d * 4225.2421) * 9003.131;\n    return fract(e);\n\n}\n\nfloat poles(vec3 p, float widthlimit, float heightlimit) {\n\n   \n    p.yx *= .25;\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n   \n    vec2 dom = vec2(1.);\n     \n      \n    vec2 id = floor(p.yx/dom);\n    float f1 = hash21(id);\n    f1 = pow(f1,2.);\n \n   \n  \n    float me   = box(p - vec3(center, 0),    widthlimit, heightlimit * f1) ;\n    float next = box(p - vec3(neighbour, 0), widthlimit, heightlimit);\n    return min(me, next);\n}\n\n\nint material;\n\nfloat map(vec3 p) {\n\n\n    //geo\n  \n    vec3 q = p;\n  \n    float width = 4.;\n\n    float field = artifact(p, width);\n   \n    vec3 p1 = p.xzy;\n    vec3 p2 = p.xzy;\n      p2.xy *= rot(1.);\n    \n    \n    float type1 = poles(p1,                  .3, 17.);\n    float type2 = poles(p2 * vec3(.2,.2,1.), .3, 37.);\n    \n    vec3 impulse = vec3(0,0,1) * iTime *  44.;\n    float aircar = gatedbox(q + impulse,vec3(1.,7.,12.)*.2, 10., .07);\n    aircar = max(aircar, -(p.y + 60.));\n  \n    aircar = max(field,aircar);\n    \n     //return min(type1,type2);\n    \n    type1 = max(field, type1);\n    type2 = max(field, type2);\n   \n    float type = min(type1,type2);\n    float ground = -p.y;\n    \n    ground = smin(ground,cylcap(p - vec3(200.,0.,7800.), 140.,4480.),580.);\n    \n    \n    \n  \n  \n    \n  \n    float final =  min(ground,(min(type,aircar)));\n    \n \n    \n    if ( final == ground) {\n        material = 0;\n    }\n    if ( final == type) {\n        material = 1;\n    }\n   if ( final == aircar) {\n        material = 2;\n    }\n  \n    return final;\n  \n    \n\n    \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  // nav \n vec3 s,t;\n\n // switch\n                        // bobbing\n float tt = iTime * .03;\nif (false) {//mod(floor(iTime),14.) < 7.){\n\n  tt *= 4.;\n\n\n  \n  s = lattice(tt)*15.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  t = lattice(tt + 53.)*15.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 3. * arm;\n  t += tock(tt * 3.) * 3. * arm;\n  \n  s.y -=10.;\n  t.y -=10.;\n  \n  s.y = clamp(-10.,-50.,s.y);\n t.y = clamp(-10.,-40.,t.y);\n  \n  \n}\n\n                // hurtling forward\nelse {\n\n\n \n  \n  tt *= 2.;\n  s = vec3(0,0,-40);\n  t = vec3(0);\n  s.y -= 40.;\n  t.y -= 10.;\n  \n  s += flitfbm(tt*20.) * 1.5;\n  t += flitfbm(tt*70. + 8.) * .5;\n  \n  s.y += sin(iTime*1.)*18.;\n  t.y += sin(iTime*1.)*3.;\n  \n  \n  vec3 hurt = vec3(0,0,1);\n  //hurt.yz *= rot(iTime*.02);\n\n  \n  vec3 adv = hurt * 779.1 * tt;\n  s+= adv;\n  t+= adv;\n  \n  vec3 yank = lattice(tick(iTime*7.1)) * 7.1;\n  yank.x = 0.;\n  yank.z = 0.;\n \n  s += yank;\n  t += yank;\n  \n  vec3 arm = t-s;\n  arm.xy *= rot(sin(tt)*1.2);\n  t = s +arm;\n\n\n\n\n}\n\n   \n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  cx.xy *= rot(sin(iTime*.57)/9.);\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz += dot(uv,uv)/10.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * .8);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<2000.;z++){ \n  \n    i = z;\n    d = map(p);\n    d = abs(d) * .8;\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 2000.) {\n        break;\n    }\n    \n    dd += d;\n    p += r * d;\n\n  }\n \n  \n  \n  // hue\n  vec3 col;\n  vec3 z = vec3(.8,.5,.4);\n  \n  if ( material == 0) {\n    col = z*z;\n  } \n  if ( material == 1) {\n    col =z;\n   // col = mix(vec3(0),z, 1.-dd/600.);\n   \n   \n  }\n  if ( material == 2) {\n    col = vec3(0);\n    \n  }\n  \n  vec3 n = norm(p);\n  \n  float aodist=.1;\n  vec3 light = normalize(vec3(10,-20,30));\n  light.xz *= rot(iTime * 1.71);\n\n  float ao = getao(p,n,aodist*.2);// * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,.2));//+getsss(p,r,0.5)*0.5)*0.9;\n  float diff = max(0., dot(n,light)*.3 +.7);\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),2.) * 1.;\n  float iff = pow(1. - i/3000.,6.);\n  \n  //col *= iff;\n  col *= diff ;\n  col *= ao ;\n  col += sss  * 1.;\n  col += spec * .2;\n  \n \n  //col = pow(col,vec3(.7));\n // vec3 fog = mix(vec3(0.1,0.2,0.7), vec3(0.6,0.6,0.6), pow(max(0.0,dot(r,light)),5.0));\n//  col = mix(fog,col,exp(-.00000003 * dd * dd * dd));\n\n// col = mix(col,vec3(1), pow(clamp(0.,1.,1.-(p.y/-10.)),6.));\n \n\n \n\n  col *= 1.3  ;\n  \n\n  if ( material == 2) {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 2.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col += edge * 10.;\n  } else {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 5.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col -= edge* 10.;\n  }\n\n  \n\n  \n  if (! hit){\n\n      col = mix(vec3(.6),vec3(0),pow(r.y,.6));\n  }\n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n/*\n//  n2 = norm(p, vec2(0.0, 1E-2+3E-2*.01) );\n//  n1 = norm(p, vec2(0.0, 2E-2) );\n\n*/\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2BR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 206, 206, 309], [312, 312, 366, 421, 645], [648, 648, 677, 677, 742], [743, 743, 785, 785, 892], [894, 894, 917, 917, 1025], [1027, 1027, 1051, 1051, 1598], [1600, 1600, 1622, 1622, 1830], [1832, 1832, 1857, 1857, 1890], [1892, 1892, 1914, 1914, 2032], [2036, 2036, 2057, 2057, 2106], [2107, 2107, 2127, 2127, 2176], [2178, 2178, 2199, 2199, 2246], [2247, 2247, 2266, 2266, 2335], [2336, 2336, 2356, 2356, 2735], [2736, 2736, 2761, 2761, 3230], [3232, 3232, 3255, 3255, 3333], [3334, 3334, 3354, 3354, 3538], [3540, 3540, 3563, 3563, 3765], [3768, 3768, 3791, 3791, 3917], [3920, 3920, 3949, 3949, 3978], [3982, 3982, 4007, 4007, 4047], [4052, 4052, 4066, 4066, 4106], [4109, 4109, 4145, 4145, 4198], [4222, 4222, 4246, 4246, 4301], [4304, 4304, 4328, 4328, 4414], [4423, 4423, 4443, 4443, 4657], [4659, 4659, 4685, 4685, 4734], [4869, 4869, 4908, 4908, 4985], [4988, 4988, 5018, 5018, 5044], [5047, 5047, 5085, 5085, 5373], [5377, 5377, 5400, 5400, 5513], [5514, 5514, 5535, 5535, 5934], [5936, 5936, 5958, 5958, 6163], [6165, 6165, 6192, 6192, 6218], [6220, 6220, 6248, 6248, 6279], [6280, 6280, 6304, 6304, 6495], [6502, 6502, 6571, 6571, 6877], [6899, 6899, 6936, 6936, 7488], [7490, 7490, 7512, 7512, 7720], [7760, 7760, 7783, 7783, 7898], [7900, 7900, 7960, 7960, 8445], [8448, 8448, 8508, 8508, 8971], [8973, 8973, 9010, 9010, 9094], [9097, 9097, 9116, 9116, 9262], [9266, 9266, 9288, 9288, 9470], [9472, 9472, 9530, 9530, 9945], [9963, 9963, 9982, 9994, 11008], [11011, 11011, 11037, 11037, 11162], [11165, 11165, 11185, 11185, 11304], [11310, 11310, 11331, 11331, 11354], [11356, 11356, 11375, 11375, 11484], [11486, 11486, 11527, 11527, 11573], [11574, 11574, 11616, 11616, 11661], [11663, 11663, 11720, 11720, 15133]]}
{"id": "ss2fR3", "name": "hypnosis2", "author": "ufffd", "description": "#2 for hypnosis set", "tags": ["hypnosis"], "likes": 2, "viewed": 144, "published": 3, "date": "1646805759", "time_retrieved": "2024-07-30T16:59:26.202270", "image_code": "float smoothedge(in float val, in float edge) {\n    float pxl = 1./iResolution.y;\n    return smoothstep(edge-pxl*1.,edge,val);\n}\n\nfloat nsin(in float val) {\n    return sin(val)*0.5+0.5;\n}\n\nfloat drawline(in float val, in float edge, in float width) {\n    return smoothedge(val,edge+width) - smoothedge(val,edge-width);\n}\n\nfloat bluredge(in float val, in float edge, in float blur) {\n    float pxl = 1./iResolution.y;\n    return smoothstep(edge-pxl*blur,edge,val);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = vec2(iResolution.x/iResolution.y * (uv.x - 0.5) + 0.5,uv.y);\n    \n    vec2 warp = uvc;\n    \n    float mono = 1.;\n    \n    float flower = 0.;\n    \n    for (int i=0;i<58;i++){\n    for (int j=0;j<14;j++) {\n        // hex grid\n        float fi = float(i);\n        float row = floor(fi/6.);\n        vec2 cp = vec2(\n            0.5 * (mod(fi,6.) + mod(row,2.) / 2.),\n            row / 12. * sqrt(3.)\n        );\n        // magic numbers\n        cp.y += 0.2225;\n        cp.x -= 0.2;\n        float cs = float(j) / 22.5;\n        cs /= 4.; // toggle\n        cs = 1./6. - cs;\n        // draw circle\n        float circle = distance(uvc+cp-0.8, vec2(0.5));\n        // mono += circle * noise(cp * 200. + iTime * .01);\n        // mono += noise(cp * 200. + iTime * .001);\n        mono += bluredge(circle,cs,iResolution.y * .1 * sin(\n            distance(uvc,vec2(0.5)) + iTime * 0.5\n        ));\n        if (j==0)\n            flower += drawline(circle,cs,0.001);\n    }\n    }\n    \n    \n    flower = mod(flower,3.0) * nsin(3.14 + iTime*0.5);\n    \n    mono += flower * .1;\n    \n    mono = mod(mono,2.);\n    \n    float bw = smoothedge(mono,0.5);\n    \n    // bw = noise(uvc * 20. + iTime * .01);\n    // bw = flower;\n    \n    vec3 col = vec3(bw);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2fR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 128], [130, 130, 156, 156, 187], [189, 189, 250, 250, 320], [322, 322, 382, 382, 465], [467, 467, 497, 497, 581], [583, 583, 603, 603, 670], [672, 672, 692, 692, 901], [903, 903, 960, 1010, 2321]]}
{"id": "ssjfR3", "name": "Fractal knots 7", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot", "lace"], "likes": 4, "viewed": 246, "published": 3, "date": "1646804723", "time_retrieved": "2024-07-30T16:59:26.992158", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a = -a;\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 36.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<15;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        //float scale = scale+col.x/16.;\n        for(int k = 0; k < 3; k++){\n            \n            //uv /= -scale-col.x;\n            uv += t2.yx;\n            uv /= -scale;\n            //uv -= t2.yx/scale;\n            //if(i>12) uv += (iTime)/10.;\n            //uv -= offset + (t2.yx)/(scale+length(col));\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            vec2 temp = t2;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2 = triangle_wave(uv.yx-.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale);\n            //t2 -= abs(t2-.5)/8.;\n            //t3 -= abs(t3-.5)/8.;\n            \n            uv.yx = (t2+t3)/scale;\n            //t2 *= (1.+temp.x-temp.y);\n            t2 /= (1.5+temp.yx);\n            //t2 /= abs(uv/scale-1.5);\n\n            //offset -= col.x/16.;\n            //offset += offset1;\n        }\n        //offset += .5/scale;\n        col.x = abs(uv.y-uv.x+col.x);\n        col = col.yzx;\n        //scale *= 1.0+col.x/16.;\n    }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 120, 134, 246], [248, 248, 305, 305, 1678]]}
{"id": "sdBfDh", "name": "Golf Phase Space", "author": "Flyguy", "description": "Simulates a putt shot at various ball speeds & angles.\nSee code comments for details.\nBased on this video by AlphaPhoenix: https://youtu.be/b-pLRX3L-fg\n", "tags": ["simulation", "physics", "golf", "phasespace"], "likes": 8, "viewed": 302, "published": 3, "date": "1646792588", "time_retrieved": "2024-07-30T16:59:27.997470", "image_code": "/*\nGolf putt shot phase space visualization\nBased on this video by AlphaPhoenix: https://youtu.be/b-pLRX3L-fg\n\nControls:\nClick -------> Location in phase space to visualize\nUp arrow ----> Show/hide phase space\nDown arrow --> Reset simulation\n\nPhase space details:\nX-axis = initial angle (ball_angle in center +/- ball_angle_range)\nY-axis = initial speed (bottom = 0, top = ball_max_speed)\nRed   = ball far from hole\nBlue  = ball close to hole\nWhite = ball in hole\n*/\n\nvec3 HeatmapGrad(float x)\n{\n    x = clamp(x,0.0,1.0);\n    return clamp(1.5-abs((x-vec3(0.75,0.50,0.25))*4.0),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.y;\n    \n    //Initial mouse position\n    if(m == vec2(0))\n    {\n        m = vec2(0.551,0.582);\n    }\n    \n    //Map coloring\n    vec4 map = texture(iChannel0,uv/res,0.);\n    map.a = (map.a-map_flat_height)/(1.0-map_flat_height);\n    fragColor = vec4(mix(vec3(0.1,0.5,0.1),vec3(0.8,1.0,0.8), floor(map.a*15.)/15.), 0);\n    \n    float dist_hole = distance(texelFetch(iChannel1,ivec2(fragCoord),0).xy,hole_pos);\n    vec2 ball_pos = texelFetch(iChannel1,ivec2(m*iResolution.y),0).xy;\n    \n    //Ball/Hole/Start position drawing\n    StartCanvas(uv, 1.0/iResolution.y, fragColor);\n    {\n        //Hole\n        Color(vec3(0));\n        Circle(hole_pos, hole_size);\n        Color(vec3(0.3));\n        Ring(hole_pos, hole_size,ps*4.);\n        \n        //Ball at cursor pos in phase space\n        Color(vec3(1));\n        Circle(ball_pos, hole_size*0.5);\n        Color(vec3(0));\n        Ring(ball_pos, hole_size*0.5,ps);\n        \n        //Balls around the cursor in phase space\n        for(int i=-num_samples;i<=num_samples;i++)\n        {\n            for(int j=-num_samples;j<=num_samples;j++)\n            {\n                    vec2 offs = sample_range * vec2(i,j)/float(num_samples);\n                    ball_pos = texelFetch(iChannel1,ivec2(m*iResolution.y + offs), 0).xy;\n\n                    Color(vec3(1));\n                    Circle(ball_pos, hole_size*0.5);\n                    Color(vec3(0));\n                    Ring(ball_pos, hole_size*0.5,ps);\n            }\n        }\n        \n\n        //Initial angle range\n        Color(vec3(0)); \n        Ring(ball_start, hole_size*0.5,ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle))*0.1),ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle+ball_angle_range))*0.1),ps);\n        Line(ball_start,(ball_start+cossin(radians(ball_angle-ball_angle_range))*0.1),ps);\n        \n        //Ball start position\n        Color(vec3(1,0,0));\n        Circle(ball_start, hole_size*0.5);\n        Color(vec3(0));\n        Ring(ball_start, hole_size*0.5,ps);\n    }\n    EndCanvas(fragColor);\n    \n    if(checkKey(iChannel2, 38).z) //Up arrow to show/hide phase space\n    {\n        float csize = 0.03;\n        fragColor = vec4(HeatmapGrad(dist_hole),0);\n        fragColor += step(-hole_size,-dist_hole); //White = in hole\n        \n        //Cursor\n        StartCanvas(uv, 1.0/iResolution.y, fragColor);\n        {        \n            Color(vec3(0.5-c.rgb)*2.);//Invert colors under cursor\n            Line(m+vec2(0,csize*0.5), m+vec2(0,csize), ps);\n            Line(m+vec2(0,-csize*0.5), m+vec2(0,-csize), ps);\n            Line(m+vec2( csize*0.5,0), m+vec2( csize,0), ps);\n            Line(m+vec2(-csize*0.5,0), m+vec2(-csize,0), ps);\n            Circle(m, 1.*ps);\n        }\n        \n        EndCanvas(fragColor);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Height map and normal map\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec4 noise2D(vec2 uv)\n{\n    ivec2 tres = textureSize(iChannel0,0);\n    uv = fract(uv);\n    uv *= vec2(tres);\n    vec4 s0 = texelFetch(iChannel0, ivec2(uv.x+0.,uv.y+0.)%tres,0);\n    vec4 s1 = texelFetch(iChannel0, ivec2(uv.x+1.,uv.y+0.)%tres,0);\n    vec4 s2 = texelFetch(iChannel0, ivec2(uv.x+0.,uv.y+1.)%tres,0);\n    vec4 s3 = texelFetch(iChannel0, ivec2(uv.x+1.,uv.y+1.)%tres,0);\n    \n    uv -= floor(uv);\n    vec4 nh0 = mix(s0,s1,-0.5*cos(uv.x*3.14159)+0.5);\n    vec4 nh1 = mix(s2,s3,-0.5*cos(uv.x*3.14159)+0.5);\n    return   mix(nh0,nh1,-0.5*cos(uv.y*3.14159)+0.5);\n}\n\nfloat heightmap(vec2 uv)\n{   \n    float h = noise2D(uv*map_scale-map_offs).x;\n    h = -smin(-h,-map_flat_height,11.);\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Initialize heightmap & normal map on frame 0/down arrow pressed\n    if(iFrame == 0 || checkKey(iChannel2, 40).x) \n    {\n        vec2 ps = 1.0 / iResolution.xy;\n        vec2 uv = fragCoord / iResolution.xy;\n\n        float h = heightmap(uv);\n\n        float u = heightmap(uv + ps.xy*vec2( 0, 1));\n        float d = heightmap(uv + ps.xy*vec2( 0,-1));\n        float l = heightmap(uv + ps.xy*vec2(-1, 0));\n        float r = heightmap(uv + ps.xy*vec2( 1, 0));\n\n        vec3 dx = vec3(ps.x*3., 0, r-l);\n        vec3 dy = vec3(0, ps.y*3., u-d);\n        vec3 n = normalize(cross(dx,dy));\n\n        fragColor = vec4(n,h);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float inf = 1e4;\nconst float tau = 6.283185307;\n\n//Display settings\nconst int num_samples = 0; // > 0 to show multiple balls at different locations in phase space around the cursor\nfloat sample_range = 25.0; // Range to sample around the cursor (pixels)\n\n//Physics Settings\nfloat dt = 0.002; //Time delta per frame\nfloat gravity = 9.0; //Gravitational acceleration.\n\n//Initial condition settings\nvec2  ball_start = vec2(0.05,0.65); //Ball starting position on screen\nfloat ball_angle = -10.0; //Ball starting angle\nfloat ball_angle_range = 60.0; //Starting angle range (ball_angle +/- ball_angle_range)\nfloat ball_max_speed = 7.; //Max inital speed\nfloat ball_min_vel = 0.1; //Minimum velocity to consider the ball stopped\nfloat ball_min_acc = 0.1; //Minimum acceleration to consider the ball stopped\nfloat ball_drag = 2.0; //Air drag coeffient\n\nvec2  hole_pos = vec2(1.3,0.6); //Hole position on screen\nfloat hole_size = 0.025; //Hole size\n\n//Map settings\nvec2  map_offs = vec2(0.124,0.330); //X,Y offset of map in the noise texture \nfloat map_scale = 0.020; //Scale of the noise texture\nfloat map_flat_height = 0.5; //Flat ground level blended with noise\n\n//Misc functions\nvec2 cossin(float x)\n{\n    return vec2(cos(x),sin(x));\n}\n\nbvec3 checkKey(sampler2D tex, int key)\n{\n    return bvec3(\n        texelFetch(tex,ivec2(key, 0), 0).x == 1.0,\n        texelFetch(tex,ivec2(key, 1), 0).x == 1.0,\n        texelFetch(tex,ivec2(key, 2), 0).x == 1.0\n    );\n}\n\n//Debug drawing canvas functions\nfloat dfCircle(float r, vec2 uv)\n{\n    return length(uv)-r;\n}\n\nfloat dfRing(float r, float w, vec2 uv)\n{\n    return abs(length(uv)-r)-w/2.0;\n}\n\nfloat dfLine(vec2 start, vec2 end, float w, vec2 uv)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv)-w/2.0;\n}\n\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\n#define StartCanvas(p, s, b) {vec2 uv=p; float ps=s; vec4 c=b; vec4 oc=vec4(0,0,0,1);\n#define Color(v) oc.rgb = vec3(v);\n#define Alpha(v) oc.a = float(v);\n#define Circle(p,d) c=mix(c,oc,smoothstep(ps,0.,dfCircle(d,uv-(p))));\n#define Ring(p,d,w) c=mix(c,oc,smoothstep(ps,0.,dfRing(d,w,uv-(p))));\n#define Line(a,b,w) c=mix(c,oc,smoothstep(ps,0.,dfLine(a,b,w,uv)));\n#define EndCanvas(o) o=mix(o,c,c.w);}", "buffer_b_code": "//Ball simulation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    ivec2 iuv = ivec2(fragCoord);\n    \n    vec4 state = texelFetch(iChannel1,iuv,0);\n    \n    vec2 cur_pos = state.xy;\n    vec2 pre_pos = state.zw;\n    \n    vec2 vel = (cur_pos - pre_pos)/dt;\n   \n    vec2 accel = gravity*texture(iChannel0,cur_pos/res,0.).xy;\n    accel += -ball_drag*vel;\n    \n    vec2 next_pos = (2.0*cur_pos - pre_pos) + accel*(dt*dt);\n\n    if(pre_pos != vec2(inf)) //pre_pos = vec2(-inf)\n    {\n        //Ball hit the border\n        if(any(lessThan(cur_pos,vec2(0))) || any(greaterThan(cur_pos,res)))\n        {\n            next_pos = cur_pos;\n            cur_pos = vec2(inf);\n        }\n        \n        //Ball is in the hole\n        if(distance(cur_pos,hole_pos) < hole_size)\n        {\n            next_pos = hole_pos;\n            cur_pos = vec2(inf);\n        }\n        \n        //Ball has stopped\n        if(length(vel) < ball_min_vel && length(accel) < ball_min_acc)\n        {\n            next_pos = cur_pos;\n            cur_pos = vec2(inf);\n        }\n    }\n    else\n    {\n        next_pos = cur_pos;\n        cur_pos = vec2(inf);\n    }\n    \n    //Initialize ball position & speed on frame 0/down arrow pressed\n    if(iFrame == 0 || checkKey(iChannel2, 40).x) \n    {\n        vec2 uv = fragCoord/iResolution.xy;\n\n        ball_angle = ball_angle + (2.*uv.x-1.)*ball_angle_range;\n        ball_max_speed = ball_max_speed * uv.y;\n        \n        next_pos = ball_start + ball_max_speed * cossin(radians(ball_angle)) * dt;\n        cur_pos = ball_start;\n    }\n    \n    fragColor = vec4(next_pos,cur_pos);;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 495, 495, 588], [590, 590, 647, 647, 3538]]}
{"id": "NlyGRz", "name": "hsv color picker", "author": "ArmandB", "description": "click and drag the slider to change hue\nclick and drag the picker to change value and saturation\nuncomment line 91 to view hsv colors\n", "tags": ["interactive", "color", "buffer", "input"], "likes": 14, "viewed": 650, "published": 3, "date": "1646783798", "time_retrieved": "2024-07-30T16:59:28.998794", "image_code": "//returns a rgb color given a hue, saturation, value color\n//https://en.wikipedia.org/wiki/HSL_and_HSV#/media/File:HSV-RGB-comparison.svg\nvec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\n//returns a hue, saturation, value color given a rgb color\n//https://www.rapidtables.com/convert/color/rgb-to-hsv.html\nvec3 rgbToHsv(vec3 rgb){\n    vec3 hsv = vec3(0);\n    float maxC = max(max(rgb.r,rgb.g),rgb.b);\n    float minC = min(min(rgb.r,rgb.g),rgb.b);\n    float delta = maxC - minC;\n    if (maxC == rgb.r) hsv.x = mod((rgb.g - rgb.b)/delta,6.0)/6.0;\n    if (maxC == rgb.g) hsv.x = (rgb.b - rgb.r)/(delta*6.0) + 1.0/3.0;\n    if (maxC == rgb.b) hsv.x = (rgb.r - rgb.g)/(delta*6.0) + 2.0/3.0;\n    hsv.y = delta/maxC;\n    hsv.z = maxC;\n    return hsv;\n}\n\n//returns if a coord is within an aabb area\nbool inArea(float startx, float starty, float endx, float endy, vec2 uv){\n    return uv.x >= startx && uv.y >= starty && uv.x <= endx && uv.y <= endy;\n}\n\n//returns 1 - 0 where start is 0 and end is 1\nfloat normalizeRange(float start, float end, float uv){\n    return (uv - start)/(end-start);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float slider = texelFetch( iChannel0, ivec2(0, 0),0 ).x;\n    vec2 sampler = texelFetch( iChannel0, ivec2(0, 0),0 ).zw;\n    float pxunit = 1.0/iResolution.y; //one pixel in uv coordinates\n    \n    vec3 col = vec3(0.8);\n    \n    //ui code\n    vec4 colorPickArea = vec4(0.4, 0.1, 1.2, 0.9);\n    vec4 slideArea = vec4(1.225, colorPickArea.y, 1.3, colorPickArea.w);\n    vec4 sliderArea = vec4(slideArea.x, slider-0.01, slideArea.z, slider+0.01);\n    vec4 colorPickerArea = vec4(sampler.x - 0.03, sampler.y - 0.03, sampler.x + 0.03, sampler.y + 0.03);\n    vec4 pickedColorArea = vec4(slideArea.x, colorPickArea.w, slideArea.z, slideArea.z - slideArea.x);\n    \n    float hue = normalizeRange(slideArea.y, slideArea.w, slider);\n    float sat = normalizeRange(0.4, 1.2, sampler.x);\n    float val = normalizeRange(0.1, 0.9, sampler.y);\n    \n    //color pick area\n    if (inArea(colorPickArea.x - pxunit, colorPickArea.y - pxunit, colorPickArea.z + pxunit, colorPickArea.w + pxunit, uv)) {\n        col = vec3(0);\n        if (inArea(colorPickArea.x, colorPickArea.y, colorPickArea.z, colorPickArea.w, uv)) {\n            col = hsvToRgb(vec3(hue, normalizeRange(colorPickArea.x, colorPickArea.z, uv.x), normalizeRange(colorPickArea.y, colorPickArea.w, uv.y)));\n        }\n    }\n    //slide area\n    if (inArea(slideArea.x - pxunit, slideArea.y - pxunit, slideArea.z + pxunit, slideArea.w + pxunit, uv)) {\n        col = vec3(0);\n        if (inArea(slideArea.x, slideArea.y, slideArea.z, slideArea.w, uv)) {\n            col = hsvToRgb(vec3(normalizeRange(slideArea.y, slideArea.w, uv.y),1.0,1.0));\n        }\n    }\n    //slider\n    if (inArea(sliderArea.x - pxunit*2.0, sliderArea.y - pxunit*2.0, sliderArea.z + pxunit*2.0, sliderArea.w + pxunit*2.0, uv)){\n        col = vec3(0);\n        if (inArea(sliderArea.x - pxunit, sliderArea.y - pxunit, sliderArea.z + pxunit, sliderArea.w + pxunit, uv)){\n            col = hsvToRgb(vec3(hue,1.0,1.0));\n        }\n    }\n    //color picker\n    if (inArea(colorPickerArea.x - pxunit, colorPickerArea.y - pxunit, colorPickerArea.z + pxunit, colorPickerArea.w + pxunit, uv)){\n        col = vec3(0);\n        if (inArea(colorPickerArea.x, colorPickerArea.y, colorPickerArea.z, colorPickerArea.w, uv)){\n            col = hsvToRgb(vec3(hue, sat, val));\n        }\n    }\n    //picked color area\n    if (inArea(pickedColorArea.x - pxunit, pickedColorArea.y - pxunit, pickedColorArea.z + pxunit, pickedColorArea.w + pxunit, uv)){\n        col = vec3(0);\n        if (inArea(pickedColorArea.x, pickedColorArea.y, pickedColorArea.z, pickedColorArea.w, uv)){\n            col = hsvToRgb(vec3(hue, sat, val));\n        }\n    }\n    \n    //tests inverse function\n    //col = rgbToHsv(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(0)) { //pixel (0,0)\n        vec4 m = vec4(iMouse.xy/iResolution.y, abs(iMouse.zw)/iResolution.y); //normalize mouse coords\n        if (m.z >= 1.225 && m.w >= 0.1 && m.z <= 1.3 && m.w <= 0.9 && iMouse.z > 0.0) { //check if last mouse click was in slider area & mouse is clicked\n            col.x = clamp(m.y,0.1,0.9); //move slider, restrained to area\n        } else {\n            col.x = texelFetch( iChannel0, ivec2(0, 0),0 ).x; //leave slider position unchanged\n            col.x = clamp(col.x,0.1,0.9); //fixes starting position\n        }\n        \n        if (m.z > 0.4 && m.z < 1.2 && m.w > 0.1 && m.w < 0.9 && iMouse.z > 0.0){ //check if last mouse click was in picker area & mouse is clicked\n            col.zw = vec2(clamp(m.x, 0.4, 1.2), clamp(m.y, 0.1, 0.9)); //move picker, restrained to area\n        } else {\n            col.zw = texelFetch( iChannel0, ivec2(0, 0),0 ).zw; //leave picker position unchanged\n            col.zw = vec2(clamp(col.z, 0.4, 1.2), clamp(col.w, 0.1, 0.9));//fixes starting position\n        }\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 138, 162, 211, 451], [453, 572, 596, 596, 1010], [1012, 1056, 1129, 1129, 1208], [1210, 1256, 1311, 1311, 1350], [1352, 1352, 1409, 1409, 4200]]}
{"id": "fdjBWw", "name": "texcoord / 3d sprite effect", "author": "cxm", "description": "texcoord sprite effect.\nrecord or edit it for you game sprite.\nIt's bad performance to normalize each one.", "tags": ["sprite", "texcoord", "cineshader"], "likes": 12, "viewed": 3312, "published": 3, "date": "1646763409", "time_retrieved": "2024-07-30T16:59:29.864478", "image_code": "\n#define scale 1.\n#define count 100\n#define time iTime\n\n#define PI 3.1415926\n#define TAU 6.2831852\n\nconst float speed = .1;\n\nmat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\n\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat getPrint( in vec2 uv, float rot, float size, float idx ){\n\n    float p = 0.;\n\n    uv -= .5;\n    uv *= _rot1( rot * .1 + ( idx * 3.1415926 *  .25 ) - fract( iTime * speed ) * TAU + 5. );\n    uv += .5;\n\n\n    float r = hashOld33( vec3( cos( fract( iTime * speed ) * TAU ), sin( fract( iTime * speed ) * TAU ), cos( fract( iTime * speed ) * TAU ) ) ).r;\n\n    vec2 bUv = uv;\n\n    float my =  .5 * 1. - cos( rot + r ) * .001;\n\n    // mix blobs, or change color\n    float g = ( 1. - abs( bUv.x - my ) * sin( idx / 70. ) * idx / float( count ) * 50. );\n\n    // g = max( 0.1, g );\n\n    p = 1. - smoothstep( 0., .1 * size * abs( cos( rot ) ) * 1., distance( uv, vec2( my + sin( fract( iTime * speed ) * TAU ) * .01, .2 + sin( rot ) * -.05 * cos( fract( iTime * speed ) * TAU ) ) ) );\n\n    p *= g;\n    \n    return p;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    float resRa = ( iResolution.x / iResolution.y );\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n\n\n    // Time varying pixel color\n    vec3 col = vec3( 0. );\n    \n    float p = .0;\n    \n    float t = iTime * 5.;\n\n\n    for( int i = 0; i < count; i++ ){\n        p = getPrint( uv, t * float( i ) / float( count ), atan( 1., cos( float( i ) * cos( fract( iTime * speed ) * TAU ) * .1 ) ), float( i ) );\n\n        col = mix(\n            col,\n            // colors[ int(mod( float(i), 7. )) ] * float( i ) / float( count ),\n            vec3( 1. ) * float( i ) / float( count ) * 1.1,\n            p\n        );\n\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 146, 146, 205], [208, 208, 233, 262, 518], [520, 520, 546, 546, 728], [730, 730, 793, 793, 1544], [1547, 1547, 1604, 1654, 2387]]}
{"id": "7sBfRc", "name": "Tunnel eva", "author": "byj1996", "description": "I have never worked with shaders before, only software rendering. Hope you enjoy it anyway. :-) ", "tags": ["3d", "tunnel", "cube", "demoeffect", "textured", "classic", "splitting", "mixture"], "likes": 4, "viewed": 313, "published": 3, "date": "1646760067", "time_retrieved": "2024-07-30T16:59:30.810948", "image_code": "// Fork of \"Tunnel 3D Shape\" by ingagard. https://shadertoy.com/view/4djfWt\n// 2022-03-08 16:51:38\n\n#define rotate(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat lineWidth=7.0;\nfloat tunneRotSpeed = 0.1;\nfloat tunnelSpeed = 0.3;\nfloat size=100.0;\nvec3 objectStartPos = vec3(0, 0, -40.0);    \nfloat camRange=1000.0;\nfloat scale[8];\nvec3 projPos[8];    \n\nvec4 quads[6] = vec4[]( \n    vec4(0, 1, 2, 3), \n    vec4(4, 5, 6, 7), \n    vec4(3, 7, 4, 0), \n    vec4(6, 5, 1, 2), \n    vec4(0, 1, 5, 4), \n    vec4(2, 3, 7, 6));\n\nvec3 edges[24];\n\n\nvoid oval(vec2 screenCoord, vec2 center, float radius, float strokeThickness, vec4 strokeColor, vec4 fillColor, inout vec4 pixel)\n{\n  float dist= distance(screenCoord, center);\n\n  if (dist<radius)\n  { \n    if (dist<radius-strokeThickness)\n    {\n      pixel = fillColor;\n    } else\n    {\n      pixel = strokeColor;\n    }\n  }\n}\n\n\nbool lineItersection(vec2 v1, vec2 v2, vec2 v3, vec2 v4) \n{    \n  float bx = v2.x - v1.x;\n  float by = v2.y - v1.y;\n  float dx = v4.x - v3.x;\n  float dy = v4.y - v3.y;\n\n  float b_dot_d_perp = bx * dy - by * dx;\n\n  if (b_dot_d_perp == 0.0) return false;\n\n  float cx = v3.x - v1.x;\n  float cy = v3.y - v1.y;\n\n  float t = (cx * dy - cy * dx) / b_dot_d_perp;\n  if (t < 0.0 || t > 1.0)  return false;\n\n  float u = (cx * by - cy * bx) / b_dot_d_perp;\n  if (u < 0.0 || u > 1.0)  return false;\n\n  return true;\n}\n\n\nvoid Line(vec2 screenCoord, vec2 p1, vec2 p2, float thickness, vec4 color, inout vec4 pixel)\n{\n\n  float a = distance(p1, screenCoord);\n  float b = distance(p2, screenCoord);\n  float c = distance(p1, p2);\n\n  if ( a >= c || b >=  c ) return;\n\n  float p = (a + b + c) * 0.5;\n\n  float dist = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  if (dist<thickness)\n  {\n    pixel = mix(pixel, color, 1.0/max(1.0, dist*3.0));\n  }\n}\n\n\n\nbool insideQuad(vec2 v1, vec2 v2, vec2 v3, vec2 v4, vec2 point)\n{\n\n  vec2 point2 = vec2(point.x-10000.0,point.y);\n    \n  int colCount = 0;\n\n  if (lineItersection(point, point2, v1, v2))         \n  {     colCount++;  }\n  if (lineItersection(point, point2, v2, v3))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v3, v4))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v4, v1))\n  {     colCount++;  }\n\n  return (colCount==1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float frame = float(iTime)*60.0;\n  float FrameRad = radians(frame);\n  float sinFrame = sin(FrameRad);\n  float cosFrame = cos(FrameRad);\n  float sinFrame2 = sinFrame*0.2;\n  float cosFrame2 = cosFrame*2.2;\n  vec2 center = (iResolution.xy/2.0)+vec2((cosFrame*sinFrame2)*250.0, (cosFrame-cosFrame2)*50.0);\n  vec2 centerFragDist = center-fragCoord;\n  vec3 halfRes = vec3(iResolution.x*0.5, iResolution.y*0.5, 0);   \n  vec2 uvTunnel = fragCoord.xy / iResolution.xy;\n  float angle = atan( centerFragDist.y, centerFragDist.x)*3.14;\n  float dist = length(fragCoord-center);\n\n  uvTunnel.x=1.0/(dist*0.0005);\n  uvTunnel.y=angle;\n\n  vec4 color = texture(iChannel3, uvTunnel*vec2(0.4, 3.0)+vec2(frame*tunnelSpeed, frame*tunneRotSpeed));\n  color*=vec4(0.3, 0.3, 0.3, 0.3)*(1.0/(dist*0.01));   \n\n  float rot = frame*0.02;\n  vec2 uv = (fragCoord.xy / iResolution.xy);\n  vec2 uv2 = (fragCoord.xy / iResolution.xy +vec2(frame*0.01, frame*0.003))*0.1;\n  vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\n  vec3 camPos = vec3(0, 0, 90.0+cos(FrameRad)*50.0);\n    \n  vec3 verts[8] = vec3[](\n    vec3(-1.0, -1.0, -1.0), \n    vec3(-1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, -1.0), \n    vec3(-1.0, 1.0, -1.0), \n    vec3(-1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, -1.0));\n    \n  for (int i=0; i<8; i++)\n  {           \n      // Y ROTATION    \n      verts[i].xz *= rotate(rot); \n      // X ROTATION\n      verts[i].yz *= rotate(rot*0.7);  \n      // Z ROTATION\n      verts[i].xy *= rotate(rot*0.2);  \n      \n      verts[i]+=objectStartPos;\n  }\n\n  for (int i=0; i<8; i++)\n  {                            \n    float camDistance = distance(verts[i], camPos);\n    scale[i] = (camRange/camDistance)*0.1;\n    projPos[i] = verts[i]-camPos;\n    projPos[i]*=size*scale[i];    \n    projPos[i]+= halfRes;\n  }\n\n  float range =  max(0.0, 1.0*sin(FrameRad));\n \n  for (int i=0; i<6; i++)\n  {\n    vec3 center = (projPos[int(quads[i].x)]+projPos[int(quads[i].y)]+projPos[int(quads[i].z)]+projPos[int(quads[i].w)])/4.0;           \n    edges[i*4 + 0]=projPos[int(quads[i].x)]+((center-projPos[int(quads[i].x)])*range);\n    edges[i*4 + 1]=projPos[int(quads[i].y)]+((center-projPos[int(quads[i].y)])*range);\n    edges[i*4 + 2]=projPos[int(quads[i].z)]+((center-projPos[int(quads[i].z)])*range);\n    edges[i*4 + 3]=projPos[int(quads[i].w)]+((center-projPos[int(quads[i].w)])*range);            \n  }\n\n  for (int i=0; i<6; i++)\n  {  \n    if (insideQuad(edges[i*4 + 0].xy, edges[i*4 + 1].xy, edges[i*4 + 2].xy, edges[i*4 + 3].xy, screenCoord))\n    { \n      vec2 center = (edges[i*4 + 0].xy+edges[i*4 + 1].xy+edges[i*4 + 2].xy+edges[i*4 + 3].xy)/4.0;                \n\n      float minX = min(edges[i*4 + 0].x, min(edges[i*4 + 1].x, min(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float minY = min(edges[i*4 + 0].y, min(edges[i*4 + 1].y, min(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n      float maxX = max(edges[i*4 + 0].x, max(edges[i*4 + 1].x, max(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float maxY = max(edges[i*4 + 0].y, max(edges[i*4 + 1].y, max(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n\n      float width = maxX-minX;\n      float height = maxY-minY;       \n      float xDist = distance(minX, screenCoord.x)/width;\n      float yDist = distance(minY, screenCoord.y)/height;\n\n      color = (color+texture(iChannel3, vec2(xDist, 1.0-yDist)*0.9))*0.3;\n      color-=0.3*((distance(center, screenCoord)/width));\n    }\n  }\n\n  vec4 lineColor = color*11.0;\n\n  for (int i=0; i<6; i++)      \n  {    \n    Line(screenCoord, edges[i*4 + 0].xy, edges[i*4 + 1].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 1].xy, edges[i*4 + 2].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 2].xy, edges[i*4 + 3].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 3].xy, edges[i*4 + 0].xy, lineWidth, lineColor, color);\n  }\n\n  for (int i=0; i<24; i++)\n  {       \n    oval(screenCoord, edges[i].xy, 4.0, lineWidth, vec4(1.0), color*5.0, color);\n  }\n\n  vec2 sunPos = vec2(400.0+(cos(FrameRad)*300.0), 200.0+(sin(FrameRad)*100.0));      \n  float sunDist = distance(screenCoord, sunPos)*0.02;\n\n  fragColor = color + vec4(0.1/sunDist, 0.1/sunDist, 0.1/sunDist,0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 664, 664, 858], [861, 861, 920, 920, 1364], [1367, 1367, 1461, 1461, 1795], [1799, 1799, 1864, 1864, 2250]]}
{"id": "7d2BRV", "name": "Fractal Waffle", "author": "lwswl", "description": "A fractal waffle.\nClick to drag.", "tags": ["raymarching", "fractal", "waffle"], "likes": 6, "viewed": 224, "published": 3, "date": "1646759564", "time_retrieved": "2024-07-30T16:59:34.125087", "image_code": "float t=0.0;\nvec3 o;\nvec3 d;\nfloat i=0.0;\n#define e 0.002\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x));\n#define PI 3.1415926\nfloat table(vec3 p)\n{\n  vec3 v=abs(p+vec3(2.45,0,0))-vec3(2,3,4)*0.9;\n  return length(max(v,0.0))+min(max(v.z,max(v.x,v.y)),0.);\n}\nfloat cloth(vec3 p){ \n      vec3 curl=vec3(0,sin(p.z*4.)*0.2*(p.x+0.3),sin(p.y*4.)*0.2*(p.x+0.3));\n      vec3 v=abs(p+vec3(2.45,0,0)+curl)-vec3(2,3,4);\n      vec3 t=(p+curl)*4.0;\n      float ret=max(abs(min(max(v.y,max(v.z,v.x)),0.)+length(max(v,0.)))-0.04,-(2.+p.x));\n      \n      \n      return ret*0.5;\n\n}\nfloat plate(vec3 p){\n    float d=dot(p.yz,p.yz);\n    return max(length(p.yz)-2.0,abs(p.x-d*0.1-0.001*d*d*sin(40.*atan(p.y/p.z)))-0.04*clamp(1./d,0.5,1.));\n}\nfloat map(vec3 p){\n    \n    i=0.0;\n    float d=100.;\n    vec3 o=vec3(0);\n    float r=0.5;\n    float f=0.0;\n    if(length(p)<20.){\n        while(i<8.){\n            vec3 on=vec3(0);\n            vec3 k=vec3(0,3.,0)*r;\n            k.xy*=rot(i*0.5);\n            k.xz*=rot(i*0.3); \n            r*=0.5;\n            d*=2.;\n            \n            for(float j=0.0;j<7.0;j++){\n                k.yz*=rot(2.*PI/7.0);\n                f=length(p+o+k*0.5)-r;if(f<d){d=f;on=+k*0.5;}\n                f=length(p+o-k*0.5)-r;if(f<d){d=f;on=-k*0.5;}\n\n            }\n            o+=on;\n            if(on==vec3(0)){\n                d*=0.5;\n                break;\n            }\n            i++;\n            if(d<e)break;\n            if(d>2.)break;\n                \n          \n\n            \n        }\n    }\n    if(i<2.0)d-=fbm(p*10.,1.0,2)*0.05;\n    if(i>4.0)d-=fbm(p*100.,0.43,5)*0.004*(1./i);\n    if(i==3.0)d-=fbm(p*21.,1.2,3)*0.01-0.005;\n    \n    float saucer=plate(p+vec3(0.61,0,0));\n    float tablecloth=cloth(p+vec3(0.1,0,0));\n    \n    if(saucer<d){\n        \n        \n        if(tablecloth<saucer){\n            i=-3.;\n            float Table=table(p);\n            if(Table<tablecloth)return Table;\n            i=-1.;\n            return tablecloth;\n        }\n        i=-2.;\n        return saucer;\n    }\n    if(tablecloth<d){\n        float Table=table(p);\n        i=-3.;\n        if(Table<tablecloth)return Table;\n        i=-1.;\n        return tablecloth;\n    }\n    \n\n    return d;\n}\nvec3 norm(vec3 p){\n    float f=map(p);\n    return normalize(vec3(f-map(vec3(p.x-0.002,p.yz)),f-map(vec3(p.x,p.y-0.002,p.z)),f-map(vec3(p.xy,p.z-0.002))));\n}\nvoid march(){\n    float x=1.0;\n    t=0.01;\n    while(x>e&&t<100.0){\n        x=map(o+d*t);\n        t+=x*0.9;\n    }\n\n}\nfloat shadow(vec3 o, vec3 d){\n    float x=1.0;\n    t=0.04;\n    float ret=1.0;\n    while(x>e&&t<10.0){\n        x=map(o+d*t);\n        t+=x;\n        ret=min(ret,x/t);\n        if(x<e)return 0.0;\n    }\n    //if(t>mt)return 0.0;\n    return ret;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv=(fragCoord.yx/iResolution.yx-0.5)*normalize(iResolution.yx);\n    d=vec3(uv,-1);\n    o=vec3(0,0,sin(iTime*0.4)*3.+4.);\n    //o.z+=10.;\n    if(iMouse.z>0.1){\n        d.xz*=rot(-1.8+iMouse.y*0.01);\n        o.xz*=rot(-1.8+iMouse.y*0.01);\n\n        d.yz*=rot(iMouse.x*0.01);\n        o.yz*=rot(iMouse.x*0.01);\n    }else{\n        d.xz*=rot(-0.8+sin(iTime*0.4+0.7)-0.2);\n        o.xz*=rot(-0.8+sin(iTime*0.4+0.7)-0.2);\n\n        d.yz*=rot(iTime*0.1-1.0);\n        o.yz*=rot(iTime*0.1-1.0);\n    }\n    fragColor.rgb=vec3(0);\n    march();\n    if(t<100.0){\n        vec3 albedo;\n        float spec;\n        float rough;\n        float sharp=0.0;\n        if(i==-3.0)albedo=vec3(0.5),spec=0.;\n        else if(i==-2.0)albedo=vec3(0.5),spec=1.;\n        else if(i==-1.0)albedo=vec3(0.8,0.7,0.5),spec=0.;\n        else if(i<2.0)albedo=vec3(0.5,0.4,0.3),spec=0.;\n        else if(i==3.0)albedo=vec3(0.04,0.02,0.3),spec=0.3;\n        else if(i==2.0||i==4.)albedo=vec3(0.1,0.04,0.02),spec=0.2;    \n        else albedo=vec3(0.25,0.11,0.04),spec=0.27;\n        {\n            //vec3 p=floor(o+d*t*2.);\n            //albedo=vec3(1)*mod(p.x+p.y+p.z,2.);\n            //albedo*=mod(p,5.);\n            //albedo=vec3(0);\n        }\n        vec3 N=norm(o+d*t);\n        vec3 ld=normalize(vec3(0.5,1,0));\n        spec=pow(0.5*max(0.,dot(reflect(o,N),ld)),1.+spec+sharp)*spec*0.1;\n        float shad=shadow(o+d*t,ld);\n        float l=clamp(dot(N,ld),0.0,1.0)*shad;\n        fragColor.rgb*=albedo;\n        fragColor.rgb+=spec*l;\n        fragColor.rgb+=spec*shad;\n        fragColor.rgb+=albedo*l;\n        \n        if(t<10.)t*=0.0;\n        \n        //fragColor.rgb=N*0.5+0.5;\n    }\n    \n    fragColor=sqrt(fragColor);\n}", "image_inputs": [], "common_code": "float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}//from DaveH\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\n// returns 3D value noise\nfloat noise(vec3 x)\n {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n            \n}//from iq, for waffle texture\n\nfloat fbm(vec3 x,float H,int octaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}//from iq, for waffle texture\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 151, 151, 260], [261, 261, 281, 281, 568], [569, 569, 589, 589, 725], [726, 726, 744, 744, 2187], [2188, 2188, 2206, 2206, 2344], [2345, 2345, 2358, 2358, 2461], [2462, 2462, 2491, 2491, 2702], [2703, 2703, 2760, 2760, 4449]]}
{"id": "sdSBzc", "name": "Losing Focus 2", "author": "dr2", "description": "Quick defocusing: time-varying focal plane distance", "tags": ["wave", "blur", "dof", "hexagon", "focus", "building"], "likes": 25, "viewed": 454, "published": 3, "date": "1646759258", "time_retrieved": "2024-07-30T16:59:35.462511", "image_code": "// \"Losing Focus 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Mix from \"Losing Focus\" and \"Edible Edifices\").\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define txBuf iChannel0\n\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 txVal, col4;\n  vec2 canvas, uv, duv;\n  float tCur, dstFoc, dPix, r;\n  float ga = pi * (3. - sqrt(5.));\n  const float NP = 32.;\n  canvas = iResolution.xy;\n  uv = fragCoord / canvas;\n  tCur = iTime;\n  dstFoc = 40. + 160. * SmoothBump (0.25, 0.75, 0.25, mod (0.05 * tCur, 1.));\n  dPix = abs (dstFoc - texture (txBuf, uv).a);          // reverse-mapped depth buffer method .. \n  duv = 0.0001 * dPix * vec2 (canvas.y / canvas.x, 1.); // ..(DoF techniques in GPU Gems 1 and 3)\n  col4 = vec4 (0.);\n  for (float n = float (VAR_ZERO); n < NP; n ++) { //  Vogel's method for point spreading\n    r = sqrt (n / NP);\n    txVal = texture (txBuf, uv + duv * r * sin (n * ga + vec2 (0.5 * pi, 0.)));\n    col4 += vec4 (txVal.rgb, 1.) * exp (-1. * r * r) *\n       clamp (1. + (1. + 0.1 * txVal.a * txVal.a) * (abs (dstFoc - txVal.a) - dPix), 0., 1.);\n  }\n  col4.rgb = pow (col4.rgb / col4.a, vec3 (0.7));\n  fragColor = vec4 (col4.rgb, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Losing Focus 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec3 HsvToRgb (vec3 c);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 qHit, ltDir;\nvec2 gId, trkF, trkA, bldCs;\nfloat tCur, dstFar, hgSize, wavHt, emFrac, grRad, pR, pA, bldTp, rc;\nint idObj;\nbool isOcc, isSh;\nconst float pi = 3.1415927, sqrt2 = 1.41421, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CasBldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  qq = q;\n  q.xy -= vec2 (-5., 1.2);\n  d = PrRoundBoxDf (q, vec3 (0.15, 1.2 + rc, 5.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 1.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  d = max (d, - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.6, 0.)), vec2 (0.6, 0.4), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 5.;\n  q.y -= 0.2;\n  d = min (PrCylAnDf (q.xzy, 0.45, 0.05, 1.2 + 0.2), PrCylDf (q.xzy, 0.4, 1.2));\n  dMin = min (dMin, d);\n  q = qq;\n  q.xy -= vec2 (-2., 2.);\n  d = max (max (q.y - 1.8 - 0.3 * q.x, - q.x), - p.y);\n  dMin = min (dMin, d);\n  d = PrRoundBoxDf (q, vec3 (0.15, 2.2 + rc, 2.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 2.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.3, 2.3);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat TwrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 3.5 - rc;\n  d = PrRoundBoxDf (q, vec3 (vec2 (1.3) * (1. - 0.05 * q.y), 3.5).xzy - rc, rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-4., -1.);\n  d = min (d, PrRoundCylDf (q.xzy, 0.8 * (1. - 0.05 * q.y) - rc, rc, 2.5 - rc));\n  q.x -= 1.7;\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y - 0.8 + 0.2 * q.x * q.x).xzy, vec3 (2., 0.4, 0.1), rc));\n  q.z = abs (q.z);\n  q -= vec3 (-2.5, -1., 1.1);\n  d = min (d, PrRoundCylDf (q.xzy, 0.7 * (1. - 0.05 * q.y)- rc, rc, 1.5 - rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PyrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = max (max (abs (q.y) - 2., - q.x + q.y), min (0.4 - abs (abs (q.z) - 0.6), (q.y - q.x + 0.18 -\n     abs (mod (q.x + q.y - 0.02, 0.4) - 0.2) / sqrt2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.2;\n  d = PrCylAnDf (q.xzy, 0.5, 0.05, 0.2);\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat TajBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (5.8, 0.1, 5.8) - rc, rc);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * (pA - 0.5) + 0.5) / 8.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = abs (q.y) - 2.;\n  q.y = mod (q.y + 0.4, 2.) - 1.;\n  q.z = abs (q.z) - 0.6;\n  d = max (d, max (- q.x, - max (PrCapsDf ((q - vec3 (0., -0.5, 0.)).xzy, 0.4, 1.), - q.y - 0.2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.z = abs (q.z);\n  q -= vec3 (-5., 3.1, 5.);\n  d = PrCylDf (q.xzy, 0.3 - 0.1 * q.y / 3., 3.);\n  dMin = min (dMin, d);\n  q.y -= 3.2;\n  d = PrSphDf (q, 0.3);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.6;\n  d = PrSphDf (q, 2.);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PisBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ht, dh, a, ai, nf, na;\n  nf = 8.;\n  na = 12.;\n  ht = 3.5;\n  q = p;\n  d = PrCylDf (q.xzy, 3., 0.05);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, pi / 4.);\n  q.y -= ht + 0.05;\n  q.xy = Rot2D (q.xy, 0.025 * pi);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  d = PrCylDf (q.xzy, 1., ht);\n  dh = abs (q.y) - ht * (1. + 1. / (4. * nf));\n  q.y = mod (q.y + ht / nf, 2. * ht / nf) - ht / nf;\n  d = min (d, max (dh, PrRoundCylDf (q.xzy, 1.2 - rc, rc, ht / (4. * nf) - rc)));\n  ai = floor (na * (a - 0.5) + 0.5) / na;\n  q.xz = Rot2D (q.xz, 2. * pi * ai);\n  q.y = abs (q.y) - ht / nf;\n  d = max (d, - PrRoundBoxDf (vec3 (length (q.xz) - 1., q.y, 2. * pi * (abs (a - ai - 0.5) - 0.5 / na)),\n     vec3 (0.2, 0.55 * ht / nf, 0.12) - rc, rc));\n  q.x -= -1.05;\n  d = min (d, max (dh, PrCylDf (q.xzy, 0.08, ht / nf)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 0.4;\n  d = PrRoundBox2Df (vec2 (pR - 6.5, abs (q.y) - 0.4), vec2 (0.25, 0.01), rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (64. * (pA - 0.5) + 0.5) / 64.));\n  q.x = abs (q.x + 6.5) - 0.15;\n  d = min (d, PrCylDf (q.xzy, 0.08, 0.4));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat FrtBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * (pA - 0.5) + 0.5) / 5.));\n  q.xy -= vec2 (-2., 1.4);\n  d = max (max (- q.x, abs (q.y) - 1.4), - PrRoundBoxDf (vec3 (q.x, abs (q.y) - 0.5,\n     mod (q.z + 0.5, 1.) - 0.5), vec3 (0.1, 0.2, 0.15), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x - 2., q.y - 1.4 - 0.3 * q.x), vec2 (2.2, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.xy -= vec2 (-3.5, -0.6);\n  d = max (max (abs (q.x) - 0.4, abs (q.y) - 0.8),\n     - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.2, 0.)), vec2 (0.4, 0.3), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x, q.y - 0.9 + 0.4 * abs (q.x)), vec2 (0.6, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 5.5 * tan (pi / 5.);\n  d = PrCylDf (q.xzy, 0.8, 1.1);\n  r = 0.2 * length (q.xz);\n  q.y -= 1.4 - r;\n  d = min (d, PrCylDf (q.xzy, 1.1, 0.3 - r));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat WvnBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rs, s, h, f, yy;\n  h = 2.5;\n  rs = 0.15;\n  q = p;\n  q.y -= h + rs;\n  f = q.y / h - 1.;\n  yy = abs (q.y) - h;\n  d = max (pR - 2.3 - 0.7 * f * f, yy);\n  q.xz *= 1.4 + 0.4 * f;\n  q.xz = vec2 (20. * pA, length (q.xz) - 10. / pi);\n  d = min (d, length (vec2 (yy, q.z)) - 2. * rs);\n  s = 0.4 * rs * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z + s)),\n     length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z - s))) - rs, yy));\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat PstBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, ss;\n  s = 1.7;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    q.xz = abs (q.xz) - 0.75 * s;\n    ss = s * s;\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    d = min (PrRoundBoxDf (q - vec3 (0., 0.6 * ss - rc, 0.), s * vec3 (0.3, 0.6 * s, 0.3) - rc, rc),\n       PrCylDf ((q - vec3 (0., 1.45 * ss - rc, 0.)).xzy, 0.12 * s, 0.25 * ss));\n    dMin = min (dMin, d);\n    s *= 0.85;\n  }\n  return 0.9 * dMin;\n}\n\nfloat BrgBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.1 + 0.01 * sin (8. * pi * pR);\n  d = max (abs (abs (pR - 5.2) - 1.4) - 0.4, abs (q.y) - 0.1);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 1.5;\n  d = min (PrCylDf (q.xzy, 2.5, 1.5),\n     PrCylDf (vec3 (q.xz, q.y - (2.2 - 0.25 * pR + 0.1 * sin (32. * pi * pA))), 2.8, 0.07));\n  q.y -= 2.16;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.22));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * (pA - 0.5) + 0.5) / 3.));\n  d = max (d, - PrRoundBoxDf (q - vec3 (-2.5, 0.8, 0.), vec3 (0.7, 0.8, 0.7), rc));\n  dMin = min (dMin, d);\n  q.x += 5.2;\n  q.y -= 0.5 - 0.2 * q.x * q.x;\n  d = PrBoxDf (q, vec3 (1.6, 0.1, 0.6));\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.3, 0.5);\n  d = min (d, PrRoundBoxDf (q, vec3 (1.6, 0.3, 0.1) - rc, rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PanBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 1.8;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (4.9, 1.6, 2.9) - rc, rc);\n  q.y = abs (q.y) - 1.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (5.4, 0.1, 3.4) - rc, rc));\n  q = p;\n  q.y -= -1.7;\n  d = min (d, PrRoundBoxDf (q, vec3 (6., 0.1, 4.) - rc, rc));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 1.7, 0.75);\n  q.y -= 0.75;\n  d = min (d, max (max (PrSphDf (q, 2.), - q.y), 0.2 - pR));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = mod (q.xz + 0.5, 1.) - 0.5;\n  d = max (PrCylDf (q.xzy, 0.2, 1.5), max (abs (p.x) - 5.5, abs (p.z) - 3.5));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * (pA - 0.5) + 0.5) / 16.));\n  q.xy -= vec2 (-1.85, 2.2);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.75));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p.xz -= HexToPix (gId * hgSize);\n  dMin = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  q.y -= wavHt - 0.05;\n  d = SmoothMax (abs (q.x) - 0.48 * sqrt3 * hgSize, q.y, 0.05);\n  DMINQ (1);\n  if (isOcc) {\n    q = p;\n    q.xz = Rot2Cs (q.xz, bldCs);\n    q.y -= wavHt + 0.35;\n    pR = length (q.xz);\n    pA = ((pR > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5;\n    rc = 0.05;\n    if (! isSh) d = PrCylDf ((q - vec3 (0., 3.8, 0.)).xzy, 8.21, 3.8);\n    if (isSh || d < 0.1) {\n      if (bldTp <= 4.) {\n        if      (bldTp == 1.) d = CasBldgDf (q, dMin);\n        else if (bldTp == 2.) d = TwrBldgDf (q, dMin);\n        else if (bldTp == 3.) d = PyrBldgDf (q, dMin);\n        else /*if (bldTp == 4.)*/ d = TajBldgDf (q, dMin);\n      } else if (bldTp <= 7.) {\n        if      (bldTp == 5.) d = PisBldgDf (q, dMin);\n        else if (bldTp == 6.) d = FrtBldgDf (q, dMin);\n        else /*if (bldTp == 7.)*/ d = WvnBldgDf (q, dMin);\n      } else /*if (bldTp <= 10.)*/ {\n        if      (bldTp == 8.) d = PstBldgDf (q, dMin);\n        else if (bldTp == 9.) d = BrgBldgDf (q, dMin);\n        else if (bldTp == 10.) d = PanBldgDf (q, dMin);\n      }\n      DMINQ (2);\n    } else dMin = min (dMin, d);\n    q.y -= -0.2;\n    d = PrRoundCylDf (q.xzy, 8.2 - rc, rc, 0.15 - rc);\n    DMINQ (3);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.4 * sin (0.2 * 2. * pi * p)) +\n     0.1 * tCur, 1.) - 0.5;\n  wavHt = dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.31, 43.11) + 27.11);\n  isOcc = (fRand.y > emFrac);\n  if (isOcc) {\n    bldTp = 1. + floor (10. * (fRand.y - emFrac) / (1. - emFrac));\n    bldCs = sin (2. * pi * fRand.x + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  int idObjT;\n  isSh = true;\n  idObjT = idObj;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 2. * hgSize) break;\n  }\n  idObj = idObjT;\n  isSh = false;\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, c;\n  float dstObj, sh;\n  bgCol = vec3 (0.5, 0.4, 0.4);\n  emFrac = 0.02;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrObjConf ();\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      c = isOcc ? HsvToRgb (vec3 (0.1 * bldTp, 0.05, 0.8)) : vec3 (0.8, 0.8, 0.8);\n      if (vn.y > 0.5) {\n        col4 = vec4 (c, 0.1) * (0.8 + 0.2 * Fbm2 (ro.xz));\n        if (isOcc) col4 = mix (vec4 (0.45, 0.25, 0.1, 0.1), col4,\n           smoothstep (8.2, 8.25, length (ro.xz - HexToPix (gId * hgSize))));\n      } else col4 = vec4 (0.9 * c, 0.1);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.35, 0.17, 0.05, 0.15);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.45, 0.25, 0.1, 0.1);\n    }\n    sh = ObjSShadow (ro + 0.1 * ltDir, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) + step (0.95, sh) * col4.a *\n       pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return vec4 (clamp (col, 0., 1.), dstObj);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\n#define txSize iChannelResolution[0].xy\n\n#define AA   0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, col4;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, vFly;\n  canvas = iResolution.xy;\n  uv = fragCoord.xy / canvas - 0.5;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  tCur = mod (tCur, 1200.);\n  hgSize = 11.;\n  az = 0.;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.2 * pi * sin (0.02 * pi * tCur);\n  }\n  trkF = 0.2 * vec2 (0.1, 0.17);\n  trkA = 2. * vec2 (1.25, 0.45);\n  vFly = 3.;\n  ro = TrackPath (vFly * tCur);\n  ro.xy += vec2 (3.5, 30.);\n  vd = normalize (TrackVel (vFly * tCur));\n  az += atan (vd.x, vd.z);\n  el = clamp (el, -0.25 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.;\n  dstFar = 500.;\n  ltDir = vuMat * normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col4 = vec4 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col4 += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = col4;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSBzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[359, 359, 415, 415, 1346], [1348, 1348, 1405, 1405, 1488]]}
{"id": "ssSfR3", "name": "Multipass Test [ppxxll]", "author": "robclouth", "description": "Multipass test", "tags": ["ppxxll"], "likes": 0, "viewed": 196, "published": 3, "date": "1646746447", "time_retrieved": "2024-07-30T16:59:36.492756", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = 1. - texture(iChannel1, uv);\n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 145]]}
{"id": "7djBzG", "name": "Screen-space Radiosity", "author": "Dave_Hoskins", "description": "Render the whole scene from each pixel's POV, accumulating brightness in the screen buffer.\nEvery pixel is a light source\n\n\n\n\n", "tags": ["3d", "screenspace", "radiosity"], "likes": 31, "viewed": 1013, "published": 3, "date": "1646726345", "time_retrieved": "2024-07-30T16:59:37.273668", "image_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 1. Render an unlit scene from the point of view of each pixel.\n// 2. Use screen buffer to store accumulated light. 🌞\n// 3. Repeat forever.\n// Every pixel is a light source\n\n// I amazes me how nicely it works, even though it can't see light from hidden objects.\n// I was inspired many years ago by this nice and descriptive article:\n\n\n// https://justinmeiners.github.io/Hugo-Elias-Radiosity/ 🔗\n\n// ( I think it was written before GPU shaders existed)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        \n    fragColor = vec4(sqrt(col.xyz), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define UNI(a, b) (a.x) < (b.x) ? a:b\nstruct Box\n{\n    vec3 centre;\n    vec3 size;\n};\n\n// This is the simple room scene of boxes...\n// TRY LIFTING THE ROOF A LITTLE! 😀\n// Boxes filled in as above structure\nBox boxes[] = Box[]\n(\n    Box(vec3(0,0,-300), vec3(210,100,10)),\n    Box(vec3(-200,00,0), vec3(10,100,300)),\n    Box(vec3(100,0,300), vec3(100,100,10)),  // Either side of door\n    Box(vec3(-150,0,300), vec3(100,100,10)),\n    Box(vec3(-0,70,300), vec3(100,30,10)), // Lintel\n    Box(vec3(200,-70,0), vec3(10,40,300)),   // Window wall\n    Box(vec3(190.,60,0), vec3(20,40,300)),\n    Box(vec3(200.,0,0), vec3(10,40,120)),\n    Box(vec3(0.,110,0), vec3(200,10,300)),      // Roof\n    Box(vec3(0.,-120,0), vec3(200,20,300)),     // Floor\n    Box(vec3(150.,-50,150), vec3(10,200,10)),   // Pillar.\n    Box(vec3(-150.,-50,150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(150.,-50,-150), vec3(10,200,10)),  // Pillar.\n    Box(vec3(-150.,-50,-150), vec3(10,200,10))  // Pillar.\n\n);\n\n//-----------------------------------------------------------------------------------------------------------------\n// Hash without Sine 2 (WebGL 2)\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/intersectors\nvec4 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec4(10000.0); // no intersection\n    vec3 norm = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4( tN, norm);\n}\n\n\n//-----------------------------------------------------------------------------------------------------------------\nvec4 boxWorldIntersection( in vec3 ro, in vec3 rd, vec3 loc, vec3 boxSize) \n{\n    return boxIntersection(ro-loc, rd, boxSize);\n}\n//-----------------------------------------------------------------------------------------------------------------\nvec4 traceScene(vec3 ori, vec3 dir)\n{\n    vec4 a,b;\n\n    a.x = 10000.0;\n    for (int i = 0; i < boxes.length(); i++)\n    {\n        a = UNI(a, boxWorldIntersection(ori, dir, boxes[i].centre, boxes[i].size));\n    }\n    return a;\n}\n//\n\n\n", "buffer_a_code": "// by Dave Hoskins. 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define VIEW_PROJ_Z 1.25\nmat3 camMat;\nvec3 camPos;\n//-----------------------------------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z));\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nmat3 cameraMat( in vec3 ro, in vec3 ta, float roll )\n{\n\tvec3 cw = normalize(ta-ro);\n   \n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    mat3 m;\n    m = mat3( cu, cv, cw );\n    return m;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvec2 getScreenspaceLocation(vec3 pos, mat3 cMat, vec3 cPos)\n{\n \n    mat3 inv = transpose(cMat);\n    vec3 cp = inv * (cPos - pos);\n    vec2 sun2d = VIEW_PROJ_Z * cp.xy / cp.z;\n    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);\n    vec2 st = .5+.5*sun2d*asp;\n    return st;\n}\n//-----------------------------------------------------------------------------------------------------------------\n// The open areas are the only light source...\nvec3 getSky(vec3 ray)\n{\n\n    vec3 sunDir = normalize(vec3(50, 20.+ sin(iTime*.4+2.)*10., 40.0*(sin(iTime)*.5+.5))-8.);\n    \n    vec3 col1 =  texture(iChannel1, ray).xyz * 3.;\n\n    float sun = pow(max(dot(sunDir, ray), 0.0), 1000.0) * 2000.;\n    return col1+sun;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\n#define SAMPLES 1000\n\nvec3 getPixelView(vec3 pos, vec3 nor, vec2 uv)\n{\n    vec3 col = vec3(0);    \n\n    for (int i = min(0, iFrame); i < SAMPLES; i++)\n    {\n        // Random hemispherical rays around the surface normal\n\n        vec3 ray  = (hash33(float(i*133)+pos*5.+iTime*5.)-.5);\n        ray = ray * sign(dot(ray, nor));\n        ray = normalize(ray+nor*.01);\n        \n        \n\n        vec4 res = traceScene(pos+nor*.01, ray);\n\n        if (res.x >= 10000.)\n        {\n            col += getSky(ray); \n        }\n        else\n        {\n            vec3 p = pos + ray * res.x;\n            vec2 st = getScreenspaceLocation(p,camMat, camPos);\n            // Add previous results if we can see them!\n            if (st.x >= 0.0 && st.x < 1.0 && st.y >=0.0 && st.y < 1.0)\n            {\n                col += texture(iChannel0, st).xyz * max(dot(ray, nor),0.) ;\n                // each pixel is lit by Lambert's cosine law.\n            }\n        }\n    }\n    return (col / float(SAMPLES)) ;\n}\n\n//-----------------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    camPos = vec3(-70, 0., sin(-iTime*.3)*230.0);\n\n    vec3 camTar = vec3(50, 10, 0);\n\n    camMat = cameraMat(camPos, camTar, 0.0);\n    vec3 ray = normalize( vec3(uv,  VIEW_PROJ_Z)) * camMat;\n    \n    vec4 res = traceScene(camPos, ray);\n\n    if (res.x >= 10000.)\n    {\n        col = getSky(ray);\n    }\n    else\n    {\n        vec3 pos = camPos + ray * res.x;\n        vec3 diff = texCube(iChannel3, pos*.004, res.yzw).xyz; // Get a diffuse texture\n        diff = diff*.5+.5;\n        \n        col = diff * getPixelView(pos, res.yzw,  fragCoord.xy) * 1.; // Make it brighter!\n    }\n\n    \n    fragColor = vec4(col, 1.);\n\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djBzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[574, 574, 631, 631, 742]]}
{"id": "fsBfz3", "name": "soccer ball 3d", "author": "4eckme", "description": "soccer 3d", "tags": ["3d", "sound", "hexagon", "green", "ball", "white", "hexagons", "football", "black", "soccer"], "likes": 3, "viewed": 287, "published": 3, "date": "1646720072", "time_retrieved": "2024-07-30T16:59:38.102452", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define m(v2,deg) mod((v2)*rot(radians(deg)),60.0)-30.0\n#define hex() o1=m(o,0.);o2=m(o,60.);o3=m(o,120.);rgba+=clamp(vec4(abs(o1.y)+abs(o2.y)+abs(o3.y)-54.),0.1,1.0);\nvoid mainImage(out vec4 rgba,in vec2 o){\n    rgba=vec4(0.33,1.0,0.5,1);\n    vec2 R=iResolution.xy;\n    o-=R/2.;vec2 O=o;o/=min(R.x,R.y)/300.0;\n    vec2 o1,o2,o3;\n    o-=vec2(cos(iTime/3.14)*128.0,sin(iTime/3.14)*64.0);\n    o/=abs(cos(iTime))+0.25;\n    float scale=7.0,x=o.x/scale,y=o.y/scale,\n    z=sqrt(x*x+y*y)/scale;o/=cos(z);\n    if(z<1.0){//ball\n      rgba=vec4(0,0,0,1);\n      o+=vec2(cos(iTime/1.0)*90.0,-sin(iTime/1.0)*90.0);hex();o.y+=40.;hex();\n      rgba*=(pow(1.0-cos(z),2.0)+3./4.0);\n      if(rgba.x<=0.5)rgba*=pow(cos(z),-2.0)/2.0;\n    }else{//background\n      if(max(R.x,R.y)/min(R.x,R.y)<2.0&&min(R.x,R.y)>1000.0||min(R.x,R.y)<=360.0)\n       rgba*=(cos(dot(O,O)*5.0)+2.0)/3.0;//if ok\n      else rgba*=(cos(dot(O,O)/4.0)+2.0)/3.0;//else fix resolution\n    }\n}", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n    float t = time;\n    vec2 res=vec2(sin(2.0*t*float((cos(t))<0.05)));\n    return res;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 258, 258, 992]]}
{"id": "7d2BzV", "name": "vueltas n2", "author": "jorge2017a2", "description": "vueltas n2", "tags": ["vueltasn2"], "likes": 13, "viewed": 253, "published": 3, "date": "1646707660", "time_retrieved": "2024-07-30T16:59:38.887354", "image_code": "//----------image\n//por jorge2017a2----7-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdSphere( vec3 p, float s )\n   { return length(p)-s;}\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec3 opAngRep( vec3 p, float a )\n{   vec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 opAngRepFull( vec3 p, float numItem )\n{   return opAngRep(p, tau / numItem); }\n\nvec2 Edificio01(vec3 p, vec2 pdist)\n{   vec2 res=pdist; \n    float numItem=6.0;\n    vec3 pnew= opAngRepFull( p.xzy,numItem );\n    vec3 pnew1=pnew-vec3(15.0,0.0,0.0);\n    vec3 pnew2=pnew-vec3(40.0,15.0,0.0);\n    vec3 pnew3=pnew-vec3(75.0,5.0,0.0);\n    vec3 pnew4=pnew-vec3(50.0,10.0,25.0);\n    float d1= sdCylinderXY( pnew1-vec3(3.0,0.0,0.0), vec2(2.0,6.0) );\n    float d2= sdCylinderXY( rotate_x(pnew2 , radians(10.0)) , vec2(1.0,8.0) );\n    float d3= sdCylinderXY( rotate_x(pnew3 , radians(-20.0)) , vec2(6.0,15.0) );\n    float d4= sdBox(rotate_y(rotate_x( pnew1-vec3(15.0,0.0,0.0),radians(-20.0)),radians(-20.)), vec3(2.0,2,14.0) );\n    float d5= sdSphere(pnew4,5.0 );\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2,101.0));\n    res =opU2(res, vec2(d3,100.0));\n    res =opU2(res, vec2(d4,101.0));\n    res =opU2(res, vec2(d5,100.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1+sin(p.x*0.015+(p.z*0.25+p.y*cos(p.x*0.5))),100.0));\n    p.y=p.y-5.0;\n    vec2 ed1= Edificio01(p, res);\n    res =opU2(res, ed1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos)); // shadows \n    float occ = occlusion(hit, norm); //occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color==100)\n       { return getColorTextura( p, n,100); }\n   if (id_color==101)\n       { return getColorTextura( p, n,101); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    ///shane\n    col = mix(col, render_sky_color(rd), smoothstep(.25, .99, hit.x/MAX_DIST));\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=37.0;\n   float veltime=20.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,-1.5,25.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));   \n    rd= rotate_y(rd, radians(60.0));\n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 511, 543, 543, 627], [629, 629, 667, 667, 688], [690, 690, 729, 729, 824], [825, 825, 864, 864, 959], [960, 960, 999, 999, 1094], [1096, 1140, 1187, 1187, 1214], [1215, 1215, 1258, 1258, 1285], [1286, 1286, 1334, 1334, 1362], [1363, 1428, 1462, 1462, 1558], [1559, 1559, 1593, 1593, 1684], [1685, 1685, 1719, 1719, 1810], [1841, 1841, 1875, 1875, 2044], [2046, 2046, 2090, 2090, 2129], [2131, 2131, 2168, 2168, 2999], [3001, 3001, 3026, 3026, 3290], [3292, 3292, 3316, 3316, 3478], [3480, 3480, 3528, 3528, 3859], [3862, 3862, 3906, 3906, 4232], [4234, 4234, 4271, 4271, 4532], [4534, 4534, 4619, 4619, 5566], [5568, 5568, 5617, 5617, 5750], [5752, 5752, 5845, 5845, 5975], [5977, 5977, 6009, 6009, 6206], [6209, 6209, 6277, 6277, 6431], [6433, 6433, 6460, 6460, 6549], [6551, 6551, 6609, 6609, 6657], [6659, 6659, 6682, 6682, 6800], [6802, 6802, 6833, 6833, 7487], [7489, 7489, 7526, 7526, 7797], [7799, 7799, 7856, 7856, 8308]]}
{"id": "7s2fRV", "name": "Train Ride test", "author": "intrakits", "description": "Still trying to figure out how to make the lighting look better.", "tags": ["raymarcher", "moving", "train"], "likes": 4, "viewed": 232, "published": 3, "date": "1646706901", "time_retrieved": "2024-07-30T16:59:39.822852", "image_code": "#define trainSpeed iTime*2.\nvec2 GetDist(vec3 p){\n    float outerWall = dBox(p-vec3(0,0,-5), vec3(10,10,.1));\n    vec2 res = vec2(outerWall,1);\n    float window = dBox(p-vec3(0,0,-5), vec3(1,2,.1)); \n    res.x = opSmoothSubtraction( window,res.x, .2);\n    window = dBox(p-vec3(2,0,-5), vec3(.5,2,.1)); \n    res.x = opSmoothSubtraction( window,res.x, .2);\n    \n    vec2 backWall = vec2(dBox(p-vec3(6,0,4), vec3(1,10,10)),1);\n    res = colMin(backWall,res);\n    vec2 opWall = vec2(dBox(p-vec3(0,0,10), vec3(10,10,.1)),1);\n    res = colMin(opWall,res);\n    vec2 chairBack = vec2(sdCylinder(p, vec3(5,0,-4), vec3(5,0,1), 1.),2);\n    res = colMin(chairBack,res);\n    chairBack = vec2(dBox(p-vec3(5.5,-2,3), vec3(1,2,7)),2);\n    res = colMin(chairBack,res);\n    \n    vec2 chairBottom = vec2(sdCylinder(p, vec3(3,-4,-4), vec3(3,-4,1), 1.),2);\n    res = colMin(chairBottom,res);\n    chairBottom = vec2(sdCylinder(p, vec3(4.5,-4,-4), vec3(4.5,-4,1), 1.),2);\n    res = colMin(chairBottom,res);\n    vec3 treep = p;\n    treep.x = mod(treep.x-trainSpeed, 5.)-1.-trainSpeed;\n    vec2 tree = vec2(sdCylinder(treep, vec3(-trainSpeed,-10,-10), vec3(-trainSpeed,10,-10), .4),3);\n    res = colMin(tree,res);\n    vec3 grassP = p;\n    grassP.x-=trainSpeed;\n    float off = cellTex(grassP.xz/10.);\n    vec2 grnd = vec2(p.y+20.-off,4);\n    res = colMin(grnd,res);\n    \n    vec2 table = vec2(dBox(p-vec3(-1,-2,-3), vec3(1,.1,1.6)),1);\n    res = colMin(table,res);\n    table = vec2(sdRhombus(p-vec3(-2,-1.9,-4), 2., 0.5, .1, 0.1 ),1);\n    res = colMin(table,res);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n       \n         dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= texture(iChannel1, p.xy).rgb;\n        col*=refl*.4;\n        //col*=vec3(fresnel);\n        reflVal = 0.7;\n    }\n    else if(d.y == 2.){\n        col *= texture(iChannel2, p.zy).rgb*vec3(2,.7,.7)*.5;\n        reflVal = 0.;\n    }\n    else if(d.y == 3.){\n        col *= texture(iChannel3, p.zy).rgb;\n        reflVal =0.1;\n    }\n    else if(d.y == 4.){\n        col *= vec3(0,.5,0);\n        col*=refl*.4;\n        reflVal =0.3;\n        //col*=vec3(fresnel);\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    float dist = length(p);\n    return vec4(col,d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro =camPos+lookDir;\n    mat3 ca = setCamera(ro, lookDir, 0.0 );\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal);\n    vec4 bounce = reflVal*Render(ro,rd,reflVal);\n    col.xyz += bounce.xyz;\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n#define AA 1\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (eight circles, in this case) using \n// the darken (min(src, dst)) blend at various locations on a tile. Make the tile wrappable by \n// ensuring the shapes wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four circles. Of course, there is 4-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's lower overall. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// However, the main reason you'd bother in the first place is the ability to extrapolate\n// to a 3D setting (swap circles for spheres) for virtually no extra cost. The result isn't\n// perfect, but 3D cellular tiles can enable you to put a Voronoi looking surface layer on a \n// lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawShape(in vec2 p){\n    \n    // Wrappable circle distance. The squared distance, to be more precise.\n    p = fract(p) - .5;    \n    return dot(p, p);\n    \n    // Other distance metrics.\n    \n    //p = abs(fract(p) - .5);\n    //p = pow(p, vec2(8));\n    //return pow(p.x+p.y, .125)*.25;\n    \n    //p = abs(fract(p) - .5);\n    //p *= p;\n    //return max(p.x, p.y);\n    \n    //p = fract(p) - .5;\n    //float n = max(abs(p.x)*.866 + p.y*.5, -p.y);\n    //return n*n;\n    \n}\n\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\n//\nfloat cellTex(in vec2 p){   \n    \n \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5); // \n    #endif\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    \n    \n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.5, -.866, .866, .5)*(p - .5);\n    #endif\n    \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);\n    \n}\n\nvec3 lightPos = vec3(-20,0,0);\nvec3 camPos = vec3(-2.,0., 5.);\nvec3 lookDir = vec3(0,0,0);\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2fRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 49, 49, 1556], [1557, 1557, 1589, 1617, 2136], [2137, 2137, 2160, 2199, 2570], [2571, 2571, 2594, 2648, 3481], [3482, 3482, 3534, 3534, 3711], [3712, 3712, 3802, 3802, 3987], [3989, 3989, 4053, 4074, 5287]]}
{"id": "fsSBzK", "name": "spqr: Paris 3040 AD", "author": "spqr", "description": "HD animation / recording available here :\n\nhttps://youtu.be/U8SEEeRgYEg\n\nMakes use of Blackle's domain gating and fms_cat's IFS\n", "tags": ["a"], "likes": 5, "viewed": 238, "published": 3, "date": "1646698816", "time_retrieved": "2024-07-30T16:59:40.913935", "image_code": "\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*33.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\n\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n/*\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n*/\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<8;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\n\n\n\n\nint matter = 0;\n\nfloat artifact(vec3 p, float width) {\n  vec3 pt=p;\n  \n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n  dist=box(pt,vec3(.131));\n  \n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gatedbox(vec3 p, vec3 dim, float domain, float prob) {\n\n     prob = prob/=2.;\n     prob = 1.-prob;\n     \n \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nfloat box(vec3 p, float w, float h) {\n\n  vec3 b = vec3(w,w,h);\n  vec3 q = abs(p) - b;\n  return max(q.x,max(q.y,q.z)) ;\n\n}\n\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\n\n\nfloat hash21(vec2 p) {\n    float a = sin(p.x*1831.424)*9918.3232;\n    float b = sin(p.y*4254.001)*7742.4342;\n\n    float d = fract(a+b);\n    float e = sin(d * 4225.2421) * 9003.131;\n    return fract(e);\n\n}\n\nfloat poles(vec3 p, float widthlimit, float heightlimit) {\n\n   \n    p.yx *= .25;\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n   \n    vec2 dom = vec2(1.);\n     \n      \n    vec2 id = floor(p.yx/dom);\n    float f1 = hash21(id);\n    f1 = pow(f1,2.);\n \n    \n\n    \n    \n  \n  \n  \n    float me   = box(p - vec3(center, 0),    widthlimit, heightlimit * f1) ;\n    float next = box(p - vec3(neighbour, 0), widthlimit, heightlimit);\n    return min(me, next);\n}\n\n\nint material;\nfloat map(vec3 p) {\n\n\n    //geo\n  \n    vec3 q = p;\n  \n    float width = 4.;\n\n    float field = artifact(p, width);\n   \n    vec3 p1 = p.xzy;\n    vec3 p2 = p.xzy;\n      p2.xy *= rot(1.);\n    \n    \n    float type1 = poles(p1,                  .3, 17.);\n    float type2 = poles(p2 * vec3(.2,.2,1.), .3, 37.);\n    \n    vec3 impulse = vec3(0,0,1) * iTime *  144.;\n    float aircar = gatedbox(q + impulse,vec3(1.,7.,12.)*.2, 10., .07);\n    aircar = max(aircar, -(p.y + 60.));\n  \n    aircar = max(field,aircar);\n    type1 = max(field, type1);\n    type2 = max(field, type2);\n   \n    float type = min(type1,type2);\n    float ground = -p.y;\n    \n    \n    \n   \n  \n    \n  \n    float final =  min(ground,(min(type,aircar)));\n    \n \n    \n    if ( final == ground) {\n        material = 0;\n    }\n    if ( final == type) {\n        material = 1;\n    }\n   if ( final == aircar) {\n        material = 2;\n    }\n  \n    return final;\n  \n    \n\n    \n}\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(map(p) - vec3( map(k[0]),map(k[1]),map(k[2]) ));\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  // nav \n vec3 s,t;\n\n // switch\n                        // bobbing\n float tt = iTime * .03;\nif (mod(floor(iTime),14.) < 7.){\n\n  tt *= 4.;\n\n\n  \n  s = lattice(tt)*15.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  t = lattice(tt + 33.)*15.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 3. * arm;\n  t += tock(tt * 3.) * 3. * arm;\n  \n  s.y -=10.;\n  t.y -=10.;\n  \n  s.y = clamp(-10.,-50.,s.y);\n t.y = clamp(-10.,-40.,t.y);\n  \n  \n}\n\n                // hurtling forward\nelse {\n  tt *= 2.;\n  s = vec3(0,0,-40);\n  t = vec3(0);\n  s.y -= 40.;\n  t.y -= 10.;\n  \n  s += flitfbm(tt*20.) * .5;\n  t += flitfbm(tt*70. + 8.) * .5;\n  \n  s.y += sin(iTime*1.)*18.;\n  t.y += sin(iTime*1.)*3.;\n  \n  \n  vec3 hurt = vec3(0,0,1);\n  //hurt.yz *= rot(iTime*.02);\n\n  \n  vec3 adv = hurt * 779.1 * tt;\n  s+= adv;\n  t+= adv;\n  vec3 arm = t-s;\n  arm.xy *= rot(sin(tt));\n  t = s +arm;\n\n\n\n\n}\n\n   \n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  cx.xy *= rot(sin(iTime*.57)/9.);\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz += dot(uv,uv)/15.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz * 1.);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<2000.;z++){ \n  \n    i = z;\n    d = map(p);\n    d = abs(d) * .8;\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 2000.) {\n        break;\n    }\n    \n    dd += d;\n    p += r * d;\n\n  }\n \n  \n  \n  // hue\n  vec3 col;\n  vec3 z = vec3(.8,.5,.4);\n  \n  if ( material == 0) {\n    col = z*z;\n  } \n  if ( material == 1) {\n    col =z;\n   \n  }\n  if ( material == 2) {\n    col = vec3(0);\n    \n  }\n  \n  vec3 n = norm(p);\n  \n  float aodist=.1;\n  vec3 light = normalize(vec3(10,-20,30));\n  light.xz *= rot(iTime * 2.);\n\n  float ao = getao(p,n,aodist*.2);// * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff = max(0., dot(n,light)*.3 +.7);\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),2.) * 1.;\n  //float iff = pow(1. - i/2000.,2.);\n  \n  //col *= iff;\n  col *= diff ;\n  col *= ao ;\n  col += sss  * 1.;\n  col += spec * .2;\n  \n \n  //col = pow(col,vec3(.7));\n // vec3 fog = mix(vec3(0.1,0.2,0.7), vec3(0.6,0.6,0.6), pow(max(0.0,dot(r,light)),5.0));\n//  col = mix(fog,col,exp(-.00000003 * dd * dd * dd));\n\n// col = mix(col,vec3(1), pow(clamp(0.,1.,1.-(p.y/-10.)),6.));\n \n\n \n\n  col *= 1.3  ;\n  \n\n  if ( material == 2) {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 22.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col += edge * 10.;\n  } else {\n    n2 = norm(p, vec2(0.0, 1E-2 ));// + 3E-2*.01) );\n    n1 = norm(p, vec2(0.0, 8.5E-2) );\n    edge = saturate(length(n1-n2)/1.);\n    col -= edge* 10.;\n  }\n\n  \n\n  \n  if (! hit){\n\n      col = mix(vec3(.6),vec3(0),pow(r.y,.6));\n  }\n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n/*\n//  n2 = norm(p, vec2(0.0, 1E-2+3E-2*.01) );\n//  n1 = norm(p, vec2(0.0, 2E-2) );\n\n*/\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n/*\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 206, 206, 309], [312, 312, 366, 421, 645], [648, 648, 677, 677, 742], [743, 743, 785, 785, 892], [894, 894, 917, 917, 1025], [1027, 1027, 1051, 1051, 1598], [1600, 1600, 1622, 1622, 1830], [1832, 1832, 1857, 1857, 1890], [1892, 1892, 1914, 1914, 2032], [2036, 2036, 2057, 2057, 2106], [2107, 2107, 2127, 2127, 2176], [2178, 2178, 2199, 2199, 2246], [2247, 2247, 2266, 2266, 2335], [2336, 2336, 2356, 2356, 2735], [2736, 2736, 2761, 2761, 3230], [3232, 3232, 3255, 3255, 3333], [3334, 3334, 3354, 3354, 3538], [3540, 3540, 3563, 3563, 3765], [3768, 3768, 3791, 3791, 3917], [3920, 3920, 3949, 3949, 3978], [3982, 3982, 4007, 4007, 4047], [4052, 4052, 4066, 4066, 4106], [4109, 4109, 4145, 4145, 4198], [4222, 4222, 4246, 4246, 4301], [4304, 4304, 4328, 4328, 4414], [4423, 4423, 4443, 4443, 4657], [4659, 4659, 4685, 4685, 4734], [4869, 4869, 4908, 4908, 4985], [4988, 4988, 5018, 5018, 5044], [5047, 5047, 5085, 5085, 5373], [5377, 5377, 5400, 5400, 5513], [5514, 5514, 5535, 5535, 5934], [5936, 5936, 5958, 5958, 6163], [6165, 6165, 6192, 6192, 6218], [6220, 6220, 6248, 6248, 6279], [6280, 6280, 6304, 6304, 6495], [6502, 6502, 6571, 6571, 6877], [6899, 6899, 6936, 6936, 7488], [7490, 7490, 7512, 7512, 7720], [7760, 7760, 7783, 7783, 7898], [7900, 7900, 7960, 7960, 8423], [8425, 8425, 8462, 8462, 8546], [8549, 8549, 8568, 8568, 8714], [8718, 8718, 8740, 8740, 8922], [8924, 8924, 8982, 8982, 9415], [9432, 9432, 9451, 9463, 10356], [10359, 10359, 10385, 10385, 10510], [10513, 10513, 10533, 10533, 10652], [10658, 10658, 10679, 10679, 10702], [10704, 10704, 10723, 10723, 10832], [10834, 10834, 10875, 10875, 10921], [10922, 10922, 10964, 10964, 11009], [11011, 11011, 11068, 11068, 14303]]}
{"id": "sdjBRV", "name": "GlitchyFoufou", "author": "antoinefortin", "description": "hello", "tags": ["hello"], "likes": 3, "viewed": 336, "published": 3, "date": "1646697321", "time_retrieved": "2024-07-30T16:59:41.740725", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n \n    vec3 rb = vec3(0.0f);\n    vec3 ct = texture(iChannel0,uv.xy -vec2(uv.y / sin(iTime * 0.05), uv.x + sin(uv.y * 12.))).rgb;\n    vec3 ct2 = texture(iChannel0,uv.xy + vec2(uv.y, uv.x)).rgb;\n    vec3 ct3 = texture(iChannel0,uv.xy * vec2(uv.y + 1.5f, uv.x * ct2.g)).rbb;\n\n    vec3 tt = texture(iChannel0, uv).rgb;\n    \n    rb = 1.0f - (vec3(1.0f) - tt.rrr);\n    \n    \n    vec2 n = vec2(dFdx(rb.z), dFdy(rb.y)) *6.0f;\n    vec2 n2 = vec2(uv.x, uv.y);\n    float n3 = dot(n,n2 + sin(iTime));\n    // Output to screen\n    fragColor = vec4(vec3(n - n3, sin(n3)),1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 715]]}
{"id": "fs2fzK", "name": "Ray Traced Ambient Occlusion", "author": "demofox", "description": "an ambient occlusion demo\nChange noise types in the common tab\nPress spacebar to reset accumulation\nAll noise is white over time", "tags": ["ambientocclusion"], "likes": 39, "viewed": 1605, "published": 3, "date": "1646682897", "time_retrieved": "2024-07-30T16:59:42.761994", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// The maximum hit time is the farthest the AO rays look for a hit.\n// The AO shade is the percentage the hit is between 0 (black) and maximum hit time (white).\nconst float c_maximumRayHitTime = 10.0f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 1;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float c_goldenRatioConjugate = 0.61803398875f;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n// The noise type specifies noise over space. They are all white noise over time.\n#define NOISE_TYPE_WHITE 0\n#define NOISE_TYPE_BLUE  1\n#define NOISE_TYPE_BAYER 2  \n#define NOISE_TYPE_R2    3\n#define NOISE_TYPE_IGN   4\n#define NOISE_TYPE_NONE  5\n\n#define NOISE_TYPE NOISE_TYPE_BLUE\n", "buffer_a_code": "uint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat WangRandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 R2(int index)\n{\n    const float g = 1.32471795724474602596f;\n    const float a1 = 1.0f/g;\n    const float a2 = 1.0f/(g*g);\n    return vec2(float(index)*a1, float(index)*a2);\n}\n\n#if NOISE_TYPE == NOISE_TYPE_WHITE\n\n#define RNGSTATE uint\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return uint(pixelPosX * uint(1973) + pixelPosY * uint(9277) + frame * uint(26699)) | uint(1);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_BLUE\n\n#define RNGSTATE ivec3\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return ivec3(pixelPosX, pixelPosY, frame);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    vec2 uv = vec2(state.xy) / 1024.0 + R2(state.z % 256);\n    state.z = state.z + 1;\n    return texture(iChannel3, uv).r;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_BAYER\n\nstruct BayerRNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE BayerRNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 8.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 8.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    vec2 uv = vec2(state.pos.xy) / 8.0f;\n\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 8.0f), int(WangRandomFloat01(state.wangRng) * 8.0f));\n\n    return texture(iChannel2, uv).r;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_R2\n\nstruct R2RNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE R2RNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 64.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 64.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    const float g = 1.32471795724474602596f;\n    const float a1 = 1.0f/g;\n    const float a2 = 1.0f/(g*g);\n    float ret = fract(float(state.pos.x)*a1+float(state.pos.y)*a2);\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 64.0f), int(WangRandomFloat01(state.wangRng) * 64.0f));\n    return ret;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_IGN\n\nstruct IGNRNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE IGNRNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 64.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 64.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    float ret = fract(52.9829189f * fract(0.06711056f*float(state.pos.x) + 0.00583715f*float(state.pos.y)));\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 64.0f), int(WangRandomFloat01(state.wangRng) * 64.0f));\n    return ret;\n}\n\n#else  // NONE\n\n#define RNGSTATE uint\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return uint(frame * uint(26699)) | uint(1);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n#endif\n\nvec3 RandomUnitVector(inout RNGSTATE state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);       \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);   \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);     \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n    }\n\n    // 3 front balls on the floor\n    {\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n    }\n\n    // 5 small balls against the back wall\n    {\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);      \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);  \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);     \n    }\n}\n\nvec3 GetAOForRay(in vec3 startRayPos, in vec3 startRayDir, inout RNGSTATE rngState)\n{\n    // primary hit\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;    \n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_superFar;\n    TestSceneTrace(rayPos, rayDir, hitInfo);\n    if (hitInfo.dist >= c_superFar)\n        return vec3(1.0f, 1.0f, 1.0f);\n        \n    // update the ray position and raydir\n    // ray direction is a cosine weighted hemisphere oriented to the surface normal.\n    rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n    rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n\n    // AO ray\n    hitInfo.dist = c_maximumRayHitTime;\n    TestSceneTrace(rayPos, rayDir, hitInfo);\n\n    // the shade gets lighter as the hit distance gets farther\n    float distPercent = min(hitInfo.dist / c_maximumRayHitTime, 1.0f);\n    return vec3(distPercent, distPercent, distPercent);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    RNGSTATE rngState = MakeRNGState(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame));\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n\tfloat cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);     \n    \n    // calculate subpixel camera jitter for anti aliasing\n    uint wangRNG = uint(uint(fragColor.x) * uint(1973) + uint(fragColor.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(WangRandomFloat01(wangRNG), WangRandomFloat01(wangRNG)) - 0.5f;\n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetAOForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2fzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]]}
{"id": "7sBfzV", "name": "Another Anglemod Fractal", "author": "SnoopethDuckDuck", "description": "Most code reused from fork. Was playing around with dif shapes + values, thought this one looked nice", "tags": ["e"], "likes": 6, "viewed": 237, "published": 3, "date": "1646670985", "time_retrieved": "2024-07-30T16:59:43.520965", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 40.\n#define SURF_DIST .0001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // was 0 -3 3\n    vec3 ro = vec3(0, -0.2 + 0.5 * cos(0.5 * iTime), 4.4);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 angleMod(vec3 p, in float r) {\n    float a = pi / r;\n    \n    float a2 = mod(atan(p.z, p.x) + a, 2. * a) - a;\n    \n    p.xz = length(p.xz) * vec2(cos(a2), sin(a2));\n    \n    return p;\n}\n\nfloat test(float x, float n) {\n    float k = pow(0.4, -log(2.));\n    float f = exp(-pow(k * x, n));\n    return f;\n}\n\nfloat GetDist(vec3 p) {  \n   \n    float t = 0.125 * iTime;// - 0.25 * length(p);\n    float o = 2. * pi / 3.;\n    vec3 ax = vec3(cos(t-o), cos(t), cos(t+o));\n    p.xz *= Rot(-0.3 * iTime); \n    p = erot(p, normalize(ax), 0.5 * iTime);\n    //p = angleMod(p.yzx, 3.);\n    p = angleMod(p.yzx, 2.); \n    p *= 1.5;\n    float d = 100.;\n    float m = 1.;\n    \n    float n = 6.;\n    for(float i = 0.; i < n; i++) {\n        float io = pi * i / n;\n        \n        p = angleMod(p.xzy, 6.);\n\n        float cc = cc(io + iTime);\n\n        p.x -= (1. + 0.5 * cc) * m;\n        m *= 0.5;\n        float s = mod(i, 2.);\n      // d = min(d, length(p) - 0.5 * m);\n        float d2 = length(p) - m;\n        //d2 = p.x;\n        s < 1. ? d = min(d, d2) : d = smin(d, mlength(p.xy) - m);\n        //d = min(d, p.x);\n    }\n\n    return 0.333 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n   // float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n       // if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    //if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n\n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 1.); \n        col *= mix(vec3(0), col, fresnel2);\n        \n        col *= 0.5 + 0.5 * n.y;\n\n    //}\n    vec3 e = vec3(1);\n    vec3 col2 = vec3(0.7);\n    col2 *= exp(rd.y-0.4);//0.8 * abs(rd);//pal(cross(rd,p)., e, e, e, vec3(0,1,2)/3.);\n   // col *= pal(0.1 * p.y, e, e, e, vec3(0,1,2)/3.);\n    col = mix(col, col2, 1.-vec3(exp(-0.8 * length(p))));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.00001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float b) {\n    float f = cos(b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 649, 649, 850], [852, 852, 887, 887, 1042], [1044, 1044, 1074, 1074, 1159], [1161, 1161, 1184, 1184, 1980], [1982, 1982, 2025, 2025, 2336], [2338, 2338, 2362, 2362, 2552], [2554, 2554, 2604, 2604, 2795], [2797, 2797, 2854, 2854, 4075]]}
{"id": "ssSfRV", "name": "Minimal number print", "author": "Suslik", "description": "A simple shader to output numbers", "tags": ["debug", "print"], "likes": 3, "viewed": 174, "published": 3, "date": "1646650743", "time_retrieved": "2024-07-30T16:59:44.377674", "image_code": "float PrintDigit(uint digit, vec2 uv)\n{\n    uint digit_raster[10] = uint[](31599u, 9362u, 31183u, 29647u, 5101u, 29671u, 31719u, 4687u, 31727u, 29679u);\n    uint texel_index = uint(uv.x * 3.0f) + uint(uv.y * 5.0f) * 3u;\n    if(texel_index >= 0u && texel_index < 15u && digit >= 0u && digit < 10u && uv.x > 0.0f && uv.y > 0.0f && uv.x < 1.0f && uv.y < 1.0f)\n        return ((digit_raster[digit] & (1u << (14u - texel_index))) != 0u) ? 1.0f : 0.0f;\n    return 0.0f;\n}\n\nfloat PrintUInt(uint val, vec2 uv, uint max_digits)\n{\n    if(!(uv.x > 0.0f && uv.y > 0.0f && uv.x < 1.0f && uv.y < 1.0f)) return 0.0f;\n    uint place_index = max_digits - 1u - uint(uv.x * float(max_digits));\n    if(val < uint(pow(10.0f, float(place_index)) + 0.5f)) return 0.0f;\n    uint digit = (val / uint(pow(10.0f, float(place_index)) + 0.5f)) % 10u;\n    vec2 digit_uv = fract(vec2(uv.x * float(max_digits), uv.y)) * vec2(4.0f / 3.0f, 1.0f);\n    return PrintDigit(digit, digit_uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(PrintUInt(uint(iTime * 100.0f), uv, 5u));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 520, 520, 954], [956, 956, 1013, 1013, 1119]]}
{"id": "7sBBRV", "name": "Glory to Ukraine!", "author": "quizcanners", "description": "Just a fun shader to raise our spirits in these difficult times.", "tags": ["flag", "standwithukraine"], "likes": 18, "viewed": 1506, "published": 3, "date": "1646648814", "time_retrieved": "2024-07-30T16:59:45.370021", "image_code": "float hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n\n    uv = (uv-0.5) *(1.2 - uv.x*0.05) + vec2(0.5, 0.5);\n\n   vec3 windSeed =  vec3(uv.x * 5.,uv.y * 7., iTime);\n   \n   float BORDER = 0.1;\n   \n   float pole = smoothstep(BORDER, .4, uv.x);\n   \n   pole = 1. - pow(1.-pole,6.);\n   \n     float tension = \n     pow(\n     abs(uv.y-0.5) * 0.3\n     ,2.) \n     * (1. - uv.x)// * ( uv.y) \n   * 50.\n   \n  ;\n   \n   vec3 gyrPos = vec3(uv.x * (5. + uv.y*5. + tension * 15.) - iTime*5., uv.y*4., iTime * 0.2);\n   \n   float windForce = 0.3 + abs(cos(iTime * 0.2 + pole)  * cos(iTime * 0.345));\n   \n   float flagUp = 1.-windForce;\n   \n   uv.x -= pole * flagUp * 0.025; // fabric stretching -> flag length\n   \n   \n   float gyr = smoothstep(1.,0., \n   abs(dot(sin(gyrPos), cos(gyrPos.zxy)))\n   )\n   ;\n   \n  vec2 shadowUv = (uv-0.5)*1.3 + vec2(-0.15, 0.15);\n  \n   float wind = \n        sin(iTime * (2.45) \n        -  tension * 3. // curve of the vawe\n        + gyr * smoothstep(0.,1.,1.2-tension*2.) //* 0.5 \n        - uv.x * (3. + tension * 10. ) \n       ) * 0.6\n        *  windForce \n         \n        // Wind phases \n       + cos(iTime * 0.23 - uv.y * 3. + uv.x * 3.) * 0.5 // perspective waving\n       \n       ;\n       \n      wind *= pole;\n       \n   uv += wind*0.03 \n   * max(0., 1.5-tension)\n   ;\n   \n \n   \n   float w = length(vec2(dFdx(uv.x), dFdy(uv.y)));\n   float isFlag = smoothstep(BORDER,BORDER + dFdx(uv.x)*2., 0.5- abs(uv.x-0.5)) * smoothstep(BORDER,BORDER + dFdy(uv.y) * 2., 0.5- abs(uv.y-0.5));\n   \n  \n\n   float shadowThickness = 0.3; // 0.3 * (1. + wind*0.15);\n\n   float shadow = \n   smoothstep(BORDER - shadowThickness, BORDER, 0.5 - abs(shadowUv.x)) \n   * smoothstep(BORDER - shadowThickness, BORDER, 0.5 - abs(shadowUv.y)) ;\n\n\n float isBlue = smoothstep(0.5,0.5 + w*2., uv.y);\n   vec3 col = mix(vec3(1., 0.84, 0.) , vec3(0.,0.34,0.71), isBlue); vec3(isBlue); // Yelow Blue\n\n#ifdef AT_WAR\n    vec3 UPAcolor = mix( vec3(0.15,0.15,0.15), vec3(1.,0.1,0.1) ,isBlue);\n    float upaEdge = cos(iTime);// 0.2;\n    float isRed = smoothstep(upaEdge,upaEdge - w*2., 1.-uv.x);\n   col = mix(col*col, UPAcolor*UPAcolor , isRed);\n   col = sqrt(col);\n#endif\n\n   col.rgb *= (0.8 + wind * 0.3 * pole); // shadow\n   \n   vec3 tex = texture(iChannel0, uv*23.).rgb;\n   \n   col.rgb *= 0.9 + tex * 0.2; // fabric\n   \n  \n   col.rgb += 0.05 * pow(max(0., wind),7. + tex.r * 10.) * vec3(0.3, 0.3, 0.6);  // blick\n   \n   float bg = 0.3;\n   \n   col.rgb = mix(vec3(bg) * (2. - shadow), col.rgb, isFlag);\n   \n     \n   float noise =  hash13(vec3(fragCoord * 15., iTime));\n   \n   col.rgb += vec3(noise) * 0.03; // hide color range limit on shadows\n   \n   col.rgb += col.gbr*col.brg * 0.3; // Bloom\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 126], [129, 129, 186, 186, 2874]]}
{"id": "7sBBzK", "name": "Fractal flower nebula", "author": "jarble", "description": "A cosmic fractal.", "tags": ["fractal", "flower", "nebula"], "likes": 3, "viewed": 272, "published": 3, "date": "1646627270", "time_retrieved": "2024-07-30T16:59:46.128991", "image_code": "//change these constants to get different patterns!\n#define bend1 2.\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 3.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n\n    vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 9; k++){\n\n            //uv -= (t2.yx+.5)/scale;\n            uv -= (t2.yx)*(bend1+uv.x+uv.y);\n            if(k > 3){\n             uv -= (iTime)/16.;}\n            //uv -= (t2.yx)/(1.-uv.y-uv.x);\n            \n            //uv -= float(k%3)*float(k%2); //this makes it even more colorful\n            \n            float bend = bend1*(t2.y*bend1+1.)*(t2.x*bend1-1.);\n\n            t2 = -triangle_wave(-uv.yx-1.5,scale)/bend;\n\n            t3 = -triangle_wave(-uv,scale)*bend;\n            \n            uv.yx = (t3-t2)/bend1*2.;\n\n        col.x = abs(abs((uv.x+uv.y+col.x)-1.));\n        col = col.yzx;\n        \n        uv /= scale*scale;\n      }\n    fragColor = vec4((col),1.0);   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 137, 137, 249], [251, 251, 308, 308, 1266]]}
{"id": "ssBBzK", "name": "Space Donut", "author": "rileyborgard", "description": "rotating shapeshifting space donut", "tags": ["3d"], "likes": 1, "viewed": 189, "published": 3, "date": "1646626915", "time_retrieved": "2024-07-30T16:59:46.983706", "image_code": "\n#define MAX_ITER 100\n#define MAX_DIST 100.\n#define THRES 0.001\n\n\nvec3 donutOrientation() {\n    return normalize(vec3(cos(1. * iTime), cos(1.2746 * iTime + 0.238947), sin(3. * iTime)));\n}\n\nfloat getDist(vec3 p) {\n    float radius1 = sin(iTime * 1.) * 0.02 + 0.15;\n    float radius2 = cos(iTime * 1.) * 0.03 + 0.05;\n    \n    vec3 normal = donutOrientation();\n    \n    float distZ = dot(p, normal);\n    vec3 proj = p - normal * distZ;\n    float len = length(proj);\n    \n    return sqrt((radius1 - len) * (radius1 - len) + distZ * distZ) - radius2;\n    //return length(p - center) - radius;\n}\n\nvec3 getNormal(vec3 p) {\n    float radius1 = 0.15;\n    vec3 normal = donutOrientation();\n    \n    float distZ = dot(p, normal);\n    vec3 proj = p - normal * distZ;\n    vec3 closestPoint = normalize(proj) * radius1;\n    return normalize(p - closestPoint);\n}\n\nvec3 rayMarch(vec3 camera, vec3 dir) {\n    float amt = 0.;\n    for(int iter = 0; iter < MAX_ITER; iter++) {\n        float dist = getDist(camera + dir * amt);\n        if (dist < THRES || dist > MAX_DIST) {\n            break;\n        }\n        amt += dist;\n    }\n    return camera + dir * amt;\n}\n\nfloat lighting(vec3 p, vec3 light) {\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(light - p);\n    return max(0.2, dot(normal, lightDir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x;\n    \n    vec3 camera = vec3(0., 0., -1.);\n    vec3 light = vec3(0., 0., -20.);\n    vec3 ray = normalize(vec3(uv.xy, 1.0));\n    vec3 p = rayMarch(camera, ray);\n    \n    vec3 col = vec3(0, 0, 0);\n    if (getDist(p) < 5.) {\n        float shade = lighting(p, light);\n        col.rgb = vec3(1., 0.3, 0.5) * shade;\n    }\n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 91, 91, 187], [189, 189, 212, 212, 589], [591, 591, 615, 615, 847], [849, 849, 887, 887, 1142], [1144, 1144, 1180, 1180, 1300], [1302, 1302, 1359, 1359, 1778]]}
{"id": "NsjfzG", "name": "Ray March Voxel Terrain", "author": "natethegreat2525", "description": "Orthographic ray march of terrain. I'm planning on optimizing this in a compute shader but used this as a scratch environment to get the look I wanted.\n\nImplements a simple voxel based AO and ray marched shadows.", "tags": ["terrain", "raymarch", "voxel", "ao", "orthographic"], "likes": 6, "viewed": 485, "published": 3, "date": "1646605987", "time_retrieved": "2024-07-30T16:59:47.817477", "image_code": "#define voxResolution 150.\n#define topPlane .1\n#define verticalBlocks (topPlane * voxResolution)\n\nbool sampleVoxels(vec3 pos) {\n    int x = int(floor(pos.x));\n    int y = int(floor(pos.y));\n    int z = int(floor(pos.z));\n    \n    float height = verticalBlocks * (1. - texture(iChannel0, vec2(float(x) / voxResolution, float(z) / voxResolution)).r);\n\n    return float(y) < height-1.0;\n}\n\n// This AO gives a nice cartoonish highlight on the front corners of cubes.\n// This could be fixed by clamping the value but I prefer the effect in this case.\nfloat getAO(vec3 pos) {\n    \n    float sum = 0.;\n    if (sampleVoxels(pos + vec3(1, 0, 0))) {\n        sum += fract(pos.x);\n    }\n    if (sampleVoxels(pos + vec3(-1, 0, 0))) {\n        sum += 1.-fract(pos.x);\n    }\n    if (sampleVoxels(pos + vec3(0, 1, 0))) {\n        sum += fract(pos.y);\n    }\n    if (sampleVoxels(pos + vec3(0, -1, 0))) {\n        sum += 1.-fract(pos.y);\n    }\n    if (sampleVoxels(pos + vec3(0, 0, 1))) {\n        sum += fract(pos.z);\n    }\n    if (sampleVoxels(pos + vec3(0, 0, -1))) {\n        sum += 1.-fract(pos.z);\n    }\n    \n    return 1. - sum/6.;\n}\n\nbool inShadow(vec3 pos, vec3 dir) {\n    int x = int(floor(pos.x));\n    int y = int(floor(pos.y));\n    int z = int(floor(pos.z));\n\n    int xInc = int(sign(dir.x));\n    int yInc = int(sign(dir.y));\n    int zInc = int(sign(dir.z));\n\n    vec3 timeDeltas = vec3(abs(dir.y/dir.x), 1, abs(dir.y/dir.z));\n    vec3 maxTimes = vec3(\n        (fract(pos.x) - .5)*-sign(dir.x) + .5,\n        (fract(pos.y) - .5)*-sign(dir.y) + .5,\n        (fract(pos.z)-.5)*-sign(dir.z)+.5)\n            * timeDeltas;\n            \n    // There is probably a better branchless way but for now just using this. Also it seems like the\n    // 3d implementation in the paper has a bug so I changed it a bit here.\n    // https://www.researchgate.net/publication/2611491_A_Fast_Voxel_Traversal_Algorithm_for_Ray_Tracing\n    for (int i = 0; i < 20; i++) {\n        float height = verticalBlocks * (1. - texture(iChannel0, vec2(float(x) / voxResolution, float(z) / voxResolution)).r);\n        if (float(y) < height-1.0) {\n            return true;\n        }\n        if (maxTimes.x < maxTimes.y && maxTimes.x < maxTimes.z) {\n            x+=xInc;\n            maxTimes.x += timeDeltas.x;\n        } else if (maxTimes.y < maxTimes.x && maxTimes.y < maxTimes.z) {\n            y+=yInc;\n            maxTimes.y += timeDeltas.y;\n        } else {\n            z+=zInc;\n            maxTimes.z += timeDeltas.z;\n        }\n        if (float(y) > topPlane * voxResolution) {\n            break;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ang = iTime*.4;\n    vec3 dir = normalize(vec3(0, -1, 2));//iTime/5.));\n\n    vec3 camPos = vec3(-sin(ang)*1.8, 1, -cos(ang)*1.8);\n    float camScale = .5;\n    vec2 camSize = vec2(camScale, camScale*iResolution.y/iResolution.x);\n    \n    \n    dir.xz = dir.xz * cos(ang) + dir.zx * sin(ang);\n    \n    \n    vec3 up = vec3(0, 1, 0);\n    \n    float pixelScale = camScale / iResolution.x;\n    \n    vec3 xVec = normalize(cross(dir, up)) * pixelScale;\n    vec3 yVec = normalize(cross(dir, xVec)) * pixelScale;\n    \n    vec2 relFragCoord = fragCoord - iResolution.xy*.5;\n    relFragCoord.y = -relFragCoord.y;\n    \n    vec3 fragStart = camPos + relFragCoord.x * xVec + relFragCoord.y * yVec;\n    \n\n    float topPlaneYTime = (topPlane - fragStart.y) / dir.y;\n    vec3 topPlaneLoc = fragStart + dir*topPlaneYTime;\n    \n    //Old debug code\n    /*float stepLen = .005;\n    vec3 dirScaled = dir*stepLen/(length(dir.xz));\n    for (int i = 0; i < 200; i++) {\n        float height = 1.-texture(iChannel0, topPlaneLoc.xz).r;\n        if (height * topPlane > topPlaneLoc.y) {\n            fragColor = vec4(height, 0, 0, 1);\n            break;\n        }\n        topPlaneLoc += dirScaled;\n    }*/\n    \n    vec3 lightDir = normalize(vec3(1,1.12,1.5));\n    \n    \n    int x = int(floor(topPlaneLoc.x*voxResolution));\n    int y = int(floor(topPlaneLoc.y*voxResolution));\n    int z = int(floor(topPlaneLoc.z*voxResolution));\n    \n    int xInc = int(sign(dir.x));\n    int yInc = int(sign(dir.y));\n    int zInc = int(sign(dir.z));\n    \n    vec3 timeDeltas = vec3(abs(dir.y/dir.x), 1, abs(dir.y/dir.z));\n    vec3 maxTimes = vec3(\n        (fract(topPlaneLoc.x*voxResolution) - .5)*-sign(dir.x) + .5,\n        1,\n        (fract(topPlaneLoc.z*voxResolution)-.5)*-sign(dir.z)+.5)\n            * timeDeltas;\n            \n    float lastTime = 0.;\n    for (int i = 0; i < 200; i++) {\n        float height = verticalBlocks * (1. - texture(iChannel0, vec2(float(x) / voxResolution, float(z) / voxResolution)).r);\n        if (float(y) < height) {\n            float val = height / verticalBlocks;\n            vec3 col = vec3(sin(val*1000.0), sin(val*3452.0 + 34.3), cos(val*3442.234 + 54.953));\n            //col = vec3(val,0,0);\n            //fragColor = vec4(col*.3 + vec3(.7,.7,.7), 1);\n            fragColor = vec4(val*.3, val*.5 + .3, val*.0, 1);\n            vec3 shadowPos = topPlaneLoc*voxResolution + dir*(lastTime-.01)/abs(dir.y);\n            vec3 samplePos = topPlaneLoc*voxResolution + dir*(lastTime-.1)/abs(dir.y);\n            float shade = 1.0;\n            if (inShadow(shadowPos, lightDir)) {\n                shade *= .5;\n            }\n            shade *= getAO(samplePos);\n            fragColor.rgb = fragColor.rgb * shade;\n            break;\n        }\n        if (maxTimes.x < maxTimes.y && maxTimes.x < maxTimes.z) {\n            x+=xInc;\n            lastTime = maxTimes.x;\n            maxTimes.x += timeDeltas.x;\n        } else if (maxTimes.y < maxTimes.x && maxTimes.y < maxTimes.z) {\n            y+=yInc;\n            lastTime = maxTimes.y;\n            maxTimes.y += timeDeltas.y;\n        } else {\n            z+=zInc;\n            lastTime = maxTimes.z;\n            maxTimes.z += timeDeltas.z;\n        }\n    }\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 127, 127, 385], [387, 546, 569, 569, 1117], [1119, 1119, 1154, 1154, 2588], [2590, 2590, 2647, 2647, 5843]]}
{"id": "fsSfRK", "name": "pontos deleuze", "author": "ufffd", "description": "me sinto contente, \nme sinto muito contente", "tags": ["pointillism", "chromaticshift", "galcosta"], "likes": 1, "viewed": 168, "published": 3, "date": "1646605407", "time_retrieved": "2024-07-30T16:59:48.814811", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel1,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLUR 0.01\n#define RATIO_SCALE 3.\n#define PIXEL_NOISE_SCALE 0.25\n#define IMAGE_WARP 0.0\n#define GRID_NOISE 0.0\n#define FEEDBACK 0.98\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(in vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // prebrightness\n    vec3 precol = texture(iChannel0,uv).rgb;\n    float prebrightness = (precol.r + precol.g + precol.b) / 3.0;\n    \n    vec2 ratio = vec2(32.,20.) * RATIO_SCALE * prebrightness;\n    \n    // pixel noise\n    float npxls = PIXEL_NOISE_SCALE;\n    vec2 npxl = floor(iTime+uv*ratio*npxls)/(ratio*npxls);\n    float pxln = noise(npxl*6.) + noise(npxl*4.) * noise(npxl*2.);\n    \n    // noise\n    float ns = noise(uv*1.+iTime) + noise(uv*3.+iTime) + noise(uv*12.+iTime)*0.2;\n    \n    // pixel grid\n    // float pxls = 1. * (floor(pxln*3.) + 1.0);\n    float pxls = GRID_NOISE*ns + 1.;\n    vec2 pxl = floor(uv*ratio*pxls)/(ratio*pxls);\n    \n    vec2 subuv = fract(uv*ratio*pxls);\n    \n    // fragColor = vec4(pxln,pxln,pxln,1.0);\n    // return;\n    \n    // webcam\n    col = texture(iChannel0,pxl+ns*IMAGE_WARP).rgb;\n    float brightness = (col.r + col.g + col.b) / 3.0;\n    \n    float ss = (pxls * ratio.y) / iResolution.y; // scaling factor to smoothstep across 2 or 3 pixels\n    ss += BLUR;\n    \n    float crs = 0.4 * col.r; // circle size\n    vec2 crp = vec2(0.5); // circle position\n    crp += rotate(vec2(.0,.5*(1.-brightness)), iTime + brightness*20.);\n    float cr = smoothstep(crs+ss,crs-ss,distance(subuv,crp));\n    \n    float cgs = 0.4 * col.g; // circle size\n    vec2 cgp = vec2(0.5); // circle position\n    cgp += rotate(vec2(.0,.5*(1.-brightness)), iTime + brightness*20. + 2.0915);\n    float cg = smoothstep(cgs+ss,cgs-ss,distance(subuv,cgp));\n    \n    float cbs = 0.4 * col.b; // circle size\n    vec2 cbp = vec2(0.5); // circle position\n    cbp += rotate(vec2(.0,.5*(1.-brightness)), iTime + brightness*20. + 4.182);\n    float cb = smoothstep(cbs+ss,cbs-ss,distance(subuv,cbp));\n    \n    // col /= subuv.xyx;\n\n    col = vec3(\n        cr * col.r,\n        cg * col.g,\n        cb * col.b\n    );\n    col *= FEEDBACK * .1;\n    vec2 feedback_uv = uv * 0.998 - vec2(0.,-0.001);\n    feedback_uv += ns * 0.002;\n    col += texture(iChannel1,feedback_uv).rgb * FEEDBACK + (ns*ns) * 0.001;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 280]]}
{"id": "7s2fzy", "name": "Dithering Test On Video", "author": "andful", "description": "Simple dithering test", "tags": ["dithering"], "likes": 2, "viewed": 305, "published": 3, "date": "1646601996", "time_retrieved": "2024-07-30T16:59:49.677504", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float gray = texture(iChannel0, uv).r;\n    float noise = texture(iChannel1, fragCoord/8.0).r;\n    if (gray < noise) {\n        fragColor.rgb = vec3(0.0);\n    } else {\n        fragColor.rgb = vec3(1.0);\n    }\n    \n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 315]]}
{"id": "7sjfzy", "name": "Weird Expememenetirent", "author": "SnoopethDuckDuck", "description": "im not sure if I like this", "tags": ["e"], "likes": 2, "viewed": 266, "published": 3, "date": "1646600572", "time_retrieved": "2024-07-30T16:59:50.524240", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smerp(float x) {\n    float f = cos(pi * x);\n    float g = sign(f) * pow(abs(f), 0.25);\n    return 0.5 - 0.5 * g;\n}\n\nfloat floop(vec2 uv) {\n    uv += 0.005 * vec2(cos(iTime), sin(iTime));\n    float t = 1.2 * iTime;// + (0.5 + 0.5 * cc(1., 0.125 * pi * h21(uv) + iTime)) * h21(uv);\n    \n    //t += (0.5 + 0.5 * cc(10., 1. * pi * h21(uv) + iTime)) * 10. * length(uv);\n    \n    int f = int(floor(t)); \n    \n    float d = 10.;\n    float s = 0.;\n    vec2 p = vec2(0.);\n    \n    float n = min(100., floor(60. * iTime));\n    \n    for (float i = 0.; i < n; i++) {\n        float f2 = 0.0001 * float(f);\n        float f3 = 0.0001 * float(f + 1);\n        \n       // uv = abs(uv) - 0.125;\n        vec2 q = p;\n             \n        p = vec2( h21(vec2(f2)), h21(vec2(0.01 + f2)) );\n        vec2 p2 = vec2( h21(vec2(f3)), h21(vec2(0.01 + f3)) );\n        float fr = fract(t);\n        fr = smerp(fr);//smoothstep(0., 1., fr);\n        p = mix(p, p2, fr);\n        p = 0.6 * (p - 0.5);\n        f++;\n        if (i == 0.) q = p;\n        float d = sdSegment(uv, p, q);\n        //if (s < 1.) s = smoothstep(0., 1., s);\n        s = abs(0.985 * s - exp(-3. * (101. - i) * d));//max(0.99 * s, step(d, 0.1));\n    }\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float o = 0.001;\n    float s = floop(uv + vec2(o, 0));\n    s *= 6. * s;\n    \n   // vec2 q = vec2( h21(vec2(f)), h21(vec2(0.01 + f)) );\n   // p = 0.5 * (p - 0.5);\n   // q = 0.5 * (q - 0.5);\n\n   // f = fract(t);\n    //f = smerp(f);\n   // p = mix(p, q, f);\n\n    \n   // d = min(d, length(uv - q));\n   // float s = step(d, 0.01);\n    \n    vec3 col = vec3(s);\n    vec3 e = vec3(1);\n    col *= pal(0.62 + 0.05 * s, e, e, e, 0.4 * vec3(0,1,2)/3.);\n    col = sqrt(col);\n    col += 0.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [173, 173, 195, 195, 293], [295, 295, 317, 317, 1380], [1382, 1382, 1439, 1439, 2024]]}
{"id": "sd2fRy", "name": "Fractal Toruseseses", "author": "SnoopethDuckDuck", "description": "This is very laggy for me! Wanted to do more with it but its hard to come up with stuff at 8fps lol\n\n(changed it a bit so runs faster)", "tags": ["e"], "likes": 12, "viewed": 260, "published": 3, "date": "1646591287", "time_retrieved": "2024-07-30T16:59:53.742635", "image_code": "#define MAX_STEPS 150\n#define MAX_DIST 20.\n#define SURF_DIST .0001\n// SURF_DIST very low because you can see it \"click\" when motion reverts\n// for illusion of constant zoom-out\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(sin(iTime), cos(iTime), 2.);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n  // ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 angleMod(vec3 p, in float r) {\n    float a = pi / r;   \n    float a2 = mod(atan(p.z, p.x) + a, 2. * a) - a;\n    \n    p.xz = length(p.xz) * vec2(cos(a2), sin(a2));   \n    return p;\n}\n\nfloat test(float x, float n) {\n    float k = pow(0.4, -log(2.));\n    float f = exp(-pow(k * x, n));\n    return f;\n}\n\nfloat GetDist(vec3 p) {  \n    float f = fract(0.25 * iTime);\n    \n    // (used at the end)\n    float mx = 1. - f;\n   // mx = test(fract(0.25 * iTime), 5.);\n    mx = smoothstep(0., 1., mx);\n    \n    f = 3. - 2. * f;\n    p /= exp2(f);\n   // p *= pow(0.5, f);\n    float m = 3.; // was 2\n    \n    /*\n    float r1 = m;\n    float r2 = 0.25 * m;\n    float d1 = length(p.xy) - r1;\n    float d  = length(vec2(d1, p.z)) - r2;\n    */\n    \n    float d = 100.;\n    \n    int n = 7;\n    for(int i = 0; i < n; i++) {\n        p = angleMod(p.yzx, 4.);\n        p.x -= m;// + 0.25 * m * cos(io + iTime);\n        m *= 0.5;\n        float d1 = length(p.xy) - m;\n        d = min(d, length(vec2(d1, p.z)) - .25 * m);\n    }\n    \n    // do 2 extra gens which retract as you zoom out. \n    // when you \"click\" back it should look the same as when you started\n    float d2 = d;\n    \n    p = angleMod(p.yzx, 4.);\n    p.x -= m;\n    m *= 0.5;\n    float d1 = length(p.xy) - m;\n    d2 = min(d2, length(vec2(d1, p.z)) - .25 * m);\n    \n    p = angleMod(p.yzx, 4.);\n    p.x -= m;\n    m *= 0.5;\n    d1 = length(p.xy) - m;\n    d2 = min(d2, length(vec2(d1, p.z)) - .25 * m);\n        \n    d = mix(d, d2, mx);\n\n    return 2. * d; // makes it run a bit faster\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n   // float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n       // if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    vec3 p = ro + rd * d;\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        /*\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n        */\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n\n        float fresnel = pow(1.+dot(rd, n), 2.); \n        col *= mix(vec3(0), col, fresnel);\n        \n        col *= 0.5 + 0.5 * n;\n\n    }\n    vec3 e = vec3(1);\n    vec3 col2 = vec3(0.5 + 0.2 * cos(0.25 * iTime),1,0.3) * exp(rd.y-0.4);//0.8 * abs(rd);//pal(cross(rd,p)., e, e, e, vec3(0,1,2)/3.);\n    //col *= pal(0.1 * p.y, e, e, e, vec3(0,1,2)/3.);\n    col = mix(col, col2, 1.-vec3(exp(-0.8 * length(p))));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2fRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 197, 197, 259], [261, 261, 275, 275, 446], [448, 448, 483, 483, 634], [636, 636, 666, 666, 751], [753, 753, 776, 776, 1971], [1973, 1973, 2016, 2016, 2327], [2329, 2329, 2353, 2353, 2543], [2545, 2545, 2595, 2595, 2786], [2788, 2788, 2845, 2845, 4026]]}
{"id": "NsSfzy", "name": "[CrzClm] Plants", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["maptoy", "crazyclimbers"], "likes": 7, "viewed": 309, "published": 3, "date": "1646588339", "time_retrieved": "2024-07-30T16:59:54.911510", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .4\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n#define MIN_DIST .001\n#define MAX_DIST 20.\n#define MAT_VOID vec3(-1)\n#define MAT_GREEN_COL vec3(0.240886584,0.422814429,0.322595179)\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = fOpUnionSmooth( res, d, s );\n    }\n    return res;\n}\n\nvec3 bokoboko = vec3(0);\nvec3 unyounyo = vec3(0);\nvec3 bokomini = vec3(0);\nvec3 paripari = vec3(0);\nvoid setTriTextures(vec3 p) {\n  p.y += .14 * 1500.;\n  const float sclpari = 5.;\n  const float smoothness = .1;\n  paripari.x = voronoiSmooth(p.yz * sclpari, smoothness);\n  paripari.y = voronoiSmooth(p.xz * sclpari, smoothness);\n  paripari.z = voronoiSmooth(p.xy * sclpari, smoothness);\n  paripari = smoothstep(.01, .95, paripari);\n\n  const float sclboko = 10.;\n  bokoboko.x = gfbm(p.yz * sclboko, 1, .5);\n  bokoboko.y = gfbm(p.xz * sclboko, 1, .5);\n  bokoboko.z = gfbm(p.xy * sclboko, 1, .5);\n  bokoboko = smoothstep(.01, 1., bokoboko);\n\n  const vec3 sclunyo = vec3(8., 16., 8.);\n  vec3 q = p;\n  q *= sclunyo;\n  q.x += u2s(gfbm(q.yz * .85, 1, .5)) * .5;\n  R(q.xy, sin(q.x * 2.) * PI * .015);\n  unyounyo.x = gfbm(q.yz, 1, .5);\n  unyounyo.y = gfbm(q.xz, 1, .5);\n  unyounyo.z = gfbm(q.xy, 1, .5);\n  unyounyo = smoothstep(.0, 1., unyounyo);\n\n  const float sclbokomini = 30.;\n  p.y *= 2.;\n  bokomini.x = gfbm(p.yz * sclbokomini, 1, .5);\n  bokomini.y = gfbm(p.xz * sclbokomini, 1, .5);\n  bokomini.z = gfbm(p.xy * sclbokomini, 1, .5);\n  bokomini = smoothstep(.01, 1., bokomini);\n}\n\nfloat getTriDisp(vec3 v3, vec3 n) {\n  const float k = 3.;\n  n = normalize(n);\n  vec3 w = pow(abs(n), vec3(k));\n  return (v3.x * w.x + v3.y * w.y + v3.z * w.z) / (w.x + w.y + w.z);\n}\n\nvec3 getTriTrans(vec3 v3, vec3 n) {\n  const float k = 3.;\n  n = normalize(n);\n  vec3 w = pow(abs(n), vec3(k));\n  w /= w.x + w.y + w.z;\n  return v3 * sign(n) * w;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.) + length(max(d,0.))));\n}\n\nfloat pMirror(float x, float k){\n\treturn sqrt(x*x+k);\n}\n\nvec2 pBend(vec2 q, float k){\n    //Based on \"bend\" by las:\n    //https://www.pouet.net/topic.php?which=7931&page=5\n\tfloat r = 1./k;\n\tif(abs(k)<1e-1)return q;\n\tfloat sgn = sign(k);\n\tvec2 d = vec2(-q.x, (r-q.y))*sgn;\n\tfloat a = -atan(d.x, d.y);\n\tvec2 b = vec2(sin(a), cos(a));\n\treturn sgn*vec2(-b.y*d.x-b.x*d.y, b.x*d.x-b.y*d.y)+vec2(a*r,r);\n}\n\nvoid pElongate(inout float q, in float h ){\n\tq = q-clamp(q,-h,h);\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat sdPlanterLeaves(vec3 p, vec2 gp, vec2 gID, float maxBend, float strBendRnd) {\n  vec4 res = vec4(MAX_DIST, MAT_VOID);\n  float bsd = length(p + vec3(0., -.3, 0.)), bsr = 0.25;\n  if(bsd > 2. * bsr) return bsd - bsr;\n\n  vec3 cpLeafBase = p;\n  cpLeafBase += vec3(-.00125, -0.216, 0.135);\n  cpLeafBase.xz = pBend(cpLeafBase.xz, 7.36);\n  const float rep = .106;\n  float leafID = floor(cpLeafBase.x / rep);\n  leafID = mod(leafID, 8.);\n  cpLeafBase.x = mod(cpLeafBase.x, rep) - rep * .5;\n\n  float bendStrength = maxBend - hash12(gID.yx + leafID) * maxBend * strBendRnd;\n  float bendf = smoothstep(maxBend, maxBend*(1.-strBendRnd), bendStrength);\n  \n  vec3 cpLeafInner = cpLeafBase;\n  {  // winkles\n    vec3 q = cpLeafInner;\n    q.z += 0.24 * 2.;\n    vec3 sq = (q + vec3(0, -.1, 0)) * vec3(1, 1, .5);\n    q -= getTriTrans(bokoboko, sq) * .05;\n    float a = atan2(q.x, q.z);\n    float l = length(q.xz);\n    float off = gfbm(vec2(l, a * 3.), 5, .5) + gfbm(vec2(l, a * 1.5), 2, .5);\n    cpLeafInner.y += off * .2;\n    float globalOff = gfbm(gp * 7., 3, .5);\n    cpLeafInner.y += u2s(globalOff) * .025;\n    R(cpLeafInner.yz, sin(l * .5));\n  }\n  cpLeafInner.yz = pBend(cpLeafInner.yz, -2.5);\n  cpLeafInner += vec3(0, -0.2, -.115);\n  cpLeafInner = rot(cpLeafInner, vec3(0., -1.57, 0.48));\n  cpLeafInner.y-=.025*bendf;\n  pElongate(cpLeafInner.y, .02);\n  cpLeafInner.z = abs(cpLeafInner.z);\n  cpLeafInner.x -= .02;\n\n  vec3 cpLeafOuter = cpLeafBase;\n  {  // winkles\n    vec3 q = cpLeafOuter;\n    q.z += 0.24 * 2.;\n    vec3 sq = (q + vec3(0, -.1, 0)) * vec3(1, 1, .5);\n    q -= getTriTrans(bokoboko, sq) * .05;\n    float a = atan2(q.x, q.z);\n    float l = length(q.xz);\n    float off = gfbm(vec2(l, a * 3.), 5, .5) + gfbm(vec2(l, a * 1.5), 2, .5);\n    cpLeafOuter.y += off * .2;\n    float globalOff = gfbm(gp * 7., 3, .5);\n    cpLeafOuter.y += u2s(globalOff) * .025;\n    R(cpLeafOuter.yz, sin(l * .5));\n  }\n  \n  cpLeafOuter.yz = pBend(cpLeafOuter.yz, -bendStrength);\n  cpLeafOuter += vec3(0., -0.15, -0.175);\n  cpLeafOuter.y+=u2s(smoothstep(0.,.15,length(p.xz))*hash11(leafID+2.))*.0125*bendf;\n  cpLeafOuter = rot(cpLeafOuter, vec3(0., -1.57, .5));\n  cpLeafOuter.y-=.05*bendf;\n  pElongate(cpLeafOuter.y, .035+bendf*.03);\n\n  cpLeafOuter.z = pMirror(cpLeafOuter.z, .0001);\n  cpLeafOuter += vec3(-.03, .01, -.005);\n  cpLeafOuter.x = abs(cpLeafOuter.x);\n  cpLeafOuter.x += .004;\n  \n  float lw = .038;\n  float lh = .05+bendf*.01;\n  float d = sdEllipsoid(cpLeafOuter, vec3(.01, lh, lw));\n  d = min(sdEllipsoid(rot(cpLeafInner, vec3(.07, .76, -.116)), vec3(.001, .007, .01)), d);\n  d = max(-p.y + .0536, d);\n\n  return d;\n}\n\nfloat map(vec3 p){\n    vec3 cp = p;\n    //p.xz+=iTime*.25;\n    vec3 q = p;\n    //q.xz = mod(q.xz, .5)-.25;\n    \n    q.y+=.25;\n    float d = sdPlanterLeaves(q, p.xz, floor(p.xz/.5)+floor(fract(iTime*.1)*10.), 6.5, .5);\n    q.y-=.125;\n    d = min(sdCylinder(q, vec2(.153,.149)), d);\n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 370, 408, 408, 700], [802, 802, 831, 831, 1874], [1876, 1876, 1911, 1911, 2057], [2059, 2059, 2094, 2094, 2222], [2224, 2224, 2259, 2259, 2358], [2360, 2360, 2392, 2392, 2415], [2417, 2417, 2445, 2531, 2758], [2760, 2760, 2803, 2803, 2827], [2829, 2829, 2867, 2867, 2886], [2888, 2888, 2924, 2924, 2947], [2949, 2949, 3032, 3032, 5550], [5552, 5552, 5570, 5570, 5848]]}
{"id": "ssjfzG", "name": "vueltas", "author": "jorge2017a2", "description": "vueltas", "tags": ["vueltas"], "likes": 13, "viewed": 240, "published": 3, "date": "1646580591", "time_retrieved": "2024-07-30T16:59:55.900865", "image_code": "//----------image\n//por jorge2017a2----6-mar-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 MediosCirculos(vec3 p, vec2 pdist  )\n{   //vec2 res= vec2(9999.0, -1.0);\n    vec2 res=pdist;\n    int num=8;\n    \n    float nesf=6.0;\n     float ang=360.0/nesf;\n     vec3 p0=p;\n \n   for (float i=0.0; i<nesf;i++)\n    {   vec3 p3= rotate_y(p0, radians(ang*i));\n        p3-=vec3(22.0,-1.0,0.0);\n        float d3a= sdCylinderXY(p3, vec2(5.5,2.0) );\n        float d3b= sdCylinderXY(p3, vec2(3.5,2.5) );\n        d3a=differenceSDF(d3a,d3b);\n        res =opU2(res, vec2(d3a,100.0));\n        p3.y+=5.0;\n        float d2a= sdCylinderXY(p3, vec2(22.0,1.0) );\n        float d2b= sdCylinderXY(p3, vec2(18.0,1.5) );\n        d2a=differenceSDF(d2a,d2b);\n        res =opU2(res, vec2(d2a,100.0));\n    }\n  return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n   \n    res =opU2(res, vec2(planeDist1+sin(p.x*0.125+p.z*0.25),100.0));\n    p.y=p.y-5.0;\n    float d1a=sdCylinderXZ( p, vec2(20.0,5.0));\n    float d1b=sdCylinderXZ( p, vec2(18.0,5.5));\n    d1a=differenceSDF(d1a,d1b);\n    res =opU2(res, vec2(d1a,101.0));\n    vec2 res2=MediosCirculos(p,res);\n    \n    res =opU2(res, res2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1;\n    float tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    \n   for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*object.x;\n        hit = GetDist(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 color, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    float shadow = getSoftShadow(hit, normalize(lightPos)); // shadows \n    float occ = occlusion(hit, norm); //occ\n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n\n   /* if (id_color<50)\n\t\t{   colobj=getColor(int( id_color)); return colobj; } */\n   \n   if (id_color==100)\n   { return getColorTextura( p, n,100); }\n   if (id_color==101)\n   { return getColorTextura( p, n,101); }\n            \n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,hit.x)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    //else if(hit.x>MAX_DIST)\n    //col= render_sky_color(rd);\n    ///shane\n    col = mix(col, render_sky_color(rd), smoothstep(.25, .99, hit.x/MAX_DIST));\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=24.0;\n   float veltime=20.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,-1.5,25.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n   //vec3 ro=vec3(0.0,7.0+abs(8.0*sin(1.0+iTime*3.141516*0.125)),-25.0);\n   vec3 ro=vec3(0.0,7.0,-25.0);\n   //float mx=sin(ro.x*0.125+ro.z*0.25);\n   //ro.y+=mx;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    rd= rotate_y(rd, radians(60.0));\n   \n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 551, 551, 646], [647, 647, 686, 686, 781], [782, 782, 821, 821, 916], [918, 962, 1009, 1009, 1036], [1037, 1037, 1080, 1080, 1107], [1108, 1108, 1156, 1156, 1184], [1185, 1250, 1284, 1284, 1380], [1381, 1381, 1415, 1415, 1506], [1507, 1507, 1541, 1541, 1632], [1634, 1634, 1677, 1711, 2338], [2340, 2340, 2365, 2365, 2788], [2790, 2790, 2814, 2814, 2976], [2978, 2978, 3026, 3026, 3357], [3360, 3360, 3404, 3404, 3730], [3732, 3732, 3769, 3769, 4030], [4032, 4032, 4117, 4117, 5064], [5066, 5066, 5115, 5115, 5358], [5360, 5360, 5453, 5453, 5583], [5585, 5585, 5617, 5617, 5814], [5817, 5817, 5885, 5885, 6131], [6134, 6134, 6161, 6161, 6250], [6252, 6252, 6310, 6310, 6358], [6361, 6361, 6384, 6384, 6502], [6504, 6504, 6535, 6535, 7253], [7255, 7255, 7292, 7292, 7563], [7566, 7566, 7623, 7623, 8211]]}
{"id": "Ns2fzy", "name": "Kleinian Seahorse", "author": "tdhooper", "description": "Path tracing the kleinian fractal from Jos Leys & Knighty [url]https://www.shadertoy.com/view/XlVXzh[/url]\n\nI've attempted 'focus stacking' to widen the focal plane, so objects near the camera stay in focus, but allowing a large blur in the background.", "tags": ["fractal", "pathtrace", "kleinian"], "likes": 108, "viewed": 4088, "published": 3, "date": "1646573127", "time_retrieved": "2024-07-30T16:59:56.840353", "image_code": "vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int MAX_BOUNCE = 3; // Try 6 if you have the power\nconst float UNDERSTEP = .5;\nconst float BOUNCE_UNDERSTEP = 1.;\n\n//#define DEBUG\n\n#define PI 3.14159265359\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// Kleinian group distance estimator\n// Jos Leys & Knighty https://www.shadertoy.com/view/XlVXzh\n\nvec2 box_size = vec2(-0.40445, 0.34) * 2.;\n\n//sphere inversion\nbool SI=true;\nvec3 InvCenter=vec3(0,1,1);\nfloat rad=.8;\n\nvec2 wrap(vec2 x, vec2 a, vec2 s){\n    x -= s; \n    return (x - a * floor(x / a)) + s;\n}\n\nvoid TransA(inout vec3 z, inout float DF, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\tDF *= iR;//max(1.,iR);\n}\n\nvec4 JosKleinian(vec3 z)\n{\n    float t = 0.;\n\n    float KleinR = 1.5 + .39;\n    float KleinI = (.55 * 2. - 1.);\n    vec3 lz=z+vec3(1.), llz=z+vec3(-1.);\n    float d=0.; float d2=0.;\n\n    if (SI) {\n        z=z-InvCenter;\n        d=length(z);\n        d2=d*d;\n        z=(rad*rad/d2)*z+InvCenter;\n    }\n\n    vec3 orbitTrap = vec3(1e20);\n\n    float DE = 1e12;\n    float DF = 1.;\n    float a = KleinR;\n    float b = KleinI;\n    float f = sign(b) * .45;     \n    for (int i = 0; i < 80 ; i++) \n    {\n        z.x += b / a * z.y;\n        z.xz = wrap(z.xz, box_size * 2., -box_size);\n        z.x -= b / a * z.y;\n\n        //If above the separation line, rotate by 180° about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec3(-b, a, 0.) - z;}\n\n        //Apply transformation a\n        TransA(z, DF, a, b);\n\n        //If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-5) {break;}\n\n        //Store prévious iterates\n        llz=lz; lz=z;\n\n        orbitTrap = min(orbitTrap, z);\n    }\n\n    float y =  min(z.y, a - z.y);\n    DE = min(DE, min(y, .3) / max(DF, 2.));\n    if (SI) {\n        DE = DE * d2 / (rad + d * DE);\n    }\n\n    return vec4(DE, orbitTrap);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    float spec = 0.;\n    float rough = 0.;\n    vec3 col = spectrum(clamp(model.albedo.y * 2., 0., 1.)) * mix(1., 3., smoothstep(0., .4, model.albedo.y));\n    return Material(col, spec, rough);\n}\n\nModel map(vec3 p) {\n    p += vec3(-.86,1.16,1.76);\n    vec4 res = JosKleinian(p);\n    float d = res.x;\n    vec3 orbitTrap = res.yzw;\n    return Model(d, p, orbitTrap, 1);\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 sunPos = normalize(vec3(-.1,1.5,-.5)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 1.5;\n\nvec3 env(vec3 dir) {\n    vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dot(dir, normalize(vec3(.5,1.,-.5)))));\n    return col;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).d - map(p-h.xyy).d,\n                           map(p+h.yxy).d - map(p-h.yxy).d,\n                           map(p+h.yyx).d - map(p-h.yyx).d ) );\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    float rayLength;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 400; i++) {\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n        rayPosition = origin + rayDirection * rayLength;\n\n        if (model.d < .00002) break;\n\n        if (rayLength > maxDist) {\n            model.id = 0;\n            break;\n        }\n    }\n    \n    return Hit(model, rayPosition, rayLength);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., BOUNCE_UNDERSTEP);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor/10. * diffuse;\n        }\n    }\n    return col;\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    \n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    p *= .85;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 3.;\n    vec3 camPos = vec3(-.8346,-.1214,-.4026);\n    vec3 camTar = vec3(0,-.02,-.04);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(1,.45,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    float rayLength = 0.;\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n    \n    Hit hit;\n    \n    #ifdef DEBUG\n        hit = march(origin, rayDir, 30., UNDERSTEP);\n        if (hit.model.id == 0) {\n            return vec4(0);\n        } else {\n            vec3 nor = calcNormal(hit.pos);\n            //vec3 col = nor * .5 + .5;\n            vec3 col = shadeModel(hit.model, nor).albedo;\n            col *= dot(nor, normalize(vec3(0,1,-1))) * .5 + .5;\n            float fog = 1. - exp((hit.rayLength - .5) * -2.);\n            col = mix(col, vec3(0), clamp(fog, 0., 1.)); \n            return vec4(col, 1.);\n        }\n    #endif\n    \n    // Focus Stacking (with help from @Aliatraces)\n    // Do an initial march with no circle of confusion but stop at the focal plane,\n    // if we hit something, continue as normal,\n    // if we don't hit anything, add a circle of confusion to the ray direction before continuing\n\n    float focalPointDist = distance(camPos, camTar) * 1.1;\n    float focalPlaneDist = dot(camMat[2], rayDir) * focalPointDist;\n    hit = march(origin, rayDir, focalPlaneDist, UNDERSTEP);\n    if (hit.model.id == 0)\n    {\n        vec3 rayFocalPoint = origin + rayDir * focalPlaneDist;\n        origin += camMat * vec3(rndunit2(seed), 0.) * .033;\n        rayDir = normalize(rayFocalPoint - origin);\n        origin = hit.pos;\n        rayLength += hit.rayLength;\n        hit = march(origin, rayDir, 30., UNDERSTEP);\n    }\n\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = vec3(0.);\n    \n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        if (bounce > 0) {\n            hit = march(origin, rayDir, 1., BOUNCE_UNDERSTEP);\n        }\n       \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0)\n            {\n                col += env(rayDir) * throughput;\n            }\n            if (bounce == 0)\n            {\n                col = bgCol;\n            }\n            break;\n        }\n\n        rayLength += hit.rayLength;\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n        \n        // update the colorMultiplier\n        throughput *= material.albedo;\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        seed = hash22(seed);\n        col += sampleDirect(hit, nor, throughput, seed);\n        rayDir = diffuseRayDir;\n    \n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    float fog = 1. - exp((rayLength - focalPointDist) * -1.);\n    col = mix(col, bgCol, clamp(fog, 0., 1.)); \n\n    return vec4(col, 1);\n}\n\n//#define ONE_SHOT\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec4 col = draw(fragCoord, iFrame);\n\n    #ifndef ONE_SHOT\n    if (iFrame > 0) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    #endif\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 210], [212, 212, 267, 267, 453]]}
{"id": "Nd2fzy", "name": "Julia domain mapping", "author": "mrange", "description": "CC0: Julia domain mapping\n  Inspired by: https://twitter.com/matthen2/status/1498684431669907458?s=20&t=ddm5bZNo5VHHCqLvZ6XGwg\n  Very interesting idea IMHO by matthen2\n", "tags": ["julia", "domain"], "likes": 13, "viewed": 331, "published": 3, "date": "1646568745", "time_retrieved": "2024-07-30T16:59:57.831703", "image_code": "// CC0: Julia domain mapping\n//  Inspired by: https://twitter.com/matthen2/status/1498684431669907458?s=20&t=ddm5bZNo5VHHCqLvZ6XGwg\n//  Very interesting idea IMHO by matthen2\n\n// Uncomment to animate\n// #define ANIMATE\n\n#define JULIA_ITERATIONS 8\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 spiralEffect(vec2 p, float a, float n) {\n  vec2 op = p;\n  float b = a/TAU;\n  vec2 pp   = toPolar(op);\n  pp.y += PI;\n  float  aa = pp.y;\n  pp        -= vec2(pp.y*n*b, (pp.x/b+PI)/n);\n  vec2  nn  = mod2(pp, vec2(a, TAU/n));\n  // Yes, this is a trial and error:ed until it looked good \n  // because I couldn't be bothered to compute the real solution\n  float xf  = tanh_approx(20.0*length(p)/abs(n));\n  return vec2(abs(pp.x)*xf, mod(nn.y, n));\n}\n\nfloat df(vec2 p) {\n  vec2 sp = spiralEffect(p, 0.1,2.0);\n  \n  float d0 = sp.x;\n  float d1 = length(p)-2.0;\n  \n  float d = d0;\n  d = max(d, d1);\n  return d;\n}\n\nfloat julia_map(inout vec2 p, vec2 c) {\n  float s = 1.0;\n\n  for (int i = 0; i < JULIA_ITERATIONS; ++i) {\n    // Turns out this is the classic julia loop after all. \n    // Oh well :)\n    vec2 p2 = p*p;\n    p = vec2(p2.x-p2.y, 2.0*p.x*p.y);\n    p += c;\n    s *= 1.9; // Mindless fine tuning at its best\n    s *= sqrt(p2.x+p2.y);\n  }\n  \n  return 1.0/s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float aa = 2.0/RESOLUTION.y;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n#if defined(ANIMATE)\n  vec2 c = 0.85*cos(vec2(1.0, sqrt(0.5))*time);\n#else\n  vec2 c = 0.85*vec2(0.45, 0.35);\n#endif\n  \n  const float z = 1.0;\n  vec2 dp = p;\n  dp /= z;\n  float js = julia_map(dp, c); \n  float d = df(dp);\n  d *= js;\n  d -= 2.0*aa;\n  d *= z;\n  \n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(0.75), smoothstep(aa, -aa, d));\n  col = sRGB(col);  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 468, 489, 489, 562], [563, 663, 685, 685, 734], [737, 737, 759, 759, 803], [805, 805, 826, 826, 867], [869, 869, 897, 917, 993], [995, 1081, 1117, 1117, 1211], [1213, 1213, 1258, 1258, 1660], [1662, 1662, 1680, 1680, 1819], [1821, 1821, 1860, 1860, 2173], [2175, 2175, 2230, 2230, 2749]]}
{"id": "fd2fzy", "name": "foldX test", "author": "takahiroando", "description": "based on:\nhttps://gam0022.net/blog/2017/03/02/raymarching-fold/\nhttps://neort.io/product/bvcrf5s3p9f7gigeevf0", "tags": ["primitive"], "likes": 0, "viewed": 177, "published": 3, "date": "1646568277", "time_retrieved": "2024-07-30T16:59:58.582695", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p){\n    p -= vec3(2.0, 0.0, 0.0);\n    p.xy*=rot(iTime*1.);\n    p.xz*=rot(iTime*1.);\n    // This is a 2D SDF to 3D trick.\n    // 1. Calculate 2D SDF\n    float sdf2d=abs(length(p.xy)-1.)-.2;\n    // 2. Calculate 1D SDF\n    float d=abs(p.z)-.3;\n    // 3. Combie them by max(boolean)\n    return max(sdf2d,d);\n}\n\n// from: https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec3 foldX(vec3 p) {\n    // This is the trick to make a mirror\n    p.x = abs(p.x);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-5);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(foldX(p)));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 371], [373, 436, 456, 498, 534], [536, 536, 593, 593, 820]]}
{"id": "NsjfDz", "name": "spqr: artifact highway 7", "author": "spqr", "description": "Am HD animation can be found here \nhttps://youtu.be/w6Qda8QodgY\n\nMade use of Blackle's domain gating technique and fms_cat's ifs technique ", "tags": ["a"], "likes": 7, "viewed": 315, "published": 3, "date": "1646559645", "time_retrieved": "2024-07-30T16:59:59.539137", "image_code": "\n#define ANTIALIAS\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*70.0/60.0)\n\n//(time*160.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n \n  float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cyl (vec2 p, float r){\n    return length(p) - r;\n}\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n} \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\n\n/*\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n*/\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  return i + r;\n}\nfloat tock(float t){ \n    float n = atan(20.*sin(t)/atan(20.));\n    n = n*.5 + .5;\n    return n;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<8;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n/*\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n*/\nfloat runner (vec3 p) {\n    return box(p, vec3(.5));\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  float u = fract(t);\n  vec3 a = lattice(floor(t));\n  vec3 b = lattice(floor(t+1.));\n  vec3 c = lattice(floor(t+2.));\n  \n  vec3 ab = mix(a,b,u);\n  vec3 bc = mix(b,c,u);\n  \n  return mix(a,b,u);\n\n  \n}\n\nint matter = 0;\nfloat artifact(vec3 p) {\n\n  \n  \n \n\n  vec3 pt=p;\n \n\n  float width = 3.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lanesphere(vec3 p, float dim, float domain, float prob) {\n\n   \n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n\n  \n\n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.04);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n    \n    vec3 jitter = vec3(0);//flit * sin((tt*9.1+rando*12.1));\n  \n    \n    if (  rando * prob < thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        //float u = box(p + jitter, vec3(.4));\n        float u = sph(p,dim);\n        return u;\n        \n    } else {\n        //return length(p)-1.;\n        //float u = box(p + jitter, vec3(.4));\n        float u = sph(p,dim);\n       \n        return u;\n    }\n \n}\n\n\nfloat lanebox(vec3 p, vec3 dim, float domain, float prob) {\n\n   \n   \n   \n    float tt = iTime * .3;\n    \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nint material = 0;\n\n\nfloat highway(vec3 p){\n\n   \n    float tt = iTime * 0.1;\n   \n   // vec3 ap = p  + tt * 145.1 * vec3(0,0,1);\n    vec3 ap = p  + lattice( tick(tt*5.) ) * 205.1 ;\n    vec3 bp = p  + tt * 0.0 * vec3(0,0,1);\n    vec3 cp = p  + tt * 0.0 * vec3(0,0,1);\n    \n    float u = 2.;\n    \n    float a = lanebox(ap, vec3(.7)*u*1.4,       5.4*u, .98);\n    float b = lanebox(bp, vec3(.3,.3,8.)*u, 7.1*u, 1.);\n    \n    //float hole = holes(p, vec3(3), vec3(1.1));\n    float hole1 = lanebox(p, vec3(2.713), 5.1, .9);\n    float hole2 = lanebox(p, vec3(1.731), 3.1, .9);\n   \n    \n    b = max(b,-hole1);\n    b = max(b,-hole2);\n  \n    \n    float c = lanebox(cp, vec3(15,15,15.1)*u,        45.1*u, .5);\n   \n    \n \n    float final = min(a,min(b,c));\n    \n    if ( final == a) {\n        material = 1;\n    } \n    \n    if ( final == b) {\n        material = 2;\n    } \n    if (final == c) {\n        material = 3;\n    }\n    return final;\n   \n    // float a = lanebox(ap, vec3(.4)*u*1.4,       5.4*u, .4);\n   \n    //float a = lanesphere(ap, .4*u*1.4,       5.4*u, .4);\n    //float c = lanebox(cp, vec3(15,15,15.1)*u,        46.1*u, .8);\n    /*\n    //float final =  min(c,min(a,b));\n    \n    if ( final == a) {\n        material = 1;\n    }\n    if ( final == b) {\n        material = 2;\n    }\n    if ( final == c) {\n        material = 3;\n    }\n    return final;\n    */\n    \n}\n\n\nfloat beams(vec3 p) {\n    p.xy *= rot(.7);\n    p.zy *= rot(.13);\n    \n    p.xz = mod(p.xz,400.)-200.;\n    float c = cyl(p.xz,50.+sin(iTime*41.1)*.3);\n  \n    return c;\n}\n\n\nfloat glow = 0.;\nfloat map(vec3 p){\n\n     // geo\n     \n   \n    float beam = beams(p);\n    glow += .05/pow(.02+abs(beam),1.4);\n     \n    float art = artifact(p + lattice(tick(iTime/5.)) * 33.);\n    float high = highway(p);\n    \n    \n    \n    //return high;\n    float both =  max(art,high);\n    return both;\n    \n   \n   \n    \n    //return min(both,max(.1,beam));\n    \n    \n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  //vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n  // nav\n\n \n  float tt = iTime * .05;\n  \n  vec3 s = lattice(tt)*45.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  vec3 t = lattice(tt + 33.)*45.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 194. * arm;\n  t += tock(tt * 3.) * 194. * arm;\n  \n\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n \n     // fisheye\n  //cz += dot(uv,uv)/9.;\n  float fov =  1.;// + sin(tock(tick(iTime)))/2.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*fov);\n \n \n\n  \n  vec3 p=s;\n  float d = 0.;\n  float dd = 0.;\n  float edge = 0.;\n  float i = 0.;\n  vec3 n1,n2;\n  \n  bool hit = false;\n  \n  \n  // march\n  \n  for(float nn=0.;nn<200.;nn++){ \n    i =nn;\n    d=map(p);\n    d = abs(d);\n   \n    \n    if ( d < .001 ) {\n      hit = true;\n      break;\n    }\n      \n     \n    if ( dd > 300.) {\n        break;\n    }\n    p += r * d;\n    dd += d;\n    \n  }\n \n \n\n   \n \n  vec3 col;\n  \n  if (material == 1) {\n  \n    col = vec3(0);\n  }\n  if (material == 2) {\n    col = vec3(1.,.4,.2);\n  }\n  if (material == 3) {\n    col = vec3(.5);\n  }\n  \n  float ao = pow(1. - i/100.,1.4);\n  \n  col *= ao;\n  col *= 1.9;\n  \n  col += glow * 1.;\n\n  \n\n  \n  if ( material == 1) {\n  n2=norm(p, vec2(0.0, 1.0E-2) );\n  n1=norm(p, vec2(0.0, 5.50E-2) );\n  edge=saturate(length(n1-n2)/0.1);\n  col += edge*100.;\n  }\n  else {\n  n2=norm(p, vec2(0.0, 1.0E-2) );\n  n1=norm(p, vec2(0.0, 2.50E-2) );\n  edge=saturate(length(n1-n2)/0.1);\n  col -= edge*100.;\n  }\n\n\n  \n  if ( ! hit ) { \n      vec3 hue = 1. - vec3(.8,.5,.2);\n      col = mix( vec3(.5), hue, r.x);\n      col = mix(vec3(0), vec3(1.), pow(dot(r,normalize(vec3(1,0,0))*.5+.5),.8));\n \n  }\n  \n\n  \n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 245, 245, 348], [349, 349, 371, 371, 579], [581, 581, 635, 690, 914], [916, 916, 940, 940, 1137], [1141, 1141, 1170, 1170, 1235], [1236, 1236, 1278, 1278, 1385], [1386, 1386, 1414, 1414, 1442], [1443, 1443, 1466, 1466, 1574], [1576, 1576, 1600, 1600, 2147], [2149, 2149, 2171, 2171, 2379], [2381, 2381, 2406, 2406, 2439], [2441, 2441, 2463, 2463, 2581], [2586, 2586, 2615, 2615, 2644], [2645, 2645, 2666, 2666, 2713], [2714, 2714, 2733, 2733, 2802], [2805, 2805, 2830, 2830, 2870], [2875, 2875, 2889, 2889, 2929], [2932, 2932, 2968, 2968, 3021], [3045, 3045, 3069, 3069, 3124], [3127, 3127, 3151, 3151, 3237], [3238, 3238, 3265, 3265, 3362], [3365, 3447, 3469, 3469, 3558], [3559, 3559, 3579, 3579, 3657], [3659, 3659, 3698, 3698, 3775], [3778, 3778, 3808, 3808, 3834], [3837, 3837, 3875, 3875, 4163], [4166, 4166, 4189, 4189, 4302], [4303, 4303, 4324, 4324, 4723], [4725, 4725, 4747, 4747, 4952], [4954, 4954, 4981, 4981, 5007], [5009, 5009, 5037, 5037, 5068], [5069, 5291, 5314, 5314, 5345], [5347, 5347, 5375, 5375, 5408], [5412, 5412, 5433, 5433, 5482], [5483, 5483, 5503, 5503, 5552], [5553, 5553, 5573, 5573, 5952], [5953, 5953, 5978, 5978, 6447], [6450, 6450, 6470, 6470, 6654], [6656, 6656, 6679, 6679, 6878], [6896, 6896, 6920, 6920, 7472], [7513, 7532, 7555, 7555, 7670], [7672, 7672, 7735, 7735, 8688], [8691, 8691, 8750, 8750, 9206], [9228, 9228, 9250, 9250, 10565], [10568, 10568, 10589, 10589, 10736], [10756, 10756, 10774, 10787, 11111], [11113, 11113, 11160, 11160, 11373], [11377, 11377, 11403, 11403, 11528], [11531, 11531, 11551, 11551, 11670], [11682, 11682, 11739, 11800, 13806]]}
{"id": "NsjfRy", "name": "大龙猫 - Gliched but cool", "author": "totetmatt", "description": "Gliched but cool", "tags": ["glitched", "artefact"], "likes": 6, "viewed": 248, "published": 3, "date": "1646559302", "time_retrieved": "2024-07-30T17:00:00.299105", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec3 p,d=normalize(vec3(uv,1.));\n    vec3 c = vec3(0.);\n    for(float i=0.,g,e;++i<99.;){\n        \n        p = g*d;\n        p.x -=.5;;\n        vec3 op=p;\n        p.z=p.z+iTime*.1;\n        \n        vec3 id = floor(p);\n        p.z = fract(p.z)-.5;\n        \n        vec3 pp = p;\n        \n        pp.x +=sin(id.z)*.2;\n        \n        pp.y +=cos(id.z)*.2;\n        \n        float gy = abs(dot(sin(pp*5.+pp.z+iTime*.1),cos(pp.yzx*5.)))/10.;\n        \n        float gy2 = abs(dot(sin(pp*5.+pp.z),cos(pp.zxy*5.)))/10.;\n        vec2 q = vec2(length(pp.xy)-(1.5),pp.z);\n        \n        float h = length(q)-(.05);\n        \n        h = min(h,length(p.xy*rot(op.z)+vec2(gy,gy2))-(.01+sin(op.z+iTime)*.02));\n        g+=e=min(.9,max(.0001,h));\n        c+=pal(e+p.z)*.05/exp(i*i*e);\n}\n    fragColor = vec4(sqrt(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 84, 84, 130], [131, 131, 186, 186, 1060]]}
{"id": "7sSfRG", "name": "Voronoi Glass Panes", "author": "mrange", "description": "License CC0: Voronoi Glass Panes\n Tinkering with the voronoi pattern by Shane on saturday evening\n Kind of hackish overall but that never stopped me from sharing a shader before\n", "tags": ["voronoi"], "likes": 38, "viewed": 863, "published": 3, "date": "1646512521", "time_retrieved": "2024-07-30T17:00:01.687393", "image_code": "// License CC0: Voronoi Glass Panes\n//  Tinkering with the voronoi pattern from a Shane shader on saturday evening\n//  Kind of hackish overall but that never stopped me from sharing a shader before\n//  Shane shader, it's worth a look: https://www.shadertoy.com/view/Mld3Rn\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PI_2        (0.5*3.141592654)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\nconst float planeDist = 1.0-0.25;\n\nfloat g_hmul = 1.0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float zoomOuter = 1.0;\nconst float zoomInner = 0.2;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r ) {\n  const vec3 k  = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return (offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  vec3 scol = HSV2RGB(vec3(0.1, 0.25, 0.9));\n  return scol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nfloat voronoi2(vec2 p){\n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1);\n    \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n      d.z = dot(o, o); \n      d.y = max(d.x, min(d.y, d.z));\n      d.x = min(d.x, d.z); \n    }\n  }\n  \n  return max(d.y/1.2 - d.x, 0.0)/1.2;\n}\n\nfloat hf2(vec2 p) {\n  const float zo = zoomOuter;\n  const float zi = zoomInner;\n  \n  p /= zo;\n  p /= zi;\n  \n  float d = -voronoi2(p);\n  d *= zi*zo;\n  \n  float h = 0.2*tanh_approx(3.0*smoothstep(0.0, 1.0*zo*zi, -d));\n  \n  return h*zo*zi;\n}\n\nfloat height(vec2 p) {\n  return -hf2(p)*g_hmul;\n}\n\nvec3 normal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = height(p + e.yx) - height(p - e.yx);\n  n.z = -2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec4 plane(vec3 pro, vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n_, out vec3 pnor) {\n  float h0 = hash(n_);\n  float h1 = fract(7793.0*h0);\n  float h2 = fract(6337.0*h0);\n  \n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  const float s = 1.0;\n  vec3 lp1 = vec3(5.0,  1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  vec3 lp2 = vec3(-5.0, 1.0, 0.0)*vec3(s, 1.0, s)+pro;\n  const float hsz = 0.2;\n  float hd = hex(p.yx, hsz);\n\n  g_hmul = smoothstep(0.0, 0.125, (hd-hsz/2.0));\n\n  p += vec2(h0,h1)*20.0;\n  p *= mix(0.5, 1.0, h2);\n  float he  = height(p);\n  vec3  nor = normal(p,2.0*aa);\n  vec3 po   = pp;\n\n  pnor = nor;\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(nor, ld1), 0.0);\n  float diff2 = max(dot(nor, ld2), 0.0);\n  diff1 = ld1.z*nor.z;;\n\n  vec3  ref   = reflect(rd, nor);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.45, 0.05));\n  const vec3 lcol1 = HSV2RGB(vec3(0.6, 0.5, 0.9));\n  const vec3 lcol2 = HSV2RGB(vec3(0.1, 0.65, 0.9));\n  \n  float hf = smoothstep(0.0, 0.0002, -he);\n  vec3 lpow1 = 1.0*lcol1/DOT2(ld1);\n  vec3 lpow2 = 1.0*lcol2/DOT2(ld2);\n  vec3 col = vec3(0.0);\n  col += hf*mat*diff1*diff1*lpow1;\n  col += hf*mat*diff2*diff2*lpow2;\n  float spes = 20.0;\n  col += pow(ref1, spes)*lcol1;\n  col += pow(ref2, spes)*lcol2;\n\n  float t = 1.0;\n  t *= smoothstep(aa, -aa, -(hd-hsz/4.0));\n  t *= mix(1.0, 0.75, hf);\n  \n  return vec4(col, t);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 pro, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = 2.0+tanh_approx(length(0.25*p));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.98;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec3 pnor = vec3(0.0);\n      vec4 pcol = plane(pro, ro, rd, pp, off, aa, nz+float(i), pnor);\n      \n      vec3 refr = refract(rd, pnor, 1.0-0.075);\n      if (pcol.w > (1.0-cutOff)&&refr != vec3(0.0)) {\n        rd = refr;\n      }\n\n      float dz = pp.z-ro.z;\n      const float fi = -0.; \n      float fadeIn = smoothstep(planeDist*(float(furthest)+fi), planeDist*(float(fadeFrom)-fi), dz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n      pcol.w *= fadeOut*fadeIn;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float z   = 0.33*planeDist*TIME;\n  vec3 pro  = offset(z-1.0);\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z);\n  vec3 ddro = ddoffset(z);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, pro, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSfRG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[575, 675, 696, 696, 769], [770, 870, 892, 892, 941], [1095, 1095, 1117, 1117, 1263], [1617, 1617, 1645, 1665, 1741], [1743, 1803, 1843, 1843, 2002], [2004, 2064, 2104, 2104, 2146], [2148, 2208, 2230, 2230, 2278], [2280, 2280, 2300, 2300, 2414], [2416, 2510, 2539, 2539, 2726], [2728, 2728, 2750, 2750, 2882], [2884, 2884, 2907, 2907, 2985], [2987, 2987, 3011, 3011, 3091], [3093, 3093, 3126, 3126, 3273], [3275, 3275, 3298, 3298, 3617], [3619, 3619, 3638, 3638, 3857], [3859, 3859, 3881, 3881, 3908], [3910, 3910, 3942, 3942, 4140], [4142, 4142, 4236, 4236, 5613], [7322, 7322, 7351, 7351, 7682], [7684, 7684, 7739, 7739, 7958]]}
{"id": "fsBfzy", "name": "draw and fade", "author": "wonko_rt", "description": "simple drawing example with fading", "tags": ["simpledrawing"], "likes": 2, "viewed": 194, "published": 3, "date": "1646506466", "time_retrieved": "2024-07-30T17:00:02.533132", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 t = texture(iChannel0, uv).xyz;\n    fragColor = vec4(t,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nhold the left mouse button to draw\nhold a,s,d for drawing red, green or blue\nhold y to draw horizontal lines\n*/\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Y 89\nfloat keyState(int key)\n{\n    return texelFetch(iChannel1, ivec2(key,0), 0 ).x;\n}\n\nconst vec2 circle[] = vec2[](\n                                                           vec2(0., 4.), \n                             vec2(-2., 3.), vec2(-1., 3.), vec2(0., 3.), vec2(1., 3.), vec2(2., 3.), \n              vec2(-3., 2.), vec2(-2., 2.), vec2(-1., 2.), vec2(0., 2.), vec2(1., 2.), vec2(2., 2.), vec2(3., 2.), \n              vec2(-3., 1.), vec2(-2., 1.), vec2(-1., 1.), vec2(0., 1.), vec2(1., 1.), vec2(2., 1.), vec2(3., 1.), \nvec2(-4.,0.), vec2(-3., 0.), vec2(-2., 0.), vec2(-1., 0.),               vec2(1., 0.), vec2(2., 0.), vec2(3., 0.), vec2(4., 0.), \n              vec2(-3.,-1.), vec2(-2.,-1.), vec2(-1.,-1.), vec2(0.,-1.), vec2(1.,-1.), vec2(2.,-1.), vec2(3.,-1.), \n              vec2(-3.,-2.), vec2(-2.,-2.), vec2(-1.,-2.), vec2(0.,-2.), vec2(1.,-2.), vec2(2.,-2.), vec2(3.,-2.), \n                             vec2(-2.,-3.), vec2(-1.,-3.), vec2(0.,-3.), vec2(1.,-3.), vec2(2.,-3.), \n                                                           vec2(0.,-4.) \n);\n\nvec4 mixcol2(vec4 a, vec4 b)\n{\n    return vec4(mix(b.xyz, a.xyz, a.a), 1.);\n}\n\nvec4 anim2(vec2 fragCoord, float fadeFactor)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 cur = texture(iChannel0, uv);\n    \n    vec3 m = vec3(0.);\n    for (int s=0; s<circle.length(); ++s)\n    {\n        vec2 uv = (fragCoord.xy + circle[s]) / iResolution.xy;\n        vec4 col = texture(iChannel0, uv);\n        for (int i=0; i<3; ++i)\n            m[i] = max(m[i], col[i]);\n    }\n        \n    m *= fadeFactor;\n\n    return vec4(mix(cur.xyz, m, .05), cur.a);\n}\n\n\nconst float drawStrength = .2;\nconst float drawSizePoint = .05;\nconst float drawSizeLine = .01;\nconst float fadeFactor = .95;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rm = min(iResolution.x, iResolution.y);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvMouse = iMouse.xy / iResolution.xy;\n\n\n    float dist = length((fragCoord.xy - iMouse.xy) / rm) * 1.;\n    dist = smoothstep(0.,1.,dist/drawSizePoint);\n\n    vec4 cur = texture(iChannel0, uv);\n    if( iFrame==0 )\n        cur = vec4(vec3(0.),0.);\n    else\n        cur = anim2(fragCoord, fadeFactor);\n\n    vec3 drawColor = vec3(1.,1.,1.);\n    if (keyState(KEY_A) > 0.)\n        drawColor = vec3(1.,0.,0.);\n    else if (keyState(KEY_S) > 0.)\n        drawColor = vec3(0.,1.,0.);\n    else if (keyState(KEY_D) > 0.)\n        drawColor = vec3(0.,0.,1.);\n        \n    if (iMouse.z > 0.)\n    {\n        if (keyState(KEY_Y) > 0.)\n        {\n            dist = abs(fragCoord.y - iMouse.y) / iResolution.y;\n            dist = smoothstep(0.,1.,dist/drawSizeLine);\n        }\n        vec4 col = vec4(drawColor,drawStrength*(1.-dist));\n        fragColor = mixcol2(col, cur);\n    }\n    else\n        fragColor = cur;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 170]]}
{"id": "NdSfRy", "name": "Fire Gyroid", "author": "JuliaPoo", "description": "Been a while since I wrote a raytracer. This is sorta a refresher for me.\n\nI saw https://www.shadertoy.com/view/tlcXWX and wanted to play with lighting and shadows again.\n\n", "tags": ["shadows", "gyroids"], "likes": 6, "viewed": 349, "published": 3, "date": "1646497402", "time_retrieved": "2024-07-30T17:00:03.397820", "image_code": "#define EP .001\n#define SCENE_END 20.\n#define TRACE_MAX_STEPS 200\n\n#define PI 3.1415\n#define sTime iTime*.07\n\n#define SCENE_ID_DEFAULT 0\n#define SCENE_ID_OBJECT 1\n#define SCENE_ID_GROUND 2\n#define SCENE_ID_LIGHT 3\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookat;\n    float zoom;\n    float fov;\n};\n\nstruct LightBase {\n    vec3 colour;\n};\n\nstruct LightDirectional {\n    vec3 direction;\n    vec3 colour;\n};\n\nstruct LightPoint {\n    vec3 position;\n    vec3 colour;\n};\n\nLightBase clightBase = LightBase(.7*vec3(1.000,0.510,0.302));\n\nLightDirectional clightDirectional = \\\n    LightDirectional(normalize(vec3(1.)), .3*vec3(1., .2, .1));\n    \nLightPoint clightPoint = \\\n    LightPoint(vec3(0.), .9*vec3(1.8,1.2,1.));\n\nfloat cheap_cos(in float x)\n{\n    float a = mod(x,2.)-1.;\n    float b = sign(mod(x,4.)-2.);\n    a = 1.5*a - .5*a*a*a;\n    return a * b;\n}\n\nmat2 rot(in float a) {\n    float c = cheap_cos(a);\n    float s = sign(2.-mod(a,4.)) * sqrt(1.-c*c);\n    return mat2(c, -s, s, c);\n}\n\nfloat Primitive_sdGyroid(in vec3 p, in float scale, in float thickness)\n{\n    p /= scale;\n    float gyroid = dot(sin(p), cos(p.yzx));\n    return .7*scale*(abs(gyroid) - thickness);\n}\n\nfloat Primitive_sdSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat Primitive_sdBox(in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat Primitive_smoothUnion(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat Primitive_smoothIntersect(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n    \nfloat Primitive_smoothSubtract(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat Object_sdBall(in vec3 p)\n{\n    float ball = Primitive_sdSphere(p, 1.);\n    float gyroid = Primitive_sdGyroid(p, .2, .3);\n    ball = Primitive_smoothIntersect(ball, gyroid, .05);\n    ball = Primitive_smoothSubtract(Primitive_sdSphere(p, .9), ball, .05);\n    return ball;\n}\n\nfloat Scene_sdf_Object(in vec3 p)\n{\n    // Optimization\n    float dp = length(p);\n    if (dp > 1.1) {return dp - 1.;}\n    \n    float sc; vec3 _p = p;\n\n    _p.yz *= rot(sTime); _p.zx *= rot(sTime);\n    float ball = Object_sdBall(_p);\n    \n    sc = .8;\n    _p = p; \n    _p.yz *= rot(-sTime*.7 + .5); _p.zx *= rot(sTime);\n    ball = min(ball, sc*Object_sdBall(_p/sc));\n    return ball;\n}\n\nfloat Scene_sdf_Ground(in vec3 p)\n{\n    // Optimization\n    float dp = p.y;\n    if (dp > 1.2) {return dp + 1.;}\n    \n    float ground = p.y + 1.1;\n    float l = length(p.xz);\n    ground += cheap_cos(l*5. - sTime*4.) * .1*smoothstep(0.,2.,l);\n    return ground;\n}\n\nfloat Scene_sdf_Light(in vec3 p)\n{\n    p -= clightPoint.position;\n    return Primitive_sdSphere(p, .1);\n}\n\nfloat Scene_sdf(in vec3 p)\n{\n    float object = Scene_sdf_Object(p);\n    float ground = Scene_sdf_Ground(p);\n    float light = Scene_sdf_Light(p);\n    \n    float sdf = min(object, ground);\n    sdf = min(sdf, light);\n    return sdf;\n}\n\nvec3 Scene_normal(in vec3 p) {\n\tconst vec2 e = vec2(EP, 0);\n\treturn normalize(vec3(Scene_sdf(p + e.xyy)-Scene_sdf(p - e.xyy), \n                          Scene_sdf(p + e.yxy)-Scene_sdf(p - e.yxy),\t\n                          Scene_sdf(p + e.yyx)-Scene_sdf(p - e.yyx)));\n}\n\nfloat _Scene_sdf(in vec3 p, inout float d_light_min, inout float d_object_min)\n{\n    float object = Scene_sdf_Object(p);\n    float ground = Scene_sdf_Ground(p);\n    float light = Scene_sdf_Light(p);\n    \n    d_light_min = min(d_light_min, light);\n    d_object_min = min(d_object_min, object);\n    \n    float sdf = min(object, ground);\n    sdf = min(sdf, light);\n    return sdf;\n}\n\nfloat Ray_trace(inout Ray ray, out float d_light_min, out float d_object_min, out int surface_id)\n{\n    vec3 p = ray.origin;\n    vec3 d = ray.direction;\n    float dist = 0.;\n    d_light_min = SCENE_END;\n    d_object_min = SCENE_END;\n    \n    for (int i = 0; i < TRACE_MAX_STEPS; ++i) {\n        vec3 _p = p + dist*d;\n        float _d = _Scene_sdf(_p, d_light_min, d_object_min);\n        dist += _d;\n        if (_d < EP) break;\n        if (dist > SCENE_END) break;\n    }\n    ray.origin = p + dist*d;\n    \n    surface_id = SCENE_ID_DEFAULT;\n    if (Scene_sdf_Object(ray.origin) < EP) surface_id = SCENE_ID_OBJECT;\n    else if (Scene_sdf_Ground(ray.origin) < EP) surface_id = SCENE_ID_GROUND;\n    else if (Scene_sdf_Light(ray.origin) < EP) surface_id = SCENE_ID_LIGHT;\n    \n    return dist;\n}\n\nvec3 LightBase_computeLighting(in LightBase light)\n{\n    return light.colour;\n}\n\nvec3 LightDirectional_computeLighting(in LightDirectional light, in vec3 normal)\n{\n    float weight = dot(normal, light.direction);\n    return light.colour * clamp(weight, 0., 1.);\n}\n\nvec3 LightPoint_computeLighting(in LightPoint light, in vec3 position, in vec3 normal)\n{\n    float weight = dot(normal, normalize(light.position - position));\n    return light.colour * clamp(weight, 0., 1.);\n}\n\nvec3 LightPoint_computeShadow(in LightPoint light, in vec3 position, in vec3 normal)\n{\n    vec3 v = light.position - position;\n    vec3 rd = normalize(v);\n    float d_light_min, d_object_min;\n    int surface_id;\n    Ray ray = Ray(position + rd*3.*EP/dot(rd, normal), rd);\n    float dist = Ray_trace(ray, d_light_min, d_object_min, surface_id);\n    \n    // Compute soft shadows uwu\n    float w = 3. * pow(length(v) / SCENE_END, 2.);\n    float w2 = smoothstep(0., w, d_object_min);\n    return vec3(w2);\n}\n\nvec3 LightPoint_computeBleed(in LightPoint light, in vec3 position, in vec3 direction, in vec3 normal) \n{\n    float x = -dot(normal, light.position - position);\n        \n    // Compute cheap bleed\n    float w1 = .8;\n    float w2 = .7;\n    float bleed = w1 - clamp(x+(1.-w1), 0., 1.);\n    vec3 col = w2 * bleed * light.colour;\n\n    // Compute cheap subscattering\n    w1 = 1.;\n    w2 = 4.;\n    bleed = w1 - clamp(x+(1.-w1), .7, 1.);\n    col += w2 * bleed*bleed*bleed * vec3(1.,.1,.3);\n\n    // Compute glare\n    w1 = 1.;\n    w2 = 10.;\n    bleed = w1 - clamp(x+(1.-w1), 0., 1.);\n    bleed *= 1.-smoothstep(0.,1.,\n        length(\n            dot(direction, light.position - position)*direction + position-light.position\n        )\n    );\n    col += w2 * bleed*bleed*bleed * clightPoint.colour;\n    \n    return col;\n}\n\nvec3 Ray_lighting(in Ray ray)\n{\n    float t = sTime*2.;\n    clightPoint.position = vec3(0.) + \\\n        .2*vec3(cheap_cos(t*10.), cheap_cos(t*13.+5.), cheap_cos(t*17.+2.)) + \\\n        .02*vec3(cheap_cos(t*50.), cheap_cos(t*57.+5.), cheap_cos(t*47.+2.));\n    \n    float d_light_min, d_object_min;\n    int surface_id;\n    float d = Ray_trace(ray, d_light_min, d_object_min, surface_id);\n    \n    vec3 col = vec3(0);\n    \n    if (surface_id == SCENE_ID_LIGHT) {\n        col = clightPoint.colour;\n        return col;\n    }\n    else {\n    \n        vec3 normal = Scene_normal(ray.origin);\n    \n        col += LightPoint_computeLighting(clightPoint, ray.origin, normal);\n        col *= LightPoint_computeShadow(clightPoint, ray.origin, normal);\n        \n        col += LightBase_computeLighting(clightBase);\n        col += LightDirectional_computeLighting(clightDirectional, normal);\n        \n        col += LightPoint_computeBleed(clightPoint, ray.origin, ray.direction, normal); \n    }\n    \n    // Compute cheap distance fog\n    float fog = 1. - smoothstep(1., 4., d);\n    col *= fog*fog;\n    col = clamp(col, 0., 1.);\n    \n    // Compute cheap light fog\n    fog = clamp(.03/(d_light_min+.01), 0.,1.);\n    col += fog * clightPoint.colour;\n    \n    return col;\n}\n\nvoid Camera_init(inout Camera cam) \n{\n    cam.pos = vec3(0,0,-3.);\n    cam.lookat = vec3(0);\n    cam.zoom = 1.;\n    cam.fov = 1.;\n}\n\nvoid Camera_mouse(inout Camera cam)\n{\n    vec2 m = (iMouse.xy / iResolution.xy -.5 )*2.;\n    cam.pos.xz *= rot(m.x);\n    cam.pos.zy *= rot(m.y);\n    cam.pos.y = max(cam.pos.y, -1.);\n}\n\nRay Camera_projectRay(in Camera cam, in vec2 uv)\n{\n    vec3 front = normalize(cam.lookat - cam.pos);\n    vec3 screen_origin = cam.pos + front * cam.zoom;\n    vec3 vert = vec3(0,1.,0);\n    vec3 up = normalize(vert-front*dot(vert, front));\n    vec3 right = cross(front, up);\n    \n    uv *= cam.fov;\n    vec3 ro = screen_origin + uv.x * right + uv.y * up;\n    vec3 rd = normalize(ro - cam.pos);\n    return Ray(ro, rd);\n}\n\nvoid Image_postProcessing(inout vec3 col)\n{\n    // Contrast!\n    col *= col;\n    // Cinematic\n    col += 2.*vec3(.01,.05,.07);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    Camera cam; Camera_init(cam);\n    Camera_mouse(cam);\n    Ray ray = Camera_projectRay(cam, uv);\n    \n    vec3 col = Ray_lighting(ray);\n    Image_postProcessing(col);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[764, 764, 793, 793, 901], [903, 903, 925, 925, 1034], [1036, 1036, 1109, 1109, 1218], [1220, 1220, 1274, 1274, 1307], [1309, 1309, 1355, 1355, 1442], [1444, 1444, 1511, 1511, 1611], [1613, 1613, 1684, 1684, 1784], [1790, 1790, 1860, 1860, 1961], [1963, 1963, 1995, 1995, 2240], [2242, 2242, 2277, 2297, 2626], [2628, 2628, 2663, 2683, 2890], [2892, 2892, 2926, 2926, 2997], [2999, 2999, 3027, 3027, 3232], [3234, 3234, 3264, 3264, 3503], [3505, 3505, 3585, 3585, 3884], [3886, 3886, 3985, 3985, 4674], [4676, 4676, 4728, 4728, 4755], [4757, 4757, 4839, 4839, 4939], [4941, 4941, 5029, 5029, 5150], [5152, 5152, 5238, 5238, 5654], [5656, 5656, 5761, 5761, 6466], [6468, 6468, 6499, 6499, 7724], [7726, 7726, 7763, 7763, 7857], [7859, 7859, 7896, 7896, 8042], [8044, 8044, 8094, 8094, 8461], [8463, 8463, 8506, 8523, 8591], [8593, 8593, 8648, 8648, 8946]]}
{"id": "fdBfRy", "name": "Retro 3D", "author": "kosmaks", "description": "Raymarched 3D -> Edge detect -> Text -> CRT", "tags": ["raymarching", "retro", "crt"], "likes": 28, "viewed": 613, "published": 3, "date": "1646490508", "time_retrieved": "2024-07-30T17:00:04.523809", "image_code": "// Finally CRT look and distortions\n\nconst vec2 curvature = vec2(6., 6.);\nconst vec3 frame = vec3(0.);\n\nvec2 curveRemapUV(vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvec3 splitColors(vec3 source, float x) {\n    float selector = mod(x, 3.) / 3.;\n    vec3 red = vec3(source.x, 0., 0.);\n    vec3 green = vec3(0., source.y, 0.);\n    vec3 blue = vec3(0., 0., source.z);\n    vec3 zero = vec3(0.);\n    \n    if (selector < 0.33) return vec3(source.x, source.y * 0.2, 0.);\n    if (selector < 0.66) return vec3(0., source.y, 0.);\n    return vec3(0., source.y * 0.2, source.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ouv = fragCoord / iResolution.xy;\n    vec2 uv = curveRemapUV(ouv * 1.01 - 0.005);\n    \n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n        fragColor = vec4(frame, 1.);\n        return;\n    }\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    col = splitColors(col, fragCoord.x);\n    \n    float scanline = abs(sin(uv.x * 250. + iTime * 10.));\n    col *= scanline * 0.1 + 0.9;\n    \n    float vignette = 1. - distance(uv, vec2(0.5)) / 0.7;\n    vignette *= vignette;\n    col *= vignette * 0.6 + 0.4;\n    col *= 2.3;\n    \n    vec3 ro = vec3(0.5, 0.5, 0.);\n    vec3 hit = vec3(uv, 1.);\n    vec3 rd = normalize(hit - ro);\n    vec3 normal = normalize(vec3(ouv, 0.) - vec3(uv, 0.1));\n    \n    vec3 light = vec3(0.9, 0.9, 0.4);\n    vec3 ld = normalize(light - hit);\n    float diffuse = dot(normal, ld);\n    \n    vec3 h = normalize(ld - rd);\n    float specular = pow(max(0., dot(normal, h)), 200.);\n    \n    vec3 refl = reflect(rd, normal);\n    vec3 reflColor = texture(iChannel1, refl).rgb;\n    \n    col += diffuse * 0.1;\n    col += specular * 0.1;\n    col += reflColor * 0.05;\n    \n    vec2 fade2 = smoothstep(0.48, 0.5, abs(uv - 0.5));\n    float fade = max(fade2.x, fade2.y);\n    col = mix(col, frame, fade);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Here we define the scene and ray marching functions\n\n#define MAX_STEPS (100)\n#define MIN_DIST (0.0001)\n#define MAX_DIST (10.)\n\n#define MAT vec3\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n    float ah = angle / 2.;\n    vec4 q = vec4(axis.xyz * sin(ah), cos(ah));\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + 2. * cross(q.xyz, temp);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat traceScene(vec3 p, out MAT outMat) {\n    float d = MAX_DIST;\n    \n    p.x = abs(p.x);\n    \n    // body\n    float yskew = 1. - min(0.3, abs(p.y)) / 0.3;\n    yskew = yskew * 0.6 + 0.3;\n    float zskew = 1. - min(1.2, abs(p.z)) / 0.3;\n    zskew = zskew * 0.2 + 0.8;\n    if (p.z < 0.) {\n        zskew = 1.;\n    }\n    d = min(d, sdBox(p, vec3(0.2 * yskew, 0.2 * zskew, 1.2)));\n    \n    // wings\n    vec3 wp = p;\n    wp.y = abs(wp.y);\n    wp = rotate(wp, vec3(0., 0., 1.), -0.4);\n    float wxskew = 1. - min(0.9, abs(p.x)) / 0.9;\n    wxskew = 0.8 * wxskew + 0.2;\n    d = min(d, sdBox(wp - vec3(0.5, 0., -0.9), vec3(0.45, 0.01, 0.3 * wxskew)));\n    \n    // engines\n    wp = rotate(wp, vec3(1., 0., 0.), 1.57);\n    d = min(d, sdCappedCylinder(wp - vec3(0.9, 0.8, 0.), 0.07, 0.2));\n    d = min(d, sdCappedCylinder(wp - vec3(0.9, 0.3, 0.), 0.01, 0.6));\n    wp.x *= sign(p.y);\n    d = min(d, sdCappedCylinder(wp - vec3(0.25, 1.2, 0.1), 0.07, 0.3));\n    \n    // cabin\n    vec3 cp = rotate(p, vec3(1., 0., 0.), -0.1);\n    d = min(d, sdBox(cp - vec3(0., 0.13, 0.3), vec3(0.1, 0.1, 0.2)));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    MAT mat;\n    float dist = traceScene(p, mat);\n    vec2 e = vec2(MIN_DIST, 0.);\n    vec3 n = dist - vec3(\n        traceScene(p - e.xyy, mat),\n        traceScene(p - e.yxy, mat),\n        traceScene(p - e.yyx, mat));\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out MAT outMat) {\n    float totalDist = 0.;\n    MAT mat;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = traceScene(ro + rd * totalDist, mat);\n        totalDist += d;\n        if (totalDist > MAX_DIST) return MAX_DIST + 1.;\n        if (d < MIN_DIST) return totalDist;\n    }\n    \n    return MAX_DIST + 1.;\n}\n\nstruct InitialRayData {\n    vec2 fragCoord;\n    vec3 iResolution;\n    float iTime;\n};\n\nvoid setupInitialRay(in InitialRayData data, out vec3 ro, out vec3 rd) {\n    vec2 fragCoord = data.fragCoord;\n    vec2 iResolution = data.iResolution.xy;\n    float iTime = data.iTime;\n    //float iTime = floor(data.iTime / 0.05) * 0.05;\n\n    vec2 vp = vec2(\n        fragCoord.x - 0.5 * (iResolution.x - iResolution.y), \n        fragCoord.y\n    ) / iResolution.y * 2. - 1.;\n    \n    float cs = 1.2;\n    //vec3 co = vec3(1., 1., -1.);\n    vec3 co = vec3(sin(iTime), 0.8, cos(iTime));\n    vec3 ct = vec3(0., 0., -0.2);\n    \n    rd = normalize(ct - co);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), rd));\n    vec3 up = cross(rd, right);\n    ro = co + right * vp.x * cs + up * vp.y * cs;\n}", "buffer_a_code": "// This pass is used to get radiance infroamtion\n\nvec3 light(vec3 ld, vec3 lr, vec3 albedo, vec3 normal, vec3 rd) {\n    vec3 radiance = vec3(0.);\n    \n    float diffuse = max(0., dot(normal, ld));\n    radiance += albedo * lr * diffuse;\n    \n    vec3 h = normalize(ld - rd);\n    float specular = pow(max(0., dot(normal, h)), 200.);\n    radiance += albedo * lr * specular * 10.;\n    \n    return radiance;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitialRayData irData;\n    irData.fragCoord = fragCoord;\n    irData.iResolution = iResolution;\n    irData.iTime = iTime;\n    vec3 ro, rd;\n    setupInitialRay(irData, ro, rd);\n    \n    // Marching\n    vec3 radiance = vec3(0.);\n    vec3 ld = normalize(vec3(1., 1., 0.4));\n    \n    MAT material;\n    float d;\n    d = rayMarch(ro, rd, material);\n    \n    if (d < MAX_DIST) {\n        vec3 touch = ro + rd * d;\n        vec3 normal = getNormal(touch);\n        vec3 albedo = vec3(0.1);\n        \n        radiance += light(\n            normalize(vec3(1., 2., 0.4)),\n            vec3(5.),\n            albedo,\n            normal,\n            rd\n        );\n        \n        radiance += light(\n            normalize(vec3(-1., 2., -0.3)),\n            vec3(0.2),\n            albedo,\n            normal,\n            rd\n        );\n        \n        float ambient = 0.2;\n        radiance += albedo * ambient;\n    } else {\n        radiance = vec3(1000.);\n    }\n    \n    vec3 color = radiance;\n    color = color / (color + vec3(2.0));\n    color = pow(color, vec3(1.0/2.2)); \n   \n    fragColor = vec4(color, 1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "// This pass computes normals and depth info for further edge detection\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitialRayData irData;\n    irData.fragCoord = fragCoord;\n    irData.iResolution = iResolution;\n    irData.iTime = iTime;\n    vec3 ro, rd;\n    setupInitialRay(irData, ro, rd);\n    \n    MAT material;\n    float d;\n    vec3 normal;\n    d = rayMarch(ro, rd, material);\n    \n    if (d < MAX_DIST) {\n        vec3 touch = ro + rd * d;\n        normal = getNormal(touch);\n    }\n    \n    fragColor = vec4(normal, d);\n}", "buffer_b_inputs": [], "buffer_c_code": "// Here we perform edge detection\n\nvec2[] neighbours = vec2[](\n    vec2(-1., -1.),\n    vec2(-1., 1.),\n    vec2(1., -1.),\n    vec2(1., 1.)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 depthScale = 1. / iResolution.xy;\n    vec2 normScale = 1. / iResolution.xy;\n    \n    vec4 value = texture(iChannel0, uv);\n    \n    float depthDiff = 0.;\n    float normalDiff = 1.;\n            \n    for (int i = 0; i < neighbours.length(); ++i) {\n        vec2 depthUV = neighbours[i] * depthScale + uv;\n        float depthValue = texture(iChannel0, depthUV).w;\n        depthDiff = max(depthDiff, abs(depthValue - value.w));\n        \n        vec2 normUV = neighbours[i] * normScale + uv;\n        vec4 normalValue = texture(iChannel0, normUV);\n        if (normalValue.w < MAX_DIST) {\n            vec3 normal = normalValue.xyz;\n            normalDiff = round(min(normalDiff, abs(dot(normal, value.xyz))));\n        }\n    }\n    \n    depthDiff = depthDiff < 0.25 ? 0. : 1.;\n    normalDiff = 1. - normalDiff;\n    float edge = max(depthDiff, normalDiff);\n    \n\n    fragColor = vec4(vec3(edge), edge);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This pass creates text version of 3d scene\n\nconst float fontSize = 16.;\nconst float fontCell = 1. / fontSize;\n\nconst vec2[] shades = vec2[](\n    vec2(0., 13.),  //\n    vec2(7., 4.),   // .\n    vec2(10., 12.), // :\n    vec2(11., 13.), // +\n    //vec2(8., 10.),  // X\n    vec2(3., 13.)   // #\n);\n\nconst vec2 eVert = vec2(12., 8.); // |\nconst vec2 eHor = vec2(13., 13.); // -\nconst vec2 eCw = vec2(15., 13.);  // /\nconst vec2 eCcw = vec2(12., 10.); // \\\n\nconst vec2[] text = vec2[](\n    vec2(13., 11.), // M\n    vec2(15., 9.), // o\n    vec2(4., 9.), // d\n    vec2(5., 9.), // e\n    vec2(12., 9.), // l\n    vec2(0., 13.),\n    vec2(14., 9.), // n\n    vec2(15., 9.), // o\n    vec2(10., 12.), // :\n    vec2(0., 13.),\n    vec2(8., 10.), // X\n    vec2(7., 10.), // W\n    vec2(1., 12.), // 1\n    vec2(3., 12.), // 3\n    vec2(3., 12.), // 3\n    vec2(7., 12.), // 7\n    vec2(14., 13.), //.\n    vec2(0., 13.),\n    vec2(4., 15.) // []\n);\n\nvec2 valueToShadeIdx(float value) {\n    uint index = uint(floor(clamp(1. - value, 0., 0.98) * float(shades.length())));\n    return shades[index];\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.y / iResolution.x;\n    \n    // Radiance -> symbol\n    float gsize = 45.;\n    vec2 vp = fragCoord / iResolution.y;\n    vec2 gvp = floor(vp * gsize) / gsize;\n    vec2 guv = fract(vp * gsize);\n    vec2 uv = gvp * vec2(ratio, 1.);\n    float color = texture(iChannel0, uv).x;\n    vec2 fillIdx = valueToShadeIdx(color);\n    \n    // Detect edge\n    vec2 winsize = vec2(ratio, 1.) / gsize;\n    vec2 firstHit = vec2(-1., 0.);\n    vec2 secondHit = vec2(-1., 0.);\n    int res = 5;\n    float unres = 1. / float(res);\n    for (int j = 0; j < res; ++j) {\n        for (int i = 0; i < res; ++i) {\n            if (i == 1 && j == 1) continue;\n            \n            vec2 offset = vec2(float(i), float(j)) * unres;\n            vec2 ouv = uv + winsize * offset;\n            float value = texture(iChannel2, ouv).x;\n            \n            if (value > 0.) {\n                if (firstHit.x < 0.) {\n                    firstHit = offset;\n                } else {\n                    secondHit = offset;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Edge -> symbol\n    vec2 edgeIdx = vec2(-1., 0.);\n    if (firstHit.x >= 0. && secondHit.x >= 0.) {\n        vec2 dir = normalize(secondHit - firstHit);\n        if (dir.y < 0.) dir = -dir;\n        float angle = atan(dir.y, dir.x);\n        \n        if (angle > 2.15) edgeIdx = eHor;\n        else if (angle > 1.88) edgeIdx = eCcw;\n        else if (angle > 1.26) edgeIdx = eVert;\n        else if (angle > 0.63) edgeIdx = eCw;\n        else edgeIdx = eHor;\n    }\n    \n    // Symbol -> tex\n    vec2 tuv;\n    float t;\n    if (edgeIdx.x >= 0.) {\n        tuv = ((guv * 0.6 + 0.2) + edgeIdx) * fontCell;\n        t = texture(iChannel1, tuv).x;\n    } else {\n        tuv = ((guv * 0.6 + 0.2) + fillIdx) * fontCell;\n        t = texture(iChannel1, tuv).x * 0.7;\n        //t = 0.;\n    }\n    \n    \n    // Text\n    ivec2 xy = ivec2(gvp * gsize);\n    if (xy.y == 5) {\n        int i = xy.x - 5;\n        int len = mod(iTime, 0.8) < 0.4 ? text.length() : text.length() - 1;\n        if (i >= 0 && i < len) {\n            vec2 ch = text[i];\n            tuv = ((guv * 0.6 + 0.2) + ch) * fontCell;\n            t = texture(iChannel1, tuv).x * 1.5;\n        }\n    }\n    \n    fragColor = vec4(vec3(t * 0.2, t * 0.8 + 0.2, t * 0.4), 1.);\n    //fragColor = vec4(vec2(y), 0., 1.);\n    //fragColor = vec4(vec3(texture(iChannel1, fragCoord / iResolution.xy).x), 1.);\n}", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 132, 132, 298], [300, 300, 340, 340, 702], [704, 704, 759, 759, 2023]]}
{"id": "fdSBRy", "name": "Scrolling Rainbow Noise", "author": "kbx", "description": "Nothing special, just noise and the default shader mixed. I thought it looked neat", "tags": ["2d", "noise", "rainbow", "scrolling"], "likes": 1, "viewed": 274, "published": 3, "date": "1646486176", "time_retrieved": "2024-07-30T17:00:05.417420", "image_code": "float random (vec2 st) \n{\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{   \n\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 uvo = uv;\n\n    uv *= 20.;\n\n    uv.x += iTime * 10.;\n\n    vec2 xi = floor(uv);\n\n    vec3 colx = 0.5 + 0.5*cos(iTime+uvo.xyx+vec3(0,2,4));\n\n    vec3 color = vec3(random(xi));\n\n    color *= colx;\n\n    fragColor = vec4(vec3(color),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSBRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 97], [102, 102, 160, 160, 449]]}
{"id": "fsSfRG", "name": "doom melt", "author": "awr", "description": "quick and dirty replication of the loading melt effect from OG doom. nothing special.", "tags": ["effect", "doom", "loading", "melt", "pixellation"], "likes": 1, "viewed": 300, "published": 3, "date": "1646473585", "time_retrieved": "2024-07-30T17:00:06.227255", "image_code": "float basicNoise(in float x) {\n  // licensed under MIT, copyright Inigo Quilez, 2019\n  // borrowed from https://www.shadertoy.com/view/3sd3Rs\n  float i = floor(x);\n  float f = fract(x);\n  float s = sign(fract(x / 2.0) - 0.5);\n  float k = fract(i * 0.1731);\n\n  // quartic polynomial\n  return s * f * (f - 1.0) * ((16.0 * k - 4.0) * f * (f - 1.0) - 1.0);\n}\n\nbool isBounded(in vec2 uv) {\n  return all(lessThanEqual(uv,    vec2(1.0, 1.0))) &&\n         all(greaterThanEqual(uv, vec2(0.0, 0.0)));\n}\n\nvec2 melt(in vec2 uv, in float delta) {\n  // pixelation pass\n  float pxWidth = 256.0;\n  float pxX     = floor(pxWidth * uv.x) / pxWidth;\n\n  // multiple passes of noise, to avoid too much uniformity\n  float noiseCore = basicNoise(pxX * 2.1)  * 2.5;\n  float noiseA    = basicNoise(pxX * 7.0)  * 0.4;\n  float noiseB    = basicNoise(pxX * 12.2) * 0.2;\n  float noiseC    = basicNoise(pxX * 35.4) * 0.4;\n  float noiseD    = basicNoise(pxX * 94.0) * 0.6;\n\n  float sum    = noiseCore * (noiseA + noiseB + noiseC + noiseD);\n  float offset = clamp(abs(sum) * delta, 0.0, 1.0) + delta;\n\n  return vec2(uv.x, uv.y + offset);\n}\n\nfloat delta(in float time) {\n  float wait         = 2.0;\n  float acceleration = 1.15;\n  return max(time - wait, 0.0) * acceleration;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv     = fragCoord / iResolution.xy;\n  vec2 melted = melt(uv, delta(iTime));\n\n  if (isBounded(melted)) {\n      fragColor = texture(iChannel0, melted);\n  } else {\n      fragColor = texture(iChannel1, uv); // layer underneath\n  }\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 141, 354], [356, 356, 384, 384, 492], [494, 494, 533, 554, 1107], [1109, 1109, 1137, 1137, 1243], [1245, 1245, 1300, 1300, 1537]]}
{"id": "7djBDm", "name": "Morphing fractal trees", "author": "jarble", "description": "Some morphing tree-like patterns.", "tags": ["fractal", "tree"], "likes": 9, "viewed": 412, "published": 3, "date": "1646458912", "time_retrieved": "2024-07-30T17:00:06.985228", "image_code": "//change these constants to get different patterns!\n#define c1 vec3(1.,0.5,1.5)\n\nfloat triangle_wave(float a){\n    return abs(fract(a)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n    //return abs(fract((a+c1.xy)*scale+iTime/500.)-.5); //morphing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    //float offset1 = iTime/1000.;\n    vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);   \n        for(int k = 0; k < 60; k++){\n        //float scale = scale + col.x/8.;\n        //float scale = scale-col.x/16.;\n            //float scale = scale + col.x/16.;\n\n            //uv /= -scale-col.x;\n            \n            //uv -= offset + (t2.yx)/(1.+(col.x+col.y+col.z)/3.);\n            uv -= offset - (t2.yx);\n\n            //uv += iTime/1000.-(t2.yx)/(scale);\n\n            \n            //uv -= (t2.yx)/(scale+t3);\n            //uv -= (t2.yx)/(scale+col.x);\n            t2 = triangle_wave(uv.yx+.5,scale);\n            //t2 = triangle_wave(uv.yx+.5+float(i),scale);\n            \n            t3 = triangle_wave(uv,scale);\n            \n            uv.yx = (t3-t2);\n            //offset += offset1;\n            //offset += iTime/400.+ col.x/(scale-col.x);\n        col.x = 1.-abs(uv.y+uv.x+col.x);\n        col = col.yzx;\n        \n        \n        uv /= 4.5-(triangle_wave(uv.x+uv.y+iTime/4.));\n        //uv /= (t2.y-t2.x+1.);\n      }\n    fragColor = vec4(col,1.0);   \n}\n", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    //t = (t*(t>>12)|(t>>6)|t/4|t/1024);\n    //t = t*(((t)>>(12))|(t>>(4))|t/(4)|t/1024);\n    //t = (t*(t>>(12+t>>12))|(t>>(6))|t/(4+t>>4)|t/(6+t>>6)|t/1024);\n    t = (t*(t>>(12+t/12>>(12)))|(t>>(5))|t>>6|t/(4-t>>4)|t/(6+t>>(6))|t/1024);\n\n\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\n\nvec2 mainSound( in int samp,float time){\n    time *= 5000.0/8.;\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 2.0;\n    }\n    return result/25.;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 110, 110, 208], [210, 210, 249, 249, 361], [363, 363, 420, 420, 1691]]}
{"id": "7sjfWm", "name": "Asteroid generator", "author": "pancakespeople", "description": "I made this shader so I could get some asteroid sprites for my game because I'm better at writing shaders than doing art lol. Click somewhere on the screen to generate a new asteroid. On firefox you can right click and select \"Take Screenshot\" to screensh", "tags": ["procedural", "asteroid", "generation"], "likes": 12, "viewed": 496, "published": 3, "date": "1646453626", "time_retrieved": "2024-07-30T17:00:07.741207", "image_code": "// Noise functions from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + iMouse.x+0.1) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat sdf(vec3 point) {\n    float radius = fbm(point*2.0)-fbm((point+300.0)*50.0)/50.0;\n    float asteroid = length(point-vec3(0.0, 1.0, -1.0))-radius;\n    \n    return asteroid;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distMarched = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = sdf(rayOrigin);\n        \n        rayOrigin += rayDir * dist;\n        distMarched += dist;\n        \n        if (dist < 0.0001 || dist > 100.0) {\n            break;\n        }\n    }\n    \n    return distMarched;\n}\n\nvec3 getNormal(vec3 point) {\n    float dist = sdf(point);\n    vec3 norm = dist - vec3(\n        sdf(point - vec3(0.01, 0.0, 0.0)),\n        sdf(point - vec3(0.0, 0.01, 0.0)),\n        sdf(point - vec3(0.0, 0.0, 0.01))\n    );\n    return normalize(norm);\n}\n\nfloat getShadow(vec3 rayOrigin, vec3 lightDir) {\n    float distMarched = 0.0;\n    float shadow = 1.0;\n    \n    for (float i = 0.0; i < 100.0; i++) {\n        float dist = sdf(rayOrigin);\n        \n        rayOrigin += lightDir * dist;\n        distMarched += dist;\n        shadow = min(shadow, 32.0*dist/i);\n        \n        if (dist < 0.0001 || dist > 100.0) {\n            break;\n        }\n    }\n    \n    return max(shadow, 0.33);\n}\n\nfloat getLight(vec3 point, vec3 cameraPos) {\n    vec3 normal = getNormal(point);\n    vec3 lightDir = normalize(vec3(cos(iMouse.x), sin(iMouse.y), 0.0));\n    float light = getShadow(point+0.02*normal, lightDir);\n    \n    return clamp(dot(normal, lightDir) * light, 0.1, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    vec3 cameraPos = vec3(0.0, 1.0, -4.0);\n    vec3 rayDir = vec3(uv.x, uv.y, 1.0);\n\n    float dist = rayMarch(cameraPos, rayDir);\n    vec3 point = rayDir * dist + cameraPos;\n    \n    vec3 col = vec3(0.0);\n    \n    if (dist < 100.0) {\n        col = vec3(getLight(point, cameraPos));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 112, 112, 157], [158, 158, 178, 178, 223], [224, 224, 242, 242, 290], [292, 292, 312, 312, 803], [805, 805, 824, 824, 984], [986, 986, 1009, 1009, 1165], [1167, 1167, 1212, 1212, 1513], [1515, 1515, 1543, 1543, 1766], [1768, 1768, 1816, 1816, 2198], [2200, 2200, 2244, 2244, 2476], [2478, 2478, 2535, 2535, 2927]]}
{"id": "7d2BWm", "name": "Chez", "author": "El_Sargo", "description": "Using reflections to create fractals", "tags": ["3d", "raymarching", "fractal"], "likes": 13, "viewed": 385, "published": 3, "date": "1646451038", "time_retrieved": "2024-07-30T17:00:08.538076", "image_code": "//Heavy performance impact \n#define AA 1\n#define raymarchSteps 40\n#define vanillaMarch\n#define rotationSpeed 7.\n#define ZERO min(iFrame, 0)\n#define post\n#define vignet\n\nconst float pi = 3.14159265359;\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n// Base primitive\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//The main part\nvec4 map(vec3 p) {\n    mat3 rot = rotx(sin (2. * iTime*0.1)*pi + sin(pi * iTime*0.1)*pi)*rotz(cos(iTime/4.)*pi)*roty(sin(iTime/4.+12313.123)*pi);\n    int maxI = 8;\n    float scale = 1.;\n    const float factor = 2.;\n    const float baseSize = .7;\n    float d = 10e10;\n    for (int i=ZERO;i<maxI;i++){ \n        p = abs(p)-.4*factor;\n        p *= factor;\n        scale /= factor;\n        p *= rot;\n\n    }\n            d = min(d,\n             sdBox(p-vec3(0,.44*factor,0), (vec3(baseSize)))*scale-(0.4*scale)\n             );\n    return vec4(d,p);\n}\n#ifndef vanillaMarch \n//https://www.shadertoy.com/view/wlVGRV\nvec3 intersection(vec3 ro, vec3 rd){\n    \n    //Boring variables\n    vec3 pos = ro;\n    float T = 0.; \n    float h = map(pos).x;\n\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<raymarchSteps; ++i) {\n    \n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = map(p).x;\n        \n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n    return ro+T*rd;;\n}\n#else\nfloat intersection(vec3 ro, vec3 rd){\n    float T = 0.;\n    for(int i=0;i < raymarchSteps;i++){\n        float dist = map(ro+rd*T).x;\n        T += dist;\n    \n        if(dist <0.01 || dist > 4.)\n            break;\n    }\n    return T;\n}\n#endif\n//iq ---\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p, float t ){\n    float h = 0.002*t;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n// ---\nvec4 render(vec3 ro, vec3 rd){\n    //world info\n    float d = intersection(ro,rd);\n    vec3 pos = ro+rd*d;\n    vec4 d_t = map(pos);\n    vec3 trp = d_t.yzw;\n   float dis = d_t.x;\n   float trd = distance(pos, trp);\n    //Shading\n     vec3 sun = vec3(1., 1., 1.1);\n    float sha = softshadow(pos, sun, 0.1, 5., 1.)*0.5+0.5;\n     vec3 nor = calcNormal(pos, d);\n    float occ = calcAO(pos, nor);\n    float lig = (dot(sun,nor)*0.5+0.5);\n\n    //Colors\n    vec3 col = vec3(0);\n    vec3 bcl = vec3(log(trd),0.5,cos(trd));\n    vec3 scl = vec3(1., 0.8 ,.7);\n    vec3 amb = vec3(0.7, 0.9, 1.);\n    //\n    if (dis < 0.1) {\n        //Bones\n        col += 0.75*lig*sha*scl*bcl;\n        col += 0.6*amb*occ;\n    } else\n        col = vec3(.7-0.5*abs(rd.y))*scl;\n    return vec4(col, 1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -5.5);\n    mat3 yrot = roty(iTime*0.2);\n    mat3 xrot = rotx(.9);\n           ro*=xrot*yrot;\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n\n    \n    #ifdef vignet\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    tot *= smoothstep(1.34, 0., length(uv));\n    #endif\n    \n    // Output to screen\n    #ifdef post\n    fragColor = smoothstep(0.,1.3,tot);\n    #else\n    fragColor = tot;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 221, 221, 348], [349, 349, 369, 369, 496], [497, 497, 517, 517, 644], [646, 664, 695, 695, 786], [788, 804, 822, 822, 1347], [2718, 2727, 2803, 2803, 3018], [3019, 3019, 3057, 3057, 3277], [3278, 3278, 3311, 3311, 3572], [3573, 3580, 3610, 3627, 4350], [4351, 4351, 4408, 4408, 5148]]}
{"id": "NsjfWm", "name": "MeetInTheMiddle", "author": "deerfeeder", "description": "basic", "tags": ["basic"], "likes": 0, "viewed": 164, "published": 3, "date": "1646435245", "time_retrieved": "2024-07-30T17:00:09.288072", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //uv=abs(uv);\n    \n    // Time varying pixel color\n    float a = sin(iTime+uv.x*uv.y*40.)* 1.;\n    float b= cos(a);\n    float c = min(a,b);\n    vec3 col = vec3(c,asin(c),tanh(c));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 411]]}
{"id": "fsjBWm", "name": "2X AA Downsampling filter", "author": "bartwronski", "description": "Demo of a sharp, anti-aliasing 2x downsampling filter (alternative to bilinear/box downsampling).\n64-tap high quality filter approximated with 8 bilinear taps.\n\nRed = bilinear / box downsample filter.\nGreen = optimized, anti-aliasing downsample AA filter.", "tags": ["antialiasing", "aa", "signalprocessing", "downsampling"], "likes": 19, "viewed": 3717, "published": 3, "date": "1646431248", "time_retrieved": "2024-07-30T17:00:10.040060", "image_code": "// License: MIT / CC-BY, author: Bartlomiej Wronski.\n//\n// Demo of a high quality 2x downsampling filter (alternative to bilinear / box downsampling).\n// Red = bilinear / box downsample filter.\n// Green = optimized, anti-aliasing downsample AA filter.\n// It not only produces less aliasing under motion, but  also \"sharper\" in non-aliased frequencies. \n// I highly recommend this type of filters for post-processing in rendering and image processing\n// pyramid creation.\n//\n// It follows the common GPU even filter centered convention, see:\n// https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/\n// \n// Proposed filter is optimized for three factors:\n// - Anti-aliasing capabilities - removing anything above the new Nyquist close to a \n//   perfect lowpass.\n// - Sharper response than bilinear - making sure that anything below the new Nyquist \n//   stays as close to unity response as possible.\n// - Runtime performance. We approximate 64 tap filter with just 8 bilinear taps!\n// Note that if some certain properties are more desired than the other ones (like AA could\n// be more desired than sharpness), it is possible to create a slightly different filter with\n// the same procedure.\n//\n// Procedure to get it was multi-step, though straightforward:\n// 1. Started with a perfect (in the least squares) 2D even 8x8, 64 tap downsampling filter. \n// 2. Remove small magnitude, corner taps. This step was done\n//    by \"eyeballing\" which ones have a small magnitude and to make sure the remaining ones\n//    can be grouped in 2x2 SAME SIGN samples.\n// 3. Re-optimize the filter for frequency response. Note that zeroing coefficients - \n//   \"truncation\" is different than a least-squares minimal response with the same positions of\n//    samples.\n// 4. Combine those groups of 2x2, 4 samples into single bilinear ones, optimizing tap offset.\n//    This step could be also done with non-linear least squares optimization, but the bilinear\n//    approximation was so close to original sample weights that I ignored it.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCoordOrig = fragCoord;\n    // Enlarge pixels to make it visible on high resolution displays.\n    fragCoord = round((fragCoord - 0.5)* 0.2) + 0.5;\n    // 2X downsampling.\n    vec2 uv = 2.0*(fragCoord+0.5)/iChannelResolution[0].xy;\n    \n    // Simple bilinear / box 2X downsampling.\n    vec3 colOrig = texture(iChannel0, uv).xyz;\n    \n    // Debug \"red\" color indicator.\n    colOrig = fragCoordOrig.x < 50.0 && fragCoordOrig.y < 50.0 ? vec3(1.0, 0.0, 0.0) : colOrig;\n\n    // Proposed optimized lowpass 2X downsampling filter.\n    vec3 col = vec3(0.0);\n    col += 0.37487566 * texture(iChannel0, uv + vec2(-0.75777156,-0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(0.75777156,-0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(0.75777156,0.75777156)/iChannelResolution[0].xy).xyz;\n    col += 0.37487566 * texture(iChannel0, uv + vec2(-0.75777156,0.75777156)/iChannelResolution[0].xy).xyz;\n    \n    col += -0.12487566 * texture(iChannel0, uv + vec2(-2.90709914,0.0)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(2.90709914,0.0)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(0.0,-2.90709914)/iChannelResolution[0].xy).xyz;\n    col += -0.12487566 * texture(iChannel0, uv + vec2(0.0,2.90709914)/iChannelResolution[0].xy).xyz;    \n    \n    // Debug \"green\" color indicator.\n    col = fragCoordOrig.x < 50.0 && fragCoordOrig.y < 50.0 ? vec3(0.0, 1.0, 0.0) : col;\n    \n    // Animate between two filtering modes with more time spent on extremes.\n    float anim = sin(0.5*iTime);\n    anim = pow(abs(anim), 0.33)*sign(anim);\n    fragColor = vec4(mix(col, colOrig, anim * 0.5 + 0.5),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Move the source image in an oscillating fashion and pick some interesting crop.\n    fragCoord += round(5.0*vec2(sin(iTime*3.0),cos(iTime*2.0)));\n    fragCoord += vec2(0,50);\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    \n    vec3 colOrig = texture(iChannel0, uv).xyz;\n    fragColor = vec4(colOrig,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjBWm.jpg", "access": "api", "license": "mit", "functions": [[2066, 2066, 2123, 2123, 3888]]}
{"id": "sd2BWh", "name": "sea of balls: fake 3D", "author": "FabriceNeyret2", "description": "No ray-marching, no 3D.\nWorley/Voronoi seed-per-cell + Jacobian for back to screenspace.\nTODO:  adaptive neighborhood for grazing angles.  try other shape.\nMouse controls camera.", "tags": ["voronoi", "worley", "short", "loopless"], "likes": 28, "viewed": 429, "published": 3, "date": "1646430801", "time_retrieved": "2024-07-30T17:00:10.812994", "image_code": "// utils from https://www.shadertoy.com/view/llySRh\n//#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define rot(a)   mat2(cos(a+1.57*vec4(0,-1,1,0)))                        // rotation\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n\nvoid mainImage(out vec4 O, vec2 u)    // --- renderer\n{\n    float t=9.; \n    vec3  R = iResolution, N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3((u+u-R.xy)/R.y, -2.)),   // ray direction\n          p = vec3(0,0,15), q,                        // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0),\n          X = vec3(1,0,0), Y = vec3(0,0,1), U;\n\n    X.yz *= rot(.5-6.3*M.y),                          // quad rotation\n    X.xz *= rot(-6.3*M.x),\n    Y.yz *= rot(.5-6.3*M.y),                      \n    Y.xz *= rot(-6.3*M.x);\n    U =  inverse(mat3(X,Y,D)) * p;                    // solve plane intersection: (u,v,lambda).\n    q = p + U.z*D;                                    // 3D hit point \n    O-=O;\n    if (abs(U.x)>5. || abs(U.y)>8. || U.z>0. ) return;\n    mat2 J = inverse( mat2(dFdx(U.xy),dFdy(U.xy)) *R.y/U.z); // Jacobian but keep perspective scaling\n    vec2 Jz = vec2(dFdx(U.z),dFdy(U.z)); float z,zl=1e9;\n    vec2 I = floor(U.xy), F = fract(U.xy), o,_I,u0; // --- get closest object on the quad\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )                        // find closest seed within neihbors\n        o = vec2(k%3,k/3) -1.,                        // offset to cur neighbor cell\n        u = J* ( o + H(I+o) - F ),                    // offset to seed + back to screen space\n        d = length( u ),                              // screen-space closest (and thus, sphere SDF )\n        z = dot(u,Jz), z < zl && d<.3 ? zl=z, l = d, u0=u, _I = I+o : I; \n     // z = dot(u,Jz), z < zl ? zl=z, u0=u,l=d,  O =  mix(O,hue(H(I+o).x),smoothstep( 1.5,0., (l- .3)/fwidth(l) )) : O; return;\n     // O = d < .4 ? mix(O, hue(H(I+o).x), smoothstep( 1.5,0., (d- .3)/fwidth(d) ) ) : O; return;\n     // d < l ? l = d, u0=u, _I = I+o : I;            // keep closest dist + its id.\n    if (l<9.) O =  smoothstep( 1.5,0., (l- .3)/fwidth(l) )  // draw sphere\n                 * hue(H(_I).x);                            // coloring from ID\n    u = u0/.3;\n    float b = asin(u.y), a = acos( u.x/cos(b) );      // sphere coordinates\n    p = vec3(cos(b)*cos(a), cos(b)*sin(a), sin(b));\n    O *= .2+.8*max(0.,dot(p,vec3(.58)));              // ball shading (as is, could be alot simpler )\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2BWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 423, 423, 2640]]}
{"id": "fd2fDw", "name": "reflection changes n4", "author": "jorge2017a2", "description": "reflection changes n4", "tags": ["reflectionchangesn4"], "likes": 9, "viewed": 239, "published": 3, "date": "1646428286", "time_retrieved": "2024-07-30T17:00:11.568973", "image_code": "//cambios por jorge flores p.---->jorge2017a2\n//23-feb-2022\n///referencia y fork\n//https://www.shadertoy.com/view/MtlfRs.....by zackpudil in 2017-12-11\n//---------image------\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n#define PI 3.1415926535\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 GetDist(vec3 p  )\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,67.0,7.0)); //inf\n    res =opU3(res, vec3(planeDist2,67.0,-1.0)); \n    res =opU3(res, vec3(planeDist3,66.0,-1.0)); \n    res =opU3(res, vec3(planeDist4,66.0,-1.0)); \n    res =opU3(res, vec3(planeDist5,65.0,-1.0)); \n    res =opU3(res, vec3(planeDist6,65.0,-1.0));\n          p.y=p.y-5.0;\n   \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,5.0), 6.0 );\n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    res =opU3(res, vec3(sdsp2,201.0,-1)); \n    return vec2(res.x, res.y);\n   \n}\n\n// basic trace, with some LOD\nvec2 RayMarch(vec3 ro, vec3 rd, float m) {\n    float t;\n\tvec2 d = vec2(9999.0,-1.0);\n    \n\tfor(int i = 0; i < 200; i++) {\n\t\td = GetDist(ro + rd*t);\n\t\tif(d.x < (0.001 + 0.0001*t) || t >= m) break;\n        t += d.x*0.67;\n\t}\n\treturn vec2(t,d.y);\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p,vec3 lp,vec3 rd, vec3 ro, vec3 color )\n{   vec3 lightPos=lp;\n    vec3 hit=p;\n    vec3 norm=normal;\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = ambOcclusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}  \n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\n\nvec3 figura001(vec2 p)\n{\n    p.x= opRep1D(p.x, 4.0 );\n    p.y= opRep1D(p.y, 3.0 );\n    \n    float d1a= sdBox( p, vec2(2.0,1.5) );\n    float d1b= sdBox( p, vec2(1.9,1.4) );\n    d1b= differenceSDF(d1a, d1b);\n    \n    float d2= sdRhombus(p, vec2(1.0,0.8));\n    float d3= sdBox( p, vec2(2.0,0.05) );\n    float d4= sdBox( p, vec2(0.05,1.5) );\n    vec3 col;\n    \n    col= DrawFigBorde(vec3(1.0), col, d1a);\n    col= DrawFigBorde(vec3(0.0), col, d1b);\n    col=DrawFigBorde(vec3(0.0), col,d3);\n    col=DrawFigBorde(vec3(0.0), col,d4);\n    col= DrawFigBorde(vec3(0.5), col, d2 );\n    \n    return col;\n}\n\nvec3 figura002(vec2 p)\n{\n    p.x= opRep1D(p.x, 4.0 );\n    p.y= opRep1D(p.y, 3.0 );\n    \n    float d1a= sdBox( p, vec2(2.0,1.5) );\n    float d1b= sdBox( p, vec2(1.9,1.4) );\n    d1b= differenceSDF(d1a, d1b);\n    \n    float d2= sdRhombus(p, vec2(1.0,0.8));\n    float d3= sdBox( p, vec2(2.0,0.05) );\n    float d4= sdBox( p, vec2(0.05,1.5) );\n    \n    vec3 col;\n    col=DrawFigSolo(vec3(0.0), col, d1a);\n    col=DrawFigSolo(vec3(1.0), col, d1b);\n    col=DrawFigSolo(vec3(1.0), col,d3);\n    col=DrawFigSolo(vec3(1.0), col,d4);\n    col=DrawFigSolo(vec3(1.0), col, d2 );\n    \n    return col;\n}\n\n\nvec3 GetColor(vec3 p, float id_color)\n{  vec3 color; \n   if(id_color<50.0)\n   { color=getColor(int(id_color)); }  \n        \n   if(id_color==57.0)\n   { color =vec3(1.0)*( 0.2 + 0.5*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0));}\n   \n   \n   if (id_color==64.0)\n   {   \n       color = figura001(p.xz*0.25+vec2(1.0,0.0)); }\n   \n   if (id_color==65.0)\n   { \n   p.xy-=vec2(0.0,5.5);\n   color = figura001(p.xy*0.25+vec2(-2.,0.0)); }\n   \n   if (id_color==66.0)\n   { \n       p.zy-=vec2(0.0,5.5);  \n       color = figura001(p.zy*0.25); }\n   \n   if (id_color==67.)\n   { color = figura002(p.xz*0.25+vec2(0.0,0.5)); }\n   \n   return color;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig1 = normalize(vec3(10.8, 10.0, -15.6));\n    vec3 lig2 = normalize(vec3(0.0, 60., 25.6));\n    vec2 t;\n    vec3 rcol = vec3(0);\n    \n    \tfor(int i = 0; i < 3; i++) {\n\t\t t = RayMarch(ro, rd, MAX_DIST);\n\t\tif(t.x < MAX_DIST) \n        {   // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t.x;\n\t\t\tvec3 nor = GetNormal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n              vec3 color= GetColor(pos,t.y);\n            rcol= lightingv3(nor,pos,lig1,rd, ro, color );\n            rcol+= lightingv3(nor,pos,lig2,rd, ro, color );\n            rcol/=2.0;\n            \n            // set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor*0.001;\n            if (t.y>70.0)\n\t\t\trd = ref;\n            // sky fog.\n\t\t\t///rcol = mix(rcol, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.00715*t.x));\n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0)\n               col = rcol;\n\t\t\telse\n               col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t\t}\n        else if(t.x>MAX_DIST)\n        col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n    \n\t}\n    return col;\n}\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,10.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.0,8.0,-15.0);\n    vec3 rd=normalize(vec3(p,1.0));\n   \n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    vec3 col= render(ro, rd);\n \tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "struct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 376, 376, 397], [398, 398, 430, 430, 514], [515, 515, 561, 561, 648], [651, 676, 710, 710, 806], [807, 807, 841, 841, 932], [933, 933, 967, 967, 1058], [1060, 1060, 1094, 1094, 1189], [1191, 1191, 1215, 1215, 2667], [2669, 2699, 2741, 2741, 2943], [2945, 2945, 2969, 2969, 3132], [3134, 3134, 3178, 3178, 3495], [3497, 3497, 3537, 3537, 3794], [3796, 3817, 3847, 3847, 3980], [3982, 3982, 4014, 4014, 4211], [4213, 4213, 4288, 4288, 5246], [5249, 5249, 5297, 5297, 5325], [5328, 5328, 5364, 5364, 5409], [5414, 5414, 5451, 5451, 5525], [5528, 5528, 5553, 5553, 5572], [5573, 5573, 5598, 5598, 5617], [5618, 5618, 5654, 5654, 5682], [5684, 5684, 5726, 5726, 5907], [6072, 6072, 6134, 6134, 6264], [6265, 6265, 6327, 6327, 6392], [6396, 6396, 6420, 6420, 6989], [6991, 6991, 7015, 7015, 7576], [7579, 7579, 7618, 7618, 8205], [8207, 8207, 8239, 8239, 9381], [9384, 9384, 9411, 9411, 9500], [9502, 9502, 9560, 9560, 9608], [9611, 9611, 9634, 9634, 9752], [9754, 9754, 9791, 9791, 10061], [10063, 10063, 10121, 10121, 10454]]}
{"id": "NsjfDw", "name": "false fire test-3d", "author": "jorge2017a2", "description": "false fire test", "tags": ["falsefiretest"], "likes": 6, "viewed": 206, "published": 3, "date": "1646428269", "time_retrieved": "2024-07-30T17:00:12.335922", "image_code": "//cambios por jorge flores p.---->jorge2017a2\n//23-feb-2022\n//----falta depurar\n\n//---------image------\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n#define PI 3.1415926535\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 GetDist(vec3 p , bool opcbln )\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n    \n   if(opcbln==true)\n   {\n   float d1= sdBox(p-vec3(0.0,5.0,0.0), vec3(10.0,6.0,0.5) );\n   res =opU3(res, vec3(d1,68.0,-1.0));\n   }    \n   else\n    {\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,57.0,7.0)); //inf\n    //res =opU3(res, vec3(planeDist1,67.0,7.0)); //inf\n    /*\n    res =opU3(res, vec3(planeDist2,14.0,-1)); \n    res =opU3(res, vec3(planeDist3,2.0,-1.0)); \n    res =opU3(res, vec3(planeDist4,3.0,-1.0)); \n    res =opU3(res, vec3(planeDist5,4.0,-1.0)); \n    res =opU3(res, vec3(planeDist6,5.0,-1.0)); \n   \n   */\n   /* \n    res =opU3(res, vec3(planeDist2,67.0,-1.0)); \n    res =opU3(res, vec3(planeDist3,66.0,-1.0)); \n    res =opU3(res, vec3(planeDist4,66.0,-1.0)); \n    res =opU3(res, vec3(planeDist5,65.0,-1.0)); \n    res =opU3(res, vec3(planeDist6,65.0,-1.0));\n    */\n    \n   p.y=p.y-5.0;\n   }\n   \n   \n    return vec2(res.x, res.y);\n   \n}\n\n// basic trace, with some LOD\nvec2 RayMarch(vec3 ro, vec3 rd, float m, bool opcbln) {\n    float t;\n\tvec2 d = vec2(9999.0,-1.0);\n    \n\tfor(int i = 0; i < 200; i++) {\n\t\td = GetDist(ro + rd*t, opcbln);\n\t\tif(d.x < (0.001 + 0.0001*t) || t >= m) break;\n        t += d.x*0.67;\n\t}\n\treturn vec2(t,d.y);\n}\n\nvec3 GetNormal(vec3 p)\n{   \n    bool opcbln=false;\n    float d = GetDist(p, opcbln).x;\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy,opcbln).x,GetDist(p-e.yxy,opcbln).x,GetDist(p-e.yyx,opcbln).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{   float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    bool opcbln=false;\n    \n    for (int i = 0; i < 15; i++) {\n        float hit = GetDist(p + lightPos * dist,opcbln).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ambOcclusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;\n        float dd = GetDist(nor * hr + pos,false).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );\n}\n\n//euclidean cameras.\nmat3 camera(vec3 o, vec3 l) \n{\tvec3 w = normalize(l - o);\n\tvec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = normalize(cross(w, u));\t\n\treturn mat3(u, v, w);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p,vec3 lp,vec3 rd, vec3 ro, vec3 color )\n{   vec3 lightPos=lp;\n    vec3 hit=p;\n    vec3 norm=normal;\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    vec3 R = reflect(-light, norm);\n    vec3 V = -rd;\n    \n    // shadows\n    float shadow = getSoftShadow(hit, normalize(lightPos));\n    // occ\n    float occ = ambOcclusion(hit, norm);\n    \n    vec3 ambient= 0.5*color*clamp(0.5 + 0.5*norm.y, 0.0, 1.0);\n    vec3 fresnel =  color *  pow(clamp(1.0 + dot(rd, norm), 0.0, 1.0), 2.0);;\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    vec3 diffuse =  color * dif;\n    \n    float specular = pow(max(dot(R, V), 0.), 8.);\n     // back\n    vec3 back = 0.5 * color * clamp(dot(norm, -light), 0.0, 1.0);\n       vec3 colOut = occ*color*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n   return colOut;\n}\n\n\nvec3 Sinusfire( in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy -.2*iResolution.xy )/iResolution.y;\n    //vec2 uv=fragCoord;\n\tfloat x = uv.x*5.;\n\tfloat y = uv.y*12.;\n\tfloat m = 1.-(y*9.)*(13.+sin(-iTime/4.)*.6)*.7+cos(y*1.+x*2.-iTime*9.)*cos(y*1.2-x*6.-iTime+sin(x*5.-y*.4-iTime*2.)+sin(iTime/15.-y*6.+x*6.)/3.)*98.;\n\treturn vec3( m*.016,m*.005,m*.0012);\n}\n\n\n\nvec3 GetColor(vec3 p, float id_color)\n{  vec3 color; \n   if(id_color<50.0)\n   { color=getColor(int(id_color)); }  \n        \n   if(id_color==57.0)\n   { color =vec3(1.0)*( 0.2 + 0.5*mod(floor(p.x*0.25) + floor(p.z*0.25), 2.0));}\n   \n   \n   \n   if (id_color==68.)\n   //{ color =Sinusfire(p.xy*0.125-vec2(0.0,0.25)); }\n   { color =Sinusfire(p.xy*8.0-vec2(0.0,0.25)); }\n   \n   return color;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    vec3 col = vec3(0.45, 0.8, 1.0);\n\tvec3 lig1 = normalize(vec3(10.8, 10.0, -15.6));\n    vec3 lig2 = normalize(vec3(0.0, 60., 25.6));\n    vec2 t;\n    vec3 rcol = vec3(0);\n    vec3 ro2,rd2;\n    ro2=ro;\n    rd2=rd;\n    \n    \t//for(int i = 0; i < 3; i++) \n        for(int i = 0; i < 1; i++) \n        {\n\t\t t = RayMarch(ro, rd, MAX_DIST,false);\n\t\tif(t.x < MAX_DIST) \n        {\n\t\t\t\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t.x;\n\t\t\tvec3 nor = GetNormal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n              vec3 color= GetColor(pos,t.y);\n              \n            \n                rcol= lightingv3(nor,pos,lig1,rd, ro, color );\n                rcol+= lightingv3(nor,pos,lig2,rd, ro, color );\n                rcol/=2.0;\n            \n            \n            // lighten intensity on each successive reflect.\n\t\t\tif(i == 0)\n               col = rcol;\n\t\t\telse\n               col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t\t}\n        else if(t.x>MAX_DIST)\n        col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n    \n\t}\n    \n    \n    ///segundo\n    int j;\n    t = RayMarch(ro2, rd2, MAX_DIST,true);\n\t\tif(t.x < MAX_DIST) \n        {\n            // geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro2 + rd2*t.x;\n\t\t\tvec3 nor = GetNormal(pos);\n\t\t\tvec3 ref = reflect(rd2, nor);\n              vec3 color= GetColor(pos,t.y)/2.0;\n                rcol= lightingv3(nor,pos,lig1,rd2, ro2, color );\n                rcol+= lightingv3(nor,pos,lig2,rd2, ro2, color );\n                rcol/=2.0;\n           \n            // lighten intensity on each successive reflect.\n\t\t\tif(j == 0)\n               col=(col+ rcol)/2.0;\n\t\t\telse\n               col= mix(rcol/2.0, col/2.0, 1.0 - exp(-0.8*float(j)));\n\t\t}\n       \n    \n    return col;\n}\n\n\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43; \n    d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,10.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.0,8.0,-15.0);\n    vec3 rd=normalize(vec3(p,1.0));\n      Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n   \n     vec3 col= render(ro, rd);\n \tcol= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "struct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),  //21\nvec3(0, 1, 1),                           //22 \nvec3(0.333, 0.803, 0.988),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 305, 305, 326], [327, 327, 359, 359, 443], [444, 444, 490, 490, 577], [580, 605, 639, 639, 735], [736, 736, 770, 770, 861], [862, 862, 896, 896, 987], [989, 989, 1023, 1023, 1118], [1120, 1120, 1157, 1157, 2332], [2334, 2364, 2419, 2419, 2629], [2631, 2631, 2655, 2655, 2875], [2877, 2877, 2921, 2921, 3273], [3275, 3275, 3315, 3315, 3578], [3580, 3601, 3631, 3631, 3764], [3766, 3766, 3798, 3798, 3995], [3997, 3997, 4072, 4072, 5030], [5033, 5033, 5070, 5070, 5389], [5393, 5393, 5432, 5432, 5780], [5782, 5782, 5814, 5814, 7576], [7580, 7580, 7607, 7607, 7696], [7698, 7698, 7756, 7756, 7804], [7807, 7807, 7830, 7830, 7948], [7950, 7950, 7987, 7987, 8257], [8259, 8259, 8317, 8317, 8654]]}
{"id": "Nd2fDw", "name": "sonriendo", "author": "jorge2017a2", "description": "sonriendo", "tags": ["sonriendo"], "likes": 4, "viewed": 143, "published": 3, "date": "1646428203", "time_retrieved": "2024-07-30T17:00:13.161714", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(20.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nvec3 Dibuja(vec3 colorIn, vec3 colorOut, float dist)\n{   float unit = 2.0 / iResolution.y;\n    return  mix(colorOut, colorIn, smoothstep(unit, 0.0, dist));  \n}\n \n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBordeR(vec3 pColObj, vec3 colOut, float distObj, float r )\n{ colOut = mix(colOut,pColObj , S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0),S2(abs( distObj)-r,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut;}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 DrawFigRB(vec3 pColObj, vec3 colOut, float distObj, float r )\n{  colOut = mix(colOut,pColObj ,S2( distObj-r,0.0)); return colOut; }\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat FigAlas(vec2 p)\n{   vec2 a;\n    vec2 b;\n    float dfin=999.9;\n    for(int i=0; i<5;i++)\n    {\n        a=vec2(0.0,0.5+float(i)*0.5); b=vec2(0.5+0.5*float(i),0.5+float(i)*0.5);\n        float d1a= sdSegment(p,a,b);\n        dfin=min(dfin, d1a);\n    }    \n   return dfin;\n}\n\n\nfloat HacerSonrisa(vec2 p)\n{vec2 p0=p;\n    vec2 pc13p1=vec2(.247,.540);\n    vec2 pc13p2=vec2(.272,.499);\n    vec2 pc13p3=vec2(.310,.497);\n\n    vec2 pc14p1=vec2(.314,.494);\n    vec2 pc14p2=vec2(.372,.510);\n    vec2 pc14p3=vec2(.378,.537);\n    \n    float d13= sdBezier(p,pc13p1,pc13p2,pc13p3);\n    float d14= sdBezier(p,pc14p1,pc14p2,pc14p3);\n    return min(d13,d14);\n}\n\nvec3 Fig001(vec2 p, vec3 col)\n{   \n    vec2 p0=rotatev2(p-vec2(0.0,0.2),radians(10.0));\n    float d1a= FigAlas(p0 );\n    float d1b= FigAlas(p0-vec2(1.0,1.0));\n    \n    \n    vec2 a , b;\n    a=vec2(0.0,-0.5); b=vec2(0.0,2.5);\n    float d3a= sdSegment(p0-vec2(0.0,0.2),a,b);\n    \n    a=vec2(1.0,-0.5); b=vec2(1.0,2.5+1.0);\n    float d3b= sdSegment(p0-vec2(0.0,0.2),a,b);\n    \n    float d2= sdCircle( p-vec2(-1.5,-1.0), 2.5 );\n    float d2a= sdCircle( p-vec2(-1.5,-1.0), 2.5 );\n    float d2b= sdOrientedBox(p-vec2(-2.0,0.5), vec2(1.0,-0.1), vec2(2.0,3.5), 5.5 );\n    \n    d2b=intersectSDF(d2b,d2a);\n    float d4a= sdCircle(p-vec2(-1.,-1.), 0.5 );\n    float d4b= sdCircle(p-vec2(-2.5,-0.5), 0.5 );\n    \n    a=vec2(-2.8,0.15); b=vec2(-0.2,-0.7);\n    float d5= sdSegment(p,a,b); //lentes\n    \n    float d6=HacerSonrisa(p*vec2(0.105,0.125)-vec2(-0.5,-0.8));\n    \n    col= DrawFigRB(vec3(0.35), col, d1b, 0.22 );\n    \n    col= DrawFigRB(vec3(0.0), col, d3b, 0.22 );\n    col= DrawFigBordeR(vec3(1.0), col, d2,0.1);\n    col= DrawFigRB(vec3(0.25), col, d2b, 0.22 ); //pelo\n    col= DrawFigRB(vec3(0.5), col, d1a, 0.22 );\n    \n    col= DrawFigRB(vec3(0.0), col, d3a, 0.22 );\n    col= DrawFigRB(vec3(0.0), col, d4a, 0.22 );\n    col= DrawFigRB(vec3(0.0), col, d4b, 0.22 );\n    col= DrawFigRB(vec3(0.0), col, d5, 0.22 );\n    col= Dibuja(vec3(0.0),col,d6 );\n    return col;\n    \n}\n\n////https://www.glslsandbox.com/e#79644.0   //Sinus fire\nvec3 sinusFire(  in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy -.2*iResolution.xy )/iResolution.y;\n    float x = uv.x*5.;\n\tfloat y = uv.y*12.;\n\tfloat m = 1.-(y*9.)*(13.+sin(-iTime/4.)*.6)*.7+cos(y*1.+x*2.-iTime*9.)*cos(y*1.2-x*6.-iTime+sin(x*5.-y*.4-iTime*2.)+sin(iTime/15.-y*6.+x*6.)/3.)*98.;\n\treturn  vec3( m*.016,m*.005,m*.0012);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=7.0;\n    uv*=esc;\n   \n    vec3 col= sinusFire(fragCoord.xy );\n    \n    float t=iTime;\n    float t1=mod(t, 1.);\n    float t2=mod(t, 2.);\n    if(t1<t2)\n    col=Fig001(vec2(uv.x, uv.y)-vec2(0.0,2.0),col);\n    else\n    col=Fig001(vec2(-uv.x, uv.y)-vec2(0.0,2.0),col);\n        \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2fDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 356, 356, 461], [465, 465, 501, 501, 546], [548, 548, 595, 595, 622], [623, 623, 666, 666, 693], [694, 694, 742, 742, 770], [773, 773, 845, 845, 971], [973, 973, 1035, 1035, 1165], [1167, 1167, 1248, 1248, 1376], [1378, 1378, 1435, 1435, 1505], [1507, 1507, 1569, 1569, 1634], [1636, 1636, 1704, 1704, 1772], [1774, 1774, 1838, 1838, 1909], [1911, 1927, 1975, 1975, 2053], [2055, 2055, 2089, 2089, 2185], [2186, 2186, 2220, 2220, 2311], [2312, 2312, 2346, 2346, 2437], [2439, 2439, 2473, 2473, 2568], [2570, 2570, 2607, 2607, 2681], [2683, 2683, 2718, 2718, 2741], [2743, 2743, 2795, 2795, 2911], [2913, 2913, 2979, 2979, 3196], [3198, 3198, 3221, 3221, 3472], [3475, 3475, 3503, 3503, 3842], [3844, 3844, 3875, 3875, 5207], [5209, 5266, 5304, 5304, 5602], [5604, 5604, 5661, 5661, 6134]]}
{"id": "fs2fR1", "name": "Fork Paint 1 d4tocchini 970", "author": "d4tocchini", "description": "Just some experiments with fbm", "tags": ["fbm", "paint"], "likes": 3, "viewed": 305, "published": 3, "date": "1646424817", "time_retrieved": "2024-07-30T17:00:13.988504", "image_code": "mat2 rot( float a )\n{ \n    float s = sin(a);\n    float c = cos(a);\n    return mat2( s, c, -c, s ); \n}\n\nfloat noise( in vec2 x ){ return smoothstep(0.,1.,sin(1.5*x.x)*sin(1.5*x.y)); }\n\nfloat fbm( vec2 p )\n{\n    mat2 m = rot(.4);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pattern (in vec2 p, out vec2 q, out vec2 r, float t)\n{\n\tq.x = fbm( p + vec2(0.0,0.0) + .7*t );\n    q.y = fbm( p + vec2(5.2,1.3) + 1.*t );\n    r.x = fbm( p + 10.0*q + vec2(1.7,9.2) + sin(t) );\n    r.y = fbm( p + 12.0*q + vec2(8.3,2.8) + cos(t) );\n    return fbm( p + 3.0*r ); \n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec2 uv = (U.xy - iMouse.xy)/iResolution.xy * 2.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 q,r;\n    vec3 col1 = vec3(0.,.9,.8);\n    vec3 col2 = vec3(1.,.6,.5);\n    \n    float f = pattern(uv, q, r, 0.07*iTime);\n    \n    vec3 c = mix(col1, vec3(0), smoothstep(.0,.95,f));\n    vec3 a = col2 * smoothstep(0., .8, dot(q,r)*0.6);\n    c = sqrt(c*c + a*a);\n    C = vec4( c, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2fR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 101], [103, 103, 128, 128, 182], [184, 184, 205, 205, 580], [583, 583, 643, 643, 866], [868, 868, 907, 907, 1296]]}
{"id": "fl3GW4", "name": "[CrzClm] Brick", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["maptoy", "crazyclimbers"], "likes": 10, "viewed": 254, "published": 3, "date": "1646417832", "time_retrieved": "2024-07-30T17:00:14.936968", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .3\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nvec3 bokoboko = vec3(0); \nvec3 paripari = vec3(0);\n\nvoid setTriTextures(vec3 p){\n\tconst float sclpari = 60.;\n    const float smoothness = .3;\n    paripari.x = voronoiSmooth(p.yz*sclpari, smoothness);\n    paripari.y = voronoiSmooth(p.xz*sclpari, smoothness);\n    paripari.z = voronoiSmooth(p.xy*sclpari, smoothness);\n    paripari=pow(paripari, vec3(2));\n    paripari = smoothstep(.01, 1., paripari);\n    const float sclboko = 100.;\n    bokoboko.x = gfbm(p.yz*sclboko, 1, .5);\n    bokoboko.y = gfbm(p.xz*sclboko, 1, .5);\n    bokoboko.z = gfbm(p.xy*sclboko, 1, .5);\n    bokoboko = smoothstep(.01, 1., bokoboko);\n}\n\nfloat getTriDisp(vec3 v3, vec3 n) {\n    const float k = 3.;\n    n = normalize(n);\n    vec3 w = pow( abs(n), vec3(k) );\n    return (v3.x*w.x + v3.y*w.y + v3.z*w.z) / (w.x + w.y + w.z);\n}\n\nvec3 getTriTrans(vec3 v3, vec3 n) {\n    const float k = 3.;\n    n = normalize(n);\n    vec3 w = pow( abs(n), vec3(k) );\n    w /= w.x + w.y + w.z;\n    return v3*sign(n) * w;\n}\n\nfloat gainstep(float edge0, float edge1, float x, float k) {\n    x = clamp((x-edge0)/(edge1-edge0), 0., 1.);\n    float a = .5*pow(2.*((x<.5)?x:1.-x), k);\n    return (x<.5)?a:1.-a;\n}\n\nfloat sdBoxR2(vec3 p, vec3 s, float r1, float r2) {\n    vec3 q = abs(p)-s+r1+r2;\n    float d = length(max(vec2(0),q.xy)) + min(max(q.x,q.y), 0.)-r1;\n    p.z+=r2*sign(p.z);\n    vec2 w = vec2( d, abs(p.z) - s.z );\n    d = min(max(w.x,w.y),0.0) + length(max(w,0.0))-r2;\n    return d;\n}\n\nfloat sdBricks(vec3 p) {\n    vec3 q = p;\n    \n    // repitation\n    vec3 s = vec3(.13,.06,.06);\n    float gap = .02;\n    vec2 margin = s.xy*2.+gap;\n    float offset = float(int(floor(p.y/margin.y)) % 2);\n\n    q.x += offset*margin.x*.5;\n    q.xy = mod(q.xy, margin) - margin*.5;\n\n    // get noise\n    float ns = gainstep(.7, 1., getTriDisp(bokoboko, q/s), 10.);\n    \n    // break edge\n    float xyRad = .015;\n    float effectRad = .04;\n    float maxlen = sqrt(effectRad*2.)-effectRad;\n    //float maxlen = length(vec3(effectRad));\n    float bd = sdBoxR2(q, s, xyRad, .001);\n    float rbd = sdBoxR2(q, s, xyRad, effectRad);\n    float dif = abs(bd-rbd);\n    \n    return bd + ns * dif * maxlen;\n}\n\nfloat map(vec3 p){\n    setTriTextures(p);\n    return sdBricks(p);\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n// https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n// https://www.shadertoy.com/view/3dVXDc\n// Gradient noise by iq (modified to be tileable)\nfloat gnoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\nfloat voronoi(in vec2 st, in float scl, in float speed, inout vec2 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec2 ist = floor(st);\n\tvec2 fst = fract(st);\n\tfor(float y=-1.; y<=1.; y+=1.){\n\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\tvec2 gridOffset = vec2(x,y);\n\t\t\tvec2 rnd = hash22(ist+gridOffset+speed*.5);\n\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\tif(d<res){\n\t\t\t\tres = d;\n\t\t\t\tid = rnd;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nfloat voronoi(in vec3 st, in float scl, in float speed, inout vec3 id){\n\tfloat res=1.*scl;\n\tst = u2s(st)*scl;\n\tvec3 ist = floor(st);\n\tvec3 fst = fract(st);\n\tfor(float z=-1.; z<=1.; z+=1.){\n\t\tfor(float y=-1.; y<=1.; y+=1.){\n\t\t\tfor(float x=-1.; x<=1.; x+=1.){\n\t\t\t\tvec3 gridOffset = vec3(x,y,z);\n\t\t\t\tvec3 rnd = hash33(ist+gridOffset+speed*.5);\n\t\t\t\tfloat d = distance(st, ist+gridOffset+rnd);\n\t\t\t\tif(d<res){\n\t\t\t\t\tres = d;\n\t\t\t\t\tid = rnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\nfloat gfbm(vec3 n, int rep, float pers){\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < rep; ++i)\n    {\n        noise += amp * gnoise(n * pers, pers);\n        pers *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat SMinC3(float a, float b, float r)\n{\n    float n = max(0.0, 1.0 - abs(a - b) / r);\n    \n    float o = (0.25 - n*0.1) * ((n*n)*(n*n));\n    \n    return min(a, b) - o*r;\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n\tvec2 u = max(vec2(r + b,r + -a), vec2(0));\n\treturn min(-r, max (b, -a)) + length(u);\n}\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = SMinC3( res, d, s );\n    }\n    return res;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3GW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 316, 316, 846], [848, 848, 883, 883, 1033], [1035, 1035, 1070, 1070, 1208], [1210, 1210, 1270, 1270, 1391], [1393, 1393, 1444, 1444, 1675], [1677, 1677, 1701, 1701, 2369], [2371, 2371, 2389, 2389, 2438]]}
{"id": "7sBfDm", "name": "sRGB vs gamma encoding 3", "author": "ttg", "description": "sRGB is [b]NOT[/b] the same as 2.2 gamma !  The error is significant for images with dark tones: compare the center row vs. top and bottom, simulating a wrong correction applied.  To visualize the difference independently of your display, enable line 37.", "tags": ["gamma", "srgb", "srgbvspow"], "likes": 6, "viewed": 785, "published": 3, "date": "1646415063", "time_retrieved": "2024-07-30T17:00:15.797666", "image_code": "\nvec3 srgb_decode (vec3 e) {\n  return mix(e/12.92,pow((e+.055)/1.055,vec3(2.4)),lessThan(vec3(.04045),e));\n}\n\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n\nvoid mainImage (out vec4 d, vec2 f) {\n//#define HALFTONE(p) float(int(dot(floor(f),vec2(413,229)))%512<int((p)*512.))\n  vec2 grid = vec2(8,3);\n  vec2 res = iResolution.xy;\n  vec2 uv = grid*f/res.xy;\n  ivec2 c = ivec2(floor(uv));\n  uv = (fract(uv)*2.-1.)/grid*res.xy/res.xx*grid.x;\n\n  // Initially: all cells indentical image of diffuse+ambient shading on a sphere\n  uv*=1.1;\n  vec3 n = normalize(vec3(uv,sqrt(1.-dot(uv,uv))));\n  vec3 l = normalize(vec3(.2,.5,.4));\n  vec3 col = dot(uv,uv)>1. ? vec3(0) :\n    vec3(.1,.05,.05) + vec3(.9,.8,.7)*max(0.,dot(n,l));\n\n  // Each cell is one halving of light energy\n  float m = exp2(-float(c.x));\n  col*= m;\n\n  // Top: what happens when gamma signal is sent to sRGB display\n  if (c.y==2) col = srgb_decode(pow(col,vec3(1./2.2)));\n\n  // Botton: what happens when sRGB signal is sent to gamma display\n  if (c.y==0) col = pow(srgb_encode(col),vec3(2.2));\n\n  // If you don't trust your display, enable the following.\n  // Middle row will be the correctly displayed one.\n#if 0\n  vec4 colr = vec4(col,m);\n  colr = colr*14.+.1; if (colr.a>1.) colr=vec4(0);\n  col = colr.rgb;\n#endif\n\n  d.rgb = srgb_encode(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 108], [110, 110, 137, 137, 220], [222, 222, 259, 339, 1368]]}
{"id": "fsBfWw", "name": "Toy Waves", "author": "SnoopethDuckDuck", "description": "messy code, wanted to offset each line (looks really cool but get artifacts) so might redo later", "tags": ["e"], "likes": 10, "viewed": 295, "published": 3, "date": "1646411977", "time_retrieved": "2024-07-30T17:00:16.573592", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float d = sqrt(26.);\n    float a = 1.8 + 0.1 * iTime;\n    vec3 ro = d * normalize(vec3(cos(a), 0.1, sin(a)));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    \n    p.x -= 0.2 * iTime;\n    p.y += 0.2 * cos(2. * p.z + iTime) * cc(1., 5. * p.x);\n    p.y -= 0.2 * cos(p.z * 3.);\n    float d = p.y + 1.;\n    \n    return 0.6 * d; // could be higher maybe\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n    float dO=0.;\n    float s = 1.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(s!=sign(dS))z*=0.5;\n        s = sign(dS);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    return 0.5 + 0.5 * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,-1,0), 1.1);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        \n        //col *= 0.5 + 0.5 * cc(4., 5. * p.x - iTime);\n        \n        float x = mod(5. * p.x - iTime, 2. * pi) - pi;\n\n        float o = 0.25 * pi;\n        float s1 = smoothstep(0. + o, 0.5 + o, abs(x));\n        s1 = pow(s1, 4.);\n    \n        float fresnel2 = pow(1.+dot(rd, n), 3.); \n    \n        float sc = step(0.1 * s1, uv.y);\n        col *= mix(col, vec3(fresnel2), 1.-vec3(s1));\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col *= fresnel;\n        \n        //col += fresnel2;\n        vec3 e = vec3(1);\n        float mx = mix(0.32, 1., 0.5 + 0.5 * cc(1., 0.05 * p.z + .5 * iTime + floor(5. * p.x - iTime)));\n        col *= pal(s1 * mx + 0.45 + 0.2 * exp(-0.2 * abs(p.z)), e, e, e, 0.5 * vec3(0,1,2)/3.);\n       \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col = 1. - col;\n     vec3 p = ro + rd * d;\n    float lerp = exp(-0.35 * mlength(p.xz * Rot(0.1 * iTime)));\n    col = mix(col, Bg(sabs(rd)+0.), 1.-lerp);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 649, 649, 887], [889, 889, 912, 912, 1108], [1110, 1110, 1153, 1153, 1446], [1448, 1448, 1472, 1472, 1662], [1664, 1664, 1714, 1714, 1905], [1907, 1907, 1925, 1925, 1954], [1956, 1956, 2013, 2013, 3698]]}
{"id": "7sBBWm", "name": "4d Menger Sponge", "author": "lwswl", "description": "A 4d Menger Sponge, rotating in the xw plane.\nDrag the mouse to move around, Y axis is zoom, X axis is pan.\n\n", "tags": ["raymarching", "raymarch", "menger", "sponge"], "likes": 2, "viewed": 430, "published": 3, "date": "1646406613", "time_retrieved": "2024-07-30T17:00:17.511085", "image_code": "\n/**\n *  4D sponge\n *  \n *\n *\n**/\n\n#if HW_PERFORMANCE==1\n//uncomment this if you have a decent GPU. It improves the sponge s lot.\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 100.\n#define COLOR_SPEED 0.1\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 4.0\n#define lerp(a, b, k,) (a*(1.0-k)+b*k)\nvec3 hue(float t){\n    vec3 h=vec3(1,0,0);\n    if (t<0.333){\n        h.r=(0.333-t)*3.;\n        h.g=(t)*3.;\n        h.b=0.;\n        return h;\n    }\n    else if(t<0.667){\n        h.g=(0.667-t)*3.;\n        h.b=(t-0.333)*3.;\n        h.r=0.;\n    }\n    else{\n        h.b=(1.-t)*3.;\n        h.r=(t-0.667)*3.;\n        h.g=0.;\n    }\n    return h;\n}\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - f;\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n    \n}\nfloat ScubeSDF(vec4 p,float f){\n    vec4 v = abs(p) - vec4(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,max(v.z,v.w))),0.0);\n    \n}\nfloat SmengerSDF(vec4 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec4 o=vec4(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=ScubeSDF(p+o,r);\n    if (d>r)return d;//1.414213562=sqrt(2)\n    //equilateral triangle, sqrt(2^2-1^2)=sqrt(3)\n    //pyramid thing sqrt(sqrt(2^2-1^2)-1^2)=sqrt(2)\n    //whatin4d sqrt(sqrt(sqrt(2^2-1^2)-1^2)-1^2)=1?\n    \n    vec4 no=vec4(0);\n    \n    r/=3.;\n    while (d<r&&(II<limit||limit==0.)){\n        \n        d=far;\n        float r2=2.*r;\n        f=ScubeSDF(p+o+vec4(r2,r2,r2,0),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,r2,0,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,0,r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(0,r2,r2,r2);}\n\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,0),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,0),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,0),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,0),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,0),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,0),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,0);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,0),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,0);}\n        \n        f=ScubeSDF(p+o+vec4(-r2,r2,0,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,0,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,0,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,0,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,0,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,0,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,0,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,0,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,0,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,0,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(-r2,0,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,0,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,0,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,0,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,0,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,0,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,0,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,0,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,0,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,0,-r2,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(0,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(0,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(0,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(0,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(0,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(0,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(0,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(0,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(0,-r2,-r2,-r2);}\n        \n        f=ScubeSDF(p+o+vec4(r2,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(r2,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(r2,-r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,r2,-r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,r2,-r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,r2);}\n        f=ScubeSDF(p+o+vec4(-r2,-r2,-r2,-r2),r);if(f<d){d=f;no=o+vec4(-r2,-r2,-r2,-r2);}\n        //48 Scubes given thats its all binary operations, more or less, this should be done in a loop.\n        \n        \n        \n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n   \n    return d;     \n}\nfloat mengerSDF(vec3 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=cubeSDF(p+o,r);\n    if (d>r*1.414213562)return d;//1.414213562=sqrt(2)\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*1.414213562&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n    if(II>limit){\n        return cubeSDF(p+o,r);\n    }\n    return d;\n    \n    \n    \n     \n}\nvec4 noise(vec3 p){\n    float f=sin(p.z*0.3)+sin(p.x*0.3)+sin(p.x)+sin(p.y)+sin(p.z)+sin(p.x+p.z)+sin(p.y+p.x)+sin(p.z+p.y);\n    f*=0.5;\n    vec3 d=normalize(vec3(\n        0.3*cos(p.x*0.3)+cos(p.x)+cos(p.x+p.z)+cos(p.x+p.y),\n        cos(p.y)+cos(p.x+p.y)+cos(p.y+p.z),\n        0.3*sin(p.z*0.3)+cos(p.z)+cos(p.x+p.z)+cos(p.y+p.z)\n        \n        ));//no coefficient, as it is normalized\n    return vec4(f,d);\n}\n\n\nconst mat3 m3=mat3(-0.5, 0.9, 0.5,\n                0.4, -0.5, 0.4,\n                0.5, 0.9, -0.5);\n\nvec4 fbm( in vec3 x, int octaves )\n{\n    float f = 2.0; \n    float s = 0.5;  \n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noise(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3*m;\n    }\n    return vec4( a, d );\n}\nbool PLANE=false;\nfloat bounce(float t){\n    t=fract(t);\n    return (1.-t)*(1.-t)+t*t;\n}//returns values in range 0, 1\nfloat sinl(float t){\n    if(fract(t*0.5)>0.5)return bounce(t);\n    else return -bounce(t);\n\n}\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0);\nfloat sceneSDF(vec3 p, float limit){\n    vec4 p4=vec4(p,-1);\n    //p4.w=sinl(iTime*0.02);\n    float r=iTime*0.1;\n    p4*=mat4(cos(r),0,0,sin(r),\n             0,1,          0,0,\n             0,0,          1,0,\n             -sin(r),0,0,cos(r));\n    \n    return SmengerSDF(p4,limit);\n}\nfloat getEplison(float dist,float R){\n    return clamp(10.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec2 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        float dist = sceneSDF(o + depth * d, limit);\n        if(!a_bool&&dist<0.0005){\n            fd=getEplison(depth+dist,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist < fd){\n            //if(dist.y>0.9)\n            return vec2(depth,fd);\n        }\n        depth += dist;\n        if (depth >= end)return vec2(end,fd);\n    }\n    return vec2(end,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    float gg=sceneSDF(vec3(p)-n*0.333,0.);\n    return normalize(vec3(gg-sceneSDF(vec3(p.x-n,p.yz),0.),\n                     gg-sceneSDF(vec3(p.x,p.y-n,p.z),0.),\n                     gg-sceneSDF(vec3(p.xy,p.z-n),0.)\n                    ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY);\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    //f.rgb=N;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows, float t){\n    light.xyz=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    //f.rgb=N;\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, t,far,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x>0.)mouse-=0.5;\n        vec3 col=hue(mod(iTime*COLOR_SPEED,1.0))*0.07;\n        \n        float dist=sin(iTime*0.1)*0.1+10.-mouse.y*16.;\n        vec3 o=vec3(sin(mouse.x*6.+1.+iTime*0.1)*dist,0,cos(mouse.x*6.+1.+iTime*0.1)*dist);\n\n        vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n\n\n        vec3 d=normalize(vec3(uv,-1.1));\n        vec3 f=lerp(vec3(0.1,0.2,0.3),vec3(0.64,0.8,0.9),fragCoord.y/iResolution.y);\n        vec3 UP=vec3(0,1,0);\n        vec3 T = normalize(-o);\n        vec3 A = cross(UP,T);\n        UP=cross(T,A);\n        mat3 cm=mat3(A,UP,-T);\n        d*=cm;\n        d=normalize(d);\n        vec2 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n        if (t.x<far){\n            vec3 p=o+d*t.x;\n            vec3 N;\n            vec3 albedo=vec3(0.4); \n            float clt=clamp(t.y,0.01,0.1);\n#ifdef AA\n            for(int i=0;i<4;i++){\n                uv = ((fragCoord+vec2(i/2,i%2)*0.25-0.25)/iResolution.xy-0.5)*normalize(iResolution.xy);\n                f=vec3(0.3,0.35,0.4);\n                d=normalize(vec3(uv,1.1));\n                d*=cm;                        \n#endif       \n                N=normal(o+d*t.x,t.y);\n                f.rgb*=albedo*0.1*vec3(dot(N,vec3(0,1,-1)));\n                f.rgb+=albedo*dist_light_func(p,N,vec3(0.5,0.5,0.5),true,clt)*vec3(0.9,0.8,0.6);\n                f.rgb+=albedo*light_func(p,vec3(0.0,0.0,0.0),true)*col*1.;\n                //f.rgb=N*0.5+0.5;\n                \n#ifdef AA         \n                fragColor.rgb+=f;\n            }\n            fragColor.rgb+=fragColor.rgb*0.25;\n#endif\n\n        }\n#ifdef AA        \n        else{\n            fragColor.rgb=f;\n        }  \n#else \n        fragColor.rgb=f;\n#endif\n\n\n     \n        \n\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 749, 749, 1070], [1071, 1071, 1101, 1101, 1197], [1198, 1198, 1229, 1229, 1340], [1341, 1341, 1379, 1379, 6088], [6089, 6089, 6126, 6126, 8287], [8288, 8288, 8307, 8307, 8698], [8802, 8802, 8838, 8838, 9273], [9292, 9292, 9314, 9314, 9362], [9362, 9393, 9413, 9413, 9486], [9487, 9487, 9527, 9527, 9550], [9578, 9578, 9614, 9614, 9860], [9861, 9861, 9898, 9898, 9958], [9959, 9959, 10045, 10045, 10719], [10722, 10722, 10751, 10751, 10992], [10994, 10994, 11064, 11064, 11316], [11317, 11317, 11368, 11368, 11599], [11600, 11600, 11677, 11677, 11959]]}
{"id": "7sXyDl", "name": "[CrzClm] Shoe", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n\nMy new shoe.", "tags": ["maptoy", "crazyclimbers"], "likes": 15, "viewed": 315, "published": 3, "date": "1646403912", "time_retrieved": "2024-07-30T17:00:18.458552", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .3\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nmat2 rot2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define MAX_DIST DIST_MAX\n#define MIN_DIST DIST_MIN\n#define MAT_VOID vec3(0)\n#define MAT_FOOT_COL vec3(1)\n#define MAT_SHOELACE_COL vec3(.5)\nvoid pElongate(inout float q, in float h ){\n\tq = q-clamp(q,-h,h);\n}\n\nfloat sigmoidstep(float edge0, float edge1, float x, float contrast, float mid) {\n    // https://www.shadertoy.com/view/3ssSz2\n    x = smoothstep(edge0, edge1, x);\n    float scale_l = (1. / mid) * x;\n    float scale_h = (1. / (1. - mid)) - (1. / (1. - mid)) * x;\n    float lower = mid * (scale_l * scale_l);\n    float upper = 1. - (1. - mid) * (scale_h * scale_h);\n\tfloat curve = x < mid ? lower : upper;\n    return mix(x, curve, (contrast - 1.));\n}\n\n\nfloat smoothbistep(float edge0, float edge1, float x, float smoothness) {\n    float l = abs(edge0-edge1) * smoothness * .5;\n    return (edge0<edge1) ?\n    max(smoothstep(edge1-l, edge1, x),smoothstep(edge0+l, edge0, x)):\n    min(smoothstep(edge1-l, edge1, x),smoothstep(edge0+l, edge0, x));\n}\n\nfloat sigmoidbistep(float edge0, float edge1, float x, float smoothness, float contrast, float mid) {\n    float l = abs(edge0-edge1) * smoothness * .5;\n    return (edge0<edge1) ?\n    max(sigmoidstep(edge1-l, edge1, x, contrast, mid),sigmoidstep(edge0+l, edge0, x, contrast, mid)):\n    min(sigmoidstep(edge1-l, edge1, x, contrast, mid),sigmoidstep(edge0+l, edge0, x, contrast, mid));\n}\n\nfloat pMirror(float x, float k){\n\treturn sqrt(x*x+k);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat vmax(vec3 v){\n\treturn max(max(v.x,v.y),v.z);\n}\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0)));\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n\tp.x = abs(p.x);\n\tvec2 sc = vec2(sin(per),cos(per));\n\tfloat k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n\treturn sqrt( dot(p,p) + r.x*r.x - 2.*r.x*k ) - r.y;\n}\n\nfloat fOpIntersection(in float a,in float b){\n\treturn max(a, b);\n}\n\nfloat common_foot_bend = .1;\nvec4 sdFoot(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\t//float bsd = length(p+vec3(0., .025, .125)), bsr=0.4;\n\t//if (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID).x;\n\n    const float bdth = .01; \n    float bbd = sdBox(p+vec3(0., .01, .125), vec3(.15, .1, .25));\n    if(bbd>bdth) return vec4(bbd-bdth*.5, MAT_VOID);\n\n\tp.xyz += vec3(0., .0118123, .0059056);\n\t\n    // Sole\n\tvec3 pRoot = p;\n\tpRoot.xyz += vec3(0., .0995976, .0139068);\n    pElongate(pRoot.y, .028);\n\n    // Winkles\n    vec3 trp = pRoot;\n    R(trp.yz, -.8);\n    R(trp.yz, trp.y*1.*trp.z);\n    trp.z*=trp.y*8.;\n    vec3 sq = (pRoot+vec3(0,.19,-.1))*vec3(.2,.2,1);\n    float msk0 = 1.-sigmoidbistep(-.1, .35, trp.z, 2.5, 1., .5);\n    float msk1 = 1.-sigmoidbistep(.04, .15, pRoot.y, 1.5, 1., .75);\n    float msk2 = smoothbistep(-.075, .18, pRoot.z, .75);\n    trp = pRoot;\n    trp.y-=.18;\n    trp.z+=.15;\n    vec2 rq = vec2(atan(trp.z, trp.y), length(trp.yz));\n    pRoot.xy -= u2s(gfbm(rq*vec2(15,20), 1, .5))*.1*(common_foot_bend*.9+.1)*msk0*msk1*msk2;\n\n    // Shoe lace\n\tvec3 pLace = p;\n\tpLace.xyz += vec3(-.0053759, -.0290327, .1038382);\n\tpLace.xyz = rot(pLace, vec3(.1253111, 0., 0.));\n\tpLace.x = sabs(pLace.x, .005);\n\tpLace.z = sabs(pLace.z, .005);\n\n\td = sdEllipsoid(rot(pRoot+vec3(0., -.0270154, -.0289158), vec3(0., -3.1415923, .1330502)), vec3(.0845093, .0617542, .1017926));\n\td = fOpUnionSmooth(sdEllipsoid(rot(pRoot+vec3(-.0024533, -.0036525, .1932134), vec3(-.156419, 2.8045447, 0.)), vec3(.1085749, .0856629, .1173515)), d, .145);\n\td = fOpUnionSmooth(sdEllipsoid(rot(pRoot+vec3(.0010224, -.0599675, .2616568), vec3(0., -3.1415923, .1330502)), vec3(.0983343, .0668576, .0762622)), d, .091);\n\td = fOpUnionSmooth(sdEllipsoid(rot(pRoot+vec3(0., -.081928, -.0354249), vec3(0., -3.1415923, .1330502)), vec3(.0464795, .0374377, .0558753)), d, .1);\n    d = fOpIntersection(sdBox(p+vec3(0., -.05, .1), vec3(.15,.15,.3)), d);\n\td = fOpUnionSmooth(sdTorus(p+vec3(0., -.0873759, -.0130113), vec2(.0397773, .0185628)), d, .043);\n\td = fOpSubstractionSmooth(sdBox(rot(p+vec3(0., .2220884, .1264618), vec3(-1.3666353, 0., 0.)), vec3(.1194755, .1194755, .1194755)-0.)-0., d, .0025);\n\tres = v4OpUnion(vec4(d, MAT_FOOT_COL), res);\n\n\td = sdCappedTorus(rot(pLace+vec3(0., .0627211, -.0031153), vec3(1.577965, .4719465, 0.)), vec2(.075577, .0075577), .6282557);\n\tres = v4OpUnion(vec4(d, MAT_SHOELACE_COL), res);\n\treturn res;\n}\n\nvoid bend(inout vec2 p, float k, float s0, float sb, float se) {\n    // https://www.pouet.net/topic.php?which=7931&page=5\n\tif(abs(k)<1e-3)return;\n\tfloat r = 1./k, ak = abs(k), sk = sign(k);\n\tvec2 d = vec2(-(p.x - s0), (r - p.y*sk*min(sk,-sign(p.x)))) * sk; // fixed to work with negative k\n\tfloat a = -atan(d.x, d.y);\n\tfloat b = clamp(a, ak*(sb-s0), ak*(se-s0)) ;\n\tfloat s = b*r+s0;\n\tvec2 c = vec2(sin(b), cos(b));\n\tp.xy = mix(\n\t\tvec2(s, length(d) - abs(r)),\n\t\tsk*(c.yx*d.xx*vec2(-1.,1) - c.xy*d.yy) + vec2(s, r),\n\t\tabs(sign(a-b))\n\t);\n}\n\nfloat map(vec3 p){\n    float t = iTime*3.;\n    p.y-=.11;\n    common_foot_bend = abs(sin(t*.5));\n    p.y*=-1.;\n    bend(p.zy, -PI*common_foot_bend, 0., 0., .25);\n    p.y*=-1.;\n    //R(p.yz, sin(t)*PI*.5);\n    //p.x += sin(t)*.2;\n    \n    return sdFoot(p).x;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-1,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 257, 257, 309], [451, 451, 494, 494, 518], [520, 520, 601, 646, 969], [972, 972, 1045, 1045, 1264], [1266, 1266, 1367, 1367, 1650], [1652, 1652, 1684, 1684, 1707], [1709, 1709, 1734, 1734, 1749], [1751, 1751, 1783, 1783, 1846], [1848, 1848, 1867, 1867, 1900], [1901, 1901, 1928, 1928, 2001], [2003, 2003, 2039, 2039, 2062], [2064, 2064, 2111, 2111, 2281], [2283, 2283, 2328, 2328, 2349], [2380, 2380, 2400, 2400, 4777], [4779, 4779, 4843, 4900, 5315], [5317, 5317, 5335, 5335, 5575]]}
{"id": "7sSfWm", "name": "Table Tracer [ppxxll]", "author": "robclouth", "description": "Created by https://www.shadertoy.com/user/Ultraviolet\nModified for use with https://github.com/robclouth/ppxxll", "tags": ["2d", "tracing", "caustic", "epicycloid"], "likes": 4, "viewed": 264, "published": 3, "date": "1646399643", "time_retrieved": "2024-07-30T17:00:19.223507", "image_code": "//@author Ultraviolet\n//@title Table Tracer\n//@description Inspired by 'modular multiplication table' diagrams.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord -iResolution.xy*.5)/iResolution.y*2.;\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    vec2 m;\n    if(iFrame == 0)\n        m = vec2(0.,2.2);\n    else\n        m = state.yz;\n    \n    \n    if(iMouse.z > 0.5)\n    {\n      //  m = vec2(200., 1.+floor(iMouse.y/iResolution.y*10.)+1./floor(1.+iMouse.x/iResolution.x*10.));\n    }\n    \n    \n    if(fragCoord == vec2(0.5)) {\n        fragColor = state;\n        if(iFrame == 0) {\n            fragColor = vec4(0.,m,0.);\n        }\n        fragColor.x += 1.;\n        \n        if(fragColor.yz != m)\n            fragColor.x = 0.;\n        \n        fragColor.yz = m;\n        return;\n    }\n    \n    if(state.x > MAX_FRAME) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    fragColor = vec4(0.);\n    \n    Circle c = Circle(vec2(0.), .9);\n        \n        \n    for(float k=0.; k<MAX_ITER_PER_FRAME; k++)\n    {\n        float theta = hash12(vec2(state.x/MAX_FRAME, k/MAX_ITER_PER_FRAME));\n        \n        vec4 rand = hash44(vec4(fragCoord/iResolution.xy, state.x/MAX_FRAME, k/MAX_ITER_PER_FRAME));\n        \n        //theta = rand.x;\n        \n        float div = fract(m.y);\n        if(div > 1e-5)\n            theta /= div;\n        \n        vec2 p0 = getPt(c, theta);\n        vec2 p1 = getPt(c, theta*m.y);\n        \n        //float d = sdSegment(p+rand.yz/iResolution.y, p0,p1);\n        float d = sdLine(p+rand.yz/iResolution.y*2., p0,p1);\n        \n        /*\n        float f = fract(theta * m.x);\n        float strength = pow(abs((f - 0.5) * 2.), 10.);\n        \n        fragColor += smoothstep(1.,0.,d*iResolution.y) * vec4(hsv2rgb_smooth(vec3(length(p1-p0)/3., 0.8, strength)), 1.);\n        /*/\n        \n        fragColor += smoothstep(1.,0.,d*iResolution.y) * vec4(hsv2rgb_smooth(vec3(length(p1-p0)/(2.8*c.rad), .8, .8)), 1.);\n        //*/\n        \n    }\n    \n    fragColor /= MAX_ITER_PER_FRAME;\n    if(state.x > 1.)\n        fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_ITER_PER_FRAME  500.\n#define MAX_FRAME  500.\n\n#define PI\t3.14159265359\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash14(vec4 p4)\n{\n\tp4  = fract(p4 * .1031);\n    p4 += dot(p4, p4.wzyx + 31.32);\n    return fract((p4.x + p4.y) * p4.z + p4.w);\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    return length((p - a) - dot(p - a, b-a)/dot(b - a, b-a) * (b-a));\n}\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n    \nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n    \nstruct Bezier3\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n};\n    \nstruct Bezier4\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n};\n    \nstruct Grid\n{\n    float inter;\n};\n\nbool intersect(Circle c, Ray r, out vec2 t)\n{\n    float A = dot(r.dir, r.dir);\n    float B = dot(r.dir, -c.ctr+r.org);\n    float C = dot(c.ctr, c.ctr) +dot(r.org, r.org) -2.*dot(c.ctr, r.org) - c.rad*c.rad;\n    \n    float delta = B*B-A*C;\n    \n    if(delta < 0.0)\n    \treturn false;\n\n    t = (vec2(-B) + vec2(sqrt(delta))*vec2(-1.,1.))/A;\n    return true;\n}\n\nbool intersect(Ray r0, Ray r1, out vec2 t)\n{\n    t = inverse(mat2(r0.dir, -r1.dir))*(r1.org-r0.org);\n    return true;\n}\n\nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nvec2 getPt(Bezier3 c, float t)\n{\n    return mix(mix(c.A, c.B, t), mix(c.B, c.C, t), t);\n}\n\nvec2 getPt(Bezier4 c, float t)\n{\n    return mix(mix(mix(c.A, c.B, t), mix(c.B, c.C, t), t), mix(mix(c.B, c.C, t), mix(c.C, c.D, t), t), t);\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\nfloat dist(Circle c, vec2 p)\n{\n    return abs(length(c.ctr-p)-c.rad);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n    \n}\n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = mod(p,g.inter);\n    d = min(d, g.inter-d);\n    return min(d.x, d.y);\n    \n    //bvec2 l = greaterThan(mod(p,g.inter*2.),vec2(g.inter));\n    //return all(l)||all(not(l)) ? 1. : 0.;\n}\n\nstruct HalfPlane\n{\n    vec2 org;\n    vec2 dir;\n};\n\nstruct HalfPlane2\n{\n    vec2 org;\n    vec2 dir0;\n    vec2 dir1;\n};\n\nfloat dist(HalfPlane r, vec2 p)\n{\n    return (dot(r.dir, p-r.org)/dot(r.dir, r.dir));\n}\n\nfloat dist(HalfPlane2 r, vec2 p)\n{\n    float d0 = dist(HalfPlane(r.org, r.dir0.yx*vec2(-1.,1.)), p);\n    float d1 = dist(HalfPlane(r.org, r.dir1.yx*vec2(-1.,1.)), p);\n    \n    /*\n    if(dot(r.dir0+r.dir1, p-r.org)<0.)\n        return dist(r.org, p);\n\t//*/\n    \n    return max(min(d0, d1), min(-d0, -d1));\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nfloat dist(Bezier3 B, vec2 p)\n{\n    vec2 a = B.B - B.A, b = B.A - B.B * 2.0 + B.C, c = a * 2.0, d = B.A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = B.A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = B.A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = B.A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\nfloat dist(Bezier4 BB, vec2 p)\n{\n    vec2 A = BB.A, B = BB.D;\n    \n    float ppt;\n    float At = .0;\n    float Bt = 1.;\n    \n    vec2 pp;\n    \n    float dis = dist(pp, p);\n    \n    for(int i=0; i<5; ++i)\n    {\n        ppt = (At+Bt)*.5;\n        pp = getPt(BB, ppt);\n        \n        if(dist(Segment(A, pp), p) < dist(Segment(pp, B), p))\n        {\n            Bt = ppt;\n        \tB = getPt(BB, Bt);\n        }\n        else\n        {\n            At = ppt;\n        \tA = getPt(BB, At);\n        }\n            \n    }\n    \n    return min(dist(Segment(A, pp), p), dist(Segment(B, pp), p));\n}\n\n\n#define DRAW(O,P,C,W, CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2. -  W, -1., 1.)*.5+.5))\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 170, 170, 232]]}
{"id": "ssSfWw", "name": "Quantum substance", "author": "El_Sargo", "description": "Domain distortion experiment.", "tags": ["3d", "raymarching", "cineshader"], "likes": 8, "viewed": 3944, "published": 3, "date": "1646386658", "time_retrieved": "2024-07-30T17:00:19.986467", "image_code": "//Heavy performance impact \n#define AA 1\n#define raymarchSteps 100\n//#define vanillaMarch\n#define rotationSpeed 7.\n#define ZERO min(iFrame, 0)\n\nconst float pi = 3.14159265359;\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nvec4 map(vec3 p) {\n    for(int i =0;i<2;i++){\n    const float s = .6;\n    p *=roty(s*sin(iTime*0.5)*p.y)*rotz(s*p.z*cos(iTime*2.1))*rotx(s*p.x*-cos(iTime));\n    p.x += cos(iTime*2.141)*0.15*abs(p.y);\n    p.y += sin(iTime*1.123123)*0.15*abs(p.z);\n    p.z += -cos(iTime*3.123123)*0.15*abs(p.x);\n\n    }\n    float d =  sdBox(p, vec3(1.));//sdSkeleton(p, iTime);\n    \n    return vec4(d-0.3, p);\n}\n#ifndef vanillaMarch \nvec3 intersection(vec3 ro, vec3 rd){\n    \n    //Boring variables\n    float zslice = -.158;//cos(stime);\n    vec3 pos = ro;\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    float T = 0.;\n    \n    //Colour \n    float h = map(pos).x;\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<raymarchSteps; ++i) {\n    \n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = map(p).x*0.5;\n        \n        if (h > 20.)\n            break;\n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        \n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n    return ro+T*rd;;\n}\n#else\n//https://www.shadertoy.com/view/wlVGRV\nvec3 intersection(vec3 ro, vec3 rd){\n    for(int i=0;i < raymarchSteps;i++){\n        float dist = map(ro).x*1.;\n        ro += rd*dist;\n        if(dist <0.01)\n            break;\n    }\n    return ro;\n}\n#endif\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p ){\n    const float h = 1.1;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<3; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 sky(vec3 rd, samplerCube sam){\n    return texture(sam, rd).xyz;\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    \n    //world info\n     vec3 pos = intersection(ro,rd);\n     vec4 sce = map(pos);\n    float dis = sce.x;\n     vec3 trp = sce.yzw;\n    float tpd = distance(trp,pos);\n    \n    //Shading\n     vec3 sun = vec3(0., 1., 0);\n    float sha = softshadow(pos, sun, 0.1, 2., 1.);\n     vec3 nor = calcNormal(pos);\n    float occ = calcAO(pos, nor);\n    float lig = (dot(sun,nor)*0.5+0.5);\n\n    //Colors\n     vec3 col = vec3(0);\n     vec3 bcl = vec3(smoothstep(-2., 1., tpd));\n     vec3 scl = sky(nor, iChannel1);\n     vec3 amb = vec3(0.9, 0.9, 1.);\n    \n    //\n     //vec3 txs = texture(iChannel0, rd).xyz;\n     //vec3 txr = texture(iChannel0, reflect(nor, rd)).xyz;\n    vec3 ref = reflect(rd,nor);\n    if (dis < 2.1) {\n        //Sun\n        //col += .75*lig*sha*scl*bcl*(max(0.,dot(sun,nor)));\n        //Ambient\n        col += 0.5*mix(vec3(0.463,0.376,0.318),vec3(1.000,1.000,1.000),smoothstep(-1.,1.,nor.y))*occ;\n        //Reflect\n        col += 2.*bcl*sha*sha*sky(ref,iChannel1)*occ*(1.+dot(ref,rd));\n    } else\n        col = sky(rd,iChannel0);\n    return vec4(col, 0.1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -5.5);\n    mat3 yrot = roty(iTime*0.2);\n    mat3 xrot = rotx(-iMouse.y/iResolution.y*rotationSpeed);\n           ro*=xrot*yrot;\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n\n    tot = smoothstep(-.1,1.4,tot);\n    \n    // Output to screen\n    fragColor = tot;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 214, 214, 294], [296, 296, 316, 316, 443], [444, 444, 464, 464, 591], [592, 592, 612, 612, 739], [742, 742, 760, 760, 1133], [2687, 2687, 2763, 2763, 2978], [2979, 2979, 3008, 3008, 3230], [3231, 3231, 3264, 3264, 3525], [3527, 3527, 3562, 3562, 3597], [3599, 3599, 3629, 3651, 4695], [4696, 4696, 4753, 4753, 5363]]}
{"id": "NsBBWW", "name": "Orthocenter at y(x)=1/x", "author": "iq", "description": "Animated recreation of this tweet by Albert Chern: [url]https://twitter.com/theAlbertChern/status/1499096653684371456[/url]. The graph shows that the orthocenter of a triangle that has vertices laying in the y=1/x graph, is also sitting on that graph.", "tags": ["2d", "triangle", "orthocenter", "1x"], "likes": 79, "viewed": 2176, "published": 3, "date": "1646376305", "time_retrieved": "2024-07-30T17:00:20.813256", "image_code": "//\n// Inigo Quilez - 2022\n//\n// An animated recreation of this tweet by Albert Chern:\n// https://twitter.com/theAlbertChern/status/1499096653684371456\n// Meaning, the art is his, not mine.\n//\n// The graph shows that the orthocenter of a triangle that has vertices\n// laying in the y=1/x graph, is also sitting on that graph.\n//\n\n//-------------------------------------------------------------------\n// noise functions\n//-------------------------------------------------------------------\n\nvec2 grad( ivec2 z )\n{\n    // 2D to 1D (feel free to replace by some other)\n    int n = z.x*1 + z.y*113;\n    \n    // hash by Hugo Elias (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors (feel free to replace by another one)\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                      gr;\n}\n\n// gradient noise\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm( in vec2 p )\n{\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {\n        f += s*noise( p );\n        p = m*p;\n        s = 0.5*s;\n    }\n    return f;\n}\n\n//-------------------------------------------------------------------\n// math functions\n//-------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a; vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa-h*ba );\n}\n\n// compute the point where the altitude for vertex c intersects its base (a,b)\nvec2 altitude( vec2 c, vec2 a, vec2 b )\n{\n    vec2  w = b-a; \n    return a + w*dot(c-a,w)/dot(w,w);\n}    \n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// intersect lines (a1,b1) with line (a2,b2)\nvec2 intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2 )\n{\n    float h = cro(a1-a2,b1-a1)/cro(b2-a2,b1-a1);\n    return a2 + (b2-a2)*h;\n}\n    \n//-------------------------------------------------------------------\n// painting funtions\n//-------------------------------------------------------------------\n\nvec3 blackboard( in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 q = fragCoord/iResolution.xy;\n    \n    // ------\n    \n    float v = sqrt(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y));\n    vec3 col = vec3(0.1 + 0.05*v);\n\n    // ------\n        \n    col += 0.05*fbm(p*1.25*vec2(1.0,4.0));\n    col += 0.02*fbm(p*20.0);\n    \n    // ------\n\n    {\n    vec2 ce = vec2(2.0,-10.0);\n    vec2 w = 2.5*p-ce;\n    w = vec2(atan(w.y,w.x),length(w));\n    float ff = fbm(w*2.0*vec2(1.0,1.0));\n    float fa = smoothstep(1.5,1.0,abs(w.y+ce.y-0.7));\n    fa *= smoothstep(0.4,0.2,abs(w.x-1.8+0.5*ff));\n    col += v*0.06*smoothstep(-0.5,0.5,ff)*fa;\n    }\n\n    // ------\n    \n    float m = 0.0;\n    float m2 = 0.0;\n    for( int i=0; i<20; i++ )\n    {\n        vec2 p1 = vec2(3.0,2.0)*sin(float(i)*1.3+vec2(0,1) );\n        vec2 p2 = p1 + vec2(0.5,2.0)*sin(float(i)*11.1+vec2(2,4) );\n        float d = sdLine( 2.5*p+0.5*sin(2.5*p+float(i)*vec2(1.7,2.3)), p1, p2 );\n        d += 0.1*fbm(1.25*p);\n        float ww = fbm(1.75*p);\n        m = max( m, smoothstep(0.05,0.0,d) );\n        m2 = max( m2, smoothstep(0.2,-0.2,d-abs(ww)) );\n    }\n    col += v*0.01*m;\n    col += v*0.025*m2;\n\n    col += col.x*col.x*0.75*smoothstep(-0.2,0.2,fbm(p*82.0));\n\n    return col;\n}\n\nvec3 chalk( in vec3 col, in vec2 fragCoord )\n{\n    // vertices\n    vec2 p1 = vec2(2.25+0.70*sin(1.3*iTime),0.0); p1.y=1.0/p1.x;\n    vec2 p2 = vec2(-1.4+0.40*sin(1.1*iTime),0.0); p2.y=1.0/p2.x;\n    vec2 p3 = vec2(0.35+0.02*sin(1.9*iTime),0.0); p3.y=1.0/p3.x;\n\n    // start drawing\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 3.0;\n    p -= vec2(-0.3,-0.7);\n    \n    float gf = 0.6;\n    gf *= 0.9+0.2*smoothstep( -0.2,0.2,fbm(p.yx*10.0));\n\n    float d = 0.0;\n    \n    // draw graph\n    if( abs(p.x)>0.1 )\n    {\n    float x = p.x;\n    float y = 1.0/x;\n    float dy = -1.0/(x*x);\n    d = abs(p.y-y)/sqrt(1.0+dy*dy);\n    d += 0.03*fbm(p*2.5);\n    col = mix( col, 1.2*1.3*vec3(160,140,80)/255.0, gf*(1.0-smoothstep(0.01,0.03,d)) );\n    }\n\n    // draw axis\n    d = sdLine( p, vec2(0.0,-10.0), vec2(0.0,3.4) );\n    d = min( d, sdLine( p, vec2(-10.0,0.0), vec2(5.2,0.0) ) );\n    // draw arrow heads\n    d = min( d, sdLine( vec2(abs(p.x),p.y), vec2(0.07,3.2), vec2(0.0,3.4) ) );\n    d = min( d, sdLine( vec2(p.x,abs(p.y)), vec2(5.0,0.07), vec2(5.2,0.0) ) );\n    d += 0.02*fbm(p*2.5);\n    col = mix( col, 1.2*1.1*vec3(120,90,64)/255.0, gf*(1.0-smoothstep(0.01,0.03,d)) );\n\n    // draw edges\n    d = sdLine( p, p1, p2 );\n    d = min( d, sdLine( p, p2, p3 ) );\n    d = min( d, sdLine( p, p3, p1 ) );\n    d += 0.03*fbm(p*2.5);\n    col = mix( col, 1.2*1.4*vec3(110,150,65)/255.0, gf*(1.0-smoothstep(0.01,0.03,d)) );\n\n    // draw altitudes\n    vec2 q1 = altitude( p1, p2, p3 );\n    vec2 q2 = altitude( p2, p3, p1 );\n    vec2 q3 = altitude( p3, p1, p2 );\n    d = sdLine( p, p1, q1 );\n    d = min( d, sdLine( p, p2, q2 ) );\n    d = min( d, sdLine( p, p3, q3 ) );\n\n    // draw angles\n    vec2 o1 = normalize(p1-q1)*0.18;\n    vec2 o2 = normalize(p2-q2)*0.18;\n    vec2 o3 = normalize(p3-q3)*0.18;\n    d = min( d, sdLine( p, q1+vec2(o1.x+o1.y,o1.y-o1.x), q1+vec2(o1.x, o1.y)) );\n    d = min( d, sdLine( p, q1+vec2(o1.x+o1.y,o1.y-o1.x), q1+vec2(o1.y,-o1.x)) );\n    d = min( d, sdLine( p, q2+vec2(o2.x+o2.y,o2.y-o2.x), q2+vec2(o2.x, o2.y)) );\n    d = min( d, sdLine( p, q2+vec2(o2.x+o2.y,o2.y-o2.x), q2+vec2(o2.y,-o2.x)) );\n    d = min( d, sdLine( p, q3+vec2(o3.x+o3.y,o3.y-o3.x), q3+vec2(o3.x, o3.y)) );\n    d = min( d, sdLine( p, q3+vec2(o3.x+o3.y,o3.y-o3.x), q3+vec2(o3.y,-o3.x)) );\n    \n    d += 0.03*fbm(p*2.5);\n    col = mix( col, 1.2*1.25*vec3(70,100,70)/255.0, gf*(1.0-smoothstep(0.01,0.03,d)) );\n\n    // draw ortho center\n    vec2 pc = intersect(p1,q1,p2,q2);\n    d = length(p-pc) - 0.08;\n    d += 0.05*fbm((p-pc)*8.0);\n    col = mix( col, 1.1*vec3(140,200,60)/255.0, (1.0-smoothstep(0.01,0.03,d)) );\n    \n    // draw vertices\n    d = min( min( length(p-p1), length(p-p2) ), length(p-p3) ) - 0.06;\n    d += 0.07*fbm(p*4.0);\n    col = mix( col, 1.1*vec3(255,240,8)/255.0, (1.0-smoothstep(0.01,0.03,d)) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = blackboard(fragCoord);\n    \n    col = chalk( col, fragCoord);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 511, 564, 952], [954, 972, 998, 998, 1380], [1382, 1421, 1445, 1445, 1653], [1814, 1865, 1914, 1914, 2036], [2038, 2117, 2158, 2158, 2218], [2224, 2224, 2259, 2259, 2287], [2289, 2334, 2388, 2388, 2466], [2634, 2634, 2672, 2672, 3898], [3900, 3900, 3946, 3962, 6730], [6732, 6732, 6789, 6789, 6900]]}
{"id": "NdSBWw", "name": "Rainbow Alien Noise", "author": "leon", "description": "Gyroid acid micro landscape", "tags": ["noise", "loop", "weird", "gyroid"], "likes": 31, "viewed": 596, "published": 3, "date": "1646350799", "time_retrieved": "2024-07-30T17:00:21.572227", "image_code": "\n// Rainbow Alien Noise by Leon Denise 2022/03/04\n// variation of https://www.shadertoy.com/view/NsBfW1\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini, Shane and many more\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat map(vec3 p);\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z); }\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos) {\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx))); }\n\n// Shane\nfloat sAbs(float x, float c){ return sqrt(x*x + c); }\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor, in float scale) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float h = 0.001 + scale*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// geometry\nfloat map(vec3 p) {\n  float dist = p.y;\n  float scale = 3.;\n  float gyroid = 100.;\n  float a = 1.0;\n  float t = iTime*1.;\n  float w = sin(iTime+length(p)*3.);\n  float b = .1+.2*w;\n  // fractalish gyroid accumulation\n  for (float i = 0.; i < 3.; ++i) {\n    vec3 s = p*scale/a;\n    s.y += t+p.z/a;\n    gyroid = smin(gyroid, sAbs(dot(sin(s), cos(s.yzx))/scale*a, .00015) - b*a, 1.*a);\n    a /= 3.;\n  }\n  b = .3+.2*w;\n  dist = smin(dist, gyroid, -b);\n  return dist;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    // coordinates\n    vec2 p = (pixel.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 pos = vec3(0,1,1.5);\n    vec3 z = normalize(-pos);\n    vec3 x = cross(z, vec3(0,1,0));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(z * 1.5 + x * p.x + y * p.y);\n    float rng = hash12(pixel);\n    // raymarch\n    float shade = 1.;\n    for (shade; shade > 0.; shade -= 1./40.) {\n        float d = map(pos);\n        if (d < .001) break;\n        d *= .9+.1*rng;\n        pos += ray * d;\n    }\n    // color\n    vec3 normal = getNormal(pos);\n    float rn = abs(dot(ray,normal));\n    float lp = length(pos);\n    vec3 rainbow = .5+.5*cos(vec3(.0,.3,.6)*6.28 + lp + iTime);\n    vec3 tint = (1.-rn)*(normal*.5+.5)*.5;\n    tint += vec3(.3)*pow(rn,3.);\n    tint += rn*rainbow*getAO(pos, normal, 0.2);\n    color = vec4(tint*shade, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 236, 236, 281], [302, 359, 381, 381, 498], [500, 565, 608, 608, 707], [709, 771, 798, 798, 925], [927, 936, 965, 965, 989], [991, 1048, 1104, 1104, 1388], [1390, 1402, 1421, 1421, 1865], [1868, 1868, 1917, 1936, 2737]]}
{"id": "7s2fDD", "name": "Fractal 2398129312", "author": "SnoopethDuckDuck", "description": "Can never get the colors quite right. Technique is just 3 2D fractals (1 for each axis) extended into columns, removed from a sphere (stole the idea from someone else but cant remember name)", "tags": ["e"], "likes": 4, "viewed": 248, "published": 3, "date": "1646346829", "time_retrieved": "2024-07-30T17:00:22.323219", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = (0.51 + 0.5 * thc(6., 0.2 * iTime)) * 1.8 * vec3(0, 1, -1);\n   \n    \n    float t = 0.2 * iTime;\n    float o = 2. * pi / 3.;\n    \n    //vec3 ro = 0.1 * vec3(cos(t-o), cos(t), cos(t+o)); //2.6\n  //  ro = vec3(0,4.4,1.);\n   ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 getRa() {\n   return vec3(0);\n    return vec3(0, 1, 0);\n}\n\nvec2 op1(vec2 p, float m) {\n    p *= 1. + 0.125 * m;\n    //p *= Rot(0. * length(p) + 0. * iTime);\n    return abs(p) - m;\n}\n\nfloat op2(float l, vec2 p, float r) {\n\n    return min(l + 0.125 * (abs(p.x) + abs(p.y)), length(p) - 0.75 * r);\n\n    //return (0.5 + 0.5 * cos(pi * l - iTime)) * min(l, length(p) - r);\n}\n\nvec2 op3(vec2 p, float a) {\n    return p * Rot(a);\n}\n\nfloat GetDist(vec3 p) {\n   \n    float r1 = 0.;\n    float r2 = 0.1;\n    \n    vec2 xy = p.xy, yz = p.yz, zx = p.zx;\n    float m = sqrt(2.) / 2.;\n    float dxy = length(xy) - m, dyz = length(yz) - m, dzx = length(zx) - m;\n    for (float i = 0.; i < 6.; i++) {  \n        float io = 2. * pi * i / 6.;\n        //m *= 0.5 + 0.5 * cos(iTime);\n        xy = op1(xy, m), yz = op1(yz, m), zx = op1(zx, m);    \n        m *= 0.45 + 0.05 * cos(8. * mlength(p) + io + iTime);\n        float r = m;\n        dxy = op2(dxy, xy, r), dyz = op2(dyz, yz, r), dzx = op2(dzx, zx, r);\n    }\n    \n    float d = min(min(dxy, dyz), dzx);\n    \n    float d2 = length(p) - 1.48;\n    d2 = -min(d, -d2);\n    \n\n    //d = max(d - r2, length(p) - 1. + 0.5 * cos(2. * length(p) + iTime));\n   // d = min(d, d2);\n   \n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    vec3 ra = getRa();\n    \n    vec3 rd = GetRayDir(uv, ro, ra, 1.4);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1.);\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 1.5); \n        col *= fresnel2;\n        \n        //col *= 0.5 + 0.5 * n;\n       \n        col = clamp(col, 0., 1.);\n        vec3 e = vec3(1);\n        col *= pal(n.y, e, e, e, 0.35 * vec3(0,1,2)/3.);\n        col += 0.15 * n.y;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2fDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 649, 649, 1000], [1002, 1002, 1016, 1016, 1063], [1065, 1065, 1092, 1092, 1187], [1189, 1189, 1226, 1226, 1375], [1377, 1377, 1404, 1404, 1429], [1431, 1431, 1454, 1454, 2223], [2225, 2225, 2268, 2268, 2502], [2504, 2504, 2528, 2528, 2718], [2720, 2720, 2770, 2770, 2961], [2963, 2963, 3020, 3020, 4152]]}
{"id": "sdjfDD", "name": "snake pattern", "author": "loryruta", "description": "cool snake pattern? i guess?", "tags": ["snakescalepattern"], "likes": 1, "viewed": 174, "published": 3, "date": "1646346118", "time_retrieved": "2024-07-30T17:00:23.131059", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    const vec2 rep_each = vec2(0.07, 0.07);\n    const float line_r = 0.1;\n    const float curve = 2.0;\n   \n    float li = mod(floor(uv.y / rep_each.y), 2.0);\n   \n    float re = abs(mod(floor(uv.x / rep_each.x), 2.0) - li);\n    float le = 1.0 - re;\n   \n    float lv = exp(-curve * mod(uv.x, rep_each.x) / rep_each.x) * rep_each.y;\n    float rv = exp(curve * (mod(uv.x, rep_each.x) / rep_each.x - 1.0)) * rep_each.y;\n   \n    float d = mod(uv.y, rep_each.y) - (lv * le + rv * re);\n    float be = 1.0 - clamp(ceil(abs(d / rep_each.y) - line_r), 0.0, 1.0);\n    \n    vec3 c1 = vec3(0.17, 0.6, 0.23);\n    vec3 c2 = vec3(0.11, 0.27, 0.14);\n    \n    fragColor = vec4(mix(c1, c2, be), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 60, 789]]}
{"id": "7sjfWD", "name": "BuzzyVRTest", "author": "antoinefortin", "description": "yo", "tags": ["yo"], "likes": 1, "viewed": 194, "published": 3, "date": "1646343943", "time_retrieved": "2024-07-30T17:00:23.882051", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    uv.x -=0.5 + abs(sin((m.x * 5.0f)));\n    uv.y -=.5 + abs(sin((m.y * 5.0f)));;\n    uv *= 2.;  \n    uv.x = uv.x * ( iResolution.x / iResolution.y);\n \n    float pixel_angle = atan(uv.x,uv.y * 2.) ;\n    float pixel_distance =  length(uv * sin(uv.x + iTime))* 12.0 ;\n    vec2 st = vec2(pixel_angle , pixel_distance); \n    vec3 c = vec3(abs(sin(st.x) * abs(sin(iTime))), abs(cos(st.y)), abs(sin(cos(st.x * st.y))));\n    vec3 c2 = vec3(\n    atan(abs(length(c.r * .04)), \n            c.g * sin(c.b))) * (1.0f-abs(uv.x)  \n            \n    );\n    vec3 col = 1.f -(c + abs(sin(st.x * c2)));\n    col.r -= .5;\n    col *= col * c2 + col;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 831]]}
{"id": "ssjfWD", "name": "Sparkling Video", "author": "lwswl", "description": "The distance to the lightest part in the pixels area, place a light there. ", "tags": ["video", "processing", "sparkles", "distances"], "likes": 6, "viewed": 586, "published": 3, "date": "1646343643", "time_retrieved": "2024-07-30T17:00:24.636035", "image_code": "\n#define f (fragColor.rgb)\n#define uv(x) (fragCoord+x)/iResolution.xy\n#define size 8\n#define strength 4.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    f=texture(iChannel0,uv(0.)).rgb;\n    vec2 brightest=vec2(0);\n    float len=length(texture(iChannel0,uv(0.)).rgb);\n    int toosame=0;\n    for(int i=-size;i<size;i++)\n    for(int j=-size;j<size;j++){\n        float nlen=length(texture(iChannel0,uv(vec2(i,j))).rgb);\n        if(abs(nlen-len)<0.01)toosame++;\n        if (nlen>len){\n            brightest=vec2(i,j);\n            len=nlen;\n        }\n        \n    }\n    if(toosame<size)f+=strength/dot(brightest,brightest);\n    \n    \n    \n    \n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 163, 659]]}
{"id": "7sjBWD", "name": "sRGB vs gamma encoding 2", "author": "ttg", "description": "sRGB is [b]NOT[/b] the same thing as 2.2 gamma !  The error is significant for images with dark tones.\n\nIf top half of image appears consistent: you have true sRGB display pipeline.\nIf bottom half consistent: you have gamma=2.2 (fake sRGB) display.", "tags": ["gamma", "srgb", "srgbvspow"], "likes": 4, "viewed": 2807, "published": 3, "date": "1646342276", "time_retrieved": "2024-07-30T17:00:25.466814", "image_code": "/*\nPlease read full description here:\n\nsRGB is *NOT* the same thing as 2.2 gamma !\nThe error is significant for images with dark tones.\n\nYes, the image should be that dark.\nTry dark theme or fullscreen if you have trouble seeing it.\n\nIf you see any moire patterns, you are on mobile or Mac, or have a calibration\nproblem or screen scaling setting, and the test cannot be used.\n\nIf the top two strips appear consistent in intensity:\n  You have true sRGB (most common standard) display pipeline.\nIf bottom two appear consistent in intensity:\n  You have gamma=2.2 (unfortunately common fake sRGB) display.\n\nExplanation:\n\nThe image is divided into four strips.\nEach represents the same red-green linear gradient.\n\nThe inner two drop into the linear portion of sRGB luminosity encoding curve.\nThe outer two avoid this portion by using a higher value range with halftone\npattern.\n\nThe top half of the image is output with sRGB luminosity encoding.\nThe bottom half is output with gamma 2.2 response encoding.\n\nThe extreme darkness of the image is as intended, the error in difference of\nthese encodings becomes significant in this range.\nBanding is expected and does not make the comparison invalid.\n\nIf you get something other than sRGB consistency, this does not necessarily\nmean your computer is incapable of displaying photographs on the web correctly.\nThere's some chance the deficiency affects only WebGL:  The standard for HTML\ncanvas fails to specify any color space, or even a means of specifying one.\nBrowser developers use this nonstandardization as an excuse to not implement\ncolor management for HTML canvas.\n \nThis can be a problem for WebGL content with wide dynamic luminosity range\n(artistic intent, not to be confused with high-dynamic-range standards) not\nappearing as intended: the distortion to dark colors and values is similar to \nthat of inappropriate gamma corrections for bright images: At the bottom of the\nrange, the gamma of sRGB is NOT 2.2, it is exactly 1.0 !\n\n*/\n\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n\nvoid mainImage (out vec4 d, vec2 f) {\n#define HALFTONE(p) float(int(dot(floor(f),vec2(413,229)))%512<int((p)*512.))\n  vec2 uv = f/iResolution.xy;\n  vec3 col = mix(vec3(1,0,0),vec3(0,1,0),uv.x);\n  col*=.005;\n  if (abs(uv.y*2.-1.)>.5) {\n    col*=3.*HALFTONE(1./3.);\n  }\n  if (uv.y>.5) d.rgb = srgb_encode(col);\n  else         d.rgb = pow(col,vec3(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1989, 1989, 2016, 2016, 2099], [2101, 2101, 2138, 2138, 2457]]}
{"id": "7d2fDW", "name": "Appolloian with a twist II", "author": "mrange", "description": "CC0: Appolloian with a twist II\n  Playing around with shadows in 2D\n  Needed a somewhat more complex distance field than boxes\n  The appolloian fractal turned out quite nice\n", "tags": ["2d", "fractal"], "likes": 55, "viewed": 1413, "published": 3, "date": "1646339794", "time_retrieved": "2024-07-30T17:00:26.254708", "image_code": "// CC0: Appolloian with a twist II\n//  Playing around with shadows in 2D\n//  Needed a somewhat more complex distance field than boxes\n//  The appolloian fractal turned out quite nice so while\n//  similar to an earlier shader of mine I think it's\n//  distrinctive enough to share\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define MAX_MARCHES 30\n#define TOLERANCE   0.0001\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nconst mat2 rot0 = ROT(0.0);\nmat2 g_rot0 = rot0;\nmat2 g_rot1 = rot0;\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apolloian(vec3 p, float s, out float h) {\n  float scale = 1.0;\n  for(int i=0; i < 5; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  vec3 ap = abs(p/scale);  \n  float d = length(ap.xy);\n  d = min(d, ap.z);\n\n  float hh = 0.0;\n  if (d == ap.z){\n    hh += 0.5;\n  }\n  h = hh;\n  return d;\n}\n\nfloat df(vec2 p, out float h) {\n  const float fz = 1.0-0.0;\n  float z = 1.55*fz;\n  p /= z;\n  vec3 p3 = vec3(p,0.1);\n  p3.xz*=g_rot0;\n  p3.yz*=g_rot1;\n  float d = apolloian(p3, 1.0/fz, h);\n  d *= z;\n  return d;\n}\n\nfloat shadow(vec2 lp, vec2 ld, float mint, float maxt) {\n  const float ds = 1.0-0.4;\n  float t = mint;\n  float nd = 1E6;\n  float h;\n  const float soff = 0.05;\n  const float smul = 1.5;\n  for (int i=0; i < MAX_MARCHES; ++i) {\n    vec2 p = lp + ld*t;\n    float d = df(p, h);\n    if (d < TOLERANCE || t >= maxt) {\n      float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n      return t >= maxt ? mix(sd, 1.0, smoothstep(0.0, 0.025, nd)) : sd;\n    }\n    nd = min(nd, d);\n    t += ds*d;\n  }\n  float sd = 1.0-exp(-smul*max(t/maxt-soff, 0.0));\n  return sd;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  float a = 0.1*TIME;\n  g_rot0 = ROT(0.5*a); \n  g_rot1 = ROT(sqrt(0.5)*a);\n\n  vec2  lightPos  = vec2(0.0, 1.0);\n  lightPos        *= (g_rot1);\n  vec2  lightDiff = lightPos - p;\n  float lightD2   = dot(lightDiff,lightDiff);\n  float lightLen  = sqrt(lightD2);\n  vec2  lightDir  = lightDiff / lightLen;\n  vec3  lightPos3 = vec3(lightPos, 0.0);\n  vec3  p3        = vec3(p, -1.0);\n  float lightLen3 = distance(lightPos3, p3);\n  vec3  lightDir3 = normalize(lightPos3-p3);\n  vec3  n3        = vec3(0.0, 0.0, 1.0);\n  float diff      = max(dot(lightDir3, n3), 0.0);\n\n  float h;\n  float d   = df(p, h);\n  float ss  = shadow(p,lightDir, 0.005, lightLen);\n  vec3 bcol = hsv2rgb(vec3(fract(h-0.2*length(p)+0.25*TIME), 0.666, 1.0));\n\n  vec3 col = vec3(0.0);\n  col += mix(0., 1.0, diff)*0.5*mix(0.1, 1.0, ss)/(lightLen3*lightLen3);\n  col += exp(-300.0*abs(d))*sqrt(bcol);\n  col += exp(-40.0*max(lightLen-0.02, 0.0));\n \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col *= mix(0.0, 1.0, smoothstep(0.0, 4.0, TIME));\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2fDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 676, 697, 697, 770], [771, 871, 893, 893, 942], [1096, 1096, 1118, 1118, 1264], [1266, 1266, 1313, 1313, 1644], [1646, 1646, 1677, 1677, 1857], [1859, 1859, 1915, 1915, 2408], [2410, 2410, 2439, 2439, 3390], [3392, 3392, 3447, 3447, 3678]]}
{"id": "ssSfzw", "name": "Cartoon landscape", "author": "loryruta", "description": "a cool terrain to test camera lighting and stuff", "tags": ["landscape"], "likes": 8, "viewed": 346, "published": 3, "date": "1646336723", "time_retrieved": "2024-07-30T17:00:27.187214", "image_code": "#define CAM_FLOATING_HEIGHT 1.0\n\n#define PI 3.14\n#define EPSILON 0.00001\n\n#define RAY_MARCH_MAX_ITER 256\n#define RAY_MARCH_INIT_STEP 0.1\n#define RAY_MARCH_STOP_APPROX 0.001\n\n#define ERR_COLOR vec3(1, 0, 0)\n\n#define SKY_COLOR vec3(0.27, 0.55, 1.0)\n\n#define TERRAIN_GRASS_METALLIC_ROUGHNESS vec2(0.1, 0.8)\n\n#define TERRAIN_ROCK_ALBEDO vec3(0.46, 0.29, 0.09)\n#define TERRAIN_ROCK_MATERIAL vec2(0.1, 0.2)\n\n#define TREE_AABB_SIZE vec3(3.5, 4.0, 3.5)\n\n#define TREE_TRUNK_HEIGHT 1.5\n#define TREE_TRUNK_RADIUS 0.2\n#define TREE_TRUNK_ALBEDO vec3(0.46, 0.29, 0.09)\n#define TREE_TRUNK_METALLIC_ROUGHNESS vec2(0.7, 0.3)\n\n#define TREE_FOLIAGE_HEIGHT 1.6\n#define TREE_FOLIAGE_RADIUS 1.0\n#define TREE_FOLIAGE_ALBEDO vec3(0.17, 0.6, 0.23)\n#define TREE_DARK_FOLIAGE_ALBEDO vec3(0.11, 0.27, 0.14)\n#define TREE_FOLIAGE_METALLIC_ROUGHNESS vec2(0.1, 0.9)\n\n#define SUNLIGHT_COLOR vec3(1.0, 1.0, 0.4)\n#define SUNLIGHT_DIR normalize(vec3(0, -1, 1))\n\n#define NO_HIT -1\n#define HIT_TERRAIN 0x00\n#define HIT_TREE_BB 0x10\n#define HIT_TREE_TRUNK 0x11\n#define HIT_TREE_FOLIAGE 0x12\n// ...\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\nvec2 sphere_uv(vec3 n)\n{\n    return vec2(\n        atan(n.x, n.z) / (2.0 * PI) + 0.5,\n        n.y * 0.5 + 0.5\n    );\n}\n\nfloat snake_pattern(vec2 repeat_each, float curve_strength, vec2 uv)\n{\n    float li = mod(floor(uv.y / repeat_each.y), 2.0);\n   \n    float re = abs(mod(floor(uv.x / repeat_each.x), 2.0) - li);\n    float le = 1.0 - re;\n   \n    float lv = exp(-curve_strength * mod(uv.x, repeat_each.x) / repeat_each.x) * repeat_each.y;\n    float rv = exp(curve_strength * (mod(uv.x, repeat_each.x) / repeat_each.x - 1.0)) * repeat_each.y;\n   \n    float d = mod(uv.y, repeat_each.y) - (lv * le + rv * re);\n    float dw = d / repeat_each.y;\n    \n    return dw;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Terrain\n// ------------------------------------------------------------------------------------------------\n\nfloat get_terrain_height_norm(vec2 p)\n{\n    return noise(p * 0.3);\n}\n\nfloat get_terrain_height(vec2 p)\n{\n    return get_terrain_height_norm(p) * 3.0;\n}\n\nvec3 get_terrain_norm(vec2 p)\n{\n    float cur_h = get_terrain_height(p);\n   \n    vec3 d1 = vec3(0, get_terrain_height(p + vec2(0, EPSILON)) - cur_h, EPSILON);\n    vec3 d2 = vec3(EPSILON, get_terrain_height(p + vec2(EPSILON, 0)) - cur_h, 0);\n    \n    return normalize(cross(d1, d2));\n}\n\nvec2 get_terrain_uv(vec2 p)\n{\n    return mod(p, vec2(1.0));\n}\n\nvoid get_terrain_material(vec2 p, out vec3 mat_albedo, out vec2 mat_metallic_roughness)\n{\n    const float k_line_width = 0.04;\n    const vec2 k_repeat_each = vec2(0.6);\n    const vec3 k_grass_color = vec3(0.17, 0.6, 0.23);\n    const vec3 k_darker_grass_color = vec3(0.11, 0.27, 0.14);\n\n    float h = get_terrain_height_norm(p);\n    float tm = 0.5 + (noise(p) * 2.0 - 1.0) * 0.15;\n    float bm = 0.2 + (noise(p) * 2.0 - 1.0) * 0.15;\n\n    float grass_enable = clamp(ceil(h - tm), 0.0, 1.0) + clamp(ceil(bm - h), 0.0, 1.0);\n    float rock_enable = 1.0 - grass_enable;\n    \n    vec2 uv = get_terrain_uv(p);\n    \n    float grass_border_enable = clamp(ceil(0.05 - abs(h - tm)) + ceil(0.05 - abs(h - bm)), 0.0, 1.0);\n    \n    vec3 grass_color =\n        k_grass_color * (1.0 - grass_border_enable) + k_darker_grass_color * grass_border_enable;\n    \n    mat_albedo = mix(TERRAIN_ROCK_ALBEDO, grass_color, grass_enable);\n    mat_metallic_roughness = grass_enable * vec2(0.2, 0.8) + rock_enable * vec2(0.2, 0.8);\n}\n\n\n// ------------------------------------------------------------------------------------------------\n// Tree\n// ------------------------------------------------------------------------------------------------\n\nbool hasTreeAt(vec2 p)\n{\n    return rand(floor(p / TREE_AABB_SIZE.xz)) >= 0.7;\n}\n\nvec3 get_tree_pos(vec3 p)\n{\n    vec3 tree_pos;\n    tree_pos.xz = floor(p.xz / TREE_AABB_SIZE.xz) * TREE_AABB_SIZE.xz + TREE_AABB_SIZE.xz / 2.0;\n    tree_pos.y = get_terrain_height(tree_pos.xz);\n    return tree_pos;\n}\n\nbool ray_hit_tree_aabb(vec3 p)\n{\n    float baseY = get_terrain_height(p.xz);\n    return hasTreeAt(p.xz) && p.y - baseY <= TREE_AABB_SIZE.y;\n}\n\nint ray_hit_tree_test(vec3 ro, vec3 rd, vec3 tree_pos, out float hit_t, out vec3 hit_norm)\n{\n    vec3 foliage_center = tree_pos + vec3(0, TREE_FOLIAGE_HEIGHT, 0);\n    vec3 trunk_from = tree_pos;\n    vec3 trunk_to = tree_pos + vec3(0, TREE_TRUNK_HEIGHT, 0);\n   \n    hit_t = sphIntersect(ro, rd, foliage_center, TREE_FOLIAGE_RADIUS).x;\n    if (hit_t >= 0.0)\n    {\n        hit_norm = normalize((ro + rd * hit_t) - foliage_center);\n        return HIT_TREE_FOLIAGE;\n    }\n    \n    hit_t = cylIntersect(ro, rd, trunk_from, trunk_to, TREE_TRUNK_RADIUS).x;\n    if (hit_t >= 0.0)\n    {\n        return HIT_TREE_TRUNK;\n    }\n    \n    return NO_HIT;  \n}\n\nvec3 get_foliage_color(vec3 n)\n{\n    vec2 uv = sphere_uv(n);\n    \n    const vec2 repeat_each = vec2(0.025, 0.1);\n    const float line_width = 3.0;\n    \n    float d = snake_pattern(repeat_each, line_width / 2.0, uv);\n    float be = 1.0 - clamp(ceil(abs(d / 0.07) - 2.0), 0.0, 1.0);\n    \n    return mix(TREE_FOLIAGE_ALBEDO, TREE_DARK_FOLIAGE_ALBEDO, be);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Camera\n// ------------------------------------------------------------------------------------------------\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1, 0, 0,\n        0, cos(a), -sin(a),\n        0, sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0, sin(a),\n        0, 1, 0,\n        -sin(a), 0, cos(a)\n    );\n}\n\nmat3 rotAroundAxis(vec3 axis, float a)\n{\n    axis = normalize(axis);\n    float s = sin(a);\n    float c = cos(a);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nvec3 getCameraPos(float t)\n{\n    vec3 p;\n    p.xz = vec2(0, t);\n    p.y = get_terrain_height(p.xz) + CAM_FLOATING_HEIGHT;\n    return p;\n}\n\nmat3 getCameraDir(float t)\n{\n    float yaw = 0.0;\n    float pitch = 0.0;\n    return rotY(yaw) * rotX(pitch);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Ray marching\n// ------------------------------------------------------------------------------------------------\n\n/** This function is used to enhance the ray marched position of the terrain collision. */\nvoid ray_march_terrain(vec3 ro, vec3 rd, inout float hit_t, out vec3 hit_norm)\n{\n    float curStep = RAY_MARCH_INIT_STEP;\n    \n    float t = hit_t;\n    \n    int iter = 0;\n    while (curStep > RAY_MARCH_STOP_APPROX && iter < RAY_MARCH_MAX_ITER)\n    {\n        vec3 ray_pos = ro + rd * t;\n        \n        if (ray_pos.y < get_terrain_height(ray_pos.xz))\n        {\n            hit_t = t;\n            hit_norm = get_terrain_norm(ray_pos.xz);\n        \n            t -= curStep;\n            curStep /= 2.0;\n\n            if (t < 0.0) {\n                return;\n            }\n        }\n\n        t += curStep;\n        iter++;\n    }\n}\n\nint ray_march(vec3 ro, vec3 rd, out float hit_t, out vec3 hit_norm)\n{\n    float t = 0.0;\n\n    int hit = NO_HIT;\n    \n    int iter = 0;\n    while (iter < RAY_MARCH_MAX_ITER)\n    {\n        vec3 ray_pos = ro + rd * t;\n        hit_t = t;\n\n        if (ray_pos.y < get_terrain_height(ray_pos.xz))\n        {\n            ray_march_terrain(ro, rd, hit_t, hit_norm);\n            return HIT_TERRAIN;\n        }\n\n        // If the intersection happens between the ray and the tree's AABB,\n        // then we have to check whether the collision actually happened with the tree\n        // if so we can return the exact hit position.\n        if (ray_hit_tree_aabb(ray_pos))\n        {\n            int hit = ray_hit_tree_test(ro, rd, get_tree_pos(ray_pos), hit_t, hit_norm);\n            if (hit != NO_HIT) {\n                return hit;\n            }\n        }\n        \n        t += RAY_MARCH_INIT_STEP; // always increment of a fixed step here\n   \n        iter++;\n    }\n    \n    return hit;\n}\n\n// ------------------------------------------------------------------------------------------------\n// PBR\n// ------------------------------------------------------------------------------------------------\n\n// https://learnopengl.com/PBR/Theory\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n  \nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 F_r(vec3 V, vec3 L, vec3 N, vec3 mat_albedo, vec2 mat_metallic_roughness)\n{\n    vec3 H = normalize(V + L);\n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, mat_metallic_roughness.y);        \n    float G   = GeometrySmith(N, V, L, mat_metallic_roughness.y);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, mat_albedo, mat_metallic_roughness.x);\n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - mat_metallic_roughness.x;\t \n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n    \n    // lambert bdrf\n    vec3 diffuse = kD * mat_albedo / PI;\n    return diffuse + specular;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Lighting\n// ------------------------------------------------------------------------------------------------\n\nint is_sun_occluded(vec3 p, out float occ_hit_t, out vec3 occ_hit_norm)\n{\n    return ray_march(p, -SUNLIGHT_DIR, occ_hit_t, occ_hit_norm);\n}\n\nvec3 shade(int hit, vec3 ro, vec3 rd, float hit_t, vec3 hit_norm)\n{\n    vec3 hit_pos = ro + rd * hit_t;\n\n    vec3 hit_albedo;\n    vec2 hit_metallic_roughness;\n    \n    if (hit == HIT_TERRAIN)\n    {\n        get_terrain_material(hit_pos.xz, hit_albedo, hit_metallic_roughness);\n    }\n    else if (hit == HIT_TREE_TRUNK)\n    {\n        hit_albedo = TREE_TRUNK_ALBEDO;\n        hit_metallic_roughness = TREE_TRUNK_METALLIC_ROUGHNESS;\n    }\n    else if (hit == HIT_TREE_FOLIAGE)\n    {\n        hit_albedo = get_foliage_color(hit_norm);\n        hit_metallic_roughness = TREE_FOLIAGE_METALLIC_ROUGHNESS;\n    }\n    else\n    {\n        hit_albedo = ERR_COLOR;\n        hit_metallic_roughness = vec2(0, 1);\n    }\n\n    // Shadowing\n    float occ_hit_t;\n    vec3 occ_hit_norm;\n    \n    bool occluded = false;\n    occluded = occluded || (is_sun_occluded(ro + rd * (hit_t - 0.01), occ_hit_t, occ_hit_norm) != NO_HIT);\n\n    // Lighting\n    //vec3 hit_albedo = TERRAIN_GRASS_ALBEDO;\n    //vec2 hit_metallic_roughness = TERRAIN_GRASS_METALLIC_ROUGHNESS;\n    \n    vec3 light_dir = SUNLIGHT_DIR;\n    vec3 light_col = SUNLIGHT_COLOR;\n    \n    vec3 tot_light = vec3(0);\n    \n    if (!occluded)\n    {\n        tot_light +=\n            F_r(-rd, -light_dir, hit_norm, hit_albedo, hit_metallic_roughness) *\n            light_col *\n            max(dot(hit_norm, -light_dir), 0.0);\n    }\n\n    vec3 ambient = vec3(0.03) * hit_albedo;\n    vec3 color = ambient + tot_light;\n\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0 / 2.2));\n\n    return color;\n}\n\n// ------------------------------------------------------------------------------------------------\n// Main\n// ------------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_pos = (fragCoord / iResolution.xy * 2.0) - 1.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    const float fov = PI / 4.0; // 45°\n    \n    vec3 camPos = getCameraPos(iTime);\n    mat3 camDir = getCameraDir(iTime);\n    \n    vec3 camForward = camDir[2];\n    vec3 camUp = camDir[1];\n    vec3 camRight = camDir[0];\n    \n    vec3 camRay = camForward;\n    camRay = rotAroundAxis(camUp, screen_pos.x * fov) * camRay;\n    camRay = rotAroundAxis(camRight, screen_pos.y * (fov / aspect_ratio)) * camRay;\n    \n    float hit_t;\n    vec3 hit_norm;\n    int hit = ray_march(camPos, camRay, hit_t, hit_norm);\n    if (hit == NO_HIT) {\n        fragColor = vec4(SKY_COLOR, 1.0);\n    } else {\n        fragColor = vec4(shade(hit, camPos, camRay, hit_t, hit_norm), 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1060, 1060, 1080, 1080, 1146], [1148, 1148, 1169, 1169, 1378], [1380, 1380, 1447, 1447, 1665], [1667, 1667, 1746, 1746, 2393], [2395, 2395, 2419, 2419, 2512], [2514, 2514, 2584, 2584, 3056], [3270, 3270, 3309, 3309, 3338], [3340, 3340, 3374, 3374, 3421], [3423, 3423, 3454, 3454, 3707], [3709, 3709, 3738, 3738, 3770], [3772, 3772, 3861, 3861, 4775], [4987, 4987, 5011, 5011, 5067], [5069, 5069, 5096, 5096, 5285], [5287, 5287, 5319, 5319, 5428], [5430, 5430, 5522, 5522, 6071], [6073, 6073, 6105, 6105, 6427], [6640, 6640, 6660, 6660, 6757], [6759, 6759, 6779, 6779, 6876], [6878, 6878, 6918, 6918, 7380], [7382, 7382, 7410, 7410, 7519], [7521, 7521, 7549, 7549, 7631], [7850, 7941, 8021, 8021, 8563], [8565, 8565, 8634, 8634, 9539], [9788, 9788, 9844, 9844, 10111], [10113, 10113, 10169, 10169, 10324], [10328, 10328, 10390, 10390, 10608], [10610, 10610, 10656, 10656, 10713], [10715, 10715, 10795, 10795, 11517], [11732, 11732, 11805, 11805, 11872], [11874, 11874, 11941, 11941, 13415], [13626, 13626, 13682, 13682, 14473]]}
{"id": "7djBWW", "name": "Nice Function 12309123801", "author": "SnoopethDuckDuck", "description": "cc() is the function\n\ncan replace f = thc(a,b) with f = cos(b) and still looks good", "tags": ["e"], "likes": 6, "viewed": 195, "published": 3, "date": "1646335412", "time_retrieved": "2024-07-30T17:00:27.948180", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n#define pi 3.14159\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float t = 1. * iTime;\n    \n    float sc = 24. + 16. * cc(1., iTime);\n    float ix = floor(sc * uv.x) + 0.5;\n    float fx = fract(sc * uv.x) - 0.5;\n    uv.y *= sc;\n    \n    float s = 0.;\n    float sp = 0.2;\n    t += sp * ix;   \n    \n    // a bit sloppy, just an example\n    float n = 20.;\n    for (float i = 0.; i < n; i++) {\n        float v = 1. * (n - i) / n; // 5.\n        float y = cc(v, t);\n\n        vec2 p = 2. * sp * sc * vec2(0, y);\n            \n        float d = length(vec2(fx, uv.y) - p);\n        s = max(s, smoothstep(-0.02, 0.02, -abs(d - 0.4) + 0.15));     \n    }\n\n    vec3 col = vec3(s, 0.11, 0.18);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 89, 89, 156], [158, 158, 215, 215, 942]]}
{"id": "fdjBWD", "name": "Glowing Orb", "author": "lwswl", "description": "an orb", "tags": ["sphere", "volumes"], "likes": 10, "viewed": 608, "published": 3, "date": "1646325528", "time_retrieved": "2024-07-30T17:00:28.706153", "image_code": "float sphere(vec3 p, float r){\n    return length(p)-r;\n}\nfloat SDF(vec3 p){\n    float d=sphere(p,1.);\n    return d;\n}\n\n\nvec2 ray(vec3 o, vec3 d){\n    float depth = 0.001;\n    float density=0.;\n    float surface=-1.;\n    for (int i = 0; i < 256; i++) {\n        float t = SDF(o + depth * d);\n        if(t<-0.01){\n            depth-=t;\n            density-=t;\n        }\n        else{\n            depth+=t;\n            if(t<0.02){\n                surface=depth;\n                depth+=0.0201;\n            }\n        }\n        if(depth>30.)break;\n        \n    }\n    return vec2(density*0.4,surface);\n}\nvec3 normal(vec3 p){\n    float e=0.02;\n    return normalize(vec3(SDF(vec3(p.x+e,p.yz))-SDF(vec3(p.x-e,p.yz)),\n                SDF(vec3(p.x,p.y+e,p.z))-SDF(vec3(p.x,p.y-e,p.z)),\n                SDF(vec3(p.xy,p.z+e))-SDF(vec3(p.xy,p.z-e))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n    vec3 col=vec3(0.9,0.8,uv.y*0.6+0.8);\n    vec3 o=vec3(15.*sin(iTime),0,15.*cos(iTime));\n    vec3 d=normalize(vec3(uv,3));\n    vec3 T=normalize(-o);\n    vec3 UP=vec3(0,1,0);\n    vec3 A=cross(T,UP);\n    \n    d*=mat3(A,UP,T);\n    \n    vec2 r=ray(o,d);\n    col-=vec3(r.x);\n    if(r.y>0.){\n        vec3 p=o+d*r.y;\n        vec3 N=normal(p);\n        col+=dot(N,vec3(0,0.5,0.2))*vec3(1,0,1)*(N*0.5+0.5);\n        col+=dot(N,vec3(0,-0.5,0))*vec3(0,0,1);\n        \n    }\n    fragColor.rgb=col;\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 56], [57, 57, 75, 75, 117], [120, 120, 145, 145, 595], [596, 596, 616, 616, 837], [838, 838, 895, 895, 1464]]}
{"id": "fs2fWD", "name": "Fractal Bracelet", "author": "SnoopethDuckDuck", "description": "click to move\n\ncouldnt think of how to color so botched some glow by reducing MAX_STEPS\n\n(removed glow because it looked weird from below)", "tags": ["e"], "likes": 11, "viewed": 253, "published": 3, "date": "1646325355", "time_retrieved": "2024-07-30T17:00:29.462132", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0.01, 2.2);\n\n    if (iMouse.z > 0.) {     \n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else ro.y += 0.3 * cos(0.8 * iTime);\n          \n    \n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n   \n    float a = atan(p.x, p.z);\n    float r = length(p.xz);\n    \n    float sc = 3. / pi;\n    // polar\n    \n    //float d = length(vec3(abs(uv.x * r) - 0.25, abs(sc * p.y) - 0.25, 0.)) - 0.2;\n    \n    vec2 uv = sc * vec2(a - 0.25 * iTime, p.y);\n    uv.x = (fract(uv.x) - 0.5) * r;\n    \n    float d = 10.;\n    float m = 0.25;\n    float n = 6.;\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        d = min(d, dlength(uv) - m);\n        uv = abs(uv) - m;\n        m *= 0.6;// * (0.5 + 0.5 * thc(5., 3. * a + iTime));// + 0.15 * cos(io + iTime);\n        \n    }\n    d = min(d, dlength(uv) - m);\n   // d = length(uv) - m;\n    \n  //  d = max(length(p) - 1.8, d);\n    \n    // main cylinder\n    float d2 = abs(length(p.xz) - 1.) - 0.03;\n    \n    // 2 cylinders on top + bottom\n    float d3 = d2;\n     \n    p.y += 0.05 * cos(3. * a + iTime);\n    float h = 0.35 * pow(abs(cos(0.5 * a + 0.5 * iTime)), 4.);\n    d2 = max(d2, abs(p.y) - h);\n   \n    float h2 = 0.02;\n    d3 = max(d3, abs(abs(p.y) - h - 0.5 * h2) - h2);\n\n    // cut out fractal from main cylinder\n    d2 = -min(-d2, d);\n    \n    d2 = min(d2, d3);\n\n   // d2 = length(p.xz) - 0.8;\n\n    return 0.8 * d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    float a = 0.5 * pi * uv.x + 0.18 * iTime;\n    //ro = 2.7 * vec3(cos(a),0,sin(a));\n\n    float zm = mix(1.2, 4., 0.5 + 0.5 * thc(5., 0. * pi * uv.x + 0.5 * iTime));\n    zm = 1.2;\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0), zm);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = -1.;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p + 1000. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, 1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float v = exp(-0.85 * pow(abs(p.y), 0.25));\n        \n        float fresnel = pow(1. + dot(p, n), 5.);\n        \n        // idk what this does\n        v = smoothstep(0., 1., v);\n        v = clamp(1.5 * v * v, 0., 1.);\n      \n        // color + lighten\n        vec3 e = vec3(1);\n        col = v * pal(0.32 + v, 0.8 * e, 0.5 * e, 0.5 * e, 0.8 * vec3(0,1,2)/3.); \n        //col = clamp(col, 0., 1.);\n       \n        col *= dif;\n        col += 0.08 * n.y;\n         col = smoothstep(0., 1., col);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col += 0.15;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.00005)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat dlength(vec2 uv) {\n    return abs(uv.x) + abs(uv.y);\n}\n\nfloat dlength(vec3 uv) {\n    return abs(uv.x) + abs(uv.y) + abs(uv.z);\n}\n\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2fWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 149], [206, 206, 236, 236, 312], [314, 314, 352, 352, 417], [419, 419, 438, 438, 521], [523, 523, 552, 552, 633], [635, 635, 649, 649, 901], [903, 903, 926, 926, 2107], [2109, 2109, 2152, 2152, 2386], [2388, 2388, 2412, 2412, 2602], [2604, 2604, 2654, 2654, 2845], [2847, 2847, 2904, 2904, 4362]]}
{"id": "NsjBDW", "name": "gyroid tunnel", "author": "yasuo", "description": "gyroid tunnel", "tags": ["gyroid"], "likes": 5, "viewed": 207, "published": 3, "date": "1646319329", "time_retrieved": "2024-07-30T17:00:30.221103", "image_code": "// Raymarching based from https://www.shadertoy.com/view/wdGGz3\n// Gyroid inspiration! https://www.youtube.com/watch?v=b0AayhCO7s8\n#define MAX_STEPS 80\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define SPEED 2.0\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .3), z);\n    p.x+=sin(z*0.12)*2.0;\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xy -= path(p.z).xy;\n    \n    p.z += iTime*SPEED;\n    \n    float d = -length(p.xy) + 3.0;\n    d = abs(d)-0.1;\n    \n    p.yz*=Rot(iTime*0.0001);\n    p*=3.0;\n    float d2 = abs(0.5*dot(sin(p),cos(p.yzx))/3.0)-0.15;\n    p = prevP;\n    \n    p.z += iTime*SPEED;\n    p.yz*=Rot(iTime*0.0001);\n    p*=3.5;\n    float d3 = abs(0.5*dot(sin(p),cos(p.yzx))/3.5)-0.1;\n    p = prevP;\n    \n    return combine(vec2(0.7*max(-d2,d),MATERIAL0),vec2(0.7*max(-d3,d),MATERIAL1));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.7)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL0){\n        col = diffuseMaterial(n,rd,p,vec3(0.8,0.3,0.3));\n    } else if(mat == MATERIAL1) {\n        col = diffuseMaterial(n,rd,p,vec3(0.3,0.3,0.8));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = path(t+1.5);\n \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);   \n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 370, 370, 412], [414, 414, 441, 441, 495], [497, 497, 517, 517, 607], [609, 609, 631, 631, 1120], [1122, 1122, 1180, 1180, 1451], [1453, 1453, 1477, 1477, 1678], [1680, 1680, 1722, 1722, 1917], [1919, 1960, 2009, 2009, 2303], [2305, 2305, 2362, 2362, 2895], [2897, 2897, 2956, 2956, 3154], [3156, 3156, 3213, 3213, 3815]]}
{"id": "NdjBWW", "name": "Distorted Menger 2", "author": "lwswl", "description": "A Menger Sponge, distorted, realtime.", "tags": ["fractal", "distortion", "menger", "sponge"], "likes": 1, "viewed": 181, "published": 3, "date": "1646317507", "time_retrieved": "2024-07-30T17:00:30.979076", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    fragColor-=-0.05+0.1*mod(fragCoord.y,3.);\n    \n    \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n *  FULL MENGER SPONGE by Louis Sarwal\n *\n *  \n * I am the sole copyright owner of this Work.\n * You cannot host, display, distribute or share this Work in any form,\n * including physical and digital. You cannot use this Work in any\n * commercial or non-commercial product, website or project. You cannot\n * sell this Work and you cannot mint an NFTs of it.\n *\n**/\n\n#if HW_PERFORMANCE==1\n//uncomment this if you have a decent GPU. It improves the sponge a lot.\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 100.\n#define COLOR_SPEED 0.1\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 4.0\n#define lerp(a, b, k,) a*(k-1.0)+b*k\nvec3 hue(float t){\n    vec3 h=vec3(1,0,0);\n    if (t<0.333){\n        h.r=(0.333-t)*3.;\n        h.g=(t)*3.;\n        h.b=0.;\n        return h;\n    }\n    else if(t<0.667){\n        h.g=(0.667-t)*3.;\n        h.b=(t-0.333)*3.;\n        h.r=0.;\n    }\n    else{\n        h.b=(1.-t)*3.;\n        h.r=(t-0.667)*3.;\n        h.g=0.;\n    }\n    return h;\n}\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - vec3(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n}\n\nfloat mengerSDF(vec3 p, float limit, float shrink,float x){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    //if(II==0.)d=cubeSDF(p+o,r);\n    //if (d>r*1.414213562)return d;//1.414213562=sqrt(2)\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*x&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        r*=shrink;\n        \n        \n    }\n    //if(II>limit){\n    //    return cubeSDF(p+o,r);\n    //}\n    return d;\n    \n    \n    \n     \n}\nvec4 noise(vec3 p){\n    float f=sin(p.z*0.3)+sin(p.x*0.3)+sin(p.x)+sin(p.y)+sin(p.z)+sin(p.x+p.z)+sin(p.y+p.x)+sin(p.z+p.y);\n    f*=0.5;\n    vec3 d=normalize(vec3(\n        0.3*cos(p.x*0.3)+cos(p.x)+cos(p.x+p.z)+cos(p.x+p.y),\n        cos(p.y)+cos(p.x+p.y)+cos(p.y+p.z),\n        0.3*sin(p.z*0.3)+cos(p.z)+cos(p.x+p.z)+cos(p.y+p.z)\n        \n        ));//no coefficient, as it is normalized\n    return vec4(f,d);\n}\n\n\nconst mat3 m3=mat3(-0.5, 0.9, 0.5,\n                0.4, -0.5, 0.4,\n                0.5, 0.9, -0.5);\n\nvec4 fbm( in vec3 x, int octaves )\n{\n    float f = 2.0; \n    float s = 0.5;  \n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noise(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3*m;\n    }\n    return vec4( a, d );\n}\nbool PLANE=false;\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0);\nfloat n(float t){\n    float x=fract(t);\n    return (1.-x)*(1.-x)+x*x;\n}\nvec2 sceneSDF(vec3 p, float limit){\n    vec3 distort=vec3(1,1,1);\n    distort.x+=0.5*n(p.z*2.)+sin(p.y*4.)*0.2;\n    distort.y+=0.5*n(p.z*2.)+sin(p.x*4.)*0.2;\n    distort.z+=0.5*n(p.x*2.)+sin(p.y*4.)*0.2;\n    float mng=mengerSDF(p*distort,limit,clamp(sin(iTime)*0.1+1.,0.,1.),limit==0. ? 1.42 : 0.1);\n    //vec4 n=fbm(p+iTime*2.,9);\n    //float pln=planeSDF(p,vec3(0,1,0),2.+n.x);\n    //PLANE_NORMAL=normalize(n.yzw);\n    //if(mng<pln){\n    //    PLANE=false;\n    return vec2(mng,0.);\n    //}\n    //else{\n    //    PLANE=true;\n    //    return vec2(pln,1.);\n    //}\n}\nfloat getEplison(float dist,float R){\n    return clamp(5.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec3 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        vec2 dist = sceneSDF(o + depth * d, limit);\n        if(dist.y==0.&&!a_bool&&dist.x<0.0005){\n            fd=getEplison(depth+dist.x,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist.x < fd){\n            //if(dist.y>0.9)\n            return vec3(depth,dist.y,fd);\n        }\n        depth += dist.x*0.5;//bad, but it gets around the broken distance field\n        if (depth >= end)return vec3(end,0,fd);\n    }\n    return vec3(end,0,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    return normalize(vec3(sceneSDF(vec3(p.x+n,p.yz),0.).x-sceneSDF(vec3(p.x-n,p.yz),0.).x,\n                sceneSDF(vec3(p.x,p.y+n,p.z),0.).x-sceneSDF(vec3(p.x,p.y-n,p.z),0.).x,\n                sceneSDF(vec3(p.xy,p.z+n),0.).x-sceneSDF(vec3(p.xy,p.z-n),0.).x\n           ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY).x;\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    //f.rgb=N;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows){\n    light.xyz=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    //f.rgb=N;\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, 4.,128.,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x==0.)mouse+=0.9;\n        else mouse+=0.3;\n        vec3 col=hue(mod(iTime*COLOR_SPEED,1.0))*0.07;\n        \n        float dist=(sin(0.25*iTime)*0.3+0.7)*7.3*(mouse.y*mouse.y+0.1);\n        vec3 o=vec3(sin(iTime-mouse.x*6.)*dist,0,cos(iTime-mouse.x*6.)*dist);\n\n#ifdef AA\n\n        \n        for(int i=0;i<4;i++){\n            vec2 uv = ((fragCoord+0.5*vec2(i/2,i%2))/iResolution.xy-0.5)*normalize(iResolution.xy);\n#else\n            vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n#endif\n\n\n            vec3 d=normalize(vec3(uv,1.1));\n            \n            vec3 a = normalize(vec3(0,0,0)-o);\n            vec3 b = cross(a, vec3(0,1,0));\n            vec3 c = cross(b, a);\n            mat3 cm=mat3(b,c,a);\n            d*=cm;\n            d=normalize(d);\n            vec3 f=vec3(0.3,0.3,d.y*0.6+0.4);\n            vec3 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n            if (t.x<far){\n                vec3 p=o+d*t.x;\n                vec3 N;\n                vec3 albedo=vec3(0);\n                \n                if(t.y>0.9){\n                    albedo=vec3(0.04,0.06,0.14)+clamp(-p.y*0.1-0.2,0.0,1.0);\n                    N=PLANE_NORMAL;\n                }\n                else {\n                    albedo=vec3(0.6);\n                    N=normal(o+d*t.x,t.z);\n                }\n\n                f.rgb*=albedo*0.0*vec3(dot(N,vec3(0,1,-1)));\n                t.z=clamp(t.z,0.01,0.1);\n                f.rgb+=albedo*dist_light_func(p,N,vec3(0.5,0.5,0.5),true)*vec3(0.3,0.5,0.6);\n                f.rgb+=albedo*light_func(p,vec3(0,0,0),true)*col*0.4;\n                //f.rgb=N*0.5+0.5;\n\n\n            }\n            #ifdef AA\n            fragColor.rgb+=f*0.25;\n            #else\n            fragColor.rgb=f;\n            #endif\n\n#ifdef AA\n        }\n#endif\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 57, 57, 182]]}
{"id": "7sBfDD", "name": "Interactive 2.5D Squiggles", "author": "SnoopethDuckDuck", "description": " please upload please upload please upload please upload please upload please upload ", "tags": ["fun"], "likes": 47, "viewed": 1152, "published": 3, "date": "1646312377", "time_retrieved": "2024-07-30T17:00:31.738046", "image_code": "#define pi 3.14159\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms  = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // change me! (and uncomment for loop stuff below)\n    float A = 1.;    // -1. // 0.\n    float r = 0.3;   // 0.6\n    float th = 0.02; // 0.12\n    \n    vec2 dir = uv - ms;\n    float a = atan(dir.x, dir.y);\n    float s = 0.;\n    \n    // n is higher than it needs to be but works fine\n    float n = 20.;\n    float k = 6./iResolution.y;\n    \n    for (float i = n; i > 0.; i--) {\n        float io = A * 2. * pi * i / n;\n        float sc = -4. - 0.5 * i + 0.9 * cos(io - 9. * length(dir) + iTime);\n        vec2 fpos = fract(sc * uv + 0.5 * i * ms) - 0.5;\n        //fpos = abs(fpos) - 0.25;\n        fpos *= Rot(a); // a + io // 5. * a // a + 3. * atan(fpos.x, fpos.y)\n        float d = abs(fpos.x);\n        s *= 0.865;\n        s += step(0., s) * smoothstep(-k, k, -abs(d - r) + th); \n    }\n    \n    float val = s * 0.1 + 0.72 + 0. * iTime - 0.23 * pow(dot(dir,dir), 0.25);\n    val = clamp(val, 0.4, 1.);\n    vec3 e = vec3(1);\n    vec3 col = 0.5 * pal(val, e, e, e, 0.24 * vec3(0,1,2)/3.);   \n    col = smoothstep(0., 1., col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 105], [107, 107, 173, 173, 216], [218, 218, 275, 275, 1475]]}
{"id": "ssBBDD", "name": "Distorted Menger 1", "author": "lwswl", "description": "A Menger Sponge distorted quadratically.", "tags": ["fractal", "distortion", "menger", "sponge"], "likes": 1, "viewed": 187, "published": 3, "date": "1646312372", "time_retrieved": "2024-07-30T17:00:32.493028", "image_code": "/**\n *  FULL MENGER SPONGE by Louis Sarwal\n *\n *  \n * I am the sole copyright owner of this Work.\n * You cannot host, display, distribute or share this Work in any form,\n * including physical and digital. You cannot use this Work in any\n * commercial or non-commercial product, website or project. You cannot\n * sell this Work and you cannot mint an NFTs of it.\n *\n**/\n\n#if HW_PERFORMANCE==1\n//uncomment this if you have a decent GPU. It improves the sponge s lot.\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 100.\n#define COLOR_SPEED 0.1\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 4.0\n#define lerp(a, b, k,) a*(k-1.0)+b*k\nvec3 hue(float t){\n    vec3 h=vec3(1,0,0);\n    if (t<0.333){\n        h.r=(0.333-t)*3.;\n        h.g=(t)*3.;\n        h.b=0.;\n        return h;\n    }\n    else if(t<0.667){\n        h.g=(0.667-t)*3.;\n        h.b=(t-0.333)*3.;\n        h.r=0.;\n    }\n    else{\n        h.b=(1.-t)*3.;\n        h.r=(t-0.667)*3.;\n        h.g=0.;\n    }\n    return h;\n}\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - vec3(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n}\n\nfloat mengerSDF(vec3 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=cubeSDF(p+o,r);\n    if (d>r*1.414213562)return d;//1.414213562=sqrt(2)\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*1.414213562&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n    //if(II>limit){\n    //    return cubeSDF(p+o,r);\n    //}\n    return d;\n    \n    \n    \n     \n}\nvec4 noise(vec3 p){\n    float f=sin(p.z*0.3)+sin(p.x*0.3)+sin(p.x)+sin(p.y)+sin(p.z)+sin(p.x+p.z)+sin(p.y+p.x)+sin(p.z+p.y);\n    f*=0.5;\n    vec3 d=normalize(vec3(\n        0.3*cos(p.x*0.3)+cos(p.x)+cos(p.x+p.z)+cos(p.x+p.y),\n        cos(p.y)+cos(p.x+p.y)+cos(p.y+p.z),\n        0.3*sin(p.z*0.3)+cos(p.z)+cos(p.x+p.z)+cos(p.y+p.z)\n        \n        ));//no coefficient, as it is normalized\n    return vec4(f,d);\n}\n\n\nconst mat3 m3=mat3(-0.5, 0.9, 0.5,\n                0.4, -0.5, 0.4,\n                0.5, 0.9, -0.5);\n\nvec4 fbm( in vec3 x, int octaves )\n{\n    float f = 2.0; \n    float s = 0.5;  \n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < octaves; i++ )\n    {\n        vec4 n = noise(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3*m;\n    }\n    return vec4( a, d );\n}\nbool PLANE=false;\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0);\nfloat n(float t){\n    float x=fract(t);\n    return (1.-x)*(1.-x)+x*x;\n}\nvec2 sceneSDF(vec3 p, float limit){\n    vec3 distort=vec3(n(p.y*0.5+0.5)+n(p.z*0.5+0.5),n(p.x*0.5+0.5)+n(p.z*0.5+0.5),n(p.y*0.5+0.5)+n(p.x*0.5+0.5));\n    float mng=mengerSDF(p*distort,limit);\n    //vec4 n=fbm(p+iTime*2.,9);\n    //float pln=planeSDF(p,vec3(0,1,0),2.+n.x);\n    //PLANE_NORMAL=normalize(n.yzw);\n    //if(mng<pln){\n    //    PLANE=false;\n    return vec2(mng,0.);\n    //}\n    //else{\n    //    PLANE=true;\n    //    return vec2(pln,1.);\n    //}\n}\nfloat getEplison(float dist,float R){\n    return clamp(5.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec3 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        vec2 dist = sceneSDF(o + depth * d, limit);\n        if(dist.y==0.&&!a_bool&&dist.x<0.0005){\n            fd=getEplison(depth+dist.x,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist.x < fd){\n            //if(dist.y>0.9)\n            return vec3(depth,dist.y,fd);\n        }\n        depth += dist.x*0.4;//bad, but it gets around the broken distance field\n        if (depth >= end)return vec3(end,0,fd);\n    }\n    return vec3(end,0,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    return normalize(vec3(sceneSDF(vec3(p.x+n,p.yz),0.).x-sceneSDF(vec3(p.x-n,p.yz),0.).x,\n                sceneSDF(vec3(p.x,p.y+n,p.z),0.).x-sceneSDF(vec3(p.x,p.y-n,p.z),0.).x,\n                sceneSDF(vec3(p.xy,p.z+n),0.).x-sceneSDF(vec3(p.xy,p.z-n),0.).x\n           ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY).x;\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    //f.rgb=N;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows){\n    light.xyz=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    //f.rgb=N;\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, 4.,128.,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x==0.)mouse+=0.9;\n        vec3 col=hue(mod(iTime*COLOR_SPEED,1.0))*0.07;\n        \n        float dist=(sin(0.25*iTime)*0.3+0.7)*7.3*(mouse.y*mouse.y+0.1);\n        vec3 o=vec3(sin(iTime-mouse.x*6.)*dist,0,cos(iTime-mouse.x*6.)*dist);\n\n#ifdef AA\n\n        \n        for(int i=0;i<4;i++){\n            vec2 uv = ((fragCoord+0.5*vec2(i/2,i%2))/iResolution.xy-0.5)*normalize(iResolution.xy);\n#else\n            vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n#endif\n\n\n            vec3 d=normalize(vec3(uv,1.1));\n            vec3 f=vec3(0.3,0.35,0.4);\n            vec3 a = normalize(vec3(0,0,0)-o);\n            vec3 b = cross(a, vec3(0,1,0));\n            vec3 c = cross(b, a);\n            mat3 cm=mat3(b,c,a);\n            d*=cm;\n            d=normalize(d);\n            vec3 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n            if (t.x<far){\n                vec3 p=o+d*t.x;\n                vec3 N;\n                vec3 albedo=vec3(0);\n                \n                if(t.y>0.9){\n                    albedo=vec3(0.04,0.06,0.14)+clamp(-p.y*0.1-0.2,0.0,1.0);\n                    N=PLANE_NORMAL;\n                }\n                else {\n                    albedo=vec3(0.4);\n                    N=normal(o+d*t.x,t.z);\n                }\n\n                f.rgb*=albedo*0.1*vec3(dot(N,vec3(0,1,-1)));\n                t.z=clamp(t.z,0.01,0.1);\n                f.rgb+=albedo*dist_light_func(p,N,vec3(0.5,0.5,0.5),true)*vec3(0.3,0.5,0.6);\n                f.rgb+=albedo*light_func(p,vec3(0,0,0),false)*col*1.;\n                //f.rgb=N*0.5+0.5;\n\n\n            }\n            #ifdef AA\n            fragColor.rgb+=f*0.25;\n            #else\n            fragColor.rgb=f;\n            #endif\n\n#ifdef AA\n        }\n#endif\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBBDD.jpg", "access": "api", "license": "proprietary-license", "functions": [[1064, 1064, 1082, 1082, 1403], [1404, 1404, 1434, 1434, 1531], [1533, 1533, 1570, 1570, 3737], [3738, 3738, 3757, 3757, 4148], [4252, 4252, 4288, 4288, 4723], [4742, 4742, 4782, 4782, 4805], [4833, 4833, 4850, 4850, 4904], [4905, 4905, 4940, 4940, 5363], [5364, 5364, 5401, 5401, 5460], [5461, 5461, 5547, 5547, 6306], [6309, 6309, 6338, 6338, 6613], [6615, 6615, 6685, 6685, 6939], [6940, 6940, 6991, 6991, 7222], [7223, 7223, 7291, 7291, 7575]]}
{"id": "fsyXDw", "name": "[CrzClm] Triplaner Displacement", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["modeling", "maptoy", "crazyclimbers"], "likes": 15, "viewed": 391, "published": 3, "date": "1646307661", "time_retrieved": "2024-07-30T17:00:33.428527", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n// Slow compiling...\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n\nfloat voronoiSmooth(vec2 p, float s)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    {\n        vec2 b = vec2(j,k);\n        vec2 r = b-f+hash22(i+b);\n\n        float d = length( r );\n        res = fOpUnionSmooth( res, d, s );\n    }\n    return res;\n}\n\nfloat tscale = 1.;\nvec2 toffset = vec2(0); // texture offset\n\nfloat ns = 0.;\nvec3 bokoboko = vec3(0); \nvec3 paripari = vec3(0);\n\nfloat getDisp(vec3 v3, vec3 n) {\n\n    const float k = 3.;\n    // blend factors\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (v3.x*w.x + v3.y*w.y + v3.z*w.z) / (w.x + w.y + w.z);\n}\n\nfloat map(vec3 p){\n    const float dp = .1;\n\n    vec3 q = p;\n    vec3 b = p;\n    \n    const float sclpari = 8.;\n    paripari.x = voronoiSmooth(p.yz*sclpari, .1);\n    paripari.y = voronoiSmooth(p.xz*sclpari, .1);\n    paripari.z = voronoiSmooth(p.xy*sclpari, .1);\n    paripari=pow(paripari, vec3(2));\n    paripari = smoothstep(0.01, 1., paripari);\n    const float sclboko = 20.;\n    bokoboko.x = gfbm(p.yz*sclboko, 1, .5);\n    bokoboko.y = gfbm(p.xz*sclboko, 1, .5);\n    bokoboko.z = gfbm(p.xy*sclboko, 1, .5);\n    bokoboko = smoothstep(.01, 1., bokoboko);\n    \n    q.y+=sin(iTime)*.5;\n    \n    q.xz+=vec2(sin(iTime),cos(iTime))*.5;\n    vec3 n = normalize(q);\n    float d = sdEllipsoid(q, vec3(1)*.25)-getDisp(paripari, n) * .05;\n    \n    q.y=p.y+cos(iTime)*.5;\n    \n    q.xz+=vec2(sin(iTime),cos(iTime))*.5;\n    vec3 n2 = normalize(q);\n    float d2 = sdEllipsoid(q, vec3(1)*.25)-getDisp(bokoboko, n2) * .05;\n    d = min(d,d2);\n    return d*.5;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-1,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 296, 296, 588], [719, 719, 751, 751, 925], [927, 927, 945, 945, 1871]]}
{"id": "ssBBDW", "name": "Day 802", "author": "jeyko", "description": "potato  ", "tags": ["fractal", "volume", "mdtmjvm"], "likes": 25, "viewed": 910, "published": 3, "date": "1646302375", "time_retrieved": "2024-07-30T17:00:34.186500", "image_code": "// The sdf and cloud rendering was inspired of another shader on the site, but i lost it!\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 map(vec3 p){\n    vec3 d = vec3(0);\n    \n    p *= 2.;\n    vec3 op = p;\n    float att = 1.;\n    for(float i = 0.; i < 3.; i++){\n        \n        p = abs(p);\n        p *= 1.5;\n        \n        p -= 0.4;\n        p /= clamp(dot(p,p),-0.5,2.4);\n        \n        p += sin(dot(p,cos(p*1. + i + iTime)))*att*0.4;\n        p.yz *= rot(1.6 + i*0.);\n        p.xy *= rot(1.6);\n        \n        \n        \n        d += exp(-abs(dot(op,p))*40.)*att*2.;\n        //d += abs(dot(sin(p*1.),cos(p*1.5 + 15.)))*att;\n        att *= 0.7;\n    }\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    d *= 1.4;\n    if(false){\n        d = d/(d+1.);\n        d = pow(d,vec3(4.4))*25.;\n    }//d = 1.-abs(d);\n    //d = abs(d);\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    //d = mix(vec3(1,0.5,1)*0.1,vec3(1,1.5,1),d*5.);\n    \n    //d = mix(vec3(1.4,0.1,0.4),vec3(0,0.4,0.2),d*0.5)*d;\n    d = (0.5 + 0.5*sin(vec3(1,2,5)*1. - cos(d*29.)*0. + 4. + d.x*0.4))*d*1.;\n    //d = exp(d*1000.);\n    //d = pow(d,vec3(5.));\n    return d;\n}\n\nvec3 getMarch(vec3 ro, vec3 rd, vec2 uv){\n\n    vec3 col = vec3(0);\n    \n    float iters = 400.;\n    float maxD = 5.;\n    vec3 accum = vec3(0);\n    //float stepSz = 1./iters*maxD*mix(0.99,1.,hash23(vec3(uv*2000.,110.)).x);\n    \n    ro -= rd * hash23(vec3(uv*2000.,510. + iTime*0.)).x*1./iters*maxD;\n    vec3 p = ro;\n    \n    float t = 0.;\n    float stepSz = 1./iters*maxD;\n    for(float i = 0.; i < iters; i++){\n        vec3 d = map(p);\n        \n        accum += d*stepSz*(1.-dot(accum,accum));\n        stepSz = 1./iters*maxD*mix(1.,0.5,exp(-dot(d,d)*44.));\n    \n        if(dot(accum,accum) > 0.9 || t > maxD)\n            break;\n        t += stepSz;\n        p += rd*stepSz;\n    }\n    \n    //col += accum;\n    col = mix(col,accum,dot(accum,accum)*15.);\n    //col = mix(col,accum,pow(dot(accum,accum)*4.,1.)*144.);\n    \n    col = col/(2. + col*0.7)*1.4;\n    col = pow(col,vec3(0.4545));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,0,-2);\n    ro.xz *= rot((iTime + sin(iTime*1.4))*0.2);\n    ro.xy *= rot((iTime*0.8 + sin(iTime*1.7)*0.6)*0.1);\n    \n    vec3 lookAt = vec3(0);\n    vec3 rd = getRd(ro,lookAt,uv);\n    \n    \n    col = getMarch(ro, rd, uv);\n    //vec3 rd = normalize(vec3(uv,1));\n    \n    \n    \n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 134, 134, 322], [375, 375, 392, 392, 1377], [1379, 1379, 1420, 1420, 2280], [2282, 2282, 2339, 2339, 2766]]}
{"id": "7sSBDW", "name": "circlу-simple", "author": "sashikus", "description": "Простой пример рисования круга", "tags": ["example", "circle"], "likes": 2, "viewed": 122, "published": 3, "date": "1646301716", "time_retrieved": "2024-07-30T17:00:34.939487", "image_code": "void circle(inout vec4 fragColor, vec2 uv, vec2 c, float r, vec3 col)\n{\n    float l = length(uv.xy - c.xy);\n    if (l < r) fragColor += vec4(col.rgb, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n\tvec3 color = vec3 (0.7, 0.07, 0.1);\n    vec2 c = vec2(0.5, 0.5);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    circle(fragColor, uv, c, 0.2, color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 71, 71, 157], [160, 160, 216, 216, 478]]}
{"id": "fsBBDD", "name": "rgb-blending", "author": "sashikus", "description": "Простой пример смешивания цветов", "tags": ["circle", "rgb", "blend"], "likes": 1, "viewed": 117, "published": 3, "date": "1646296184", "time_retrieved": "2024-07-30T17:00:35.819135", "image_code": "void circle(inout vec4 fragColor, vec2 uv, vec2 c, float r, vec3 col)\n{\n    float l = length(uv.xy - c.xy);\n    if (l < r) fragColor += vec4(col.rgb, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 red = vec3   (1.0, 0.0, 0.0);\n    vec3 green = vec3 (0.0, 1.0, 0.0);\n    vec3 blue = vec3  (0.0, 0.0, 1.0);\n    \n    vec2 c_red = vec2  (0.5, 0.3);\n    vec2 c_green = vec2(0.3, 0.8);\n    vec2 c_blue = vec2 (0.8, 0.8);\n    \n    float r = 0.4;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    circle(fragColor, uv, c_red,   r, red);\n    circle(fragColor, uv, c_green, r, green);\n    circle(fragColor, uv, c_blue,  r, blue);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 71, 71, 157], [160, 160, 216, 216, 695]]}
{"id": "fdlcRH", "name": "[CrzClm] Hand", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["maptoy", "crazyclimbers"], "likes": 28, "viewed": 420, "published": 3, "date": "1646290087", "time_retrieved": "2024-07-30T17:00:36.861348", "image_code": "// SDF is in BufB.\n\n#define getBuf(coord)\ttexelFetch(iChannel0, ivec2(coord), 0)\nvec3 getAlbedo(vec2 coord) { return unpackU4(getBuf(coord).x).rgb; }\nfloat getAO(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).b); }\nfloat getDiffuse(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).r); }\nfloat getDepth(vec2 coord) { return getBuf(coord).w; }\nvec3 getNormal(vec2 coord) { return normalize(unpackS3(getBuf(coord).z)); }\nvec2 clampCoord(vec2 coord) { return clamp(coord, vec2(0), iResolution.xy - .5); }\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2) {\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(1.5, 1., difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord) {\n    if(getDepth(coord)>.9)return .4;\n    \n\tconst vec3 offset = vec3(.5, -.5, 0)*2.;\n    #define NM(x)\tgetNormal(x)\n\tvec2 coords = coord;\n\tfloat edge = 1.;\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yx)), NM(clampCoord(coords + offset.xy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.xx)), NM(clampCoord(coords + offset.yy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yz)), NM(clampCoord(coords + offset.xz))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.zx)), NM(clampCoord(coords + offset.zy))));\n\treturn edge;\n}\n\n// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir) {\n\tfloat np, zp, pp, nz, pz, nn, zn, pn, gx, gy;\n    np = getDiffuse(clampCoord(fragCoord + (vec2(-1, 1) + dir)));\n    zp = getDiffuse(clampCoord(fragCoord + (vec2(0, 1) + dir)));\n    pp = getDiffuse(clampCoord(fragCoord + (vec2(1) + dir)));\n    nz = getDiffuse(clampCoord(fragCoord + (vec2(-1, 0) + dir)));\n    pz = getDiffuse(clampCoord(fragCoord + (vec2(1, 0) + dir)));\n    nn = getDiffuse(clampCoord(fragCoord + (vec2(-1) + dir)));\n    zn = getDiffuse(clampCoord(fragCoord + (vec2(0, -1) + dir)));\n    pn = getDiffuse(clampCoord(fragCoord + (vec2(1, -1) + dir)));\n\n\t// https://www.shadertoy.com/view/Wds3Rl\n\tgx = np * -3. + nz * -10. + nn * -3. + pp * 3. + pz * 10. + pn * 3.;\n\tgy = np * -3. + zp * -10. + pp * -3. + nn * 3. + zn * 10. + pn * 3.;\n\n\tvec2 G = vec2(gx, gy);\n\treturn vec4(G, length(G), atan(G.y, G.x));\n}\n\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx) {\n\tvec4 edge = sobel(fragCoord, vec2(0));\n\tvec2 dir = vec2(cos(-edge.w), sin(-edge.w));\n\tvec4 edgep = sobel(fragCoord, dir),\n\t     edgen = sobel(fragCoord, -dir);\n\tif (edge.z < edgep.z || edge.z < edgen.z) edge.z = 0.;\n\treturn vec2((edge.z > mn) ? edge.z : 0., (edge.z > mx) ? edge.z : 0.);\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx, bool isDiffuse) {\n\tvec2 np = hysteresisThr(fragCoord + vec2(-1, 1), mn, mx),\n\t     zp = hysteresisThr(fragCoord + vec2(0, 1), mn, mx),\n\t     pp = hysteresisThr(fragCoord + vec2(1), mn, mx),\n\t     nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx),\n\t     zz = hysteresisThr(fragCoord + vec2(0), mn, mx),\n\t     pz = hysteresisThr(fragCoord + vec2(1, 0), mn, mx),\n\t     nn = hysteresisThr(fragCoord + vec2(-1), mn, mx),\n\t     zn = hysteresisThr(fragCoord + vec2(0, -1), mn, mx),\n\t     pn = hysteresisThr(fragCoord + vec2(1, -1), mn, mx);\n\treturn 1. - min(1., step(1e-3, zz.x * 8.) * smoothstep(0., .5, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y) * 8.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    switchShowFinal();\n    \n\tvec3 albedo = getAlbedo(fragCoord);\n    vec3 col = vec3(.9608, .9216, .8431);\n\n\tcol *= min(getOutline(fragCoord), cannyEdge(fragCoord, 0., 3.5, true));\n    col *= sms(.25,.24, getAO(fragCoord));\n\tcol *= sms(.4, .401, gnoise(fragCoord * .18+floor(iTime)) + gnoise(fragCoord * .15) + .3);\n\tcol += 1. - sms(.8, .801, (1. - gnoise(fragCoord * .05+floor(iTime)) * gnoise(fragCoord * .1)) + .7);\n\tfragColor = vec4(pow3(col, .45), 1);\n    \n    if(!SHOW_FINAL)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbool SHOW_FINAL = true;\n#define switchShowFinal() SHOW_FINAL=(int(floor(iTime*.25))%2==0) \n\n#define PI acos(-1.)\n#define TAU (PI*2.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n#define sat(x) clamp(x,0.,1.)\n#define sms(min,max,x) smoothstep(min,max,x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x > 0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x),sign1f(v.y))\n#define linearstep(edge0,edge1,x) min(max((x-(edge0))/((edge1)-(edge0)),0.),1.)\n#define ZERO min(0,iFrame)\nvec3 pow3(vec3 v,float power){return pow(v,vec3(power));}\n\n// \"hash11()\"-\"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n  st *= .75;\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0., 1., f);\n\n  vec2 rnd_x0y0 = u2s(hash22(i + vec2(0, 0)));\n  vec2 rnd_x1y0 = u2s(hash22(i + vec2(1, 0)));\n  vec2 rnd_x0y1 = u2s(hash22(i + vec2(0, 1)));\n  vec2 rnd_x1y1 = u2s(hash22(i + vec2(1, 1)));\n\n  vec2 dir_x0y0 = st - (i + vec2(0, 0));\n  vec2 dir_x1y0 = st - (i + vec2(1, 0));\n  vec2 dir_x0y1 = st - (i + vec2(0, 1));\n  vec2 dir_x1y1 = st - (i + vec2(1, 1));\n\n  float dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n  float res_x = mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y = mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y) * 2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers) {\n  float res = 0.;\n  fbm_base(gnoise, n, rep, pers);\n  return res;\n}\n\n\n// Data packer/unpacker\n// albedo,diffuse,specular,shadow,normal,and depth are rendered in raymarching pass,\n// and then,those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) *.997 * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n\nstruct RenderData {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n} renDat;\n\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n}ray;\n\nstruct Camera {\n  vec3 position;\n  vec3 direction;\n  vec3 target;\n  vec4 quaternion;\n  float fov;\n  float orthoDist;\n  float orthoScale;\n  vec3 up;\n};\n\nstruct Light {\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n\n#define MAT_VOID vec3(-1)\nbool isMaterial(vec3 MAT) { return distance(renDat.albedo, MAT) < .005; }\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 20.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-.25,2)\n#define CAM_DIST 5.\n#define CAM_INIT_SCALE .6\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(.13)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\nvec4 packRenderData(){\n  return vec4(packU4(vec4(renDat.albedo, renDat.shadow)), packS3((vec3(u2s(renDat.diffuse), renDat.specular, u2s(renDat.ao)))), packS3((renDat.normal)), renDat.depth);\n}\n\nbool isTurntable = false;\nint char_id = -1; vec2 char_pos, dfdx, dfdy;\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n#define render() \\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=ZERO; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=ZERO; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), 1, cos(iTime*TURN_TABLE_SPEED))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    renDat.normal=vec3(0);\\\n    renDat.diffuse=1.;\\\n    renDat.albedo=vec3(.9);\\\n    renDat.depth=1.;\\\n    renDat.specular=0.;\\\n    renDat.shadow=1.;\\\n    renDat.ao=1.;\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5 || SHOW_FINAL){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(n,vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n            renDat.normal=n;\\\n            renDat.diffuse=(dot(n, normalize(vec3(1.0, 1.0, 1.0))));\\\n            renDat.albedo = vec3(1);\\\n            renDat.depth = 0.;\\\n            renDat.specular = 0.;\\\n            renDat.shadow = 1.;\\\n            renDat.ao = cost/float(STEP_MAX);\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz)*.333;\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x>.5;\\\n    switchShowFinal();\\\n    isTurntable = true;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    if(SHOW_FINAL)fragColor=packRenderData();\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\nmat2 rot2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define CYCLE 4.\n\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\n\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\n\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\n\nfloat sdFinger(vec3 p, vec2 baseSize, vec4 frot) {\n    float min_mix = .001;\n    float base_mix = baseSize.x*2.7;\n    const float MAX_ROT = PI*.25;\n    frot *= MAX_ROT;\n    \n    // anchor points\n    vec3 p0 = p;\n    p0.yx *= rot2d(-frot.w);\n    p0.yz *= rot2d(-frot.x);\n    \n    vec3 p1 = p0-vec3(0,baseSize.y*1.166*2.,0);\n    p1.yz *= rot2d(-frot.y);\n    \n    vec3 p2 = p1-vec3(0,baseSize.y*2.,0);\n    p2.yz *= rot2d(-frot.z);\n    \n    float dRoot = sdEllipsoid(p0-vec3(0,baseSize.y*.6,0), baseSize.xyx*1.1);\n    float dFin0 = sdEllipsoid(p0-vec3(0,baseSize.y*1.166,0), baseSize.xyx*vec2(1., 1.15).xyx);\n    dFin0 = fOpUnionSmooth(dFin0, dRoot, .05); \n    float dFin1 = sdEllipsoid(p1+vec3(0,-baseSize.y*1.15,0), baseSize.xyx*vec2(1., 1.1).xyx);\n    float dFin2 = sdEllipsoid(p2+vec3(0,-baseSize.x*1.5,0), baseSize.xxx*1.15);\n\n    // combine all\n    float d = fOpUnionSmooth(dFin0, dFin1, base_mix*.9+min_mix);\n    d = fOpUnionSmooth(d, dFin2, base_mix*1.1+min_mix);\n    \n    return d;\n}\n\nfloat sdPalm(vec3 p) {\n    float d= sdEllipsoid(p, vec2(0.17, .1).xxy);\n    d = fOpSubstractionSmooth(sdEllipsoid(p+vec3(-.1,0,.17), vec2(0.17, .1).xxy), d, .15);\n    return d;\n}\n\nfloat sdHand(vec3 p, vec4 frot0, vec4 frot1, vec4 frot2, vec4 frot3) {\n    float bd = length(p-vec3(0,.25,0))-.6;\n    if(bd>.1) return bd;\n    \n    p.y-=.27;\n    p.x-=.09;\n    vec2 baseSize = vec2(.175, .25);\n    float winkleStart = 2.;\n    \n    // anchor points\n    vec3 p0 = p;\n    p0 += vec3(-.0,.13,.05);\n    p0 = rot(p0, vec3(-.75,-1.5,.75));\n    \n    vec3 p1 = p;\n    p1 += vec3(0,0,0);\n    p1 = rot(p1, vec3(0,0,.25));\n    \n    vec3 p2 = p;\n    p2 += vec3(.1,-.015,0);\n    p2 = rot(p2, vec3(0,0,0));\n    \n    vec3 p3 = p;\n    p3 += vec3(.19,0,0);\n    p3 = rot(p3, vec3(0,0,-.25));\n    \n    // combine all\n    float d = sdPalm(p+vec3(.09,.1,0));\n    vec2 scale = vec2(.9, 1.);\n    d = fOpUnionSmooth(d, sdFinger(p0, vec2(0.039, .06)*scale, frot0*.9), .001+.25 * smoothstep(.2, .0, length(p0)));\n    d = fOpUnionSmooth(d, sdFinger(p1, vec2(0.036, .07)*scale, frot1*.75), .001+.065 * smoothstep(.2, .1, length(p1)));\n    d = fOpUnionSmooth(d, sdFinger(p2, vec2(0.036, .07)*scale, frot2*.8), .001+.065 * smoothstep(.2, .1, length(p2)));\n    d = fOpUnionSmooth(d, sdFinger(p3, vec2(0.0325, .0625)*scale, frot3*.8), .001+.06 * smoothstep(.2, .1, length(p3)));\n    \n    return d-.01;\n}\n\nfloat map(vec3 p){\n    p.y+=.3;\n    float t = iTime*3.;\n    float rxyz0 = (swCubic(t+.5))*.15-.1;\n    float rxyz1 = (swCubic(t+.5)+1.)*1.3-.2;\n    float rxyz2 = (swCubic(t+.5*2.)+1.)*1.3-.2;\n    float rxyz3 = (swCubic(t+.5*3.)+1.)*1.3-.2;\n    float rw = swCubic(t)*.25;\n    vec4 frot0 = vec4(vec3(rxyz0), rw);\n    vec4 frot1 = vec4(vec3(rxyz1), rw);\n    vec4 frot2 = vec4(vec3(rxyz2), rw);\n    vec4 frot3 = vec4(vec3(rxyz3), rw);\n    return sdHand(p, frot0, frot1, frot2, frot3);\n}\n\nrender();\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 109, 109, 149], [150, 150, 175, 175, 218], [219, 219, 249, 249, 292], [293, 293, 321, 321, 347], [348, 348, 376, 376, 423], [424, 424, 453, 453, 506], [508, 508, 546, 546, 631], [633, 633, 663, 663, 1238], [1240, 1338, 1376, 1376, 2196], [2198, 2198, 2254, 2254, 2545], [2547, 2547, 2616, 2616, 3262], [3264, 3264, 3316, 3316, 3855]]}
{"id": "NsBfWW", "name": "Julia  sets", "author": "El_Sargo", "description": "Visualization of the Julia sets. The Mandelbrot set is pulsating in green behind and you can use the mouse the change the Julia set.", "tags": ["2d", "fractal", "mandelbrot", "julai"], "likes": 1, "viewed": 194, "published": 3, "date": "1646281613", "time_retrieved": "2024-07-30T17:00:37.686143", "image_code": "#define ITIME iTime*.1\n#define AA 2\nconst int maxIterations = 50;\nvec2 complexMul(vec2 a, vec2 b){\n    return vec2(\n              a.x*b.x - a.y * b.y,\n              2. * a.x * b.y\n            );\n}\n\nint julia(vec2 z, vec2 c){\n    for (int i=0;i<maxIterations;i++){\n        z = complexMul(z, z) + c;\n        if (length(z) > 1000.)\n            return i;\n    }\n    return -1;\n}\n\n//---------------------------------------------------------------------------\n//1D Perlin noise implementation from https://www.shadertoy.com/view/lt3BWM\n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\n//------------------------------------------------------------------------------\n\nvec3 render(vec2 uv){\n    //Evaluate perlin noise to dertmine c\n    vec2 c = vec2(perlinNoise1D(ITIME), perlinNoise1D(ITIME+10.1231));\n    //Use mouse input if mb1 is held\n    if (iMouse.z > 0.){\n        c = (iMouse.xy/iResolution.xy-0.5)*3.;\n        c.x *= iResolution.x / iResolution.y;\n    }\n    \n    int j = julia(uv, c);\n    //Mandelbrot uses the same function as the julia sets\n    int m = julia(vec2(0), uv);\n    \n    vec3 col = pow(vec3(smoothstep(float(maxIterations)*0.01, float(maxIterations)*0.6, float(j))), vec3(.2,1.,.01));\n    col.y = float(m)/float(maxIterations)*sin(iTime);\n    col.y += 0.01/distance(c,uv)*smoothstep(-1.5,1.,sin(iTime*2.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col = vec3(0);\n    \n    //AA\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = ((fragCoord+o)/iResolution.xy-0.5)*3.;\n        uv.x *= iResolution.x / iResolution.y;\n        //Draw\n        col += render(uv)/float(AA*AA);\n    }}\n\n\n    // Output to screen\n    fragColor = vec4 (col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 98, 98, 196], [198, 198, 224, 224, 373], [633, 633, 654, 654, 771], [773, 773, 794, 794, 829], [831, 831, 864, 864, 924], [926, 926, 956, 956, 1084], [1168, 1168, 1189, 1231, 1851], [1853, 1853, 1910, 1910, 2351]]}
{"id": "ssjfD1", "name": "Primes Collatz and Ulam", "author": "elenzil", "description": "The integers are spread out in the Ulam spiral,\nand then we fade between either the primes or the height of the Collatz conjecture.\n\nResult: the Collatz Conjecture is a better hash than primacy !", "tags": ["spiral", "primes", "integer", "cantor", "integers", "ulam", "diagonalize"], "likes": 10, "viewed": 258, "published": 3, "date": "1646182338", "time_retrieved": "2024-07-30T17:00:38.445114", "image_code": "// Fork of \"Ulam Spiral & Cantor Diagonal\" by elenzil. https://shadertoy.com/view/fdjBDR\n// 2022-03-02 00:33:47\n\n// Fork of \"Ulam Spiral\" by elenzil. https://shadertoy.com/view/ssjBRm\n// 2022-02-28 00:22:54\n\nint sqr(int n) {\n    return n * n;\n}\n\n// thanks to @Envy24 for optimized version of this routine.\nbool isPrime(int N) {\n    switch (N)\n    {\n    case 0:\n    case 1:\n        return false;\n    case 2:\n    case 3:\n    case 5:\n    case 7:\n        return true;\n    default:\n        break;\n    }\n\n    if ((N & 1) == 0) { return false; }\n\n    int n = 3;\n    bool r = true;\n    int limit = int(sqrt(float(N)));\n\n    do \n    { \n        r = (N % n) != 0;\n        n += 2;\n    } while (r &&\n        n <= limit);\n\n    return r;\n}\n\nint getNForPixel_Cartesian(in ivec2 IJ, int width) {    \n    return IJ.x + (IJ.y * width);\n}\n\nint getNForPixel_Diagnolize(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int i_j = I + J;\n    return (i_j * 1) * i_j / 2 + J + 1;    \n}\n\nint getNForPixel_Spiral(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J));\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    return n;\n}\n\nint collatzIters(int n, int maxIters) {\n\n    int count;\n    \n    for (count = 1; count < maxIters && n > 1; ++count) {\n        if (n % 2 == 1)\n        {\n            n = n * 3 + 1;\n        }\n        else\n        {\n            n /= 2;\n        }\n    }\n    \n    return count;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    int pixelsPerPixel = iMouse.z > 1.0 ? 1 : 3;\n    ivec2 IJ_centered = ivec2(XY) / pixelsPerPixel - ivec2(iResolution.xy) / 2 / pixelsPerPixel;\n    ivec2 IJ_cornered = ivec2(XY) / pixelsPerPixel;\n    \n    int n;\n\n    n = getNForPixel_Spiral(IJ_centered);\n\n    float p = isPrime(n) ? 0.0 : 1.0;\n    \n    int maxIters = 500;\n    int ci = collatzIters(n, maxIters);\n    float c = 1.0 - pow(float(ci) / float(maxIters), 0.5);\n\n    vec3 rgb = mix(vec3(p), vec3(c), smoothstep(-0.8, 0.8, sin(iTime / 2.0)));\n    \n\n    \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 224, 224, 244], [246, 306, 327, 327, 724], [726, 726, 778, 778, 818], [820, 820, 862, 862, 970], [972, 972, 1010, 1010, 1642], [1644, 1644, 1683, 1683, 1917], [1919, 1919, 1962, 1962, 2506]]}
{"id": "7d2fDh", "name": "Bling fractal", "author": "El_Sargo", "description": "My first fractal, inspired by the merger sponge, it is just a cross of cylinders smoothly subtracted from a sphere. Coloring is based on orbit traps.\n\nUse the mouse to rotate around.", "tags": ["3d", "raymarching"], "likes": 20, "viewed": 400, "published": 3, "date": "1646175353", "time_retrieved": "2024-07-30T17:00:39.195108", "image_code": "#define zoom -5.\n#define sensitivity 7.\n#define rotaionSpeed .2\n//Heavy performance impact, maybe set to 1 if going full screen \n#define AA 2\n//Setting this to high can crash the complier\n#define maxSteps 60\n#define shadows\n#define normals\n#define AO\n#define shadowSoftness 5.\n//#define hmmm\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n//https://iquilezles.org/articles/distfunctions\nfloat sminus( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n//----\n\n//rotation matrices\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\n\nfloat sdCylenderCross(vec3 p, float r){\n    return min(min(\n                   length(p.xz),\n                   length(p.xy)),\n                   length(p.yz)) - r;\n}\n// distance to the scene and the final position of p\nvec4 map(vec3 p) {\n    \n    float d = sdSphere(p, 2.);\n    if (d > 0.1){return vec4(d,p);}\n    float scale = 1.;\n    for (int i = 0; i<4;i++){\n       \n        d = sminus(\n                    sdCylenderCross((p=abs(p)-scale)/scale, 0.16)*scale,\n                    d,\n                    scale*0.5);\n        scale /= 2.;\n    }\n    return vec4(d, p);\n}\n\n//https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    #ifdef shadows\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n    #else\n    return .9;\n    #endif\n}\n#define ZERO min(iFrame, 0)\n//https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    #ifdef normals\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n    #else\n    return vec3(0);\n    #endif\n}\n\n//\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    #ifdef AO\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n    #else\n    return 1.;\n    #endif\n}\n\nvec3 intersection(vec3 ro, vec3 rd){\n    float dist;\n    for (int i = 0; i < maxSteps; i++){\n        dist = map(ro).x;\n        ro += dist*rd;\n        if (dist < 0.01)\n            break;\n    }\n    \n    return ro;\n\n}\n\nvec4 render(vec3 ro, vec3 rd){\n      vec3 p = intersection(ro,rd);\n vec4 d_pxyz = map(p);\n    vec3 trp = d_pxyz.yzw;\n  float trap = distance(p, trp);\n    \n    //Shading\n    vec3 sun = vec3(0., 1., .0);\n    float sha = softshadow(p, sun, 0.1, 5., shadowSoftness)*0.5+0.5;\n     vec3 nor = calcNormal(p);\n    float occ = calcAO(p, nor);\n     vec3 tex = texture(iChannel0, reflect(rd, nor)).xyz;\n    //float lig = (dot(sun,nor)*0.5+0.5);\n\n    //Colors\n    vec3 col = vec3(0);\n    vec3 bcl = vec3(sin(tan(trap*2.)), sin(trap), sin(tan(trap)));\n    vec3 scl = vec3(0.9, 0.4 ,.3);\n    vec3 amb = vec3(0.7, 0.8, 1.);\n    //\n \n    //Hit\n    col += 0.75*scl*bcl+(tex*sha*sha*sha*sha*sha);\n    col += 0.6*amb*occ;\n    //No hit\n    vec3 bgc = texture(iChannel0, rd).xyz;\n    //\n    #ifndef hmmm\n    col = mix(bgc, col,  min(1.,0.01/d_pxyz.x));\n    #else\n    col = mix(bgc, col,  min(1.,0.001/d_pxyz.x));\n    #endif\n    return vec4(col, 1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3   ro = vec3(0, 0, zoom);\n    mat3 xrot;\n    mat3 yrot;\n    if (iMouse.z > 0.){\n        yrot = roty(iMouse.x/iResolution.x*sensitivity);\n        xrot = rotx(-iMouse.y/iResolution.y*sensitivity);\n    } else {\n        yrot = roty(iTime*rotaionSpeed);\n        xrot = rotx(0.7);\n    }\n   ro*=xrot*yrot;\n\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n    \n    //tone mapping\n    tot = smoothstep(0.,1.6,tot);\n    \n    // Output to screen\n    fragColor = tot;\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2fDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 325, 325, 353], [354, 402, 447, 447, 547], [553, 553, 594, 594, 655], [664, 684, 704, 704, 831], [832, 832, 852, 852, 979], [980, 980, 1000, 1000, 1127], [1131, 1131, 1170, 1170, 1297], [1298, 1351, 1369, 1369, 1701], [1703, 1747, 1824, 1824, 2094], [2123, 2168, 2198, 2198, 2483], [2485, 2488, 2522, 2522, 2833], [2835, 2835, 2871, 2871, 3049], [3051, 3051, 3081, 3081, 3980], [3981, 3981, 4038, 4038, 4823]]}
{"id": "NslfD4", "name": "Mandelbrot Rainbow Cycling", "author": "jdowner", "description": "The mandelbrot set with color (hue) cycling", "tags": ["fractal", "mandelbrot", "rainbow"], "likes": 1, "viewed": 183, "published": 3, "date": "1646171484", "time_retrieved": "2024-07-30T17:00:39.954079", "image_code": "#define PI 3.141592653589793\n\nvec3 hsv2rgb(in vec3 hsv) {\n  float h = hsv.x;\n  float s = hsv.y;\n  float v = hsv.z;\n  vec3 k = vec3(1.0, 2.0/3.0, 1.0/3.0);\n  vec3 p = clamp(abs(6.0*fract(h - k) - 3.0) - 1.0, 0.0, 1.0);\n  return v * mix(k.xxx, p, s);\n}\n\nvec4 rainbowify(float value) {\n    const float hueSpeed = -75.0;\n    float hue = mod(value + iTime*hueSpeed, 360.0) / 360.0;\n    vec3 hsv = vec3(hue, 1.0, 1.0);\n    return vec4(hsv2rgb(hsv), 1.0);\n}\n\nint mandelbrot(in vec2 uv) {\n    vec2 st = vec2(0.0, 0.0);\n    const int maxIterations = 1000;\n    for (int i = 0; i < maxIterations - 1; i++) {\n        if (st.x*st.x + st.y*st.y > 4.0) {\n            return i;\n        }\n        st = vec2(st.x*st.x - st.y*st.y, 2.0*st.x*st.y) + uv;\n    }\n    return -1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 wh = iResolution.xy;\n    vec2 c = wh*0.5;\n\n    // const float zoomMax = 5.0;\n    \n    const float zoom = -0.4;\n    const vec2 offset = vec2(-1.0, 0.0);\n    \n    // const float zoom = 1.0;\n    // const vec2 offset = vec2(-1.0, 0.3);\n    \n    // const float zoom = 5.0;\n    // const vec2 offset = vec2(-0.725+0.0001, 0.29+0.00001);\n    \n    float scale = pow(10.0, zoom);\n    float ratio = min(wh.x, wh.y);\n    vec2 uv = (fragCoord - c)/(ratio*scale) + offset;\n    \n    int iterations = mandelbrot(uv);\n    if (iterations < 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    const float hueOffset = 120.0;\n    const float deltaHue = -8.0;\n    float hue = float(iterations)*deltaHue + hueOffset;\n    fragColor = rainbowify(hue);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 57, 57, 250], [252, 252, 282, 282, 450], [452, 452, 480, 480, 756], [758, 758, 813, 813, 1576]]}
{"id": "ss2BDh", "name": "deformed stripes", "author": "FabriceNeyret2", "description": "inspired by reference: https://www.instagram.com/p/CKk7Ui2II5L/\nAman Daharwal zebra.", "tags": ["short", "reproduction"], "likes": 28, "viewed": 508, "published": 3, "date": "1646169465", "time_retrieved": "2024-07-30T17:00:40.825749", "image_code": "#define S smoothstep\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n         \n    float t = -2.*iTime, l = length(U), \n          a = fract( (t-atan(U.y,U.x))/6.283+.42  ), b,\n          v = U.y                                           // background deformation\n              + .16 * S(.2, 0., abs(l-.6)-.02 ) \n                    * S( 0.,.9, a ) * S( 1.,.9, a );\n    v = sin(120.*v);\n    U += .6*vec2(cos(t),sin(t)); U /= .17;                  // ball\n    b = asin(U.y), a = acos( U.x/cos(b) );                  // sphere coordinates\n  //  if ( !isnan(a+b) ) \n    { \n        vec3 P = vec3(cos(b)*cos(a), cos(b)*sin(a), sin(b));\n        t = .2+.8*max(0.,dot(P,vec3(.58)));                 // ball shading (as is, could be alot simpler )\n     // t = sin(b*10.)*sin(a*40.-t); t /= (1e-5+fwidth(t)); // ball texture. ?rolling rotation\n    } \n    O = vec4( mix( .5+.5*v/fwidth(v),\n                 // min(1.,.5+.5*v/fwidth(v)) * (.5+.5*S(0.,.6,length(U)-.8)), // with shadow\n                   t, \n                   S(3./R.y/.17,0.,length(U)-1.)) ); // compose\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2BDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 60, 60, 1115]]}
{"id": "7d2BWh", "name": "fractal 284925780141204819", "author": "SnoopethDuckDuck", "description": "ill stop making fratals soon", "tags": ["fractal"], "likes": 9, "viewed": 253, "published": 3, "date": "1646165684", "time_retrieved": "2024-07-30T17:00:41.657525", "image_code": "#define pi 3.14159\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(vec2 id) {\n    int x = FK(id.x), y = FK(id.y);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat tlength(vec2 uv, float m) {\n    return mix(length(uv), mlength(uv), m);\n}\n\nvec2 mabs(vec2 x) {\n    return sqrt(x*x+0.0001)-0.005;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n   \n    // radius of inner circle (used for smaller circles too)\n    float r = 0.22 + 0.02 * thc(3., 0.5 * iTime);\n    // line thickness\n    float th = 0.005;\n    float d = 0.02 + tlength(uv, 0.5 + 0.5 * thc(4., 0.5 * iTime));\n    \n    float k = 1. / iResolution.y;    \n    float s = smoothstep(-k, k, -abs(d - r) + th);\n   \n    // y determines if pixel has already been visited\n    float y = 1.;\n    // m scales down radii etc in for loop\n    float m = 1.;\n    \n    vec2 id = vec2(1);\n    \n    vec3 col = vec3(0);\n    vec3 e = vec3(1);\n    \n    float n = 6.;\n    float h = 0.;\n    for (float i = 0.; i < n; i++) {\n        uv *= Rot(0.6 * h + 0.2 * iTime);\n        \n        // set y to 0 if inside previous circle\n        y *= step(m * r, d);\n        \n        id = 0.5 * id + step(uv, vec2(0));\n        \n        // dynamic random number for each id (\"cell\")\n        h = hash(id) - iTime;\n        float h1 = hash(floor(h) + 0.01 * id);\n        float h2 = hash(floor(h) + 1. + 0.01 * id);\n        h = mix(h1, h2, smoothstep(0., 1., fract(h)));\n        //h = smoothstep(-0.05, 0.05, -h + 0.5); // looks cool too\n        \n        uv = mabs(uv) - sqrt(2.) / 2.  * m * r;\n        d = tlength(uv, h);\n     \n        // -= looks cool too\n        s += y * smoothstep(-k, k, -abs(d - 0.5 * m * r) + (n-i)/n * th);\n      \n        col -= 0.08 * m * s;\n        col += 0.35 * m * y * (1.-s) * pal(0.1 * iTime + 0.25 * h, e, e, e, .5 * vec3(0,1,2)/3.);\n\n        m *= 0.55;\n    }\n    \n    col += 0.13;\n\n    float s1 = smoothstep(-k, k, -tlength(ouv, 0.5 + 0.5 * thc(4., 0.5 * iTime)) + 0.465);\n    float s2 = smoothstep(-k, k, -abs(abs(ouv.x + 0.04 * cos(iTime + 2. * ouv.y)) - 0.7) + 0.05);\n    col *= s1 + s2;\n    col = sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));//-smin(-abs(uv.x), -abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 105], [162, 162, 183, 183, 265], [267, 267, 300, 300, 346], [348, 348, 367, 367, 404], [406, 406, 463, 463, 2303]]}
{"id": "sd2fWh", "name": "Fork Fork xor m rast1234 174", "author": "rast1234", "description": "inspired by https://www.shadertoy.com/view/XlcyD8\nhash function used : https://www.shadertoy.com/view/XdGfRR", "tags": ["xor"], "likes": 1, "viewed": 233, "published": 3, "date": "1646158283", "time_retrieved": "2024-07-30T17:00:42.477333", "image_code": "\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n\nvoid mainImage( out vec4 frag_color, vec2 frag_coord )\n{  \n\t\n\n    frag_coord -= iResolution.xy/200.;\n    //frag_color -= frag_color;\n\tfrag_color = vec4(0,0,0,1.0); // keeps alpha\n    \n    for (float i=2.; i<40.; i+=2.) {\n        uvec2 p = uvec2( frag_coord * (i*.04+.96) + 10000.+ iMouse.xy * 10.); \n        uint temp = ( p.x + uint(100000.*i) ) \n        \t          ^  // try ^ & |\n        \t          p.y;\n  \n        frag_color += step(.98, hash11(temp)) * vec4(2.23/3.,1.16/3.,0.12/3.,1.) / i;\n    }\n\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2fWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 178, 178, 248], [251, 251, 307, 307, 757]]}
{"id": "fd2fW1", "name": "fractal 12389723592053", "author": "SnoopethDuckDuck", "description": "e", "tags": ["fractal"], "likes": 11, "viewed": 273, "published": 3, "date": "1646149774", "time_retrieved": "2024-07-30T17:00:43.229322", "image_code": "#define pi 3.14159\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n/*\n//#define tabs(x) 1.-min(vec2(0), abs(x - 0.1))\nvec2 tabs(vec2 uv) {\n    vec2 m = min(vec2(0), abs(uv) - 0.1);\n    return sqrt(uv * uv * (1. - m));\n}\n//#define tabs(x) sqrt(x * x * (1. - min(vec2(0), abs(x) - vec2(3)))\n//*/\n\nvec2 tabs(vec2 x, float m, float o) {\n    return abs(x) + m * thc(0.01, 2.5 * abs(x) + o);\n}\n\n\nfloat tlength(vec2 uv, float m) {\n    return mix(length(uv), mlength(uv), 0.5 + 0.5 * thc(4., m)); \n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    \n   // uv = floor(80. * uv) / 2000.;\n    \n    uv.y += 0.03 * cos(iTime);\n    \n    float r = 0.25;\n    float th = 0.01;\n    \n    uv *= 1.5;\n\n    float t = iTime;\n\n    float d = 1.;//tlength(uv, t);\n    float k = 1. / iResolution.y;\n    float s = step(abs(d - 2. * r), th);\n    \n    float m = 0.25;\n    float n = 7.;\n    float a = -0.2 * iTime;\n    for (float i = 0.; i < n; i++) {\n        float a2 = atan(uv.x, uv.y);\n        uv *= Rot(thc(4000., 3. * a2 + a) * length(uv) + a2 * 3. + a);\n        uv = abs(uv) - m;\n        \n        d = abs( length(uv) - mlength(uv)) - 0.25 * m;\n        if (d >= r + 0.* th) {\n            \n            //uv = abs(uv) - m;\n\n            //d = length(uv);\n            //s *= s;\n           // s -= 2./(n+1.);\n           // float k = 4. / iResolution.y;\n            s += step(s, 0.) * step(abs(d-r), th);\n          \n        } \n        \n        m *= 1.;\n        //r += 0.04;\n       // r *= 0.5;\n        r = m * d;//abs(r-d);\n    }\n    \n    vec3 col = vec3(s);\n    //col *= 2. * exp(-2.1 * pow(dot(ouv, ouv), 0.125));\n    vec3 e = vec3(1);\n    vec3 orange = pal(0.2 * iTime -ouv.y * 0.1 + length(uv) * 2.- 0.08, e, e, e, 0.8 * vec3(0,1,2)/3.);\n\n    col += 0.13;\n\n    float s1 = step(length(ouv), 0.45);\n    float s2 = step(length(abs(ouv) - vec2(1.5 * 0.44,0)), 0.1);\n    col *= s1 + s2;\n    col += step(abs(length(ouv) - 0.47), 1./400.);\n    col += step(abs(length(abs(ouv) - vec2(1.5 * 0.44,0)) - 0.12), 1./400.);\n    col *= orange;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 2.0\nvoid mainImage(out vec4 O,vec2 C){\n    float px=1./AA,i,j;vec4 cl2,cl;\n    if(AA==1.){render(cl,C);O=cl;return;}\n    for(i=0.;i<AA;i++){for(j=0.;j<AA;j++){\n    vec2 C2 = vec2(C.x+px*i,C.y+px*j);\n    render(cl2,C2);cl+=cl2;\n    //If the shader has global variables they need to be reset here\n    }}cl/=AA*AA;O=cl;\n}\n\n", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 105], [335, 335, 372, 372, 427], [430, 430, 463, 463, 531], [533, 533, 587, 587, 2191], [2208, 2208, 2242, 2242, 2522]]}
{"id": "fd2fD1", "name": "Fork xor madnes rast1234 523", "author": "rast1234", "description": "inspired by https://www.shadertoy.com/view/XlcyD8\nhash function used : https://www.shadertoy.com/view/XdGfRR", "tags": ["xor"], "likes": 5, "viewed": 283, "published": 3, "date": "1646148576", "time_retrieved": "2024-07-30T17:00:43.981311", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{  \n    U -= iResolution.xy/2.;\n    O -= O;\n    \n    for (float i=1.; i<3.; i++) {\n        uvec2 p = uvec2( U * (i*.04+.96) + iTime*111.+ iMouse.xy * 10.); \n        uint temp = ( p.x + uint(1000.*i) ) \n        \t          ^  // try ^ & |\n        \t          p.y;\n  \n        O += step(.98, hash11(temp)) * vec4(1,2,1,1) / i;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2fD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 177, 177, 247], [250, 250, 288, 288, 616]]}
{"id": "Ns2fW1", "name": "Experiment:  Deformed Light", "author": "iY0Yi", "description": "This is a silly experiment. I had been tired. I think about how looks if light direction is changed by hit position.\nIt looks ugly. I got tired more. So, I share it with everyone.", "tags": ["lighting"], "likes": 12, "viewed": 285, "published": 3, "date": "1646145985", "time_retrieved": "2024-07-30T17:00:44.913818", "image_code": "vec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float cL = 25.;\n    const vec3 forcus = vec3(0,-5,0);\n    const float fov = .25;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,1.5,0);\n    pos.xz = vec2(0)*cL;\n    pos.xz-=vec2(-iTime,iTime);\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n        \n    \n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// I forgot where I found these bx_cossin()...\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// More simpler usage scene of sdNumFont() is here:\n// https://www.shadertoy.com/view/Ntc3Wf\nfloat sdNumFont(vec3 p, float s, float w, float i) {\n    i = mod(floor(i), 10.); // 0-9\n    vec2 uv = p.xy/s +vec2(i, 12); // Numbers are in 12 row of Font texture.\n    \n    // https://www.shadertoy.com/view/llcXRl\n    // Sample the font texture. Make sure to not use mipmaps.\n    vec4 tx = texture(iChannel0, (uv+.5)*(1./16.));\n    float ch = tx.w - .5 - .025 * min(1.,(w/10.)*2.-1.);\n    \n    vec3 q = abs(p)-vec3(s,s*.8,.15*s)*.5;\n    float bb =  length(max(vec3(0.),q));\n    return max(ch, bb)*.7;\n}\n\nfloat sdID(vec3 p, float id) {\n    float num = id;\n    const float fontSize = .4;\n    const float fontWeight = 8.; // 1 to 10\n    const float spacing = .25;\n    float ppd = sdNumFont(p+vec3(3,0,0)*spacing*fontSize, fontSize, fontWeight, num*.01);\n    float pd = sdNumFont(p+vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num*.1);\n    float nd = sdNumFont(p-vec3(1,0,0)*spacing*fontSize, fontSize, fontWeight, num);\n    return min(ppd,min(pd,nd));\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    #if 1\n    float rad = .2;\n    #else // animate radius. they can't move at raius 1.0.\n    float rad = abs(sin(3.14+iTime*.1))*0.9+.1;\n    #endif\n    \n    vec3 q = p;\n    q.xz = mod(q.xz,1.);\n    \n    #if 1 // Spheres.\n        q.y-= rad;\n    #else // Shrink the height. You can see more clearly the range of movement of each sphere.\n        q.y-= rad*.1;\n        q.y*=4.;\n    #endif\n    \n    float speed = 2.;\n    vec3 pm=MAT_ERNST2;\n    for(int i=-1; i<1; i++)\n    for(int j=-1; j<1; j++)\n    {\n        vec2 offset = vec2(i,j);\n        vec3 qq = q;\n        vec2 iqq = floor((p.xz-offset));\n        vec2 rnd = hash22(iqq);\n        \n        qq.xz+=offset;\n        float v =  rnd.x * iTime * speed * sign(rnd.y-rnd.x); \n        vec2 sq = bx_cossin(v)*(1.-rad/* max range is ±(cellSize-Radius) */);\n        //qq.xz+= sq;\n        \n        //qq.y-=.25*abs(sin(rnd.x*3.+iTime*3.*4.)); // jumping. just for fun.\n        \n        #if 0 // reduce population\n        if(rnd.y<.1 || rnd.x<.1)\n        #endif\n        {\n            vec2 iq = abs(floor((p.xz-offset)));\n            iq = vec2(int(iq.x)%2, int(iq.y)%2);\n            float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .05 : .05;\n            vec3 m = (rnd.y<.5) ? (tile<.5)?MAT_ERNST0:MAT_ERNST3 : (tile<.5)?MAT_ERNST1:MAT_ERNST4;\n\n            res = v4OpUnionSmooth(vec4(length(qq)-rad, m), res, .01);\n            /*\n            if(sat(sin(iTime*.5))>0.){\n                //pm = mix(pm,m,.5);\n                res = v4OpUnion(vec4(sdCapsule(qq, vec3(0), vec3(sq.x, -rad, sq.y), .01), m), res);\n                res = v4OpUnion(vec4(length(q+vec3(i,rad,j))-.05, m), res);\n            }\n            //*/\n        }\n    }\n\n    vec2 iqq = floor(p.xz);\n    vec2 rnd = hash22(iqq);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.3,.5), iqq.x),vec3(0.996,0.224,0.224)), res);\n    res = v4OpUnion(vec4(sdID(q-vec3(.5,.0,.5), iqq.y),vec3(0.149,0.788,0.192)), res);\n\n    vec2 iq = abs(floor((p.xz)));\n    iq = vec2(int(iq.x)%2, int(iq.y)%2);\n    float tile = (iq.x==0. || iq.y==0.) ? (iq.x==1. || iq.y==1.) ? 1. : .85 : .85; \n    res = v4OpUnion(vec4(p.y, pm*tile),res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 getLightDir(vec3 p){\n    vec3 baseDir = vec3(0,1,0);\n    R(baseDir.xy, sin(p.x*PI*2.*cos(iTime*.25)+iTime*.5)*PI*.25);\n    R(baseDir.yz, cos(p.z*PI*2.*sin(iTime*.25)+iTime*.5)*PI*.25);\n    return normalize(baseDir);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n    vec3 ldir = getLightDir(o);\n\tfor( int i=0; i < 20; i++){\n\t\tfloat h = sdScene(o + ldir*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 8;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv;\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l;\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n\t\tfloat shininess = .5;\n\t\tfloat intensity = .05;\n        \n        vec3 ldir = getLightDir(p);\n\t\tfloat lamb1 = sat(dot(renDat.normal, ldir))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, ldir))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.001, renDat.normal);\n\n\t\t//renDat.ao = ambientOcclusion(p, renDat.normal, .1, 1.5);\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .5, 1.5);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 2., 4.);\n\t\t//renDat.ao += ambientOcclusion(p, renDat.normal, 4., 8.);\n\t\trenDat.ao = smoothstep(-0.3, 1.5, renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\t#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, ldir);\n\t\trenDat.specular = spec*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST*3.5;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.2;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.0875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result.rgb = sms(-.01,.9,renDat.result.rgb);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(1.000,0.980,0.400)\n#define MAT_ERNST1 vec3(1.000,0.424,0.361)\n#define MAT_ERNST2 vec3(0.631,0.525,0.408)\n#define MAT_ERNST3 vec3(0.322,0.773,1.000)\n#define MAT_ERNST4 vec3(0.345,0.976,0.502)\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2fW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 118], [119, 119, 141, 141, 820], [913, 960, 980, 980, 1028], [1029, 1029, 1053, 1053, 1083], [1085, 1085, 1137, 1137, 1258], [1260, 1353, 1405, 1405, 1856], [1858, 1858, 1888, 1888, 2311], [4541, 4541, 4558, 4558, 4847], [4849, 4849, 4874, 4874, 5071], [5073, 5073, 5094, 5220, 5431], [5433, 5433, 5462, 5462, 5771], [5773, 5921, 5952, 5952, 6055], [6056, 6056, 6100, 6100, 6196], [6197, 6197, 6280, 6280, 6678], [6680, 6752, 6766, 6766, 8506], [8508, 8611, 8623, 8623, 9162], [9164, 9236, 9290, 9290, 9727]]}
{"id": "fdBfD1", "name": "Aliens (Scanner scene)", "author": "dean_the_coder", "description": "Another Aliens-themed shader, motivated by me watching this clip from the movie: https://youtu.be/3HbkcRAQhew", "tags": ["3d", "raymarching", "glow", "alien", "laser", "movie", "glint", "frost", "cineshader"], "likes": 25, "viewed": 4467, "published": 3, "date": "1646138746", "time_retrieved": "2024-07-30T17:00:45.743600", "image_code": "// 'Aliens (Scanner scene)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/fdBfD1 (YouTube: https://youtu.be/yimsQfjK8es)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Another Aliens-themed shader, motivated by me watching\n// this clip from the movie: https://youtu.be/3HbkcRAQhew\n// I try to add add something new each time I make a shader,\n// and this time it was the 'frost' effect on the cryo pod.\n// Definitely an effect I want to come back to in the future!\n//\n// Tricks to get the performance:\n//   - No 'max dist' raymarch check needed, as the room is enclosed.\n//   - Reflective helmet glass and laser effect calculated using\n//     ray-sphere ray-plane intersections, allowing me to keep\n//     the raymarching loop simple.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t.0015\n#define MAX_STEPS\t120.0\n#define SHADOW_STEPS\t30.0\n\n#define LIGHT_RGB\tvec3(0.1, 0.6, 1.4)\n#define FOG_RGB\tvec3(0.03, 0.04, 0.05)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0.0, 1.0, a)\n\nfloat t,\n      g = 0.0;\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat a = 0.0,\n\t      b = 0.5, i;\n\tfor (i = Z0; i < 4.0; i++) {\n\t\ta += b * n31(p);\n\t\tb *= 0.5;\n\t\tp *= 2.0;\n\t}\n    \n\treturn a * 0.5;\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\nfloat max2(vec2 v) { return max(v.x, v.y); }\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nbool intPlane(vec3 p0, vec3 n, vec3 ro, vec3 rd, out float d) {\n\tfloat denom = dot(n, rd);\n\tif (abs(denom) > 0.0001) {\n\t\td = dot(p0 - ro, n) / denom;\n\t\treturn d >= 0.0;\n\t}\n\n\treturn false;\n}\n\nbool intSph(vec3 p0, float r, vec3 ro, vec3 rd, out float d) {\n\tvec3 oc = ro - p0;\n\tfloat a = dot(rd, rd),\n          b = dot(oc, rd),\n          c = dot(oc, oc) - r * r,\n          e = b * b - a * c;\n\tif (e <= 0.0) return false;\n    d = b > 0.0 ? (-b + sqrt(e)) / a : (-b - sqrt(e)) / a;\n    return true;\n}\n\nmat2 rot(float a) {\n\t// Thanks Fabrice.\n\treturn mat2(cos(a + vec4(0, 11, 33, 0)));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat hatch(vec3 p, float ex) {\n\tfloat d = box(p, vec3(2, 2.5, ex + .3));\n\tp.xy *= rot(3.1415 / 4.);\n\treturn max(d, box(p, vec2(2.7, 2.7 + ex).xxy));\n}\n\n#define LP\tvec3(0, -0.4, 3.5)\n\nvec3 rigP() {\n\tfloat tt = t;\n\tif (tt > 47.0) tt = 16.0 - tt + 47.0;\n\treturn vec3(0, 0.5, 6) +\n\t  S(vec3(0.5, 0.7, 1), vec3(0.0, 0.2, 0.3), vec3(S(1.0, 13.0, tt))) * vec3(-2.4, 1.6, 5);\n}\n\nfloat map(vec3 p) {\n\t// Walls.\n\tfloat d = abs(box(p, vec3(8, 4, 10)) - 0.5) - 0.5;\n\td = max(d, -hatch(p - vec3(0, 0, 8), 3.));\n\td = min(d, 20. - p.z);\n\n\t// Wall posts.\n\tvec3 tp = p;\n\ttp.x = abs(tp.x);\n\ttp.xz -= vec2(7, 9);\n\td = min(d, box(tp, vec3(1. + p.y * 0.15, 4, 0.5)));\n\td = min(d, abs(p.y) * -0.15 - tp.x);\n\n\t// Hatch.\n\ttp = p - vec3(0.8, -3.4, 7);\n\ttp.yz *= rot(1.4);\n\ttp.xy *= rot(0.2);\n\td = min(d, hatch(tp, 0.0));\n\n\t// Laser rig.\n\ttp = p - rigP();\n\td = min(d, cyl(tp, vec2(0.05, .1))); // Nozzle.\n\ttp.yz += vec2(0.15, -1.0);\n\td = min(d, box(tp, vec3(0.3, 0.3, 1))); // Barrel.\n\td = min(d, box(tp - vec3(0, 0.15, 0), vec3(0.25, 0.25, 0.9))); // Heat sinks.\n\ttp.y += 0.3;\n\td = min(d, max(box(tp, vec3(0.4, 0.45, 0.4)), -box(tp, vec3(0.3, 0.4, 0.5))));\n\ttp.xz += vec2(.5, 0.4);\n\td = min(d, cap(tp.yzx, 1.2, S(0.0, -0.1, tp.y - 0.8) * 0.04 + .02));\n\ttp -= vec3(0.0, -0.24, 2.4);\n\td = min(d, max(box(tp, vec3(0.2, 0.15, 2)), -tp.x - tp.z - 2.)); // Front support.\n\tvec3 mp = tp.zyx + vec3(1.5, 0, 0.22);\n\tmp.y = abs(mp.y) - 0.06;\n\td = min(d, cap(mp, 2., .1)); // Pipes.\n\ttp.z -= 4. - 1.8;\n\ttp.xz *= rot(1.);\n\ttp.z -= 1.8;\n\td = min(d, box(tp, vec3(0.2, 0.3, 2))); // Rear support.\n    \n\t// Panel-thing.\n\ttp = p + vec3(0, 3, 2.5);\n\ttp.xz = abs(tp.xz);\n\ttp.z -= 3.;\n\td = min(d, max(box(tp, vec3(3, 1.5, 1)), tp.x + tp.y * 0.5 - 3.2));\n\n\t// Lighty-boxes.\n\ttp -= vec3(1.5, 2, -.2);\n\td = min(d, box(tp, vec3(0.6)));\n\ttp.x = abs(abs(tp.x) - 0.12 - .12) - 0.12;\n\ttp.y = abs(tp.y) - 0.12;\n\tfloat f = box(tp - vec3(0, 0, 0.58), vec3(0.06));\n\tg += S(0.8, 0.96, p.z) * 0.003 / (0.003 + abs(f)) * S(0.8, 0., f);\n\td = min(d, f);\n\n\t// Helmet table.\n\ttp = p + vec3(0.5, 2, -2);\n\td = min(d, box(tp + vec3(0, 1.4, 0), vec3(1, 1, 0.5)));\n\n\t// Helmet.\n\tfloat l = length(tp);\n\tf = abs(l - 0.47) - 0.02;\n\tf -= step(abs(abs(tp.z) - .1), 0.05) * 0.006 + step(abs(tp.y), 0.08) * 0.01;\n\td = min(d, max(f, -box(tp + vec3(0.6, -0.3, 0), vec3(0.5))));\n\n\t// Pod.\n\ttp = p + vec3(4.2, 3.2, -1);\n\tl = S(2., 0.0, tp.z) * 0.5 + S(1.2, 2., tp.z) * 0.4;\n\tfloat b = box(tp, vec3(0.6, 0.6, 2));\n\tf = mix(cyl(tp + vec3(0, tp.z * 0.1, 0), vec2(0.7, 2)), b - 0.2, l);\n\treturn min(d, mix(b - 0.15, f, S(.6, .65, tp.y + 0.5)));\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * 0.4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat s = 1.,\n\t      t = .02, d,\n          mxt = length(p - lp);\n\tvec3 ld = normalize(lp - p);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = map(t * ld + p);\n\t\ts = min(s, 15. * d / t);\n\t\tt += d;\n\t\tif (mxt - t < 0.5 || s < 0.001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p) / h); }\n\nfloat fog(float d) { return exp(d * d * (t < 16. ? -0.01 : -0.02)); }\n\nfloat L_On() { return 0.01 + step(9.5, t) * step(t, 51.0); }\n\nfloat dtc(vec2 p) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.0;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.)\n\t\treturn 0.6;\n\n\tfloat dc = step(.5, -p.x), f;\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn step(0.1, dc);\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec3 ld = normalize(LP - p),\n\t     c = vec3(0.25, 0.05, 0.04);\n         \n    c += dtc((p.xy + vec2(4, -0.8)) * 0.5) * 0.04 * step(0.0, p.z);\n\n\t// Scanner.\n\tfloat s = step(5., p.z);\n\tc.rg += vec2(.5, .1) * step(max2(abs(p.xy)), 1.8 * s);\n\n\t// Helmet.\n\tfloat f = .12 * step(length(p - vec3(-0.5, -2, 2)), .502);\n\tc = mix(c, 1. / LIGHT_RGB, f);\n\tn.yz -= n31(p * 40.) * .12 * .3 * (1. - s);\n\n\t// Pod frost.\n\tif (p.x < -3.5 && abs(p.z) < 4. && s < 1.0) {\n\t\tvec3 pp = p * vec3(105, 86, 53);\n\t\tfloat glint = n21(pp.xz) * (0.5 + 0.5 * h21(pp.yx));\n\t\tc = mix(c, 1. / LIGHT_RGB, S(0.85, 1., glint) + 0.13);\n\t}\n\n\tfloat ao = mix(aof(p, n, .2), aof(p, n, 2.), .7),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (0.3 + 0.7 * shadow(p, LP)) * (0.3 + 0.7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.) * 2.,\n\t      fre = S(.7, 1., 1. + dot(rd, n)) * 0.2,\n          lig = l1 + l2 * ao;\n\treturn mix(lig * c * LIGHT_RGB, FOG_RGB, fre) * L_On();\n}\n\nvec3 beam(vec3 p, vec3 ro, vec3 rd, float d, float plane) {\n\tvec3 lp = rigP() - vec3(0, 0, 0.1),\n         pn = vec3(1, 0, 0);\n\tfloat r = 0.0;\n\tif (t < 35.0)\n        r = mix(-1.8, 0.6, sin(max(0.0, t - 16.) * 0.15) * 0.5 + 0.5);\n\telse if (t < 47.0) {\n\t\tr = mix(-0.5, 0.35, sin(max(0.0, t - 35.) * 0.3) * 0.5 + 0.5);\n\t\tlp.x -= 3.5;\n\t}\n\n\tpn.xz *= rot(r);\n\tfloat u;\n\tif (intPlane(lp, pn, ro, rd, u) && u < d) {\n\t\tvec3 op = p;\n\t\tp = ro + rd * u;\n\t\tfloat tt = step(t, 16.0) + step(47., t);\n\t\tif (abs(p.y - lp.y) * tt < lp.z - p.z) {\n\t\t\tvec3 q = p * vec3(0.2, 2.5, 2.5);\n\t\t\tq.yz = vec2(fbm(q), fbm(q + vec3(0.23, 1.23, 4.56)) + t * 0.04);\n\t\t\tfloat edge = S(0.02, 0.0, abs(length(p - op) - 0.01));\n\t\t\tedge += 0.5 * tt * max3(S(vec3(0.02), vec3(0), abs(p.y - 0.5 - sin(t + vec3(0, 3, 5)) * (lp.z - p.z))));\n\t\t\tfloat beam = 0.5 * min(edge, 1.0);\n\t\t\tbeam += fbm(p + q * 10.) * plane;\n\t\t\tbeam *= S(4.5, -3.0, op.y) * fog(u * 1.3);\n\t\t\treturn beam * shadow(p, lp) * vec3(0.3, 1.2, 2.4);\n\t\t}\n\t}\n\n\treturn vec3(0);\n}\n\nfloat addFade(float a) { return min(1.0, abs(t - a)); }\n\nvec3 scene(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tfloat d = 0.0, i, h;\n\tvec3 p = ro, col;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\t\tif (abs(h) < MIN_DIST) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\tcol = mix(FOG_RGB, g * vec3(0.76, 0.16, .08) + lights(p, rd, N(p, d)), fog(d));\n\n\t// Ground fog.\n\tcol = mix(FOG_RGB, col, S(-4., -3.5, p.y - abs(p.x * 0.1)));\n\tfloat ns = fbm(p + t * vec3(0.2, -0.4, 0.1)) * 5.;\n\tcol += mix(0.5, 1.0, L_On()) * FOG_RGB * ns * (0.1 + S(-2., -4., p.y + ns * 0.6 - 2. * step(6., p.z)));\n\n\t// LAZERS!\n\tif (L_On() > 0.1) {\n\t\tcol += beam(p, ro, rd, d, 0.25 + 0.75 * step(t, 16.));\n\n\t\t// Helmet glass.\n\t\tfloat u;\n\t\tif (intSph(vec3(-0.5, -2, 2), 0.45, ro, rd, u) && u < d) {\n\t\t\tp = ro + rd * u;\n\t\t\tvec3 n = normalize(p - vec3(-0.5, -2, 2));\n\t\t\tcol *= 0.6; // Darken a bit.\n            \n            // Add highlights.\n\t\t\tcol += pow(sat(dot(n, vec3(-0.1, 1, 0))), 10.0) * 0.1;\n\t\t\tcol += S(0.5, 1.0, 1. + dot(rd, n)) * 0.05;\n\t\t\tcol += pow(sat(dot(n, vec3(-1, 1, 1)) - 0.95), 15.0) * 5.;\n\t\t\tcol += beam(p, ro, rd, u, 0.1);\n\n\t\t\t// Reflect button lights.\n\t\t\tg *= 0.28;\n\t\t\th = map(p + n);\n\t\t\tcol += g * vec3(76, 16, 8);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tt = mod(iTime, 61.);\n\tfloat fade = addFade(0.0) * addFade(16.0) * addFade(35.0) * addFade(47.0) * addFade(61.0);\n\n    // Door/scanner entry.\n\tvec3 ro = vec3(-2, 0, 2),\n         lookAt = vec3(0, -0.9 * S(16.0, 0.0, t), 10);\n\tif (t < 47.0) {\n\t\tif (t > 35.0) {\n\t\t\t// Pod scan.\n\t\t\tro = vec3(-5, -2, 3);\n\t\t\tlookAt = vec3(2, -6, -5);\n\t\t}\n\t\telse if (t > 16.0) {\n\t\t\t// Helmet/room scan.\n\t\t\tro = vec3(-1.6, -1.4, 3) + S(16., 30., t) * vec3(-0.8, 0.2, 0.8);\n\t\t\tlookAt = vec3(4, -4, -10);\n\t\t}\n\t}\n\n    // Keep camera moving a tad.\n\tro.x += 0.1 * sin(t * 0.3);\n    \n\tvec3 col = scene(ro, rayDir(ro, lookAt, uv));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * fade, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBfD1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1420, 1420, 1440, 1440, 1539], [1541, 1541, 1560, 1560, 1581], [1583, 1583, 1602, 1659, 1944], [1946, 1946, 1965, 1965, 1991], [1993, 1993, 2012, 2012, 2147], [2149, 2149, 2169, 2169, 2193], [2194, 2194, 2214, 2214, 2238], [2239, 2239, 2259, 2259, 2293], [2295, 2295, 2358, 2358, 2484], [2486, 2486, 2548, 2548, 2790], [2792, 2792, 2811, 2831, 2876], [2878, 2878, 2905, 2905, 2976], [2978, 2978, 3006, 3006, 3081], [3083, 3083, 3120, 3120, 3172], [3174, 3174, 3218, 3218, 3354], [3356, 3356, 3387, 3387, 3507], [3540, 3540, 3553, 3553, 3726], [3728, 3728, 3747, 3758, 5919], [5921, 5921, 5946, 5946, 6164], [6166, 6166, 6197, 6197, 6461], [6463, 6491, 6527, 6527, 6561], [6563, 6563, 6583, 6583, 6632], [6634, 6634, 6648, 6648, 6694], [6696, 6696, 6715, 6715, 6996], [6998, 6998, 7036, 7036, 8021], [8023, 8023, 8082, 8082, 9022], [9024, 9024, 9048, 9048, 9079], [9081, 9081, 9111, 9132, 10245], [10247, 10247, 10292, 10292, 11088]]}
{"id": "ssSBW1", "name": "spqr: artifact highway 13", "author": "spqr", "description": "An HD animation/recording is available here:  https://youtu.be/G5rKjezo6dg\n\nMade use of Blackle's domain gating technique and fms_cat's ifs technique ", "tags": ["a"], "likes": 5, "viewed": 342, "published": 3, "date": "1646109542", "time_retrieved": "2024-07-30T17:00:46.717994", "image_code": "\n#define ANTIALIAS\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*30.0/60.0)\n\n//(time*160.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n \n  float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cyl (vec2 p, float r){\n    return length(p) - r;\n}\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n} \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\n\n/*\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n*/\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  return i + r;\n}\nfloat tock(float t){ \n    float n = atan(20.*sin(t)/atan(20.));\n    n = n*.5 + .5;\n    return n;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<8;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n/*\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n*/\nfloat runner (vec3 p) {\n    return box(p, vec3(.5));\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\nvec3 bezier( float t ){\n  float u = fract(t);\n  vec3 a = lattice(floor(t));\n  vec3 b = lattice(floor(t+1.));\n  vec3 c = lattice(floor(t+2.));\n  \n  vec3 ab = mix(a,b,u);\n  vec3 bc = mix(b,c,u);\n  \n  return mix(a,b,u);\n\n  \n}\n\nint matter = 0;\nfloat artifact(vec3 p) {\n\n  \n  \n \n\n  vec3 pt=p;\n \n\n  float width = 3.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n  pt=mod(pt,width)-halfwidth;\n  \n\n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(\n      pt,\n      vec3(3.6,3.0+0.4*phase,3.1),\n      vec3(3.0,2.3,3.5)\n  );\n  \n  pt=mod(pt-.5,1.)-.5;\n  \n  \n  vec3 seed = floor(p/width);\n  float uu = hash13(seed);\n  float dist;\n  \n  \n  dist=box(pt,vec3(.19));\n\n\n  dist=max(dist,clampBox);\n\n \n  return dist;\n  \n}\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//value noise hash\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lanesphere(vec3 p, float dim, float domain, float prob) {\n\n   \n    \n\n    float tt = iTime * .3;\n    vec3 q = p;\n    \n\n  \n\n    \n    vec3 id = floor((p*.1)/domain);\n     vec3 id2 = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    \n    float thresh = fbm(id);\n    \n    float rando = hash31(id2);\n\n\n   \n    vec3 flit = vec3(.04);\n    flit.xz *= rot(rando*5.1+tt*2.3);\n    flit.yz *= rot(rando*4.2+tt*1.4);\n    flit.xy *= rot(rando*3.3+tt*1.1);\n    \n    vec3 jitter = vec3(0);//flit * sin((tt*9.1+rando*12.1));\n  \n    \n    if (  rando * prob < thresh) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        //return length(p)-1.;\n        \n        //float u = box(p + jitter, vec3(.4));\n        float u = sph(p,dim);\n        return u;\n        \n    } else {\n        //return length(p)-1.;\n        //float u = box(p + jitter, vec3(.4));\n        float u = sph(p,dim);\n       \n        return u;\n    }\n \n}\n\n\nfloat lanebox(vec3 p, vec3 dim, float domain, float prob) {\n\n   \n   \n   \n    float tt = iTime * .3;\n    \n    vec3 id = floor((p)/domain);\n    p = mod(p,domain) - domain/2.;\n    float f1 = hash31(id);\n    \n    if (  f1 < prob) {\n\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= domain;\n        float u = box(p,dim);\n        return u;\n        \n    } else {\n        float u = box(p,dim);\n       \n        return u;\n    }\n \n}\n\nint material = 0;\n\n\nfloat highway(vec3 p){\n\n\n    float tt = iTime * 0.1;\n   \n   // vec3 ap = p  + tt * 145.1 * vec3(0,0,1);\n    vec3 ap = p  + lattice( tick(tt*5.) ) * 75.1 ;\n    vec3 bp = p  + tt * 0.0 * vec3(0,0,1);\n    vec3 cp = p  + tt * 0.0 * vec3(0,0,1);\n    vec3 dp = p  + tt * 3330.0 * vec3(0,0,1);\n    \n    \n    float u = 2.;\n    \n    float a = lanebox(ap, vec3(.7)*u*1.4,       5.4*u, .98);\n    float b = lanebox(bp, vec3(.3,.3,8.)*u, 7.1*u, 1.);\n    \n      float h1 = lanebox(p + vec3(1.4), vec3(2.513)*u, 5.1*u, .1);\n      float h2 = lanebox(p + vec3(1.4), vec3(3.513)*u, 7.1*u, .7);\n      float h3 = lanebox(p + vec3(11.4), vec3(51.513)*u, 152.1*u, .9);\n  \n      b = max(b,-h1);\n      b = max(b,-h2);\n      b = max(b,-h3);\n   \n    \n    float c = lanebox(cp, vec3(15,15,15.1)*u,        45.1*u, .5);\n    float d = lanebox(dp, vec3(.4,2.4,6.1)*u,        20.1*u, .8);\n   \n    \n \n    float final = min(min(a,b),min(c,d));//(a,min(b,c));\n    \n   \n    \n    if ( final == a) {\n        material = 1;\n    } \n    \n    if ( final == b) {\n        material = 2;\n    } \n    if (final == c) {\n        material = 3;\n    }\n    if (final == d) {\n        material = 4;\n    }\n    return final;\n   \n   \n   \n    // float a = lanebox(ap, vec3(.4)*u*1.4,       5.4*u, .4);\n   \n    //float a = lanesphere(ap, .4*u*1.4,       5.4*u, .4);\n    //float c = lanebox(cp, vec3(15,15,15.1)*u,        46.1*u, .8);\n    /*\n    //float final =  min(c,min(a,b));\n    \n    if ( final == a) {\n        material = 1;\n    }\n    if ( final == b) {\n        material = 2;\n    }\n    if ( final == c) {\n        material = 3;\n    }\n    return final;\n    */\n    \n}\n\nfloat tack (float t){\n    float i = floor(t);\n    float r = fract(t);\n    r = pow(r,.7);\n    return i + r;\n    \n\n}\nfloat beams(vec3 p) {\n   \n\n    \n    p.xz = mod(p.xz,160.)-80.;\n    float c = cyl(p.xz,.01+sin(iTime*121.1)*.01);\n  \n    return c;\n}\n\n\nfloat glow = 0.;\nfloat map(vec3 p){\n\n     // geo\n     \n   \n     \n    float art = artifact(p + lattice(tack(iTime/4.1)) * 33.);\n    float high = highway(p);\n    float both =  max(art,high);\n    \n    \n    float beam = beams(p);\n    glow += .15/pow(.02+abs(beam),1.5);\n    \n    // return both;\n    return min(both,beam);\n    \n    \n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\n\n\nfloat sinstep(float t){\n    return cos(t) + t;\n}\n\n\nfloat onoff ( float t) {\n\n    float z =  atan(10. * sin(t))/atan(10.);\n    z = z * .5 + .5;\n    return 1.-z;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  \n  //vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n  // nav\nvec3 s,t;\n\n // switch\n                        // floating\n float tt = iTime * .05;\nif ( mod(floor(iTime),14.) < 7.){\n\n\n  \n  s = lattice(tt)*15.1;\n  s.xz *= rot(tick(tt)*.413);\n  s.xy *= rot(tick(tt)*.111);\n\n  t = lattice(tt + 33.)*15.1;\n  t.xz *= rot(tick(-tt)*.31);\n  t.yz *= rot(tick(tt)*.21);\n  \n \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tt);\n  arm.yz *= rot(tt*.71);\n  arm.xy *= rot(tt*.51);\n  \n  s += arm * 1.;\n  t += arm * 1.;\n  \n  \n  s += tock(tt * 3.) * 100. * arm;\n  t += tock(tt * 3.) * 100. * arm;\n}\n\n                // hurtling forward\nelse {\n  s = vec3(0,0,-20);\n  t = vec3(0);\n  \n  s += flitfbm(tt*70.) * .5;\n  t += flitfbm(tt*70. + 8.) * .5;\n  \n  vec3 hurt = vec3(0,0,1);\n  //hurt.yz *= rot(iTime*.02);\n\n  \n  vec3 adv = hurt * 1379.1 * tt;\n  s+= adv;\n  t+= adv;\n\n\n\n\n}\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\n  vec3 cy=normalize(cross(cz,cx));\n \n     // fisheye\n  //cz -= dot(uv,uv)/15.;\n  float fov =  .8;// + sin(tock(tick(iTime)))/2.;\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*fov);\n \n \n\n  \n  vec3 p=s;\n  float d = 0.;\n  float dd = 0.;\n  float edge = 0.;\n  float i = 0.;\n  vec3 n1,n2;\n  \n  bool hit = false;\n  \n  \n  // march\n  \n  for(float nn=0.;nn<200.;nn++){ \n    i =nn;\n    d=map(p);\n    d = abs(d);\n   \n    \n    if ( d < .001 ) {\n      hit = true;\n      break;\n    }\n      \n     \n    if ( dd > 500.) {\n        break;\n    }\n    p += r * d;\n    dd += d;\n    \n  }\n \n \n\n   \n \n  vec3 col;\n  if ( material == 0){\n    col = vec3(1);\n  }\n  if (material == 1) {\n  \n    col = vec3(0);\n  }\n  if (material == 2) {\n    col = vec3(1.,.4,.2);\n  }\n  if (material == 3) {\n    col = vec3(.5);\n  }\n  if (material == 4) {\n    col = vec3(1.,.4,.2);\n  }\n\n  \n  float ao = pow(1. - i/100.,1.4);\n  \n  col *= ao;\n  col *= 1.9;\n  \n\n\n  \n\n  \n  if ( material == 1) {\n    n2=norm(p, vec2(0.0, 1.0E-2) );\n    n1=norm(p, vec2(0.0, 5.50E-2) );\n    edge=saturate(length(n1-n2)/0.1);\n    col += edge*100.;\n  }\n  else {\n    n2=norm(p, vec2(0.0, 1.0E-2) );\n    n1=norm(p, vec2(0.0, 2.50E-2) );\n    edge=saturate(length(n1-n2)/0.1);\n    col -= edge*100.;\n  }\n\n  //col += glow * 1.;\n  \n  if ( ! hit ) { \n      col = vec3(.7);\n      //col = mix(vec3(0), vec3(1.), pow(dot(r,normalize(vec3(1,0,0))*.5+.5),.8));\n \n  }\n  \n\n  \n  \n  fragColor = vec4(col, 1.0);\n\n}\n\n\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 245, 245, 348], [349, 349, 371, 371, 579], [581, 581, 635, 690, 914], [916, 916, 940, 940, 1137], [1141, 1141, 1170, 1170, 1235], [1236, 1236, 1278, 1278, 1385], [1386, 1386, 1414, 1414, 1442], [1443, 1443, 1466, 1466, 1574], [1576, 1576, 1600, 1600, 2147], [2149, 2149, 2171, 2171, 2379], [2381, 2381, 2406, 2406, 2439], [2441, 2441, 2463, 2463, 2581], [2586, 2586, 2615, 2615, 2644], [2645, 2645, 2666, 2666, 2713], [2714, 2714, 2733, 2733, 2802], [2805, 2805, 2830, 2830, 2870], [2875, 2875, 2889, 2889, 2929], [2932, 2932, 2968, 2968, 3021], [3045, 3045, 3069, 3069, 3124], [3127, 3127, 3151, 3151, 3237], [3238, 3238, 3265, 3265, 3362], [3365, 3447, 3469, 3469, 3558], [3559, 3559, 3579, 3579, 3657], [3659, 3659, 3698, 3698, 3775], [3778, 3778, 3808, 3808, 3834], [3837, 3837, 3875, 3875, 4163], [4166, 4166, 4189, 4189, 4302], [4303, 4303, 4324, 4324, 4723], [4725, 4725, 4747, 4747, 4952], [4954, 4954, 4981, 4981, 5007], [5009, 5009, 5037, 5037, 5068], [5069, 5291, 5314, 5314, 5345], [5347, 5347, 5375, 5375, 5408], [5412, 5412, 5433, 5433, 5482], [5483, 5483, 5503, 5503, 5552], [5553, 5553, 5573, 5573, 5952], [5953, 5953, 5978, 5978, 6447], [6450, 6450, 6470, 6470, 6654], [6656, 6656, 6679, 6679, 6881], [6883, 6883, 6906, 6906, 7105], [7123, 7123, 7147, 7147, 7699], [7740, 7759, 7782, 7782, 7897], [7899, 7899, 7962, 7962, 8915], [8918, 8918, 8977, 8977, 9433], [9455, 9455, 9477, 9477, 11061], [11063, 11063, 11084, 11084, 11177], [11178, 11178, 11199, 11199, 11309], [11329, 11329, 11347, 11360, 11641], [11643, 11643, 11690, 11690, 11903], [11907, 11907, 11933, 11933, 12058], [12061, 12061, 12081, 12081, 12200], [12208, 12208, 12231, 12231, 12256], [12259, 12259, 12283, 12283, 12370], [12371, 12371, 12428, 12492, 14911]]}
{"id": "7dSfDh", "name": "fraccy fractal", "author": "SnoopethDuckDuck", "description": "i struggle with backgrounds a bit. looks best in fullscreen + it almost looks handdrawn which is nice", "tags": ["fractal"], "likes": 10, "viewed": 256, "published": 3, "date": "1646098150", "time_retrieved": "2024-07-30T17:00:47.561738", "image_code": "#define pi 3.14159\n\nmat2 Rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n/*\n//#define tabs(x) 1.-min(vec2(0), abs(x - 0.1))\nvec2 tabs(vec2 uv) {\n    vec2 m = min(vec2(0), abs(uv) - 0.1);\n    return sqrt(uv * uv * (1. - m));\n}\n//#define tabs(x) sqrt(x * x * (1. - min(vec2(0), abs(x) - vec2(3)))\n//*/\n\nvec2 tabs(vec2 x, float m, float o) {\n    return abs(x) + m * thc(0.01, 2.5 * abs(x) + o);\n}\n\n//rename the original mainImage to render\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    \n    uv.y += 0.03 * cos(iTime);\n    \n    float r = 0.4;\n    float th = 0.01;\n    \n    uv *= 1.54;\n\n    float d = 1.;//length(uv);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -abs(d - r) + th);\n    \n    float m = 0.25;\n    float n = 8.;\n    float a = -0.2 * iTime;\n    for (float i = 0.; i < n; i++) {\n        if (d >= r + th) {\n            a += 0.2 * iTime;\n            uv *= Rot(2. * pi * i / n + a);\n            uv = tabs(uv, 0.5 * (1. + thc(4., 2. * pi * i / n + 0.5 * iTime)) * m, 2. * pi * i / n) - m;\n            d = length(uv);\n            s = smoothstep(-k, k, -abs(d - r) + th);\n            \n        } \n        \n        m *= 0.5;\n        r += 0.04;\n        r *= 0.5;\n    }\n    \n    vec3 col = vec3(s);\n    col *= 2. * exp(-2.1 * pow(dot(ouv, ouv), 0.125));\n    vec3 e = vec3(1);\n    vec3 orange = pal(-ouv.y * 0.1 + length(uv) * 0.4- 0.025, e, e, e, 0.8 * vec3(0,1,2)/3.);\n    col *= orange;\n    col += 0.13;\n    //if (col.x <= 0.15)\n     //   col += (0.56-exp(-3. * length(ouv))) * pal(0.0, e, e, e, 0.8 * vec3(0,1,2)/3.);\n    if (col.x <= 0.13) {\n        float val = 0.12 + 0.12 * thc(16.,51. * ouv.y + cos(4.* ouv.x + iTime));\n        //col += val;\n       // col *= 0.7 * orange;\n        //col = mix(vec3(0.13), col, smoothstep(0.4 - val, 0.6 + val, length(ouv)));\n    }\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 3.0\nvoid mainImage(out vec4 O,vec2 C){\n    float px=1./AA,i,j;vec4 cl2,cl;\n    if(AA==1.){render(cl,C);O=cl;return;}\n    for(i=0.;i<AA;i++){for(j=0.;j<AA;j++){\n    vec2 C2 = vec2(C.x+px*i,C.y+px*j);\n    render(cl2,C2);cl+=cl2;\n    //If the shader has global variables they need to be reset here\n    }}cl/=AA*AA;O=cl;\n}\n\n\n", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 105], [335, 335, 372, 372, 427], [429, 471, 525, 525, 1953], [1970, 1970, 2004, 2004, 2284]]}
